<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes" xml:space="preserve">
          <source>Type widening</source>
          <target state="translated">Ensanchamiento del tipo</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes" xml:space="preserve">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;globalThis&lt;/code&gt; para globalThis</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes" xml:space="preserve">
          <source>Type-checking speed-ups</source>
          <target state="translated">Aceleración de la revisión del tipo de letra</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes" xml:space="preserve">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes" xml:space="preserve">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target state="translated">TypeScript 1.5 añade soporte a las declaraciones y asignaciones de desestructuración de ES6.</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target state="translated">TypeScript 1.5 añade soporte a ES6 para...de bucles en matrices para ES3/ES5 así como soporte completo para interfaces Iterator al apuntar a ES6.</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target state="translated">TypeScript 1.5 admite m&amp;oacute;dulos ECMAScript 6 (ES6). Los m&amp;oacute;dulos ES6 son efectivamente m&amp;oacute;dulos externos TypeScript con una nueva sintaxis: los m&amp;oacute;dulos ES6 son archivos fuente cargados por separado que posiblemente importan otros m&amp;oacute;dulos y proporcionan una serie de exportaciones accesibles desde el exterior. Los m&amp;oacute;dulos ES6 incluyen varias declaraciones de importaci&amp;oacute;n y exportaci&amp;oacute;n nuevas. Se recomienda que las bibliotecas y aplicaciones de TypeScript se actualicen para usar la nueva sintaxis, pero esto no es un requisito. La nueva sintaxis del m&amp;oacute;dulo ES6 coexiste con las construcciones de m&amp;oacute;dulos internos y externos originales de TypeScript y las construcciones se pueden mezclar y combinar a voluntad.</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6 agrega una nueva forma de limitar un tipo de variable dentro de un bloque &lt;code&gt;if&lt;/code&gt; , adem&amp;aacute;s de &lt;code&gt;typeof&lt;/code&gt; y &lt;code&gt;instanceof&lt;/code&gt; . Una funci&amp;oacute;n de protecci&amp;oacute;n de tipo definida por el usuario es una con una anotaci&amp;oacute;n de tipo de retorno de la forma &lt;code&gt;x is T&lt;/code&gt; , donde &lt;code&gt;x&lt;/code&gt; es un par&amp;aacute;metro declarado en la firma y &lt;code&gt;T&lt;/code&gt; es cualquier tipo. Cuando una funci&amp;oacute;n de tipo protector definido por el usuario se invoca en una variable en una &lt;code&gt;if&lt;/code&gt; bloque, el tipo de la variable se redujo a &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target state="translated">TypeScript 1.6 agrega soporte para palabras clave &lt;code&gt;abstract&lt;/code&gt; as para clases y sus m&amp;eacute;todos. Una clase abstracta puede tener m&amp;eacute;todos sin implementaci&amp;oacute;n y no se puede construir.</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target state="translated">TypeScript 1.6 añade soporte para expresiones de clase ES6.En una expresión de clase,el nombre de la clase es opcional y,si se especifica,sólo tiene alcance en la propia expresión de clase.Esto es similar al nombre opcional de una expresión de función.No es posible referirse al tipo de instancia de clase de una expresión de clase fuera de la expresión de clase,pero el tipo puede,por supuesto,ser emparejado estructuralmente.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target state="translated">TypeScript 1.6 añade soporte para clases que extienden la expresión arbitraria que calcula una función constructora.Esto significa que los tipos incorporados pueden ahora extenderse en las declaraciones de clase.</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target state="translated">TypeScript 1.6 añade soporte para generadores cuando se apunta a ES6.</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target state="translated">TypeScript 1.6 impone comprobaciones de asignaci&amp;oacute;n literal de objetos m&amp;aacute;s estrictas con el fin de detectar propiedades en exceso o mal escritas. Espec&amp;iacute;ficamente, cuando se asigna un literal de objeto nuevo a una variable o se pasa como argumento para un tipo de destino no vac&amp;iacute;o, es un error que el literal de objeto especifique propiedades que no existen en el tipo de destino.</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target state="translated">TypeScript 1.6 introduce una nueva extensi&amp;oacute;n de archivo &lt;code&gt;.tsx&lt;/code&gt; . Esta extensi&amp;oacute;n hace dos cosas: habilita JSX dentro de los archivos de TypeScript y hace que el operador new &lt;code&gt;as&lt;/code&gt; sea la forma predeterminada de transmitir (eliminando cualquier ambig&amp;uuml;edad entre las expresiones JSX y el operador de conversi&amp;oacute;n de prefijo de TypeScript). Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target state="translated">TypeScript 1.6 introduce soporte experimental de funciones &lt;code&gt;async&lt;/code&gt; cuando se dirige a ES6. Se espera que las funciones as&amp;iacute;ncronas invoquen una operaci&amp;oacute;n as&amp;iacute;ncrona y esperen su resultado sin bloquear la ejecuci&amp;oacute;n normal del programa. Esto se logr&amp;oacute; mediante el uso de una implementaci&amp;oacute;n de &lt;code&gt;Promise&lt;/code&gt; compatible con ES6 y la transposici&amp;oacute;n del cuerpo de la funci&amp;oacute;n a una forma compatible para reanudar la ejecuci&amp;oacute;n cuando se complete la operaci&amp;oacute;n asincr&amp;oacute;nica esperada.</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6 presenta los tipos de intersecci&amp;oacute;n, el complemento l&amp;oacute;gico de los tipos de uni&amp;oacute;n. Una uni&amp;oacute;n tipo &lt;code&gt;A | B&lt;/code&gt; representa una entidad que es ya sea de tipo &lt;code&gt;A&lt;/code&gt; o tipo &lt;code&gt;B&lt;/code&gt; , mientras que un tipo de intersecci&amp;oacute;n &lt;code&gt;A &amp;amp; B&lt;/code&gt; representa una entidad que es tanto de tipo &lt;code&gt;A&lt;/code&gt; &lt;em&gt;y&lt;/em&gt; tipo &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target state="translated">TypeScript 1.7 agrega &lt;code&gt;ES6&lt;/code&gt; a la lista de opciones disponibles para la &lt;code&gt;--module&lt;/code&gt; y le permite especificar la salida del m&amp;oacute;dulo al apuntar a &lt;code&gt;ES6&lt;/code&gt; . Esto proporciona m&amp;aacute;s flexibilidad para apuntar exactamente a las funciones que desea en tiempos de ejecuci&amp;oacute;n espec&amp;iacute;ficos.</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target state="translated">TypeScript 1.7 hace que la comprobación de los patrones de desestructuración con un objeto literal o una matriz de inicializadores literales sea menos rígida y más intuitiva.</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 supports upcoming &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.7 es compatible con los pr&amp;oacute;ximos &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;operadores de exponenciaci&amp;oacute;n ES7 / ES2016&lt;/a&gt; : &lt;code&gt;**&lt;/code&gt; y &lt;code&gt;**=&lt;/code&gt; . Los operadores se transformar&amp;aacute;n en la salida a ES3 / ES5 usando &lt;code&gt;Math.pow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target state="translated">TypeScript 1.8 permite archivos &lt;code&gt;tsconfig.json&lt;/code&gt; en todos los tipos de proyectos. Esto incluye proyectos ASP.NET v4, &lt;em&gt;aplicaci&amp;oacute;n de consola&lt;/em&gt; y la &lt;em&gt;aplicaci&amp;oacute;n Html con&lt;/em&gt; tipos de proyectos &lt;em&gt;TypeScript&lt;/em&gt; . Adem&amp;aacute;s, ya no est&amp;aacute; limitado a un solo archivo &lt;code&gt;tsconfig.json&lt;/code&gt; , sino que puede agregar varios, y cada uno se crear&amp;aacute; como parte del proyecto. Esto le permite separar la configuraci&amp;oacute;n para diferentes partes de su aplicaci&amp;oacute;n sin tener que usar varios proyectos diferentes.</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target state="translated">TypeScript 1.8 permite a los usuarios usar el argumento &lt;code&gt;--outFile&lt;/code&gt; con entidades especiales del sistema de archivos como tuber&amp;iacute;as con nombre, dispositivos, etc.</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 extends &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target state="translated">TypeScript 1.8 extiende &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;las funciones de protecci&amp;oacute;n de tipos definidas por el usuario&lt;/a&gt; a m&amp;eacute;todos de clase e interfaz.</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.8 mejora la inferencia de tipos que involucran lados de origen y destino que son tipos de uni&amp;oacute;n o intersecci&amp;oacute;n. Por ejemplo, al inferir de la &lt;code&gt;string | string[]&lt;/code&gt; a &lt;code&gt;string | T&lt;/code&gt; , que reducen los tipos de &lt;code&gt;string[]&lt;/code&gt; y &lt;code&gt;T&lt;/code&gt; , por lo tanto inferir &lt;code&gt;string[]&lt;/code&gt; para &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target state="translated">TypeScript 1.8 introduce el análisis de flujo de control para ayudar a detectar errores comunes con los que los usuarios tienden a tropezar.Sigue leyendo para obtener más detalles,y comprueba estos errores en acción:</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0</source>
          <target state="translated">TypeScript 2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target state="translated">TypeScript 2.0 agrega una nueva opci&amp;oacute;n de compilador &lt;code&gt;--skipLibCheck&lt;/code&gt; que hace que se omita la verificaci&amp;oacute;n de tipos de archivos de declaraci&amp;oacute;n (archivos con extensi&amp;oacute;n &lt;code&gt;.d.ts&lt;/code&gt; ). Cuando un programa incluye archivos de declaraci&amp;oacute;n de gran tama&amp;ntilde;o, el compilador pasa mucho tiempo verificando declaraciones que ya se sabe que no contienen errores, y los tiempos de compilaci&amp;oacute;n pueden reducirse significativamente al omitir las verificaciones del tipo de archivo de declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.0 tiene dos nuevos indicadores para ayudarlo a mantener una base de c&amp;oacute;digo limpia. &lt;code&gt;--noUnusedParameters&lt;/code&gt; marca cualquier funci&amp;oacute;n no utilizada o errores de par&amp;aacute;metros de m&amp;eacute;todo. &lt;code&gt;--noUnusedLocals&lt;/code&gt; marca cualquier declaraci&amp;oacute;n local no utilizada (no exportada) como variables, funciones, clases, importaciones, etc. Adem&amp;aacute;s, los miembros privados no utilizados de una clase se marcar&amp;iacute;an como errores en &lt;code&gt;--noUnusedLocals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target state="translated">TypeScript 2.0 implementa un an&amp;aacute;lisis de tipo basado en flujo de control para variables y par&amp;aacute;metros locales. Anteriormente, el an&amp;aacute;lisis de tipos realizado para guardias de tipos se limitaba a declaraciones &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;?:&lt;/code&gt; Expresiones condicionales y no inclu&amp;iacute;a efectos de asignaciones y construcciones de flujo de control como declaraciones de &lt;code&gt;return&lt;/code&gt; y &lt;code&gt;break&lt;/code&gt; . Con TypeScript 2.0, el verificador de tipos analiza todos los posibles flujos de control en declaraciones y expresiones para producir el tipo m&amp;aacute;s espec&amp;iacute;fico posible (el &lt;em&gt;tipo restringido&lt;/em&gt; ) en cualquier ubicaci&amp;oacute;n dada para una variable local o par&amp;aacute;metro que se declara que tiene un tipo de uni&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">TypeScript 2.0 implementa soporte para tipos de uni&amp;oacute;n etiquetados (o discriminados). Espec&amp;iacute;ficamente, el compilador TS ahora admite protecciones de tipos que reducen los tipos de uni&amp;oacute;n basados ​​en pruebas de una propiedad discriminante y, adem&amp;aacute;s, ampl&amp;iacute;an esa capacidad para &lt;code&gt;switch&lt;/code&gt; declaraciones.</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target state="translated">TypeScript 2.0 introduce un nuevo tipo primitivo &lt;code&gt;never&lt;/code&gt; . El tipo &lt;code&gt;never&lt;/code&gt; representa el tipo de valores que nunca ocurren. Espec&amp;iacute;ficamente, &lt;code&gt;never&lt;/code&gt; es el tipo de retorno para funciones que nunca regresan y &lt;code&gt;never&lt;/code&gt; es el tipo de variables bajo protecciones de tipo que nunca son verdaderas.</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target state="translated">TypeScript 2.0 proporciona un conjunto de botones de resoluci&amp;oacute;n de m&amp;oacute;dulo adicionales para &lt;em&gt;informar&lt;/em&gt; al compilador d&amp;oacute;nde encontrar declaraciones para un m&amp;oacute;dulo determinado.</target>
        </trans-unit>
        <trans-unit id="3f3705d152a2f1f40c51f05e54dd28f6cc6cc047" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have &lt;em&gt;identical&lt;/em&gt; types.</source>
          <target state="translated">TypeScript 2.0 relaja esta restricci&amp;oacute;n y permite identificadores duplicados en bloques, siempre que tengan tipos &lt;em&gt;id&amp;eacute;nticos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1a29a22cd01cb9654bf025f544accb002ba6f777" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 supports the use of the wildcard character (&lt;code&gt;*&lt;/code&gt;) to declare a &amp;ldquo;family&amp;rdquo; of module names; this way, a declaration is only required once for an extension, and not for every resource.</source>
          <target state="translated">TypeScript 2.0 admite el uso del car&amp;aacute;cter comod&amp;iacute;n ( &lt;code&gt;*&lt;/code&gt; ) para declarar una &quot;familia&quot; de nombres de m&amp;oacute;dulo; de esta forma, solo se requiere una declaraci&amp;oacute;n una vez para una extensi&amp;oacute;n y no para cada recurso.</target>
        </trans-unit>
        <trans-unit id="e87039bc208381c858aaf91b34ef9a99581764c4" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1</source>
          <target state="translated">TypeScript 2.1</target>
        </trans-unit>
        <trans-unit id="0eb31cb3569ffcba88f7cd6f2aa1426af6d2ca9f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.</source>
          <target state="translated">TypeScript 2.1 permite incluir estos archivos en su proyecto una vez en un módulo separado,y el compilador emitirá importaciones a ellos según sea necesario.</target>
        </trans-unit>
        <trans-unit id="4d20c0e4270450dc5df5d6df69b86f9a3084c753" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 brings support for &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.1 ofrece soporte para &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a2602f6bc15b060152681aebb2deae22d1b7344" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports inheriting configuration using &lt;code&gt;extends&lt;/code&gt;, where:</source>
          <target state="translated">TypeScript 2.1 admite la configuraci&amp;oacute;n heredada mediante &lt;code&gt;extends&lt;/code&gt; , donde:</target>
        </trans-unit>
        <trans-unit id="e46023b88cb014edcb72d5fe91dd5e9bb7df4962" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports three new target values &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.1 admite tres nuevos valores objetivo : &lt;code&gt;--target ES2016&lt;/code&gt; , &lt;code&gt;--target ES2017&lt;/code&gt; y &lt;code&gt;--target ESNext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b933ffe70d107fc6bfc7a208af67d2175dec62d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2</source>
          <target state="translated">TypeScript 2.2</target>
        </trans-unit>
        <trans-unit id="af11383d0a489a01508b14d16cfebecdac9851f5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;MDN Mixin description&lt;/a&gt; and &lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;&amp;ldquo;Real&amp;rdquo; Mixins with JavaScript Classes&lt;/a&gt; for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.</source>
          <target state="translated">TypeScript 2.2 agrega soporte para el patr&amp;oacute;n de clase mixin ECMAScript 2015 (consulte la &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;descripci&amp;oacute;n de MDN Mixin&lt;/a&gt; y &lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;Mixins &amp;ldquo;reales&amp;rdquo; con clases JavaScript&lt;/a&gt; para obtener m&amp;aacute;s detalles), as&amp;iacute; como reglas para combinar firmas de construcci&amp;oacute;n mixin con firmas de construcci&amp;oacute;n regulares en tipos de intersecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0a2dbbdfdaba8d57c906119c6fac6d8266bfac36" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for using spread on a JSX element children. Please see &lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook/jsx#57&lt;/a&gt; for more details.</source>
          <target state="translated">TypeScript 2.2 agrega soporte para usar spread en un elemento JSX secundario. Consulte &lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook / jsx # 57&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4c48aa745cc516094ac80f0eaa3816fe06bddfbf" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:</source>
          <target state="translated">TypeScript 2.2 mejora la comprobación de operandos anulables en las expresiones.Específicamente,ahora se marcan como errores:</target>
        </trans-unit>
        <trans-unit id="d38d07af3e985997222428fd513a69781f6cc8f7" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3</source>
          <target state="translated">TypeScript 2.3</target>
        </trans-unit>
        <trans-unit id="b61f4d2dcbfa7df846edf73961314986771cb44f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with &lt;code&gt;--downlevelIteration&lt;/code&gt; flag.</source>
          <target state="translated">TypeScript 2.3 agrega soporte completo para generadores y el protocolo Iterator para objetivos ES3 y ES5 con el indicador &lt;code&gt;--downlevelIteration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7db822200563cfa58805541c7f52f40509bd7eb" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for declaring defaults for generic type parameters.</source>
          <target state="translated">TypeScript 2.3 añade soporte para declarar los valores por defecto de los parámetros de tipo genérico.</target>
        </trans-unit>
        <trans-unit id="576c3abf51df0a1e8501d6946731fd5b93e9a596" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for the async iterators and generators as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.3 agrega soporte para los iteradores y generadores as&amp;iacute;ncronos como se describe en la &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;propuesta&lt;/a&gt; actual de TC39 .</target>
        </trans-unit>
        <trans-unit id="f9905a786ea9066024ac4028d0fd104e321fa970" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 and later support type-checking and reporting errors in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.3 y versiones posteriores admiten la verificaci&amp;oacute;n de tipos y los errores de informes en archivos &lt;code&gt;.js&lt;/code&gt; con &lt;code&gt;--checkJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a711e374d74b34d98e80b0011ffc309914ec3f56" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4</source>
          <target state="translated">TypeScript 2.4</target>
        </trans-unit>
        <trans-unit id="63121e1a86e22e0c3bb62dbea7a515bd9e567278" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.</source>
          <target state="translated">TypeScript 2.4 introduce algunos cambios maravillosos en la forma en que los genéricos son inferidos.</target>
        </trans-unit>
        <trans-unit id="4047de971a7748310180f70bca2f83ce413444e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces the concept of &amp;ldquo;weak types&amp;rdquo;. Any type that contains nothing but a set of all-optional properties is considered to be &lt;em&gt;weak&lt;/em&gt;. For example, this &lt;code&gt;Options&lt;/code&gt; type is a weak type:</source>
          <target state="translated">TypeScript 2.4 introduce el concepto de &quot;tipos d&amp;eacute;biles&quot;. Cualquier tipo que no contenga nada m&amp;aacute;s que un conjunto de propiedades opcionales se considera &lt;em&gt;d&amp;eacute;bil&lt;/em&gt; . Por ejemplo, este tipo de &lt;code&gt;Options&lt;/code&gt; es un tipo d&amp;eacute;bil:</target>
        </trans-unit>
        <trans-unit id="86b2369322c0e2cb12bd30f7af1523fb15f271df" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:</source>
          <target state="translated">TypeScript 2.4 introduce un ajuste cuando se relacionan dos tipos de llamadas de retorno.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="76b70868a8ecce2623fa642627ea2865c40679ae" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 now allows enum members to contain string initializers.</source>
          <target state="translated">TypeScript 2.4 ahora permite que los miembros de enum contengan inicializadores de cadenas.</target>
        </trans-unit>
        <trans-unit id="c757b8632386bce7302d5253a3fe5a403ad48f5b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5</source>
          <target state="translated">TypeScript 2.5</target>
        </trans-unit>
        <trans-unit id="96d62a44f6ecea4f2d8ccb3d978b4697f85a8fe0" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 brings the &lt;code&gt;preserveSymlinks&lt;/code&gt; flag, which parallels the behavior of &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the &lt;code&gt;--preserve-symlinks&lt;/code&gt; flag in Node.js&lt;/a&gt;. This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, and vice-versa).</source>
          <target state="translated">Mecanografiado 2.5 ocasiona &lt;code&gt;preserveSymlinks&lt;/code&gt; bandera, que es paralelo al comportamiento de &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;la &lt;code&gt;--preserve-symlinks&lt;/code&gt; bandera en Node.js&lt;/a&gt; . Esta bandera tambi&amp;eacute;n exhibe el comportamiento opuesto a la opci&amp;oacute;n resolve.symlinks de &lt;code&gt;resolve.symlinks&lt;/code&gt; (es decir, establecer &lt;code&gt;preserveSymlinks&lt;/code&gt; de TypeScript en paralelos &lt;code&gt;true&lt;/code&gt; establecer resolve.symlinks de &lt;code&gt;resolve.symlinks&lt;/code&gt; en &lt;code&gt;false&lt;/code&gt; , y viceversa).</target>
        </trans-unit>
        <trans-unit id="c8ad58c085604fcd7c2e1f3468a3e3e991a926ce" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 introduces the ability to &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;assert the type of expressions when using plain JavaScript in your projects&lt;/a&gt;. The syntax is an &lt;code&gt;/** @type {...} */&lt;/code&gt; annotation comment followed by a parenthesized expression whose type needs to be re-evaluated. For example:</source>
          <target state="translated">TypeScript 2.5 introduce la capacidad de &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;afirmar el tipo de expresiones cuando se usa JavaScript simple en sus proyectos&lt;/a&gt; . La sintaxis es un &lt;code&gt;/** @type {...} */&lt;/code&gt; comentario de anotaci&amp;oacute;n seguido de una expresi&amp;oacute;n entre par&amp;eacute;ntesis cuyo tipo necesita ser reevaluado. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="669d038e7cc1925c80d686495e192a922f14d7e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6</source>
          <target state="translated">TypeScript 2.6</target>
        </trans-unit>
        <trans-unit id="f05ad28a2eccdd4292c999695e9643dff88f04a9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 adds revised implementation the &lt;code&gt;--noUnusedLocals&lt;/code&gt; and &lt;code&gt;--noUnusedParameters&lt;/code&gt;&lt;a href=&quot;../compiler-options&quot;&gt;compiler options&lt;/a&gt;. Declarations are only written to but never read from are now flagged as unused.</source>
          <target state="translated">TypeScript 2.6 agrega la implementaci&amp;oacute;n revisada de las &lt;a href=&quot;../compiler-options&quot;&gt;opciones del compilador &lt;/a&gt; &lt;code&gt;--noUnusedLocals&lt;/code&gt; y &lt;code&gt;--noUnusedParameters&lt;/code&gt; . Las declaraciones solo se escriben pero nunca se leen desde ahora se marcan como no utilizadas.</target>
        </trans-unit>
        <trans-unit id="b3d5a37c18c460f27ef01973c59f69c2b7e4b6db" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 also improves type inference involving contravariant positions:</source>
          <target state="translated">TypeScript 2.6 también mejora la inferencia de tipos que implican posiciones contrarias:</target>
        </trans-unit>
        <trans-unit id="597afbba7d51bc72adeb8bdd4361ee8ee1244087" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 brings a faster &lt;code&gt;--watch&lt;/code&gt; implementation. The new version optimizes code generation and checking for code bases using ES modules. Changes detected in a module file will result in &lt;em&gt;only&lt;/em&gt; regenerating the changed module, and files that depend on it, instead of the whole project. Projects with large number of files should reap the most benefit from this change.</source>
          <target state="translated">TypeScript 2.6 trae una implementaci&amp;oacute;n de &lt;code&gt;--watch&lt;/code&gt; m&amp;aacute;s r&amp;aacute;pida . La nueva versi&amp;oacute;n optimiza la generaci&amp;oacute;n de c&amp;oacute;digo y la verificaci&amp;oacute;n de bases de c&amp;oacute;digo utilizando m&amp;oacute;dulos ES. Los cambios detectados en un archivo de m&amp;oacute;dulo dar&amp;aacute;n como resultado que &lt;em&gt;solo se&lt;/em&gt; regenere el m&amp;oacute;dulo modificado y los archivos que dependen de &amp;eacute;l, en lugar de todo el proyecto. Los proyectos con una gran cantidad de archivos deber&amp;iacute;an obtener los mayores beneficios de este cambio.</target>
        </trans-unit>
        <trans-unit id="bff2120308b7a70612c6347b0884825c125b9bb6" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec. As per the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;ECMAScript spec&lt;/a&gt;, every time a template tag is evaluated, the &lt;em&gt;same&lt;/em&gt; template strings object (the same &lt;code&gt;TemplateStringsArray&lt;/code&gt;) should be passed as the first argument. Before TypeScript 2.6, the generated output was a completely new template object each time. Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. &lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-html&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.6 corrige la emisi&amp;oacute;n de la plantilla de cadena etiquetada para que se alinee mejor con la especificaci&amp;oacute;n ECMAScript. Seg&amp;uacute;n la &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;especificaci&amp;oacute;n ECMAScript&lt;/a&gt; , cada vez que se eval&amp;uacute;a una etiqueta de plantilla, se debe pasar el &lt;em&gt;mismo&lt;/em&gt; objeto de cadenas de plantilla (el mismo &lt;code&gt;TemplateStringsArray&lt;/code&gt; ) como primer argumento. Antes de TypeScript 2.6, la salida generada era un objeto de plantilla completamente nuevo cada vez. Aunque el contenido de la cadena es el mismo, esta emisi&amp;oacute;n afecta a las bibliotecas que usan la identidad de la cadena para prop&amp;oacute;sitos de invalidaci&amp;oacute;n de cach&amp;eacute;, por ejemplo, &lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3332e1f0228da76e93e5e699b31c42f80f487ec2" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 introduces a new strict checking flag, &lt;code&gt;--strictFunctionTypes&lt;/code&gt;. The &lt;code&gt;--strictFunctionTypes&lt;/code&gt; switch is part of the &lt;code&gt;--strict&lt;/code&gt; family of switches, meaning that it defaults to on in &lt;code&gt;--strict&lt;/code&gt; mode. You can opt-out by setting &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; on your command line or in your tsconfig.json.</source>
          <target state="translated">TypeScript 2.6 introduce una nueva &lt;code&gt;--strictFunctionTypes&lt;/code&gt; verificaci&amp;oacute;n estricta, --strictFunctionTypes . El &lt;code&gt;--strictFunctionTypes&lt;/code&gt; es parte de la familia de modificadores &lt;code&gt;--strict&lt;/code&gt; , lo que significa que est&amp;aacute; &lt;code&gt;--strict&lt;/code&gt; forma predeterminada en el modo --strict . Puede optar por no participar estableciendo &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; en su l&amp;iacute;nea de comando o en su tsconfig.json.</target>
        </trans-unit>
        <trans-unit id="50b83579cf141ddf3a24a6600e359e207807258a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages. The localized messages are available when using &lt;code&gt;--locale&lt;/code&gt; flag on the command line.</source>
          <target state="translated">El paquete TypeScript 2.6 npm se env&amp;iacute;a con versiones localizadas de mensajes de diagn&amp;oacute;stico para 13 idiomas. Los mensajes localizados est&amp;aacute;n disponibles cuando se usa el indicador &lt;code&gt;--locale&lt;/code&gt; en la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="71107e6f11d3d9498db10524c3f3c164f19e9415" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 support suppressing errors in .js files using &lt;code&gt;// @ts-ignore&lt;/code&gt; comments placed above the offending lines.</source>
          <target state="translated">TypeScript 2.6 admite la supresi&amp;oacute;n de errores en archivos .js mediante &lt;code&gt;// @ts-ignore&lt;/code&gt; comentarios colocados sobre las l&amp;iacute;neas ofensivas.</target>
        </trans-unit>
        <trans-unit id="bef45e6468d0c0a17f09c30d2b82dd8a05124a51" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7</source>
          <target state="translated">TypeScript 2.7</target>
        </trans-unit>
        <trans-unit id="79e7e447b60909166288dcf8cb72e27e89f7cec5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.</source>
          <target state="translated">TypeScript 2.7 agrega soporte para declarar propiedades de nombre const en tipos que incluyen símbolos de ECMAScript.</target>
        </trans-unit>
        <trans-unit id="a51783c99c59b3257833940324affc2689b71a24" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 also introduced &lt;code&gt;--watch&lt;/code&gt; mode builds via a new incremental &amp;ldquo;builder&amp;rdquo; API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing &lt;em&gt;intra&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 2.7 tambi&amp;eacute;n se introdujo &lt;code&gt;--watch&lt;/code&gt; modo de observaci&amp;oacute;n se compila a trav&amp;eacute;s de una nueva API de &quot;constructor&quot; incremental. De manera similar, la idea completa es que este modo solo vuelve a verificar y vuelve a emitir archivos modificados o archivos cuyas dependencias podr&amp;iacute;an afectar la verificaci&amp;oacute;n de tipos. Puede pensar en esto como una optimizaci&amp;oacute;n de &lt;em&gt;las&lt;/em&gt; compilaciones dentro del proyecto.</target>
        </trans-unit>
        <trans-unit id="162b6515dd83712cce22c0f4cc8d254c9b33661b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 brings support for &lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;ES Numeric Separators&lt;/a&gt;. Numeric literals can now be separated into segments using &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.7 ofrece soporte para &lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;separadores num&amp;eacute;ricos ES&lt;/a&gt; . Los literales num&amp;eacute;ricos ahora se pueden separar en segmentos usando &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af59c15c50945a988e8dab909a898e4259657c00" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves the handling of structurally identical classes in union types and &lt;code&gt;instanceof&lt;/code&gt; expressions:</source>
          <target state="translated">TypeScript 2.7 mejora el manejo de clases estructuralmente id&amp;eacute;nticas en tipos de uni&amp;oacute;n e &lt;code&gt;instanceof&lt;/code&gt; expresiones:</target>
        </trans-unit>
        <trans-unit id="91f038aff687710c549846983751034fac966226" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now &lt;em&gt;normalize&lt;/em&gt; the object literal types such that all properties are present in each constituent of the union type.</source>
          <target state="translated">TypeScript 2.7 mejora la inferencia de tipos para m&amp;uacute;ltiples objetos literales que ocurren en el mismo contexto. Cuando varios tipos de objetos literales contribuyen a un tipo de uni&amp;oacute;n, ahora &lt;em&gt;normalizamos&lt;/em&gt; los tipos de objetos literales de manera que todas las propiedades est&amp;eacute;n presentes en cada constituyente del tipo de uni&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6ab94d5588595f01a47bea04f5db381bcbb5dba9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 introduces a new flag called &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;. This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example</source>
          <target state="translated">TypeScript 2.7 introduce una nueva &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; llamada --strictPropertyInitialization . Este indicador realiza comprobaciones para garantizar que cada propiedad de instancia de una clase se inicialice en el cuerpo del constructor o mediante un inicializador de propiedad. Por ejemplo</target>
        </trans-unit>
        <trans-unit id="50a1f4f6bc66299bafe27e7f60a3413972205937" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an &lt;code&gt;__esModule&lt;/code&gt; indicator under &lt;code&gt;--esModuleInterop&lt;/code&gt;. The change brings the generated output from TypeScript closer to that generated by Babel.</source>
          <target state="translated">Mecanografiado 2,7 actualizaciones CommonJS / AMD / UMD m&amp;oacute;dulo Emit para sintetizar espacio de nombres registros basados en la presencia de un &lt;code&gt;__esModule&lt;/code&gt; indicador bajo &lt;code&gt;--esModuleInterop&lt;/code&gt; . El cambio acerca la salida generada de TypeScript a la generada por Babel.</target>
        </trans-unit>
        <trans-unit id="4e42d10f15cd2510b82037d64e9dbecd5c11e732" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8</source>
          <target state="translated">TypeScript 2.8</target>
        </trans-unit>
        <trans-unit id="3b84208a266962375c246ada5aa0bd123c9cfe9e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds several predefined conditional types to &lt;code&gt;lib.d.ts&lt;/code&gt;:</source>
          <target state="translated">TypeScript 2.8 agrega varios tipos condicionales predefinidos a &lt;code&gt;lib.d.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5e0ed8e368b2f12d192ed317481ad4102d428b8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for a per-file configurable JSX factory name using &lt;code&gt;@jsx dom&lt;/code&gt; pragma. JSX factory can be configured for a compilation using &lt;code&gt;--jsxFactory&lt;/code&gt; (default is &lt;code&gt;React.createElement&lt;/code&gt;). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.</source>
          <target state="translated">TypeScript 2.8 agrega soporte para un nombre de f&amp;aacute;brica JSX configurable por archivo usando &lt;code&gt;@jsx dom&lt;/code&gt; pragma. JSX factory se puede configurar para una compilaci&amp;oacute;n usando &lt;code&gt;--jsxFactory&lt;/code&gt; (el valor predeterminado es &lt;code&gt;React.createElement&lt;/code&gt; ). Con TypeScript 2.8 puede anular esto por archivo agregando un comentario al principio del archivo.</target>
        </trans-unit>
        <trans-unit id="4f6ad1955b40525b81ee6b350e3efda1dca7803e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for understanding more namespace patterns in &lt;code&gt;.js&lt;/code&gt; files. Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.</source>
          <target state="translated">TypeScript 2.8 agrega soporte para comprender m&amp;aacute;s patrones de espacio de nombres en archivos &lt;code&gt;.js&lt;/code&gt; . Las declaraciones de objetos literales vac&amp;iacute;os en el nivel superior, al igual que las funciones y clases, ahora se reconocen como declaraciones de espacio de nombres en JavaScript.</target>
        </trans-unit>
        <trans-unit id="f9e15ad123318d14a1567d61a8eb9b88ec3f14c9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; property modifier in a mapped type can now be prefixed with either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; to indicate that the modifier should be added or removed.</source>
          <target state="translated">TypeScript 2.8 agrega la capacidad de un tipo asignado para agregar o eliminar un modificador en particular. Espec&amp;iacute;ficamente, un &lt;code&gt;readonly&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; El modificador de propiedad en un tipo mapeado ahora puede tener el prefijo &lt;code&gt;+&lt;/code&gt; o &lt;code&gt;-&lt;/code&gt; para indicar que el modificador debe agregarse o eliminarse.</target>
        </trans-unit>
        <trans-unit id="ccbc7d666b3ba41052f2f21dcaf1e812e9bac36a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 introduces &lt;em&gt;conditional types&lt;/em&gt; which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target state="translated">TypeScript 2.8 introduce &lt;em&gt;tipos condicionales&lt;/em&gt; que agregan la capacidad de expresar asignaciones de tipos no uniformes. Un tipo condicional selecciona uno de dos tipos posibles en funci&amp;oacute;n de una condici&amp;oacute;n expresada como una prueba de relaci&amp;oacute;n de tipos:</target>
        </trans-unit>
        <trans-unit id="38d22337c31f40538f05a1b3be32d35d5d040ad3" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9</source>
          <target state="translated">TypeScript 2.9</target>
        </trans-unit>
        <trans-unit id="79a8a3cdfaf2e7ea5b694163b786814a57e8ccbe" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 adds support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties in index types and mapped types. Previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties.</source>
          <target state="translated">TypeScript 2.9 agrega soporte para propiedades con nombres de &lt;code&gt;number&lt;/code&gt; y &lt;code&gt;symbol&lt;/code&gt; en tipos de &amp;iacute;ndice y tipos mapeados. Anteriormente, el operador &lt;code&gt;keyof&lt;/code&gt; y los tipos asignados solo admit&amp;iacute;an propiedades con nombre de &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3af31e687b53bc6028a7656648578f8526d1535" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 allows passing generic type arguments to tagged template strings.</source>
          <target state="translated">TypeScript 2.9 permite pasar argumentos de tipo genérico a cadenas de plantillas etiquetadas.</target>
        </trans-unit>
        <trans-unit id="c576ebab33996a3a7642529b1b3cf098557fad0c" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 and earlier didn&amp;rsquo;t leverage &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt;React &lt;code&gt;defaultProps&lt;/code&gt;&lt;/a&gt; declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of &lt;code&gt;render&lt;/code&gt;, or they&amp;rsquo;d use type-assertions to fix up the type of the component before exporting it.</source>
          <target state="translated">TypeScript 2.9 y &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt; &lt;code&gt;defaultProps&lt;/code&gt; &lt;/a&gt; anteriores no aprovecharon las declaraciones de React defaultProps dentro de los componentes JSX. Los usuarios a menudo tendr&amp;iacute;an que declarar propiedades opcionales y usar aserciones no nulas dentro del &lt;code&gt;render&lt;/code&gt; , o usar&amp;iacute;an aserciones de tipo para corregir el tipo de componente antes de exportarlo.</target>
        </trans-unit>
        <trans-unit id="54d0224b3f561c10aa0b8f9cc4af3cf6fc0acd70" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 introduces support for &lt;code&gt;import.meta&lt;/code&gt;, a new meta-property as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.9 introduce soporte para &lt;code&gt;import.meta&lt;/code&gt; , una nueva metapropiedad como se describe en la &lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;propuesta&lt;/a&gt; actual de TC39 .</target>
        </trans-unit>
        <trans-unit id="ff47669d6e3d77ab534a2150af62bcea4228ce7e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0</source>
          <target state="translated">TypeScript 3.0</target>
        </trans-unit>
        <trans-unit id="1b5495b8f8bb8ada5fe9aabb083f17ca19955412" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support for a new type alias in the &lt;code&gt;JSX&lt;/code&gt; namespace called &lt;code&gt;LibraryManagedAttributes&lt;/code&gt;. This helper type defines a transformation on the component&amp;rsquo;s &lt;code&gt;Props&lt;/code&gt; type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.</source>
          <target state="translated">TypeScript 3.0 agrega soporte para un nuevo alias de tipo en el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; llamado &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; . Este tipo de ayuda define una transformaci&amp;oacute;n en el tipo de &lt;code&gt;Props&lt;/code&gt; del componente , antes de usarlo para verificar una expresi&amp;oacute;n JSX dirigida a &amp;eacute;l; permitiendo as&amp;iacute; la personalizaci&amp;oacute;n como: c&amp;oacute;mo se manejan los conflictos entre los accesorios proporcionados y los accesorios inferidos, c&amp;oacute;mo se mapean las inferencias, c&amp;oacute;mo se maneja la opcionalidad y c&amp;oacute;mo se deben combinar las inferencias de diferentes lugares.</target>
        </trans-unit>
        <trans-unit id="898331749799c0ae0af6a27a2c4a2bf1b9107b53" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:</source>
          <target state="translated">TypeScript 3.0 añade soporte a múltiples nuevas capacidades para interactuar con las listas de parámetros de función como tipos tuple.TypeScript 3.0 añade soporte para:</target>
        </trans-unit>
        <trans-unit id="24d0fe89da15fd3c400693e525d5250f550dd57a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 also introduces a new mode for tsc, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand-in-hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">TypeScript 3.0 tambi&amp;eacute;n introduce un nuevo modo para tsc, la &lt;code&gt;--build&lt;/code&gt; , que funciona de la mano con las referencias del proyecto para permitir compilaciones de TypeScript m&amp;aacute;s r&amp;aacute;pidas.</target>
        </trans-unit>
        <trans-unit id="76ebacc06303039a717759a1bc81f839c55d819c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced a new feature for structuring builds called &amp;ldquo;composite projects&amp;rdquo;. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use &lt;code&gt;--build&lt;/code&gt; mode to recompile only the set of projects and dependencies. You can think of this as optimizing &lt;em&gt;inter&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 3.0 introdujo una nueva caracter&amp;iacute;stica para estructurar compilaciones llamada &quot;proyectos compuestos&quot;. Parte del objetivo aqu&amp;iacute; era garantizar que los usuarios pudieran dividir proyectos grandes en partes m&amp;aacute;s peque&amp;ntilde;as que se construyen r&amp;aacute;pidamente y preservan la estructura del proyecto, sin comprometer la experiencia existente de TypeScript. Gracias a los proyectos compuestos, TypeScript puede usar el modo &lt;code&gt;--build&lt;/code&gt; para recompilar solo el conjunto de proyectos y dependencias. Se puede pensar en esto como la optimizaci&amp;oacute;n de &lt;em&gt;entre&lt;/em&gt; construye -project.</target>
        </trans-unit>
        <trans-unit id="12be550f3be8a1f6da19a996860414de543a9312" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced support for referencing other and building them incrementally using the &lt;code&gt;--build&lt;/code&gt; flag. Additionally, TypeScript 3.4 introduced the &lt;code&gt;--incremental&lt;/code&gt; flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn&amp;rsquo;t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.</source>
          <target state="translated">TypeScript 3.0 introdujo soporte para hacer referencia a otros y construirlos de forma incremental usando la &lt;code&gt;--build&lt;/code&gt; . Adem&amp;aacute;s, TypeScript 3.4 introdujo la &lt;code&gt;--incremental&lt;/code&gt; para guardar informaci&amp;oacute;n sobre compilaciones anteriores para reconstruir solo ciertos archivos. Estas banderas fueron incre&amp;iacute;blemente &amp;uacute;tiles para estructurar proyectos de manera m&amp;aacute;s flexible y acelerar las construcciones. Desafortunadamente, el uso de estos indicadores no funcion&amp;oacute; con herramientas de construcci&amp;oacute;n de terceros como Gulp y Webpack. TypeScript 3.6 ahora expone dos conjuntos de API para operar en referencias de proyectos y creaci&amp;oacute;n de programas incrementales.</target>
        </trans-unit>
        <trans-unit id="ef2e2b53b736d1c6d2b067c0b85011c12a528c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing &lt;code&gt;tsconfig.json&lt;/code&gt; files to reference other &lt;code&gt;tsconfig.json&lt;/code&gt; files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.</source>
          <target state="translated">TypeScript 3.0 introduce un nuevo concepto de referencias de proyectos. Las referencias de proyecto permiten que los proyectos de TypeScript dependan de otros proyectos de TypeScript, espec&amp;iacute;ficamente, permitiendo que los archivos &lt;code&gt;tsconfig.json&lt;/code&gt; hagan referencia a otros archivos &lt;code&gt;tsconfig.json&lt;/code&gt; . Especificar estas dependencias facilita la divisi&amp;oacute;n de su c&amp;oacute;digo en proyectos m&amp;aacute;s peque&amp;ntilde;os, ya que le brinda a TypeScript (y las herramientas que lo rodean) una forma de comprender el orden de compilaci&amp;oacute;n y la estructura de salida.</target>
        </trans-unit>
        <trans-unit id="303ce39af16c9af3efeedd99c02704afd6f021df" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new top type &lt;code&gt;unknown&lt;/code&gt;. &lt;code&gt;unknown&lt;/code&gt; is the type-safe counterpart of &lt;code&gt;any&lt;/code&gt;. Anything is assignable to &lt;code&gt;unknown&lt;/code&gt;, but &lt;code&gt;unknown&lt;/code&gt; isn&amp;rsquo;t assignable to anything but itself and &lt;code&gt;any&lt;/code&gt; without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an &lt;code&gt;unknown&lt;/code&gt; without first asserting or narrowing to a more specific type.</source>
          <target state="translated">TypeScript 3.0 introduce un nuevo tipo superior &lt;code&gt;unknown&lt;/code&gt; . &lt;code&gt;unknown&lt;/code&gt; es la contraparte con seguridad de tipos de &lt;code&gt;any&lt;/code&gt; . Cualquier cosa es asignable a &lt;code&gt;unknown&lt;/code&gt; , pero &lt;code&gt;unknown&lt;/code&gt; no se puede ceder a otra cosa que a s&amp;iacute; mismo y &lt;code&gt;any&lt;/code&gt; sin una aseveraci&amp;oacute;n tipo o un estrechamiento basado en el flujo de control. Del mismo modo, no se permiten operaciones en un &lt;code&gt;unknown&lt;/code&gt; sin primero afirmar o limitar a un tipo m&amp;aacute;s espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="7978444d69de42e59647fdd6e697c61c835aefcc" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1</source>
          <target state="translated">TypeScript 3.1</target>
        </trans-unit>
        <trans-unit id="277efbe36e840571109f3bbb5578c95d9d3c2d0f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1 brings the ability to define properties on function declarations and &lt;code&gt;const&lt;/code&gt;-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to &lt;code&gt;namespace&lt;/code&gt; hacks. For example:</source>
          <target state="translated">TypeScript 3.1 brinda la capacidad de definir propiedades en declaraciones de funciones y funciones declaradas &lt;code&gt;const&lt;/code&gt; , simplemente asignando propiedades en estas funciones en el mismo &amp;aacute;mbito. Esto nos permite escribir c&amp;oacute;digo JavaScript can&amp;oacute;nico sin recurrir a hacks de &lt;code&gt;namespace&lt;/code&gt; de nombres . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b9f00fd1052d436127e4de48e371112ca1399051" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2</source>
          <target state="translated">TypeScript 3.2</target>
        </trans-unit>
        <trans-unit id="1bd9c97a859cbb3246a80b48f6fdb33c3666de34" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Exclude&lt;/code&gt; helper types from &lt;code&gt;lib.d.ts&lt;/code&gt;, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.</source>
          <target state="translated">TypeScript 3.2 tambi&amp;eacute;n permite desestructurar un enlace de descanso a partir de una variable gen&amp;eacute;rica. Esto se logra usando los tipos de ayuda &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Exclude&lt;/code&gt; predefinidos de &lt;code&gt;lib.d.ts&lt;/code&gt; , y usando el tipo gen&amp;eacute;rico en cuesti&amp;oacute;n, as&amp;iacute; como los nombres de las otras vinculaciones en el patr&amp;oacute;n de desestructuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="32739636ab98224be8b965eab8472c294e08c8bd" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 introduces a new &lt;code&gt;--strictBindCallApply&lt;/code&gt; compiler option (in the &lt;code&gt;--strict&lt;/code&gt; family of options) with which the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on function objects are strongly typed and strictly checked.</source>
          <target state="translated">Mecanografiado 3.2 introduce un nuevo &lt;code&gt;--strictBindCallApply&lt;/code&gt; opci&amp;oacute;n del compilador (en el &lt;code&gt;--strict&lt;/code&gt; familia de opciones) con el que la &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; , y &lt;code&gt;apply&lt;/code&gt; m&amp;eacute;todos en los objetos de funci&amp;oacute;n son de tipo firme y estrictamente controlados.</target>
        </trans-unit>
        <trans-unit id="b0c6e2bed7992d15f04fd899cadd250b20a960e6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain &lt;em&gt;some&lt;/em&gt; singleton type (e.g. a string literal, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;), and they contain no generics.</source>
          <target state="translated">TypeScript 3.2 facilita la reducci&amp;oacute;n al relajar las reglas para lo que considera una propiedad discriminante. Las propiedades comunes de las uniones ahora se consideran discriminantes siempre que contengan &lt;em&gt;alg&amp;uacute;n&lt;/em&gt; tipo de singleton (por ejemplo, una cadena literal, &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; ) y no contengan gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="7a26700dbb32ecd2b75ac980f07316d21f373a07" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 now resolves &lt;code&gt;tsconfig.json&lt;/code&gt;s from &lt;code&gt;node_modules&lt;/code&gt;. When using a bare path for the &lt;code&gt;&quot;extends&quot;&lt;/code&gt; field in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript will dive into &lt;code&gt;node_modules&lt;/code&gt; packages for us.</source>
          <target state="translated">TypeScript 3.2 ahora resuelve &lt;code&gt;tsconfig.json&lt;/code&gt; s de &lt;code&gt;node_modules&lt;/code&gt; . Al usar una ruta &lt;code&gt;tsconfig.json&lt;/code&gt; para el campo &lt;code&gt;&quot;extends&quot;&lt;/code&gt; en tsconfig.json , TypeScript se sumergir&amp;aacute; en los paquetes &lt;code&gt;node_modules&lt;/code&gt; por nosotros.</target>
        </trans-unit>
        <trans-unit id="cfd2b961db2e8cd46070f763e5c724b34d770631" translate="yes" xml:space="preserve">
          <source>TypeScript 3.3</source>
          <target state="translated">TypeScript 3.3</target>
        </trans-unit>
        <trans-unit id="151f809570316cd705748f077714354101e09c3c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4</source>
          <target state="translated">TypeScript 3.4</target>
        </trans-unit>
        <trans-unit id="289b2ef5b5dba27b6f9d27a73f1f934655330ac2" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 also introduces new support for &lt;code&gt;readonly&lt;/code&gt; tuples. We can prefix any tuple type with the &lt;code&gt;readonly&lt;/code&gt; keyword to make it a &lt;code&gt;readonly&lt;/code&gt; tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, &lt;code&gt;readonly&lt;/code&gt; tuples only permit reading from those positions.</source>
          <target state="translated">TypeScript 3.4 tambi&amp;eacute;n presenta un nuevo soporte para tuplas de &lt;code&gt;readonly&lt;/code&gt; . Podemos prefijar cualquier tipo de tupla con la palabra clave &lt;code&gt;readonly&lt;/code&gt; para convertirla en una tupla de &lt;code&gt;readonly&lt;/code&gt; , al igual que ahora podemos hacerlo con la sintaxis abreviada de matriz. Como era de esperar, a diferencia de las tuplas ordinarias en cuyas ranuras se podr&amp;iacute;a escribir, las tuplas de solo &lt;code&gt;readonly&lt;/code&gt; solo permiten la lectura desde esas posiciones.</target>
        </trans-unit>
        <trans-unit id="d5ae4e4e2dd524eb742ca067c90d1124fa510b9b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.</source>
          <target state="translated">TypeScript 3.4 puede ahora producir tipos de funciones genéricas cuando la inferencia de otras funciones genéricas produce variables de tipo libre para las inferencias.Esto significa que muchos patrones de composición de funciones ahora funcionan mejor en 3.4.</target>
        </trans-unit>
        <trans-unit id="bf09bd81476b0409b652aa37d69d0d04e6689320" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new construct for literal values called &lt;em&gt;&lt;code&gt;const&lt;/code&gt;&lt;/em&gt; assertions. Its syntax is a type assertion with &lt;code&gt;const&lt;/code&gt; in place of the type name (e.g. &lt;code&gt;123 as const&lt;/code&gt;). When we construct new literal expressions with &lt;code&gt;const&lt;/code&gt; assertions, we can signal to the language that</source>
          <target state="translated">TypeScript 3.4 introduce una nueva construcci&amp;oacute;n para valores literales denominada aserciones &lt;em&gt; &lt;code&gt;const&lt;/code&gt; &lt;/em&gt; . Su sintaxis es una aserci&amp;oacute;n de tipo con &lt;code&gt;const&lt;/code&gt; en lugar del nombre del tipo (por ejemplo, &lt;code&gt;123 as const&lt;/code&gt; ). Cuando construimos nuevas expresiones literales con aserciones &lt;code&gt;const&lt;/code&gt; antes , podemos indicarle al lenguaje que</target>
        </trans-unit>
        <trans-unit id="1d6b24572a67a82fae359fdfff1468ec35fb0de9" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new flag called &lt;code&gt;--incremental&lt;/code&gt; which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with &lt;code&gt;--incremental&lt;/code&gt;, it will use that information to detect the least costly way to type-check and emit changes to your project.</source>
          <target state="translated">TypeScript 3.4 introduce una nueva &lt;code&gt;--incremental&lt;/code&gt; llamada --incremental que le dice a TypeScript que guarde informaci&amp;oacute;n sobre el gr&amp;aacute;fico del proyecto de la &amp;uacute;ltima compilaci&amp;oacute;n. La pr&amp;oacute;xima vez que se invoque TypeScript con &lt;code&gt;--incremental&lt;/code&gt; , usar&amp;aacute; esa informaci&amp;oacute;n para detectar la forma menos costosa de verificar el tipo y emitir cambios en su proyecto.</target>
        </trans-unit>
        <trans-unit id="ac5af210d9695056d6101c62263f01f5967d4e08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt; using a new &lt;code&gt;readonly&lt;/code&gt; modifier for array types.</source>
          <target state="translated">TypeScript 3.4 introduce una nueva sintaxis para &lt;code&gt;ReadonlyArray&lt;/code&gt; usando un nuevo modificador de &lt;code&gt;readonly&lt;/code&gt; para tipos de matriz.</target>
        </trans-unit>
        <trans-unit id="12a10c24cba59cb68af585f1698de8ae3445244e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces support for type-checking ECMAScript&amp;rsquo;s new &lt;code&gt;globalThis&lt;/code&gt; - a global variable that, well, refers to the global scope. Unlike the above solutions, &lt;code&gt;globalThis&lt;/code&gt; provides a standard way for accessing the global scope which can be used across different environments.</source>
          <target state="translated">TypeScript 3.4 introduce soporte para la verificaci&amp;oacute;n de tipos del nuevo &lt;code&gt;globalThis&lt;/code&gt; de ECMAScript, una variable global que, bueno, se refiere al alcance global. A diferencia de las soluciones anteriores, &lt;code&gt;globalThis&lt;/code&gt; proporciona una forma est&amp;aacute;ndar para acceder al alcance global que se puede utilizar en diferentes entornos.</target>
        </trans-unit>
        <trans-unit id="f91b4dd92032cff1d431b2484ffb02c538b2840a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.</source>
          <target state="translated">TypeScript 3.4 hace que sea un poco más fácil usar tipos tipo array de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="9ab9e17f2ce04fc3d04ccc515b149cf9aa3aa203" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 produces the type</source>
          <target state="translated">TypeScript 3.4 produce el tipo</target>
        </trans-unit>
        <trans-unit id="10f518faa467d8e0e2925a31d9b4b672b9c2e19b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5</source>
          <target state="translated">TypeScript 3.5</target>
        </trans-unit>
        <trans-unit id="359b79f7544026e6404a7f5dc527aa3cfdbf0be7" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</source>
          <target state="translated">TypeScript 3.5 contiene ciertas optimizaciones sobre TypeScript 3.4 para la comprobación de tipos de forma más eficiente.Estas mejoras son significativamente más pronunciadas en los escenarios de los editores en los que la verificación de tipo conduce operaciones como las listas de finalización de código.</target>
        </trans-unit>
        <trans-unit id="a6938b07665eedd653729021d3cce39e74883c08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.</source>
          <target state="translated">TypeScript 3.5 generaliza este comportamiento para trabajar en las funciones de construcción también.</target>
        </trans-unit>
        <trans-unit id="a73d70bff8d5fc727c0bd14cb107e1c1b473750e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 improves on 3.4&amp;rsquo;s &lt;code&gt;--incremental&lt;/code&gt; build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript&amp;rsquo;s project references in &lt;code&gt;--build&lt;/code&gt; mode, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;we&amp;rsquo;ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4&lt;/a&gt;!</source>
          <target state="translated">TypeScript 3.5 mejora el 3.4 &lt;code&gt;--incremental&lt;/code&gt; compilaci&amp;oacute;n incremental , al guardar informaci&amp;oacute;n sobre c&amp;oacute;mo se calcul&amp;oacute; el estado del mundo - la configuraci&amp;oacute;n del compilador, por qu&amp;eacute; se buscaron los archivos, d&amp;oacute;nde se encontraron los archivos, etc. En escenarios que involucran cientos de proyectos usando TypeScript's referencias de proyectos en modo &lt;code&gt;--build&lt;/code&gt; , &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;hemos descubierto que la cantidad de tiempo de reconstrucci&amp;oacute;n se puede reducir hasta en un 68% en comparaci&amp;oacute;n con TypeScript 3.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8870d39de72c9538f7b989e9c665dcecc3f792f4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.</source>
          <target state="translated">TypeScript 3.5 introduce varias optimizaciones en torno a la verificación de tipos y las construcciones incrementales.</target>
        </trans-unit>
        <trans-unit id="a67354830dc88bba666b8a01f15200fc520abe67" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces the new &lt;code&gt;Omit&lt;/code&gt; helper type, which creates a new type with some properties dropped from the original.</source>
          <target state="translated">TypeScript 3.5 introduce el nuevo tipo de ayuda &lt;code&gt;Omit&lt;/code&gt; ir , que crea un nuevo tipo con algunas propiedades eliminadas del original.</target>
        </trans-unit>
        <trans-unit id="860169965c68715ea7e25ddf2b4ae280a663fdd6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6</source>
          <target state="translated">TypeScript 3.6</target>
        </trans-unit>
        <trans-unit id="43040204a5b205b20ce117e9abeba80afa37f954" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.</source>
          <target state="translated">TypeScript 3.6 contiene un mejor soporte para los caracteres Unicode en los identificadores al emitir a ES2015 y objetivos posteriores.</target>
        </trans-unit>
        <trans-unit id="bd36d48e4d1462dffb6c3c392323087bb23fcc1d" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces a new &lt;code&gt;__spreadArrays&lt;/code&gt; helper to accurately model what happens in ECMAScript 2015 in older targets outside of &lt;code&gt;--downlevelIteration&lt;/code&gt;. &lt;code&gt;__spreadArrays&lt;/code&gt; is also available in &lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt;.</source>
          <target state="translated">TypeScript 3.6 presenta un nuevo ayudante &lt;code&gt;__spreadArrays&lt;/code&gt; para modelar con precisi&amp;oacute;n lo que sucede en ECMAScript 2015 en objetivos m&amp;aacute;s antiguos fuera de &lt;code&gt;--downlevelIteration&lt;/code&gt; . &lt;code&gt;__spreadArrays&lt;/code&gt; tambi&amp;eacute;n est&amp;aacute; disponible en &lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33cd49dc97acf9b88dbc38ffefb886129306a9c4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces some improvements for when &lt;code&gt;Promise&lt;/code&gt;s are mis-handled.</source>
          <target state="translated">TypeScript 3.6 introduce algunas mejoras para cuando las &lt;code&gt;Promise&lt;/code&gt; se manejan incorrectamente.</target>
        </trans-unit>
        <trans-unit id="74c9e7c03722726e70a2ffe1f76f8a558869d112" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.</source>
          <target state="translated">TypeScript 3.6 introduce un control más estricto de los iteradores y las funciones del generador.En las versiones anteriores,los usuarios de los generadores no tenían forma de diferenciar si un valor era cedido o devuelto por un generador.</target>
        </trans-unit>
        <trans-unit id="81aa3de148cf46d845b3cd5b3e434a89e256c4c6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;see more details in the original pull request here&lt;/a&gt;.</source>
          <target state="translated">TypeScript 3.6 ahora es un poco m&amp;aacute;s inteligente al analizar sus importaciones existentes antes de decidir c&amp;oacute;mo importar autom&amp;aacute;ticamente otros m&amp;oacute;dulos. Puede &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;ver m&amp;aacute;s detalles en la solicitud de extracci&amp;oacute;n original aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="314b10ba05a1161535cb19963756c6c11ff953ee" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 supports transforming &lt;code&gt;import.meta&lt;/code&gt; to &lt;code&gt;context.meta&lt;/code&gt; when your &lt;code&gt;module&lt;/code&gt; target is set to &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.6 admite la transformaci&amp;oacute;n de &lt;code&gt;import.meta&lt;/code&gt; en &lt;code&gt;context.meta&lt;/code&gt; cuando el destino de su &lt;code&gt;module&lt;/code&gt; est&amp;aacute; configurado en &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f7ed4364cfc54d058bc3677d8dbecd5e3827aa5" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7</source>
          <target state="translated">TypeScript 3.7</target>
        </trans-unit>
        <trans-unit id="27083dbf128c773c5403938ac6b066e57d56ab6a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7 allows us to add &lt;code&gt;// @ts-nocheck&lt;/code&gt; comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of &lt;code&gt;checkJs&lt;/code&gt;, but we&amp;rsquo;ve expanded support to TypeScript files to make migrations easier for all users.</source>
          <target state="translated">TypeScript 3.7 nos permite agregar comentarios &lt;code&gt;// @ts-nocheck&lt;/code&gt; en la parte superior de los archivos de TypeScript para deshabilitar las comprobaciones sem&amp;aacute;nticas. Hist&amp;oacute;ricamente, este comentario solo se respetaba en los archivos fuente de JavaScript en presencia de &lt;code&gt;checkJs&lt;/code&gt; , pero hemos ampliado el soporte a los archivos TypeScript para facilitar las migraciones a todos los usuarios.</target>
        </trans-unit>
        <trans-unit id="3948f56aa0a7c4b97a01b6021dd36790f3c27f3b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e6c0e6d51157bb20e26a7e863eb63b56787312" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation</source>
          <target state="translated">Documentación de TypeScript</target>
        </trans-unit>
        <trans-unit id="5d719aff063d96145b68e6a617af89b4002a79f6" translate="yes" xml:space="preserve">
          <source>TypeScript Tooling in 5 minutes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403fb75c6290c33e1ee26eea036308b48aa46bfe" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</source>
          <target state="translated">Versi&amp;oacute;n de TypeScript: si instal&amp;oacute; con npm: &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9bf97b3981273152e80b422491273038dfba6f7" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</source>
          <target state="translated">Versi&amp;oacute;n de TypeScript: si instal&amp;oacute; con npm: &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92158f74ec4a49fce0c3bbd7e4df145bfac809dd" translate="yes" xml:space="preserve">
          <source>TypeScript additionally has a &lt;code&gt;readonly&lt;/code&gt; modifier for properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9786e84531c7e9e6709c98099bfd87c8dde49dc4" translate="yes" xml:space="preserve">
          <source>TypeScript adds a new triple-slash-reference directive (&lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt;), allowing a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">TypeScript agrega una nueva directiva de referencia de triple barra inclinada ( &lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt; ), lo que permite que un archivo incluya expl&amp;iacute;citamente un archivo &lt;em&gt;lib&lt;/em&gt; incorporado existente .</target>
        </trans-unit>
        <trans-unit id="ab30849b28c84e739618b723a20cd7f3bd9f8230" translate="yes" xml:space="preserve">
          <source>TypeScript adds several predefined conditional types, you can find the full list and examples in &lt;a href=&quot;utility-types&quot;&gt;Utility Types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933684eac8c53f3d3b595b291f7f85a2962ff42b" translate="yes" xml:space="preserve">
          <source>TypeScript also has boolean literal types. You might use these to constrain object values whose properties are interrelated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cb184abb97e12b74ad8254592410b6fab20413" translate="yes" xml:space="preserve">
          <source>TypeScript also has its own way to declare a member as being marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b23712d0cd1521663db4c571af695acc5fe01d" translate="yes" xml:space="preserve">
          <source>TypeScript also has numeric literal types, which act the same as the string literals above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627afeb35305a2b7b628a49f47ad27ec0e7523cd" translate="yes" xml:space="preserve">
          <source>TypeScript also has numeric literal types.</source>
          <target state="translated">TypeScript también tiene tipos literales numéricos.</target>
        </trans-unit>
        <trans-unit id="cd15608e954ae2e54d306fd4af46560be232f740" translate="yes" xml:space="preserve">
          <source>TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript&amp;rsquo;s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d421259d60dd75e6cc38c009347d8fbd16eecddf" translate="yes" xml:space="preserve">
          <source>TypeScript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f845ee328e4da8982a9cb87a1d1fe60de76cba85" translate="yes" xml:space="preserve">
          <source>TypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned &lt;em&gt;off&lt;/em&gt; by default, and can be enabled using &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;.</source>
          <target state="translated">TypeScript puede informar errores para casos fallidos en la instrucci&amp;oacute;n switch donde la cl&amp;aacute;usula case no est&amp;aacute; vac&amp;iacute;a. Esta verificaci&amp;oacute;n est&amp;aacute; &lt;em&gt;desactivada&lt;/em&gt; de forma predeterminada y se puede habilitar usando &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86267f4e18cd09316cea7bbab141853557982d64" translate="yes" xml:space="preserve">
          <source>TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051064120a5cd70ddad4ed87c1bc2af64d3d9e4b" translate="yes" xml:space="preserve">
          <source>TypeScript checks a program for errors before execution, and does so based on the &lt;em&gt;kinds of values&lt;/em&gt;, it&amp;rsquo;s a &lt;em&gt;static type checker&lt;/em&gt;. For example, the last example above has an error because of the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;obj&lt;/code&gt;. Here&amp;rsquo;s the error TypeScript found:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b9849713d9bf4417e9c5210a0c528aff29dc06" translate="yes" xml:space="preserve">
          <source>TypeScript code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3883e486fe04d1f7d13e0ad9f1b9eb0d552664b9" translate="yes" xml:space="preserve">
          <source>TypeScript comes with a &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that is the same as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; with all mutating methods removed, so you can make sure you don&amp;rsquo;t change your arrays after creation:</source>
          <target state="translated">TypeScript viene con un tipo &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; que es el mismo que &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; con todos los m&amp;eacute;todos mutantes eliminados, por lo que puede asegurarse de no cambiar sus matrices despu&amp;eacute;s de la creaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c46782ad571ccfa1375c328c08d6d8a52aae9f4e" translate="yes" xml:space="preserve">
          <source>TypeScript comes with certain checks to give you more safety and analysis of your program. Once you&amp;rsquo;ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.</source>
          <target state="translated">TypeScript viene con ciertas comprobaciones para brindarle m&amp;aacute;s seguridad y an&amp;aacute;lisis de su programa. Una vez que haya convertido su base de c&amp;oacute;digo a TypeScript, puede comenzar a habilitar estas comprobaciones para mayor seguridad.</target>
        </trans-unit>
        <trans-unit id="ccbb64b768c9b80a0141d5b0cacdf027e032576b" translate="yes" xml:space="preserve">
          <source>TypeScript compiles this down to the following JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982bd44a5cc8b5512117571aef28b0ebcb320b22" translate="yes" xml:space="preserve">
          <source>TypeScript decorators are based on the &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;ES7 decorator proposal&lt;/a&gt;.</source>
          <target state="translated">Los decoradores de TypeScript se basan en la &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;propuesta del decorador de ES7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c49eb75318af39272125eec481e10dad28c42573" translate="yes" xml:space="preserve">
          <source>TypeScript determines if the call to &lt;code&gt;fn&lt;/code&gt; here is valid by seeing if the provided argument is a valid &lt;code&gt;Empty&lt;/code&gt;. It does so by examining the &lt;em&gt;structure&lt;/em&gt; of &lt;code&gt;{ k: 10 }&lt;/code&gt; and &lt;code&gt;class Empty { }&lt;/code&gt;. We can see that &lt;code&gt;{ k: 10 }&lt;/code&gt; has &lt;em&gt;all&lt;/em&gt; of the properties that &lt;code&gt;Empty&lt;/code&gt; does, because &lt;code&gt;Empty&lt;/code&gt; has no properties. Therefore, this is a valid call!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250cd79d3d3268a25a6551d40fbaae96eebab0e3" translate="yes" xml:space="preserve">
          <source>TypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;. Enter the new &lt;code&gt;object&lt;/code&gt; type.</source>
          <target state="translated">TypeScript no ten&amp;iacute;a un tipo que representara el tipo no primitivo, es decir, cualquier cosa que no sea &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; o , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . Ingrese el nuevo tipo de &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5ef0d0e7c127dd5aa5d2057bcc3b018aa657ae1" translate="yes" xml:space="preserve">
          <source>TypeScript does not have higher kinded types, so the following is not legal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecbedd4aac4c783dc5087f561c9c49681b205cd" translate="yes" xml:space="preserve">
          <source>TypeScript does not support resolving JSON files by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99706e78c25c70ab97b91669035d38e90b305ea6" translate="yes" xml:space="preserve">
          <source>TypeScript doesn&amp;rsquo;t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fada45685495c730f9a9cc2a93bbb49026908546" translate="yes" xml:space="preserve">
          <source>TypeScript doesn&amp;rsquo;t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we&amp;rsquo;re going to look at how you might start out. We assume you&amp;rsquo;ve read enough of the handbook to write new TypeScript code.</source>
          <target state="translated">TypeScript no existe en el vac&amp;iacute;o. Se cre&amp;oacute; teniendo en cuenta el ecosistema de JavaScript y hoy en d&amp;iacute;a existe una gran cantidad de JavaScript. Convertir una base de c&amp;oacute;digo JavaScript en TypeScript es, aunque algo tedioso, por lo general no es un desaf&amp;iacute;o. En este tutorial, veremos c&amp;oacute;mo podr&amp;iacute;a comenzar. Suponemos que ha le&amp;iacute;do lo suficiente del manual para escribir un nuevo c&amp;oacute;digo TypeScript.</target>
        </trans-unit>
        <trans-unit id="1c8cdf286fbbcc4e7b49af3039a27393efcafa25" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler and end up in &lt;code&gt;dist&lt;/code&gt;.</source>
          <target state="translated">Los archivos de TypeScript comenzar&amp;aacute;n en su carpeta &lt;code&gt;src&lt;/code&gt; , se ejecutar&amp;aacute;n a trav&amp;eacute;s del compilador de TypeScript y terminar&amp;aacute;n en &lt;code&gt;dist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59c18fee8487cdeda3b2f34b4ca8e8a543f5cab1" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler, then webpack, and end up in a &lt;code&gt;main.js&lt;/code&gt; file in &lt;code&gt;dist&lt;/code&gt;. Any components that we write will go in the &lt;code&gt;src/components&lt;/code&gt; folder.</source>
          <target state="translated">Los archivos de TypeScript comenzar&amp;aacute;n en su carpeta &lt;code&gt;src&lt;/code&gt; , se ejecutar&amp;aacute;n a trav&amp;eacute;s del compilador de TypeScript, luego en el paquete web y terminar&amp;aacute;n en un archivo &lt;code&gt;main.js&lt;/code&gt; en &lt;code&gt;dist&lt;/code&gt; . Cualquier componente que escribamos ir&amp;aacute; a la carpeta &lt;code&gt;src/components&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e928664e9ba3db7f949861f05d81f86d70adeb" translate="yes" xml:space="preserve">
          <source>TypeScript follows the case sensitivity rules of the file system it&amp;rsquo;s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren&amp;rsquo;t. If a file attempts to import &lt;code&gt;fileManager.ts&lt;/code&gt; by specifying &lt;code&gt;./FileManager.ts&lt;/code&gt; the file will be found in a case-insensitive file system, but not on a case-sensitive file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc050e207c38920097293143b10d59b473dbcff4" translate="yes" xml:space="preserve">
          <source>TypeScript for Functional Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc592d6d7ce7d2bc3c3f49068e5d4fff5338e8e" translate="yes" xml:space="preserve">
          <source>TypeScript for JS Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad7cb0c6b7a5eb829a0cd66ebdfe0d11d25b842" translate="yes" xml:space="preserve">
          <source>TypeScript for Java/C# Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d15563ab88aa0acbcf181a27f272f5268b418d" translate="yes" xml:space="preserve">
          <source>TypeScript for JavaScript Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf59fb1a4572acf6d6413101225073873cc311" translate="yes" xml:space="preserve">
          <source>TypeScript for New Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871854b83287d4786ba7236204173f606ee249bb" translate="yes" xml:space="preserve">
          <source>TypeScript for OOP Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6afc05f4efdee6736a14797a9429ba616e9f7d" translate="yes" xml:space="preserve">
          <source>TypeScript for the New Programmer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e275a1ab2aa2f59571ca8cefeaf8a68b8704838b" translate="yes" xml:space="preserve">
          <source>TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a367ff679df04f05c3c34e6560229bdc2557a732" translate="yes" xml:space="preserve">
          <source>TypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with &lt;code&gt;Promise&lt;/code&gt;s and &lt;code&gt;Observable&lt;/code&gt;s.</source>
          <target state="translated">TypeScript siempre ha comparado par&amp;aacute;metros de forma bivariante. Hay varias razones para esto, pero en general, esto no fue un gran problema para nuestros usuarios hasta que vimos algunos de los efectos adversos que tuvo con &lt;code&gt;Promise&lt;/code&gt; sy &lt;code&gt;Observable&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="2cc6486a45098c6f81cc098930195dc52786060c" translate="yes" xml:space="preserve">
          <source>TypeScript has corresponding primitive types for the built-in types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994258a317498ea30e98974b2dd26c0832e6c8f6" translate="yes" xml:space="preserve">
          <source>TypeScript has some obvious places where it can infer types, like variable declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db02a42b5c74e823760580106f119d33d32acab0" translate="yes" xml:space="preserve">
          <source>TypeScript has traditionally been overly strict about how you can import modules. This was to avoid typos and prevent users from using modules incorrectly.</source>
          <target state="translated">Tradicionalmente,TypeScript ha sido demasiado estricto en cuanto a la forma de importar módulos.Esto fue para evitar errores de escritura y evitar que los usuarios usaran los módulos incorrectamente.</target>
        </trans-unit>
        <trans-unit id="6506fa415538aa5ce5fe042526c3ba02ac3c0356" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href=&quot;basic-types&quot;&gt;the Basic Types section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b5002b156ed20abcb2373b3f1a34e30ef133d5" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href=&quot;basic-types&quot;&gt;the Basic Types section&lt;/a&gt;. By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">TypeScript tiene dos tipos especiales, &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; , que tienen los valores nulo e indefinido respectivamente. Los mencionamos brevemente en &lt;a href=&quot;basic-types&quot;&gt;la secci&amp;oacute;n Tipos b&amp;aacute;sicos&lt;/a&gt; . De forma predeterminada, el verificador de tipos considera asignables &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; a cualquier cosa. Efectivamente, &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; son valores v&amp;aacute;lidos de todo tipo. Eso significa que no es posible &lt;em&gt;evitar&lt;/em&gt; que se asignen a ning&amp;uacute;n tipo, incluso cuando desee evitarlo. El inventor de &lt;code&gt;null&lt;/code&gt; , Tony Hoare, llama a esto su &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;&quot;error de mil millones de d&amp;oacute;lares&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75fc1f90351ac73e35a5f3f576d18314c46dc6c2" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, Null and Undefined, that have the values &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Previously it was not possible to explicitly name these types, but &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; may now be used as type names regardless of type checking mode.</source>
          <target state="translated">TypeScript tiene dos tipos especiales, Null y Undefined, que tienen los valores &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; respectivamente. Anteriormente, no era posible nombrar expl&amp;iacute;citamente estos tipos, pero ahora se pueden usar &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; como nombres de tipos independientemente del modo de verificaci&amp;oacute;n de tipos.</target>
        </trans-unit>
        <trans-unit id="76257f3717800dcd967d87bc9d2ef1e67b788bfb" translate="yes" xml:space="preserve">
          <source>TypeScript ignores any unsupported JSDoc tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669ae0c383f0ebc9a1b71a33795f2fba316ff636" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes</source>
          <target state="translated">Escriba a máquina en 5 minutos</target>
        </trans-unit>
        <trans-unit id="452bd92ef7047873dae5fa9a26760186598678c6" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Building your first TypeScript file</source>
          <target state="translated">Escriba a máquina en 5 minutos:Construyendo su primer archivo de TypeScript</target>
        </trans-unit>
        <trans-unit id="cfe56778efe914c509395d743856f638e0b2dc80" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Classes</source>
          <target state="translated">Escriba a máquina en 5 minutos:Clases</target>
        </trans-unit>
        <trans-unit id="66f6d1b030c2c31817cfd629aeaf4e9f8e001440" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Compiling your code</source>
          <target state="translated">Escriba a máquina en 5 minutos:Compilación de su código</target>
        </trans-unit>
        <trans-unit id="64b3883005157157bc3e05fd1909ad05a7782093" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Installing TypeScript</source>
          <target state="translated">Escriba a máquina en 5 minutos:Instalando TypeScript</target>
        </trans-unit>
        <trans-unit id="679437aa54596d7921f489403e44c2b30fef5aed" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Interfaces</source>
          <target state="translated">Escriba a máquina en 5 minutos:Interfaces</target>
        </trans-unit>
        <trans-unit id="520fec1d849d26fa3641ec76d5fda0df2e56b07e" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Running your TypeScript web app</source>
          <target state="translated">Escriba a máquina en 5 minutos:Ejecutando su aplicación web TypeScript</target>
        </trans-unit>
        <trans-unit id="6a574132fb48839d07c1e73530345fd9189655e2" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Type annotations</source>
          <target state="translated">Escriba a máquina en 5 minutos:Escriba las anotaciones</target>
        </trans-unit>
        <trans-unit id="49f01d7597e304266b95072fc59979cc8fe48d0a" translate="yes" xml:space="preserve">
          <source>TypeScript includes a default set of type definitions for built-in JS APIs (like &lt;code&gt;Math&lt;/code&gt;), as well as type definitions for things found in browser environments (like &lt;code&gt;document&lt;/code&gt;). TypeScript also includes APIs for newer JS features matching the &lt;code&gt;target&lt;/code&gt; you specify; for example the definition for &lt;code&gt;Map&lt;/code&gt; is available if &lt;code&gt;target&lt;/code&gt; is &lt;code&gt;ES6&lt;/code&gt; or newer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa27fdf7da61b594edc2419147ebeb6293bab089" translate="yes" xml:space="preserve">
          <source>TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">TypeScript incluye soporte experimental para emitir ciertos tipos de metadatos para declaraciones que tienen decoradores. Para habilitar este soporte experimental, debe configurar la opci&amp;oacute;n del compilador &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; en la l&amp;iacute;nea de comandos o en su &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65097970997af32f38424bf7e3969825b3d282b6" translate="yes" xml:space="preserve">
          <source>TypeScript injects a handful of helper functions such as &lt;code&gt;__extends&lt;/code&gt; for inheritance, &lt;code&gt;__assign&lt;/code&gt; for spread operator in object literals and JSX elements, and &lt;code&gt;__awaiter&lt;/code&gt; for async functions.</source>
          <target state="translated">TypeScript inyecta un pu&amp;ntilde;ado de funciones auxiliares como &lt;code&gt;__extends&lt;/code&gt; para herencia, &lt;code&gt;__assign&lt;/code&gt; para operador de propagaci&amp;oacute;n en literales de objeto y elementos JSX, y &lt;code&gt;__awaiter&lt;/code&gt; para funciones as&amp;iacute;ncronas.</target>
        </trans-unit>
        <trans-unit id="1676238ce5402b50fb854510e52fc28497e635a6" translate="yes" xml:space="preserve">
          <source>TypeScript is a language that is a &lt;em&gt;superset&lt;/em&gt; of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a &lt;em&gt;syntax&lt;/em&gt; error because it&amp;rsquo;s missing a &lt;code&gt;)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a40df62f3fab8b8861efc1fdf68a3995194acce" translate="yes" xml:space="preserve">
          <source>TypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4865203c87f3f94d8f8566ed718390d0119234fb" translate="yes" xml:space="preserve">
          <source>TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.</source>
          <target state="translated">TypeScript es un sistema de tipo estructural.Cuando comparamos dos tipos diferentes,sin importar de dónde vienen,si los tipos de todos los miembros son compatibles,entonces decimos que los tipos mismos son compatibles.</target>
        </trans-unit>
        <trans-unit id="03aae380405163f427174ac0826d59a0323fbdd4" translate="yes" xml:space="preserve">
          <source>TypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in &lt;em&gt;lib.dom.d.ts&lt;/em&gt;, one stands out among the rest: &lt;code&gt;HTMLElement&lt;/code&gt; . This type is the backbone for DOM manipulation with TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a4f8e7040f4dce8be2768117a4691b14f816d0" translate="yes" xml:space="preserve">
          <source>TypeScript is also a programming language that preserves the &lt;em&gt;runtime behavior&lt;/em&gt; of JavaScript. For example, dividing by zero in JavaScript produces &lt;code&gt;Infinity&lt;/code&gt; instead of throwing a runtime exception. As a principle, TypeScript &lt;strong&gt;never&lt;/strong&gt; changes the runtime behavior of JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5933fe400768d081ab73894e4f792a102e8c04" translate="yes" xml:space="preserve">
          <source>TypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won&amp;rsquo;t add one.</source>
          <target state="translated">TypeScript ahora es lo suficientemente inteligente como para detectar si su archivo usa punto y coma al aplicar este tipo de ediciones. Si su archivo generalmente carece de punto y coma, TypeScript no agregar&amp;aacute; uno.</target>
        </trans-unit>
        <trans-unit id="f8e7896660208a1071901f88668396a6aa40f6ae" translate="yes" xml:space="preserve">
          <source>TypeScript is smart enough to infer types in other contexts as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5a722ba8718780ca30a3749f2e85938a171a6e" translate="yes" xml:space="preserve">
          <source>TypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b561cb58276a15cfc408ce85335f9d608e3f0d7" translate="yes" xml:space="preserve">
          <source>TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; or &lt;code&gt;// @ts-expect-error&lt;/code&gt; on the preceding line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0716da88bf8553ba341ae10829c8d80565f07b2" translate="yes" xml:space="preserve">
          <source>TypeScript might compile this down to something like the the following JavaScript:</source>
          <target state="translated">TypeScript podría compilar esto en algo como el siguiente JavaScript:</target>
        </trans-unit>
        <trans-unit id="32fed70cd34feef29d0649f498d61da78cbda0ab" translate="yes" xml:space="preserve">
          <source>TypeScript now only strictly enforces the visibility of types in modules if the &lt;code&gt;--declaration&lt;/code&gt; flag is provided. This is very useful for Angular scenarios, for example:</source>
          <target state="translated">TypeScript ahora solo aplica estrictamente la visibilidad de los tipos en los m&amp;oacute;dulos si se proporciona la &lt;code&gt;--declaration&lt;/code&gt; . Esto es muy &amp;uacute;til para escenarios angulares, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="bf627cab04633b795ac087dea296a4bdb609bc4d" translate="yes" xml:space="preserve">
          <source>TypeScript now supports &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;Function components&lt;/a&gt;. These are lightweight components that easily compose other components:</source>
          <target state="translated">TypeScript ahora admite &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;componentes de funci&amp;oacute;n&lt;/a&gt; . Estos son componentes ligeros que componen f&amp;aacute;cilmente otros componentes:</target>
        </trans-unit>
        <trans-unit id="52d1c2115b1983ad21a42bf4d3fb47956062ab0c" translate="yes" xml:space="preserve">
          <source>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</source>
          <target state="translated">TypeScript ahora soporta cadenas de plantillas ES6.Esta es una forma fácil de incrustar expresiones arbitrarias en las cadenas:</target>
        </trans-unit>
        <trans-unit id="dca2d3b95767ef524c8d3421355c36053ab3819a" translate="yes" xml:space="preserve">
          <source>TypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the &lt;code&gt;async&lt;/code&gt; keyword; &lt;code&gt;await&lt;/code&gt; suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the &lt;code&gt;Promise&lt;/code&gt; returned.</source>
          <target state="translated">TypeScript ahora admite funciones asincr&amp;oacute;nicas para motores que tienen soporte nativo para generadores ES6, por ejemplo, Node v4 y superior. Las funciones asincr&amp;oacute;nicas tienen como prefijo la palabra clave &lt;code&gt;async&lt;/code&gt; ; &lt;code&gt;await&lt;/code&gt; suspende la ejecuci&amp;oacute;n hasta que se cumpla una promesa de devoluci&amp;oacute;n de funci&amp;oacute;n as&amp;iacute;ncrona y desenvuelve el valor de la &lt;code&gt;Promise&lt;/code&gt; devuelta.</target>
        </trans-unit>
        <trans-unit id="0e7958ec88d9f0faef067488c643d885da64e7bf" translate="yes" xml:space="preserve">
          <source>TypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you&amp;rsquo;ll get stricter checks when relating two generic signatures, and may catch some bugs.</source>
          <target state="translated">TypeScript ahora intenta unificar los par&amp;aacute;metros de tipo al comparar dos tipos de firma &amp;uacute;nica. Como resultado, obtendr&amp;aacute; controles m&amp;aacute;s estrictos al relacionar dos firmas gen&amp;eacute;ricas y es posible que detecte algunos errores.</target>
        </trans-unit>
        <trans-unit id="a1e4e94f6714f3b9449e43db5907067b8f68b98e" translate="yes" xml:space="preserve">
          <source>TypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you&amp;rsquo;ll find them more intuitive if you think of types as sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62273ee78dee44c5da22f4945f26ce4659fc27f" translate="yes" xml:space="preserve">
          <source>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.</source>
          <target state="translated">TypeScript proporciona varios tipos de utilidad para facilitar las transformaciones de tipos comunes.Estas utilidades están disponibles a nivel mundial.</target>
        </trans-unit>
        <trans-unit id="4ef0844b7f909249d5a9f9e273a4f9a6ba63eb30" translate="yes" xml:space="preserve">
          <source>TypeScript replicates the node resolution for modules in a &lt;code&gt;package.json&lt;/code&gt;, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional &lt;code&gt;&quot;types&quot;&lt;/code&gt; field, then the &lt;code&gt;&quot;main&quot;&lt;/code&gt; field, and finally will try &lt;code&gt;index.d.ts&lt;/code&gt; in the root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988860fc02a853b3a27d2af5425c58bd62c2eceb" translate="yes" xml:space="preserve">
          <source>TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, &lt;em&gt;and extraneous arguments are allowed&lt;/em&gt;. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:</source>
          <target state="translated">TypeScript resuelve la compatibilidad de firmas al ver si se puede invocar alguna firma del destino con los argumentos de la fuente, &lt;em&gt;y se permiten argumentos extra&amp;ntilde;os&lt;/em&gt; . Este c&amp;oacute;digo, por ejemplo, expone un error solo cuando la firma est&amp;aacute; escrita correctamente usando par&amp;aacute;metros opcionales:</target>
        </trans-unit>
        <trans-unit id="8a0c2fdfc90997d639e7e23066198c7742ba74d7" translate="yes" xml:space="preserve">
          <source>TypeScript ships with three JSX modes: &lt;code&gt;preserve&lt;/code&gt;, &lt;code&gt;react&lt;/code&gt;, and &lt;code&gt;react-native&lt;/code&gt;. These modes only affect the emit stage - type checking is unaffected. The &lt;code&gt;preserve&lt;/code&gt; mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;). Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension. The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension. The &lt;code&gt;react-native&lt;/code&gt; mode is the equivalent of &lt;code&gt;preserve&lt;/code&gt; in that it keeps all JSX, but the output will instead have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">TypeScript viene con tres modos JSX: &lt;code&gt;preserve&lt;/code&gt; , &lt;code&gt;react&lt;/code&gt; y &lt;code&gt;react-native&lt;/code&gt; . Estos modos solo afectan la etapa de emisi&amp;oacute;n; la verificaci&amp;oacute;n de tipo no se ve afectada. El modo de &lt;code&gt;preserve&lt;/code&gt; mantendr&amp;aacute; el JSX como parte de la salida para ser consumido por otro paso de transformaci&amp;oacute;n (por ejemplo, &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; ). Adem&amp;aacute;s, la salida tendr&amp;aacute; una extensi&amp;oacute;n de archivo &lt;code&gt;.jsx&lt;/code&gt; . El modo de &lt;code&gt;react&lt;/code&gt; emitir&amp;aacute; &lt;code&gt;React.createElement&lt;/code&gt; , no necesita pasar por una transformaci&amp;oacute;n JSX antes de su uso, y la salida tendr&amp;aacute; una extensi&amp;oacute;n de archivo &lt;code&gt;.js&lt;/code&gt; . El modo &lt;code&gt;react-native&lt;/code&gt; es el equivalente de &lt;code&gt;preserve&lt;/code&gt; ya que mantiene todo JSX, pero la salida tendr&amp;aacute; una extensi&amp;oacute;n de archivo &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2cd47e8e27537ecdbea6c76c0813851141bdf88" translate="yes" xml:space="preserve">
          <source>TypeScript ships with two JSX modes: &lt;code&gt;preserve&lt;/code&gt; and &lt;code&gt;react&lt;/code&gt;.</source>
          <target state="translated">TypeScript incluye dos modos JSX: &lt;code&gt;preserve&lt;/code&gt; y &lt;code&gt;react&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00a935a3f7579d721385691d1b84e679d883dff3" translate="yes" xml:space="preserve">
          <source>TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript&amp;rsquo;s features, and an additional layer on top of these: TypeScript&amp;rsquo;s type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bbddad2b4d434df60aaa882de571170d946407" translate="yes" xml:space="preserve">
          <source>TypeScript strives to only include features which are confirmed to be added into the JavaScript language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e350ae43b9a5687315f9cb51fc6866456b882a7f" translate="yes" xml:space="preserve">
          <source>TypeScript supports a wide spectrum of JavaScript patterns and defaults to allowing for quite a lot of flexibility in accommodating these styles. Often the safety and potential scalability of a codebase can be at odds with some of these techniques.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68cb065a26c6d898de1ad77c499a5380c7336c0" translate="yes" xml:space="preserve">
          <source>TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.</source>
          <target state="translated">TypeScript soporta getters/setters como una forma de interceptar accesos a un miembro de un objeto.Esto le da una forma de tener un control más fino sobre cómo se accede a un miembro en cada objeto.</target>
        </trans-unit>
        <trans-unit id="b66debd096de5790d32615c82aeae20dd89c1b00" translate="yes" xml:space="preserve">
          <source>TypeScript treats a namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt;.Things are simple here, but they don&amp;rsquo;t work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (&lt;code&gt;foo&lt;/code&gt; in the example above) is not callable, though allowed by TypeScript</source>
          <target state="translated">TypeScript trata una importaci&amp;oacute;n de espacio de nombres (es decir, una &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ) para un m&amp;oacute;dulo CommonJS / AMD / UMD como equivalente a &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt; cosas son simples aqu&amp;iacute;, pero no funcionan si el objeto principal que se est&amp;aacute; importando es una primitiva, una clase o una funci&amp;oacute;n. La especificaci&amp;oacute;n ECMAScript estipula que un registro de espacio de nombres es un objeto simple y que una importaci&amp;oacute;n de espacio de nombres ( &lt;code&gt;foo&lt;/code&gt; en el ejemplo anterior) no es invocable, aunque lo permite TypeScript</target>
        </trans-unit>
        <trans-unit id="190d779979c1c225024b4faf8c71539ad6be2768" translate="yes" xml:space="preserve">
          <source>TypeScript used the &lt;code&gt;module&lt;/code&gt; keyword to define both &amp;ldquo;internal modules&amp;rdquo; and &amp;ldquo;external modules&amp;rdquo;; this has been a bit of confusion for developers new to TypeScript. &amp;ldquo;Internal modules&amp;rdquo; are closer to what most people would call a namespace; likewise, &amp;ldquo;external modules&amp;rdquo; in JS speak really just are modules now.</source>
          <target state="translated">TypeScript us&amp;oacute; la palabra clave &lt;code&gt;module&lt;/code&gt; para definir tanto &quot;m&amp;oacute;dulos internos&quot; como &quot;m&amp;oacute;dulos externos&quot;; esto ha sido un poco confuso para los desarrolladores nuevos en TypeScript. Los &amp;ldquo;m&amp;oacute;dulos internos&amp;rdquo; est&amp;aacute;n m&amp;aacute;s cerca de lo que la mayor&amp;iacute;a de la gente llamar&amp;iacute;a un espacio de nombres; del mismo modo, los &quot;m&amp;oacute;dulos externos&quot; en JS son realmente m&amp;oacute;dulos ahora.</target>
        </trans-unit>
        <trans-unit id="1b58b6b726ed6ef37d5ab19f3e08450acedef197" translate="yes" xml:space="preserve">
          <source>TypeScript uses a file called &lt;code&gt;tsconfig.json&lt;/code&gt; for managing your project&amp;rsquo;s options, such as which files you want to include, and what sorts of checking you want to perform. Let&amp;rsquo;s create a bare-bones one for our project:</source>
          <target state="translated">TypeScript usa un archivo llamado &lt;code&gt;tsconfig.json&lt;/code&gt; para administrar las opciones de su proyecto, como qu&amp;eacute; archivos desea incluir y qu&amp;eacute; tipo de verificaci&amp;oacute;n desea realizar. Creemos uno b&amp;aacute;sico para nuestro proyecto:</target>
        </trans-unit>
        <trans-unit id="f56d1e973d936e7e25808ece950aef4bac63d378" translate="yes" xml:space="preserve">
          <source>TypeScript uses the &lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;same convention that React does&lt;/a&gt; for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</source>
          <target state="translated">TypeScript usa la &lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;misma convenci&amp;oacute;n que React&lt;/a&gt; para distinguir entre estos. Un elemento intr&amp;iacute;nseco siempre comienza con una letra min&amp;uacute;scula y un elemento basado en valores siempre comienza con una letra may&amp;uacute;scula.</target>
        </trans-unit>
        <trans-unit id="7fed99366cf22869561ff0cde11374db19d9f07b" translate="yes" xml:space="preserve">
          <source>TypeScript uses the type &lt;code&gt;any&lt;/code&gt; whenever it can&amp;rsquo;t tell what the type of an expression should be. Compared to &lt;code&gt;Dynamic&lt;/code&gt;, calling &lt;code&gt;any&lt;/code&gt; a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an &lt;code&gt;any[]&lt;/code&gt; without marking the value in any way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94cd2357ef6caf93ae4025491d6f6435c0dfc38" translate="yes" xml:space="preserve">
          <source>TypeScript will also now compute enum values when possible:</source>
          <target state="translated">TypeScript también calculará ahora valores numéricos cuando sea posible:</target>
        </trans-unit>
        <trans-unit id="363493eaf871474aebe9c026f44b9b57be878dd1" translate="yes" xml:space="preserve">
          <source>TypeScript will also warn about unreachable code and labels, which you can disable with &lt;code&gt;allowUnreachableCode&lt;/code&gt; and &lt;code&gt;allowUnusedLabels&lt;/code&gt; respectively.</source>
          <target state="translated">TypeScript tambi&amp;eacute;n advertir&amp;aacute; sobre c&amp;oacute;digos y etiquetas inalcanzables, que puede deshabilitar con &lt;code&gt;allowUnreachableCode&lt;/code&gt; y &lt;code&gt;allowUnusedLabels&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="e8a61643ec3271fd661861cae15f39927b074e83" translate="yes" xml:space="preserve">
          <source>TypeScript will mimic the Node.js run-time resolution strategy in order to locate definition files for modules at compile-time. To accomplish this, TypeScript overlays the TypeScript source file extensions (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt;) over Node&amp;rsquo;s resolution logic. TypeScript will also use a field in &lt;code&gt;package.json&lt;/code&gt; named &lt;code&gt;&quot;types&quot;&lt;/code&gt; to mirror the purpose of &lt;code&gt;&quot;main&quot;&lt;/code&gt; - the compiler will use it to find the &amp;ldquo;main&amp;rdquo; definition file to consult.</source>
          <target state="translated">TypeScript imitar&amp;aacute; la estrategia de resoluci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n de Node.js para ubicar archivos de definici&amp;oacute;n de m&amp;oacute;dulos en tiempo de compilaci&amp;oacute;n. Para lograr esto, TypeScript superpone las extensiones de archivo fuente de TypeScript ( &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; y &lt;code&gt;.d.ts&lt;/code&gt; ) sobre la l&amp;oacute;gica de resoluci&amp;oacute;n de Node. TypeScript tambi&amp;eacute;n usar&amp;aacute; un campo en &lt;code&gt;package.json&lt;/code&gt; llamado &lt;code&gt;&quot;types&quot;&lt;/code&gt; para reflejar el prop&amp;oacute;sito de &lt;code&gt;&quot;main&quot;&lt;/code&gt; - el compilador lo usar&amp;aacute; para encontrar el archivo de definici&amp;oacute;n &quot;principal&quot; para consultar.</target>
        </trans-unit>
        <trans-unit id="d20fd8b3bcedf7d11d40c55cf087585df77e7708" translate="yes" xml:space="preserve">
          <source>TypeScript will say that you can&amp;rsquo;t assign to &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;volume&lt;/code&gt; because it first figured out the type of &lt;code&gt;options&lt;/code&gt; as &lt;code&gt;{}&lt;/code&gt; which doesn&amp;rsquo;t have any properties. If you instead moved the declarations into the object literal themselves, you&amp;rsquo;d get no errors:</source>
          <target state="translated">TypeScript dir&amp;aacute; que no puede asignar &lt;code&gt;color&lt;/code&gt; y &lt;code&gt;volume&lt;/code&gt; n porque primero descubri&amp;oacute; el tipo de &lt;code&gt;options&lt;/code&gt; como &lt;code&gt;{}&lt;/code&gt; que no tiene propiedades. Si, en cambio, moviera las declaraciones al objeto literal, no obtendr&amp;iacute;a errores:</target>
        </trans-unit>
        <trans-unit id="b835b008208b64fdab50a54358ce702512ec0e47" translate="yes" xml:space="preserve">
          <source>TypeScript will unify type parameters when comparing two generic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0ca513c7dc163be9ae8d550d8e42ef8b211838" translate="yes" xml:space="preserve">
          <source>TypeScript will usually add a compiler flag for the latter set of errors, and by default these are not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bf0c53ba4aa0ec1095c2375e35e8a2ae0dd7f7" translate="yes" xml:space="preserve">
          <source>TypeScript with &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strict&quot;&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e22e69ba01fd253f8ca30b84167b834c8db6f0" translate="yes" xml:space="preserve">
          <source>TypeScript with JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd367b77df54efafc687e3d2bce712bf9f604879" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--pretty&lt;/code&gt; flag can make error messages easier to read and manage. &lt;code&gt;--pretty&lt;/code&gt; now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).</source>
          <target state="translated">La &lt;code&gt;--pretty&lt;/code&gt; de TypeScript puede hacer que los mensajes de error sean m&amp;aacute;s f&amp;aacute;ciles de leer y administrar. &lt;code&gt;--pretty&lt;/code&gt; ahora usa colores para nombres de archivos, c&amp;oacute;digos de diagn&amp;oacute;stico y n&amp;uacute;meros de l&amp;iacute;nea. Los nombres de archivo y las posiciones ahora tambi&amp;eacute;n est&amp;aacute;n formateados para permitir la navegaci&amp;oacute;n en terminales comunes (por ejemplo, terminal Visual Studio Code).</target>
        </trans-unit>
        <trans-unit id="82367d5505123220713eb9aa76910332cb1314fc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; mode now clears the screen after a re-compilation is requested.</source>
          <target state="translated">El modo &lt;code&gt;--watch&lt;/code&gt; de TypeScript ahora borra la pantalla despu&amp;eacute;s de que se solicita una recompilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e240610ed534bc76d20bc7bebb7e8fd4ee492fe3" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript&amp;rsquo;s automatic semicolon insertion (ASI) rules. The setting is available now in &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt;, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.</source>
          <target state="translated">El formateador integrado de TypeScript ahora admite la inserci&amp;oacute;n y eliminaci&amp;oacute;n de punto y coma en ubicaciones donde un punto y coma final es opcional debido a las reglas de inserci&amp;oacute;n autom&amp;aacute;tica de punto y coma (ASI) de JavaScript. La configuraci&amp;oacute;n est&amp;aacute; disponible ahora en &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt; y estar&amp;aacute; disponible en Visual Studio 16.4 Preview 2 en el men&amp;uacute; Herramientas Opciones.</target>
        </trans-unit>
        <trans-unit id="08c6179dcf1375ce19533b773a6b25765f412389" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn&amp;rsquo;t been built (or whose output was out of date) meant that the editing experience wouldn&amp;rsquo;t work well.</source>
          <target state="translated">Las referencias de proyectos de TypeScript nos brindan una manera f&amp;aacute;cil de dividir las bases de c&amp;oacute;digo para brindarnos compilaciones m&amp;aacute;s r&amp;aacute;pidas. Desafortunadamente, editar un proyecto cuyas dependencias no se hab&amp;iacute;an creado (o cuya salida estaba desactualizada) significaba que la experiencia de edici&amp;oacute;n no funcionar&amp;iacute;a bien.</target>
        </trans-unit>
        <trans-unit id="8e33dd464f3004daae495bfbf61b1d8f4515a8bc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it&amp;rsquo;s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.</source>
          <target state="translated">El sistema de tipos estructurales de TypeScript se dise&amp;ntilde;&amp;oacute; en funci&amp;oacute;n de c&amp;oacute;mo se escribe normalmente el c&amp;oacute;digo JavaScript. Debido a que JavaScript utiliza ampliamente objetos an&amp;oacute;nimos como expresiones de funci&amp;oacute;n y literales de objeto, es mucho m&amp;aacute;s natural representar los tipos de relaciones que se encuentran en las bibliotecas de JavaScript con un sistema de tipos estructurales en lugar de uno nominal.</target>
        </trans-unit>
        <trans-unit id="bb4cd132d17765763f4ec7ad513fe8c0ba6e5307" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system allows certain operations that can&amp;rsquo;t be known at compile-time to be safe. When a type system has this property, it is said to not be &amp;ldquo;sound&amp;rdquo;. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we&amp;rsquo;ll explain where these happen and the motivating scenarios behind them.</source>
          <target state="translated">El sistema de tipos de TypeScript permite que ciertas operaciones que no se pueden conocer en tiempo de compilaci&amp;oacute;n sean seguras. Cuando un sistema de tipos tiene esta propiedad, se dice que no es &quot;s&amp;oacute;lido&quot;. Se consideraron cuidadosamente los lugares donde TypeScript permite un comportamiento incorrecto y, a lo largo de este documento, explicaremos d&amp;oacute;nde ocurren y los escenarios motivadores detr&amp;aacute;s de ellos.</target>
        </trans-unit>
        <trans-unit id="bc25ef434b456b8e9b3f38204ffc2330bc4fb76d" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system is &lt;em&gt;structural&lt;/em&gt;, not nominal: We can use &lt;code&gt;obj&lt;/code&gt; as a &lt;code&gt;Pointlike&lt;/code&gt; because it has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties that are both numbers. The relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699fd96b329576b8e4f3bea33063886228ddc2e0" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system is also &lt;em&gt;not reified&lt;/em&gt;: There&amp;rsquo;s nothing at runtime that will tell us that &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;Pointlike&lt;/code&gt;. In fact, the &lt;code&gt;Pointlike&lt;/code&gt; type is not present &lt;em&gt;in any form&lt;/em&gt; at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd0cf7a946fdeea7bb4261a202a46f6a006f525" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program. While TypeScript provides many familiar features for these developers, it&amp;rsquo;s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages. Understanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall in to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2727a72bb787115b0b255c31ef21d7adbe04c368" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s understanding of a &lt;em&gt;type&lt;/em&gt; is actually quite different from C# or Java&amp;rsquo;s. Let&amp;rsquo;s explore some differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349e8ba90638f01a95ebe613d90e5ffbcee9736b" translate="yes" xml:space="preserve">
          <source>TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by &lt;code&gt;[]&lt;/code&gt; to denote an array of that element type:</source>
          <target state="translated">TypeScript, como JavaScript, le permite trabajar con matrices de valores. Los tipos de matriz se pueden escribir de dos formas. En el primero, usa el tipo de los elementos seguido de &lt;code&gt;[]&lt;/code&gt; para denotar una matriz de ese tipo de elemento:</target>
        </trans-unit>
        <trans-unit id="4ad04619aba3f2f4ed81caa26fedf4a7d7810729" translate="yes" xml:space="preserve">
          <source>TypeScript-Preview</source>
          <target state="translated">TypeScript-Preview</target>
        </trans-unit>
        <trans-unit id="0fbb22e14b529ffecc219e421d78a3fd5f50af73" translate="yes" xml:space="preserve">
          <source>TypeScript: A Static Type Checker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d9bbe35312804100303ce4556c7c954c09e309" translate="yes" xml:space="preserve">
          <source>TypeScriptAdditionalFlags</source>
          <target state="translated">TypeScriptAdditionalFlags</target>
        </trans-unit>
        <trans-unit id="7b5fe2a5e0980eb4438ba0537940cad4dba1cbf4" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowSyntheticDefaultImports</source>
          <target state="translated">TypeScriptAllowSyntheticDefaultImports</target>
        </trans-unit>
        <trans-unit id="a94bfbe88239bd8121e18f907e172dde0a5dee8d" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnreachableCode</source>
          <target state="translated">TypeScriptAllowUnreachableCode</target>
        </trans-unit>
        <trans-unit id="a57b98365d2468c29049e5c8c8ee824604a3fdb7" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnusedLabels</source>
          <target state="translated">TypeScriptAllowUnusedLabels</target>
        </trans-unit>
        <trans-unit id="52c7a27301fde259e8f6bb99fc56cb8133f9b303" translate="yes" xml:space="preserve">
          <source>TypeScriptAlwaysStrict</source>
          <target state="translated">TypeScriptAlwaysStrict</target>
        </trans-unit>
        <trans-unit id="2ed81307b38a7333d37096546abf4a0b57b93c74" translate="yes" xml:space="preserve">
          <source>TypeScriptBaseUrl</source>
          <target state="translated">TypeScriptBaseUrl</target>
        </trans-unit>
        <trans-unit id="77f797b2abb4954f5643abb4b5b80d59868c9236" translate="yes" xml:space="preserve">
          <source>TypeScriptCharset</source>
          <target state="translated">TypeScriptCharset</target>
        </trans-unit>
        <trans-unit id="107cd94d243e6194c069f50feafef3b1230a7556" translate="yes" xml:space="preserve">
          <source>TypeScriptCompileBlocked</source>
          <target state="translated">TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="7acf8c8a12467f8aca42a0fb5a3ef1f764482e71" translate="yes" xml:space="preserve">
          <source>TypeScriptDeclarationDir</source>
          <target state="translated">TypeScriptDeclarationDir</target>
        </trans-unit>
        <trans-unit id="4a2236f58ea00d2b0bb17b6cea7aca0c8a68c053" translate="yes" xml:space="preserve">
          <source>TypeScriptESModuleInterop</source>
          <target state="translated">TypeScriptESModuleInterop</target>
        </trans-unit>
        <trans-unit id="55c811b895566e510d35f99a3a36ec8a3177f330" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitBOM</source>
          <target state="translated">TypeScriptEmitBOM</target>
        </trans-unit>
        <trans-unit id="b2959142651db2ba36f7a76acb1a7cd0464dd2f0" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDeclarationOnly</source>
          <target state="translated">TypeScriptEmitDeclarationOnly</target>
        </trans-unit>
        <trans-unit id="17656226f24afbbb0494dc47d1fdf5cb6aec6e7e" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDecoratorMetadata</source>
          <target state="translated">TypeScriptEmitDecoratorMetadata</target>
        </trans-unit>
        <trans-unit id="f1a24003307b278d63a345cf4646070ee3538d81" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalAsyncFunctions</source>
          <target state="translated">TypeScriptExperimentalAsyncFunctions</target>
        </trans-unit>
        <trans-unit id="f178eb0d68749f84390526fcfcf73643580199b8" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalDecorators</source>
          <target state="translated">TypeScriptExperimentalDecorators</target>
        </trans-unit>
        <trans-unit id="227102f3c5d5c0c4fe35d5a94e14769df56ea3ea" translate="yes" xml:space="preserve">
          <source>TypeScriptForceConsistentCasingInFileNames</source>
          <target state="translated">TypeScriptForceConsistentCasingInFileNames</target>
        </trans-unit>
        <trans-unit id="e8221bda0f5ae2cb80b553adafbf9c7d7eb1ff79" translate="yes" xml:space="preserve">
          <source>TypeScriptGeneratesDeclarations</source>
          <target state="translated">TypeScriptGeneratesDeclarations</target>
        </trans-unit>
        <trans-unit id="12faa091e4a57a36c933420258af4a9f60dccc85" translate="yes" xml:space="preserve">
          <source>TypeScriptImportHelpers</source>
          <target state="translated">TypeScriptImportHelpers</target>
        </trans-unit>
        <trans-unit id="ee1203ba67f873be0ddd284d0922dc4eaed56181" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSourceMap</source>
          <target state="translated">TypeScriptInlineSourceMap</target>
        </trans-unit>
        <trans-unit id="388355e20cca01322235dfa01c312ca0d6781b5a" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSources</source>
          <target state="translated">TypeScriptInlineSources</target>
        </trans-unit>
        <trans-unit id="d77acf48160dec4408ea9726aa2e65d9aca96302" translate="yes" xml:space="preserve">
          <source>TypeScriptIsolatedModules</source>
          <target state="translated">TypeScriptIsolatedModules</target>
        </trans-unit>
        <trans-unit id="956314972e52b72d9e36530ee0a4e72a92acae0b" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXEmit</source>
          <target state="translated">TypeScriptJSXEmit</target>
        </trans-unit>
        <trans-unit id="a67c071d130c25aefdb45b19dfa130ff6bb485ad" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXFactory</source>
          <target state="translated">TypeScriptJSXFactory</target>
        </trans-unit>
        <trans-unit id="37a4427a09452551dd538cba6e5a87a9c65983c9" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXFragmentFactory</source>
          <target state="translated">TypeScriptJSXFragmentFactory</target>
        </trans-unit>
        <trans-unit id="4552cc5179a4f2f2d43bbca69cfe48ae1d8a59ca" translate="yes" xml:space="preserve">
          <source>TypeScriptLib</source>
          <target state="translated">TypeScriptLib</target>
        </trans-unit>
        <trans-unit id="0572909efb507dda301b9d8012fab7e5de772948" translate="yes" xml:space="preserve">
          <source>TypeScriptMapRoot</source>
          <target state="translated">TypeScriptMapRoot</target>
        </trans-unit>
        <trans-unit id="dc7b169788198faee3555056c08f9f57327e0a3f" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleKind</source>
          <target state="translated">TypeScriptModuleKind</target>
        </trans-unit>
        <trans-unit id="421c0ae622f44c1602b14f2b708d2cca0d2934ce" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleResolution</source>
          <target state="translated">TypeScriptModuleResolution</target>
        </trans-unit>
        <trans-unit id="35fa542971e052e37cc4839000b5258adf72a14c" translate="yes" xml:space="preserve">
          <source>TypeScriptNewLine</source>
          <target state="translated">TypeScriptNewLine</target>
        </trans-unit>
        <trans-unit id="fc2a8ef1565c45f435f3d5ef342d1c6dae60cbb5" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitHelpers</source>
          <target state="translated">TypeScriptNoEmitHelpers</target>
        </trans-unit>
        <trans-unit id="e36e19ff5e1f6a8202b09c668028ec57276c68b9" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitOnError</source>
          <target state="translated">TypeScriptNoEmitOnError</target>
        </trans-unit>
        <trans-unit id="5b756225451ecee18834373559b43fedcb96fba8" translate="yes" xml:space="preserve">
          <source>TypeScriptNoFallthroughCasesInSwitch</source>
          <target state="translated">TypeScriptNoFallthroughCasesInSwitch</target>
        </trans-unit>
        <trans-unit id="d92e432f5565e45efa98aec9e0c61f938d26c756" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitAny</source>
          <target state="translated">TypeScriptNoImplicitAny</target>
        </trans-unit>
        <trans-unit id="1c9c8201c130add485ca511eb79ea6e375bc4375" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitReturns</source>
          <target state="translated">TypeScriptNoImplicitReturns</target>
        </trans-unit>
        <trans-unit id="3f55bf3dfa28bf03f3b28f94aa19817851b78cae" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitThis</source>
          <target state="translated">TypeScriptNoImplicitThis</target>
        </trans-unit>
        <trans-unit id="6f256f510247fb48347ab1a84a79bfdc18f35187" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitUseStrict</source>
          <target state="translated">TypeScriptNoImplicitUseStrict</target>
        </trans-unit>
        <trans-unit id="8bd63af2b503b90aadf320b0938c7cc2e9e1080f" translate="yes" xml:space="preserve">
          <source>TypeScriptNoLib</source>
          <target state="translated">TypeScriptNoLib</target>
        </trans-unit>
        <trans-unit id="aba68b0d2bfe600c1b7505f9cf090259fafedf3a" translate="yes" xml:space="preserve">
          <source>TypeScriptNoResolve</source>
          <target state="translated">TypeScriptNoResolve</target>
        </trans-unit>
        <trans-unit id="362c0511319630974131db1f54ca0f8546597ce7" translate="yes" xml:space="preserve">
          <source>TypeScriptNoStrictGenericChecks</source>
          <target state="translated">TypeScriptNoStrictGenericChecks</target>
        </trans-unit>
        <trans-unit id="dfa69886ed42a2dc63f9a0eab77d8450ce96b009" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedLocals</source>
          <target state="translated">TypeScriptNoUnusedLocals</target>
        </trans-unit>
        <trans-unit id="cefd9f6aa4a0ee3b0be73fb43be3ecc77bfe22df" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedParameters</source>
          <target state="translated">TypeScriptNoUnusedParameters</target>
        </trans-unit>
        <trans-unit id="6565a78c53fe02fdb81995bb6c6ec68f1f0ea3bd" translate="yes" xml:space="preserve">
          <source>TypeScriptOutDir</source>
          <target state="translated">TypeScriptOutDir</target>
        </trans-unit>
        <trans-unit id="b14c0569c9dd07bb52cefa5e53a9ee362f59b00f" translate="yes" xml:space="preserve">
          <source>TypeScriptOutFile</source>
          <target state="translated">TypeScriptOutFile</target>
        </trans-unit>
        <trans-unit id="644b7783acc77f0caa187daf9c367ba62b739548" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveConstEnums</source>
          <target state="translated">TypeScriptPreserveConstEnums</target>
        </trans-unit>
        <trans-unit id="44c9e768eb6070e00bdba352e27ce7e68b24160f" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveSymlinks</source>
          <target state="translated">TypeScriptPreserveSymlinks</target>
        </trans-unit>
        <trans-unit id="4130284b0addaca5f98609c12c577055315ad705" translate="yes" xml:space="preserve">
          <source>TypeScriptReactNamespace</source>
          <target state="translated">TypeScriptReactNamespace</target>
        </trans-unit>
        <trans-unit id="373f7134beec8752f28917f8c2d07c6972a8eda7" translate="yes" xml:space="preserve">
          <source>TypeScriptRemoveComments</source>
          <target state="translated">TypeScriptRemoveComments</target>
        </trans-unit>
        <trans-unit id="72de35523759783c4427070755e0bb5453621f68" translate="yes" xml:space="preserve">
          <source>TypeScriptRootDir</source>
          <target state="translated">TypeScriptRootDir</target>
        </trans-unit>
        <trans-unit id="6aa743721c9942df651b926d8a6b9d1d8b06dee1" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipDefaultLibCheck</source>
          <target state="translated">TypeScriptSkipDefaultLibCheck</target>
        </trans-unit>
        <trans-unit id="8bfb0bbce64d6d061521026129b6afc021fdb739" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipLibCheck</source>
          <target state="translated">TypeScriptSkipLibCheck</target>
        </trans-unit>
        <trans-unit id="11cea9751a4427f602e3999e641567437522451c" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceMap</source>
          <target state="translated">TypeScriptSourceMap</target>
        </trans-unit>
        <trans-unit id="981b0099a78995ed3e09e63f3468ae20d833111d" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceRoot</source>
          <target state="translated">TypeScriptSourceRoot</target>
        </trans-unit>
        <trans-unit id="144320f2ae79b3129b36ee19ddeac0b49fefd1cb" translate="yes" xml:space="preserve">
          <source>TypeScriptStrict</source>
          <target state="translated">TypeScriptStrict</target>
        </trans-unit>
        <trans-unit id="dd87b21546d155f9fa69bfbdc72090ba951be0b1" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictFunctionTypes</source>
          <target state="translated">TypeScriptStrictFunctionTypes</target>
        </trans-unit>
        <trans-unit id="a6d54bf19b0c132487ec76f847985482640ea044" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictNullChecks</source>
          <target state="translated">TypeScriptStrictNullChecks</target>
        </trans-unit>
        <trans-unit id="102ce2e8221cdb409f6a7a01055c5b3f52db3b57" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictPropertyInitialization</source>
          <target state="translated">TypeScriptStrictPropertyInitialization</target>
        </trans-unit>
        <trans-unit id="565bf41241b63a69256bebd7801f835b429830df" translate="yes" xml:space="preserve">
          <source>TypeScriptStripInternal</source>
          <target state="translated">TypeScriptStripInternal</target>
        </trans-unit>
        <trans-unit id="558de0db52b8fdbbfefba7315f0e5b368e1bccc8" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressExcessPropertyErrors</source>
          <target state="translated">TypeScriptSuppressExcessPropertyErrors</target>
        </trans-unit>
        <trans-unit id="321f13b1fb2371cd5951fbfd893bddec800abf02" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressImplicitAnyIndexErrors</source>
          <target state="translated">TypeScriptSuppressImplicitAnyIndexErrors</target>
        </trans-unit>
        <trans-unit id="1df2c0c33e87134f7b9585a2fc5c306565947b0c" translate="yes" xml:space="preserve">
          <source>TypeScriptTarget</source>
          <target state="translated">TypeScriptTarget</target>
        </trans-unit>
        <trans-unit id="71d1dceb1918725eab2477bf3bc8195ca94011da" translate="yes" xml:space="preserve">
          <source>TypeScriptUseDefineForClassFields</source>
          <target state="translated">TypeScriptUseDefineForClassFields</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="d69d793fa4b90aab364868879e764b399a806ac0" translate="yes" xml:space="preserve">
          <source>Types - &lt;code&gt;types&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f831a607f5835e209904afa74400f9d95d0c1f0" translate="yes" xml:space="preserve">
          <source>Types as Sets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a23621c19578981ae69a01b97eead68c0765db" translate="yes" xml:space="preserve">
          <source>Types by Inference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34915d42cc54d52a01ea82c5bdce2991a6ef1cbb" translate="yes" xml:space="preserve">
          <source>Types can exist in &lt;em&gt;namespaces&lt;/em&gt;. For example, if we have the declaration &lt;code&gt;let x: A.B.C&lt;/code&gt;, we say that the type &lt;code&gt;C&lt;/code&gt; comes from the &lt;code&gt;A.B&lt;/code&gt; namespace.</source>
          <target state="translated">Los tipos pueden existir en &lt;em&gt;espacios&lt;/em&gt; de &lt;em&gt;nombres&lt;/em&gt; . Por ejemplo, si tenemos la declaraci&amp;oacute;n &lt;code&gt;let x: A.B.C&lt;/code&gt; , decimos que el tipo &lt;code&gt;C&lt;/code&gt; proviene del espacio de nombres &lt;code&gt;A.B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ee9af272b9b52e38ff727c2aeeaf8e298f25123" translate="yes" xml:space="preserve">
          <source>Types in Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4983c5239614810aa77447dfbec17bd7041d4202" translate="yes" xml:space="preserve">
          <source>Types that have a common, singleton type property &amp;mdash; the &lt;em&gt;discriminant&lt;/em&gt;.</source>
          <target state="translated">Tipos que tienen una propiedad com&amp;uacute;n de tipo singleton: el &lt;em&gt;discriminante&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ab7315f529976c1e9046634d7f86b088c404171a" translate="yes" xml:space="preserve">
          <source>Types with a string index signature can be indexed using the &lt;code&gt;[]&lt;/code&gt; notation, but were not allowed to use the &lt;code&gt;.&lt;/code&gt;. Starting with TypeScript 2.2 using either should be allowed.</source>
          <target state="translated">Los tipos con una firma de &amp;iacute;ndice de cadena se pueden indexar usando la notaci&amp;oacute;n &lt;code&gt;[]&lt;/code&gt; , pero no se les permiti&amp;oacute; usar &lt;code&gt;.&lt;/code&gt; . Comenzar con TypeScript 2.2 debe permitirse el uso de cualquiera.</target>
        </trans-unit>
        <trans-unit id="eefc11c2a4fd735c4e7783f6bcfa193306bfe237" translate="yes" xml:space="preserve">
          <source>Typescript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target state="translated">TypeScript toma prestada la sintaxis de conversi&amp;oacute;n de Closure. Esto le permite convertir tipos a otros tipos agregando una etiqueta &lt;code&gt;@type&lt;/code&gt; antes de cualquier expresi&amp;oacute;n entre par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="4c9358fb040ac0e3e60567763fe2b8b87185ed9b" translate="yes" xml:space="preserve">
          <source>Typescript is smart enough to infer the type of things in other contexts as well:</source>
          <target state="translated">La tipografía es lo suficientemente inteligente como para inferir el tipo de cosas en otros contextos también:</target>
        </trans-unit>
        <trans-unit id="aa237f14744bf9c080f4239d70330d26fd6782a1" translate="yes" xml:space="preserve">
          <source>Typically, exporting from a module involves adding properties to a value like &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:</source>
          <target state="translated">Normalmente, exportar desde un m&amp;oacute;dulo implica agregar propiedades a un valor como &lt;code&gt;exports&lt;/code&gt; o &lt;code&gt;module.exports&lt;/code&gt; . TypeScript le permite utilizar declaraciones de exportaci&amp;oacute;n de nivel superior. Por ejemplo, si export&amp;oacute; una funci&amp;oacute;n como esta:</target>
        </trans-unit>
        <trans-unit id="c2df529fd52e531e7ccfbb71ef147f00c590c161" translate="yes" xml:space="preserve">
          <source>Typing the function</source>
          <target state="translated">Escribiendo la función</target>
        </trans-unit>
        <trans-unit id="1184391d4660ab61ecb650550cc662801a4ad10e" translate="yes" xml:space="preserve">
          <source>UMD SimpleModule.js</source>
          <target state="translated">UMD SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="afb3e96e84eea2d4709a70ab3751ff0f583aa243" translate="yes" xml:space="preserve">
          <source>UMD modules</source>
          <target state="translated">Módulos UMD</target>
        </trans-unit>
        <trans-unit id="bf3e09cfd260f3d9900f06488088b667722b7926" translate="yes" xml:space="preserve">
          <source>Uglify</source>
          <target state="translated">Uglify</target>
        </trans-unit>
        <trans-unit id="0a5bbb787c318135c5901c5f8fb697634bd5bb32" translate="yes" xml:space="preserve">
          <source>Uglify compacts your code so that it takes less time to download.</source>
          <target state="translated">Uglify compacta tu código para que lleve menos tiempo descargarlo.</target>
        </trans-unit>
        <trans-unit id="ae386e47ac367ccb8dc289004083400a638ccbc5" translate="yes" xml:space="preserve">
          <source>Ultimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called &amp;ldquo;assertion signatures&amp;rdquo; which model these assertion functions.</source>
          <target state="translated">En &amp;uacute;ltima instancia, el objetivo de TypeScript es escribir las construcciones de JavaScript existentes de la manera menos disruptiva. Por esa raz&amp;oacute;n, TypeScript 3.7 introduce un nuevo concepto llamado &quot;firmas de aserci&amp;oacute;n&quot; que modelan estas funciones de aserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4339e741945b9652bb1d49489e6a98543eef7bb2" translate="yes" xml:space="preserve">
          <source>Uncalled Function Checks</source>
          <target state="translated">Chequeos de función no llamados</target>
        </trans-unit>
        <trans-unit id="180b1f03e6992ccd4fc623bfa5063f77a58ada25" translate="yes" xml:space="preserve">
          <source>Unconditional calls to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">Llamadas incondicionales para &lt;code&gt;require&lt;/code&gt; o &lt;code&gt;define&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b497122fd6b99841feeae2f0b3528acf90c34986" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; function type parameter positions are checked &lt;em&gt;contravariantly&lt;/em&gt; instead of &lt;em&gt;bivariantly&lt;/em&gt;. For some background on what variance means for function types check out &lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;What are covariance and contravariance?&lt;/a&gt;.</source>
          <target state="translated">Bajo &lt;code&gt;--strictFunctionTypes&lt;/code&gt; , las posiciones de los par&amp;aacute;metros de tipo de funci&amp;oacute;n se comprueban de forma &lt;em&gt;contravariable en&lt;/em&gt; lugar de &lt;em&gt;bivariante&lt;/em&gt; . Para obtener algunos antecedentes sobre lo que significa la varianza para los tipos de funciones, consulte &lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;&amp;iquest;Qu&amp;eacute; son la covarianza y la contravarianza? &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2346be489fd11bd810e990b096f9680008f047bd" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; the first assignment is still permitted if &lt;code&gt;compare&lt;/code&gt; was declared as a method. Effectively, &lt;code&gt;T&lt;/code&gt; is bivariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in method parameter positions.</source>
          <target state="translated">En &lt;code&gt;--strictFunctionTypes&lt;/code&gt; , la primera asignaci&amp;oacute;n a&amp;uacute;n est&amp;aacute; permitida si se declar&amp;oacute; &lt;code&gt;compare&lt;/code&gt; como m&amp;eacute;todo. Efectivamente, &lt;code&gt;T&lt;/code&gt; es bivariante en &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; porque se usa solo en las posiciones de los par&amp;aacute;metros del m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="33054f0cbee74c9f788ca4bd77541c3e143d3d3f" translate="yes" xml:space="preserve">
          <source>Under the new &lt;code&gt;--esModuleInterop&lt;/code&gt; these two issues should be addressed:</source>
          <target state="translated">Bajo el nuevo &lt;code&gt;--esModuleInterop&lt;/code&gt; , se deben abordar estos dos problemas:</target>
        </trans-unit>
        <trans-unit id="128561d89ec896d82327b08129ac6710b805e301" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">Entendiendo lo &lt;code&gt;private&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54219e3d20bedb021463636f2132089eb4de56ba" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">Entendiendo &lt;code&gt;protected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfc76f54e044a62bc08d7f563732d6c4137e806c" translate="yes" xml:space="preserve">
          <source>Understanding Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb57f5cf2c9525393089f7f613c8715146826b2" translate="yes" xml:space="preserve">
          <source>Understanding TypeScript&amp;rsquo;s &lt;code&gt;private&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23e9d7d02cff72c54df81048c1a4380b98b0319" translate="yes" xml:space="preserve">
          <source>Understanding private</source>
          <target state="translated">Entendiendo lo privado</target>
        </trans-unit>
        <trans-unit id="95841ad8022df544f75a9cb58504b9e361799465" translate="yes" xml:space="preserve">
          <source>Understanding protected</source>
          <target state="translated">Comprensión protegida</target>
        </trans-unit>
        <trans-unit id="ce277cc9234cfe2b86b777dd92906ff2f86a4ffc" translate="yes" xml:space="preserve">
          <source>Understanding the sample</source>
          <target state="translated">Comprensión de la muestra</target>
        </trans-unit>
        <trans-unit id="b8046695cbb07b887254bfc5fba8b62777baab42" translate="yes" xml:space="preserve">
          <source>Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.</source>
          <target state="translated">Entender lo que se crea con cada declaración le ayudará a entender lo que se fusiona cuando se realiza una fusión de declaraciones.</target>
        </trans-unit>
        <trans-unit id="b6d31265a9d2bb701584804cfe2084c1e863a4e3" translate="yes" xml:space="preserve">
          <source>Unfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.</source>
          <target state="translated">Desafortunadamente en TypeScript estas comprobaciones nunca pudieron ser codificadas correctamente.Para el código suelto esto significaba que TypeScript revisaba menos,y para el código ligeramente conservador a menudo forzaba a los usuarios a usar afirmaciones de tipo.</target>
        </trans-unit>
        <trans-unit id="f5ac25ede763c83433a3b880f5f3fc5c401f7ac2" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;--declaration&lt;/code&gt; didn&amp;rsquo;t work with the &lt;code&gt;--allowJs&lt;/code&gt; flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn&amp;rsquo;t use the &lt;code&gt;--declaration&lt;/code&gt; flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!</source>
          <target state="translated">Desafortunadamente, &lt;code&gt;--declaration&lt;/code&gt; no funcion&amp;oacute; con la &lt;code&gt;--allowJs&lt;/code&gt; , que permite mezclar archivos de entrada de TypeScript y JavaScript. Esta fue una limitaci&amp;oacute;n frustrante porque significaba que los usuarios no pod&amp;iacute;an usar la &lt;code&gt;--declaration&lt;/code&gt; al migrar bases de c&amp;oacute;digo, incluso si ten&amp;iacute;an anotaciones JSDoc. TypeScript 3.7 cambia eso y permite que las dos opciones se usen juntas.</target>
        </trans-unit>
        <trans-unit id="90407376a294ed45dab6024b8ace72b1f1a4f495" translate="yes" xml:space="preserve">
          <source>Unfortunately, mapped types like the &lt;code&gt;Readonly&lt;/code&gt; utility type were effectively no-ops on array and tuple types.</source>
          <target state="translated">Desafortunadamente, los tipos mapeados como el tipo de utilidad &lt;code&gt;Readonly&lt;/code&gt; eran efectivamente no operativos en tipos de matriz y tupla.</target>
        </trans-unit>
        <trans-unit id="c9f9b24434ff80b111bededc5c17e2eb1610c1fc" translate="yes" xml:space="preserve">
          <source>Unfortunately, the type of &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is still &lt;code&gt;any&lt;/code&gt;. That&amp;rsquo;s because &lt;code&gt;this&lt;/code&gt; comes from the function expression inside the object literal. To fix this, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">Desafortunadamente, el tipo de &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; sigue siendo &lt;code&gt;any&lt;/code&gt; . Eso es porque &lt;code&gt;this&lt;/code&gt; viene de la expresi&amp;oacute;n de la funci&amp;oacute;n dentro del objeto literal. Para solucionar este problema, se puede proporcionar un expl&amp;iacute;cito &lt;code&gt;this&lt;/code&gt; par&amp;aacute;metro. &lt;code&gt;this&lt;/code&gt; par&amp;aacute;metros son par&amp;aacute;metros falsos que aparecen primero en la lista de par&amp;aacute;metros de una funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e53ce54f63b88cf452ded6201871a14783c0be8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, this means that constructor functions that are also callable cannot use &lt;code&gt;@constructor&lt;/code&gt;.</source>
          <target state="translated">Desafortunadamente, esto significa que las funciones de constructor que tambi&amp;eacute;n son invocables no pueden usar &lt;code&gt;@constructor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da9748783613337de4d74ee2abacadcb4e991578" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:</source>
          <target state="translated">Lamentablemente,aunque esta parecía ser la dirección hacia la que se dirigía la propuesta en sus primeros días,hay una gran posibilidad de que los campos de clase pública se estandaricen de manera diferente.En su lugar,la muestra de código original podría necesitar desazucararse a algo más cercano a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b582e2c337ad84d8772f97cd78414fbed01f687b" translate="yes" xml:space="preserve">
          <source>Unicode codepoint escapes in strings</source>
          <target state="translated">El punto de código del Unicode se escapa en cuerdas</target>
        </trans-unit>
        <trans-unit id="d0fec623da4b84453812e1c4c0b17b0a532ec7d4" translate="yes" xml:space="preserve">
          <source>Union Exhaustiveness checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">Tipos de unión</target>
        </trans-unit>
        <trans-unit id="b7ed90cee7078e9ede776e2d455827cd6c390d7b" translate="yes" xml:space="preserve">
          <source>Union enums and enum member types</source>
          <target state="translated">La Unión enumera y enumera los tipos de miembros</target>
        </trans-unit>
        <trans-unit id="aba2f05474229fdcd9d1da33808bf8c11dd33d17" translate="yes" xml:space="preserve">
          <source>Union type subtype reduction only removes a class type if it is a subclass of &lt;em&gt;and&lt;/em&gt; derives from another class type in the union.</source>
          <target state="translated">La reducci&amp;oacute;n de subtipos de tipo de uni&amp;oacute;n solo elimina un tipo de clase si es una subclase de &lt;em&gt;y&lt;/em&gt; deriva de otro tipo de clase en la uni&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">Tipos de unión</target>
        </trans-unit>
        <trans-unit id="56de4c1005168da2654053cbc54188220ab6bb4f" translate="yes" xml:space="preserve">
          <source>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</source>
          <target state="translated">Los tipos de unión también permiten una mejor inferencia de tipos en matrices y otros lugares donde se pueden tener múltiples tipos de valores en una colección:</target>
        </trans-unit>
        <trans-unit id="3e7108953bcfc1c7c0311e2518816a93bc306b40" translate="yes" xml:space="preserve">
          <source>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a &lt;code&gt;string&lt;/code&gt;, a &lt;code&gt;string[]&lt;/code&gt; or a function that returns a &lt;code&gt;string&lt;/code&gt;. You can now write:</source>
          <target state="translated">Los tipos de uni&amp;oacute;n son una forma poderosa de expresar un valor que puede ser de varios tipos. Por ejemplo, puede tener una API para ejecutar un programa que toma una l&amp;iacute;nea de comando como una &lt;code&gt;string&lt;/code&gt; , una &lt;code&gt;string[]&lt;/code&gt; o una funci&amp;oacute;n que devuelve una &lt;code&gt;string&lt;/code&gt; . Ahora puedes escribir:</target>
        </trans-unit>
        <trans-unit id="70635a04ab9351bca09c5621dffee8f76929cc2c" translate="yes" xml:space="preserve">
          <source>Union types are an advanced topic that we&amp;rsquo;ll cover in a later chapter.</source>
          <target state="translated">Los tipos de uni&amp;oacute;n son un tema avanzado que cubriremos en un cap&amp;iacute;tulo posterior.</target>
        </trans-unit>
        <trans-unit id="3fa5955704db38dbb3e16e34ca92691e9ea2bbf5" translate="yes" xml:space="preserve">
          <source>Union types are closely related to intersection types, but they are used very differently. Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="translated">Los tipos de uni&amp;oacute;n est&amp;aacute;n estrechamente relacionados con los tipos de intersecci&amp;oacute;n, pero se usan de manera muy diferente. Ocasionalmente, se encontrar&amp;aacute; con una biblioteca que espera que un par&amp;aacute;metro sea un &lt;code&gt;number&lt;/code&gt; o una &lt;code&gt;string&lt;/code&gt; . Por ejemplo, tome la siguiente funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cd921c2ea01c32f5a34e452b767384ff1f31852e" translate="yes" xml:space="preserve">
          <source>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a &lt;code&gt;Fish&lt;/code&gt;? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</source>
          <target state="translated">Los tipos de uni&amp;oacute;n son &amp;uacute;tiles para modelar situaciones en las que los valores pueden superponerse en los tipos que pueden asumir. &amp;iquest;Qu&amp;eacute; sucede cuando necesitamos saber espec&amp;iacute;ficamente si tenemos un &lt;code&gt;Fish&lt;/code&gt; ? Un modismo com&amp;uacute;n en JavaScript para diferenciar entre dos valores posibles es verificar la presencia de un miembro. Como mencionamos, solo puede acceder a miembros que est&amp;eacute;n garantizados en todos los constituyentes de un tipo de sindicato.</target>
        </trans-unit>
        <trans-unit id="d4d68a0298812ddd887befc8ebd536a465311e12" translate="yes" xml:space="preserve">
          <source>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to. If a value has the type &lt;code&gt;A | B&lt;/code&gt;, we only know for &lt;em&gt;certain&lt;/em&gt; that it has members that both &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;B&lt;/code&gt; have. In this example, &lt;code&gt;Bird&lt;/code&gt; has a member named &lt;code&gt;fly&lt;/code&gt;. We can&amp;rsquo;t be sure whether a variable typed as &lt;code&gt;Bird | Fish&lt;/code&gt; has a &lt;code&gt;fly&lt;/code&gt; method. If the variable is really a &lt;code&gt;Fish&lt;/code&gt; at runtime, then calling &lt;code&gt;pet.fly()&lt;/code&gt; will fail.</source>
          <target state="translated">Los tipos de uni&amp;oacute;n pueden ser un poco complicados aqu&amp;iacute;, pero solo se necesita un poco de intuici&amp;oacute;n para acostumbrarse. Si un valor tiene el tipo &lt;code&gt;A | B&lt;/code&gt; , s&amp;oacute;lo saber con &lt;em&gt;certeza&lt;/em&gt; que tiene miembros que ambos &lt;code&gt;A&lt;/code&gt; &lt;em&gt;y &lt;/em&gt; &lt;code&gt;B&lt;/code&gt; tienen. En este ejemplo, &lt;code&gt;Bird&lt;/code&gt; tiene un miembro llamado &lt;code&gt;fly&lt;/code&gt; . No podemos estar seguros de si una variable escrita como &lt;code&gt;Bird | Fish&lt;/code&gt; tiene un m&amp;eacute;todo de &lt;code&gt;fly&lt;/code&gt; . Si la variable es realmente un &lt;code&gt;Fish&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n, la llamada a &lt;code&gt;pet.fly()&lt;/code&gt; fallar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="00002b164c08859d5a15579e55c8f17ce6478546" translate="yes" xml:space="preserve">
          <source>Unions</source>
          <target state="translated">Unions</target>
        </trans-unit>
        <trans-unit id="f48468b06a9e4516b5c97a2b05c0405b665a11bd" translate="yes" xml:space="preserve">
          <source>Unions and Intersection Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a013266da3448b7cdbeb6ae12b743b8431bc0dc9" translate="yes" xml:space="preserve">
          <source>Unions provide a way to handle different types too. For example, you may have a function that takes an &lt;code&gt;array&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716232e9652a75720d14510144c825017458f7cc" translate="yes" xml:space="preserve">
          <source>Unions with Common Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec354f7a8e237dd28115d025f20f869218004ad" translate="yes" xml:space="preserve">
          <source>Unit types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9003e1fae84a4609d6b8fb77cb5eb2556e480e27" translate="yes" xml:space="preserve">
          <source>Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; has the type &lt;code&gt;&quot;foo&quot;&lt;/code&gt;. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7819b34ff87570745fbe461e36a16f80e562ce" translate="yes" xml:space="preserve">
          <source>Unknown</source>
          <target state="translated">Unknown</target>
        </trans-unit>
        <trans-unit id="ece8b3c6faf7510538396ff92255b9fc5deb4014" translate="yes" xml:space="preserve">
          <source>Unless you take specific measures to avoid it, the internal state of a &lt;code&gt;const&lt;/code&gt; variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are &lt;code&gt;readonly&lt;/code&gt;. The &lt;a href=&quot;interfaces&quot;&gt;chapter on Interfaces&lt;/a&gt; has the details.</source>
          <target state="translated">A menos que tome medidas espec&amp;iacute;ficas para evitarlo, el estado interno de una variable &lt;code&gt;const&lt;/code&gt; a&amp;uacute;n es modificable. Afortunadamente, TypeScript le permite especificar que los miembros de un objeto sean de &lt;code&gt;readonly&lt;/code&gt; . El &lt;a href=&quot;interfaces&quot;&gt;cap&amp;iacute;tulo sobre interfaces&lt;/a&gt; tiene los detalles.</target>
        </trans-unit>
        <trans-unit id="c861cf88ebb1a5b494f6992b73222db7fff28246" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;re really trying to take advantage of JavaScript&amp;rsquo;s runtime behavior in a clever way, it&amp;rsquo;s advised that you don&amp;rsquo;t do this.</source>
          <target state="translated">A menos que realmente est&amp;eacute; tratando de aprovechar el comportamiento en tiempo de ejecuci&amp;oacute;n de JavaScript de una manera inteligente, se recomienda que no lo haga.</target>
        </trans-unit>
        <trans-unit id="84b3e4863aee46ac562de68360e58df6ef13bb83" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;unknown&lt;/code&gt;, variables of type &lt;code&gt;any&lt;/code&gt; allow you to access arbitrary properties, even ones that don&amp;rsquo;t exist. These properties include functions and TypeScript will not check their existence or type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f45df55b8eab061b85101f488f9a767624cd64" translate="yes" xml:space="preserve">
          <source>Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading &lt;code&gt;|&lt;/code&gt; is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c675fd40f67f1744d7a77a8ad4c15f4daebdc18" translate="yes" xml:space="preserve">
          <source>Unlike JSDoc&amp;rsquo;s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;mdash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1461542d00d5010806839c20e64aa1678fdff5" translate="yes" xml:space="preserve">
          <source>Unlike JSDoc&amp;rsquo;s type system, Typescript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;ndash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target state="translated">A diferencia del sistema de tipos de JSDoc, Typescript solo le permite marcar tipos que contienen nulos o no. No existe una no nulabilidad expl&amp;iacute;cita: si strictNullChecks est&amp;aacute; activado, el &lt;code&gt;number&lt;/code&gt; no admite nulos . Si est&amp;aacute; desactivado, el &lt;code&gt;number&lt;/code&gt; es anulable.</target>
        </trans-unit>
        <trans-unit id="51985852906766cae660d6a12174c73de43d98b6" translate="yes" xml:space="preserve">
          <source>Unlike plain optional parameters, default-initialized parameters don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass &lt;code&gt;undefined&lt;/code&gt; to get the default initialized value. For example, we could write our last example with only a default initializer on &lt;code&gt;firstName&lt;/code&gt;:</source>
          <target state="translated">A diferencia de los par&amp;aacute;metros opcionales simples, los par&amp;aacute;metros inicializados por defecto no &lt;em&gt;necesitan&lt;/em&gt; ocurrir despu&amp;eacute;s de los par&amp;aacute;metros requeridos. Si un par&amp;aacute;metro inicializado predeterminado viene antes de un par&amp;aacute;metro obligatorio, los usuarios deben pasar expl&amp;iacute;citamente &lt;code&gt;undefined&lt;/code&gt; para obtener el valor inicializado predeterminado. Por ejemplo, podr&amp;iacute;amos escribir nuestro &amp;uacute;ltimo ejemplo con solo un inicializador predeterminado en &lt;code&gt;firstName&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b497f9d0d5c2c4f2547035f0fcd80ba5746c84a" translate="yes" xml:space="preserve">
          <source>Unreachable code</source>
          <target state="translated">Código inalcanzable</target>
        </trans-unit>
        <trans-unit id="1d0500c74b8aa49d1d2f3d7c0b7c86b3a9d2a921" translate="yes" xml:space="preserve">
          <source>Unspecified type parameters default to &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">Los par&amp;aacute;metros de tipo no especificado est&amp;aacute;n predeterminados a &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c849b45ea75a8c2321b502c7837adbcdc9a6ff" translate="yes" xml:space="preserve">
          <source>Unsupported tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1948c97816d203ebc2f90700d76faedc4fbbccfe" translate="yes" xml:space="preserve">
          <source>Untyped imports</source>
          <target state="translated">Importaciones no cifradas</target>
        </trans-unit>
        <trans-unit id="42a377f570d337b6d69100d6ff55ff5b9e97a424" translate="yes" xml:space="preserve">
          <source>Unused labels</source>
          <target state="translated">Etiquetas no utilizadas</target>
        </trans-unit>
        <trans-unit id="950c29b1f717e4fff1d2a159fa44b64e58240c0f" translate="yes" xml:space="preserve">
          <source>Unused labels are also flagged. Just like unreachable code checks, these are turned on by default; use &lt;code&gt;--allowUnusedLabels&lt;/code&gt; to stop reporting these errors.</source>
          <target state="translated">Las etiquetas no utilizadas tambi&amp;eacute;n se marcan. Al igual que las comprobaciones de c&amp;oacute;digo inalcanzable, estas est&amp;aacute;n activadas de forma predeterminada; use &lt;code&gt;--allowUnusedLabels&lt;/code&gt; para dejar de informar de estos errores.</target>
        </trans-unit>
        <trans-unit id="3ea5ca14dc52b9bd423f61c07136cde4865d6a52" translate="yes" xml:space="preserve">
          <source>Up to this point, we&amp;rsquo;ve only talked about the &lt;em&gt;instance&lt;/em&gt; members of the class, those that show up on the object when it&amp;rsquo;s instantiated. We can also create &lt;em&gt;static&lt;/em&gt; members of a class, those that are visible on the class itself rather than on the instances. In this example, we use &lt;code&gt;static&lt;/code&gt; on the origin, as it&amp;rsquo;s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending &lt;code&gt;this.&lt;/code&gt; in front of instance accesses, here we prepend &lt;code&gt;Grid.&lt;/code&gt; in front of static accesses.</source>
          <target state="translated">Hasta este punto, solo hemos hablado de los miembros de &lt;em&gt;instancia&lt;/em&gt; de la clase, los que aparecen en el objeto cuando se crea una instancia. Tambi&amp;eacute;n podemos crear miembros &lt;em&gt;est&amp;aacute;ticos&lt;/em&gt; de una clase, aquellos que son visibles en la propia clase en lugar de en las instancias. En este ejemplo, usamos &lt;code&gt;static&lt;/code&gt; en el origen, ya que es un valor general para todas las cuadr&amp;iacute;culas. Cada instancia accede a este valor anteponiendo el nombre de la clase. Similar a anteponer &lt;code&gt;this.&lt;/code&gt; delante de los accesos de instancia, aqu&amp;iacute; anteponemos &lt;code&gt;Grid.&lt;/code&gt; frente a accesos est&amp;aacute;ticos.</target>
        </trans-unit>
        <trans-unit id="ad67feee99a0f439a0e27027c5ea3dcbcf7ff3d4" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;.vscode/settings.json&lt;/code&gt; with the following:</source>
          <target state="translated">Actualice &lt;code&gt;.vscode/settings.json&lt;/code&gt; con lo siguiente:</target>
        </trans-unit>
        <trans-unit id="0c453d2caa8ecb4d47c7c21d916dd5de2c9571a9" translate="yes" xml:space="preserve">
          <source>Update project file to include locally installed &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (at the top) and &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (at the bottom) files:</source>
          <target state="translated">Actualice el archivo del proyecto para incluir los archivos &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (en la parte superior) y &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (en la parte inferior) instalados localmente :</target>
        </trans-unit>
        <trans-unit id="61ef22d6991101f4978ea02b3e277ed08f8a02ed" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;Settings - User&lt;/code&gt; file with the following:</source>
          <target state="translated">Actualice la &lt;code&gt;Settings - User&lt;/code&gt; archivo de usuario con lo siguiente:</target>
        </trans-unit>
        <trans-unit id="8b2b612f6daeee72c04fac6bf2b62e95619d91d9" translate="yes" xml:space="preserve">
          <source>Updating your IDE to use the nightly builds</source>
          <target state="translated">Actualizando tu IDE para usar las construcciones nocturnas</target>
        </trans-unit>
        <trans-unit id="baadd0b4691cd923997ea6041f0a70f9d9c1d58d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;--jsxFactory&lt;/code&gt;&lt;/a&gt; instead. Specify the object invoked for &lt;code&gt;createElement&lt;/code&gt; when targeting &lt;code&gt;react&lt;/code&gt; for TSX files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396d021a8d5ef888effc1abd9236b7f66ab50d42" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#outFile&quot;&gt;outFile&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794a3710c02b705cb8176f0ebe766dee147dd40c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#skipLibCheck&quot;&gt;&lt;code&gt;--skipLibCheck&lt;/code&gt;&lt;/a&gt; instead. Skip type checking of default library declaration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd29d9aedccf4abdd9f95da49e8b3e269208158" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a820b114f9666c422cc3a7015e046eea0e5ef5f7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc2e4b6eb759a2e235283631204f80eaa19dc57" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">Use &lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt; si su m&amp;oacute;dulo se puede &lt;em&gt;construir&lt;/em&gt; usando &lt;code&gt;new&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dcb83b510816e0232e4eea4a6e8821858e1d88cf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="translated">Use &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; si su m&amp;oacute;dulo se puede &lt;em&gt;llamar&lt;/em&gt; como una funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9135ad666eb865ef0f03b22c777b4833dda580f4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--pretty false&lt;/code&gt; on the command line or set &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt; to disable &lt;code&gt;--pretty&lt;/code&gt; output.</source>
          <target state="translated">Use &lt;code&gt;--pretty false&lt;/code&gt; en la l&amp;iacute;nea de comando o establezca &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; en su &lt;code&gt;tsconfig.json&lt;/code&gt; para deshabilitar la salida &lt;code&gt;--pretty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d777cba827da4d9bd0a80b90d7cc7d35bc7eb763" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare class&lt;/code&gt; to describe a class or class-like object. Classes can have properties and methods as well as a constructor.</source>
          <target state="translated">Utilice &lt;code&gt;declare class&lt;/code&gt; para describir una clase o un objeto similar a una clase. Las clases pueden tener propiedades y m&amp;eacute;todos, adem&amp;aacute;s de un constructor.</target>
        </trans-unit>
        <trans-unit id="1d25646e3d1c96527dec663a49cd97e0a677f024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare function&lt;/code&gt; to declare functions.</source>
          <target state="translated">Utilice &lt;code&gt;declare function&lt;/code&gt; para declarar funciones.</target>
        </trans-unit>
        <trans-unit id="dc5e87631ffbf23b795c1170d5135c6525f91882" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare namespace&lt;/code&gt; to describe types or values accessed by dotted notation.</source>
          <target state="translated">Utilice &lt;code&gt;declare namespace&lt;/code&gt; de nombres para describir los tipos o valores a los que se accede mediante notaci&amp;oacute;n con puntos.</target>
        </trans-unit>
        <trans-unit id="646cf6b60f19ec39b9a348c993659c06af5ff17e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare var&lt;/code&gt; to declare variables. If the variable is read-only, you can use &lt;code&gt;declare const&lt;/code&gt;. You can also use &lt;code&gt;declare let&lt;/code&gt; if the variable is block-scoped.</source>
          <target state="translated">Utilice &lt;code&gt;declare var&lt;/code&gt; para declarar variables. Si la variable es de solo lectura, puede usar &lt;code&gt;declare const&lt;/code&gt; . Tambi&amp;eacute;n puede usar &lt;code&gt;declare let&lt;/code&gt; si la variable tiene un alcance de bloque.</target>
        </trans-unit>
        <trans-unit id="fc7b733452effbd68c17f48699824b764aa4d5c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; to watch directories and child directories</source>
          <target state="translated">Use &lt;code&gt;fs.watch&lt;/code&gt; para ver directorios y directorios secundarios</target>
        </trans-unit>
        <trans-unit id="a20558d88b96350c2a6617d2a8806bb939c26e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; which uses file system events (but might not be accurate on different OS) to get the notifications for the file changes/creation/deletion. Note that few OS eg. linux has limit on number of watches and failing to create watcher using &lt;code&gt;fs.watch&lt;/code&gt; will result it in creating using &lt;code&gt;fs.watchFile&lt;/code&gt;</source>
          <target state="translated">Use &lt;code&gt;fs.watch&lt;/code&gt; , que usa eventos del sistema de archivos (pero puede que no sea preciso en diferentes sistemas operativos) para recibir las notificaciones de los cambios / creaci&amp;oacute;n / eliminaci&amp;oacute;n del archivo. Tenga en cuenta que pocos sistemas operativos, por ejemplo. linux tiene un l&amp;iacute;mite en el n&amp;uacute;mero de relojes y si no se crea un observador con &lt;code&gt;fs.watch&lt;/code&gt; , se &lt;code&gt;fs.watchFile&lt;/code&gt; con fs.watchFile</target>
        </trans-unit>
        <trans-unit id="b8a0ecc46b3020c85d683ef9e7bfc225a06e140d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; but use different polling intervals for source files, config files and missing files</source>
          <target state="translated">Use &lt;code&gt;fs.watchFile&lt;/code&gt; pero use diferentes intervalos de sondeo para archivos de origen, archivos de configuraci&amp;oacute;n y archivos faltantes</target>
        </trans-unit>
        <trans-unit id="d9b3f25a00b42d34692eae633c97a930b3ef45c2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; to watch the directories and child directories which is a polling watch (consuming CPU cycles)</source>
          <target state="translated">Use &lt;code&gt;fs.watchFile&lt;/code&gt; para ver los directorios y los directorios secundarios, que es un reloj de sondeo (que consume ciclos de CPU)</target>
        </trans-unit>
        <trans-unit id="b82d02e810b66cfc5287f1002d1703389ec9f322" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; as an explicit type annotation instead, or do not add a type annotation as done in the example above.</source>
          <target state="translated">Use &lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; como una anotaci&amp;oacute;n de tipo expl&amp;iacute;cita en su lugar, o no agregue una anotaci&amp;oacute;n de tipo como se hizo en el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="6e4e750a17d76a60f93d2129a4bfe65128e56bdc" translate="yes" xml:space="preserve">
          <source>Use Define For Class Fields - &lt;code&gt;useDefineForClassFields&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c797e1ab4188af4e8f2f348f9d4813348e879b0b" translate="yes" xml:space="preserve">
          <source>Use JSDoc &lt;code&gt;@augments&lt;/code&gt; to specify the types explicitly. for instance:</source>
          <target state="translated">Utilice JSDoc &lt;code&gt;@augments&lt;/code&gt; para especificar los tipos expl&amp;iacute;citamente. por ejemplo:</target>
        </trans-unit>
        <trans-unit id="26914e7e48730258a108abb453430cd3518851d2" translate="yes" xml:space="preserve">
          <source>Use Optional Parameters</source>
          <target state="translated">Usar los parámetros opcionales</target>
        </trans-unit>
        <trans-unit id="1f551ab7cd042c6186f08b5016c6fbb015348adf" translate="yes" xml:space="preserve">
          <source>Use Union Types</source>
          <target state="translated">Usar los tipos de unión</target>
        </trans-unit>
        <trans-unit id="c6e9ca22aa2af3128ca0dfccc6ca984b9a53e2f4" translate="yes" xml:space="preserve">
          <source>Use a dynamic queue where in the frequently modified files will be polled at shorter interval and the files unchanged will be polled less frequently</source>
          <target state="translated">Usar una cola dinámica en la que en los archivos frecuentemente modificados se sondee a intervalos más cortos y los archivos no modificados se sondeen con menos frecuencia</target>
        </trans-unit>
        <trans-unit id="b6bcaab1110f17c72658c24deb9f410172d12ea7" translate="yes" xml:space="preserve">
          <source>Use a type assertion (i.e. &lt;code&gt;opts as Options&lt;/code&gt;).</source>
          <target state="translated">Utilice una aserci&amp;oacute;n de tipo (es decir, &lt;code&gt;opts as Options&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c373f04992cf46cf315a11d0cfd773d124512011" translate="yes" xml:space="preserve">
          <source>Use an &lt;code&gt;interface&lt;/code&gt; to define a type with properties.</source>
          <target state="translated">Utilice una &lt;code&gt;interface&lt;/code&gt; para definir un tipo con propiedades.</target>
        </trans-unit>
        <trans-unit id="de6bf5682731fffe8d17a1a2893ad0e0e875fbd9" translate="yes" xml:space="preserve">
          <source>Use comma or multiple tags to declare multiple type parameters:</source>
          <target state="translated">Utilice la coma o varias etiquetas para declarar los parámetros de tipos múltiples:</target>
        </trans-unit>
        <trans-unit id="813eb2c164fdf97484adee07af475b49c979cbf5" translate="yes" xml:space="preserve">
          <source>Use destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets &lt;em&gt;really&lt;/em&gt; hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.</source>
          <target state="translated">Utilice la desestructuraci&amp;oacute;n con cuidado. Como demuestra el ejemplo anterior, todo lo que no sea la expresi&amp;oacute;n de desestructuraci&amp;oacute;n m&amp;aacute;s simple es confuso. Esto es especialmente cierto con la desestructuraci&amp;oacute;n profundamente anidada, que se vuelve &lt;em&gt;realmente&lt;/em&gt; dif&amp;iacute;cil de entender incluso sin acumular cambios de nombre, valores predeterminados y anotaciones de tipo. Trate de que las expresiones de desestructuraci&amp;oacute;n sean peque&amp;ntilde;as y simples. Siempre puede escribir las asignaciones que la desestructuraci&amp;oacute;n generar&amp;iacute;a usted mismo.</target>
        </trans-unit>
        <trans-unit id="84ca1d512ea34e66413a09bf03aea43da1cd5e61" translate="yes" xml:space="preserve">
          <source>Use dynamic polling queue to poll changes to the directory and child directories.</source>
          <target state="translated">Usar la cola de votación dinámica para sondear los cambios en el directorio y en los directorios infantiles.</target>
        </trans-unit>
        <trans-unit id="476bd570b1cb323c844b457111807cf0bfe14c03" translate="yes" xml:space="preserve">
          <source>Use namespaces to organize types.</source>
          <target state="translated">Usar espacios de nombres para organizar los tipos.</target>
        </trans-unit>
        <trans-unit id="a7fb2226e7d1637c125b100d2ae8ebe1ff2bbb66" translate="yes" xml:space="preserve">
          <source>Use returned values from super calls as &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">Utilice valores devueltos de super llamadas como 'esto'</target>
        </trans-unit>
        <trans-unit id="4281cb2734b20854fad7ce1621ef834a4a1b4e65" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;global-plugin-d-ts&quot;&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674fffd874755fee3353fca4923c07272aaa239e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec0cfa03e45ca3f1d25fc09af8034cc6ba3a098" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">Utilice la plantilla &lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt; &lt;code&gt;global-modifying-module.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f66cc8b895d213df6b8e2c503e64c2fdad1da70f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-modifying-module.d.ts.md&quot;&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467a1132d18100a2fea14dea179fb807cc8c9786" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">Utilice la plantilla &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt; &lt;code&gt;global-plugin.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ded88ccc850f489f2c1db682f66acc6ce6e89c02" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">Utilice la plantilla &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d00f93f8ed19c310af833f02b233f61189f29867" translate="yes" xml:space="preserve">
          <source>Use the namespace import pattern if you&amp;rsquo;re importing a large number of things</source>
          <target state="translated">Utilice el patr&amp;oacute;n de importaci&amp;oacute;n del espacio de nombres si est&amp;aacute; importando una gran cantidad de cosas</target>
        </trans-unit>
        <trans-unit id="181dfdffa543aacf139786370fa1942354e5e0e8" translate="yes" xml:space="preserve">
          <source>Use the specified end of line sequence to be used when emitting files: &lt;code&gt;&quot;crlf&quot;&lt;/code&gt; (windows) or &lt;code&gt;&quot;lf&quot;&lt;/code&gt; (unix).&amp;rdquo;</source>
          <target state="translated">Utilice la secuencia de final de l&amp;iacute;nea especificada que se utilizar&amp;aacute; al emitir archivos: &lt;code&gt;&quot;crlf&quot;&lt;/code&gt; (windows) o &lt;code&gt;&quot;lf&quot;&lt;/code&gt; (unix) &quot;.</target>
        </trans-unit>
        <trans-unit id="991f181fa1f670d03fe9e8348c63df208559c8f3" translate="yes" xml:space="preserve">
          <source>Use the template &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5dbc74cf020a727ea7578eaadc331456e2cdd0" translate="yes" xml:space="preserve">
          <source>Use these directives only when you&amp;rsquo;re authoring a &lt;code&gt;d.ts&lt;/code&gt; file by hand.</source>
          <target state="translated">Utilice estas directivas solo cuando est&amp;eacute; creando un archivo &lt;code&gt;d.ts&lt;/code&gt; a mano.</target>
        </trans-unit>
        <trans-unit id="3c9eac17e15f70b4957575dc44afd54e3e8ed5d8" translate="yes" xml:space="preserve">
          <source>Use your best judgement, and if applicable, consult the matter with the rest of your team.</source>
          <target state="translated">Use su mejor juicio,y si es aplicable,consulte el asunto con el resto de su equipo.</target>
        </trans-unit>
        <trans-unit id="2adb0f1b976920901a418d9f6d757aa6988d5b84" translate="yes" xml:space="preserve">
          <source>Used to output diagnostic information for debugging. This command is a subset of &lt;a href=&quot;#extendedDiagnostics&quot;&gt;&lt;code&gt;extendedDiagnostics&lt;/code&gt;&lt;/a&gt; which are more user-facing results, and easier to interpret.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e789822c27891d496e2d1c824f3137fc0a60e8" translate="yes" xml:space="preserve">
          <source>User Combinations</source>
          <target state="translated">Combinaciones de usuarios</target>
        </trans-unit>
        <trans-unit id="6db409b39dc46fb85822ac1924c1fb876244cc1a" translate="yes" xml:space="preserve">
          <source>User-Defined Type Guards</source>
          <target state="translated">Guardias de tipo definido por el usuario</target>
        </trans-unit>
        <trans-unit id="d8895e69c18f832a3dc18dc0b25ac0287a552c83" translate="yes" xml:space="preserve">
          <source>User-defined type guard functions</source>
          <target state="translated">Funciones de protección de tipo definidas por el usuario</target>
        </trans-unit>
        <trans-unit id="865aa2eab27a2eebc9f8c1b7ee2b45dba99a5722" translate="yes" xml:space="preserve">
          <source>Users can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; syntax), and are directly nested either your own modules, or in another top level ambient external module.</source>
          <target state="translated">Los usuarios ahora pueden declarar cualquier aumento que quieran hacer, o que otros consumidores ya hayan hecho, a un m&amp;oacute;dulo existente. Los aumentos de m&amp;oacute;dulos se ven como declaraciones simples de m&amp;oacute;dulos ambientales antiguos (es decir, la sintaxis &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; ), y se anidan directamente en sus propios m&amp;oacute;dulos o en otro m&amp;oacute;dulo externo ambiental de nivel superior.</target>
        </trans-unit>
        <trans-unit id="b92638c4a093946ffe782b9c6ea843146edd2d04" translate="yes" xml:space="preserve">
          <source>Users can now ensure that the type system will catch such errors. Here&amp;rsquo;s our new &lt;code&gt;AnimationOptions&lt;/code&gt; using string literal types:</source>
          <target state="translated">Los usuarios ahora pueden asegurarse de que el sistema de tipos detectar&amp;aacute; tales errores. Aqu&amp;iacute; est&amp;aacute;n nuestras nuevas &lt;code&gt;AnimationOptions&lt;/code&gt; usando tipos de literal de cadena:</target>
        </trans-unit>
        <trans-unit id="971fc6da1fad26d48864984a1a77ed97685d4f3a" translate="yes" xml:space="preserve">
          <source>Users using newer versions of TS, will see a prompt to upgrade their project on first load.</source>
          <target state="translated">Los usuarios que usen las nuevas versiones de TS,verán un aviso para actualizar su proyecto en la primera carga.</target>
        </trans-unit>
        <trans-unit id="076baa79ca77082f0ca2b3320f7136b88d1a143c" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;rootDirs&amp;rsquo;, you can inform the compiler of the &lt;em&gt;roots&lt;/em&gt; making up this &amp;ldquo;virtual&amp;rdquo; directory; and thus the compiler can resolve relative modules imports within these &amp;ldquo;virtual&amp;rdquo; directories &lt;em&gt;as if&lt;/em&gt; were merged together in one directory.</source>
          <target state="translated">Usando 'rootDirs', puede informar al compilador de las &lt;em&gt;ra&amp;iacute;ces&lt;/em&gt; que componen este directorio &quot;virtual&quot;; y as&amp;iacute; el compilador puede resolver las importaciones de m&amp;oacute;dulos relativos dentro de estos directorios &quot;virtuales&quot; &lt;em&gt;como si&lt;/em&gt; estuvieran fusionados en un directorio.</target>
        </trans-unit>
        <trans-unit id="9c907fc236b5576ec4b9496e0b00bbfb71e593bd" translate="yes" xml:space="preserve">
          <source>Using --noResolve</source>
          <target state="translated">Usando --noResolve</target>
        </trans-unit>
        <trans-unit id="fea016f48554330486c9c94e60974382dcd30124" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.</source>
          <target state="translated">El uso de &lt;code&gt;&quot;paths&quot;&lt;/code&gt; tambi&amp;eacute;n permite mapeos m&amp;aacute;s sofisticados que incluyen m&amp;uacute;ltiples ubicaciones de respaldo. Considere la configuraci&amp;oacute;n de un proyecto en el que solo algunos m&amp;oacute;dulos est&amp;aacute;n disponibles en una ubicaci&amp;oacute;n y el resto en otra.</target>
        </trans-unit>
        <trans-unit id="42ba4227d3af5762437561f59f30ce6a1e5f2260" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</source>
          <target state="translated">El uso de &lt;code&gt;&quot;paths&quot;&lt;/code&gt; tambi&amp;eacute;n permite mapeos m&amp;aacute;s sofisticados que incluyen m&amp;uacute;ltiples ubicaciones de respaldo. Considere la configuraci&amp;oacute;n de un proyecto en el que solo algunos m&amp;oacute;dulos est&amp;aacute;n disponibles en una ubicaci&amp;oacute;n y el resto en otra. Un paso de construcci&amp;oacute;n los pondr&amp;iacute;a a todos juntos en un solo lugar. El dise&amp;ntilde;o del proyecto puede verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="06cd012e6c788da38d72b27da1a7bbf3bef7051d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--noResolve&lt;/code&gt;</source>
          <target state="translated">Usando &lt;code&gt;--noResolve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3bbb6573d95fdc85524c7db21fa164109d78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;// @ts-check&lt;/code&gt; in a JavaScript file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afa8edba85ebf100416b76304f95c6450f3141c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">Usar &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; en uno de los archivos de una compilaci&amp;oacute;n es equivalente a compilar con &lt;code&gt;--lib es2017.string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e4933f2a2e7814cc135c9b1388e792cdd66475c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from&lt;/code&gt; clause a module can copy the exports of a given module to the current module without introducing local names.</source>
          <target state="translated">El uso &lt;code&gt;from&lt;/code&gt; cl&amp;aacute;usula from de un m&amp;oacute;dulo puede copiar las exportaciones de un m&amp;oacute;dulo determinado al m&amp;oacute;dulo actual sin introducir nombres locales.</target>
        </trans-unit>
        <trans-unit id="37a797ad92e300fcb869331595d2c4e343d74dfd" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.</source>
          <target state="translated">El uso de &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; en una anotaci&amp;oacute;n de tipo permite acceder a un m&amp;oacute;dulo y acceder a su declaraci&amp;oacute;n exportada sin importarlo.</target>
        </trans-unit>
        <trans-unit id="72074f269aec1329aae7105fabf958e05d5c07ed" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;instanceof&lt;/code&gt; with classes and union types:</source>
          <target state="translated">Usando &lt;code&gt;instanceof&lt;/code&gt; con clases y tipos de uni&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="111256c2f12b3cd232c38c44c986dfdd41c62efb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;rootDirs&lt;/code&gt;, you can inform the compiler that there are many &amp;ldquo;virtual&amp;rdquo; directories acting as a single root. This allows the compiler to resolve relative module imports within these &amp;ldquo;virtual&amp;rdquo; directories, as if they were merged in to one directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdc800bcd35f72f5dd0659132e5a66ef820079a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; is quite a drastic approach. It is recommended to use a &lt;code&gt;@ts-ignore&lt;/code&gt; comment instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd8860cf6465e1b2bdf45812f3f39ab68cf98e0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;tsconfig.json&lt;/code&gt; or &lt;code&gt;jsconfig.json&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3148c33827558727523c9ea9ec8a97850719dfe8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; to test a variable:</source>
          <target state="translated">Usando &lt;code&gt;typeof&lt;/code&gt; para probar una variable:</target>
        </trans-unit>
        <trans-unit id="3512c5d8c5a6f92bc7eb3bc3316fb1091e9fc207" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; with union types and &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">Usando &lt;code&gt;typeof&lt;/code&gt; con tipos de uni&amp;oacute;n y &lt;code&gt;else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d577340ac4bb94fb9a7eb6e17e1355af2faee1e" translate="yes" xml:space="preserve">
          <source>Using API</source>
          <target state="translated">Usando el API</target>
        </trans-unit>
        <trans-unit id="87b350fddfa272510c3726ee54b4b05350ba043d" translate="yes" xml:space="preserve">
          <source>Using Babel with TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea338f92c90962e364abdd73770a9a8e0a22f76" translate="yes" xml:space="preserve">
          <source>Using Class Types in Generics</source>
          <target state="translated">Uso de los tipos de clase en los genéricos</target>
        </trans-unit>
        <trans-unit id="43300137282de05306e305d02f5a4e3a4a8e2d0d" translate="yes" xml:space="preserve">
          <source>Using Command Line Interface</source>
          <target state="translated">Uso de la interfaz de la línea de comandos</target>
        </trans-unit>
        <trans-unit id="8b74d8a06cce7b65888ba4e8c7818fe0688bd9a8" translate="yes" xml:space="preserve">
          <source>Using Modules</source>
          <target state="translated">Usando módulos</target>
        </trans-unit>
        <trans-unit id="c5dfdd934dc02ab2c210cf3f3003872dcd3d25e6" translate="yes" xml:space="preserve">
          <source>Using Namespaces</source>
          <target state="translated">Usando espacios de nombres</target>
        </trans-unit>
        <trans-unit id="2340df0448163b853367fed9720dff6a29c60ae1" translate="yes" xml:space="preserve">
          <source>Using NuGet with MSBuild</source>
          <target state="translated">Usando NuGet con MSBuild</target>
        </trans-unit>
        <trans-unit id="547f3d366f6ba6dbebb442ff52e5209ac22bfe3d" translate="yes" xml:space="preserve">
          <source>Using React</source>
          <target state="translated">Usando Reaccionar</target>
        </trans-unit>
        <trans-unit id="d7491bb32b4d14f757fef9c824559f69f7177e06" translate="yes" xml:space="preserve">
          <source>Using Type Guards, you can easily work with a variable of a union type:</source>
          <target state="translated">Usando los guardias de tipo,puedes trabajar fácilmente con una variable de un tipo de unión:</target>
        </trans-unit>
        <trans-unit id="eccd06efc2831f9179398ffcb9ce80cec01c9e63" translate="yes" xml:space="preserve">
          <source>Using Type Parameters in Generic Constraints</source>
          <target state="translated">Uso de los parámetros de tipo en las restricciones genéricas</target>
        </trans-unit>
        <trans-unit id="bb7c0204b1637ead9e29a3786a6bee30ee0e9071" translate="yes" xml:space="preserve">
          <source>Using TypeScript in several environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba60f8a349037067c0634dc31a0ac923864cdd8c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">El uso de &lt;code&gt;baseUrl&lt;/code&gt; es una pr&amp;aacute;ctica com&amp;uacute;n en aplicaciones que usan cargadores de m&amp;oacute;dulos AMD donde los m&amp;oacute;dulos se &amp;ldquo;implementan&amp;rdquo; en una sola carpeta en tiempo de ejecuci&amp;oacute;n. Se supone que todas las importaciones de m&amp;oacute;dulos con nombres no relativos son relativas a &lt;code&gt;baseUrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb2a81ce273392d8c282cd088fcd0585336e4cfd" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. The sources of these modules can live in different directories, but a build script will put them all together.</source>
          <target state="translated">El uso de &lt;code&gt;baseUrl&lt;/code&gt; es una pr&amp;aacute;ctica com&amp;uacute;n en aplicaciones que usan cargadores de m&amp;oacute;dulos AMD donde los m&amp;oacute;dulos se &amp;ldquo;implementan&amp;rdquo; en una sola carpeta en tiempo de ejecuci&amp;oacute;n. Las fuentes de estos m&amp;oacute;dulos pueden vivir en diferentes directorios, pero un script de compilaci&amp;oacute;n los pondr&amp;aacute; todos juntos.</target>
        </trans-unit>
        <trans-unit id="b5e01fea434d511ae7f89196d33d7e8c07fa0679" translate="yes" xml:space="preserve">
          <source>Using a class as an interface</source>
          <target state="translated">Usar una clase como interfaz</target>
        </trans-unit>
        <trans-unit id="b21dff09db83d498fc08fa858a2c6f95c4bc7857" translate="yes" xml:space="preserve">
          <source>Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:</source>
          <target state="translated">El uso de un enum es sencillo:basta con acceder a cualquier miembro como propiedad del propio enum,y declarar los tipos utilizando el nombre del enum:</target>
        </trans-unit>
        <trans-unit id="e8cff08e29703580b7ac86809f0f79615642a204" translate="yes" xml:space="preserve">
          <source>Using npm</source>
          <target state="translated">Usando npm</target>
        </trans-unit>
        <trans-unit id="f97748b0bee558e2605da416afdbef74fd01695b" translate="yes" xml:space="preserve">
          <source>Using other JSX frameworks</source>
          <target state="translated">Usando otros marcos JSX</target>
        </trans-unit>
        <trans-unit id="5c78cf487464fa0e7c06524cc2aed76314129a78" translate="yes" xml:space="preserve">
          <source>Using target &lt;code&gt;--target ES2016&lt;/code&gt; will instruct the compiler not to transform ES2016-specific features, e.g. &lt;code&gt;**&lt;/code&gt; operator.</source>
          <target state="translated">El uso de target &lt;code&gt;--target ES2016&lt;/code&gt; le indicar&amp;aacute; al compilador que no transforme caracter&amp;iacute;sticas espec&amp;iacute;ficas de ES2016, por ejemplo, &lt;code&gt;**&lt;/code&gt; operador.</target>
        </trans-unit>
        <trans-unit id="c2bbd5627cb0ada9bd95ef8d96473ec05f861c62" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property</source>
          <target state="translated">Usando la propiedad &lt;code&gt;&quot;files&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd019ddcfa9a356cc6a71911adc51d98cc08a82d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties</source>
          <target state="translated">Usar las propiedades &lt;code&gt;&quot;include&quot;&lt;/code&gt; y &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9ecf041c00e73da91e933f322f297654272ffc" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">Usando el operador &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f1886e62dc25a8ce4c42a8a5cea86b655977fa4" translate="yes" xml:space="preserve">
          <source>Using the CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd12de5962e5ab568b3c5a067da105ee87fe5e16" translate="yes" xml:space="preserve">
          <source>Using this TSConfig:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05695053496c73d09b9080abbb8ddbcec5718d22" translate="yes" xml:space="preserve">
          <source>Using this ability, &lt;code&gt;lib.d.ts&lt;/code&gt; now has a new &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; type. This type strips &lt;code&gt;?&lt;/code&gt; modifiers from all properties of &lt;code&gt;T&lt;/code&gt;, thus making all properties required.</source>
          <target state="translated">Con esta capacidad, &lt;code&gt;lib.d.ts&lt;/code&gt; ahora tiene un nuevo tipo &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; . &amp;iquest;Este tipo de tiras &lt;code&gt;?&lt;/code&gt; modificadores de todas las propiedades de &lt;code&gt;T&lt;/code&gt; , por lo que se requieren todas las propiedades.</target>
        </trans-unit>
        <trans-unit id="6f3cf80ca63760070e6103046db8653a28ce64e1" translate="yes" xml:space="preserve">
          <source>Using tsconfig.json</source>
          <target state="translated">Usando tsconfig.json</target>
        </trans-unit>
        <trans-unit id="e3ff1e8a9c36f6f4750c05884c5f542d5a46249b" translate="yes" xml:space="preserve">
          <source>Using type predicates</source>
          <target state="translated">Usando predicados de tipo</target>
        </trans-unit>
        <trans-unit id="3601427971630988ad2755ef28a7717d757f3df8" translate="yes" xml:space="preserve">
          <source>Using with &lt;code&gt;export =&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;</source>
          <target state="translated">Utilizando con &lt;code&gt;export =&lt;/code&gt; o &lt;code&gt;import&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">Tipos de utilidad</target>
        </trans-unit>
        <trans-unit id="9f89751a678d7643787dbd16a9f2d25d5880c644" translate="yes" xml:space="preserve">
          <source>VS Code has the ability for a extension to &lt;a href=&quot;https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins&quot;&gt;automatically include language service plugins&lt;/a&gt;, and so you may have some running in your editor without needing to define them in your &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdf32ce970b80477ef67d464ba5d9d15cfb327c" translate="yes" xml:space="preserve">
          <source>Validation.ts</source>
          <target state="translated">Validation.ts</target>
        </trans-unit>
        <trans-unit id="524163f0faa0530bac2b1baaeb887189c9c73216" translate="yes" xml:space="preserve">
          <source>Validators in a single file</source>
          <target state="translated">Los validadores en un solo archivo</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="5a0535139a31a774a3c9068d34adc7058d5bf642" translate="yes" xml:space="preserve">
          <source>Value of &lt;em&gt;baseUrl&lt;/em&gt; is determined as either:</source>
          <target state="translated">El valor de &lt;em&gt;baseUrl&lt;/em&gt; se determina como:</target>
        </trans-unit>
        <trans-unit id="577084450a5e984b5f6966940c5dcc148307a726" translate="yes" xml:space="preserve">
          <source>Value-based elements</source>
          <target state="translated">Elementos basados en valores</target>
        </trans-unit>
        <trans-unit id="3f2f78c89fa82d18f5843ae8eee30d072a82336b" translate="yes" xml:space="preserve">
          <source>Value-based elements are simply looked up by identifiers that are in scope.</source>
          <target state="translated">Los elementos basados en valores son simplemente buscados por los identificadores que están en alcance.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="d79ccf393d6a199b4ad9ea5944ca607bfd113cf4" translate="yes" xml:space="preserve">
          <source>Var-args parameter declaration inferred from use of &lt;code&gt;arguments&lt;/code&gt;</source>
          <target state="translated">Declaraci&amp;oacute;n de par&amp;aacute;metros var-args inferida del uso de &lt;code&gt;arguments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="5ae56dde19ee92722af581b79a15e413c188460b" translate="yes" xml:space="preserve">
          <source>Variable Declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532e17316f9909fba79f94428471eb6888d1b255" translate="yes" xml:space="preserve">
          <source>Variable Declarations</source>
          <target state="translated">Declaraciones variables</target>
        </trans-unit>
        <trans-unit id="b3912d587e9569bb7bfd495613a05ef2130c8e37" translate="yes" xml:space="preserve">
          <source>Variable capturing quirks</source>
          <target state="translated">Las peculiaridades de la captura de variables</target>
        </trans-unit>
        <trans-unit id="7c09718bb5da0232e2044986eb3a280f493f26a9" translate="yes" xml:space="preserve">
          <source>Variables declared in a &lt;code&gt;catch&lt;/code&gt; clause also have similar scoping rules.</source>
          <target state="translated">Las variables declaradas en una cl&amp;aacute;usula &lt;code&gt;catch&lt;/code&gt; tambi&amp;eacute;n tienen reglas de alcance similares.</target>
        </trans-unit>
        <trans-unit id="b11bd74b68068c8cda414d69c145cdd12377e1bb" translate="yes" xml:space="preserve">
          <source>Version selection with &lt;code&gt;typesVersions&lt;/code&gt;</source>
          <target state="translated">Selecci&amp;oacute;n de versi&amp;oacute;n con &lt;code&gt;typesVersions&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4133624045854a306b02e62768cbf604af93f40f" translate="yes" xml:space="preserve">
          <source>Via npm (the Node.js package manager)</source>
          <target state="translated">A través de npm (el administrador de paquetes Node.js)</target>
        </trans-unit>
        <trans-unit id="bbef03a29ac970d4beb2f168015277f559e746e0" translate="yes" xml:space="preserve">
          <source>Virtual Directories with &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target state="translated">Directorios virtuales con &lt;code&gt;rootDirs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd7f9c3ff1ebf06a17bf0502aaa043bb8f017fe6" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 and 2015</source>
          <target state="translated">Visual Studio 2013 y 2015</target>
        </trans-unit>
        <trans-unit id="023fa801554be0ffd9cb5b6327c0e269a7154d1a" translate="yes" xml:space="preserve">
          <source>Visual Studio 2015 and Visual Studio 2013 Update 2 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2015 y Visual Studio 2013 Update 2 incluyen TypeScript de forma predeterminada. Si no instal&amp;oacute; TypeScript con Visual Studio, a&amp;uacute;n puede &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;descargarlo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="353b01045c518e21b3e08d0cee10940ef65c683f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2017 y Visual Studio 2015 Update 3 incluyen TypeScript de forma predeterminada. Si no instal&amp;oacute; TypeScript con Visual Studio, a&amp;uacute;n puede &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;descargarlo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4bd86a16fcf22eb738bf2f6614ab69242ef036b" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">Código de estudio visual</target>
        </trans-unit>
        <trans-unit id="a54600c66809939b059f9682e260da90c5cc8595" translate="yes" xml:space="preserve">
          <source>Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.</source>
          <target state="translated">Visual Studio debería empezar a instalar gulp and del tan pronto como guarde el archivo.Si no,haz clic con el botón derecho del ratón en package.json y luego en Restore Packages.</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="1e2aae0cdb6f3a79d62e669c768545f8953beef6" translate="yes" xml:space="preserve">
          <source>Watch Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369e965336691b4254b406f11997b3fb8754eafe" translate="yes" xml:space="preserve">
          <source>Watchify</source>
          <target state="translated">Watchify</target>
        </trans-unit>
        <trans-unit id="4306cbf1196af02448fb51c54f07ce1e5c41ddbb" translate="yes" xml:space="preserve">
          <source>Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.</source>
          <target state="translated">Watchify comienza a tragar y lo mantiene funcionando,compilando gradualmente cada vez que guardas un archivo.Esto te permite mantener un ciclo de editar-guardar-actualizar en el navegador.</target>
        </trans-unit>
        <trans-unit id="2e4ac287a7b8a6ec87dd3885f171fdb1cb26939c" translate="yes" xml:space="preserve">
          <source>Watchify, Babel, and Uglify</source>
          <target state="translated">Vigilar,Babel,y Uglificar</target>
        </trans-unit>
        <trans-unit id="f89058c451cdea76e04b5f0c00e5ff23bd62a1b8" translate="yes" xml:space="preserve">
          <source>We added two overload signatures to &lt;code&gt;myCoolFunction&lt;/code&gt;. The first checks states that &lt;code&gt;myCoolFunction&lt;/code&gt; takes a function (which takes a &lt;code&gt;number&lt;/code&gt;), and then a list of &lt;code&gt;number&lt;/code&gt;s. The second one says that it will take a function as well, and then uses a rest parameter (&lt;code&gt;...nums&lt;/code&gt;) to state that any number of arguments after that need to be &lt;code&gt;number&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;myCoolFunction&lt;/code&gt; dos firmas de sobrecarga a myCoolFunction . La primera comprobaci&amp;oacute;n indica que &lt;code&gt;myCoolFunction&lt;/code&gt; toma una funci&amp;oacute;n (que toma un &lt;code&gt;number&lt;/code&gt; ) y luego una lista de &lt;code&gt;number&lt;/code&gt; . El segundo dice que tambi&amp;eacute;n tomar&amp;aacute; una funci&amp;oacute;n, y luego usa un par&amp;aacute;metro de descanso ( &lt;code&gt;...nums&lt;/code&gt; ) para indicar que cualquier n&amp;uacute;mero de argumentos despu&amp;eacute;s de ese debe ser el &lt;code&gt;number&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="906c596e0e9e46a347b462739c927291c09ad640" translate="yes" xml:space="preserve">
          <source>We also disable the project properties page when you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file. This means that all configuration changes have to be made in the &lt;code&gt;tsconfig.json&lt;/code&gt; file itself.</source>
          <target state="translated">Tambi&amp;eacute;n deshabilitamos la p&amp;aacute;gina de propiedades del proyecto cuando agrega un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; . Esto significa que todos los cambios de configuraci&amp;oacute;n deben realizarse en el &lt;code&gt;tsconfig.json&lt;/code&gt; archivo tsconfig.json .</target>
        </trans-unit>
        <trans-unit id="862f52cc171b96bf071e122091285af320650575" translate="yes" xml:space="preserve">
          <source>We also have an &lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.epub&quot;&gt;epub&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.pdf&quot;&gt;pdf&lt;/a&gt; version of the Handbook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce7ec51558a4620670481cd3447782aedb45ad7" translate="yes" xml:space="preserve">
          <source>We also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let&amp;rsquo;s modify &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n necesitamos tener el objetivo de TypeScript ES2015. Luego, Babel producir&amp;aacute; ES5 a partir del c&amp;oacute;digo ES2015 que emite TypeScript. Modifiquemos &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb158a631eeb5215d7f9b41d49e937425bf4888b" translate="yes" xml:space="preserve">
          <source>We are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;Declaration Reference&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca6da16584407722c05c582e9312d4b12506c7e" translate="yes" xml:space="preserve">
          <source>We assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">Suponemos que ya est&amp;aacute; usando &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; con &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dccbace9aee63165dc6770bfacb34962fe498a76" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">Llamamos a las declaraciones que no definen una implementaci&amp;oacute;n &quot;ambiente&quot;. Normalmente, estos se definen en archivos &lt;code&gt;.d.ts&lt;/code&gt; . Si est&amp;aacute; familiarizado con C / C ++, puede considerarlos como archivos &lt;code&gt;.h&lt;/code&gt; . Veamos algunos ejemplos.</target>
        </trans-unit>
        <trans-unit id="92c076044fe3078a3a2d956ae660fa0b4723354a" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically, these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">Llamamos a las declaraciones que no definen una implementaci&amp;oacute;n &quot;ambiente&quot;. Normalmente, estos se definen en archivos &lt;code&gt;.d.ts&lt;/code&gt; . Si est&amp;aacute; familiarizado con C / C ++, puede considerarlos como archivos &lt;code&gt;.h&lt;/code&gt; . Veamos algunos ejemplos.</target>
        </trans-unit>
        <trans-unit id="d7554b9ee0145ef5796d9b34e5b993a1e04de397" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; to log to the console.</source>
          <target state="translated">LlamamoswatchBrowserify.on &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; para iniciar sesi&amp;oacute;n en la consola.</target>
        </trans-unit>
        <trans-unit id="5dedc9b8f5d0ca8dda8092dbf79a3b7121e6221e" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; so that Browserify will run the &lt;code&gt;bundle&lt;/code&gt; function every time one of your TypeScript files changes.</source>
          <target state="translated">LlamamoswatchBrowserify.on &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; para que Browserify ejecute la funci&amp;oacute;n de &lt;code&gt;bundle&lt;/code&gt; cada vez que cambie uno de sus archivos de TypeScript.</target>
        </trans-unit>
        <trans-unit id="d78c8a7db971a258629029d93d5ac32c8f9a6480" translate="yes" xml:space="preserve">
          <source>We can add additional members to an &lt;code&gt;interface&lt;/code&gt; with another &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target state="translated">Podemos agregar miembros adicionales a una &lt;code&gt;interface&lt;/code&gt; con otra declaraci&amp;oacute;n de &lt;code&gt;interface&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="72346222530ba2a9b0966af45f7d0245b45ebadb" translate="yes" xml:space="preserve">
          <source>We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.</source>
          <target state="translated">Podemos añadir tipos a cada uno de los parámetros y luego a la propia función para añadir un tipo de retorno.TypeScript puede calcular el tipo de retorno mirando las declaraciones de retorno,así que también podemos dejar esto opcionalmente en muchos casos.</target>
        </trans-unit>
        <trans-unit id="3ffa5dba257543828c847bbd33acb3e1bdc1db72" translate="yes" xml:space="preserve">
          <source>We can also declare a variable inside of a function:</source>
          <target state="translated">También podemos declarar una variable dentro de una función:</target>
        </trans-unit>
        <trans-unit id="661d963b4beb85aa27dfba66adb8817f5f2d18c5" translate="yes" xml:space="preserve">
          <source>We can also explicitly give type information to the function&amp;rsquo;s argument to override any contextual type:</source>
          <target state="translated">Tambi&amp;eacute;n podemos dar informaci&amp;oacute;n de tipo expl&amp;iacute;citamente al argumento de la funci&amp;oacute;n para anular cualquier tipo contextual:</target>
        </trans-unit>
        <trans-unit id="eaa8774bff1b83856163130bd5db5fa1d1e6c687" translate="yes" xml:space="preserve">
          <source>We can also have a type alias refer to itself in a property:</source>
          <target state="translated">También podemos tener un tipo de alias que se refiera a sí mismo en una propiedad:</target>
        </trans-unit>
        <trans-unit id="a869a9aafbfef91521e95e5db94bb387cae93e3a" translate="yes" xml:space="preserve">
          <source>We can also write the generic type as a call signature of an object literal type:</source>
          <target state="translated">También podemos escribir el tipo genérico como una firma de llamada de un tipo literal de objeto:</target>
        </trans-unit>
        <trans-unit id="658e04fc9fb0e75106204a24f2c9d06bdf8f78c2" translate="yes" xml:space="preserve">
          <source>We can alternatively write the sample example this way:</source>
          <target state="translated">Podemos escribir el ejemplo de la muestra de esta manera:</target>
        </trans-unit>
        <trans-unit id="ff36204ad2dc388ad3938b7f629d5c14ff6e7faf" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@configurable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">Podemos definir el decorador &lt;code&gt;@configurable&lt;/code&gt; usando la siguiente declaraci&amp;oacute;n de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="82bc383c0b279737360de0b5872e4eaf53cabffa" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@enumerable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">Podemos definir el decorador &lt;code&gt;@enumerable&lt;/code&gt; usando la siguiente declaraci&amp;oacute;n de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="7089db4e18a0f27d1d43d048ff6a50fbd3dce944" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@sealed&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">Podemos definir el decorador &lt;code&gt;@sealed&lt;/code&gt; usando la siguiente declaraci&amp;oacute;n de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9b791fa8333e00451d101fd617a6f57b865394fd" translate="yes" xml:space="preserve">
          <source>We can extend the existing module like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d89086425b5ee284135e15deb90e23ed2590c7" translate="yes" xml:space="preserve">
          <source>We can fix this by making sure the function is bound to the correct &lt;code&gt;this&lt;/code&gt; before we return the function to be used later. This way, regardless of how it&amp;rsquo;s later used, it will still be able to see the original &lt;code&gt;deck&lt;/code&gt; object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the &lt;code&gt;this&lt;/code&gt; where the function is created rather than where it is invoked:</source>
          <target state="translated">Podemos solucionar esto asegur&amp;aacute;ndonos de que la funci&amp;oacute;n est&amp;eacute; vinculada al correcto &lt;code&gt;this&lt;/code&gt; antes de devolver la funci&amp;oacute;n para usarla m&amp;aacute;s adelante. De esta manera, independientemente de c&amp;oacute;mo se use m&amp;aacute;s tarde, a&amp;uacute;n podr&amp;aacute; ver el objeto de la &lt;code&gt;deck&lt;/code&gt; original . Para hacer esto, cambiamos la expresi&amp;oacute;n de la funci&amp;oacute;n para usar la sintaxis de flecha ECMAScript 6. Arrow funciones de captura de la &lt;code&gt;this&lt;/code&gt; donde se crea la funci&amp;oacute;n en lugar de en el que se invoca:</target>
        </trans-unit>
        <trans-unit id="c6ea0d2b6b5f45da1e1324a08cfc0e11b786897c" translate="yes" xml:space="preserve">
          <source>We can see this in action in the following example:</source>
          <target state="translated">Podemos ver esto en acción en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="65140ca83fcc5d0530859c1beb185464ff42f37a" translate="yes" xml:space="preserve">
          <source>We can see this more clearly in this example:</source>
          <target state="translated">Podemos ver esto más claramente en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="ee21326f232b62bacd8134f20c57de98fb355244" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@format&lt;/code&gt; decorator and &lt;code&gt;getFormat&lt;/code&gt; functions using the following function declarations:</source>
          <target state="translated">Entonces podemos definir el &lt;code&gt;@format&lt;/code&gt; decorador y &lt;code&gt;getFormat&lt;/code&gt; funciones usando las siguientes declaraciones de funciones:</target>
        </trans-unit>
        <trans-unit id="bd3c3bda45ff67c029de2e2368aec01e7ef3a4eb" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@required&lt;/code&gt; and &lt;code&gt;@validate&lt;/code&gt; decorators using the following function declarations:</source>
          <target state="translated">Luego podemos definir los decoradores &lt;code&gt;@required&lt;/code&gt; y &lt;code&gt;@validate&lt;/code&gt; usando las siguientes declaraciones de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="db549ad2d4eebb5605913a990e51c4ee29c07c32" translate="yes" xml:space="preserve">
          <source>We can use this information to record metadata about the property, as in the following example:</source>
          <target state="translated">Podemos utilizar esta información para registrar metadatos sobre la propiedad,como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="ea01d2c138e3b5218d8e1d52564f033747bdd0ce" translate="yes" xml:space="preserve">
          <source>We can write a decorator factory in the following fashion:</source>
          <target state="translated">Podemos escribir una fábrica de decorados de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="171a94c1fd6a31b533d269529646e906879fde4e" translate="yes" xml:space="preserve">
          <source>We can write the same example again, this time using an interface to describe the requirement of having the &lt;code&gt;label&lt;/code&gt; property that is a string:</source>
          <target state="translated">Podemos escribir el mismo ejemplo nuevamente, esta vez usando una interfaz para describir el requisito de tener la propiedad de &lt;code&gt;label&lt;/code&gt; que es una cadena:</target>
        </trans-unit>
        <trans-unit id="d0f35bfcf99e7f68867547c0414c1be9551ec721" translate="yes" xml:space="preserve">
          <source>We could also add a namespaced type to a class:</source>
          <target state="translated">También podríamos añadir un tipo de ritmo de nombre a una clase:</target>
        </trans-unit>
        <trans-unit id="f1593c28383f7f19b9f300464de36e13bda32294" translate="yes" xml:space="preserve">
          <source>We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.</source>
          <target state="translated">También podríamos haber usado un nombre diferente para el parámetro de tipo genérico en el tipo,siempre y cuando el número de variables de tipo y cómo se usan las variables de tipo se alineen.</target>
        </trans-unit>
        <trans-unit id="81879f8730c017d5576f5e7bef1f5b5dd6185843" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using &lt;code&gt;// @ts-ignore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae12050685d86d62a3f9d2765b3b1a3a61021e1" translate="yes" xml:space="preserve">
          <source>We frequently see the question &amp;ldquo;Should I learn JavaScript or TypeScript?&amp;ldquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a79655a0f6dc78edf29c467dcf807b7ee04905" translate="yes" xml:space="preserve">
          <source>We just imported our &lt;code&gt;Hello&lt;/code&gt; component into &lt;code&gt;index.tsx&lt;/code&gt;. Notice that unlike with &lt;code&gt;&quot;react&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt;, we used a &lt;em&gt;relative path&lt;/em&gt; to &lt;code&gt;Hello.tsx&lt;/code&gt; - this is important. If we hadn&amp;rsquo;t, TypeScript would&amp;rsquo;ve instead tried looking in our &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">Acabamos de importar nuestro componente &lt;code&gt;Hello&lt;/code&gt; a &lt;code&gt;index.tsx&lt;/code&gt; . Observe que, a diferencia de &lt;code&gt;&quot;react&quot;&lt;/code&gt; o &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt; , usamos una &lt;em&gt;ruta relativa&lt;/em&gt; a &lt;code&gt;Hello.tsx&lt;/code&gt; ; esto es importante. Si no lo hubi&amp;eacute;ramos hecho, TypeScript habr&amp;iacute;a intentado buscar en nuestra carpeta &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fbc60a8f3964107caa151501b90a1aec6061763" translate="yes" xml:space="preserve">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content &amp;ndash; e.g. from the user &amp;ndash; or we may want to intentionally accept all values in our API. In these cases, we want to provide a type that tells the compiler and future readers that this variable could be anything, so we give it the &lt;code&gt;unknown&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b6c237e5c56a0727a6cedbb2962b0899558457" translate="yes" xml:space="preserve">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, we want to opt-out of type checking and let the values pass through compile-time checks. To do so, we label these with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">Es posible que necesitemos describir el tipo de variables que no conocemos cuando estamos escribiendo una aplicaci&amp;oacute;n. Estos valores pueden provenir de contenido din&amp;aacute;mico, por ejemplo, del usuario o de una biblioteca de terceros. En estos casos, queremos excluirnos de la verificaci&amp;oacute;n de tipos y dejar que los valores pasen por las verificaciones en tiempo de compilaci&amp;oacute;n. Para hacerlo, los etiquetamos con &lt;code&gt;any&lt;/code&gt; tipo:</target>
        </trans-unit>
        <trans-unit id="7e0b762a7d5b6b35f90cd8500631ccf9ab22b8c1" translate="yes" xml:space="preserve">
          <source>We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;NPM Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">Necesitamos configurar NPM para que se puedan descargar los paquetes de JavaScript. Haga clic derecho en el proyecto y seleccione &lt;strong&gt;Nuevo elemento&lt;/strong&gt; . Luego, elija &lt;strong&gt;Archivo de configuraci&amp;oacute;n de NPM&lt;/strong&gt; y use el nombre predeterminado de &lt;code&gt;package.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc466c22e7712a5cff2da5cf89c0cc81b64e2a7" translate="yes" xml:space="preserve">
          <source>We owe a big thanks to GitHub user &lt;a href=&quot;https://github.com/jwbay&quot;&gt;@jwbay&lt;/a&gt; who took the initiative to create a &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;proof-of-concept&lt;/a&gt; and iterated to provide us with with &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;the current version&lt;/a&gt;.</source>
          <target state="translated">Le debemos un gran agradecimiento al usuario de GitHub &lt;a href=&quot;https://github.com/jwbay&quot;&gt;@jwbay,&lt;/a&gt; quien tom&amp;oacute; la iniciativa de crear una &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;prueba de concepto&lt;/a&gt; e iter&amp;oacute; para proporcionarnos &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;la versi&amp;oacute;n actual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="894e0a020d31c47096948e05d4d7e1a77b0f6785" translate="yes" xml:space="preserve">
          <source>We owe a large thanks to community members &lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Wenlu Wang&lt;/a&gt; and &lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Titian Cernicova Dragomir&lt;/a&gt; for implementing this feature! For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;check out their pull request&lt;/a&gt; and &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;the nullish coalescing proposal repository&lt;/a&gt;.</source>
          <target state="translated">&amp;iexcl;Debemos un gran agradecimiento a los miembros de la comunidad &lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Wenlu Wang&lt;/a&gt; y &lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Titian Cernicova Dragomir&lt;/a&gt; por implementar esta funci&amp;oacute;n! Para obtener m&amp;aacute;s detalles, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;consulte su solicitud de extracci&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;el repositorio de propuestas de fusi&amp;oacute;n nula&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd7c75518818af1c60b72b48de1120f76c7411f" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;#strict&quot;&gt;compiler option &lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; to opt-in to every possible improvement as they are built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027ffea53cb8344a8ca0b02644101c1fc88508e6" translate="yes" xml:space="preserve">
          <source>We said earlier that some languages wouldn&amp;rsquo;t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as &lt;em&gt;static checking&lt;/em&gt;. Determining what&amp;rsquo;s an error and what&amp;rsquo;s not based on the kinds of values being operated on is known as static &lt;em&gt;type&lt;/em&gt; checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be98474a5452e0a16847898535c758700d80e71" translate="yes" xml:space="preserve">
          <source>We say that this version of the &lt;code&gt;identity&lt;/code&gt; function is generic, as it works over a range of types. Unlike using &lt;code&gt;any&lt;/code&gt;, it&amp;rsquo;s also just as precise (ie, it doesn&amp;rsquo;t lose any information) as the first &lt;code&gt;identity&lt;/code&gt; function that used numbers for the argument and return type.</source>
          <target state="translated">Decimos que esta versi&amp;oacute;n de la funci&amp;oacute;n de &lt;code&gt;identity&lt;/code&gt; es gen&amp;eacute;rica, ya que funciona en una variedad de tipos. A diferencia de &lt;code&gt;any&lt;/code&gt; uso , tambi&amp;eacute;n es tan preciso (es decir, no pierde ninguna informaci&amp;oacute;n) como la primera funci&amp;oacute;n de &lt;code&gt;identity&lt;/code&gt; que us&amp;oacute; n&amp;uacute;meros para el argumento y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="b6da2cbd96b3e75b9187d15de475de9ac9b10faa" translate="yes" xml:space="preserve">
          <source>We strongly encourage users to try the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.</source>
          <target state="translated">&lt;code&gt;useDefineForClassFields&lt;/code&gt; encarecidamente a los usuarios que prueben la marca useDefineForClassFields e informen sobre nuestro rastreador de problemas o en los comentarios a continuaci&amp;oacute;n. Esto incluye comentarios sobre la dificultad de adoptar la bandera para que podamos entender c&amp;oacute;mo podemos facilitar la migraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c7a2b84a24b11f7b028b0dbae7870221e6b866b5" translate="yes" xml:space="preserve">
          <source>We understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.</source>
          <target state="translated">Entendemos que una tonelada de salida monocromática puede ser un poco difícil para los ojos.Los colores pueden ayudar a discernir dónde comienza y termina un mensaje,y estas pistas visuales son importantes cuando la salida del error se vuelve abrumadora.</target>
        </trans-unit>
        <trans-unit id="9c538d5dd6bb04252a1e101d363501930cb1f96c" translate="yes" xml:space="preserve">
          <source>We used a &lt;code&gt;.ts&lt;/code&gt; extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</source>
          <target state="translated">Usamos una extensi&amp;oacute;n &lt;code&gt;.ts&lt;/code&gt; , pero este c&amp;oacute;digo es solo JavaScript. Podr&amp;iacute;a haber copiado / pegado esto directamente desde una aplicaci&amp;oacute;n JavaScript existente.</target>
        </trans-unit>
        <trans-unit id="0e0159d00e8ed5efa3d03297f6ba1361aeceb56f" translate="yes" xml:space="preserve">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;NetworkFromCachedState&lt;/code&gt; to &lt;code&gt;NetworkState&lt;/code&gt;, we need to update &lt;code&gt;logger&lt;/code&gt; as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5123383e9966536bbcb7f101d2b7d8f6a074dca8" translate="yes" xml:space="preserve">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;Triangle&lt;/code&gt; to &lt;code&gt;Shape&lt;/code&gt;, we need to update &lt;code&gt;area&lt;/code&gt; as well:</source>
          <target state="translated">Nos gustar&amp;iacute;a que el compilador nos dijera cu&amp;aacute;ndo no cubrimos todas las variantes de la uni&amp;oacute;n discriminada. Por ejemplo, si agregamos &lt;code&gt;Triangle&lt;/code&gt; a &lt;code&gt;Shape&lt;/code&gt; , tambi&amp;eacute;n necesitamos actualizar el &lt;code&gt;area&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9c5b24b66e133e695b5340a53b29a9a03a4588c0" translate="yes" xml:space="preserve">
          <source>We wrapped our &lt;code&gt;browserify&lt;/code&gt; instance in a call to &lt;code&gt;watchify&lt;/code&gt;, and then held on to the result.</source>
          <target state="translated">&lt;code&gt;browserify&lt;/code&gt; nuestra instancia de browserify en una llamada a &lt;code&gt;watchify&lt;/code&gt; , y luego mantuvimos el resultado.</target>
        </trans-unit>
        <trans-unit id="b6077b883e1d7e622df4d40c8eae3398ce7b9837" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d like to extend a huge thanks to &lt;a href=&quot;https://github.com/calebsander&quot;&gt;Caleb Sander&lt;/a&gt; for all the work on this feature. We&amp;rsquo;re grateful for the contribution, and we&amp;rsquo;re sure our users are too!</source>
          <target state="translated">Nos gustar&amp;iacute;a extender un gran agradecimiento a &lt;a href=&quot;https://github.com/calebsander&quot;&gt;Caleb Sander&lt;/a&gt; por todo el trabajo en esta funci&amp;oacute;n. Estamos agradecidos por la contribuci&amp;oacute;n y estamos seguros de que nuestros usuarios tambi&amp;eacute;n lo est&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="2955af2348407c162d10bf22c8f15b1a2bc20810" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also need a page to display our &lt;code&gt;Hello&lt;/code&gt; component. Create a file at the root of &lt;code&gt;proj&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt; with the following contents:</source>
          <target state="translated">Tambi&amp;eacute;n necesitaremos una p&amp;aacute;gina para mostrar nuestro componente &lt;code&gt;Hello&lt;/code&gt; . Cree un archivo en la ra&amp;iacute;z del &lt;code&gt;proj&lt;/code&gt; llamado &lt;code&gt;index.html&lt;/code&gt; con el siguiente contenido:</target>
        </trans-unit>
        <trans-unit id="9886aca5459083f9b058f494e9b979c3c4ef1899" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover classes later in this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0e5a7f6725b7d626b76e36ae307b3fc402a1e2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss index signatures in a bit, but here we&amp;rsquo;re saying a &lt;code&gt;SquareConfig&lt;/code&gt; can have any number of properties, and as long as they aren&amp;rsquo;t &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;width&lt;/code&gt;, their types don&amp;rsquo;t matter.</source>
          <target state="translated">Discutiremos las firmas de &amp;iacute;ndice en un momento, pero aqu&amp;iacute; estamos diciendo que un &lt;code&gt;SquareConfig&lt;/code&gt; puede tener cualquier cantidad de propiedades, y siempre que no sean de &lt;code&gt;color&lt;/code&gt; o &lt;code&gt;width&lt;/code&gt; , sus tipos no importan.</target>
        </trans-unit>
        <trans-unit id="1a2f59b32ace790506f0abdad902dd97d8982882" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first start off with numeric enums, which are probably more familiar if you&amp;rsquo;re coming from other languages. An enum can be defined using the &lt;code&gt;enum&lt;/code&gt; keyword.</source>
          <target state="translated">Primero comenzaremos con enumeraciones num&amp;eacute;ricas, que probablemente sean m&amp;aacute;s familiares si viene de otros idiomas. Se puede definir una enumeraci&amp;oacute;n utilizando la palabra clave &lt;code&gt;enum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff341e9ebeb5367479b561ddef0d845208be6d6e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll learn more about how classes relate to each other in the Classes chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19448f8bcee986b6f99112a504f95247ef4c159e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start with Watchify to provide background compilation:</source>
          <target state="translated">Comenzaremos con Watchify para proporcionar una compilaci&amp;oacute;n en segundo plano:</target>
        </trans-unit>
        <trans-unit id="0b37518565138e9254324247a79b02efcfc6deef" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also creating another value that we call the &lt;em&gt;constructor function&lt;/em&gt;. This is the function that is called when we &lt;code&gt;new&lt;/code&gt; up instances of the class. To see what this looks like in practice, let&amp;rsquo;s take a look at the JavaScript created by the above example:</source>
          <target state="translated">Tambi&amp;eacute;n estamos creando otro valor que llamamos &lt;em&gt;funci&amp;oacute;n constructora&lt;/em&gt; . Esta es la funci&amp;oacute;n a la que se llama cuando se crean &lt;code&gt;new&lt;/code&gt; instancias de la clase. Para ver c&amp;oacute;mo se ve esto en la pr&amp;aacute;ctica, echemos un vistazo al JavaScript creado por el ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="7aff8cf77620ede7bc7d3e8d39158810b0f689b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also including two other utility types as well: &lt;code&gt;Record&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n incluimos otros dos tipos de utilidades: &lt;code&gt;Record&lt;/code&gt; y &lt;code&gt;Pick&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3e9714b389303e76259f45a7e8e4a3371445cb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also introducing a new mode for &lt;code&gt;tsc&lt;/code&gt;, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand in hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">Tambi&amp;eacute;n presentamos un nuevo modo para &lt;code&gt;tsc&lt;/code&gt; , el indicador &lt;code&gt;--build&lt;/code&gt; , que funciona de la mano con las referencias del proyecto para permitir compilaciones de TypeScript m&amp;aacute;s r&amp;aacute;pidas.</target>
        </trans-unit>
        <trans-unit id="0a856c3b5c5d0b1b8b27ac26776fabf8b60ed0f0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve also added support for &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;declaration source maps&lt;/a&gt;. If you enable &lt;code&gt;--declarationMap&lt;/code&gt;, you&amp;rsquo;ll be able to use editor features like &amp;ldquo;Go to Definition&amp;rdquo; and Rename to transparently navigate and edit code across project boundaries in supported editors.</source>
          <target state="translated">Tambi&amp;eacute;n hemos agregado soporte para &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;mapas de fuentes de declaraci&amp;oacute;n&lt;/a&gt; . Si habilita &lt;code&gt;--declarationMap&lt;/code&gt; , podr&amp;aacute; utilizar funciones del editor como &quot;Ir a la definici&amp;oacute;n&quot; y Cambiar el nombre para navegar y editar de forma transparente el c&amp;oacute;digo a trav&amp;eacute;s de los l&amp;iacute;mites del proyecto en los editores compatibles.</target>
        </trans-unit>
        <trans-unit id="f8e13c786c22514d18489b8a515cda5e549982a7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now added a type variable &lt;code&gt;T&lt;/code&gt; to the identity function. This &lt;code&gt;T&lt;/code&gt; allows us to capture the type the user provides (e.g. &lt;code&gt;number&lt;/code&gt;), so that we can use that information later. Here, we use &lt;code&gt;T&lt;/code&gt; again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</source>
          <target state="translated">Ahora hemos agregado una variable de tipo &lt;code&gt;T&lt;/code&gt; a la funci&amp;oacute;n de identidad. Esta &lt;code&gt;T&lt;/code&gt; nos permite capturar el tipo que proporciona el usuario (por ejemplo, &lt;code&gt;number&lt;/code&gt; ), para que podamos usar esa informaci&amp;oacute;n m&amp;aacute;s tarde. Aqu&amp;iacute;, usamos &lt;code&gt;T&lt;/code&gt; nuevamente como el tipo de retorno. Al inspeccionar, ahora podemos ver que se usa el mismo tipo para el argumento y el tipo de retorno. Esto nos permite traficar ese tipo de informaci&amp;oacute;n en un lado de la funci&amp;oacute;n y fuera del otro.</target>
        </trans-unit>
        <trans-unit id="5d422ede737ddc07ca03c94e0a0c10b9d58412d1" translate="yes" xml:space="preserve">
          <source>Weak Type Detection</source>
          <target state="translated">Detección de tipos débiles</target>
        </trans-unit>
        <trans-unit id="1b5eb8b25701e63a0124e28e65777b9976429161" translate="yes" xml:space="preserve">
          <source>Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is long and gradual growth of &amp;ldquo;the web&amp;rdquo;, starting as a simple network of static pages, and evolving into a platform for rich &lt;em&gt;applications&lt;/em&gt; of all kinds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="c81830d8b730ad2fae90f8032a7776f8b0e39714" translate="yes" xml:space="preserve">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;awesome-typescript-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target state="translated">La integraci&amp;oacute;n de Webpack es bastante simple. Puede usar &lt;code&gt;awesome-typescript-loader&lt;/code&gt; , un cargador de TypeScript, combinado con &lt;code&gt;source-map-loader&lt;/code&gt; para facilitar la depuraci&amp;oacute;n. Simplemente corre</target>
        </trans-unit>
        <trans-unit id="ac0ca563dd0d3261e9ed866ed6e122036a96d12c" translate="yes" xml:space="preserve">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;ts-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f41141dbd3f1cbecbaad98cf3de708ecdf41b9b" translate="yes" xml:space="preserve">
          <source>Webpack is a tool that will bundle your code and optionally all of its dependencies into a single &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Webpack es una herramienta que agrupar&amp;aacute; su c&amp;oacute;digo y, opcionalmente, todas sus dependencias en un solo archivo &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7901ed28bacfe5bf0d524efc7190b1e5a54f7326" translate="yes" xml:space="preserve">
          <source>Webpack will eventually generate the &lt;code&gt;dist&lt;/code&gt; directory for us.</source>
          <target state="translated">Webpack eventualmente generar&amp;aacute; el directorio &lt;code&gt;dist&lt;/code&gt; para nosotros.</target>
        </trans-unit>
        <trans-unit id="7fad9fe5b80f48cd956db4822a16674a29a1b973" translate="yes" xml:space="preserve">
          <source>Websites are made up of HTML and/or XML documents. These documents are static, they do not change. The &lt;em&gt;Document Object Model (DOM)&lt;/em&gt; is a programming interface implemented by browsers in order to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it in order to make dynamic websites even easier to develop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39db66a63832d879643a9c74c80d078ce3a9abfa" translate="yes" xml:space="preserve">
          <source>Weeding out Errors</source>
          <target state="translated">Eliminar los errores</target>
        </trans-unit>
        <trans-unit id="e97ac55d12c65e8ccc90515dafcb06d1bbf38e6c" translate="yes" xml:space="preserve">
          <source>Well-known Symbols</source>
          <target state="translated">Símbolos bien conocidos</target>
        </trans-unit>
        <trans-unit id="a62da38185ade2ed494ca3c34e28aed2e07c4954" translate="yes" xml:space="preserve">
          <source>What does this affect?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b453e4894b5221614db3412183873d5d5a3d6fc9" translate="yes" xml:space="preserve">
          <source>What if we want to also log the length of the argument &lt;code&gt;arg&lt;/code&gt; to the console with each call? We might be tempted to write this:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; sucede si tambi&amp;eacute;n queremos registrar la longitud del argumento &lt;code&gt;arg&lt;/code&gt; en la consola con cada llamada? Podr&amp;iacute;amos tener la tentaci&amp;oacute;n de escribir esto:</target>
        </trans-unit>
        <trans-unit id="45fda52dea40ed49a1af31b0fc06e0a0f19b734d" translate="yes" xml:space="preserve">
          <source>What if we&amp;rsquo;re not running in TypeScript 3.1 in this example? Well, if none of the fields in &lt;code&gt;typesVersions&lt;/code&gt; get matched, TypeScript falls back to the &lt;code&gt;types&lt;/code&gt; field, so here TypeScript 3.0 and earlier will be redirected to &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa si no estamos ejecutando TypeScript 3.1 en este ejemplo? Bueno, si ninguno de los campos de &lt;code&gt;typesVersions&lt;/code&gt; coincide, TypeScript recurre al campo de &lt;code&gt;types&lt;/code&gt; , por lo que aqu&amp;iacute; TypeScript 3.0 y versiones anteriores se redirigir&amp;aacute;n a &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e305f4bbf1ed90aa73345044f0a492bd2c96f31" translate="yes" xml:space="preserve">
          <source>What is JavaScript? A Brief History</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6349e923db276196bacfe2471e600626fa732ab4" translate="yes" xml:space="preserve">
          <source>What is a Project Reference?</source>
          <target state="translated">¿Qué es un proyecto de referencia?</target>
        </trans-unit>
        <trans-unit id="549e8639ff7e2907dd68d7e827ef96b82a333747" translate="yes" xml:space="preserve">
          <source>What is a tsconfig.json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59beb27768eff0de85903d679ab600335df3cfc4" translate="yes" xml:space="preserve">
          <source>What is supported in my version of Visual Studio?</source>
          <target state="translated">¿Qué es lo que soporta mi versión de Visual Studio?</target>
        </trans-unit>
        <trans-unit id="2aab3d2a4f95d11fe606c90edd3b7781f2071f7b" translate="yes" xml:space="preserve">
          <source>What should you look for?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebc3fc3da860ce67243a9d91e606b84eda07cf2" translate="yes" xml:space="preserve">
          <source>What these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.</source>
          <target state="translated">Lo que estos dos se reducen a que la mezcla de las propiedades con los accesorios va a causar problemas,y también lo hará la re-declaración de las propiedades sin inicializadores.</target>
        </trans-unit>
        <trans-unit id="d5327b36090577d46345fd56199590737f1090b4" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New</source>
          <target state="translated">Qu&amp;eacute; hay de nuevo</target>
        </trans-unit>
        <trans-unit id="b19f846e4de2aa633d8a22d53f27123620724843" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@sealed&lt;/code&gt; is executed, it will seal both the constructor and its prototype.</source>
          <target state="translated">Cuando se ejecuta &lt;code&gt;@sealed&lt;/code&gt; , sellar&amp;aacute; tanto el constructor como su prototipo.</target>
        </trans-unit>
        <trans-unit id="de89d2eba1215f58d1dd8899c9e7c9afa82b2bb8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;declaration&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, running the compiler with this TypeScript code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d97be1b8d72d15598e3c754e9841feedf07996a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;downlevelIteration&lt;/code&gt; is enabled, TypeScript will use a helper function that checks for a &lt;code&gt;Symbol.iterator&lt;/code&gt; implementation (either native or polyfill). If this implementation is missing, you&amp;rsquo;ll fall back to index-based iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030f0dfcec29d2c5288e91c918593dc6c753cec6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;localStorage.volume&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, the page will set the volume to &lt;code&gt;0.5&lt;/code&gt; which is unintended. &lt;code&gt;??&lt;/code&gt; avoids some unintended behavior from &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; being treated as falsy values.</source>
          <target state="translated">Cuando &lt;code&gt;localStorage.volume&lt;/code&gt; se establece en &lt;code&gt;0&lt;/code&gt; , la p&amp;aacute;gina establecer&amp;aacute; el volumen en &lt;code&gt;0.5&lt;/code&gt; ,lo cual no es intencionado. &lt;code&gt;??&lt;/code&gt; evita que algunos comportamientos no deseados de &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; y &lt;code&gt;&quot;&quot;&lt;/code&gt; sean tratados como valores falsos.</target>
        </trans-unit>
        <trans-unit id="f8cdcfeef8004c101022b373d173e5e67f254a91" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outFile&lt;/code&gt; is used, the build information file&amp;rsquo;s name will be based on the output file&amp;rsquo;s name. As an example, if our output JavaScript file is &lt;code&gt;./output/foo.js&lt;/code&gt;, then under the &lt;code&gt;--incremental&lt;/code&gt; flag, TypeScript will generate the file &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt;. As above, this can be controlled with the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">Cuando se usa &lt;code&gt;outFile&lt;/code&gt; , el nombre del archivo de informaci&amp;oacute;n de compilaci&amp;oacute;n se basar&amp;aacute; en el nombre del archivo de salida. Por ejemplo, si nuestro archivo JavaScript de salida es &lt;code&gt;./output/foo.js&lt;/code&gt; , bajo la marca &lt;code&gt;--incremental&lt;/code&gt; , TypeScript generar&amp;aacute; el archivo &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt; . Como antes, esto se puede controlar con el indicador &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b4ab4c97cea9690c0e23272de9b69e351862d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;removeComments&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85b0524d36ff619229702608a55d6837ddd69c1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are effectively ignored by the language. This can lead to unexpected errors at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f13327933b18823e01adeaea42756b80600b7ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; have their own distinct types and you&amp;rsquo;ll get a type error if you try to use them where a concrete value is expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f520248f652ff2167281b35bfd68546d3ba6914b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is enabled, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; get their own types called &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Whenever anything is &lt;em&gt;possibly&lt;/em&gt;&lt;code&gt;null&lt;/code&gt;, you can use a union type with the original type. So for instance, if something could be a &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you&amp;rsquo;d write the type out as &lt;code&gt;number | null&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;strictNullChecks&lt;/code&gt; est&amp;aacute; habilitado, &lt;code&gt;null&lt;/code&gt; y &lt;code&gt;undefined&lt;/code&gt; obtienen sus propios tipos llamados &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; respectivamente. Siempre que algo sea &lt;em&gt;posiblemente &lt;/em&gt; &lt;code&gt;null&lt;/code&gt; , puede usar un tipo de uni&amp;oacute;n con el tipo original. Entonces, por ejemplo, si algo pudiera ser un &lt;code&gt;number&lt;/code&gt; o un &lt;code&gt;null&lt;/code&gt; , escribir&amp;iacute;a el tipo como &lt;code&gt;number | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bbf9f8fcdd1b99e48e1893b7a75fd930f81e35d" translate="yes" xml:space="preserve">
          <source>When Javascript classes extend a generic base class, there is nowhere to specify what the type parameter should be. The &lt;code&gt;@extends&lt;/code&gt; tag provides a place for that type parameter:</source>
          <target state="translated">Cuando las clases de Javascript ampl&amp;iacute;an una clase base gen&amp;eacute;rica, no hay ning&amp;uacute;n lugar para especificar cu&amp;aacute;l deber&amp;iacute;a ser el par&amp;aacute;metro de tipo. La etiqueta &lt;code&gt;@extends&lt;/code&gt; proporciona un lugar para ese par&amp;aacute;metro de tipo:</target>
        </trans-unit>
        <trans-unit id="04de13704216a9db06f5ffa39317b375f05787e0" translate="yes" xml:space="preserve">
          <source>When TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d424ff2d89383aadc098c9555b347abf8e1516" translate="yes" xml:space="preserve">
          <source>When TypeScript opens a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8c176e99ff6882e6b0d9b7305bf530d1b1a588" translate="yes" xml:space="preserve">
          <source>When a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.</source>
          <target state="translated">Cuando una llamada a una función incluye una expresión de propagación de un tipo de tupla como último argumento,la expresión de propagación corresponde a una secuencia de argumentos discretos de los tipos de elementos de tupla.</target>
        </trans-unit>
        <trans-unit id="9c33bce0f75302f0d6e1a7e860836fefe8f472c2" translate="yes" xml:space="preserve">
          <source>When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.</source>
          <target state="translated">Cuando una función tiene un parámetro de reposo,se trata como si fuera una serie infinita de parámetros opcionales.</target>
        </trans-unit>
        <trans-unit id="fd713400776c7d40925b3ed1ecacc3ed2345c946" translate="yes" xml:space="preserve">
          <source>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function.</source>
          <target state="translated">Cuando una función tiene sobrecargas,cada sobrecarga en el tipo de fuente debe corresponderse con una firma compatible en el tipo de destino.Esto garantiza que la función de destino pueda ser llamada en todas las mismas situaciones que la función de origen.</target>
        </trans-unit>
        <trans-unit id="5607cf867fc582d411cd22588c4ee37feb393557" translate="yes" xml:space="preserve">
          <source>When a member is marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target state="translated">Cuando un miembro se marca como &lt;code&gt;private&lt;/code&gt; , no se puede acceder a &amp;eacute;l desde fuera de la clase que lo contiene. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="584d36e45bec249f6c98a43c17d122b7fd42bae9" translate="yes" xml:space="preserve">
          <source>When a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:</source>
          <target state="translated">Cuando un parámetro de reposo tiene un tipo de tupla,el tipo de tupla se expande en una secuencia de parámetros discretos.Por ejemplo,las dos declaraciones siguientes son equivalentes:</target>
        </trans-unit>
        <trans-unit id="564e9e469a41360585db50dc07312fe0e7a957af" translate="yes" xml:space="preserve">
          <source>When a type inference is made from several expressions, the types of those expressions are used to calculate a &amp;ldquo;best common type&amp;rdquo;. For example,</source>
          <target state="translated">Cuando se hace una inferencia de tipo a partir de varias expresiones, los tipos de esas expresiones se utilizan para calcular el &quot;mejor tipo com&amp;uacute;n&quot;. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="5b460fc1b0afb2a95c11c3857f5c3f8edcb0a57d" translate="yes" xml:space="preserve">
          <source>When a variable is declared using &lt;code&gt;let&lt;/code&gt;, it uses what some call &lt;em&gt;lexical-scoping&lt;/em&gt; or &lt;em&gt;block-scoping&lt;/em&gt;. Unlike variables declared with &lt;code&gt;var&lt;/code&gt; whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or &lt;code&gt;for&lt;/code&gt;-loop.</source>
          <target state="translated">Cuando una variable se declara usando &lt;code&gt;let&lt;/code&gt; , usa lo que algunos llaman &lt;em&gt;alcance l&amp;eacute;xico&lt;/em&gt; o &lt;em&gt;alcance de &lt;/em&gt;&lt;em&gt;bloque&lt;/em&gt; . A diferencia de las variables declaradas con &lt;code&gt;var&lt;/code&gt; cuyos alcances se filtran a su funci&amp;oacute;n contenedora, las variables de alcance de bloque no son visibles fuera de su bloque contenedor m&amp;aacute;s cercano o &lt;code&gt;for&lt;/code&gt; -loop.</target>
        </trans-unit>
        <trans-unit id="e90a72104ebe8868314228d24725924c08766c5b" translate="yes" xml:space="preserve">
          <source>When accessing an element with a known index, the correct type is retrieved:</source>
          <target state="translated">Cuando se accede a un elemento con un índice conocido,se recupera el tipo correcto:</target>
        </trans-unit>
        <trans-unit id="d43b1825ee2b2cb0d745c365143986923701b4d7" translate="yes" xml:space="preserve">
          <source>When all members in an enum have literal enum values, some special semantics come to play.</source>
          <target state="translated">Cuando todos los miembros de un &quot;enum&quot; tienen valores literales de &quot;enum&quot;,una semántica especial entra en juego.</target>
        </trans-unit>
        <trans-unit id="84234191fb7cb5a1d6647ae5bcd64e2e66fdf73e" translate="yes" xml:space="preserve">
          <source>When an array literal is contextually typed by the implied type of an array binding pattern:</source>
          <target state="translated">Cuando una matriz literal es tipificada contextualmente por el tipo implícito de un patrón de unión de matriz:</target>
        </trans-unit>
        <trans-unit id="6db5ea81f7f1151fab25e118bfe8501e1c5b8304" translate="yes" xml:space="preserve">
          <source>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</source>
          <target state="translated">Cuando un tipo de interfaz amplía un tipo de clase,hereda los miembros de la clase pero no sus implementaciones.Es como si la interfaz hubiera declarado todos los miembros de la clase sin proporcionar una implementación.Las interfaces heredan incluso los miembros privados y protegidos de una clase base.Esto significa que cuando se crea una interfaz que extiende una clase con miembros privados o protegidos,ese tipo de interfaz sólo puede ser implementado por esa clase o una subclase de ella.</target>
        </trans-unit>
        <trans-unit id="5744d6fdcbf8dc3476727393bac3b4cddf93ada3" translate="yes" xml:space="preserve">
          <source>When an object literal is contextually typed by the implied type of an object binding pattern:</source>
          <target state="translated">Cuando un objeto literal es tipificado contextualmente por el tipo implícito de un patrón de unión de objetos:</target>
        </trans-unit>
        <trans-unit id="be88d1b03a9be5d8830da895b57d21e37b131ee9" translate="yes" xml:space="preserve">
          <source>When an object with a numeric index signature of type &lt;code&gt;T&lt;/code&gt; (such as an array) is indexed by a &lt;code&gt;for..in&lt;/code&gt; variable of a containing &lt;code&gt;for..in&lt;/code&gt; statement for an object &lt;em&gt;with&lt;/em&gt; a numeric index signature and &lt;em&gt;without&lt;/em&gt; a string index signature (again such as an array), the value produced is of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Cuando un objeto con una firma de &amp;iacute;ndice num&amp;eacute;rico de tipo &lt;code&gt;T&lt;/code&gt; (como una matriz) es indexado por una variable &lt;code&gt;for..in&lt;/code&gt; de una instrucci&amp;oacute;n &lt;code&gt;for..in&lt;/code&gt; que contiene para un objeto &lt;em&gt;con&lt;/em&gt; una firma de &amp;iacute;ndice num&amp;eacute;rico y &lt;em&gt;sin&lt;/em&gt; una firma de &amp;iacute;ndice de cadena (nuevamente tal como una matriz), el valor producido es de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a191b524d20c2c29223783fb417af58e807f338" translate="yes" xml:space="preserve">
          <source>When calling this function, TypeScript will try to figure out the types of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; through a process called &lt;em&gt;type argument inference&lt;/em&gt;. This inference process usually works pretty well:</source>
          <target state="translated">Al llamar a esta funci&amp;oacute;n, TypeScript intentar&amp;aacute; averiguar los tipos de &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;C&lt;/code&gt; a trav&amp;eacute;s de un proceso llamado &lt;em&gt;inferencia de argumento de tipo&lt;/em&gt; . Este proceso de inferencia suele funcionar bastante bien:</target>
        </trans-unit>
        <trans-unit id="a79acd611da5588e33a3cd349e2f634dc5e04388" translate="yes" xml:space="preserve">
          <source>When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.</source>
          <target state="translated">Cuando se comparan las funciones para la compatibilidad,los parámetros opcionales y los requeridos son intercambiables.Los parámetros opcionales adicionales del tipo de fuente no son un error,y los parámetros opcionales del tipo de destino sin los parámetros correspondientes en el tipo de fuente no son un error.</target>
        </trans-unit>
        <trans-unit id="03084317d53b13f20dd727e5c86474664f6cced3" translate="yes" xml:space="preserve">
          <source>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:</source>
          <target state="translated">Al comparar los tipos de parámetros de la función,la asignación tiene éxito si el parámetro de origen es asignable al parámetro de destino,o viceversa.Esto es poco sólido porque a quien llama puede terminar recibiendo una función que toma un tipo más especializado,pero que invoca la función con un tipo menos especializado.En la práctica,este tipo de error es raro,y permitir esto permite muchos patrones comunes de JavaScript.Un breve ejemplo:</target>
        </trans-unit>
        <trans-unit id="e381f7d0b16f43f925b00a27f8c4e30f5d16099b" translate="yes" xml:space="preserve">
          <source>When compiled in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, optional properties and methods automatically have &lt;code&gt;undefined&lt;/code&gt; included in their type. Thus, the &lt;code&gt;b&lt;/code&gt; property above is of type &lt;code&gt;number | undefined&lt;/code&gt; and the &lt;code&gt;g&lt;/code&gt; method above is of type &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt;. Type guards can be used to strip away the &lt;code&gt;undefined&lt;/code&gt; part of the type:</source>
          <target state="translated">Cuando se compilan en el modo &lt;code&gt;--strictNullChecks&lt;/code&gt; , las propiedades y los m&amp;eacute;todos opcionales tienen autom&amp;aacute;ticamente un &lt;code&gt;undefined&lt;/code&gt; incluido en su tipo. Por tanto, la propiedad &lt;code&gt;b&lt;/code&gt; anterior es del tipo &lt;code&gt;number | undefined&lt;/code&gt; y el m&amp;eacute;todo &lt;code&gt;g&lt;/code&gt; anterior es de tipo &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt; . Los protectores de texto se pueden utilizar para eliminar la parte &lt;code&gt;undefined&lt;/code&gt; del texto:</target>
        </trans-unit>
        <trans-unit id="5bbcd2d4cb15d58c0854ed82d657d8c796031edd" translate="yes" xml:space="preserve">
          <source>When compiled, each module will become a separate &lt;code&gt;.js&lt;/code&gt; file. As with reference tags, the compiler will follow &lt;code&gt;import&lt;/code&gt; statements to compile dependent files.</source>
          <target state="translated">Cuando se compile, cada m&amp;oacute;dulo se convertir&amp;aacute; en un archivo &lt;code&gt;.js&lt;/code&gt; separado . Al igual que con las etiquetas de referencia, el compilador seguir&amp;aacute; las instrucciones de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n para compilar archivos dependientes.</target>
        </trans-unit>
        <trans-unit id="751fdd8e03ce07c29b56146fecc9f825067cb792" translate="yes" xml:space="preserve">
          <source>When compiling to pre-ES6 targets, the string is decomposed:</source>
          <target state="translated">Cuando se compila a los objetivos pre-ES6,la cadena se descompone:</target>
        </trans-unit>
        <trans-unit id="4156655ae276c8b3ed96d041dfc8baeba1797652" translate="yes" xml:space="preserve">
          <source>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,</source>
          <target state="translated">Cuando se crean fábricas en TypeScript usando genéricos,es necesario referirse a los tipos de clase por sus funciones constructivas.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="dcace02a91899e1f338f3e9e2fa474b942645716" translate="yes" xml:space="preserve">
          <source>When enabled, TypeScript will check all code paths in a function to ensure they return a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a561b2561570486c65edf072423fc080bd866b" translate="yes" xml:space="preserve">
          <source>When enabled, as long as the &lt;code&gt;reflect-metadata&lt;/code&gt; library has been imported, additional design-time type information will be exposed at runtime.</source>
          <target state="translated">Cuando est&amp;aacute; habilitado, siempre que se haya importado la biblioteca &lt;code&gt;reflect-metadata&lt;/code&gt; , se expondr&amp;aacute; informaci&amp;oacute;n adicional de tipo en tiempo de dise&amp;ntilde;o en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2e2b57241329652bf13e53eebcd41139c80c8d1c" translate="yes" xml:space="preserve">
          <source>When enabled, this flag causes functions parameters to be checked more correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2be8d3bddd72617c23414391cc48bc565dfaa5" translate="yes" xml:space="preserve">
          <source>When exporting a module using &lt;code&gt;export =&lt;/code&gt;, TypeScript-specific &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; must be used to import the module.</source>
          <target state="translated">Al exportar un m&amp;oacute;dulo usando &lt;code&gt;export =&lt;/code&gt; , se debe usar el m&amp;oacute;dulo de &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; espec&amp;iacute;fico de TypeScript = require (&quot;m&amp;oacute;dulo&quot;) para importar el m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="06ca5da26932f2433c3883f2ba92d649c8f8ac14" translate="yes" xml:space="preserve">
          <source>When first moving to a module-based organization, a common tendency is to wrap exports in an additional layer of namespaces. Modules have their own scope, and only exported declarations are visible from outside the module. With this in mind, namespace provide very little, if any, value when working with modules.</source>
          <target state="translated">Cuando se pasa por primera vez a una organización basada en módulos,una tendencia común es envolver las exportaciones en una capa adicional de espacios para nombres.Los módulos tienen su propio ámbito de aplicación y sólo las declaraciones de exportación son visibles desde fuera del módulo.Teniendo esto en cuenta,los espacios de nombres proporcionan muy poco o ningún valor cuando se trabaja con módulos.</target>
        </trans-unit>
        <trans-unit id="668eaece6bc69ffaa69b4efacde9943b15dbace6" translate="yes" xml:space="preserve">
          <source>When imported into a TypeScript file will raise an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7376b10eff8993749ce4879a342660552379ff7" translate="yes" xml:space="preserve">
          <source>When imported into a TypeScript module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cbb0349fc79c96ec431ec47e8f342090438ecb" translate="yes" xml:space="preserve">
          <source>When importing using the &lt;code&gt;Node&lt;/code&gt; module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from &amp;ldquo;identical&amp;rdquo; packages. If a file originates from a package with a &lt;code&gt;package.json&lt;/code&gt; containing the same &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt; fields as a previously encountered package, then TypeScript will redirect itself to the top-most package. This helps resolve problems where two packages might contain identical declarations of classes, but which contain &lt;code&gt;private&lt;/code&gt; members that cause them to be structurally incompatible.</source>
          <target state="translated">Al importar usando la estrategia de resoluci&amp;oacute;n del m&amp;oacute;dulo &lt;code&gt;Node&lt;/code&gt; en TypeScript 2.5, el compilador ahora verificar&amp;aacute; si los archivos se originan en paquetes &quot;id&amp;eacute;nticos&quot;. Si un archivo se origina en un paquete con un &lt;code&gt;package.json&lt;/code&gt; que contiene los mismos campos de &lt;code&gt;name&lt;/code&gt; y &lt;code&gt;version&lt;/code&gt; que un paquete encontrado anteriormente, TypeScript se redirigir&amp;aacute; al paquete superior. Esto ayuda a resolver problemas donde dos paquetes pueden contener declaraciones de clases id&amp;eacute;nticas, pero que contienen miembros &lt;code&gt;private&lt;/code&gt; que los hacen estructuralmente incompatibles.</target>
        </trans-unit>
        <trans-unit id="e53d751bb35ec11bb8d50707759e0855efc875fb" translate="yes" xml:space="preserve">
          <source>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the &lt;em&gt;last&lt;/em&gt; signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</source>
          <target state="translated">Cuando se infiere de un tipo con m&amp;uacute;ltiples firmas de llamada (como el tipo de una funci&amp;oacute;n sobrecargada), se hacen inferencias a partir de la &lt;em&gt;&amp;uacute;ltima&lt;/em&gt; firma (que, presumiblemente, es el caso general m&amp;aacute;s permisivo). No es posible realizar una resoluci&amp;oacute;n de sobrecarga basada en una lista de tipos de argumentos.</target>
        </trans-unit>
        <trans-unit id="c0e5d12e818f1a128405e0dcf37599e5124ab4c5" translate="yes" xml:space="preserve">
          <source>When input files are specified on the command line, &lt;code&gt;tsconfig.json&lt;/code&gt; files are ignored.</source>
          <target state="translated">Cuando se especifican archivos de entrada en la l&amp;iacute;nea de comando, los archivos &lt;code&gt;tsconfig.json&lt;/code&gt; se ignoran.</target>
        </trans-unit>
        <trans-unit id="c7dbba16b050a53843a9368cb4cf7aacd6cb532e" translate="yes" xml:space="preserve">
          <source>When install is complete, rebuild!</source>
          <target state="translated">Cuando la instalación esté completa,¡reconstruya!</target>
        </trans-unit>
        <trans-unit id="9030ab49af527527a3048a47ea128f0c0c219027" translate="yes" xml:space="preserve">
          <source>When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.</source>
          <target state="translated">Cuando se interactúa con JavaScript de terceros,puede ser necesario utilizar patrones como el anterior para describir completamente la forma del tipo.</target>
        </trans-unit>
        <trans-unit id="6164dc5fed96c16868282dad3b94f86d550f8593" translate="yes" xml:space="preserve">
          <source>When looking at the code of a global library, you&amp;rsquo;ll usually see:</source>
          <target state="translated">Al mirar el c&amp;oacute;digo de una biblioteca global, normalmente ver&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="8a513a2bca42391a3829f6aa2918feafe16fa0e9" translate="yes" xml:space="preserve">
          <source>When making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b922be38a1d8a16178d415d54259031e8aa4f6f" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="translated">Cuando varios decoradores se aplican a una sola declaraci&amp;oacute;n, su evaluaci&amp;oacute;n es similar a la &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;composici&amp;oacute;n de funciones en matem&amp;aacute;ticas&lt;/a&gt; . En este modelo, al componer las funciones &lt;em&gt;f&lt;/em&gt; y &lt;em&gt;g&lt;/em&gt; , el compuesto resultante ( &lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt; ) ( &lt;em&gt;x&lt;/em&gt; ) es equivalente &lt;em&gt;af&lt;/em&gt; ( &lt;em&gt;g&lt;/em&gt; ( &lt;em&gt;x&lt;/em&gt; )).</target>
        </trans-unit>
        <trans-unit id="954328cfc017ca1687105e4509b95a1b13d2af54" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;http://wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2ce3b2acc4dd5238eaac40a3c2b746b0805538" translate="yes" xml:space="preserve">
          <source>When needed, the compiler &lt;em&gt;widens&lt;/em&gt; &amp;mdash; converts to a supertype &amp;mdash; the unit type to the primitive type, such as &lt;code&gt;&quot;foo&quot;&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;. This happens when using mutability, which can hamper some uses of mutable variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6f6092ccbf1d0a9294c7e4c282859a027ca09d" translate="yes" xml:space="preserve">
          <source>When no best common type is found, the resulting inference is the union array type, &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt;.</source>
          <target state="translated">Cuando no se encuentra el mejor tipo com&amp;uacute;n, la inferencia resultante es el tipo de matriz de uni&amp;oacute;n, &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="577abe4bb126beb561a8efdcb48a28392a4a75af" translate="yes" xml:space="preserve">
          <source>When obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; has a single construct signature &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt;.</source>
          <target state="translated">Al obtener las firmas de construcci&amp;oacute;n de un tipo de intersecci&amp;oacute;n que contiene tipos de constructor mixin, las firmas de construcci&amp;oacute;n mixin se descartan y sus tipos de instancia se mezclan con los tipos de retorno de las otras firmas de construcci&amp;oacute;n en el tipo de intersecci&amp;oacute;n. Por ejemplo, el tipo de intersecci&amp;oacute;n &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; tiene una &amp;uacute;nica firma de construcci&amp;oacute;n &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5037d7b746e687be44f9da9ad23e7dc846aba52" translate="yes" xml:space="preserve">
          <source>When reading from a union type, you can see any properties that are shared by them:</source>
          <target state="translated">Cuando se lee de un tipo de unión,se pueden ver las propiedades que son compartidas por ellos:</target>
        </trans-unit>
        <trans-unit id="35582d74eec1d631b57c2de10a47c90c793d3dde" translate="yes" xml:space="preserve">
          <source>When relating the type of &lt;code&gt;map&lt;/code&gt; in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.</source>
          <target state="translated">Al relacionar el tipo de &lt;code&gt;map&lt;/code&gt; a en TS 2.4, el lenguaje verificar&amp;aacute; si cada par&amp;aacute;metro es un tipo de devoluci&amp;oacute;n de llamada y, de ser as&amp;iacute;, se asegurar&amp;aacute; de que esos par&amp;aacute;metros se verifiquen de manera contravariante con respecto a la relaci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="39dea6a28c7ed5ec45fbae153245367a81c4db31" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; allows you to write an import like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c583a10fdbc7daf7e0efcc6636eb8647630843da" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;allowUmdGlobalAccess&lt;/code&gt; lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c950a1a9d1adb8bf75c10364f43b53406e85813" translate="yes" xml:space="preserve">
          <source>When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e345c366b26184d9f74a06f292f247bfab9bfef" translate="yes" xml:space="preserve">
          <source>When set, TypeScript will check that the built-in methods of functions &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; are invoked with correct argument for the underlying function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ba421a210ee671b7d2e94cf97295f944594d7c" translate="yes" xml:space="preserve">
          <source>When set, TypeScript will include the original content of the &lt;code&gt;.ts&lt;/code&gt; file as an embedded string in the source map. This is often useful in the same cases as &lt;code&gt;inlineSourceMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4ff52db3699946536782a20c9a209457b23419" translate="yes" xml:space="preserve">
          <source>When set, instead of writing out a &lt;code&gt;.js.map&lt;/code&gt; file to provide source maps, TypeScript will embed the source map content in the &lt;code&gt;.js&lt;/code&gt; files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn&amp;rsquo;t allow &lt;code&gt;.map&lt;/code&gt; files to be served.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff10b12f6a9033fbc10cf950cc0ed31b94b4a4d" translate="yes" xml:space="preserve">
          <source>When specifying a greeting, you must pass a &lt;code&gt;GreetingSettings&lt;/code&gt; object. This object has the following properties:</source>
          <target state="translated">Al especificar un saludo, debe pasar un objeto &lt;code&gt;GreetingSettings&lt;/code&gt; . Este objeto tiene las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="43988d6b430a774a26861955cc54fd9c702d0452" translate="yes" xml:space="preserve">
          <source>When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.</source>
          <target state="translated">Cuando se especifican los argumentos de tipo,sólo se requiere especificar los argumentos de tipo para los parámetros de tipo requeridos.Los parámetros de tipo no especificados se resolverán a sus tipos por defecto.</target>
        </trans-unit>
        <trans-unit id="1ebe929f8f784ba5280922a50ab6e379d8859057" translate="yes" xml:space="preserve">
          <source>When targeting ES3/ES5, the following code</source>
          <target state="translated">Al apuntar a ES3/ES5,el siguiente código</target>
        </trans-unit>
        <trans-unit id="156025a3f40907ffeac72e030a3a730a1deebeb1" translate="yes" xml:space="preserve">
          <source>When targeting an ECMAScipt 2015-compliant engine, the compiler will generate &lt;code&gt;for..of&lt;/code&gt; loops to target the built-in iterator implementation in the engine.</source>
          <target state="translated">Al apuntar a un motor compatible con ECMAScipt 2015, el compilador generar&amp;aacute; bucles &lt;code&gt;for..of&lt;/code&gt; para apuntar a la implementaci&amp;oacute;n del iterador incorporado en el motor.</target>
        </trans-unit>
        <trans-unit id="81f1ae5ab6877859c51c53b6981d29f05adff0a6" translate="yes" xml:space="preserve">
          <source>When targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of &lt;code&gt;Array&lt;/code&gt; type. It is an error to use &lt;code&gt;for..of&lt;/code&gt; loops on non-Array values, even if these non-Array values implement the &lt;code&gt;Symbol.iterator&lt;/code&gt; property.</source>
          <target state="translated">Al apuntar a un motor compatible con ES5 o ES3, los iteradores solo se permiten en valores de tipo &lt;code&gt;Array&lt;/code&gt; . Es un error usar &lt;code&gt;for..of&lt;/code&gt; bucles en valores que no son Array, incluso si estos valores que no son Array implementan la propiedad &lt;code&gt;Symbol.iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6f752156fda72ea7aae2689896f7e4699113094" translate="yes" xml:space="preserve">
          <source>When the module &lt;strong&gt;does not&lt;/strong&gt; explicitly specify a default export.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c37c6770fe59c21b776453641387b80134be5e8" translate="yes" xml:space="preserve">
          <source>When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da87dafd3c996b8acd299c5e81f629e20d29370b" translate="yes" xml:space="preserve">
          <source>When this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990f9e6deb289272b10e4e4125770810112d182e" translate="yes" xml:space="preserve">
          <source>When this setting is on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fff15c1d3e5e5f2e18f1d4a6ac9350c4a78b3f2" translate="yes" xml:space="preserve">
          <source>When tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.</source>
          <target state="translated">Cuando se infieren tipos de tupla para los parámetros de reposo,los parámetros opcionales en la fuente se convierten en elementos de tupla opcionales en el tipo inferido.</target>
        </trans-unit>
        <trans-unit id="75737547c96987306eebfed378fbd115f0634d72" translate="yes" xml:space="preserve">
          <source>When using Node module resolution in TypeScript 3.1, when TypeScript cracks open a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;. A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target state="translated">Cuando se usa la resoluci&amp;oacute;n del m&amp;oacute;dulo de nodo en TypeScript 3.1, cuando TypeScript abre un archivo &lt;code&gt;package.json&lt;/code&gt; para averiguar qu&amp;eacute; archivos necesita leer, primero mira un nuevo campo llamado &lt;code&gt;typesVersions&lt;/code&gt; . Un &lt;code&gt;package.json&lt;/code&gt; con un campo &lt;code&gt;typesVersions&lt;/code&gt; podr&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="1ae8b3b63e3d4432d7dcb8ebb6d1406c00d3f904" translate="yes" xml:space="preserve">
          <source>When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn&amp;rsquo;t support native file watchers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4850716ae612670ae2d56349b6a2660a6446e72a" translate="yes" xml:space="preserve">
          <source>When we do, the compiler will give us an error that we&amp;rsquo;re using the &lt;code&gt;.length&lt;/code&gt; member of &lt;code&gt;arg&lt;/code&gt;, but nowhere have we said that &lt;code&gt;arg&lt;/code&gt; has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a &lt;code&gt;number&lt;/code&gt; instead, which does not have a &lt;code&gt;.length&lt;/code&gt; member.</source>
          <target state="translated">Cuando lo hagamos, el compilador nos dar&amp;aacute; un error de que estamos usando el miembro &lt;code&gt;.length&lt;/code&gt; de &lt;code&gt;arg&lt;/code&gt; , pero en ninguna parte hemos dicho que &lt;code&gt;arg&lt;/code&gt; tiene este miembro. Recuerde, dijimos anteriormente que estas variables de tipo representan todos y cada uno de los tipos, por lo que alguien que use esta funci&amp;oacute;n podr&amp;iacute;a haber pasado un &lt;code&gt;number&lt;/code&gt; lugar, que no tiene un miembro &lt;code&gt;.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217dd70751ec70c2507f34daeb4f28f27ba30001" translate="yes" xml:space="preserve">
          <source>When we first touched on the idea of variable capturing with &lt;code&gt;var&lt;/code&gt; declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an &amp;ldquo;environment&amp;rdquo; of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.</source>
          <target state="translated">Cuando abordamos por primera vez la idea de la captura de variables con la declaraci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; , analizamos brevemente c&amp;oacute;mo act&amp;uacute;an las variables una vez capturadas. Para dar una mejor intuici&amp;oacute;n de esto, cada vez que se ejecuta un alcance, crea un &quot;entorno&quot; de variables. Ese entorno y sus variables capturadas pueden existir incluso despu&amp;eacute;s de que todo dentro de su alcance haya terminado de ejecutarse.</target>
        </trans-unit>
        <trans-unit id="7c4c9e905df51f2991607084fd0766320f038e1a" translate="yes" xml:space="preserve">
          <source>When working with &lt;a href=&quot;docs/handbook/project-references&quot;&gt;composite TypeScript projects&lt;/a&gt;, this option provides a way to declare that you do not want a project to be included when using features like &lt;em&gt;find all references&lt;/em&gt; or &lt;em&gt;jump to definition&lt;/em&gt; in an editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c31435415edfd38b4ca387c630ed5c177c68f06" translate="yes" xml:space="preserve">
          <source>When working with &lt;a href=&quot;docs/handbook/project-references&quot;&gt;composite TypeScript projects&lt;/a&gt;, this option provides a way to go &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references&quot;&gt;back to the pre-3.7&lt;/a&gt; behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fe803409a586a0ea7a977ee5a94d526da6f55e" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;.d.ts&lt;/code&gt; files for JavaScript files you may want to use &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt; or use &lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt; to ensure that the JavaScript files are not overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff7f4efa05e217597245c432a821c2527e220ab" translate="yes" xml:space="preserve">
          <source>When working with classes and interfaces, it helps to keep in mind that a class has &lt;em&gt;two&lt;/em&gt; types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:</source>
          <target state="translated">Cuando se trabaja con clases e interfaces, es &amp;uacute;til tener en cuenta que una clase tiene &lt;em&gt;dos&lt;/em&gt; tipos: el tipo del lado est&amp;aacute;tico y el tipo del lado de la instancia. Puede notar que si crea una interfaz con una firma de construcci&amp;oacute;n e intenta crear una clase que implemente esta interfaz, obtendr&amp;aacute; un error:</target>
        </trans-unit>
        <trans-unit id="59ca9320ae741734ed0a3e6c543e8c5deef3ad35" translate="yes" xml:space="preserve">
          <source>When writing in JavaScript files (using &lt;code&gt;allowJs&lt;/code&gt;), TypeScript now recognizes declarations that use &lt;code&gt;Object.defineProperty&lt;/code&gt;. This means you&amp;rsquo;ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the &lt;code&gt;checkJs&lt;/code&gt; option or adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to the top of your file).</source>
          <target state="translated">Al escribir en archivos JavaScript (usando &lt;code&gt;allowJs&lt;/code&gt; ), TypeScript ahora reconoce declaraciones que usan &lt;code&gt;Object.defineProperty&lt;/code&gt; . Esto significa que obtendr&amp;aacute; mejores terminaciones y una verificaci&amp;oacute;n de tipos m&amp;aacute;s s&amp;oacute;lida cuando habilite la verificaci&amp;oacute;n de tipos en archivos JavaScript (activando la opci&amp;oacute;n &lt;code&gt;checkJs&lt;/code&gt; o agregando un comentario &lt;code&gt;// @ts-check&lt;/code&gt; en la parte superior de su archivo).</target>
        </trans-unit>
        <trans-unit id="2c9a1bcb431f60ef891dc5272428f61ccd6deae4" translate="yes" xml:space="preserve">
          <source>When you are trying to debug why a module isn&amp;rsquo;t being included. You can set &lt;code&gt;traceResolutions&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to have TypeScript print information about its resolution process for each processed file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5f993452425d2ee4ab0f5de68ed85198028eec" translate="yes" xml:space="preserve">
          <source>When you begin to use generics, you&amp;rsquo;ll notice that when you create generic functions like &lt;code&gt;identity&lt;/code&gt;, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.</source>
          <target state="translated">Cuando comience a usar gen&amp;eacute;ricos, notar&amp;aacute; que cuando crea funciones gen&amp;eacute;ricas como &lt;code&gt;identity&lt;/code&gt; , el compilador exigir&amp;aacute; que use correctamente cualquier par&amp;aacute;metro escrito gen&amp;eacute;ricamente en el cuerpo de la funci&amp;oacute;n. Es decir, que realmente trata estos par&amp;aacute;metros como si pudieran ser de todos los tipos.</target>
        </trans-unit>
        <trans-unit id="bb76a0dfbc0b927a30bc60fb3308eae1c0c32030" translate="yes" xml:space="preserve">
          <source>When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the &lt;em&gt;instance&lt;/em&gt; of the class.</source>
          <target state="translated">Cuando declaras una clase en TypeScript, en realidad est&amp;aacute;s creando varias declaraciones al mismo tiempo. El primero es el tipo de &lt;em&gt;instancia&lt;/em&gt; de la clase.</target>
        </trans-unit>
        <trans-unit id="63841123e89ff79b5bb8a778012e2675dfb6bf27" translate="yes" xml:space="preserve">
          <source>When you declare a variable via &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;, you are telling the compiler that there is the chance that this variable will change its contents. In contrast, using &lt;code&gt;const&lt;/code&gt; to declare a variable will inform TypeScript that this object will never change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffefcf45ac3a82bd7f38544ffbfd55e8c346d30" translate="yes" xml:space="preserve">
          <source>When you have a JavaScript project in your editor, TypeScript will provide types for your &lt;code&gt;node_modules&lt;/code&gt; automatically using the DefinitelyTyped set of &lt;code&gt;@types&lt;/code&gt; definitions. This is called automatic type acquisition, and you can customize it using the &lt;code&gt;typeAcquisition&lt;/code&gt; object in your configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c36dbc166af4c2b15a69645f3c727647f3368c" translate="yes" xml:space="preserve">
          <source>When you have this option set, by not including a module in the &lt;code&gt;types&lt;/code&gt; array it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbca5cdf2d57a23f367d0a1514252e4f2c75c7b6" translate="yes" xml:space="preserve">
          <source>When you reference a project, new things happen:</source>
          <target state="translated">Cuando se hace referencia a un proyecto,ocurren cosas nuevas:</target>
        </trans-unit>
        <trans-unit id="34a19e5b1b2f656dfeb0df790e074ddaa8c1d34a" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;this&lt;/code&gt; keyword outside of classes, it has the type &lt;code&gt;any&lt;/code&gt; by default. For instance, imagine a &lt;code&gt;Point&lt;/code&gt; class, and imagine a function that we wish to add as a method:</source>
          <target state="translated">Cuando usa la palabra clave &lt;code&gt;this&lt;/code&gt; fuera de las clases, tiene el tipo &lt;code&gt;any&lt;/code&gt; por defecto. Por ejemplo, imagina una clase &lt;code&gt;Point&lt;/code&gt; e imagina una funci&amp;oacute;n que deseamos agregar como m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="70c371f96f2c201ef59af8e252df237c2c99859d" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re happy, clone &lt;a href=&quot;https://github.com/DefinitelyTyped&quot;&gt;DefinitelyTyped/DefinitelyTyped&lt;/a&gt; and follow the instructions in the README.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2ff1337f892c7263b4813735bcd04bc80f2255" translate="yes" xml:space="preserve">
          <source>When:</source>
          <target state="translated">When:</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="2e1366df4a2e5026b79e734a847a45f2224acce3" translate="yes" xml:space="preserve">
          <source>Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619362ecade2fffba9685e4a969d18b8cca8689d" translate="yes" xml:space="preserve">
          <source>Which can be described by the following .d.ts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33710489e78a6feef64468d41a06aab499f59059" translate="yes" xml:space="preserve">
          <source>Which can be described with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bbf399003bd64788409edf57ef8dcc79e01d02" translate="yes" xml:space="preserve">
          <source>Which can be switched out with your own globals via this flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6de3b1c6e1142dd03c8ec0d38d67a76b4d0290" translate="yes" xml:space="preserve">
          <source>Which creates quite a lot of JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938fe38b788f59c1c6e957d41be0c2a25ffdccf8" translate="yes" xml:space="preserve">
          <source>Which generates code like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962849684c80963bf61b9a409447ab660d400c45" translate="yes" xml:space="preserve">
          <source>Which in turn can be imported using default imports:</source>
          <target state="translated">Que a su vez puede ser importado utilizando importaciones predeterminadas:</target>
        </trans-unit>
        <trans-unit id="cf6447c6242e379fc5cad3f436eb54be60f4dba3" translate="yes" xml:space="preserve">
          <source>Which leads us to writing our first generic interface. Let&amp;rsquo;s take the object literal from the previous example and move it to an interface:</source>
          <target state="translated">Lo que nos lleva a escribir nuestra primera interfaz gen&amp;eacute;rica. Tomemos el objeto literal del ejemplo anterior y lo movamos a una interfaz:</target>
        </trans-unit>
        <trans-unit id="70bd03441762cc2b325aef1bac1f313f2d0e16b5" translate="yes" xml:space="preserve">
          <source>Which translates to:</source>
          <target state="translated">Lo que se traduce en:</target>
        </trans-unit>
        <trans-unit id="3dbf1444b14bbeff8ff24b42f88c1114396361cf" translate="yes" xml:space="preserve">
          <source>Which would include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfe760aa187d990362b3f4c61beb430484ea0d1" translate="yes" xml:space="preserve">
          <source>Which would print this output to the console:</source>
          <target state="translated">Que imprimiría esta salida a la consola:</target>
        </trans-unit>
        <trans-unit id="53ebf7ccbab25bb66042f79bfb51a8652406a52d" translate="yes" xml:space="preserve">
          <source>While ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to &amp;ldquo;just work&amp;rdquo; TypeScript. Additionally, this approach for property declarations allows us to express common patterns like &lt;code&gt;defaultProps&lt;/code&gt; and &lt;code&gt;propTypes&lt;/code&gt; on React function components (formerly known as SFCs).</source>
          <target state="translated">Si bien las exportaciones de ECMAScript son a menudo una mejor manera de proporcionar esta funcionalidad, este nuevo soporte permite que el c&amp;oacute;digo escrito en este estilo &quot;simplemente funcione&quot; en TypeScript. Adem&amp;aacute;s, este enfoque para las declaraciones de propiedad nos permite expresar patrones comunes como &lt;code&gt;defaultProps&lt;/code&gt; y &lt;code&gt;propTypes&lt;/code&gt; en componentes de funci&amp;oacute;n React (anteriormente conocidos como SFC).</target>
        </trans-unit>
        <trans-unit id="fad58bbb4ff5e3b9b95e4764b17888edf69eef4d" translate="yes" xml:space="preserve">
          <source>While TypeScript 3.7 isn&amp;rsquo;t changing any existing emit by default, we&amp;rsquo;ve been rolling out changes incrementally to help users mitigate potential future breakage. We&amp;rsquo;ve provided a new flag called &lt;code&gt;useDefineForClassFields&lt;/code&gt; to enable this emit mode with some new checking logic.</source>
          <target state="translated">Si bien TypeScript 3.7 no cambia ninguna emisi&amp;oacute;n existente de forma predeterminada, hemos estado implementando cambios de forma incremental para ayudar a los usuarios a mitigar posibles roturas futuras. Hemos proporcionado una nueva bandera llamada &lt;code&gt;useDefineForClassFields&lt;/code&gt; para habilitar este modo de emisi&amp;oacute;n con una nueva l&amp;oacute;gica de verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f56a592c618616410fc71f4bbabb49d78514f411" translate="yes" xml:space="preserve">
          <source>While allowing people to randomly set &lt;code&gt;fullName&lt;/code&gt; directly is pretty handy, we may also want enforce some constraints when &lt;code&gt;fullName&lt;/code&gt; is set.</source>
          <target state="translated">Si bien permitir que las personas establezcan &lt;code&gt;fullName&lt;/code&gt; de forma aleatoria directamente es bastante &amp;uacute;til, es posible que tambi&amp;eacute;n deseemos aplicar algunas restricciones cuando se establece &lt;code&gt;fullName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="636d4d19d4405d30263f2aa95da0f2c2a734da53" translate="yes" xml:space="preserve">
          <source>While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let&amp;rsquo;s start with a basic example of two functions that differ only in their parameter lists:</source>
          <target state="translated">Si bien comparar tipos primitivos y tipos de objetos es relativamente sencillo, la cuesti&amp;oacute;n de qu&amp;eacute; tipos de funciones deben considerarse compatibles es un poco m&amp;aacute;s complicada. Comencemos con un ejemplo b&amp;aacute;sico de dos funciones que difieren solo en sus listas de par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="03a5fd4e6d293c6d495eff753858affb70025397" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s good practice to use &lt;code&gt;ReadonlyArray&lt;/code&gt; over &lt;code&gt;Array&lt;/code&gt; when no mutation is intended, it&amp;rsquo;s often been a pain given that arrays have a nicer syntax. Specifically, &lt;code&gt;number[]&lt;/code&gt; is a shorthand version of &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;, just as &lt;code&gt;Date[]&lt;/code&gt; is a shorthand for &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si bien es una buena pr&amp;aacute;ctica usar &lt;code&gt;ReadonlyArray&lt;/code&gt; sobre &lt;code&gt;Array&lt;/code&gt; cuando no se pretende realizar ninguna mutaci&amp;oacute;n, a menudo resulta complicado dado que las matrices tienen una sintaxis m&amp;aacute;s agradable. Espec&amp;iacute;ficamente, &lt;code&gt;number[]&lt;/code&gt; es una versi&amp;oacute;n abreviada de &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; , al igual que &lt;code&gt;Date[]&lt;/code&gt; es una abreviatura de &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c74aaa3335f7bff7bf6990f82abec0b22352a01" translate="yes" xml:space="preserve">
          <source>While not a breakage per se, opting in to the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag can cause breakage when:</source>
          <target state="translated">Si bien no es una rotura per se, optar por la &lt;code&gt;useDefineForClassFields&lt;/code&gt; puede provocar roturas cuando:</target>
        </trans-unit>
        <trans-unit id="ebbe87035da271030af0d806842f81f2cc35cc3b" translate="yes" xml:space="preserve">
          <source>While not strictly a language change, nightly builds are now available by installing with the following command:</source>
          <target state="translated">Aunque no es estrictamente un cambio de idioma,las construcciones nocturnas están ahora disponibles al instalarse con el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="3360869251a9b9ea8953b44e203398f6f81cb993" translate="yes" xml:space="preserve">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href=&quot;#enums-at-runtime&quot;&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target state="translated">Si bien las enumeraciones de cadena no tienen un comportamiento de incremento autom&amp;aacute;tico, las enumeraciones de cadena tienen la ventaja de que se &quot;serializan&quot; bien. En otras palabras, si estaba depurando y tuvo que leer el valor de tiempo de ejecuci&amp;oacute;n de una enumeraci&amp;oacute;n num&amp;eacute;rica, el valor suele ser opaco; no transmite ning&amp;uacute;n significado &amp;uacute;til por s&amp;iacute; solo (aunque &lt;a href=&quot;#enums-at-runtime&quot;&gt;el mapeo inverso a&lt;/a&gt; menudo puede ayudar), las enumeraciones de cadenas le permiten para dar un valor significativo y legible cuando se ejecuta su c&amp;oacute;digo, independientemente del nombre del miembro enum en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="9889e9833569f06fb69539d73f7b2696ca91f5f9" translate="yes" xml:space="preserve">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href=&quot;#reverse-mappings&quot;&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c063d2ee2675e04f30864acccf31e9c245c672" translate="yes" xml:space="preserve">
          <source>While string index signatures are a powerful way to describe the &amp;ldquo;dictionary&amp;rdquo; pattern, they also enforce that all properties match their return type. This is because a string index declares that &lt;code&gt;obj.property&lt;/code&gt; is also available as &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt;. In the following example, &lt;code&gt;name&lt;/code&gt;&amp;rsquo;s type does not match the string index&amp;rsquo;s type, and the type checker gives an error:</source>
          <target state="translated">Si bien las firmas de &amp;iacute;ndice de cadena son una forma poderosa de describir el patr&amp;oacute;n de &quot;diccionario&quot;, tambi&amp;eacute;n imponen que todas las propiedades coincidan con su tipo de retorno. Esto se debe a que un &amp;iacute;ndice de cadena declara que &lt;code&gt;obj.property&lt;/code&gt; tambi&amp;eacute;n est&amp;aacute; disponible como &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt; . En el siguiente ejemplo, el tipo de &lt;code&gt;name&lt;/code&gt; no coincide con el tipo de &amp;iacute;ndice de cadena y el verificador de tipo da un error:</target>
        </trans-unit>
        <trans-unit id="205fbdc2b0eb96d4c083fa10d1cf873197618502" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;any&lt;/code&gt; is certainly generic in that it will cause the function to accept any and all types for the type of &lt;code&gt;arg&lt;/code&gt;, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</source>
          <target state="translated">Si bien el uso de &lt;code&gt;any&lt;/code&gt; es ciertamente gen&amp;eacute;rico en el sentido de que har&amp;aacute; que la funci&amp;oacute;n acepte todos y cada uno de los tipos para el tipo de &lt;code&gt;arg&lt;/code&gt; , en realidad estamos perdiendo la informaci&amp;oacute;n sobre cu&amp;aacute;l era ese tipo cuando la funci&amp;oacute;n regresa. Si pasamos un n&amp;uacute;mero, la &amp;uacute;nica informaci&amp;oacute;n que tenemos es que se puede devolver cualquier tipo.</target>
        </trans-unit>
        <trans-unit id="ad9ab077983f93d52e50138e0c0b8bb1d71036dc" translate="yes" xml:space="preserve">
          <source>While you can use TypeScript to produce JavaScript code from TypeScript code, it&amp;rsquo;s also common to use other transpilers such as &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt; to do this. However, other transpilers only operate on a single file at a time, which means they can&amp;rsquo;t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript&amp;rsquo;s &lt;code&gt;ts.transpileModule&lt;/code&gt; API which is used by some build tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3773d499a43f196d119753de15012adfe413581f" translate="yes" xml:space="preserve">
          <source>While you might imagine close interaction between &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;bigint&lt;/code&gt;, the two are separate domains.</source>
          <target state="translated">Si bien puede imaginar una interacci&amp;oacute;n cercana entre &lt;code&gt;number&lt;/code&gt; y &lt;code&gt;bigint&lt;/code&gt; , los dos son dominios separados.</target>
        </trans-unit>
        <trans-unit id="7942bdf53c9b517b254a399642caadffcd723ac5" translate="yes" xml:space="preserve">
          <source>Why does a module in the exclude list still get picked up by the compiler?</source>
          <target state="translated">¿Por qué un módulo de la lista de exclusión sigue siendo recogido por el compilador?</target>
        </trans-unit>
        <trans-unit id="dd7392a9f697967405bb99a3337ee2df7f8bb374" translate="yes" xml:space="preserve">
          <source>Wildcard character in module names</source>
          <target state="translated">Carácter comodín en los nombres de los módulos</target>
        </trans-unit>
        <trans-unit id="90ff022ca86ce297643ad53057127508fda59a21" translate="yes" xml:space="preserve">
          <source>Wildcard module declarations</source>
          <target state="translated">Declaraciones del módulo comodín</target>
        </trans-unit>
        <trans-unit id="e1deac0ee95462765acc0e4d19e587e5b367dac8" translate="yes" xml:space="preserve">
          <source>Wildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Los nombres de los m&amp;oacute;dulos comod&amp;iacute;n pueden ser incluso m&amp;aacute;s &amp;uacute;tiles cuando se migra desde una base de c&amp;oacute;digo sin escribir. Combinado con declaraciones de m&amp;oacute;dulos ambientales abreviados, un conjunto de m&amp;oacute;dulos se puede declarar f&amp;aacute;cilmente como &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="576eaaaec7aa1978999d8da3f80d2816c7c61923" translate="yes" xml:space="preserve">
          <source>Will generate an &lt;code&gt;index.js&lt;/code&gt; file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294ac8947e55f645c50e17c1f027a18712e8f38f" translate="yes" xml:space="preserve">
          <source>Will generate the following JavaScript output:</source>
          <target state="translated">Generará la siguiente salida de JavaScript:</target>
        </trans-unit>
        <trans-unit id="49659e5a07d9ec9ddbc5ea2cded9dfed86235252" translate="yes" xml:space="preserve">
          <source>Will generate:</source>
          <target state="translated">Se generará:</target>
        </trans-unit>
        <trans-unit id="9d704e8d8dc3b8c3f478cd3a1e99749549751af4" translate="yes" xml:space="preserve">
          <source>Will not add globals to your project (e.g &lt;code&gt;process&lt;/code&gt; in node, or &lt;code&gt;expect&lt;/code&gt; in Jest)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c5226c3b0025dce708838e9de5a2bc24249633" translate="yes" xml:space="preserve">
          <source>Will not have exports appear as auto-import recommendations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74eea0f1c70b52371bc0816bb556d0f8780652ce" translate="yes" xml:space="preserve">
          <source>Will produce a &lt;code&gt;.d.ts&lt;/code&gt; file like</source>
          <target state="translated">Producir&amp;aacute; un archivo &lt;code&gt;.d.ts&lt;/code&gt; como</target>
        </trans-unit>
        <trans-unit id="8dc5830cdd248d481961de84dd0f5250619d9bd8" translate="yes" xml:space="preserve">
          <source>Will result in assigning the name &lt;code&gt;NamedModule&lt;/code&gt; to the module as part of calling the AMD &lt;code&gt;define&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NamedModule&lt;/code&gt; como resultado la asignaci&amp;oacute;n del nombre NamedModule al m&amp;oacute;dulo como parte de la llamada a AMD &lt;code&gt;define&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ccd47948ed1aa34956ec39f702d4f4d8e5beb53d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;React 17&lt;/a&gt; the library supports a new form of JSX transformation via a separate import.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d439834e2baaed052d93e4971a2a939ad111045c" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fa735b620d5297fbccee8fa108c418d0b3be08" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&quot;allowUnreachableCode&quot;: false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c698c1cfe17edf510077db506e15f74e06ad129" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&quot;baseUrl&quot;: &quot;./&quot;&lt;/code&gt; inside this project TypeScript will look for files starting at the same folder as the &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13740d4f0b7aedad3ff699e83aa212feeaefbb89" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--downlevelIteration&lt;/code&gt;, the compiler uses new type check and emit behavior that attempts to call a &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.</source>
          <target state="translated">Con &lt;code&gt;--downlevelIteration&lt;/code&gt; , el compilador usa un nuevo comportamiento de verificaci&amp;oacute;n y emisi&amp;oacute;n de tipos que intenta llamar a un &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; en el objeto iterado si se encuentra, y crea un iterador de matriz sint&amp;eacute;tico sobre el objeto si no lo est&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="0baf96b645c93694808d46132810c65e4ff0d180" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--esModuleInterop&lt;/code&gt; two new helpers are generated &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; for import &lt;code&gt;*&lt;/code&gt; and import &lt;code&gt;default&lt;/code&gt; respectively. For instance input like:</source>
          <target state="translated">Con &lt;code&gt;--esModuleInterop&lt;/code&gt; se generan dos nuevos ayudantes &lt;code&gt;__importStar&lt;/code&gt; y &lt;code&gt;__importDefault&lt;/code&gt; para la importaci&amp;oacute;n &lt;code&gt;*&lt;/code&gt; y la importaci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; respectivamente. Por ejemplo, ingrese como:</target>
        </trans-unit>
        <trans-unit id="3da68912666fd5861031d156bf5a2c7082eb8729" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;, this example will trigger an error:</source>
          <target state="translated">Con &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; , este ejemplo desencadenar&amp;aacute; un error:</target>
        </trans-unit>
        <trans-unit id="f2e90c030cc7f4b83e2a77c542e137b8a0ccca5d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--strictNullChecks&lt;/code&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target state="translated">Con &lt;code&gt;--strictNullChecks&lt;/code&gt; , un par&amp;aacute;metro opcional agrega autom&amp;aacute;ticamente &lt;code&gt;| undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="32a499399a274aac8c9b26572f194ee6506912c8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. You will also get an error if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target state="translated">Con &lt;code&gt;@constructor&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; se verifica dentro de la funci&amp;oacute;n constructora &lt;code&gt;C&lt;/code&gt; , por lo que obtendr&amp;aacute; sugerencias para el m&amp;eacute;todo de &lt;code&gt;initialize&lt;/code&gt; y un error si le pasa un n&amp;uacute;mero. Tambi&amp;eacute;n obtendr&amp;aacute; un error si llama a &lt;code&gt;C&lt;/code&gt; en lugar de construirlo.</target>
        </trans-unit>
        <trans-unit id="a035a3570a36bd407b773b9516d29f13b1a3f416" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. Your editor may also show warnings if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d91be3836c575b7186f6f373bced4bbebe5f6bb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; not set to true (default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bf84665fe838195d196abf704465f50c25a018" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; set to true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91ba76f93ca7d7e7796d620a3627489f9dfc963" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;esModuleInterop&lt;/code&gt; disabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856c403e9c9ac477d8823a19f4509e5405076b88" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;esModuleInterop&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df6054d7160294fcb8ad604c1672c83e1b676c9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;false&lt;/code&gt;, the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ea5d91d6887a555bb6f2794a07c5714e99ed42" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;import&lt;/code&gt; types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.</source>
          <target state="translated">Con &lt;code&gt;import&lt;/code&gt; tipos de importaci&amp;oacute;n disponibles, muchos de los errores de visibilidad notificados durante la generaci&amp;oacute;n del archivo de declaraci&amp;oacute;n pueden ser manejados por el compilador sin la necesidad de cambiar la entrada.</target>
        </trans-unit>
        <trans-unit id="0b3f0c8f5386232b3414f9e7bc8c3f6e1ed65eec" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;jsxFactory: &quot;h&quot;&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84d42cb295076793894c8acadb047e99a4e746a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;object&lt;/code&gt; type, APIs like &lt;code&gt;Object.create&lt;/code&gt; can be better represented. For example:</source>
          <target state="translated">Con el tipo de &lt;code&gt;object&lt;/code&gt; , las API como &lt;code&gt;Object.create&lt;/code&gt; se pueden representar mejor. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8ea2d3d828b1a918f20e697667351b7f6a125a32" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;preserveConstEnums&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;enum&lt;/code&gt; exists at runtime and the numbers are still emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a01b47e5ab896c53b6fbdf6dc40647a614653e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;state&lt;/code&gt; as a literal type, you can compare the value of &lt;code&gt;state&lt;/code&gt; to the equivalent string and TypeScript will know which type is currently being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e1537de3780fc9b8daffc9debdc08216587d32" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;strictFunctionTypes&lt;/code&gt;&lt;em&gt;on&lt;/em&gt;, the error is correctly detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787b06dec962cd4ac1d5fed3f2e1a225bfd61e2b" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;stripInternal&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; the &lt;code&gt;d.ts&lt;/code&gt; emitted will be redacted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa847821456a4401d0546fcc0d18f6208406246" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;this&lt;/code&gt; annotated, you make it explicit that &lt;code&gt;onClickBad&lt;/code&gt; must be called on an instance of &lt;code&gt;Handler&lt;/code&gt;. Then TypeScript will detect that &lt;code&gt;addClickListener&lt;/code&gt; requires a function that has &lt;code&gt;this: void&lt;/code&gt;. To fix the error, change the type of &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Con &lt;code&gt;this&lt;/code&gt; anotado, &lt;code&gt;onClickBad&lt;/code&gt; expl&amp;iacute;cito que se debe llamar a onClickBad en una instancia de &lt;code&gt;Handler&lt;/code&gt; . Entonces TypeScript detectar&amp;aacute; que &lt;code&gt;addClickListener&lt;/code&gt; requiere una funci&amp;oacute;n que tenga &lt;code&gt;this: void&lt;/code&gt; . Para corregir el error, cambie el tipo de &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af6f22a2cba3d56fa994838cc0aadc7b657d06d7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275d348200c6c9320565561ab80694a7f189a460" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;var&lt;/code&gt; declarations, we mentioned that it didn&amp;rsquo;t matter how many times you declared your variables; you just got one.</source>
          <target state="translated">Con las declaraciones &lt;code&gt;var&lt;/code&gt; , mencionamos que no importa cu&amp;aacute;ntas veces declaraste tus variables; solo tienes uno.</target>
        </trans-unit>
        <trans-unit id="c9b5a6af6e81107e965d92874d8f98c54b8d5351" translate="yes" xml:space="preserve">
          <source>With ES6&amp;rsquo;s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt;. TypeScript will emit the string in ES3/ES5 as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;.</source>
          <target state="translated">Con los escapes de puntos de c&amp;oacute;digo de ES6, puede representar claramente ese car&amp;aacute;cter exacto en cadenas y cadenas de plantillas con un solo escape: &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt; . TypeScript emitir&amp;aacute; la cadena en ES3 / ES5 como &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3fe0d7c3c1bcf18bd50d0141170db310dc43d9e" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.6, type aliases can be generic. For example:</source>
          <target state="translated">Con TypeScript 1.6,los alias de tipo pueden ser genéricos.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="460f7c766e92b496f73d02d4ccf0cc4d7ee440b6" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as &lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F-Bounded Polymorphism&lt;/a&gt;.</source>
          <target state="translated">Con TypeScript 1.8 es posible que una restricci&amp;oacute;n de par&amp;aacute;metro de tipo haga referencia a par&amp;aacute;metros de tipo de la misma lista de par&amp;aacute;metros de tipo. Anteriormente, esto era un error. Esta capacidad se refiere generalmente como &lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F-Bounded polimorfismo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10bf274b692b3bbc5a7692bb92ffc8f07852abb4" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.</source>
          <target state="translated">Con TypeScript 1.8,las etiquetas JSX están ahora clasificadas y coloreadas en Visual Studio 2015.</target>
        </trans-unit>
        <trans-unit id="c62a9b4ded80d831595f6cf41c707a66d7b472df" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, we&amp;rsquo;ve introduced string literal types. These types are written the same way string literals are, but in type positions.</source>
          <target state="translated">Con TypeScript 1.8, hemos introducido tipos de cadenas literales. Estos tipos se escriben de la misma forma que los literales de cadena, pero en posiciones de tipo.</target>
        </trans-unit>
        <trans-unit id="cafdb66c7fc578df947b8db9b1207f3133582261" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.0, the compiler will look up definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.ts&lt;/code&gt; or &lt;code&gt;./moduleA.d.t&lt;/code&gt;.</source>
          <target state="translated">Con TypeScript 2.0, el compilador buscar&amp;aacute; la definici&amp;oacute;n de &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; en &lt;code&gt;./moduleA.ts&lt;/code&gt; o &lt;code&gt;./moduleA.d.t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f9f7cdd4003c7ab1f53ac08b77e405631b7232" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, instead of just choosing &lt;code&gt;any&lt;/code&gt;, TypeScript will infer types based on what you end up assigning later on.</source>
          <target state="translated">Con TypeScript 2.1, en lugar de simplemente elegir &lt;code&gt;any&lt;/code&gt; , TypeScript inferir&amp;aacute; tipos en funci&amp;oacute;n de lo que termines asignando m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="9277e32824b441ad62cb76d21644b7bd58f69e2f" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, you can import a JavaScript module without needing a type declaration. A type declaration (such as &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; or &lt;code&gt;node_modules/@types/foo&lt;/code&gt;) still takes priority if it exists.</source>
          <target state="translated">Con TypeScript 2.1, puede importar un m&amp;oacute;dulo JavaScript sin necesidad de una declaraci&amp;oacute;n de tipo. Una declaraci&amp;oacute;n de tipo (como &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; o &lt;code&gt;node_modules/@types/foo&lt;/code&gt; ) todav&amp;iacute;a tiene prioridad si existe.</target>
        </trans-unit>
        <trans-unit id="fbf94ecb57bb0f01e4f682c5fcfc23891843f05c" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.8 &lt;code&gt;keyof&lt;/code&gt; applied to an intersection type is transformed to a union of &lt;code&gt;keyof&lt;/code&gt; applied to each intersection constituent. In other words, types of the form &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; are transformed to be &lt;code&gt;keyof A | keyof B&lt;/code&gt;. This change should address inconsistencies with inference from &lt;code&gt;keyof&lt;/code&gt; expressions.</source>
          <target state="translated">Con TypeScript 2.8, &lt;code&gt;keyof&lt;/code&gt; aplicada a un tipo de intersecci&amp;oacute;n se transforma en una uni&amp;oacute;n de &lt;code&gt;keyof&lt;/code&gt; aplicada a cada constituyente de intersecci&amp;oacute;n. En otras palabras, los tipos de la forma &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; se transforman para ser &lt;code&gt;keyof A | keyof B&lt;/code&gt; . Este cambio deber&amp;iacute;a abordar las inconsistencias con la inferencia de expresiones &lt;code&gt;keyof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799099f20671837db4b655a12286097f02ebcd18" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.9, no errors are reported, and now the generated file looks like:</source>
          <target state="translated">Con TypeScript 2.9,no se reportan errores,y ahora el archivo generado se ve como:</target>
        </trans-unit>
        <trans-unit id="593a67e967dde8319eb871882cb980edd2921bd0" translate="yes" xml:space="preserve">
          <source>With TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c155aa6cb506c0f0942a50171b6b5c899640514a" translate="yes" xml:space="preserve">
          <source>With TypeScript 3.8, you can use &lt;code&gt;export * as ns&lt;/code&gt; as a shorthand for re-exporting another module with a name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61e7a4d8ea1ab6a29d0ab09e04c9367f5313f2f" translate="yes" xml:space="preserve">
          <source>With TypeScript being a superset of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">Dado que TypeScript es un superconjunto de JavaScript, el lenguaje naturalmente admite &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; . Aqu&amp;iacute; profundizaremos m&amp;aacute;s en estas nuevas declaraciones y por qu&amp;eacute; son preferibles a &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64acedeec41f3540960ea284815c1fcdf273f591" translate="yes" xml:space="preserve">
          <source>With TypeScript being an extension of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05547de14b26a58915e578c86428fac86c5d55e1" translate="yes" xml:space="preserve">
          <source>With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with Unions, and with Generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d707a1290fe39949a2e479395f58ab100dab281" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;tsconfig.json&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3feff2c10853072f1034314c16cdb18d37370a30" translate="yes" xml:space="preserve">
          <source>With a corresponding &lt;code&gt;helloWorld.d.ts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f706ee444b6a34fbb533bf241523f396e3c6d47a" translate="yes" xml:space="preserve">
          <source>With a union, you can declare that a type could be one of many types. For example, you can describe a &lt;code&gt;boolean&lt;/code&gt; type as being either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f558e3e809cb29cfb2ac66cc2514576d7422f4" translate="yes" xml:space="preserve">
          <source>With definite assignment assertions, we can assert that &lt;code&gt;x&lt;/code&gt; is really assigned by appending an &lt;code&gt;!&lt;/code&gt; to its declaration:</source>
          <target state="translated">Con aserciones de asignaci&amp;oacute;n definidas, podemos afirmar que &lt;code&gt;x&lt;/code&gt; se asigna realmente agregando un &lt;code&gt;!&lt;/code&gt; a su declaraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="1b9ea4bd3d43c0f24f8d1235be222ef088964840" translate="yes" xml:space="preserve">
          <source>With generic parameter defaults we can reduce it to:</source>
          <target state="translated">Con los parámetros genéricos por defecto podemos reducirlo a:</target>
        </trans-unit>
        <trans-unit id="285525d91c532d67502baa5d535e42948f1fec46" translate="yes" xml:space="preserve">
          <source>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:</source>
          <target state="translated">Con los tipos de índice,puedes hacer que el compilador compruebe el código que utiliza nombres de propiedades dinámicas.Por ejemplo,un patrón común de JavaScript es elegir un subconjunto de propiedades de un objeto:</target>
        </trans-unit>
        <trans-unit id="16dcd92f3ae6feec4cfbb7198eb7027566939a02" translate="yes" xml:space="preserve">
          <source>With more &lt;code&gt;tsconfig.json&lt;/code&gt; files, you&amp;rsquo;ll usually want to use &lt;a href=&quot;tsconfig-json&quot;&gt;Configuration file inheritance&lt;/a&gt; to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.</source>
          <target state="translated">Con m&amp;aacute;s archivos &lt;code&gt;tsconfig.json&lt;/code&gt; , normalmente querr&amp;aacute; usar &lt;a href=&quot;tsconfig-json&quot;&gt;la herencia de archivos de configuraci&amp;oacute;n&lt;/a&gt; para centralizar las opciones comunes del compilador. De esta forma, puede cambiar una configuraci&amp;oacute;n en un archivo en lugar de tener que editar varios archivos.</target>
        </trans-unit>
        <trans-unit id="6c19413ec559ade6957207124c85c3143a8ddce9" translate="yes" xml:space="preserve">
          <source>With the flag set to &lt;code&gt;false&lt;/code&gt; (default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc980dcbd81da3823a44dd1638ddc07a1ed0b4b4" translate="yes" xml:space="preserve">
          <source>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;stage 2 proposal&lt;/a&gt; for JavaScript and are available as an experimental feature of TypeScript.</source>
          <target state="translated">Con la introducci&amp;oacute;n de Clases en TypeScript y ES6, ahora existen ciertos escenarios que requieren caracter&amp;iacute;sticas adicionales para admitir la anotaci&amp;oacute;n o modificaci&amp;oacute;n de clases y miembros de clase. Los decoradores proporcionan una forma de agregar anotaciones y una sintaxis de metaprogramaci&amp;oacute;n para las declaraciones de clase y los miembros. Los decoradores son una &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;propuesta&lt;/a&gt; de fase 2 para JavaScript y est&amp;aacute;n disponibles como una funci&amp;oacute;n experimental de TypeScript.</target>
        </trans-unit>
        <trans-unit id="d5cc45fbb67785639194811b9d1feec6410a8444" translate="yes" xml:space="preserve">
          <source>With these all set up, then you can create a class which represents the base class with mixins applied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c7c6883f9c76d8e00e3e2c0ffe4b6a8b55fa95" translate="yes" xml:space="preserve">
          <source>With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.</source>
          <target state="translated">Con estas características es posible escribir con fuerza una serie de funciones de orden superior que transforman las funciones y sus listas de parámetros.</target>
        </trans-unit>
        <trans-unit id="57d2f941d62c110711648e01f573d26e835149f4" translate="yes" xml:space="preserve">
          <source>With this TypeScript code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433e4f23f467e7ae0dc8cfdd04d371137cd886c1" translate="yes" xml:space="preserve">
          <source>With this change, the overloads now give us type checked calls to the &lt;code&gt;pickCard&lt;/code&gt; function.</source>
          <target state="translated">Con este cambio, las sobrecargas ahora nos dan llamadas de tipo verificado a la funci&amp;oacute;n &lt;code&gt;pickCard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78f2f313b67611945a513d63a8211e0d1592c710" translate="yes" xml:space="preserve">
          <source>With this enabled, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50288405a714a4c057a990453fc548fab19c0a86" translate="yes" xml:space="preserve">
          <source>With union types able to represent a wide range of type scenarios, we&amp;rsquo;ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</source>
          <target state="translated">Con tipos de uni&amp;oacute;n capaces de representar una amplia gama de escenarios de tipos, hemos decidido mejorar el rigor de ciertas llamadas gen&amp;eacute;ricas. Anteriormente, un c&amp;oacute;digo como este se compilar&amp;iacute;a (sorprendentemente) sin errores:</target>
        </trans-unit>
        <trans-unit id="4aaf334cc02fe3036ee03973d99bc9627c8d8c34" translate="yes" xml:space="preserve">
          <source>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</source>
          <target state="translated">Con los tipos de unión,ahora puede especificar el comportamiento deseado tanto en el sitio de declaración de la función como en el sitio de llamada:</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="1faa6ed78c77561690bfff2329835e7f699fad40" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method), but the &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Location&lt;/code&gt; classes are not.</source>
          <target state="translated">Dentro de la clase &lt;code&gt;Control&lt;/code&gt; es posible acceder al miembro privado &lt;code&gt;state&lt;/code&gt; trav&amp;eacute;s de una instancia de &lt;code&gt;SelectableControl&lt;/code&gt; . Efectivamente, un &lt;code&gt;SelectableControl&lt;/code&gt; act&amp;uacute;a como un &lt;code&gt;Control&lt;/code&gt; que se sabe que tiene un m&amp;eacute;todo de &lt;code&gt;select&lt;/code&gt; . Las clases &lt;code&gt;Button&lt;/code&gt; y &lt;code&gt;TextBox&lt;/code&gt; son subtipos de &lt;code&gt;SelectableControl&lt;/code&gt; (porque ambas heredan de &lt;code&gt;Control&lt;/code&gt; y tienen un m&amp;eacute;todo de &lt;code&gt;select&lt;/code&gt; ), pero las clases &lt;code&gt;Image&lt;/code&gt; y &lt;code&gt;Location&lt;/code&gt; no lo son.</target>
        </trans-unit>
        <trans-unit id="40659a03fa7e7592baf48c7a0c5720e665372319" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method). The &lt;code&gt;ImageControl&lt;/code&gt; class has it&amp;rsquo;s own &lt;code&gt;state&lt;/code&gt; private member rather than extending &lt;code&gt;Control&lt;/code&gt;, so it cannot implement &lt;code&gt;SelectableControl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11991f5f3539f8365b2755a33096a790d376c466" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extends&lt;/code&gt; clause of a conditional type, it is now possible to have &lt;code&gt;infer&lt;/code&gt; declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple &lt;code&gt;infer&lt;/code&gt; locations for the same type variable.</source>
          <target state="translated">Dentro del &lt;code&gt;extends&lt;/code&gt; cl&amp;aacute;usula de tipo condicional, ahora es posible tener &lt;code&gt;infer&lt;/code&gt; declaraciones que introducen una variable de tipo de inferirse. Se puede hacer referencia a tales variables de tipo inferido en la rama verdadera del tipo condicional. Es posible tener m&amp;uacute;ltiples ubicaciones &lt;code&gt;infer&lt;/code&gt; idas para el mismo tipo de variable.</target>
        </trans-unit>
        <trans-unit id="025d407dde53ca8d56d3a7b67f8687df35d8b119" translate="yes" xml:space="preserve">
          <source>Within the same block duplicate definitions are still disallowed.</source>
          <target state="translated">Dentro del mismo bloque las definiciones duplicadas siguen estando desautorizadas.</target>
        </trans-unit>
        <trans-unit id="9735c33d4a9302da353c7b0e0f8ad6d2bbb66115" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;downlevelIteration&lt;/code&gt; enabled, a &lt;code&gt;for / of&lt;/code&gt; loop on any object is downleveled to a traditional &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244687c671b9bf5c3bf00c75ac23daf9254dabd2" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;ScientificCalculator&lt;/code&gt; would not have been able to extend &lt;code&gt;BasicCalculator&lt;/code&gt; and keep the fluent interface. &lt;code&gt;multiply&lt;/code&gt; would have returned &lt;code&gt;BasicCalculator&lt;/code&gt;, which doesn&amp;rsquo;t have the &lt;code&gt;sin&lt;/code&gt; method. However, with &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;multiply&lt;/code&gt; returns &lt;code&gt;this&lt;/code&gt;, which is &lt;code&gt;ScientificCalculator&lt;/code&gt; here.</source>
          <target state="translated">Sin &lt;code&gt;this&lt;/code&gt; tipos, &lt;code&gt;ScientificCalculator&lt;/code&gt; no habr&amp;iacute;a podido extender &lt;code&gt;BasicCalculator&lt;/code&gt; y mantener la interfaz fluida. &lt;code&gt;multiply&lt;/code&gt; habr&amp;iacute;a devuelto &lt;code&gt;BasicCalculator&lt;/code&gt; , que no tiene el m&amp;eacute;todo &lt;code&gt;sin&lt;/code&gt; . Sin embargo, con &lt;code&gt;this&lt;/code&gt; tipo, &lt;code&gt;multiply&lt;/code&gt; devuelve &lt;code&gt;this&lt;/code&gt; , que es &lt;code&gt;ScientificCalculator&lt;/code&gt; aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="4e062851d9b41c2fc52e761a5a5db277213a8a79" translate="yes" xml:space="preserve">
          <source>Without generics, we would either have to give the identity function a specific type:</source>
          <target state="translated">Sin los genéricos,tendríamos que dar a la función de identidad un tipo específico:</target>
        </trans-unit>
        <trans-unit id="94acabacd4951abae06ed7d329ea42ae0a58c740" translate="yes" xml:space="preserve">
          <source>Without knowledge of the values of these members, other transpilers can&amp;rsquo;t replace the references to &lt;code&gt;Number&lt;/code&gt;, which would be a runtime error if left alone (since there are no &lt;code&gt;Numbers&lt;/code&gt; object at runtime). Because of this, when &lt;code&gt;isolatedModules&lt;/code&gt; is set, it is an error to reference an ambient &lt;code&gt;const enum&lt;/code&gt; member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00201f849d1c48c82416c11f802e9a66c3600782" translate="yes" xml:space="preserve">
          <source>Without setting &lt;code&gt;removeComments&lt;/code&gt; or having it as &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f67c21f22ceab8ce26ba774a06869c3e5ea9d49" translate="yes" xml:space="preserve">
          <source>Working with Generic Type Variables</source>
          <target state="translated">Trabajando con Variables de Tipo Genérico</target>
        </trans-unit>
        <trans-unit id="5dec7390553f0c8e11febdec62abeb23d870ba14" translate="yes" xml:space="preserve">
          <source>Working with Other JavaScript Libraries</source>
          <target state="translated">Trabajar con otras bibliotecas de JavaScript</target>
        </trans-unit>
        <trans-unit id="0e5c5aeb5b5c1f3bc5c5f5f8d62b7bc1a585d5dc" translate="yes" xml:space="preserve">
          <source>Works in tandem with &lt;code&gt;allowJs&lt;/code&gt;. When &lt;code&gt;checkJs&lt;/code&gt; is enabled then errors are reported in JavaScript files. This is the equivalent of including &lt;code&gt;// @ts-check&lt;/code&gt; at the top of all JavaScript files which are included in your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb174c18ecc84cb0d3bcf90788707696b007bc5" translate="yes" xml:space="preserve">
          <source>Would add &lt;code&gt;preact/jsx-runtime&lt;/code&gt; as an import for the &lt;code&gt;_jsx&lt;/code&gt; factory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584f179f141358ddf434da1f8a8d5abbc0ae519b" translate="yes" xml:space="preserve">
          <source>Would declare that &lt;code&gt;index.js&lt;/code&gt; will have a source file at &lt;code&gt;https://my-website.com/debug/source/index.ts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efdb26317cc1befd0965c705beeabd7a3facadd" translate="yes" xml:space="preserve">
          <source>Would declare that &lt;code&gt;index.js&lt;/code&gt; will have sourcemaps at &lt;code&gt;https://my-website.com/debug/sourcemaps/index.js.map&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6170858562fd81d218ec9a03c46f20224b39cf2" translate="yes" xml:space="preserve">
          <source>Would echo paths like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1231a1512daa0744414ea3f58fde0c7b8ae3edc8" translate="yes" xml:space="preserve">
          <source>Would look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c17b2d1a864a8fcd44eef5059b45f5c7e951923" translate="yes" xml:space="preserve">
          <source>Would place the d.ts for the &lt;code&gt;index.ts&lt;/code&gt; in a &lt;code&gt;types&lt;/code&gt; folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb6c46801aca7729ea1a91a878ce6c995fb3d2b" translate="yes" xml:space="preserve">
          <source>Write a .d.ts declaration for a simple function, object, or class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944e87083d9fc0d208f24e3ca6004e001d6ee8c0" translate="yes" xml:space="preserve">
          <source>Write a HTML page</source>
          <target state="translated">Ecrire une page HTML</target>
        </trans-unit>
        <trans-unit id="9a3206c5e21cfc9c171ea878cfc1acee74565cd8" translate="yes" xml:space="preserve">
          <source>Write a simple example</source>
          <target state="translated">Rédigez un exemple simple</target>
        </trans-unit>
        <trans-unit id="e885a108400a007a39fa103119566542fbe5da72" translate="yes" xml:space="preserve">
          <source>Write some code</source>
          <target state="translated">Ecrivez un code</target>
        </trans-unit>
        <trans-unit id="efab40cfd729fdef6a3321a502f603a5fd3d1efd" translate="yes" xml:space="preserve">
          <source>Write-only references now flagged as unused</source>
          <target state="translated">Les références écrites uniquement sont désormais signalées comme inutilisées</target>
        </trans-unit>
        <trans-unit id="1f09dbf6607d2b3a3fef434b06897c0d44094e34" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; directive atop every generated file.</source>
          <target state="translated">Escribe &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; directiva sobre cada archivo generado.</target>
        </trans-unit>
        <trans-unit id="caefe3ddb12a11eef5e5aa559be74af44b08a512" translate="yes" xml:space="preserve">
          <source>Writing a Configuration File</source>
          <target state="translated">Rédaction d'un fichier de configuration</target>
        </trans-unit>
        <trans-unit id="8d3bf80dd76a472762dc04013242f325f5d4630a" translate="yes" xml:space="preserve">
          <source>Writing the function type</source>
          <target state="translated">Rédaction du type de fonction</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="124e1188da963d3aaab4e295c7a108fbd2a41dd4" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see:</source>
          <target state="translated">Usted &lt;em&gt;no va a&lt;/em&gt; ver:</target>
        </trans-unit>
        <trans-unit id="a0826b2d3de77311d09a836d3625c330fde392d4" translate="yes" xml:space="preserve">
          <source>You also need to include &lt;code&gt;esnext&lt;/code&gt; in your &lt;code&gt;--lib&lt;/code&gt; option, to get the &lt;code&gt;AsyncIterator&lt;/code&gt; declaration if you do not already have it.</source>
          <target state="translated">Tambi&amp;eacute;n necesita incluir &lt;code&gt;esnext&lt;/code&gt; en su opci&amp;oacute;n &lt;code&gt;--lib&lt;/code&gt; , para obtener la declaraci&amp;oacute;n &lt;code&gt;AsyncIterator&lt;/code&gt; si a&amp;uacute;n no la tiene.</target>
        </trans-unit>
        <trans-unit id="9dbfe774d94760df702cae74c61861ed61736c9f" translate="yes" xml:space="preserve">
          <source>You are not sure that TypeScript has included a file you expected, as a part of debugging the &lt;a href=&quot;#Project_Files_0&quot;&gt;file inclusion settings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb77374dde597ec3f89f049a8b2572ac5e594b0" translate="yes" xml:space="preserve">
          <source>You are using TypeScript to only generate &lt;code&gt;d.ts&lt;/code&gt; files for your consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61cc6e69930635f4f2ec81f40d529f5f6496336" translate="yes" xml:space="preserve">
          <source>You are using a transpiler other than TypeScript to generate your JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d178984134105b099386ca1a8bdc43d115ba87" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;see more details in the pull request&lt;/a&gt;.</source>
          <target state="translated">Puede &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;ver m&amp;aacute;s detalles en la solicitud de extracci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fc0ff3454e62e27b1d1616762b98ba9e340784f" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;read up more about this change by reading up on its pull request&lt;/a&gt;.</source>
          <target state="translated">Puede &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;leer m&amp;aacute;s sobre este cambio leyendo su solicitud de extracci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2d37b1f71e5cef3cd269ee2fede52081b3627c" translate="yes" xml:space="preserve">
          <source>You can also add declarations to the global scope from inside a module:</source>
          <target state="translated">Vous pouvez également ajouter des déclarations au champ d'application global à l'intérieur d'un module :</target>
        </trans-unit>
        <trans-unit id="aa5e7508cbf31286f90d3fa92778943caff41bbb" translate="yes" xml:space="preserve">
          <source>You can also create nested namespaces in one declaration:</source>
          <target state="translated">Vous pouvez également créer des espaces de noms imbriqués dans une déclaration :</target>
        </trans-unit>
        <trans-unit id="c9e0636992c973f4dd8a12b1aab83b4e3dc21c83" translate="yes" xml:space="preserve">
          <source>You can also describe methods in an interface that are implemented in the class, as we do with &lt;code&gt;setTime&lt;/code&gt; in the below example:</source>
          <target state="translated">Tambi&amp;eacute;n puede describir m&amp;eacute;todos en una interfaz que se implementan en la clase, como lo hacemos con &lt;code&gt;setTime&lt;/code&gt; en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="10881a4ac29a88d1e8e385325bacc892d71cbc57" translate="yes" xml:space="preserve">
          <source>You can also destructure objects:</source>
          <target state="translated">Vous pouvez également déstructurer des objets :</target>
        </trans-unit>
        <trans-unit id="f263658c8957170383fc6acd098a9e253a17a6eb" translate="yes" xml:space="preserve">
          <source>You can also enable prepending the output of a dependency using the &lt;code&gt;prepend&lt;/code&gt; option in a reference:</source>
          <target state="translated">Tambi&amp;eacute;n puede habilitar anteponer la salida de una dependencia usando la opci&amp;oacute;n &lt;code&gt;prepend&lt;/code&gt; en una referencia:</target>
        </trans-unit>
        <trans-unit id="7a3ee9c0b30719b4ec3010d9b67f41513948956a" translate="yes" xml:space="preserve">
          <source>You can also give different names to properties:</source>
          <target state="translated">También puedes dar diferentes nombres a las propiedades:</target>
        </trans-unit>
        <trans-unit id="46914e5a790630d332743102ee7c0fd4a1d3bfaa" translate="yes" xml:space="preserve">
          <source>You can also import commonjs modules &amp;mdash; modules written using node.js&amp;rsquo; module system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57504dce8579275ca3fec263bbff7e03026c0c14" translate="yes" xml:space="preserve">
          <source>You can also import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa56c11bed0da0fe19acfcb08f266a5ef3e86db8" translate="yes" xml:space="preserve">
          <source>You can also import declarations from other files using import types. This syntax is Typescript-specific and differs from the JSDoc standard:</source>
          <target state="translated">También se pueden importar declaraciones de otros archivos utilizando tipos de importación.Esta sintaxis es específica de Typescript y difiere del estándar JSDoc:</target>
        </trans-unit>
        <trans-unit id="dca8a7aa37da66a7e0661bda41e830a52a5189ae" translate="yes" xml:space="preserve">
          <source>You can also override existing properties and add new ones:</source>
          <target state="translated">También puede anular las propiedades existentes y añadir otras nuevas:</target>
        </trans-unit>
        <trans-unit id="e783edc2ccbd9e24ba2f903e758def00265edb8b" translate="yes" xml:space="preserve">
          <source>You can also run into errors with &lt;code&gt;this&lt;/code&gt; in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;. With some work you can use &lt;code&gt;this&lt;/code&gt; parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n puede encontrar errores con &lt;code&gt;this&lt;/code&gt; en las devoluciones de llamada, cuando pasa funciones a una biblioteca que luego las llamar&amp;aacute;. Debido a que la biblioteca que llama a su devoluci&amp;oacute;n de llamada lo llamar&amp;aacute; como una funci&amp;oacute;n normal, &lt;code&gt;this&lt;/code&gt; no estar&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; . Con algo de trabajo, tambi&amp;eacute;n puede usar &lt;code&gt;this&lt;/code&gt; par&amp;aacute;metros para evitar errores con devoluciones de llamada. Primero, el autor de la biblioteca debe anotar el tipo de devoluci&amp;oacute;n de llamada con &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8bc617eb0b3c708d101d575cea082665b2e4c486" translate="yes" xml:space="preserve">
          <source>You can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:</source>
          <target state="translated">También se puede especificar una restricción de tipo antes del nombre del parámetro de tipo.Sólo se restringe el primer parámetro de clase de una lista:</target>
        </trans-unit>
        <trans-unit id="d00d3142af394bb2294c1c64058dcebe2e496a01" translate="yes" xml:space="preserve">
          <source>You can also specify object literal types. For example, an object with properties &amp;lsquo;a&amp;rsquo; (string) and &amp;lsquo;b&amp;rsquo; (number) uses the following syntax:</source>
          <target state="translated">Tambi&amp;eacute;n puede especificar tipos de objetos literales. Por ejemplo, un objeto con propiedades 'a' (cadena) y 'b' (n&amp;uacute;mero) usa la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="fe8328cdac7d502c96b86354aece870f05fd04b3" translate="yes" xml:space="preserve">
          <source>You can also spread objects:</source>
          <target state="translated">También puedes esparcir objetos:</target>
        </trans-unit>
        <trans-unit id="1908bbe93e9847a90199e01d70ec2bf4ba120262" translate="yes" xml:space="preserve">
          <source>You can also update your IDE to use the nightly drop. First you will need to install the package through npm. You can either install the npm package globally or to a local &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">Tambi&amp;eacute;n puede actualizar su IDE para usar el servicio nocturno. Primero necesitar&amp;aacute; instalar el paquete a trav&amp;eacute;s de npm. Puede instalar el paquete npm globalmente o en una carpeta local &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd769df0df5d6f0aa6315e5bbbcccdf2351c2f6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;em&gt;template strings&lt;/em&gt;, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (&lt;code&gt;`&lt;/code&gt;) character, and embedded expressions are of the form &lt;code&gt;${ expr }&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n puede utilizar &lt;em&gt;cadenas de plantilla&lt;/em&gt; , que pueden abarcar varias l&amp;iacute;neas y tener expresiones incrustadas. Estas cadenas est&amp;aacute;n rodeadas por el car&amp;aacute;cter de comilla invertida / comilla inversa ( &lt;code&gt;`&lt;/code&gt; ), y las expresiones incrustadas tienen el formato &lt;code&gt;${ expr }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8642a91579cb79f285b253bbe1a7a6a5ff3ec30" translate="yes" xml:space="preserve">
          <source>You can also use a const-assertion, which operates on arrays and object literals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf980f17e02d8f2a94115cf1b8ed0aa09a9c8f3" translate="yes" xml:space="preserve">
          <source>You can also use a union type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55dd36012d4dbcf4dacc5832f2294fe2f575c7c" translate="yes" xml:space="preserve">
          <source>You can assign an object literal directly to the prototype property. Individual prototype assignments still work too:</source>
          <target state="translated">Puedes asignar un objeto literal directamente a la propiedad del prototipo.Las asignaciones de prototipos individuales también funcionan:</target>
        </trans-unit>
        <trans-unit id="8c16422cd5326d69a5eb84cd5f6aae392dfed484" translate="yes" xml:space="preserve">
          <source>You can call the function &lt;code&gt;greet&lt;/code&gt; with a string to show a greeting to the user.</source>
          <target state="translated">Puede llamar a la funci&amp;oacute;n &lt;code&gt;greet&lt;/code&gt; con una cadena para mostrar un saludo al usuario.</target>
        </trans-unit>
        <trans-unit id="1a7ff571453a3f2b2057590cf96aa4493691af9b" translate="yes" xml:space="preserve">
          <source>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called &lt;em&gt;discriminated unions&lt;/em&gt;, also known as &lt;em&gt;tagged unions&lt;/em&gt; or &lt;em&gt;algebraic data types&lt;/em&gt;. Discriminated unions are useful in functional programming. Some languages automatically discriminate unions for you; TypeScript instead builds on JavaScript patterns as they exist today. There are three ingredients:</source>
          <target state="translated">Puede combinar tipos de singleton, tipos de uni&amp;oacute;n, protectores de tipo y alias de tipo para crear un patr&amp;oacute;n avanzado denominado &lt;em&gt;uniones discriminadas&lt;/em&gt; , tambi&amp;eacute;n conocidas como &lt;em&gt;uniones etiquetadas&lt;/em&gt; o &lt;em&gt;tipos de datos algebraicos&lt;/em&gt; . Las uniones discriminadas son &amp;uacute;tiles en la programaci&amp;oacute;n funcional. Algunos idiomas discriminan autom&amp;aacute;ticamente las uniones por usted; En cambio, TypeScript se basa en patrones de JavaScript tal como existen en la actualidad. Hay tres ingredientes:</target>
        </trans-unit>
        <trans-unit id="6d357850b01dac1eeac6457b17d7ca5319c972ef" translate="yes" xml:space="preserve">
          <source>You can construct a &lt;code&gt;Point&lt;/code&gt; by assigning an object literal. After the assignment, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; can&amp;rsquo;t be changed.</source>
          <target state="translated">Puede construir un &lt;code&gt;Point&lt;/code&gt; asignando un objeto literal. Despu&amp;eacute;s de la asignaci&amp;oacute;n, &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; no se pueden cambiar.</target>
        </trans-unit>
        <trans-unit id="4fb6b2a81bd2b7aaa5985f5e53a25640c10196cd" translate="yes" xml:space="preserve">
          <source>You can create a greeter by instantiating the &lt;code&gt;Greeter&lt;/code&gt; object, or create a customized greeter by extending from it.</source>
          <target state="translated">Puede crear un saludo al crear una instancia del objeto de &lt;code&gt;Greeter&lt;/code&gt; o crear un saludo personalizado extendi&amp;eacute;ndose desde &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="75665cb8837cc0487308ee22852413c93f1fc259" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in a list using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">Puede crear una variable para los elementos restantes en una lista usando la sintaxis &lt;code&gt;...&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8460f1444f4aa17633ac5c787a8314796932f6a5" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in an object using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">Puede crear una variable para los elementos restantes en un objeto usando la sintaxis &lt;code&gt;...&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="671e7dc200d0c80a25936e430c7090352f3d72ae" translate="yes" xml:space="preserve">
          <source>You can declare a type parameter that is constrained by another type parameter. For example, here we&amp;rsquo;d like to get a property from an object given its name. We&amp;rsquo;d like to ensure that we&amp;rsquo;re not accidentally grabbing a property that does not exist on the &lt;code&gt;obj&lt;/code&gt;, so we&amp;rsquo;ll place a constraint between the two types:</source>
          <target state="translated">Puede declarar un par&amp;aacute;metro de tipo que est&amp;aacute; restringido por otro par&amp;aacute;metro de tipo. Por ejemplo, aqu&amp;iacute; nos gustar&amp;iacute;a obtener una propiedad de un objeto dado su nombre. Nos gustar&amp;iacute;a asegurarnos de que no estamos tomando accidentalmente una propiedad que no existe en el &lt;code&gt;obj&lt;/code&gt; , por lo que colocaremos una restricci&amp;oacute;n entre los dos tipos:</target>
        </trans-unit>
        <trans-unit id="bb0d4186733111c3ff772adfa9929d9115f1fe52" translate="yes" xml:space="preserve">
          <source>You can declare generic functions with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f192a3654a48e7ea0a0cc0a370781ac7a446e607" translate="yes" xml:space="preserve">
          <source>You can declare generic types with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target state="translated">Puede declarar tipos gen&amp;eacute;ricos con la etiqueta &lt;code&gt;@template&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39c755b295968915cb7f36206ab4acb5152d4feb" translate="yes" xml:space="preserve">
          <source>You can declare your own types that use generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125273b21991da50ace34ccf074e5c40f14c2af0" translate="yes" xml:space="preserve">
          <source>You can define a root folder where you can do absolute file resolution. E.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc9cd9cf610e86ca2fc0386a0460cd60dd0d41d" translate="yes" xml:space="preserve">
          <source>You can explicitly describe this object&amp;rsquo;s shape using an &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8f084feb2f8af2ede413a048aa5f0369d9c8d1" translate="yes" xml:space="preserve">
          <source>You can explore the source code for the &lt;a href=&quot;https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts&quot;&gt;DOM type definitions&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e46331273cd57070033fdf01cbe89968dccfda4" translate="yes" xml:space="preserve">
          <source>You can export with an export list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c976f009cdbf256d8a8056997c9ba760d321e8" translate="yes" xml:space="preserve">
          <source>You can find documentation on TypeScript projects in &lt;a href=&quot;docs/handbook/project-references&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9a4311f9cdef796f23298f9df9ad3c9567377d" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/api.md#baseurl&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578813d014f5da6ccea41bacd872a0d259c87786" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="translated">Puede encontrar m&amp;aacute;s documentaci&amp;oacute;n sobre baseUrl en la documentaci&amp;oacute;n de &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; y &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3565b07531ff1df206f19c27fc9bf382f93d1b9c" translate="yes" xml:space="preserve">
          <source>You can find out more about decorator support in TypeScript in &lt;a href=&quot;docs/handbook/decorators&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba620983de41a7ef95236f421d1dc97955b1aa9" translate="yes" xml:space="preserve">
          <source>You can find the full list of supported JSDoc patterns &lt;a href=&quot;#supported-jsdoc&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Puede encontrar la lista completa de patrones JSDoc compatibles a &lt;a href=&quot;#supported-jsdoc&quot;&gt;continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34fda10118f041f159330cd7abc22afc3606cf87" translate="yes" xml:space="preserve">
          <source>You can find the full list of supported JSDoc patterns &lt;a href=&quot;jsdoc-supported-types&quot;&gt;in JSDoc Supported Types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c476c80d4a52dce79024022ae48c95db9d5b6f4d" translate="yes" xml:space="preserve">
          <source>You can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f608f667f472aa22cebd5f33fb938554db51b9e" translate="yes" xml:space="preserve">
          <source>You can fully understand how to make any shape of definition by understanding some key concepts of how TypeScript works.</source>
          <target state="translated">Puedes entender completamente como hacer cualquier forma de definición entendiendo algunos conceptos clave de cómo funciona TypeScript.</target>
        </trans-unit>
        <trans-unit id="ffbbf130c4a666890a749997011788aa15e53216" translate="yes" xml:space="preserve">
          <source>You can have TypeScript raise errors when this happens via the compiler flag &lt;code&gt;strictFunctionTypes&lt;/code&gt;.</source>
          <target state="translated">Puede hacer que TypeScript genere errores cuando esto suceda a trav&amp;eacute;s de la &lt;code&gt;strictFunctionTypes&lt;/code&gt; del compilador rigidFunctionTypes .</target>
        </trans-unit>
        <trans-unit id="e7cf81fd3fe04126a6e45600ef8b2c4d2d493009" translate="yes" xml:space="preserve">
          <source>You can install this library via npm:</source>
          <target state="translated">Puedes instalar esta biblioteca a través del NPM:</target>
        </trans-unit>
        <trans-unit id="6152873a2f68376c518851001d0d205cfc51fe07" translate="yes" xml:space="preserve">
          <source>You can learn how to do this in our &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;installation page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68173b0a46e94261744a5e3bad0e83f40a64e4d8" translate="yes" xml:space="preserve">
          <source>You can learn how to do this in our &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;installation page&lt;/a&gt;. You want to make sure these files are included in your package if you have the files in your project&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947cee68bd128ad7579db636c222ec6f612e50a8" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;tsconfig.json&lt;/code&gt; files &lt;a href=&quot;tsconfig-json&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Puede obtener m&amp;aacute;s informaci&amp;oacute;n sobre los archivos &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;a href=&quot;tsconfig-json&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0002bbb784dd22adfca99735cd3bee016fc7bc2f" translate="yes" xml:space="preserve">
          <source>You can learn more about configuring webpack &lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Puede obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo configurar el paquete web &lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11a81cf552959831fd7e6995da492be14d30da53" translate="yes" xml:space="preserve">
          <source>You can learn more about how to measure and understand the output in the performance &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;section of the wiki&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd112a39c804a14040d8ee141d2691324c73c733" translate="yes" xml:space="preserve">
          <source>You can learn more about the options in the &lt;a href=&quot;https://www.typescriptlang.org/reference&quot;&gt;tsconfig reference&lt;/a&gt;. An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acea5010ea541a31bcbc5992b38da22bdf966f2" translate="yes" xml:space="preserve">
          <source>You can make properties readonly by using the &lt;code&gt;readonly&lt;/code&gt; keyword. Readonly properties must be initialized at their declaration or in the constructor.</source>
          <target state="translated">Puede hacer que las propiedades sean de solo lectura utilizando la palabra clave &lt;code&gt;readonly&lt;/code&gt; . Las propiedades de solo lectura deben inicializarse en su declaraci&amp;oacute;n o en el constructor.</target>
        </trans-unit>
        <trans-unit id="5ac33330400d5a0e5b89b577a3c10f0de7e4e12f" translate="yes" xml:space="preserve">
          <source>You can now define an &lt;em&gt;alias&lt;/em&gt; for a type using the &lt;code&gt;type&lt;/code&gt; keyword:</source>
          <target state="translated">Ahora puede definir un &lt;em&gt;alias&lt;/em&gt; para un tipo usando la palabra clave &lt;code&gt;type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e434657788b8ddc40cdc0edab54832db855ade3" translate="yes" xml:space="preserve">
          <source>You can pass any of the three allowed strings, but any other string will give the error</source>
          <target state="translated">Puedes pasar cualquiera de las tres cuerdas permitidas,pero cualquier otra cuerda dará el error</target>
        </trans-unit>
        <trans-unit id="d470740bd26919fb50f6301789d422e287938cf6" translate="yes" xml:space="preserve">
          <source>You can provide &lt;code&gt;tsc -b&lt;/code&gt; with multiple config file paths (e.g. &lt;code&gt;tsc -b src test&lt;/code&gt;). Just like &lt;code&gt;tsc -p&lt;/code&gt;, specifying the config file name itself is unnecessary if it&amp;rsquo;s named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">Puede proporcionar a &lt;code&gt;tsc -b&lt;/code&gt; m&amp;uacute;ltiples rutas de archivo de configuraci&amp;oacute;n (por ejemplo, &lt;code&gt;tsc -b src test&lt;/code&gt; ). Al igual que &lt;code&gt;tsc -p&lt;/code&gt; , especificar el nombre del archivo de configuraci&amp;oacute;n en s&amp;iacute; no es necesario si se llama &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8c2c8135b90f55175c15912e8774ea2151cd6c3" translate="yes" xml:space="preserve">
          <source>You can read more about how references works in the &lt;a href=&quot;docs/handbook/project-references&quot;&gt;Project References&lt;/a&gt; section of the handbook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0c4b0cf188a255ee3afb8b2ea5e76910a20990" translate="yes" xml:space="preserve">
          <source>You can read more about the process in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt;loading modules from &lt;code&gt;node_modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Puede leer m&amp;aacute;s sobre el proceso en la documentaci&amp;oacute;n de Node.js sobre c&amp;oacute;mo &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt;cargar m&amp;oacute;dulos desde &lt;code&gt;node_modules&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45ae7c33d245bc14dc13773d18d87a71cb89dde7" translate="yes" xml:space="preserve">
          <source>You can read more about the transition in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the 3.7 release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5500a793cafd40811d12bec320b636a9073b8503" translate="yes" xml:space="preserve">
          <source>You can read more about this in &lt;a href=&quot;docs/handbook/module-resolution#tracing-module-resolution&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dbf3245e466cb4f090abb7404f3d0e9c3f028b" translate="yes" xml:space="preserve">
          <source>You can read more about this in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions&quot;&gt;the release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c1237490875a34de9e3a6f34ec2e6bab8560cf" translate="yes" xml:space="preserve">
          <source>You can read more about this in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;file modules&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;folder modules&lt;/a&gt;.</source>
          <target state="translated">Puede leer m&amp;aacute;s sobre esto en la documentaci&amp;oacute;n de Node.js sobre &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;m&amp;oacute;dulos de archivo&lt;/a&gt; y &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;m&amp;oacute;dulos de carpeta&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecd3a208f74e578df2b2a2fa60c227e643c4ba88" translate="yes" xml:space="preserve">
          <source>You can read the type of &lt;code&gt;loggingIdentity&lt;/code&gt; as &amp;ldquo;the generic function &lt;code&gt;loggingIdentity&lt;/code&gt; takes a type parameter &lt;code&gt;T&lt;/code&gt;, and an argument &lt;code&gt;arg&lt;/code&gt; which is an array of &lt;code&gt;T&lt;/code&gt;s, and returns an array of &lt;code&gt;T&lt;/code&gt;s.&amp;rdquo; If we passed in an array of numbers, we&amp;rsquo;d get an array of numbers back out, as &lt;code&gt;T&lt;/code&gt; would bind to &lt;code&gt;number&lt;/code&gt;. This allows us to use our generic type variable &lt;code&gt;T&lt;/code&gt; as part of the types we&amp;rsquo;re working with, rather than the whole type, giving us greater flexibility.</source>
          <target state="translated">Puede leer el tipo de &lt;code&gt;loggingIdentity&lt;/code&gt; como &quot;la funci&amp;oacute;n gen&amp;eacute;rica &lt;code&gt;loggingIdentity&lt;/code&gt; toma un par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; y un argumento &lt;code&gt;arg&lt;/code&gt; que es una matriz de &lt;code&gt;T&lt;/code&gt; s, y devuelve una matriz de &lt;code&gt;T&lt;/code&gt; s&quot;. Si pasamos una matriz de n&amp;uacute;meros, obtendr&amp;iacute;amos una matriz de n&amp;uacute;meros, ya que &lt;code&gt;T&lt;/code&gt; se unir&amp;iacute;a a un &lt;code&gt;number&lt;/code&gt; . Esto nos permite usar nuestra variable de tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; como parte de los tipos con los que estamos trabajando, en lugar del tipo completo, lo que nos da una mayor flexibilidad.</target>
        </trans-unit>
        <trans-unit id="39f93a09cc5f4b2491c0b2ccab1b26b016dd256f" translate="yes" xml:space="preserve">
          <source>You can see an example DTS below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb82b9593a1fc045e2a68f5072eaf1a1f4d845d" translate="yes" xml:space="preserve">
          <source>You can see an example of using Webpack in our &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/react-&amp;amp;-webpack.html&quot;&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4219455f5a7b401b488cbe6f3cc25db24a4f9204" translate="yes" xml:space="preserve">
          <source>You can see an example of using Webpack in our &lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target state="translated">Puede ver un ejemplo del uso de Webpack en nuestro &lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;tutorial sobre React y Webpack&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="522afc6f6129110c8704aded05f62e148f7fcfe8" translate="yes" xml:space="preserve">
          <source>You can see these patterns in the TypeScript repo - see &lt;code&gt;src/tsconfig_base.json&lt;/code&gt;, &lt;code&gt;src/tsconfig.json&lt;/code&gt;, and &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; as key examples.</source>
          <target state="translated">Puede ver estos patrones en el repositorio de TypeScript; consulte &lt;code&gt;src/tsconfig_base.json&lt;/code&gt; , &lt;code&gt;src/tsconfig.json&lt;/code&gt; y &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; como ejemplos clave.</target>
        </trans-unit>
        <trans-unit id="342e97c124555c4631ae12805973e016d0bd72c0" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line.</source>
          <target state="translated">Puede omitir la comprobaci&amp;oacute;n de algunos archivos agregando &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment a ellos; a la inversa, puede optar por verificar solo unos pocos archivos &lt;code&gt;.js&lt;/code&gt; agregando &lt;code&gt;// @ts-check&lt;/code&gt; comment a ellos sin configurar &lt;code&gt;--checkJs&lt;/code&gt; . Tambi&amp;eacute;n puede ignorar errores en l&amp;iacute;neas espec&amp;iacute;ficas agregando &lt;code&gt;// @ts-ignore&lt;/code&gt; en la l&amp;iacute;nea anterior.</target>
        </trans-unit>
        <trans-unit id="964c60dd8551d7582983d7537470492d6195db2c" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely, you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line. Note that if you have a &lt;code&gt;tsconfig.json&lt;/code&gt;, JS checking will respect strict flags like &lt;code&gt;noImplicitAny&lt;/code&gt;, &lt;code&gt;strictNullChecks&lt;/code&gt;, etc. However, because of the relative looseness of JS checking, combining strict flags with it may be surprising.</source>
          <target state="translated">Puede omitir la comprobaci&amp;oacute;n de algunos archivos a&amp;ntilde;adi&amp;eacute;ndoles un comentario &lt;code&gt;// @ts-nocheck&lt;/code&gt; ; a la inversa, puede optar por verificar solo unos pocos archivos &lt;code&gt;.js&lt;/code&gt; agregando un comentario &lt;code&gt;// @ts-check&lt;/code&gt; sin configurar &lt;code&gt;--checkJs&lt;/code&gt; . Tambi&amp;eacute;n puede ignorar errores en l&amp;iacute;neas espec&amp;iacute;ficas agregando &lt;code&gt;// @ts-ignore&lt;/code&gt; en la l&amp;iacute;nea anterior. Tenga en cuenta que si tiene un &lt;code&gt;tsconfig.json&lt;/code&gt; , la comprobaci&amp;oacute;n de JS respetar&amp;aacute; los indicadores estrictos como &lt;code&gt;noImplicitAny&lt;/code&gt; , &lt;code&gt;strictNullChecks&lt;/code&gt; , etc. Sin embargo, debido a la relativa flexibilidad de la comprobaci&amp;oacute;n de JS, la combinaci&amp;oacute;n de indicadores estrictos puede resultar sorprendente.</target>
        </trans-unit>
        <trans-unit id="a94719f47d299841e6e51ceee5706dcecbbee79d" translate="yes" xml:space="preserve">
          <source>You can specify any number of config files:</source>
          <target state="translated">Puede especificar cualquier número de archivos de configuración:</target>
        </trans-unit>
        <trans-unit id="49e57a0ea093e19313c1e384f922d69417882b6c" translate="yes" xml:space="preserve">
          <source>You can specify array types using a variety of syntaxes:</source>
          <target state="translated">Puede especificar los tipos de arreglos usando una variedad de sintaxis:</target>
        </trans-unit>
        <trans-unit id="a70277082e31e5e52d3d480b2d3e85e69cad3826" translate="yes" xml:space="preserve">
          <source>You can specify function types using either TypeScript or Closure syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34efcdea59af77ca626a5d378a5a510fc13373a4" translate="yes" xml:space="preserve">
          <source>You can specify function types using either Typescript or Closure syntax:</source>
          <target state="translated">Puede especificar los tipos de función utilizando la sintaxis de Typescript o de Closure:</target>
        </trans-unit>
        <trans-unit id="374bf1cc94385f96a421817886992b3a7d544791" translate="yes" xml:space="preserve">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7d6f924eeeb484fecdc0bbd17378d7530144b6" translate="yes" xml:space="preserve">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or Typescript syntax.</source>
          <target state="translated">Puede especificar objetos de tipo mapa y de tipo matriz utilizando firmas de índice de cadenas y números,utilizando la sintaxis estándar de JSDoc o la sintaxis de Typescript.</target>
        </trans-unit>
        <trans-unit id="e5b4c27e6b170dfa095f022ece8aad3250bbb88a" translate="yes" xml:space="preserve">
          <source>You can specify the type of &lt;em&gt;children&lt;/em&gt; like any other attribute. This will override the default type from, eg the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt; if you use them.</source>
          <target state="translated">Puede especificar el tipo de &lt;em&gt;hijos&lt;/em&gt; como cualquier otro atributo. Esto anular&amp;aacute; el tipo predeterminado de, por ejemplo, los &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;tipos de React&lt;/a&gt; si los usa.</target>
        </trans-unit>
        <trans-unit id="aa5974276811e58130f1843d3263db447637e938" translate="yes" xml:space="preserve">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt; in your tsconfig.json&lt;/a&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37fd121d8b3692df1ee3680ad29d96a4b8894ae" translate="yes" xml:space="preserve">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option in your &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; file.</source>
          <target state="translated">Puede especificar este modo usando la &lt;code&gt;--jsx&lt;/code&gt; l&amp;iacute;nea de comando --jsx o la opci&amp;oacute;n correspondiente en su archivo &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e710607df82b140e1dbb754cf8fc5b94b8059800" translate="yes" xml:space="preserve">
          <source>You can then declare that a JavaScript object conforms to the shape of your new &lt;code&gt;interface&lt;/code&gt; by using syntax like &lt;code&gt;: TypeName&lt;/code&gt; after a variable declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90dfbdf6b89a09fcab1c28a3e863c8c3729853fd" translate="yes" xml:space="preserve">
          <source>You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65236d6747127a47949cb8a9fb216884384fd47" translate="yes" xml:space="preserve">
          <source>You can think of this as TypeScript &amp;ldquo;toughening up&amp;rdquo; the weak guarantees of these types to catch what would otherwise be silent bugs.</source>
          <target state="translated">Puede pensar en esto como que TypeScript &quot;endurece&quot; las d&amp;eacute;biles garant&amp;iacute;as de estos tipos para detectar lo que de otro modo ser&amp;iacute;an errores silenciosos.</target>
        </trans-unit>
        <trans-unit id="5097622074f85132325f78b68e79fba79fe3f621" translate="yes" xml:space="preserve">
          <source>You can think of this feature - the &lt;code&gt;??&lt;/code&gt; operator - as a way to &amp;ldquo;fall back&amp;rdquo; to a default value when dealing with &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. When we write code like</source>
          <target state="translated">Puedes pensar en esta caracter&amp;iacute;stica: el &lt;code&gt;??&lt;/code&gt; operador: como una forma de &quot;retroceder&quot; a un valor predeterminado cuando se trata de &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . Cuando escribimos c&amp;oacute;digo como</target>
        </trans-unit>
        <trans-unit id="be980ac4c9e799583178b2189eb7f2bb72eb8228" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#noEmitHelpers&quot;&gt;&lt;code&gt;noEmitHelpers&lt;/code&gt;&lt;/a&gt; when you provide your own implementations of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66e09412263a50bdba0d73f81189d39cb3e2051" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; via &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt; to reduce the amount of inline JavaScript too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b09ddf784752f3c6f4d86dc25ca304e62284b0e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;export as namespace&lt;/code&gt; to declare that your module will be available in the global scope in UMD contexts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b715cffb2277991c0db4c0b6b9e109955e0bcf" translate="yes" xml:space="preserve">
          <source>You can use a type alias to make a shorthand for a type:</source>
          <target state="translated">Puedes usar un alias de tipo para hacer una taquigrafía de un tipo:</target>
        </trans-unit>
        <trans-unit id="f059cdce98ff966444670c2070525a863818425c" translate="yes" xml:space="preserve">
          <source>You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391c1498a82ae1b3dc563cb57e6b7cbe9562f400" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;object&lt;/code&gt; or &lt;code&gt;Object&lt;/code&gt; on the first line.</source>
          <target state="translated">Puede utilizar &lt;code&gt;object&lt;/code&gt; o &lt;code&gt;Object&lt;/code&gt; en la primera l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="73ad51c87d1ff2edbd6bedd2ce2c75e2f55b6846" translate="yes" xml:space="preserve">
          <source>You can use interfaces to annotate parameters and return values to functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446759c7e9287dd9b2744b78bd72e945161fa89b" translate="yes" xml:space="preserve">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use any Typescript type, and most JSDoc types.</source>
          <target state="translated">Puede utilizar la etiqueta &quot;@type&quot; y hacer referencia a un nombre de tipo (ya sea primitivo, definido en una declaraci&amp;oacute;n de TypeScript o en una etiqueta JSDoc &quot;@typedef&quot;). Puede utilizar cualquier tipo de TypeScript y la mayor&amp;iacute;a de los tipos de JSDoc.</target>
        </trans-unit>
        <trans-unit id="46b8562cf700f30f831c7873691acf285a8928d7" translate="yes" xml:space="preserve">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use most JSDoc types and any TypeScript type, from &lt;a href=&quot;basic-types&quot;&gt;the most basic like &lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;advanced-types&quot;&gt;the most advanced, like conditional types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6198a75a95e389a7a03972f1adcbada6802fc1" translate="yes" xml:space="preserve">
          <source>You can use this flag to discover where TypeScript is spending it&amp;rsquo;s time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a45fbb2d4cb410ac9052a3f0018033b37e3130" translate="yes" xml:space="preserve">
          <source>You can use this pattern with other parts of the type system to get type-safe lookups.</source>
          <target state="translated">Puedes usar este patrón con otras partes del sistema de tipos para obtener búsquedas seguras de tipos.</target>
        </trans-unit>
        <trans-unit id="ca792ffbb908ece0647bb752e2d90bf39f35c90e" translate="yes" xml:space="preserve">
          <source>You can work around this by using functions to return your classes which differ based on a generic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcf07ddca5f6840ea854ce2231a54e72513b8b2" translate="yes" xml:space="preserve">
          <source>You can work around this with a type annotation for &lt;code&gt;s&lt;/code&gt;, but that in turn prevents assignments to &lt;code&gt;s&lt;/code&gt; of variables that are not of type &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597b5c6c408a6a967509763c765d774adc0ad149" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;mdash; just patches to existing declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df1f23ca2dd7c39f8e49a4cc5f4fc6278b9486d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;ndash; just patches to existing declarations.</source>
          <target state="translated">No puede declarar nuevas declaraciones de nivel superior en el aumento, solo parches para declaraciones existentes.</target>
        </trans-unit>
        <trans-unit id="81a1eeecad5bacc57bd430d953c632133311eb85" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e3055df49675bbb87854f15fad0bf01e0d93c4" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is readonly.</source>
          <target state="translated">No puede configurar &lt;code&gt;myArray[2]&lt;/code&gt; porque la firma del &amp;iacute;ndice es de solo lectura.</target>
        </trans-unit>
        <trans-unit id="767af037748d5f5e35da8733c684e29d4e2efa46" translate="yes" xml:space="preserve">
          <source>You cannot use decorators to provide mixins via code flow analysis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e14e65723450d9d571a4aeb121d26c5a7c7c1f" translate="yes" xml:space="preserve">
          <source>You could also define the type of &lt;code&gt;options&lt;/code&gt; and add a type assertion on the object literal.</source>
          <target state="translated">Tambi&amp;eacute;n puede definir el tipo de &lt;code&gt;options&lt;/code&gt; y agregar una aserci&amp;oacute;n de tipo en el objeto literal.</target>
        </trans-unit>
        <trans-unit id="10223649f26ed1ba254c71d5968c360f3987e66e" translate="yes" xml:space="preserve">
          <source>You could argue that this program is correctly typed, since the &lt;code&gt;width&lt;/code&gt; properties are compatible, there&amp;rsquo;s no &lt;code&gt;color&lt;/code&gt; property present, and the extra &lt;code&gt;colour&lt;/code&gt; property is insignificant.</source>
          <target state="translated">Se podr&amp;iacute;a argumentar que este programa est&amp;aacute; escrito correctamente, ya que las propiedades de &lt;code&gt;width&lt;/code&gt; son compatibles, no hay ninguna propiedad de &lt;code&gt;color&lt;/code&gt; presente y la propiedad de &lt;code&gt;colour&lt;/code&gt; adicional es insignificante.</target>
        </trans-unit>
        <trans-unit id="453e1d8a491394744db85218dccb0ae80c5b3442" translate="yes" xml:space="preserve">
          <source>You could use multiple tsconfig files to solve &lt;em&gt;some&lt;/em&gt; of those problems, but new ones would appear:</source>
          <target state="translated">Puede usar varios archivos tsconfig para resolver &lt;em&gt;algunos&lt;/em&gt; de esos problemas, pero aparecer&amp;iacute;an otros nuevos:</target>
        </trans-unit>
        <trans-unit id="3c150ba833a45169bc5e39fe665acb71dd66349e" translate="yes" xml:space="preserve">
          <source>You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783ca79e34aba59fadb024fdf75ec796a34f288d" translate="yes" xml:space="preserve">
          <source>You may already be familiar with this style of type from other languages. In the next section, we&amp;rsquo;ll cover how you can create your own generic types like &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Es posible que ya est&amp;eacute; familiarizado con este estilo de tipograf&amp;iacute;a en otros idiomas. En la siguiente secci&amp;oacute;n, cubriremos c&amp;oacute;mo puede crear sus propios tipos gen&amp;eacute;ricos como &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e224facb474f21f90e2b2be7d6c67fc9a0105ac" translate="yes" xml:space="preserve">
          <source>You may be wondering why we allow &amp;lsquo;discarding&amp;rsquo; parameters like in the example &lt;code&gt;y = x&lt;/code&gt;. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, &lt;code&gt;Array#forEach&lt;/code&gt; provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it&amp;rsquo;s very useful to provide a callback that only uses the first parameter:</source>
          <target state="translated">Quiz&amp;aacute;s se est&amp;eacute; preguntando por qu&amp;eacute; permitimos 'descartar' par&amp;aacute;metros como en el ejemplo &lt;code&gt;y = x&lt;/code&gt; . La raz&amp;oacute;n por la que se permite esta asignaci&amp;oacute;n es que ignorar los par&amp;aacute;metros de funciones adicionales es bastante com&amp;uacute;n en JavaScript. Por ejemplo, &lt;code&gt;Array#forEach&lt;/code&gt; proporciona tres par&amp;aacute;metros a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada: el elemento de la matriz, su &amp;iacute;ndice y la matriz que lo contiene. Sin embargo, es muy &amp;uacute;til proporcionar una devoluci&amp;oacute;n de llamada que solo use el primer par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="52a0e16871788839263e691e58ca61bc61635cd5" translate="yes" xml:space="preserve">
          <source>You may have noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword is actually a newer JavaScript construct that TypeScript makes available. You can read in the Handbook Reference on &lt;a href=&quot;variable-declarations&quot;&gt;Variable Declarations&lt;/a&gt; more about how &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; fix a lot of the problems with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0160fde4a217a4e964a5d1723b8afe990d3ed06e" translate="yes" xml:space="preserve">
          <source>You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6203b314b9679b4e6a450edc94780928a6921225" translate="yes" xml:space="preserve">
          <source>You may need to restart VS for the red squiggly lines below &lt;code&gt;UseDefaultFiles&lt;/code&gt; and &lt;code&gt;UseStaticFiles&lt;/code&gt; to disappear.</source>
          <target state="translated">Es posible que deba reiniciar VS para que desaparezcan las l&amp;iacute;neas &lt;code&gt;UseDefaultFiles&lt;/code&gt; rojas debajo de UseDefaultFiles y &lt;code&gt;UseStaticFiles&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0a6344f0b1a26e856b642628201bf4d2566c8e" translate="yes" xml:space="preserve">
          <source>You may still mark a member &lt;code&gt;public&lt;/code&gt; explicitly. We could have written the &lt;code&gt;Animal&lt;/code&gt; class from the previous section in the following way:</source>
          <target state="translated">A&amp;uacute;n puede marcar a un miembro como &lt;code&gt;public&lt;/code&gt; expl&amp;iacute;citamente. Podr&amp;iacute;amos haber escrito la clase &lt;code&gt;Animal&lt;/code&gt; de la secci&amp;oacute;n anterior de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7ef83e7afe42eda500cffed4a0d1116b24bc397f" translate="yes" xml:space="preserve">
          <source>You may use the type guard &lt;code&gt;isFish&lt;/code&gt; to filter an array of &lt;code&gt;Fish | Bird&lt;/code&gt; and obtain an array of &lt;code&gt;Fish&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb996842f792b4271e727f1a43257b60e8cebb4e" translate="yes" xml:space="preserve">
          <source>You may want to change these for a few reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf04c61ef2202484a43e999d7405474bf9abd112" translate="yes" xml:space="preserve">
          <source>You may want to provide a type for JavaScript code which does not exist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc16c019974ce3ac91057cddfe1e72a32d707b7" translate="yes" xml:space="preserve">
          <source>You may&amp;rsquo;ve noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword was introduced to JavaScript in ES2015 and is now considered the standard because it&amp;rsquo;s safer than &lt;code&gt;var&lt;/code&gt;. We&amp;rsquo;ll discuss the details later, but many common problems in JavaScript are alleviated by using &lt;code&gt;let&lt;/code&gt;, so you should use it instead of &lt;code&gt;var&lt;/code&gt; whenever possible.</source>
          <target state="translated">Es posible que haya notado que hasta ahora, hemos estado usando la palabra clave &lt;code&gt;let&lt;/code&gt; en lugar de la palabra clave &lt;code&gt;var&lt;/code&gt; de JavaScript con la que podr&amp;iacute;a estar m&amp;aacute;s familiarizado. La palabra clave &lt;code&gt;let&lt;/code&gt; se introdujo en JavaScript en ES2015 y ahora se considera el est&amp;aacute;ndar porque es m&amp;aacute;s segura que &lt;code&gt;var&lt;/code&gt; . Discutiremos los detalles m&amp;aacute;s adelante, pero muchos problemas comunes en JavaScript se alivian usando &lt;code&gt;let&lt;/code&gt; , por lo que deber&amp;iacute;a usarlo en lugar de &lt;code&gt;var&lt;/code&gt; siempre que sea posible.</target>
        </trans-unit>
        <trans-unit id="c6ca7fd5f06b5916404ff0286e5a8b87e56d87ec" translate="yes" xml:space="preserve">
          <source>You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.</source>
          <target state="translated">También podría estar ejecutando algunos pasos intermedios en su Javascript,como la agrupación o el uso de otro transpondedor como Babel.En este caso,es posible que ya tengas una estructura de carpetas como esta configurada.</target>
        </trans-unit>
        <trans-unit id="77d12568f27dbc483de4e3aa9461fb0fdafcd3b7" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; to say that a value can have any property on it because &lt;code&gt;Object&lt;/code&gt; is, for most purposes, the most general type. However &lt;strong&gt;&lt;code&gt;any&lt;/code&gt; is actually the type you want to use&lt;/strong&gt; in those situations, since it&amp;rsquo;s the most &lt;em&gt;flexible&lt;/em&gt; type.</source>
          <target state="translated">Puede tener la tentaci&amp;oacute;n de usar &lt;code&gt;Object&lt;/code&gt; o &lt;code&gt;{}&lt;/code&gt; para decir que un valor puede tener cualquier propiedad porque &lt;code&gt;Object&lt;/code&gt; es, para la mayor&amp;iacute;a de los prop&amp;oacute;sitos, el tipo m&amp;aacute;s general. Sin embargo, &lt;strong&gt; &lt;code&gt;any&lt;/code&gt; es en realidad el tipo que desea usar&lt;/strong&gt; en esas situaciones, ya que es el tipo m&amp;aacute;s &lt;em&gt;flexible&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="902577569221e3d57d91dd10a280916026992b82" translate="yes" xml:space="preserve">
          <source>You might be wondering about that &lt;code&gt;externals&lt;/code&gt; field. We want to avoid bundling all of React into the same file, since this increases compilation time and browsers will typically be able to cache a library if it doesn&amp;rsquo;t change.</source>
          <target state="translated">Quiz&amp;aacute;s se est&amp;eacute; preguntando acerca de ese campo &lt;code&gt;externals&lt;/code&gt; . Queremos evitar agrupar todo React en el mismo archivo, ya que esto aumenta el tiempo de compilaci&amp;oacute;n y los navegadores normalmente podr&amp;aacute;n almacenar en cach&amp;eacute; una biblioteca si no cambia.</target>
        </trans-unit>
        <trans-unit id="3787c905bb80e813db582cc0b39b9469c3749297" translate="yes" xml:space="preserve">
          <source>You might find yourself using &lt;code&gt;?.&lt;/code&gt; to replace a lot of code that performs repetitive nullish checks using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">Es posible que se encuentre usando &lt;code&gt;?.&lt;/code&gt; para reemplazar una gran cantidad de c&amp;oacute;digo que realiza comprobaciones repetitivas de nulidad mediante el operador &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="453b06c204a19fa2060d497fe42b9d6b893f9b0c" translate="yes" xml:space="preserve">
          <source>You might have previously written that like so:</source>
          <target state="translated">Podrías haber escrito eso anteriormente de esa manera:</target>
        </trans-unit>
        <trans-unit id="79ec33e56a8b7eaeb4d65dc92383b5f0d769696d" translate="yes" xml:space="preserve">
          <source>You might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we&amp;rsquo;ll do our best to cover the gist of things.</source>
          <target state="translated">Es posible que tenga algunos pasos de compilaci&amp;oacute;n m&amp;aacute;s en su canal. Quiz&amp;aacute;s concatenas algo a cada uno de tus archivos. Cada herramienta de construcci&amp;oacute;n es diferente, pero haremos todo lo posible para cubrir la esencia de las cosas.</target>
        </trans-unit>
        <trans-unit id="4d2749eb8b0574a3a2922dc523ce38ed21997148" translate="yes" xml:space="preserve">
          <source>You might see documentation like this:</source>
          <target state="translated">Puede que vea documentación como esta:</target>
        </trans-unit>
        <trans-unit id="9ebbdb79f43467b01f07e5bf9e813b83bf4b06f2" translate="yes" xml:space="preserve">
          <source>You might start out getting a bunch of errors like &lt;code&gt;Cannot find name 'require'.&lt;/code&gt;, and &lt;code&gt;Cannot find name 'define'.&lt;/code&gt;. In these cases, it&amp;rsquo;s likely that you&amp;rsquo;re using modules. While you can just convince TypeScript that these exist by writing out</source>
          <target state="translated">Es posible que comience a recibir un mont&amp;oacute;n de errores como &lt;code&gt;Cannot find name 'require'.&lt;/code&gt; y &lt;code&gt;Cannot find name 'define'.&lt;/code&gt; . En estos casos, es probable que est&amp;eacute; utilizando m&amp;oacute;dulos. Si bien puede convencer a TypeScript de que existen escribiendo</target>
        </trans-unit>
        <trans-unit id="a98f3b8ccf34fbf5eb87c6d57b621277a9a767e5" translate="yes" xml:space="preserve">
          <source>You no longer need to either explicitly declare &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;extend React.Props&lt;/code&gt;</source>
          <target state="translated">Ya no es necesario declarar expl&amp;iacute;citamente &lt;code&gt;ref&lt;/code&gt; y &lt;code&gt;key&lt;/code&gt; o &lt;code&gt;extend React.Props&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc9e6801f613004f3ef228abfb6dc5acf9a7df7a" translate="yes" xml:space="preserve">
          <source>You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language&amp;rsquo;s features and behaviors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20ea1578d72074920168379785a4d62e2beb851" translate="yes" xml:space="preserve">
          <source>You should first read &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; for an overview on the way they all work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22090ec26c2134c8a6e2097c73237d381154a0ba" translate="yes" xml:space="preserve">
          <source>You should strongly consider turning this on if you&amp;rsquo;re using project references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273fc30ccbe12c9343d1e8b3f416cecb591b9158" translate="yes" xml:space="preserve">
          <source>You shouldn&amp;rsquo;t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue at the top of the file. This setting disables the prologue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb008eccba10a9a792e21493ddf4d96a2e05ffe" translate="yes" xml:space="preserve">
          <source>You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcfb9bf7e9a5a70d6661bc4978c8808ff85beea" translate="yes" xml:space="preserve">
          <source>You will mostly see intersection types used for mixins and other concepts that don&amp;rsquo;t fit in the classic object-oriented mold. (There are a lot of these in JavaScript!) Here&amp;rsquo;s a simple example that shows how to create a mixin:</source>
          <target state="translated">En su mayor&amp;iacute;a, ver&amp;aacute; tipos de intersecci&amp;oacute;n utilizados para mixins y otros conceptos que no encajan en el molde cl&amp;aacute;sico orientado a objetos. (&amp;iexcl;Hay muchos de estos en JavaScript!) Aqu&amp;iacute; hay un ejemplo simple que muestra c&amp;oacute;mo crear un mixin:</target>
        </trans-unit>
        <trans-unit id="f88663c08b841df52333cc0dae0185031e7b194f" translate="yes" xml:space="preserve">
          <source>You will not get any errors. However, if you turn on &lt;code&gt;checkJs&lt;/code&gt; then you will get error messages from the JavaScript file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d538693b1e7a8713fd015bc6f34e84e12105e70c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use &lt;code&gt;./dist/main.js&lt;/code&gt;. You can always go back and change these in the &lt;code&gt;package.json&lt;/code&gt; file that&amp;rsquo;s been generated for you.</source>
          <target state="translated">Se le dar&amp;aacute; una serie de indicaciones. Puede utilizar los valores predeterminados excepto su punto de entrada. Para su punto de entrada, use &lt;code&gt;./dist/main.js&lt;/code&gt; . Siempre puede volver atr&amp;aacute;s y cambiarlos en el archivo &lt;code&gt;package.json&lt;/code&gt; que se gener&amp;oacute; para usted.</target>
        </trans-unit>
        <trans-unit id="639d21bc62abc7441d41597c046101c12fe57e01" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that in the class when we refer to one of the members of the class we prepend &lt;code&gt;this.&lt;/code&gt;. This denotes that it&amp;rsquo;s a member access.</source>
          <target state="translated">Notar&amp;aacute;s que en la clase, cuando nos referimos a uno de los miembros de la clase, anteponemos &lt;code&gt;this.&lt;/code&gt; . Esto denota que es un acceso de miembro.</target>
        </trans-unit>
        <trans-unit id="96310a35cd7703a91b61529ec989ae56b9f242ba" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see examples that look like this:</source>
          <target state="translated">Ver&amp;aacute; ejemplos que se ven as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="5a5b2c7c93441f6c370caaf81abe9018ba769023" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that there are two syntaxes for building types: &lt;a href=&quot;https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces&quot;&gt;Interfaces and Types&lt;/a&gt;. You should prefer &lt;code&gt;interface&lt;/code&gt;. Use &lt;code&gt;type&lt;/code&gt; when you need specific features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f270d2ae21cc7300335c3380e8b45bcd31b76c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the &lt;code&gt;arguments&lt;/code&gt; object instead of writing out any parameters:</source>
          <target state="translated">A veces te encontrar&amp;aacute;s llamando a una funci&amp;oacute;n con demasiados / pocos argumentos. Por lo general, esto es un error, pero en algunos casos, es posible que haya declarado una funci&amp;oacute;n que usa el objeto de &lt;code&gt;arguments&lt;/code&gt; lugar de escribir cualquier par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="20cb63d917861135d9d38ee4daf7eae6a3aead46" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll typically see modular libraries include one of these lines in their documentation:</source>
          <target state="translated">Por lo general, ver&amp;aacute; que las bibliotecas modulares incluyen una de estas l&amp;iacute;neas en su documentaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c9d443a11ab3a7c14d4920d4c70eef21109fe48c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:</source>
          <target state="translated">Por lo general, ver&amp;aacute; orientaci&amp;oacute;n en la documentaci&amp;oacute;n de una biblioteca global sobre c&amp;oacute;mo usar la biblioteca en una etiqueta de script HTML:</target>
        </trans-unit>
        <trans-unit id="3dffae8ffc86fe15706e64a3a387cd0d95f60fa7" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll want to bring your TypeScript files together - both the code you&amp;rsquo;ll be writing as well as any necessary declaration files.</source>
          <target state="translated">Querr&amp;aacute; reunir sus archivos de TypeScript, tanto el c&amp;oacute;digo que escribir&amp;aacute; como los archivos de declaraci&amp;oacute;n necesarios.</target>
        </trans-unit>
        <trans-unit id="6c61d3ce52f41b7a2b4d4549b6255c2f3af699ec" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve probably already heard that TypeScript is a &amp;ldquo;flavor&amp;rdquo; or &amp;ldquo;variant&amp;rdquo; of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947d14a2174247c5b66d9b89b8d5cbb14d3c55b1" translate="yes" xml:space="preserve">
          <source>Your declaration files should thus be</source>
          <target state="translated">Sus archivos de declaración deben por lo tanto ser</target>
        </trans-unit>
        <trans-unit id="3e3e5fe5867a90441e1c7a4c99511a740d6fdb06" translate="yes" xml:space="preserve">
          <source>Your program doesn&amp;rsquo;t run in a browser, so you don&amp;rsquo;t want the &lt;code&gt;&quot;dom&quot;&lt;/code&gt; type definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fee6aeee4c8ecf2f473cd812413ce00001a6540" translate="yes" xml:space="preserve">
          <source>Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn&amp;rsquo;t yet support the full syntax of a given ECMAScript version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440ddccd9fb08c957f616ff6766040aab7a385dd" translate="yes" xml:space="preserve">
          <source>ZipCodeValidator.ts</source>
          <target state="translated">ZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="d130dd019725c3415fcffb0d0068497b6ab5463c" translate="yes" xml:space="preserve">
          <source>a default import like &lt;code&gt;import moment from &quot;moment&quot;&lt;/code&gt; acts the same as &lt;code&gt;const moment = require(&quot;moment&quot;).default&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f974c701a93b4450d9860f64bfb55d3dd330753" translate="yes" xml:space="preserve">
          <source>a double-precision IEEE 754 floating point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103388cf7ca274b241718ae87f010b3c451a1308" translate="yes" xml:space="preserve">
          <source>a literal enum expression (basically a string literal or a numeric literal)</source>
          <target state="translated">una expresión literal de enumeración (básicamente una literal de cadena o una literal numérica)</target>
        </trans-unit>
        <trans-unit id="d8a7d3fe2ecf18d5a1f75697ddb3939f637d6862" translate="yes" xml:space="preserve">
          <source>a namespace import like &lt;code&gt;import * as moment from &quot;moment&quot;&lt;/code&gt; acts the same as &lt;code&gt;const moment = require(&quot;moment&quot;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c353e97b94a39673f6777646c09f2fc9ba56cf1" translate="yes" xml:space="preserve">
          <source>a parenthesized constant enum expression</source>
          <target state="translated">una expresión constante de enumeración entre paréntesis</target>
        </trans-unit>
        <trans-unit id="6f264047eeed3d46fe957e11ffb9269c2a50015e" translate="yes" xml:space="preserve">
          <source>a reference to previously defined constant enum member (which can originate from a different enum)</source>
          <target state="translated">una referencia a un miembro del censo constante previamente definido (que puede proceder de un censo diferente)</target>
        </trans-unit>
        <trans-unit id="9fd2ce9f0c4f3c8c3e340067701294ac5d5eb8f9" translate="yes" xml:space="preserve">
          <source>a subtype of &lt;code&gt;undefined&lt;/code&gt; intended for use as a return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c528b1c807d172a8f416db6731cf13e39f6f146c" translate="yes" xml:space="preserve">
          <source>a unary minus applied to any numeric literal (e.g. &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;-100&lt;/code&gt;)</source>
          <target state="translated">un unario menos aplicado a cualquier literal num&amp;eacute;rico (por ejemplo , &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;-100&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e0de8923dd9a86f5d289496a0c29c4b707c6eee6" translate="yes" xml:space="preserve">
          <source>a unique value usually used as a key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4ccee361c095697aa4c9d3e90553c49ca21ae4" translate="yes" xml:space="preserve">
          <source>also equivalent to the unit type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442d3d9c923419455d4cda7f945720f15e70bc16" translate="yes" xml:space="preserve">
          <source>amdModule.js</source>
          <target state="translated">amdModule.js</target>
        </trans-unit>
        <trans-unit id="bd7d452e38c7164a50e08e9fa4635c29c0daaa0b" translate="yes" xml:space="preserve">
          <source>amdModule.ts</source>
          <target state="translated">amdModule.ts</target>
        </trans-unit>
        <trans-unit id="d28fdf8d5aa89ce199b0e06ebcd80f424c23a2d8" translate="yes" xml:space="preserve">
          <source>an expression</source>
          <target state="translated">una expresión</target>
        </trans-unit>
        <trans-unit id="c9d85523bbe34073152505725bb477f4e59b253d" translate="yes" xml:space="preserve">
          <source>an immutable UTF-16 string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2f7e39bb1317b9d8b35bfd3478e54eeafbdfcc2b" translate="yes" xml:space="preserve">
          <source>and as expected, this will print out</source>
          <target state="translated">y como se esperaba,esto se imprimirá</target>
        </trans-unit>
        <trans-unit id="5a1d8e9654b07127c7e5e0c08c9afa232068f17f" translate="yes" xml:space="preserve">
          <source>and merge in options from the following into your &lt;code&gt;webpack.config.js&lt;/code&gt; file:</source>
          <target state="translated">y &lt;code&gt;webpack.config.js&lt;/code&gt; opciones siguientes en su archivo webpack.config.js :</target>
        </trans-unit>
        <trans-unit id="23fcd315817eba480bb49d04295a2aed7b06de1d" translate="yes" xml:space="preserve">
          <source>and optionally returns a property descriptor to install on the target object</source>
          <target state="translated">y opcionalmente devuelve un descriptor de propiedad para instalar en el objeto objetivo</target>
        </trans-unit>
        <trans-unit id="70d4ff6caac47a36ba7af0fb07acabf9735a878b" translate="yes" xml:space="preserve">
          <source>and we can also access those same variables within other functions:</source>
          <target state="translated">y también podemos acceder a esas mismas variables dentro de otras funciones:</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="14539c18332daf6c00ef5a5fb87c44bcec15c080" translate="yes" xml:space="preserve">
          <source>any numeric literal (e.g. &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;100&lt;/code&gt;)</source>
          <target state="translated">cualquier literal num&amp;eacute;rico (por ejemplo , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;100&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d4fc9c2ab5d3af99646bec10e59c8eeb1d9814d0" translate="yes" xml:space="preserve">
          <source>any string literal (e.g. &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, &lt;code&gt;&quot;bar&lt;/code&gt;, &lt;code&gt;&quot;baz&quot;&lt;/code&gt;)</source>
          <target state="translated">cualquier literal de cadena (por ejemplo, &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , &lt;code&gt;&quot;bar&lt;/code&gt; , &lt;code&gt;&quot;baz&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="94012cbdbf0e0cf94a72971e951224b4fef1ce18" translate="yes" xml:space="preserve">
          <source>app.ts</source>
          <target state="translated">app.ts</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="90e0d93d8b273dfcd00bd87849d5d11bf6a1ff97" translate="yes" xml:space="preserve">
          <source>array literals become &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">los literales de matriz se convierten en tuplas de &lt;code&gt;readonly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="850ad5d4afbea97738fa95acd1da7e607bd530cc" translate="yes" xml:space="preserve">
          <source>at compile time</source>
          <target state="translated">en el momento de la compilación</target>
        </trans-unit>
        <trans-unit id="ea0880f5346592a44bf582fa485ad5c011fc5cda" translate="yes" xml:space="preserve">
          <source>at runtime</source>
          <target state="translated">en tiempo de ejecución</target>
        </trans-unit>
        <trans-unit id="864ec6413a2ca497c9c6969ef6b7506903f57beb" translate="yes" xml:space="preserve">
          <source>awesome-typescript-loader</source>
          <target state="translated">awesome-typescript-loader</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="4946408acb38561a9b39f78af5d1c6064ba23a12" translate="yes" xml:space="preserve">
          <source>bundling with your npm package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba69ef3aa7bab274d4a266a6dcb623595c1d29fe" translate="yes" xml:space="preserve">
          <source>bundling with your npm package, or</source>
          <target state="translated">que se adjunta con su paquete de NPM,o</target>
        </trans-unit>
        <trans-unit id="231393efbaac44c960b4ab365234afea0360d138" translate="yes" xml:space="preserve">
          <source>cache module resolution</source>
          <target state="translated">resolución del módulo de caché</target>
        </trans-unit>
        <trans-unit id="30fdfe9db20efa1fbadcfb48f8e2224b604a7625" translate="yes" xml:space="preserve">
          <source>cache settings calculated from &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">configuraci&amp;oacute;n de cach&amp;eacute; calculada a partir de &lt;code&gt;tsconfig.json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb02f65cfddd8df81baf783711476ad11f820af3" translate="yes" xml:space="preserve">
          <source>can actually be passed around to functions</source>
          <target state="translated">puede en realidad pasar a las funciones</target>
        </trans-unit>
        <trans-unit id="1628f3e3fa5143b8a4026ed6fba31449a9455f0b" translate="yes" xml:space="preserve">
          <source>can be rewritten as the following array literal</source>
          <target state="translated">puede ser reescrito como la siguiente matriz literal</target>
        </trans-unit>
        <trans-unit id="f3d83e025c075f2d6dbf66e81628a8d397f050ac" translate="yes" xml:space="preserve">
          <source>can finally be rewritten without helper interfaces.</source>
          <target state="translated">puede finalmente ser reescrito sin interfaces de ayuda.</target>
        </trans-unit>
        <trans-unit id="3bd6f396d9282cc0e5d8f5658854945a9c9a7565" translate="yes" xml:space="preserve">
          <source>checks &amp;ldquo;main&amp;rdquo;, then index.d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fb06210fafc02fd7479ddbed2d042cc3a5155e" translate="yes" xml:space="preserve">
          <source>code</source>
          <target state="translated">code</target>
        </trans-unit>
        <trans-unit id="e40f6b5c83d4e391396b982f962d9261185c5bc7" translate="yes" xml:space="preserve">
          <source>const declarations</source>
          <target state="translated">declaraciones de la const</target>
        </trans-unit>
        <trans-unit id="6d43229f086c7e1519152492bb976fdefa4cd26f" translate="yes" xml:space="preserve">
          <source>declarations.d.ts</source>
          <target state="translated">declarations.d.ts</target>
        </trans-unit>
        <trans-unit id="2c78b75bf2045753edca089f4a8b164e61897b5b" translate="yes" xml:space="preserve">
          <source>default (no value specified)</source>
          <target state="translated">por defecto (no se especifica ningún valor)</target>
        </trans-unit>
        <trans-unit id="4dfe6906050d68d5f43e33ba17ba494351d18a0f" translate="yes" xml:space="preserve">
          <source>disableReferencedProjectLoad - &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa6f0ed9db98407e1677119423605d0592c8193" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t stop the division or &lt;code&gt;someComputation()&lt;/code&gt; call from occurring. It&amp;rsquo;s equivalent to</source>
          <target state="translated">no impide que &lt;code&gt;someComputation()&lt;/code&gt; llamada de divisi&amp;oacute;n o someComputation () . Es equivalente a</target>
        </trans-unit>
        <trans-unit id="be65d27ae088a0e03fd8e1331d90b01649464cb6" translate="yes" xml:space="preserve">
          <source>dom</source>
          <target state="translated">dom</target>
        </trans-unit>
        <trans-unit id="44b226e39304e9a0605138651ed370e25b549357" translate="yes" xml:space="preserve">
          <source>dramaticWelcome.ts</source>
          <target state="translated">dramaticWelcome.ts</target>
        </trans-unit>
        <trans-unit id="e2608af6f0beabaa750585a646e365513da9f22e" translate="yes" xml:space="preserve">
          <source>dynamicPriorityPolling</source>
          <target state="translated">dynamicPriorityPolling</target>
        </trans-unit>
        <trans-unit id="959d6a167eca6ea657af75189c740aa4548ab0b3" translate="yes" xml:space="preserve">
          <source>dynamicPriorityPolling,</source>
          <target state="translated">dynamicPriorityPolling,</target>
        </trans-unit>
        <trans-unit id="aa96353082ad7b23abd85373f7bcda3b74f29b1f" translate="yes" xml:space="preserve">
          <source>eg &lt;code&gt;{ property: Type }&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c3d909b5b29bd46a7edf52931b97737d5d1ace" translate="yes" xml:space="preserve">
          <source>emits as:</source>
          <target state="translated">emite como:</target>
        </trans-unit>
        <trans-unit id="37c5d2d3764f1aed8efd4b2dab6e40c6ae488747" translate="yes" xml:space="preserve">
          <source>equivalent to the unit type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="3c5fff4d0016b644ab9720bf2113d69e16ee0db5" translate="yes" xml:space="preserve">
          <source>es2015.collection</source>
          <target state="translated">es2015.collection</target>
        </trans-unit>
        <trans-unit id="77452a908deffdbe4e25c0322f6fc17a39206ee1" translate="yes" xml:space="preserve">
          <source>es2015.core</source>
          <target state="translated">es2015.core</target>
        </trans-unit>
        <trans-unit id="4860f22d1763b9179816b962767983a680787ab3" translate="yes" xml:space="preserve">
          <source>es2015.generator</source>
          <target state="translated">es2015.generator</target>
        </trans-unit>
        <trans-unit id="a55fcf72537ff6199c436b9f28cfe5f307a1cc8d" translate="yes" xml:space="preserve">
          <source>es2015.iterable</source>
          <target state="translated">es2015.iterable</target>
        </trans-unit>
        <trans-unit id="455275f9b321b188ad0398ce86c78e923eb8b72b" translate="yes" xml:space="preserve">
          <source>es2015.promise</source>
          <target state="translated">es2015.promise</target>
        </trans-unit>
        <trans-unit id="ec95b856e9e47298430b5eb6799d9d8096bc4095" translate="yes" xml:space="preserve">
          <source>es2015.proxy</source>
          <target state="translated">es2015.proxy</target>
        </trans-unit>
        <trans-unit id="e6a8c5db65e11ddb62cc5fade31b70004048dc2c" translate="yes" xml:space="preserve">
          <source>es2015.reflect</source>
          <target state="translated">es2015.reflect</target>
        </trans-unit>
        <trans-unit id="de3c65e6af009d778471d8136d3c826fe99099be" translate="yes" xml:space="preserve">
          <source>es2015.symbol</source>
          <target state="translated">es2015.symbol</target>
        </trans-unit>
        <trans-unit id="671a9cd26cd3ffb3ef770f5b5b32cdcb27809d42" translate="yes" xml:space="preserve">
          <source>es2015.symbol.wellknown</source>
          <target state="translated">es2015.symbol.wellknown</target>
        </trans-unit>
        <trans-unit id="139a6dc78bee16dab8bae5ac789d730b614b917b" translate="yes" xml:space="preserve">
          <source>es2016</source>
          <target state="translated">es2016</target>
        </trans-unit>
        <trans-unit id="cd9583a356098ba3a4b81fc650ae36d83d670a5d" translate="yes" xml:space="preserve">
          <source>es2016.array.include</source>
          <target state="translated">es2016.array.include</target>
        </trans-unit>
        <trans-unit id="911015d28bbfae967ffe9225bd0fbdb225773f33" translate="yes" xml:space="preserve">
          <source>es2017</source>
          <target state="translated">es2017</target>
        </trans-unit>
        <trans-unit id="70890fd881ddc0e6b5672ad7751679f721fb15d1" translate="yes" xml:space="preserve">
          <source>es2017.object</source>
          <target state="translated">es2017.object</target>
        </trans-unit>
        <trans-unit id="5c6dbbf6f5b69fd02229a5a287b71af3d57a3f79" translate="yes" xml:space="preserve">
          <source>es2017.sharedmemory</source>
          <target state="translated">es2017.sharedmemory</target>
        </trans-unit>
        <trans-unit id="04fd367a754d12acaf37607d62e169a42efc8e2f" translate="yes" xml:space="preserve">
          <source>es5</source>
          <target state="translated">es5</target>
        </trans-unit>
        <trans-unit id="616df35d1ecf30f8712a0292c2c5a1d0030a5cf2" translate="yes" xml:space="preserve">
          <source>es6 / es2015</source>
          <target state="translated">es6/es2015</target>
        </trans-unit>
        <trans-unit id="dfb1e3d26774a3a7d06095ec73fbb40447cd1e68" translate="yes" xml:space="preserve">
          <source>export = and import = require()</source>
          <target state="translated">exportar=e importar=requerir()</target>
        </trans-unit>
        <trans-unit id="9639877bbfe3d90ce8d23fd8941c66db62463627" translate="yes" xml:space="preserve">
          <source>fallbackPolling - &lt;code&gt;fallbackPolling&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5ca2976cdf4d1995987c214fc85c32c370ff40" translate="yes" xml:space="preserve">
          <source>fixedPollingInterval,</source>
          <target state="translated">fixedPollingInterval,</target>
        </trans-unit>
        <trans-unit id="552fc8d9cfca0ff2b5ed367c413c5cc38420bb95" translate="yes" xml:space="preserve">
          <source>folders whose combined content represent the structure of the project at runtime. See &lt;a href=&quot;module-resolution#virtual-directories-with-rootdirs&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">carpetas cuyo contenido combinado representa la estructura del proyecto en tiempo de ejecuci&amp;oacute;n. Consulte la &lt;a href=&quot;module-resolution#virtual-directories-with-rootdirs&quot;&gt;documentaci&amp;oacute;n de Resoluci&amp;oacute;n del m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="c6111b4c03a562ccddbf99c1de8d5cfee0039f5a" translate="yes" xml:space="preserve">
          <source>for...of statements</source>
          <target state="translated">para...de las declaraciones</target>
        </trans-unit>
        <trans-unit id="31f79b8f38a6b1aee4464af7bf6e58995fdcc55c" translate="yes" xml:space="preserve">
          <source>for..of support</source>
          <target state="translated">para...de apoyo</target>
        </trans-unit>
        <trans-unit id="e777919351daf00b0d9ef805e8c06560be596a16" translate="yes" xml:space="preserve">
          <source>from anywhere - even modules - using the new &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag.</source>
          <target state="translated">desde cualquier lugar, incluso m&amp;oacute;dulos, utilizando el nuevo indicador &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
