<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">En el modo de comprobaci&amp;oacute;n nulo estricto, los valores &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n en el dominio de todos los tipos y solo se pueden asignar a ellos mismos y a &lt;code&gt;any&lt;/code&gt; (la &amp;uacute;nica excepci&amp;oacute;n es que &lt;code&gt;undefined&lt;/code&gt; tambi&amp;eacute;n se puede asignar a &lt;code&gt;void&lt;/code&gt; ). Entonces, mientras que &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;T | undefined&lt;/code&gt; se consideran sin&amp;oacute;nimos en el modo de verificaci&amp;oacute;n de tipo regular (porque &lt;code&gt;undefined&lt;/code&gt; se considera un subtipo de cualquier &lt;code&gt;T&lt;/code&gt; ), son tipos diferentes en el modo de verificaci&amp;oacute;n de tipo estricto y solo &lt;code&gt;T | undefined&lt;/code&gt; permite valores &lt;code&gt;undefined&lt;/code&gt; . Lo mismo es cierto para la relaci&amp;oacute;n de &lt;code&gt;T&lt;/code&gt; con &lt;code&gt;T | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">En el modo de verificaci&amp;oacute;n nulo estricto, los valores &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; no est&amp;aacute;n en el dominio de todos los tipos y solo se pueden asignar a s&amp;iacute; mismos y a &lt;code&gt;any&lt;/code&gt; (la &amp;uacute;nica excepci&amp;oacute;n es que &lt;code&gt;undefined&lt;/code&gt; tambi&amp;eacute;n se puede asignar a &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">En ese ejemplo, primero verificamos si &lt;code&gt;x&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; era &lt;code&gt;E.Foo&lt;/code&gt; . Si esa comprobaci&amp;oacute;n tiene &amp;eacute;xito, entonces nuestro &lt;code&gt;||&lt;/code&gt; har&amp;aacute; un cortocircuito, y el cuerpo del 'if' funcionar&amp;aacute;. Sin embargo, si la comprobaci&amp;oacute;n no tuvo &amp;eacute;xito, entonces &lt;code&gt;x&lt;/code&gt; &lt;em&gt;solo&lt;/em&gt; puede ser &lt;code&gt;E.Foo&lt;/code&gt; , por lo que no tiene sentido ver si es igual a &lt;code&gt;E.Bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb5ff5bf0dceac10cc35060c81ee9faad7242ab" translate="yes" xml:space="preserve">
          <source>In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db5a8c7126c3ff13b89dab79253baece66850d2" translate="yes" xml:space="preserve">
          <source>In the Template section you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548f3708a85b8745e47e7af1b59669e8ecf4cfa7" translate="yes" xml:space="preserve">
          <source>In the above case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo anterior, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; funcionar&amp;aacute; bien, pero &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; dar&amp;aacute; como resultado un error ya que no se ha especificado en &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">En el ejemplo anterior, &lt;code&gt;SelectableControl&lt;/code&gt; contiene todos los miembros de &lt;code&gt;Control&lt;/code&gt; , incluida la propiedad &lt;code&gt;state&lt;/code&gt; privada . Dado que el &lt;code&gt;state&lt;/code&gt; es un miembro privado, solo los descendientes de &lt;code&gt;Control&lt;/code&gt; pueden implementar &lt;code&gt;SelectableControl&lt;/code&gt; . Esto se debe a que solo los descendientes de &lt;code&gt;Control&lt;/code&gt; tendr&amp;aacute;n un miembro privado &lt;code&gt;state&lt;/code&gt; que se origine en la misma declaraci&amp;oacute;n, lo cual es un requisito para que los miembros privados sean compatibles.</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">En el ejemplo anterior, todas las declaraciones de &lt;code&gt;x&lt;/code&gt; en realidad se refieren a la &lt;em&gt;misma &lt;/em&gt; &lt;code&gt;x&lt;/code&gt; , y esto es perfectamente v&amp;aacute;lido. Esto a menudo termina siendo una fuente de errores. Afortunadamente, &lt;code&gt;let&lt;/code&gt; declaraciones no son tan tolerantes.</target>
        </trans-unit>
        <trans-unit id="c61ebd05e2312c5e85ecc6cef6e59dba4f593f68" translate="yes" xml:space="preserve">
          <source>In the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, TypeScript will try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0ee9dcee21963bf1982f4a5b086175197a8510" translate="yes" xml:space="preserve">
          <source>In the above form, the mixin&amp;rsquo;s have no underlying knowledge of the class which can make it hard to create the design you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">En lo anterior, &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; son compatibles debido a que sus estructuras no utilizan el argumento de tipo de una manera diferenciadora. Cambiar este ejemplo agregando un miembro a &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; muestra c&amp;oacute;mo funciona esto:</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">En lo anterior, si realmente quisi&amp;eacute;ramos que &lt;code&gt;baz&lt;/code&gt; fuera potencialmente &lt;code&gt;undefined&lt;/code&gt; , deber&amp;iacute;amos haberlo declarado con el tipo &lt;code&gt;boolean | undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">En lo anterior, la variable &lt;code&gt;a&lt;/code&gt; tiene un tipo condicional que a&amp;uacute;n no ha elegido una rama. Cuando otro fragmento de c&amp;oacute;digo termina llamando a &lt;code&gt;foo&lt;/code&gt; , lo sustituir&amp;aacute; en &lt;code&gt;U&lt;/code&gt; con alg&amp;uacute;n otro tipo, y TypeScript volver&amp;aacute; a evaluar el tipo condicional, decidiendo si realmente puede elegir una rama.</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">En el c&amp;oacute;digo siguiente, mostramos c&amp;oacute;mo puede modelar mixins en TypeScript. Despu&amp;eacute;s del c&amp;oacute;digo, analizaremos c&amp;oacute;mo funciona.</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">En la declaraci&amp;oacute;n de &lt;code&gt;f2&lt;/code&gt; anterior, la inferencia de tipos infiere los tipos &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;[string, boolean]&lt;/code&gt; y &lt;code&gt;void&lt;/code&gt; para &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="8ab389301f78b38cc120b50ad55981dfdf9ab9b4" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;a href=&quot;functions#this&quot;&gt;this&lt;/a&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">En el ejemplo anterior, el objeto de &lt;code&gt;methods&lt;/code&gt; en el argumento de &lt;code&gt;makeObject&lt;/code&gt; tiene un tipo contextual que incluye &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; y, por lo tanto, el tipo de &lt;code&gt;this&lt;/code&gt; en los m&amp;eacute;todos dentro del objeto de &lt;code&gt;methods&lt;/code&gt; es &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; . Observe c&amp;oacute;mo el tipo de propiedad de los &lt;code&gt;methods&lt;/code&gt; es simult&amp;aacute;neamente un objetivo de inferencia y una fuente para &lt;code&gt;this&lt;/code&gt; tipo de m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo anterior, los par&amp;aacute;metros &lt;code&gt;fruit&lt;/code&gt; y &lt;code&gt;color&lt;/code&gt; se cruzan juntos en un nuevo par&amp;aacute;metro de tipo &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; . &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; es realmente lo mismo que &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; que es equivalente a &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; . Cada una de esas intersecciones imposibles se reduce a &lt;code&gt;never&lt;/code&gt; , y nos quedamos con &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; que es simplemente &lt;code&gt;&quot;orange&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d9dddab39b8eb943f3877822ffa8bdb3bae451" translate="yes" xml:space="preserve">
          <source>In the first &lt;code&gt;length&lt;/code&gt;, T is not necessary; notice that it&amp;rsquo;s only referenced once, so it&amp;rsquo;s not being used to constrain the type of the return value or other parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">En el siguiente ejemplo,cada elemento de entrada se imprimirá de uno en uno con un retardo de 400ms:</target>
        </trans-unit>
        <trans-unit id="d0896b9003166f205cee791b2a20d447c0e588fb" translate="yes" xml:space="preserve">
          <source>In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">En la &amp;uacute;ltima l&amp;iacute;nea construimos una instancia de la clase &lt;code&gt;Greeter&lt;/code&gt; usando &lt;code&gt;new&lt;/code&gt; . Esto llama al constructor que definimos anteriormente, creando un nuevo objeto con la forma &lt;code&gt;Greeter&lt;/code&gt; y ejecutando el constructor para inicializarlo.</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">En la &amp;uacute;ltima ventana, seleccione la plantilla &lt;strong&gt;vac&amp;iacute;a&lt;/strong&gt; y presione el bot&amp;oacute;n &lt;em&gt;Crear&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Mientras tanto, podemos asignar un tipo condicional a cualquier otro tipo de objetivo siempre que cada rama del condicional sea asignable a ese objetivo. Entonces, en nuestro ejemplo anterior, pudimos asignar &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; a &lt;code&gt;string | number&lt;/code&gt; ya que no importa a qu&amp;eacute; se eval&amp;uacute;e el condicional, se sabe que es una &lt;code&gt;string&lt;/code&gt; o un &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">En un futuro cercano, actualizaremos las muestras del &amp;aacute;rea de juegos, agregaremos soporte JSX y mejoraremos la adquisici&amp;oacute;n autom&amp;aacute;tica de tipos, lo que significa que podr&amp;aacute; ver la misma experiencia en el &amp;aacute;rea de juegos que la que obtendr&amp;iacute;a en su editor personal. .</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">En la ra&amp;iacute;z del proyecto, &lt;code&gt;proj&lt;/code&gt; , cree el archivo &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">En la ra&amp;iacute;z del proyecto, cree el archivo &lt;code&gt;gulpfile.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">En el tipo de objeto de m&amp;oacute;dulo, las variables &lt;code&gt;const&lt;/code&gt; exportadas se consideran propiedades de solo lectura.</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">En el tipo de un objeto enum,los miembros enum se consideran propiedades de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">En estos ejemplos, la lista de propiedades es &lt;code&gt;keyof T&lt;/code&gt; y el tipo resultante es alguna variante de &lt;code&gt;T[P]&lt;/code&gt; . Esta es una buena plantilla para cualquier uso general de tipos mapeados. Eso es porque este tipo de transformaci&amp;oacute;n es &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homom&amp;oacute;rfica&lt;/a&gt; , lo que significa que el mapeo se aplica solo a las propiedades de &lt;code&gt;T&lt;/code&gt; y no a otras. El compilador sabe que puede copiar todos los modificadores de propiedad existentes antes de agregar nuevos. Por ejemplo, si &lt;code&gt;Person.name&lt;/code&gt; fuera de solo lectura, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; ser&amp;iacute;a de solo lectura y opcional.</target>
        </trans-unit>
        <trans-unit id="9c7ec405a4a58ac2e2e3c9c60919a90fae57f264" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo anterior, &lt;code&gt;g&lt;/code&gt; captur&amp;oacute; la variable &lt;code&gt;a&lt;/code&gt; declarada en &lt;code&gt;f&lt;/code&gt; . En cualquier punto en el que se llame a &lt;code&gt;g&lt;/code&gt; , el valor de &lt;code&gt;a&lt;/code&gt; estar&amp;aacute; vinculado al valor de &lt;code&gt;a&lt;/code&gt; en &lt;code&gt;f&lt;/code&gt; . Incluso si se llama a &lt;code&gt;g&lt;/code&gt; una vez que &lt;code&gt;f&lt;/code&gt; termine de ejecutarse, podr&amp;aacute; acceder y modificar &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">En este caso, necesitamos usar TypeScript para informar a cualquiera de nuestras personas que llaman sobre las formas en que &lt;code&gt;myCoolFunction&lt;/code&gt; se puede llamar usando sobrecargas de funciones.</target>
        </trans-unit>
        <trans-unit id="ca269f81daa4e288c099aeabd210add3bf701ab7" translate="yes" xml:space="preserve">
          <source>In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code. This pattern can be used to avoid long relative paths within your codebase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ee66fa54ed1af4b6530c2bbfb39ea8c9308255" translate="yes" xml:space="preserve">
          <source>In this case, you can use a &lt;code&gt;switch&lt;/code&gt; statement to narrow down which type is represented at runtime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, si &lt;code&gt;someValue&lt;/code&gt; no es igual a &lt;code&gt;42&lt;/code&gt; , &lt;code&gt;assert&lt;/code&gt; arrojar&amp;aacute; un &lt;code&gt;AssertionError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">En este ejemplo, la &lt;code&gt;b?&lt;/code&gt; indica que &lt;code&gt;b&lt;/code&gt; es opcional, por lo que puede &lt;code&gt;undefined&lt;/code&gt; estar definido . &lt;code&gt;keepWholeObject&lt;/code&gt; tiene ahora una variable para &lt;code&gt;wholeObject&lt;/code&gt; as&amp;iacute; como las propiedades &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; , incluso si &lt;code&gt;b&lt;/code&gt; no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;greeter1&lt;/code&gt; funciona de manera similar a antes. Instalamos la clase &lt;code&gt;Greeter&lt;/code&gt; y usamos este objeto. Esto lo hemos visto antes.</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">En este ejemplo, el mejor tipo com&amp;uacute;n tiene un conjunto de cuatro candidatos: &lt;code&gt;Animal&lt;/code&gt; , &lt;code&gt;Rhino&lt;/code&gt; , &lt;code&gt;Elephant&lt;/code&gt; y &lt;code&gt;Snake&lt;/code&gt; . De estos, &lt;code&gt;Animal&lt;/code&gt; puede elegirse mediante el mejor algoritmo de tipo com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">En este ejemplo,el primer bloque crea los siguientes significados de los nombres:</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">En este ejemplo, no hab&amp;iacute;a un espacio de nombres &lt;code&gt;C&lt;/code&gt; hasta que escribimos la declaraci&amp;oacute;n del &lt;code&gt;namespace&lt;/code&gt; para &amp;eacute;l. El significado de &lt;code&gt;C&lt;/code&gt; como espacio de nombres no entra en conflicto con el valor o los significados de tipo de &lt;code&gt;C&lt;/code&gt; creado por la clase.</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, tenemos un &lt;code&gt;Animal&lt;/code&gt; y un &lt;code&gt;Rhino&lt;/code&gt; , siendo &lt;code&gt;Rhino&lt;/code&gt; una subclase de &lt;code&gt;Animal&lt;/code&gt; . Tambi&amp;eacute;n tenemos una nueva clase de &lt;code&gt;Employee&lt;/code&gt; que se ve id&amp;eacute;ntica a &lt;code&gt;Animal&lt;/code&gt; en t&amp;eacute;rminos de forma. Creamos algunas instancias de estas clases y luego intentamos asignarlas entre s&amp;iacute; para ver qu&amp;eacute; pasa. Debido a que &lt;code&gt;Animal&lt;/code&gt; y &lt;code&gt;Rhino&lt;/code&gt; comparten el lado &lt;code&gt;private&lt;/code&gt; de su forma de la misma declaraci&amp;oacute;n de &lt;code&gt;private name: string&lt;/code&gt; en &lt;code&gt;Animal&lt;/code&gt; , son compatibles. Sin embargo, este no es el caso de &lt;code&gt;Employee&lt;/code&gt; . Cuando intentamos asignar de un &lt;code&gt;Employee&lt;/code&gt; a &lt;code&gt;Animal&lt;/code&gt; obtenemos un error de que estos tipos no son compatibles. Aunque &lt;code&gt;Employee&lt;/code&gt; tambi&amp;eacute;n tiene un miembro &lt;code&gt;private&lt;/code&gt; llamado &lt;code&gt;name&lt;/code&gt; , no es el que declaramos en &lt;code&gt;Animal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, trasladaremos todas las entidades relacionadas con el validador a un espacio de nombres llamado &lt;code&gt;Validation&lt;/code&gt; . Como queremos que las interfaces y clases aqu&amp;iacute; sean visibles fuera del espacio de nombres, las introducimos con &lt;code&gt;export&lt;/code&gt; . Por el contrario, las variables &lt;code&gt;lettersRegexp&lt;/code&gt; y &lt;code&gt;numberRegexp&lt;/code&gt; son detalles de implementaci&amp;oacute;n, por lo que no se exportan y no ser&amp;aacute;n visibles para el c&amp;oacute;digo fuera del espacio de nombres. En el c&amp;oacute;digo de prueba al final del archivo, ahora necesitamos calificar los nombres de los tipos cuando se usan fuera del espacio de nombres, por ejemplo, &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">En este c&amp;oacute;digo generado, se compila una enumeraci&amp;oacute;n en un objeto que almacena asignaciones directas ( &lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt; ) e inversas ( &lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt; ). Las referencias a otros miembros de enumeraci&amp;oacute;n siempre se emiten como accesos de propiedad y nunca en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">En esta gu&amp;iacute;a, asumiremos una familiaridad b&amp;aacute;sica con el lenguaje TypeScript. Si a&amp;uacute;n no lo ha hecho, deber&amp;iacute;a leer el &lt;a href=&quot;../basic-types&quot;&gt;Manual de TypeScript&lt;/a&gt; para familiarizarse con los conceptos b&amp;aacute;sicos, especialmente los tipos y los espacios de nombres.</target>
        </trans-unit>
        <trans-unit id="daba3c5117e7e15297eb31c7463a628f5e08b0ec" translate="yes" xml:space="preserve">
          <source>In this introduction, I assume you know the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">En este modo, las referencias a m&amp;oacute;dulos y paquetes (por ejemplo, las directivas &lt;code&gt;import&lt;/code&gt; sy &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; ) se resuelven en relaci&amp;oacute;n con la ubicaci&amp;oacute;n del archivo de enlace simb&amp;oacute;lico, en lugar de con respecto a la ruta que el enlace simb&amp;oacute;lico resuelve. Para un ejemplo m&amp;aacute;s concreto, vamos a aplazar a &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;la documentaci&amp;oacute;n en el sitio web de Node.js&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">En esta secci&amp;oacute;n describiremos varios errores comunes en el uso de espacios de nombres y m&amp;oacute;dulos, y c&amp;oacute;mo evitarlos.</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">En esta secci&amp;oacute;n, cubriremos la inferencia de tipos en TypeScript. Es decir, discutiremos d&amp;oacute;nde y c&amp;oacute;mo se infieren los tipos.</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">En este ejemplo simple, &lt;code&gt;Keys&lt;/code&gt; es una lista codificada de nombres de propiedad y el tipo de propiedad siempre es &lt;code&gt;boolean&lt;/code&gt; o , por lo que este tipo mapeado es equivalente a escribir:</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">En esta versi&amp;oacute;n, agregamos un setter que verifica la longitud de &lt;code&gt;newName&lt;/code&gt; para asegurarse de que sea compatible con la longitud m&amp;aacute;xima de nuestro campo de base de datos de respaldo. Si no es as&amp;iacute;, arrojamos un error notificando al c&amp;oacute;digo del cliente que algo sali&amp;oacute; mal.</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">De esta manera,un tipo genérico que tiene sus argumentos de tipo especificados actúa como un tipo no genérico.</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">En el c&amp;oacute;digo tradicional orientado a objetos, podr&amp;iacute;amos abstraer los dos tipos creando una jerarqu&amp;iacute;a de tipos. Si bien esto es mucho m&amp;aacute;s expl&amp;iacute;cito, tambi&amp;eacute;n es un poco exagerado. Una de las cosas buenas de la versi&amp;oacute;n original de &lt;code&gt;padLeft&lt;/code&gt; fue que pudimos simplemente pasar primitivas. Eso significaba que el uso era simple y conciso. Este nuevo enfoque tampoco ayudar&amp;iacute;a si solo intent&amp;aacute;ramos usar una funci&amp;oacute;n que ya existe en otros lugares.</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">En su editor, escriba el siguiente c&amp;oacute;digo JavaScript en &lt;code&gt;greeter.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2065108186f788b7e824c4d623ba210ab88b1c4" translate="yes" xml:space="preserve">
          <source>Include - &lt;code&gt;include&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">Incluya m&amp;oacute;dulos importados con extensi&amp;oacute;n &lt;code&gt;.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">Incluyendo archivos &lt;code&gt;.js&lt;/code&gt; con &lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">Incluyendo declaraciones de tipo &lt;code&gt;--lib&lt;/code&gt; con --lib</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">Incluyendo declaraciones en su paquete npm</target>
        </trans-unit>
        <trans-unit id="67c5ad4060ac33b6d094ebba765d48e9ee51b0ef" translate="yes" xml:space="preserve">
          <source>Incremental - &lt;code&gt;incremental&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">Observaci&amp;oacute;n incremental de archivos para proyectos compuestos en &lt;code&gt;--build --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7deed7a63ea26f03a02053b178171e4c34213f53" translate="yes" xml:space="preserve">
          <source>Incremental typing in JavaScript &lt;a href=&quot;jsdoc-supported-types&quot;&gt;via JSDoc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">Tipos de índice</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">Tipos de índice y firmas de índice</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">Tipos indexables</target>
        </trans-unit>
        <trans-unit id="0adbe17edc35b59357a465c0c0744f9ea42fd3f6" translate="yes" xml:space="preserve">
          <source>Individual library components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">Inferencia de los tipos mapeados</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">Infiriendo los tipos</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">Iniciar el proyecto</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">Inicializa un proyecto de TypeScript y crea un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">Inicializar un objeto con propiedades dinámicas puede ser un poco pesado.Tomemos el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="9c7561073b85798bf28e57100cdf96cfe8bdcf3e" translate="yes" xml:space="preserve">
          <source>Inline Source Map - &lt;code&gt;inlineSourceMap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424e6831576ffef65176196315c29ac68ac4bf21" translate="yes" xml:space="preserve">
          <source>Inline Sources - &lt;code&gt;inlineSources&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">Dentro de la secci&amp;oacute;n &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; del archivo &lt;code&gt;package.json&lt;/code&gt; , agregue &lt;em&gt;gulp&lt;/em&gt; y &lt;em&gt;del&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">Instalar ASP.NET Core y TypeScript</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">Instalar nuestras dependencias</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">Instalación de TypeScript</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">En lugar de &lt;code&gt;Object&lt;/code&gt; , use el tipo de &lt;code&gt;object&lt;/code&gt; no primitivo ( &lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;agregado en TypeScript 2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="481ebcf06d3a6af9b20dbe32b1d7d942a9bbaeef" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">En lugar de &lt;code&gt;any&lt;/code&gt; , podemos usar un &lt;em&gt;tipo de uni&amp;oacute;n&lt;/em&gt; para el par&amp;aacute;metro de &lt;code&gt;padding&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">En lugar de un tipo relativamente in&amp;uacute;til como &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; , que inferir&amp;iacute;an versiones anteriores del lenguaje, la inferencia de TypeScript 3.4 permite que &lt;code&gt;newFn&lt;/code&gt; sea ​​gen&amp;eacute;rico. Su nuevo tipo es &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7820345e86f733909d6d0cf768d7afc07da46bf5" translate="yes" xml:space="preserve">
          <source>Instead of importing helpers with &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">En lugar de trabajar con todos y cada uno de los tipos, nos gustar&amp;iacute;a restringir esta funci&amp;oacute;n para que funcione con todos los tipos que tambi&amp;eacute;n tengan la propiedad &lt;code&gt;.length&lt;/code&gt; . Siempre que el tipo tenga este miembro, lo permitiremos, pero se requiere tener al menos este miembro. Para hacerlo, debemos enumerar nuestro requisito como una restricci&amp;oacute;n sobre lo que puede ser T.</target>
        </trans-unit>
        <trans-unit id="56c1302b0e9b5a2d049280773df6dd17a03e760a" translate="yes" xml:space="preserve">
          <source>Instead, use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">En cambio, necesitamos una forma de capturar el tipo de argumento de tal manera que tambi&amp;eacute;n podamos usarlo para denotar lo que se est&amp;aacute; devolviendo. Aqu&amp;iacute;, usaremos una &lt;em&gt;variable de tipo&lt;/em&gt; , un tipo especial de variable que trabaja con tipos en lugar de valores.</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">En cambio,necesitamos pasar valores cuyo tipo tenga todas las propiedades requeridas:</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">En cambio, necesitar&amp;iacute;a trabajar directamente con el lado est&amp;aacute;tico de la clase. En este ejemplo, definimos dos interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; para el constructor y &lt;code&gt;ClockInterface&lt;/code&gt; para los m&amp;eacute;todos de instancia. Luego, por conveniencia, definimos una funci&amp;oacute;n constructora &lt;code&gt;createClock&lt;/code&gt; que crea instancias del tipo que se le pasa:</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">Integración con las herramientas de construcción</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">Integrándose con las herramientas de construcción:Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">Integrándose con las herramientas de construcción:Navegue por</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">Integrándose con las herramientas de construcción:Dúo</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">Integrándose con las herramientas de construcción:Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">Integrándose con las herramientas de construcción:Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">Integrándose con las herramientas de construcción:Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">Integrándose con las herramientas de construcción:MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">Integrándose con las herramientas de construcción:NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">Integrándose con las herramientas de construcción:Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA (Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA (Windows)</target>
        </trans-unit>
        <trans-unit id="a018a82309e992e850b9031373cff79ce1cccba4" translate="yes" xml:space="preserve">
          <source>Interested in learning more?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">Interfaces que amplían las clases</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">Las interfaces son capaces de describir el amplio rango de formas que los objetos de JavaScript pueden tomar.Además de describir un objeto con propiedades,las interfaces también son capaces de describir tipos de funciones.</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">Las interfaces describen el lado público de la clase,más que el lado público y el privado.Esto te prohíbe usarlas para comprobar que una clase también tiene tipos particulares para la parte privada de la instancia de la clase.</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">Interfaces vs.Alias de tipo</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">Las interfaces con propiedades opcionales se escriben de manera similar a otras interfaces, con cada propiedad opcional indicada por un &lt;code&gt;?&lt;/code&gt; al final del nombre de la propiedad en la declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">Tipos de intersección</target>
        </trans-unit>
        <trans-unit id="084148d39f0e6339840f9abce4a71b7b8a28568e" translate="yes" xml:space="preserve">
          <source>Intersection and Union types are one of the ways in which you can compose types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">Tipos de intersección</target>
        </trans-unit>
        <trans-unit id="b78d51b88c1d1feb693e6d11fb2eab9417d88d2e" translate="yes" xml:space="preserve">
          <source>Intersection types are closely related to union types, but they are used very differently. An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a type which is all of &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564a9241fc2a9fe2599b22267f67a36231a5fd3e" translate="yes" xml:space="preserve">
          <source>Intersections</source>
          <target state="translated">Intersections</target>
        </trans-unit>
        <trans-unit id="024b4beab6775314e602953c2f94088fe4678bde" translate="yes" xml:space="preserve">
          <source>Intrinsic String Manipulation Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">Elementos intrínsecos</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">Los elementos intr&amp;iacute;nsecos se &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; en la interfaz especial JSX.IntrinsicElements . De forma predeterminada, si no se especifica esta interfaz, todo vale y los elementos intr&amp;iacute;nsecos no se comprobar&amp;aacute;n el tipo. Sin embargo, si esta interfaz &lt;em&gt;est&amp;aacute;&lt;/em&gt; presente, el nombre del elemento intr&amp;iacute;nseco se busca como una propiedad en la interfaz &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5929e5c75cee5abeee0333968fe15c20cd3d7eef" translate="yes" xml:space="preserve">
          <source>Intro to the TSConfig Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="7f426c016099b5f664f1e39e6247678f1b9e5312" translate="yes" xml:space="preserve">
          <source>Introduction to the DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">Introducción:Inmersión profunda</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">Introducción:Buscar e instalar archivos de declaración</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">Introducción:Estructuras de la biblioteca</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">Introducción:Publicar a npm</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">Introducción:Secciones</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">Introducción:Plantillas</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">Introducción:&quot;Lo que se debe y lo que no se debe hacer</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">Invocar &lt;code&gt;tsc&lt;/code&gt; dos veces supone una mayor sobrecarga de tiempo de inicio</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">Invocar el compilador con &lt;code&gt;--alwaysStrict&lt;/code&gt; causas:</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">Invocar el compilador con &lt;code&gt;--traceResolution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92c7543673d428591b536d245bf2f8a34c3f3bdf" translate="yes" xml:space="preserve">
          <source>Is your build output mostly the same as your source input files? Use &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2b2e48ddaed31be99cbca83c7b264785d54b10" translate="yes" xml:space="preserve">
          <source>Isolated Modules - &lt;code&gt;isolatedModules&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54054e6683cbfd13efd0196ccd3001db60a01e75" translate="yes" xml:space="preserve">
          <source>It also ships with a mapped type &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; that makes all properties &lt;code&gt;readonly&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">También se puede usar como una variable global,pero sólo dentro de un guión.(Un script es un archivo sin importaciones ni exportaciones).</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">También se puede usar para crear espacios de nombres simples:</target>
        </trans-unit>
        <trans-unit id="683cf85c60231c18d1e9862199f167cc8ac3cdf5" translate="yes" xml:space="preserve">
          <source>It can be tempting to think that the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; are the same as the lowercase versions recommended above. These types do not refer to the language primitives however, and almost never should be used as a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38dbabfa59d50143ee85c5c345800b0f340110b" translate="yes" xml:space="preserve">
          <source>It does not change the behavior of your code, or otherwise change the behavior of TypeScript&amp;rsquo;s checking and emitting process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">No tiene un inicializador y el miembro de enumeraci&amp;oacute;n anterior era una constante &lt;em&gt;num&amp;eacute;rica&lt;/em&gt; . En este caso, el valor del miembro de enumeraci&amp;oacute;n actual ser&amp;aacute; el valor del miembro de enumeraci&amp;oacute;n anterior m&amp;aacute;s uno.</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">Es un patr&amp;oacute;n com&amp;uacute;n devolver el objeto actual (es decir, &lt;code&gt;this&lt;/code&gt; ) de un m&amp;eacute;todo para crear &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;API de estilo fluido&lt;/a&gt; . Por ejemplo, considere el siguiente m&amp;oacute;dulo &lt;code&gt;BasicCalculator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">Es un error de tiempo de compilaci&amp;oacute;n para que las expresiones de enumeraci&amp;oacute;n constante se eval&amp;uacute;en en &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;Infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6c1d1a64c5c77319ef0ca3b0e9b3ec9e20641bd" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and &lt;strong&gt;we recommended modules over namespaces in modern code&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">También cabe señalar que,para las aplicaciones de Node.js,los módulos son el enfoque predeterminado y recomendado para estructurar su código.</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">Es un error hacer referencia a un archivo que no existe.Es un error que un archivo tenga una referencia de triple barra a sí mismo.</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">Es importante señalar que es un error llamar a una función con demasiados argumentos.</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">Es importante notar que el compilador &lt;em&gt;no&lt;/em&gt; realizar&amp;aacute; ninguna de estas transformaciones; simplemente usa estos datos para guiar el proceso de resoluci&amp;oacute;n de la importaci&amp;oacute;n de un m&amp;oacute;dulo a su archivo de definici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3789f800d631595c74b86aed0db3fe5327908530" translate="yes" xml:space="preserve">
          <source>It is not a mechanism that &lt;strong&gt;prevents&lt;/strong&gt; a file from being included in the codebase - it simply changes what the &lt;code&gt;include&lt;/code&gt; setting finds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">No es posible utilizar declaraciones &lt;code&gt;infer&lt;/code&gt; idas en cl&amp;aacute;usulas de restricci&amp;oacute;n para par&amp;aacute;metros de tipo regular:</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">Es posible definir el tipo de componente de una clase. Sin embargo, para hacerlo, es mejor comprender dos t&amp;eacute;rminos nuevos: el &lt;em&gt;tipo de clase de elemento&lt;/em&gt; y el &lt;em&gt;tipo de instancia de elemento&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">Es el primer miembro de la enumeraci&amp;oacute;n y no tiene inicializador, en cuyo caso se le asigna el valor &lt;code&gt;0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">Vale la pena se&amp;ntilde;alar que si el paquete npm ya incluye su archivo de declaraci&amp;oacute;n como se describe en &lt;a href=&quot;publishing&quot;&gt;Publicaci&amp;oacute;n&lt;/a&gt; , no es necesario descargar el paquete &lt;code&gt;@types&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">Da la casualidad de que TypeScript tiene algo llamado &lt;em&gt;tipo protector&lt;/em&gt; . Una protecci&amp;oacute;n de tipo es una expresi&amp;oacute;n que realiza una verificaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n que garantiza el tipo en alg&amp;uacute;n &amp;aacute;mbito.</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">Fue posible para los archivos de implementación importar los archivos de prueba</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">No fue posible compilar &lt;code&gt;test&lt;/code&gt; y &lt;code&gt;src&lt;/code&gt; al mismo tiempo sin que &lt;code&gt;src&lt;/code&gt; apareciera en el nombre de la carpeta de salida, lo que probablemente no quieras</target>
        </trans-unit>
        <trans-unit id="9c6a38098d06734f39da99f25d9ab37fea049fd8" translate="yes" xml:space="preserve">
          <source>It would be an error to specify &lt;code&gt;rootDir&lt;/code&gt; as &lt;code&gt;core&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;include&lt;/code&gt; as &lt;code&gt;*&lt;/code&gt; because it creates a file (&lt;code&gt;helpers.ts&lt;/code&gt;) that would need to be emitted &lt;em&gt;outside&lt;/em&gt; the &lt;code&gt;outDir&lt;/code&gt; (i.e. &lt;code&gt;../helpers.js&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57b32bfac61e19b63383ba6ca826d555cc838b5" translate="yes" xml:space="preserve">
          <source>It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">Tambi&amp;eacute;n es com&amp;uacute;n intentar acceder a un m&amp;eacute;todo antes de &lt;code&gt;await&lt;/code&gt; &lt;code&gt;.then()&lt;/code&gt; o .luego () -ing una &lt;code&gt;Promise&lt;/code&gt; . Este es otro ejemplo, entre muchos otros, en los que podemos hacerlo mejor.</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">Tambi&amp;eacute;n es importante tener en cuenta que TypeScript no transforma las referencias a &lt;code&gt;globalThis&lt;/code&gt; al compilar versiones anteriores de ECMAScript. Como tal, a menos que est&amp;eacute; apuntando a navegadores de hoja perenne (que ya son compatibles con &lt;code&gt;globalThis&lt;/code&gt; ), es posible que desee &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;utilizar un polyfill apropiado en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">&amp;iexcl;Siempre es bueno poder documentar su configuraci&amp;oacute;n! &lt;code&gt;tsconfig.json&lt;/code&gt; ahora acepta comentarios de una o varias l&amp;iacute;neas.</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">Es un error desestructurar una tupla m&amp;aacute;s all&amp;aacute; del rango de sus elementos:</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">En esta situaci&amp;oacute;n, es importante no anteponer cada referencia, porque terminar&amp;aacute; con dos copias de &lt;code&gt;A&lt;/code&gt; en la salida de &lt;code&gt;D&lt;/code&gt; ; esto puede llevar a resultados inesperados.</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">Es importante tener en cuenta que awesome-typescript-loader deber&amp;aacute; ejecutarse antes que cualquier otro cargador que se &lt;code&gt;.js&lt;/code&gt; archivos .js .</target>
        </trans-unit>
        <trans-unit id="a2ffa790ea2c3349ed046c358aae967ad51e1cec" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that ts-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b692de3183276b518dabfb631757e7af1419f734" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that TypeScript uses the same &lt;em&gt;runtime&lt;/em&gt; as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don&amp;rsquo;t limit yourself to TypeScript-specific resources!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">No es raro que una API espere un conjunto espec&amp;iacute;fico de cadenas para ciertos valores. Por ejemplo, considere una biblioteca de UI que puede mover elementos a trav&amp;eacute;s de la pantalla mientras controla la &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&quot;suavizaci&amp;oacute;n&quot; de la animaci&amp;oacute;n.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b18ceff60d615281a03cf2a9ea16d87dd519931" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible you really &lt;em&gt;did&lt;/em&gt; intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript&amp;rsquo;s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we&amp;rsquo;ll learn about settings you can use to configure how strictly TypeScript checks your code.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c163602d3325175e90ecde073b2e8d099514998d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file, and that circularity between configuration files is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">Vale la pena se&amp;ntilde;alar que el verificador de tipos no requiere que estas propiedades vengan en ning&amp;uacute;n tipo de orden, solo que las propiedades que requiere la interfaz est&amp;eacute;n presentes y tengan el tipo requerido.</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">Iteradores y generadores</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">Iteradores y generadores</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="7aec719645d59e0338990dc21d17c20ab20b5e3a" translate="yes" xml:space="preserve">
          <source>JS Class extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53889159f973b9fcdbf5533d3f8b2fee581e75e1" translate="yes" xml:space="preserve">
          <source>JS Projects Utilizing TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad13379ffbb44dfeef3669b43a6cf7eda0226c2" translate="yes" xml:space="preserve">
          <source>JSDoc Property Modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196b2a7280a3752416773c234c6662e07ab87209" translate="yes" xml:space="preserve">
          <source>JSDoc Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d193b4e629fd62bb8a4297db587f6b30503894f" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;) to express optionality. e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">Las funciones anotadas de JSDoc están excluidas de esta regla.Use la sintaxis de parámetros opcionales de JSDoc para expresar la opcionalidad.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">Las anotaciones del JSDoc que adornan una declaración se usarán para establecer el tipo de esa declaración.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b57ab1e3e810539c8d1ec0a2a10337c1c2186c67" translate="yes" xml:space="preserve">
          <source>JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">Los tipos JSDoc se usan para la información de tipos</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="200185b1255b1a221ca2903c5a111895d54bee5e" translate="yes" xml:space="preserve">
          <source>JSX - &lt;code&gt;jsx&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a12fc57c5b8ab36078ef438cd9ea85d576a140" translate="yes" xml:space="preserve">
          <source>JSX Factory - &lt;code&gt;jsxFactory&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSX le permite incrustar expresiones entre etiquetas rodeando las expresiones con llaves ( &lt;code&gt;{ }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">Los nombres y propiedades de los elementos JSX se validan con el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; . Consulte la p&amp;aacute;gina wiki [[JSX]] para definir el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; para su marco.</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">Los elementos JSX permiten ahora pasar argumentos de tipo a los componentes genéricos.</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSX es una sintaxis incrustada similar a XML.Está pensada para ser transformada en un JavaScript válido,pero la semántica de esa transformación es específica de la implementación.JSX se hizo popular con la librería React,pero desde entonces ha visto otras aplicaciones.TypeScript 1.6 soporta la incrustación,la verificación de tipos,y opcionalmente la compilación de JSX directamente en JavaScript.</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">Soporte JSX</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">La verificaci&amp;oacute;n de tipo JSX est&amp;aacute; impulsada por definiciones en un espacio de nombres JSX, por ejemplo, &lt;code&gt;JSX.Element&lt;/code&gt; para el tipo de un elemento JSX y &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; para elementos integrados. Antes de TypeScript 2.8, se esperaba que el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; estuviera en el espacio de nombres global y, por lo tanto, solo permitiera definir uno en un proyecto. A partir de TypeScript 2.8, el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; se buscar&amp;aacute; bajo &lt;code&gt;jsxNamespace&lt;/code&gt; (por ejemplo, &lt;code&gt;React&lt;/code&gt; ), lo que permite m&amp;uacute;ltiples f&amp;aacute;bricas jsx en una compilaci&amp;oacute;n. Para compatibilidad con versiones anteriores, el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; global se utiliza como reserva si no se defini&amp;oacute; ninguno en la funci&amp;oacute;n de f&amp;aacute;brica. Combinado con el archivo &lt;code&gt;@jsx&lt;/code&gt; pragma, cada archivo puede tener una f&amp;aacute;brica JSX diferente.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="0a68962be09173771bec34eb689c44a3c96b2537" translate="yes" xml:space="preserve">
          <source>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page &amp;mdash; writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d9a3e1ce5dffeacdf5c830a6c6440a69613ddc" translate="yes" xml:space="preserve">
          <source>JavaScript also allows accessing properties which aren&amp;rsquo;t present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b453322efee2df3d69cc86054aa88030b8bd03" translate="yes" xml:space="preserve">
          <source>JavaScript defines 8 built-in types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c885f8940580133691e264e6c024d89b341481" translate="yes" xml:space="preserve">
          <source>JavaScript does have some limited primitives like &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, &lt;code&gt;typeof (new Car())&lt;/code&gt; will be &lt;code&gt;&quot;object&quot;&lt;/code&gt;, not &lt;code&gt;Car&lt;/code&gt; or &lt;code&gt;&quot;Car&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScript tiene muchas sintaxis o convenciones de m&amp;oacute;dulos diferentes: la del est&amp;aacute;ndar ECMAScript, la que Node ya admite (CommonJS), AMD, System.js, &amp;iexcl;y m&amp;aacute;s! En su mayor parte, TypeScript se importar&amp;iacute;a autom&amp;aacute;ticamente de forma predeterminada utilizando la sintaxis del m&amp;oacute;dulo ECMAScript, que a menudo era inapropiado en ciertos proyectos de TypeScript con diferentes configuraciones de compilador, o en proyectos de nodo con JavaScript simple y &lt;code&gt;require&lt;/code&gt; llamadas.</target>
        </trans-unit>
        <trans-unit id="98cdb2f49473d8f457b2b983ae7b2e9569316471" translate="yes" xml:space="preserve">
          <source>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type &lt;code&gt;number&lt;/code&gt; and the boxed type &lt;code&gt;Number&lt;/code&gt;. The boxed types are rarely needed, since their methods return primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScript es inherentemente un lenguaje muy din&amp;aacute;mico. No es raro que una sola funci&amp;oacute;n de JavaScript devuelva diferentes tipos de objetos seg&amp;uacute;n la forma de los argumentos pasados.</target>
        </trans-unit>
        <trans-unit id="3fa9627af8c315eed2d8a18ed7ec36d91039abb7" translate="yes" xml:space="preserve">
          <source>JavaScript projects can use a &lt;code&gt;jsconfig.json&lt;/code&gt; file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1195a91c56a7095e67e44a18fe31d7c0292fae" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s equality operator (&lt;code&gt;==&lt;/code&gt;) &lt;em&gt;coerces&lt;/em&gt; its arguments, leading to unexpected behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db5a96d3e3aba783d7007c3a17e6f71e51a7e0e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s modern module syntax is a bit like Haskell&amp;rsquo;s, except that any file with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is implicitly a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">As&amp;iacute; como &quot;exportar cerca del nivel superior&quot; reduce la fricci&amp;oacute;n en los consumidores de su m&amp;oacute;dulo, tambi&amp;eacute;n lo hace la introducci&amp;oacute;n de una exportaci&amp;oacute;n predeterminada. Si el prop&amp;oacute;sito principal de un m&amp;oacute;dulo es albergar una exportaci&amp;oacute;n espec&amp;iacute;fica, entonces deber&amp;iacute;a considerar exportarlo como una exportaci&amp;oacute;n predeterminada. Esto hace que tanto la importaci&amp;oacute;n como el uso real de la importaci&amp;oacute;n sean un poco m&amp;aacute;s f&amp;aacute;ciles. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">Al igual que en JavaScript, las funciones pueden hacer referencia a variables fuera del cuerpo de la funci&amp;oacute;n. Cuando lo hacen, se dice que &lt;em&gt;capturan&lt;/em&gt; estas variables. Si bien comprender c&amp;oacute;mo funciona esto (y las compensaciones al usar esta t&amp;eacute;cnica) est&amp;aacute; fuera del alcance de este art&amp;iacute;culo, tener una comprensi&amp;oacute;n firme de c&amp;oacute;mo funciona esta mec&amp;aacute;nica es una parte importante del trabajo con JavaScript y TypeScript.</target>
        </trans-unit>
        <trans-unit id="f568f7b7378d75e427e395efb94692dbc6539719" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">As&amp;iacute; como existe una correspondencia uno a uno entre los archivos JS y los m&amp;oacute;dulos, TypeScript tiene una correspondencia uno a uno entre los archivos fuente del m&amp;oacute;dulo y sus archivos JS emitidos. Un efecto de esto es que no es posible concatenar m&amp;uacute;ltiples archivos fuente de m&amp;oacute;dulo dependiendo del sistema de m&amp;oacute;dulo al que se dirige. Por ejemplo, no puede usar la opci&amp;oacute;n &lt;code&gt;outFile&lt;/code&gt; mientras apunta a &lt;code&gt;commonjs&lt;/code&gt; o &lt;code&gt;umd&lt;/code&gt; , pero con TypeScript 1.8 y &lt;code&gt;outFile&lt;/code&gt; posteriores, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;es posible&lt;/a&gt; usar outFile cuando apunta a &lt;code&gt;amd&lt;/code&gt; o &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ce9925cfd88bf773f747d79c2d2f37e043fb9f" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;for / of&lt;/code&gt;, &lt;code&gt;downlevelIteration&lt;/code&gt; will use &lt;code&gt;Symbol.iterator&lt;/code&gt; (if present) to more accurately emulate ES 6 behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">Al igual que con la interfaz,poner el parámetro de tipo en la propia clase nos permite asegurarnos de que todas las propiedades de la clase funcionan con el mismo tipo.</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">Al igual que toda la contaminación mundial del espacio de nombres,puede ser difícil identificar las dependencias de los componentes,especialmente en una gran aplicación.</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">Al igual que las interfaces,los alias de tipo también pueden ser genéricos-podemos simplemente añadir parámetros de tipo y usarlos en el lado derecho de la declaración de alias:</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">Al igual que los espacios de nombres, los m&amp;oacute;dulos pueden contener tanto c&amp;oacute;digo como declaraciones. La principal diferencia es que los m&amp;oacute;dulos &lt;em&gt;declaran&lt;/em&gt; sus dependencias.</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">Al igual que las cuerdas,los símbolos pueden ser usados como claves para las propiedades de los objetos.</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">Sólo corre:</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; se activar&amp;aacute; junto con otros &lt;code&gt;--strict&lt;/code&gt; mode, que pueden afectar su proyecto. Puede establecer la configuraci&amp;oacute;n &lt;code&gt;strictPropertyInitialization&lt;/code&gt; en &lt;code&gt;false&lt;/code&gt; en su &lt;code&gt;tsconfig.json&lt;/code&gt; 's &lt;code&gt;compilerOptions&lt;/code&gt; , o &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; en la l&amp;iacute;nea de comando para desactivar esta verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">&amp;iquest;Ten en cuenta eso &lt;code&gt;?.&lt;/code&gt; act&amp;uacute;a de manera diferente a las operaciones &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ya que &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; actuar&amp;aacute; especialmente en valores &quot;falsos&quot; (por ejemplo, la cadena vac&amp;iacute;a, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; y, bueno, &lt;code&gt;false&lt;/code&gt; ), pero esta es una caracter&amp;iacute;stica intencional de la construcci&amp;oacute;n. No cortocircuita datos v&amp;aacute;lidos como &lt;code&gt;0&lt;/code&gt; o cadenas vac&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">Tenga en cuenta que la inclusi&amp;oacute;n autom&amp;aacute;tica solo es importante si utiliza archivos con declaraciones globales (a diferencia de los archivos declarados como m&amp;oacute;dulos). Si usa una declaraci&amp;oacute;n de &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; , por ejemplo, TypeScript a&amp;uacute;n puede buscar en las carpetas &lt;code&gt;node_modules&lt;/code&gt; y &lt;code&gt;node_modules/@types&lt;/code&gt; para encontrar el paquete &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">Tenga en cuenta que para un c&amp;oacute;digo simple como el anterior, probablemente no deber&amp;iacute;a intentar &quot;sortear&quot; estas comprobaciones. Para literales de objetos m&amp;aacute;s complejos que tienen m&amp;eacute;todos y estado de retenci&amp;oacute;n, es posible que deba tener en cuenta estas t&amp;eacute;cnicas, pero la mayor&amp;iacute;a de los errores de propiedad en exceso son en realidad errores. Eso significa que si tiene problemas de verificaci&amp;oacute;n de exceso de propiedad para algo como bolsas de opciones, es posible que deba revisar algunas de sus declaraciones de tipo. En este caso, si est&amp;aacute; bien pasar un objeto con una propiedad de &lt;code&gt;color&lt;/code&gt; o de &lt;code&gt;colour&lt;/code&gt; a &lt;code&gt;createSquare&lt;/code&gt; , debe corregir la definici&amp;oacute;n de &lt;code&gt;SquareConfig&lt;/code&gt; para reflejar eso.</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">Tenga en cuenta que nuestro soporte para iteradores as&amp;iacute;ncronos depende del soporte para que &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; exista en tiempo de ejecuci&amp;oacute;n. Es posible que necesite &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; , que para prop&amp;oacute;sitos simples puede ser tan simple como: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">Tenga en cuenta que los miembros de la enumeraci&amp;oacute;n de cadenas &lt;em&gt;no&lt;/em&gt; obtienen una asignaci&amp;oacute;n inversa generada en absoluto.</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">Mantener la salida de la consola desactualizada en el modo de reloj en lugar de borrar la pantalla</target>
        </trans-unit>
        <trans-unit id="652c3d36f013f3eb41d356a2dc9496bad6b87cd2" translate="yes" xml:space="preserve">
          <source>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">Conceptos clave</target>
        </trans-unit>
        <trans-unit id="e3f555e673324c6ef7fc096a52a9695768dbceba" translate="yes" xml:space="preserve">
          <source>Keyof Strings Only - &lt;code&gt;keyofStringsOnly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842ec99d82ed307bd84f2310114874cbd9666b4e" translate="yes" xml:space="preserve">
          <source>Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3366a00a2d7b488f6edaccf084d0f236fe293734" translate="yes" xml:space="preserve">
          <source>Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">Por último,creamos una función de ayuda que hará la mezcla por nosotros.Esto recorrerá las propiedades de cada una de las mezclas y las copiará en el objetivo de las mismas,llenando las propiedades de los suplentes con sus implementaciones.</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">Diseñe el proyecto...</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">El dise&amp;ntilde;o de las compilaciones que usan &lt;code&gt;outFile&lt;/code&gt; es m&amp;aacute;s flexible porque las rutas relativas no importan tanto. Una cosa a tener en cuenta es que generalmente no querr&amp;aacute; usar &lt;code&gt;prepend&lt;/code&gt; hasta el &amp;ldquo;&amp;uacute;ltimo&amp;rdquo; proyecto; esto mejorar&amp;aacute; los tiempos de compilaci&amp;oacute;n y reducir&amp;aacute; la cantidad de E / S necesaria en cualquier compilaci&amp;oacute;n. El repositorio de TypeScript en s&amp;iacute; mismo es una buena referencia aqu&amp;iacute;: tenemos algunos proyectos de &quot;biblioteca&quot; y algunos proyectos de &quot;punto final&quot;; Los proyectos de &quot;punto final&quot; se mantienen lo m&amp;aacute;s peque&amp;ntilde;os posible y solo incorporan las bibliotecas que necesitan.</target>
        </trans-unit>
        <trans-unit id="a8ce8ab803d2f69beb12ecc965c63513d9c144ec" translate="yes" xml:space="preserve">
          <source>Learn how to use a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f574e7a40077551e582b33afc9de1c41b4ea1f26" translate="yes" xml:space="preserve">
          <source>Learn how to work in an &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild project&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a698431922622bdba500ba547874a9e36cb868" translate="yes" xml:space="preserve">
          <source>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f5cb90f300e2c9d89b461fd1882c4957ea2a20" translate="yes" xml:space="preserve">
          <source>Learning JavaScript and TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">Aprender a usar &lt;code&gt;this&lt;/code&gt; en JavaScript es una especie de rito de iniciaci&amp;oacute;n. Desde mecanografiado es un superconjunto de JavaScript, los desarrolladores de transcripci&amp;oacute;n tambi&amp;eacute;n necesitan aprender c&amp;oacute;mo utilizar &lt;code&gt;this&lt;/code&gt; y c&amp;oacute;mo detectar cuando no est&amp;aacute; siendo utilizado correctamente. Afortunadamente, TypeScript le permite detectar usos incorrectos de &lt;code&gt;this&lt;/code&gt; con un par de t&amp;eacute;cnicas. Sin embargo, si necesita aprender c&amp;oacute;mo funciona &lt;code&gt;this&lt;/code&gt; en JavaScript, primero lea &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Comprendiendo la invocaci&amp;oacute;n de funciones de JavaScript de&lt;/a&gt; Yehuda Katz y &quot;esto&quot; . El art&amp;iacute;culo de Yehuda explica muy bien el funcionamiento interno de &lt;code&gt;this&lt;/code&gt; , por lo que solo cubriremos lo b&amp;aacute;sico aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">Agreguemos un par de interfaces a nuestro ejemplo anterior, &lt;code&gt;Card&lt;/code&gt; y &lt;code&gt;Deck&lt;/code&gt; , para que los tipos sean m&amp;aacute;s claros y f&amp;aacute;ciles de reutilizar:</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">Agreguemos tipos a nuestros ejemplos simples de antes:</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">Convirtamos una clase simple para usar &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;set&lt;/code&gt; . Primero, comencemos con un ejemplo sin getters ni setters.</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">Desarrollemos m&amp;aacute;s nuestra muestra. Aqu&amp;iacute; usamos una interfaz que describe objetos que tienen un campo de nombre y apellido. En TypeScript, dos tipos son compatibles si su estructura interna es compatible. Esto nos permite implementar una interfaz simplemente teniendo la forma que la interfaz requiere, sin una cl&amp;aacute;usula de &lt;code&gt;implements&lt;/code&gt; expl&amp;iacute;cita .</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">Comencemos construyendo una aplicaci&amp;oacute;n web simple con TypeScript.</target>
        </trans-unit>
        <trans-unit id="31f50512e5bac716ad2127f4d6b19108bf103d8e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for a version of &lt;code&gt;padLeft&lt;/code&gt; which uses union types. We could write it with type predicates as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">Regresemos y escribamos el c&amp;oacute;digo para la versi&amp;oacute;n de &lt;code&gt;padLeft&lt;/code&gt; que usa tipos de uni&amp;oacute;n. Podr&amp;iacute;amos escribirlo con predicados de tipo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">Veamos un programa bastante normal y veamos c&amp;oacute;mo las referencias de proyectos pueden ayudarnos a organizarlo mejor. Imagine que tiene un proyecto con dos m&amp;oacute;dulos, &lt;code&gt;converter&lt;/code&gt; y &lt;code&gt;units&lt;/code&gt; , y un archivo de prueba correspondiente para cada uno:</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">Veamos un ejemplo para ver mejor c&amp;oacute;mo se desarrolla esto en la pr&amp;aacute;ctica:</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">Veamos un ejemplo:</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">Modifiquemos un poco el ejemplo para mostrar esta diferencia:</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">Ahora agreguemos React y React-DOM, junto con sus archivos de declaraci&amp;oacute;n, como dependencias a su archivo &lt;code&gt;package.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">Veamos ahora un ejemplo m&amp;aacute;s complejo.</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">Digamos que hemos tenido la intenci&amp;oacute;n de que esta funci&amp;oacute;n funcione en matrices de &lt;code&gt;T&lt;/code&gt; en lugar de &lt;code&gt;T&lt;/code&gt; directamente. Como estamos trabajando con matrices, el miembro &lt;code&gt;.length&lt;/code&gt; deber&amp;iacute;a estar disponible. Podemos describir esto como crear&amp;iacute;amos matrices de otros tipos:</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">Digamos que tenemos una aplicaci&amp;oacute;n de muestra que usa el m&amp;oacute;dulo &lt;code&gt;typescript&lt;/code&gt; . &lt;code&gt;app.ts&lt;/code&gt; tiene una importaci&amp;oacute;n como &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">Digamos que escribimos un archivo de m&amp;oacute;dulo &lt;code&gt;foo.d.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">Vamos a andamiar esto:</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">Veamos c&amp;oacute;mo se puede usar esto.</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">Comencemos con un nuevo directorio. Lo &lt;code&gt;proj&lt;/code&gt; por ahora, pero puede cambiarlo a lo que quiera.</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">Comencemos con el programa que usaremos como ejemplo en esta p&amp;aacute;gina. Hemos escrito un peque&amp;ntilde;o conjunto de validadores de cadenas simplistas, como podr&amp;iacute;a escribir para verificar la entrada de un usuario en un formulario en una p&amp;aacute;gina web o verificar el formato de un archivo de datos proporcionado externamente.</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">Echemos un vistazo a un ejemplo simple basado en clases:</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">Echemos un vistazo a un ejemplo:</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">Echemos un vistazo al tipo mapeado m&amp;aacute;s simple y sus partes:</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">Tomemos un minuto para considerar lo que eso significa. &lt;code&gt;setTimeout&lt;/code&gt; ejecutar&amp;aacute; una funci&amp;oacute;n despu&amp;eacute;s de algunos milisegundos, &lt;em&gt;pero solo&lt;/em&gt; despu&amp;eacute;s de que el bucle &lt;code&gt;for&lt;/code&gt; haya dejado de ejecutarse; Cuando el bucle &lt;code&gt;for&lt;/code&gt; deja de ejecutarse, el valor de &lt;code&gt;i&lt;/code&gt; es &lt;code&gt;10&lt;/code&gt; . As&amp;iacute; que cada vez que se llame a la funci&amp;oacute;n dada, imprimir&amp;aacute; &lt;code&gt;10&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">Tomemos nuestra funci&amp;oacute;n de &lt;code&gt;identity&lt;/code&gt; de antes:</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">Escribamos un programa de Hello World. En &lt;code&gt;src&lt;/code&gt; , cree el archivo &lt;code&gt;main.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">Escribamos nuestro primer archivo TypeScript usando React. Primero, cree un archivo llamado &lt;code&gt;Hello.tsx&lt;/code&gt; en &lt;code&gt;src/components&lt;/code&gt; y escriba lo siguiente:</target>
        </trans-unit>
        <trans-unit id="aae2739f68fb37ce086c5c2093758c62b36667b3" translate="yes" xml:space="preserve">
          <source>Lets explore a TypeScript script that adds a &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element to the &lt;code&gt;#app&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7305992657ab0909fb4eb83c394c6114c9f6b07" translate="yes" xml:space="preserve">
          <source>Lets you set a base directory to resolve non-absolute module names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="0282b6f4a590ade8d83152438864b31e1ed6a0e7" translate="yes" xml:space="preserve">
          <source>Lib - &lt;code&gt;lib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">Las bibliotecas tambi&amp;eacute;n pueden usar &lt;code&gt;this&lt;/code&gt; par&amp;aacute;metros para declarar c&amp;oacute;mo se invocar&amp;aacute;n las devoluciones de llamada.</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">Estructuras de la biblioteca</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">Estructuras de la biblioteca:Consumir Dependencias</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">Estructuras de la biblioteca:Dependencias de las bibliotecas mundiales</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">Estructuras de la biblioteca:Dependencias de los módulos</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">Estructuras de la biblioteca:Dependencias de las bibliotecas de UMD</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">Estructuras de la biblioteca:Bibliotecas mundiales</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">Estructuras de la biblioteca:Plugin Global</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">Estructuras de la biblioteca:Módulos modificadores globales</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">Estructuras de la biblioteca:Identificación de tipos de bibliotecas</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">Estructuras de la biblioteca:Estructura de archivos de la biblioteca</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">Estructuras de la biblioteca:Bibliotecas modulares</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">Estructuras de la biblioteca:Plugin de módulo o plugin UMD</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">Estructuras de la biblioteca:Prevención de conflictos de nombres</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">Estructuras de la biblioteca:El impacto del ES6 en los enchufes de los módulos</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">Estructuras de la biblioteca:UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">La disposición de los archivos de la biblioteca</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Licenciado bajo la licencia de Apache,versión 2.0.</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">Al igual que la desestructuración de la matriz,puedes tener una asignación sin declaración:</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">Al igual que las clases,las interfaces pueden extenderse entre sí.Esto permite copiar los miembros de una interfaz en otra,lo que le da más flexibilidad en la forma de separar las interfaces en componentes reutilizables.</target>
        </trans-unit>
        <trans-unit id="7d787f38e64660d964087ea17b902351795b7ef8" translate="yes" xml:space="preserve">
          <source>Like most C-descended languages, TypeScript requires declaration of type parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">Como otros comportamientos especiales de comprobación de JS,este comportamiento puede ser cambiado especificando un tipo de JSDoc para la variable.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">Como mencionamos, no es inesperado recibir mensajes de error despu&amp;eacute;s de la conversi&amp;oacute;n. Lo importante es revisarlos uno por uno y decidir c&amp;oacute;mo lidiar con los errores. A menudo, estos ser&amp;aacute;n errores leg&amp;iacute;timos, pero a veces tendr&amp;aacute;s que explicar un poco mejor lo que intentas hacer con TypeScript.</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">De la misma manera,para el tipo de retorno de una función:</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">Del mismo modo,el hecho de que haya varios candidatos para el mismo tipo de variable en posiciones contravariantes hace que se infiera un tipo de intersección:</target>
        </trans-unit>
        <trans-unit id="17904ff532be036b7cb87941e7bed2e100c68152" translate="yes" xml:space="preserve">
          <source>Linter Checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885980150a8aa23ee2581fde57cdd77e524c220a" translate="yes" xml:space="preserve">
          <source>List Emitted Files - &lt;code&gt;listEmittedFiles&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef72f198033a01dd1518070e6ebb3e26bd88d5da" translate="yes" xml:space="preserve">
          <source>List Files - &lt;code&gt;listFiles&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">Lista de</target>
        </trans-unit>
        <trans-unit id="0a9f639b79fa294ae337e3e6ef448a4796481e4d" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">Lista de carpetas para incluir definiciones de tipos. Consulte &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots y &amp;ndash;types&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="dc93386b00a8c2f17516b547e96b3b9822dd074a" translate="yes" xml:space="preserve">
          <source>List of language service plugins to run inside the editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">Lista de archivos de la biblioteca que se incluirán en la compilación.</target>
        </trans-unit>
        <trans-unit id="9230df08537df807ad2117d7fc0d39c84158a446" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">Lista de nombres de definiciones de tipo para incluir. Consulte &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots y &amp;ndash;types&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Lista de entradas de asignaci&amp;oacute;n de ruta de nombres de los m&amp;oacute;dulos a ubicaciones relativas a la &lt;code&gt;baseUrl&lt;/code&gt; . Consulte la &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;documentaci&amp;oacute;n de Resoluci&amp;oacute;n del m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="de64a9e9a2fea78c8d6ba63c5e5b1387423f2076" translate="yes" xml:space="preserve">
          <source>Literal Narrowing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">El ensanchamiento de tipo literal se puede controlar mediante anotaciones de tipo expl&amp;iacute;citas. Espec&amp;iacute;ficamente, cuando se infiere una expresi&amp;oacute;n de un tipo literal para una ubicaci&amp;oacute;n const sin una anotaci&amp;oacute;n de tipo, esa variable &lt;code&gt;const&lt;/code&gt; obtiene un tipo de literal ampliado inferido. Pero cuando una ubicaci&amp;oacute;n &lt;code&gt;const&lt;/code&gt; tiene una anotaci&amp;oacute;n de tipo literal expl&amp;iacute;cita, la variable &lt;code&gt;const&lt;/code&gt; obtiene un tipo literal que no se ensancha.</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">Carga de tipos de paquetes de npm</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">Las declaraciones de tipo local e importado ahora entran en conflicto</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">Las declaraciones de clase local, interfaz, enumeraci&amp;oacute;n y alias de tipo ahora pueden aparecer dentro de las declaraciones de funci&amp;oacute;n. Los tipos locales tienen un &amp;aacute;mbito de bloque, similar a las variables declaradas con &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">Declaraciones de tipo local</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">Los tipos locales pueden hacer referencia a parámetros de tipos de cierre y las clases e interfaces locales pueden ser en sí mismas genéricas.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">Diagnósticos localizados en la línea de mando</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">Los espacios de nombres JSX con alcance local</target>
        </trans-unit>
        <trans-unit id="f24374818cfbd2c002fceb8b97034ee88dd96257" translate="yes" xml:space="preserve">
          <source>Location of default .d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">Busca en la primera carpeta de localhost,luego scripts/app.ts</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">Busque en su &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; . Las asignaciones autorizadas entre las etiquetas XML de MSBuild y las opciones del compilador &lt;code&gt;tsc&lt;/code&gt; residen all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">MSBuild Nombre de la propiedad</target>
        </trans-unit>
        <trans-unit id="6460830fa61cf6da70e79284adc64a8688cb9f06" translate="yes" xml:space="preserve">
          <source>MSG</source>
          <target state="translated">MSG</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">Aseg&amp;uacute;rese de que los m&amp;oacute;dulos funcionen ejecutando &lt;code&gt;gulp&lt;/code&gt; y luego probando en Node:</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">Aseg&amp;uacute;rese de volver a visitar la secci&amp;oacute;n &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consumir dependencias&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">Muchos desarrolladores de JavaScript est&amp;aacute;n &amp;iacute;ntimamente familiarizados con este comportamiento, pero si te sorprende, ciertamente no est&amp;aacute;s solo. La mayor&amp;iacute;a de la gente espera que la salida sea</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">Muchos paquetes admiten la divisi&amp;oacute;n autom&amp;aacute;tica de paquetes de salida en funci&amp;oacute;n de estas expresiones de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n , as&amp;iacute; que considere usar esta nueva funci&amp;oacute;n con el &lt;code&gt;esnext&lt;/code&gt; m&amp;oacute;dulo esnext .</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">Muchos errores comunes en los archivos de declaraci&amp;oacute;n se pueden evitar f&amp;aacute;cilmente. La secci&amp;oacute;n &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Qu&amp;eacute; hacer y qu&amp;eacute; no hacer&lt;/a&gt; identifica errores comunes, describe c&amp;oacute;mo detectarlos y c&amp;oacute;mo solucionarlos. Todos deben leer esta secci&amp;oacute;n para evitar errores comunes.</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Muchas bibliotecas populares de Node.js est&amp;aacute;n en la familia de m&amp;oacute;dulos, como &lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">Muchas bibliotecas populares,como la Express,se exponen como una función llamable cuando se importan.Por ejemplo,el uso típico de Express se ve así:</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">Muchas veces, nos enfrentamos a escribir un archivo de declaraci&amp;oacute;n cuando solo tenemos ejemplos de la biblioteca subyacente para guiarnos. La secci&amp;oacute;n &lt;a href=&quot;by-example&quot;&gt;Por ejemplo&lt;/a&gt; muestra muchos patrones de API comunes y c&amp;oacute;mo escribir declaraciones para cada uno de ellos. Esta gu&amp;iacute;a est&amp;aacute; dirigida a los principiantes de TypeScript que a&amp;uacute;n no est&amp;eacute;n familiarizados con todas las construcciones de lenguaje en TypeScript.</target>
        </trans-unit>
        <trans-unit id="e04dbd57e91d78d0c5bec01a4fe02f73a4ba1540" translate="yes" xml:space="preserve">
          <source>Map Root - &lt;code&gt;mapRoot&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">Tipos mapeados</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">Tipos mapeados</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">Los tipos asignados se generan tomando una uni&amp;oacute;n de tipos literales y calculando un conjunto de propiedades para un nuevo tipo de objeto. Son como &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;listas por comprensi&amp;oacute;n en Python&lt;/a&gt; , pero en lugar de producir nuevos elementos en una lista, producen nuevas propiedades en un tipo.</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">Tipos mapeados en tuplas y matrices</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">Los tipos asignados admiten la adici&amp;oacute;n de un &lt;code&gt;readonly&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; modificador a una propiedad asignada, pero no proporcionaban soporte para la capacidad de &lt;em&gt;eliminar&lt;/em&gt; modificadores. Esto es importante en los &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;tipos mapeados homom&amp;oacute;rficos&lt;/em&gt;&lt;/a&gt; que, por defecto, conservan los modificadores del tipo subyacente.</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">Comportamiento de la pareja</target>
        </trans-unit>
        <trans-unit id="e877b2873e30b35f125ca0ad5fb9dc583519caa0" translate="yes" xml:space="preserve">
          <source>Max Node Module JS Depth - &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6746fd6ef4bdedacc9e255f7e5c953f3f9081507" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some experienced JavaScript developers, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">Tal vez fue f&amp;aacute;cil de detectar para algunos, pero el bucle &lt;code&gt;for&lt;/code&gt; interno sobrescribir&amp;aacute; accidentalmente la variable &lt;code&gt;i&lt;/code&gt; porque &lt;code&gt;i&lt;/code&gt; se refiere a la misma variable de &amp;aacute;mbito de funci&amp;oacute;n. Como ya saben los desarrolladores experimentados, tipos similares de errores se escabullen en las revisiones de c&amp;oacute;digo y pueden ser una fuente inagotable de frustraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">Interfaces de fusión</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">Fusión de espacios de nombres</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">Fusión de espacios de nombres con clases</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">Fusionar los espacios de nombres con clases,funciones y sumas</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">Fusión de la clase de ambiente y la declaración de la interfaz</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">Método Decoradores</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">Los m&amp;eacute;todos dentro de una clase abstracta que est&amp;aacute;n marcados como abstractos no contienen una implementaci&amp;oacute;n y deben implementarse en clases derivadas. Los m&amp;eacute;todos abstractos comparten una sintaxis similar a los m&amp;eacute;todos de interfaz. Ambos definen la firma de un m&amp;eacute;todo sin incluir un cuerpo de m&amp;eacute;todo. Sin embargo, los m&amp;eacute;todos abstractos deben incluir la palabra clave &lt;code&gt;abstract&lt;/code&gt; a y, opcionalmente, pueden incluir modificadores de acceso.</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">Migrando desde JavaScript</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">Migrando desde JavaScript:Beneficios tempranos</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">Migrando desde JavaScript:Obteniendo controles más estrictos</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">Migrando desde JavaScript:Gulp</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">Migrando desde JavaScript:Integración con herramientas de construcción</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">Migrando desde JavaScript:Migrando a los archivos de TypeScript</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">Migrando desde JavaScript:Establecimiento de sus directorios</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">Migrando desde JavaScript:Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">Migrando desde JavaScript:Eliminando los errores</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">Migrando desde JavaScript:Escribiendo un archivo de configuración</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">Proyecto mínimo</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">Las clases de mezcla pueden restringir los tipos de clases en las que pueden mezclarse especificando un tipo de retorno de firma de construcci&amp;oacute;n en la restricci&amp;oacute;n para el par&amp;aacute;metro de tipo. Por ejemplo, las siguientes &lt;code&gt;WithLocation&lt;/code&gt; funci&amp;oacute;n implementa una f&amp;aacute;brica de subclase que a&amp;ntilde;ade un &lt;code&gt;getLocation&lt;/code&gt; m&amp;eacute;todo para cualquier clase que satisface el &lt;code&gt;Point&lt;/code&gt; de interfaz (es decir, que tiene &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; propiedades de tipo &lt;code&gt;number&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">Muestra de la mezcla</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="bf3760256feac6cc46ec45ef674425285cde51d6" translate="yes" xml:space="preserve">
          <source>Modern browsers support all ES6 features, so &lt;code&gt;ES6&lt;/code&gt; is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b8e599868465369a62573e28c7d5b2c17c8067" translate="yes" xml:space="preserve">
          <source>Modify the html by removing one of the &lt;code&gt;p&lt;/code&gt; tags, but keep the text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">Bibliotecas modulares</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">Las bibliotecas modulares suelen tener al menos algunos de los siguientes elementos:</target>
        </trans-unit>
        <trans-unit id="680e2cdf724785f8d2fb8c99fb4ac60b980c1748" translate="yes" xml:space="preserve">
          <source>Module - &lt;code&gt;module&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">Módulo de aumento</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">Resolución del módulo</target>
        </trans-unit>
        <trans-unit id="3f1f355f5558be61bf0295855b4e35d7e9e193c7" translate="yes" xml:space="preserve">
          <source>Module Resolution - &lt;code&gt;moduleResolution&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">Módulo Estrategias de resolución</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">Los identificadores de m&amp;oacute;dulo permiten la extensi&amp;oacute;n &lt;code&gt;.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">Las importaciones de módulos se resuelven de forma diferente en función de si la referencia del módulo es relativa o no.</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">Los cargadores de m&amp;oacute;dulos como SystemJS envuelven los m&amp;oacute;dulos CommonJS y los exponen como una importaci&amp;oacute;n ES6 &lt;code&gt;default&lt;/code&gt; . Esto hace que sea imposible compartir los archivos de definici&amp;oacute;n entre la implementaci&amp;oacute;n de SystemJS y CommonJS del m&amp;oacute;dulo, ya que la forma del m&amp;oacute;dulo se ve diferente seg&amp;uacute;n el cargador.</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">Mejoras en la resolución del módulo:BaseUrl,Path mapping,rootDirs y tracing</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">El tipo de resoluci&amp;oacute;n del m&amp;oacute;dulo no est&amp;aacute; especificado, usando &lt;strong&gt;'NodeJs'&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1df43e7e9f83fc7173a7334ad19fcc3cc8e8bc" translate="yes" xml:space="preserve">
          <source>Module: Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f261737e777673d28880af66138654486e39e3bc" translate="yes" xml:space="preserve">
          <source>Module: Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2f8f319a1e5fc06c98c20b985a907aed2cafd5" translate="yes" xml:space="preserve">
          <source>Module: Plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="48e09f525757a351dfe7b299e6750c6d122d7d38" translate="yes" xml:space="preserve">
          <source>Modules .d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d8406349015ac16eed554df9f310ef31446573" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">Los módulos también dependen de un cargador de módulos (como CommonJs/Require.js).Para una pequeña aplicación JS esto podría no ser óptimo,pero para aplicaciones más grandes,el costo viene con beneficios de modularidad y mantenimiento a largo plazo.Los módulos permiten una mejor reutilización del código,un aislamiento más fuerte y un mejor soporte de herramientas para la agrupación.</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">Los módulos son declarativos;las relaciones entre los módulos se especifican en términos de importaciones y exportaciones a nivel de archivo.</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">Los m&amp;oacute;dulos se ejecutan dentro de su propio &amp;aacute;mbito, no en el &amp;aacute;mbito global; esto significa que las variables, funciones, clases, etc. declaradas en un m&amp;oacute;dulo no son visibles fuera del m&amp;oacute;dulo a menos que se exporten expl&amp;iacute;citamente utilizando uno de los &lt;a href=&quot;#export&quot;&gt;formularios de &lt;/a&gt; &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n . Por el contrario, para consumir una variable, funci&amp;oacute;n, clase, interfaz, etc. exportada desde un m&amp;oacute;dulo diferente, debe importarse utilizando uno de los &lt;a href=&quot;#import&quot;&gt;formularios de &lt;/a&gt; &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">Los m&amp;oacute;dulos ahora se emiten con un &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; pr&amp;oacute;logo</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">Los módulos se analizan automáticamente en modo estricto.La nueva bandera se recomienda para el código de no-módulos.</target>
        </trans-unit>
        <trans-unit id="eb465684cf64b809ea4e18738ce52c8fd9a32f30" translate="yes" xml:space="preserve">
          <source>Modules can contain both code and declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">Los m&amp;oacute;dulos pueden importar tipos declarados en otros m&amp;oacute;dulos. Pero los scripts globales que no son m&amp;oacute;dulos no pueden acceder a tipos declarados en m&amp;oacute;dulos. Ingrese &lt;code&gt;import&lt;/code&gt; tipos de importaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">Los m&amp;oacute;dulos se importan entre s&amp;iacute; mediante un cargador de m&amp;oacute;dulos. En tiempo de ejecuci&amp;oacute;n, el cargador de m&amp;oacute;dulos es responsable de localizar y ejecutar todas las dependencias de un m&amp;oacute;dulo antes de ejecutarlo. Los cargadores de m&amp;oacute;dulos m&amp;aacute;s conocidos que se utilizan en JavaScript son el cargador de Node.js para m&amp;oacute;dulos &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; y el cargador &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; para m&amp;oacute;dulos &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; en aplicaciones web.</target>
        </trans-unit>
        <trans-unit id="252a052c9420d6ecb6b140e66b5a6e193c6c9859" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">Los m&amp;oacute;dulos siempre se analizaron en modo estricto seg&amp;uacute;n ES6, pero para los destinos que no son ES6, esto no se respet&amp;oacute; en el c&amp;oacute;digo generado. A partir de TypeScript 1.8, los m&amp;oacute;dulos emitidos siempre est&amp;aacute;n en modo estricto. Esto no deber&amp;iacute;a tener ning&amp;uacute;n cambio visible en la mayor&amp;iacute;a del c&amp;oacute;digo, ya que TS considera los errores de modo m&amp;aacute;s estrictos como errores en tiempo de compilaci&amp;oacute;n, pero significa que algunas cosas que sol&amp;iacute;an fallar silenciosamente en tiempo de ejecuci&amp;oacute;n en su c&amp;oacute;digo TS, como asignar a &lt;code&gt;NaN&lt;/code&gt; , ahora lo har&amp;aacute;n en voz alta. fallar. Puede consultar el &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;art&amp;iacute;culo de MDN&lt;/a&gt; sobre el modo estricto para obtener una lista detallada de las diferencias entre el modo estricto y el modo no estricto.</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">Una propagación de la matriz más precisa</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s detalles sobre c&amp;oacute;mo definir las opciones del compilador de MSBuild: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Configuraci&amp;oacute;n de las opciones del compilador en proyectos de MSBuild&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">Se pueden encontrar m&amp;aacute;s detalles en el &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;cuadro de &lt;/a&gt;&lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;di&amp;aacute;logo Administrador de paquetes&lt;/a&gt; y el uso de compilaciones nocturnas con NuGet</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s detalles: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s detalles: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s detalles: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s detalles: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s detalles: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">Más ejemplos</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">M&amp;aacute;s informaci&amp;oacute;n est&amp;aacute; disponible en la &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;documentaci&amp;oacute;n de VSCode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">Hay m&amp;aacute;s informaci&amp;oacute;n disponible en la &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;documentaci&amp;oacute;n de instalaci&amp;oacute;n del complemento TypeScript para Sublime Text&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">M&amp;aacute;s detalles, puede &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;leer sobre la propuesta&lt;/a&gt; y &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;ver la solicitud de extracci&amp;oacute;n original&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="752dbfdfe70e9a653727ad54bd026e4e1adbb672" translate="yes" xml:space="preserve">
          <source>More of a gotcha than a constraint. The class expression pattern creates singletons, so they can&amp;rsquo;t be mapped at the type system to support different variable types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87404c3db1a136e631f5512bc31b4108095e74c7" translate="yes" xml:space="preserve">
          <source>More on Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">Más claramente,ese fragmento de código es lo mismo que escribir lo siguiente.</target>
        </trans-unit>
        <trans-unit id="e65b8445ad886f1be93458429fb5dd37c90a50bb" translate="yes" xml:space="preserve">
          <source>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The &amp;ldquo;run anywhere&amp;rdquo; nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use &lt;em&gt;only&lt;/em&gt; JavaScript to program their entire stack!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">Las bibliotecas m&amp;aacute;s populares ahora est&amp;aacute;n disponibles como paquetes UMD. Los ejemplos incluyen &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; , &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; , &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt; y muchos m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="94b01864f5579af47acd49be012292e69db8aa02" translate="yes" xml:space="preserve">
          <source>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation &amp;mdash; before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">Moverse a los archivos de escritura</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">La mayor parte del tiempo cuando hablamos de &quot;tipos singleton&quot;, nos referimos tanto a tipos de miembros enum como a tipos literales num&amp;eacute;ricos / de cadena, aunque muchos usuarios usar&amp;aacute;n &quot;tipos singleton&quot; y &quot;tipos literales&quot; indistintamente.</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">Espacios de nombres de archivos múltiples</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">Se pueden aplicar varios decoradores a una declaración,como en los siguientes ejemplos:</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">Múltiples campos</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">Varios archivos que tienen el mismo &lt;code&gt;export namespace Foo {&lt;/code&gt; en el nivel superior (&amp;iexcl;no crea que se van a combinar en un solo &lt;code&gt;Foo&lt;/code&gt; !)</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">Múltiples inferencias de tipo literal de objeto para el mismo parámetro de tipo se colapsan de forma similar en un único tipo de unión normalizada:</target>
        </trans-unit>
        <trans-unit id="aede1800680b8eed7745689bb8cd192726458952" translate="yes" xml:space="preserve">
          <source>Mutually exclusive with &lt;a href=&quot;#sourceMap&quot;&gt;&lt;code&gt;sourceMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">MyTestPage.html (extracto)</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">NOTA Un &lt;em&gt;descriptor de propiedad&lt;/em&gt; no se proporciona como argumento para un decorador de propiedad debido a c&amp;oacute;mo se inicializan los decoradores de propiedad en TypeScript. Esto se debe a que actualmente no existe ning&amp;uacute;n mecanismo para describir una propiedad de instancia al definir miembros de un prototipo, y no hay forma de observar o modificar el inicializador de una propiedad. El valor de retorno tambi&amp;eacute;n se ignora. Como tal, un decorador de propiedades solo se puede usar para observar que se ha declarado una propiedad con un nombre espec&amp;iacute;fico para una clase.</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">NOTA Un decorador de parámetros sólo puede ser usado para observar que un parámetro ha sido declarado en un método.</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">NOTA Los metadatos del decorador son una característica experimental y pueden introducir cambios de última hora en futuras versiones.</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">NOTA Los decoradores son una característica experimental que puede cambiar en futuras versiones.</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">NOTA Si elige devolver una nueva funci&amp;oacute;n de constructor, debe tener cuidado de mantener el prototipo original. La l&amp;oacute;gica que aplica decoradores en tiempo de ejecuci&amp;oacute;n &lt;strong&gt;no&lt;/strong&gt; har&amp;aacute; esto por usted.</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">NOTA El &lt;em&gt;descriptor de propiedades&lt;/em&gt; no estar&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; si el destino de su script es menor que &lt;code&gt;ES5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">NOTA El valor de retorno se ignora si el destino de su secuencia de comandos es menor que &lt;code&gt;ES5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">NOTA Este ejemplo requiere la biblioteca &lt;code&gt;reflect-metadata&lt;/code&gt; . Consulte &lt;a href=&quot;#metadata&quot;&gt;Metadatos&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la biblioteca &lt;code&gt;reflect-metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">NOTA TypeScript no permite decorar tanto el &lt;code&gt;get&lt;/code&gt; acceso get como &lt;code&gt;set&lt;/code&gt; para un solo miembro. En cambio, todos los decoradores del miembro deben aplicarse al primer descriptor de acceso especificado en el orden del documento. Esto se debe a que los decoradores se aplican a un &lt;em&gt;descriptor de propiedad&lt;/em&gt; , que combina el &lt;em&gt;descriptor de&lt;/em&gt; acceso &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;set&lt;/code&gt; , no cada declaraci&amp;oacute;n por separado.</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">NOTA Puede ver un ejemplo m&amp;aacute;s detallado de una f&amp;aacute;brica de decoradores en &lt;a href=&quot;#method-decorators&quot;&gt;Decoradores de m&amp;eacute;todos&lt;/a&gt; , a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">NOTA Puede ver un ejemplo m&amp;aacute;s detallado de un decorador en &lt;a href=&quot;#class-decorators&quot;&gt;Decoradores de clase&lt;/a&gt; , a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">Nombre y ubicación de la importación</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">Nombra tus archivos con una extensi&amp;oacute;n &lt;code&gt;.tsx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">Nombra tu proyecto y soluci&amp;oacute;n. Despu&amp;eacute;s de seleccionar el bot&amp;oacute;n &lt;em&gt;Crear&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b69558e9b061498c09673bf8df0b367bf33694fd" translate="yes" xml:space="preserve">
          <source>Named types just give a name to a type; for assignability purposes there&amp;rsquo;s no difference between the type alias &lt;code&gt;One&lt;/code&gt; and the interface type &lt;code&gt;Two&lt;/code&gt; below. They both have a property &lt;code&gt;p: string&lt;/code&gt;. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">Validadores del ritmo de los nombres</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">M&amp;oacute;dulos y espacios de nombres</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">Espacios de nombres y módulos</target>
        </trans-unit>
        <trans-unit id="0b0a6e9c59b25d6d7bd54387d9652cfedae85b49" translate="yes" xml:space="preserve">
          <source>Namespaces are a TypeScript-specific way to organize code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">Los espacios de nombres son lo suficientemente flexibles como para fusionarse también con otros tipos de declaraciones.Para ello,la declaración del espacio de nombres debe seguir a la declaración con la que se fusionará.La declaración resultante tiene propiedades de ambos tipos de declaración.TypeScript utiliza esta capacidad para modelar algunos de los patrones en JavaScript así como en otros lenguajes de programación.</target>
        </trans-unit>
        <trans-unit id="3952a1181de40dbd2a06ce80db7e580384e74ec9" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;mdash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">Los espacios de nombres son importantes para evitar colisiones de nombres en el &amp;aacute;mbito global. Por ejemplo, puede tener &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; y &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; , dos tipos con el mismo nombre, pero con un espacio de nombres diferente. Sin embargo, esto no es un problema con los m&amp;oacute;dulos. Dentro de un m&amp;oacute;dulo, no hay ninguna raz&amp;oacute;n plausible para tener dos objetos con el mismo nombre. Desde el lado del consumo, el consumidor de cualquier m&amp;oacute;dulo puede elegir el nombre que usar&amp;aacute; para referirse al m&amp;oacute;dulo, por lo que los conflictos de nombres accidentales son imposibles.</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">Los espacios de nombres se denominan simplemente objetos JavaScript en el espacio de nombres global. Esto hace que los espacios de nombres sean una construcci&amp;oacute;n muy simple de usar. Pueden abarcar varios archivos y se pueden concatenar usando &lt;code&gt;--outFile&lt;/code&gt; . Los espacios de nombres pueden ser una buena forma de estructurar su c&amp;oacute;digo en una aplicaci&amp;oacute;n web, con todas las dependencias incluidas como etiquetas &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; en su p&amp;aacute;gina HTML.</target>
        </trans-unit>
        <trans-unit id="558fb2926bc952cf7a6b78aa83d90ef0f04f4eb8" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abfc41609e10694546f23e6fe8ec31d3b441731d" translate="yes" xml:space="preserve">
          <source>Namespaces in Module Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">Módulos nativos de ECMAScript 2015 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">Espacios de nombres innecesarios</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">Ni los aumentos de m&amp;oacute;dulo ni los aumentos globales pueden agregar nuevos elementos al alcance de nivel superior; solo pueden &quot;parchear&quot; declaraciones existentes.</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">Declaraciones anidadas y fusionadas</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">El anidamiento funciona a cualquier nivel ahora,y se fusiona correctamente a través de los archivos.Antes no era así.</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">Nuevo - siempre &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">Nuevo &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">Nuevo &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">Nuevo &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">Nuevo &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">Nuevo &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">Nuevo &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">Nueva opci&amp;oacute;n de maestro &lt;code&gt;--strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">Nueva extensi&amp;oacute;n de archivo &lt;code&gt;.tsx&lt;/code&gt; y &lt;code&gt;as&lt;/code&gt; operador</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">Nuevo &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">Nuevo tipo superior &lt;code&gt;unknown&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3249cca6099abd4cca11ff2add4d8cce20a25fa1" translate="yes" xml:space="preserve">
          <source>New Line - &lt;code&gt;newLine&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">Nueva zona de juegos de TypeScript</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">Las nuevas comprobaciones agregadas a TypeScript a menudo est&amp;aacute;n desactivadas de forma predeterminada para evitar romper los proyectos existentes. Si bien evitar la rotura es algo bueno, esta estrategia tiene el inconveniente de hacer que sea cada vez m&amp;aacute;s complejo elegir el nivel m&amp;aacute;s alto de seguridad de tipos, y hacerlo requiere una acci&amp;oacute;n expl&amp;iacute;cita de aceptaci&amp;oacute;n en cada versi&amp;oacute;n de TypeScript. Con la opci&amp;oacute;n &lt;code&gt;--strict&lt;/code&gt; es posible elegir la m&amp;aacute;xima seguridad de tipos con el entendimiento de que las versiones m&amp;aacute;s recientes del compilador pueden informar errores adicionales a medida que se agregan caracter&amp;iacute;sticas mejoradas de verificaci&amp;oacute;n de tipos.</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">A continuación tenemos un ejemplo de cómo anular el constructor.</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, agregaremos una nueva carpeta y la llamaremos &lt;code&gt;scripts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, para cada variable de tipo introducida por una declaraci&amp;oacute;n &lt;code&gt;infer&lt;/code&gt; ir (m&amp;aacute;s tarde) dentro de &lt;code&gt;U&lt;/code&gt; , recopile un conjunto de tipos candidatos infiriendo de &lt;code&gt;T&lt;/code&gt; a &lt;code&gt;U&lt;/code&gt; (utilizando el mismo algoritmo de inferencia que la inferencia de tipos para funciones gen&amp;eacute;ricas). Para una variable de tipo de &lt;code&gt;infer&lt;/code&gt; ir dada &lt;code&gt;V&lt;/code&gt; , si alg&amp;uacute;n candidato fue inferido de posiciones covariantes, el tipo inferido para &lt;code&gt;V&lt;/code&gt; es una uni&amp;oacute;n de esos candidatos. De lo contrario, si alg&amp;uacute;n candidato se infiere de posiciones contrarias, el tipo inferido para &lt;code&gt;V&lt;/code&gt; es una intersecci&amp;oacute;n de esos candidatos. De lo contrario, el tipo inferido para &lt;code&gt;V&lt;/code&gt; &lt;code&gt;never&lt;/code&gt; es .</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, si su versi&amp;oacute;n de Visual Studio a&amp;uacute;n no tiene la &amp;uacute;ltima versi&amp;oacute;n de TypeScript, puede &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;instalarla&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">A continuaci&amp;oacute;n, &lt;code&gt;index.tsx&lt;/code&gt; un index.tsx en &lt;code&gt;src&lt;/code&gt; con la siguiente fuente:</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">A continuaci&amp;oacute;n, usamos la clase directamente. Aqu&amp;iacute; creamos una nueva variable llamada &lt;code&gt;greeterMaker&lt;/code&gt; . Esta variable contendr&amp;aacute; la clase en s&amp;iacute;, o dicho de otra manera su funci&amp;oacute;n constructora. Aqu&amp;iacute; usamos &lt;code&gt;typeof Greeter&lt;/code&gt; , que es &quot;dame el tipo de la clase &lt;code&gt;Greeter&lt;/code&gt; en s&amp;iacute;&quot; en lugar del tipo de instancia. O, m&amp;aacute;s precisamente, &quot;dame el tipo de s&amp;iacute;mbolo llamado &lt;code&gt;Greeter&lt;/code&gt; &quot;, que es el tipo de funci&amp;oacute;n constructora. Este tipo contendr&amp;aacute; todos los miembros est&amp;aacute;ticos de Greeter junto con el constructor que crea instancias de la clase &lt;code&gt;Greeter&lt;/code&gt; . Mostramos esto usando &lt;code&gt;new&lt;/code&gt; en &lt;code&gt;greeterMaker&lt;/code&gt; , creando nuevas instancias de &lt;code&gt;Greeter&lt;/code&gt; e invoc&amp;aacute;ndolos como antes.</target>
        </trans-unit>
        <trans-unit id="d23baf839f3be80e72847391d0e91cd097e57246" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before. It is also good to mention that changing static property is frowned upon, here &lt;code&gt;greeter3&lt;/code&gt; has &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; on &lt;code&gt;standardGreeting&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, agregaremos dependencias de tiempo de desarrollo en &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; y &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">A continuaci&amp;oacute;n, crearemos la clase que manejar&amp;aacute; la combinaci&amp;oacute;n de los dos mixins. Veamos esto con m&amp;aacute;s detalle para ver c&amp;oacute;mo lo hace:</target>
        </trans-unit>
        <trans-unit id="65015e14839407ce052eab7ebecff46c96ec532e" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ve also added the &lt;code&gt;@readonly&lt;/code&gt; modifier to ensure that a property is only ever written to during initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">Nightly Builds</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">Nightly Builds:Usando NuGet con MSBuild</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">Nightly Builds:Usando npm</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">La noche se construye</target>
        </trans-unit>
        <trans-unit id="137f56df766041937e987c0af9dc02adfcc4755b" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;main&amp;rdquo; field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2bbc3e501b46e56dd329eeeb31b55fa0b1f266" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;types&amp;rdquo; field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947828c2d274f8a21e38e5dd1c59c5dea679fff4" translate="yes" xml:space="preserve">
          <source>No Emit - &lt;code&gt;noEmit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517bdc2dcead288c404ef1a218dadda3060ef0b5" translate="yes" xml:space="preserve">
          <source>No Emit Helpers - &lt;code&gt;noEmitHelpers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f8de53c793590eccee3c9ce2ed4caeb14a5452" translate="yes" xml:space="preserve">
          <source>No Emit On Error - &lt;code&gt;noEmitOnError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1eb323a13015b5221c0cd99fda83cbd652752c" translate="yes" xml:space="preserve">
          <source>No Error Truncation - &lt;code&gt;noErrorTruncation&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8026bb65899345422d9472e2fb88c6be373e8549" translate="yes" xml:space="preserve">
          <source>No Fallthrough Cases In Switch - &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">No impl&amp;iacute;cito &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">No impl&amp;iacute;cito &lt;code&gt;any&lt;/code&gt; para &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa3c1c5d879a76450e09d3b73229dae5a7fb02f8" translate="yes" xml:space="preserve">
          <source>No Implicit Any - &lt;code&gt;noImplicitAny&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c71f4c5d6c858e8b215dbb144dbf6d05414836" translate="yes" xml:space="preserve">
          <source>No Implicit Returns - &lt;code&gt;noImplicitReturns&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5134182dd86f7b3181089a2100da25c6c0bc7cf4" translate="yes" xml:space="preserve">
          <source>No Implicit This - &lt;code&gt;noImplicitThis&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763fcaff914bd4c20f0951a9a84eab99aa002c2b" translate="yes" xml:space="preserve">
          <source>No Implicit Use Strict - &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b77ce03e2df58d71af1d4f405d9bf1ac7e9005" translate="yes" xml:space="preserve">
          <source>No Lib - &lt;code&gt;noLib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592cae7a1118d335c8f2c20593f693616662691c" translate="yes" xml:space="preserve">
          <source>No Resolve - &lt;code&gt;noResolve&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675ae146fc17269a9c7ab5f87fa461ad1c19cf8e" translate="yes" xml:space="preserve">
          <source>No Strict Generic Checks - &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e5a62628a8609c8c2ea29d4e598862499087d1" translate="yes" xml:space="preserve">
          <source>No Unused Locals - &lt;code&gt;noUnusedLocals&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c92a5c1d34b1db353f920c96e229f154407160" translate="yes" xml:space="preserve">
          <source>No Unused Parameters - &lt;code&gt;noUnusedParameters&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">Ning&amp;uacute;n tipo es un subtipo de o asignable a &lt;code&gt;never&lt;/code&gt; (excepto &lt;code&gt;never&lt;/code&gt; s&amp;iacute; mismo).</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="5c47793ac8ba8a46e72ec2594c5dca3b16c44344" translate="yes" xml:space="preserve">
          <source>Node 10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c07c40cb823fe2596e38b4e3bb579fa72706bed" translate="yes" xml:space="preserve">
          <source>Node 12</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f07679d61eb1484f3fbb7f03c094ced47df3b09" translate="yes" xml:space="preserve">
          <source>Nominal Reified Type Systems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05004c27291ee5258d4639719f948e95da6af52b" translate="yes" xml:space="preserve">
          <source>Non-Goals</source>
          <target state="translated">Non-Goals</target>
        </trans-unit>
        <trans-unit id="116d53de6ee6ef67d2d4805314ad0787f638003a" translate="yes" xml:space="preserve">
          <source>Non-Module Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">Los miembros no funcionales de las interfaces deben ser únicos.Si no son únicos,deben ser del mismo tipo.El compilador emitirá un error si ambas interfaces declaran un miembro no funcional del mismo nombre,pero de tipos diferentes.</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">Las expresiones de difusión no genéricas siguen procesándose como antes:Las firmas de llamada y construcción son despojadas,sólo se conservan las propiedades no genéricas,y para las propiedades con el mismo nombre,se utiliza el tipo de la propiedad más derecha.Esto contrasta con los tipos de intersección que concatenan las firmas de llamada y construcción,preservan todas las propiedades,e intersecan los tipos de propiedades con el mismo nombre.Por lo tanto,las dispersiones de los mismos tipos pueden producir resultados diferentes cuando se crean a través de la instanciación de tipos genéricos:</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">Los tipos no homom&amp;oacute;rficos est&amp;aacute;n creando esencialmente nuevas propiedades, por lo que no pueden copiar modificadores de propiedades desde cualquier lugar.</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">Guardias de tipo no nulo y no definido</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">No nulo y los guardias de tipo no indefinidos pueden utilizar el &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;===&lt;/code&gt; , o &lt;code&gt;!==&lt;/code&gt; operador para comparar con &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; , como en &lt;code&gt;x != null&lt;/code&gt; o &lt;code&gt;x === undefined&lt;/code&gt; . Los efectos sobre los tipos de variables de sujeto reflejan con precisi&amp;oacute;n la sem&amp;aacute;ntica de JavaScript (por ejemplo, los operadores de doble igual verifican ambos valores sin importar cu&amp;aacute;l se especifique, mientras que triple-igual solo verifica el valor especificado).</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">Operador de afirmación no nula</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">Los tipos no anulables no tienen ningún significado y son tratados como su tipo original:</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">Los tipos no unitarios como discriminantes sindicales</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">Normalmente, el compilador intentar&amp;aacute; resolver todas las importaciones de m&amp;oacute;dulos antes de iniciar el proceso de compilaci&amp;oacute;n. Cada vez que resuelve con &amp;eacute;xito una &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n a un archivo, el archivo se agrega al conjunto de archivos que el compilador procesar&amp;aacute; m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">Normalmente, &lt;code&gt;tsc&lt;/code&gt; producir&amp;aacute; salidas ( &lt;code&gt;.js&lt;/code&gt; y &lt;code&gt;.d.ts&lt;/code&gt; ) en presencia de errores de sintaxis o tipo, a menos que &lt;code&gt;noEmitOnError&lt;/code&gt; est&amp;eacute; activado . Hacer esto en un sistema de compilaci&amp;oacute;n incremental ser&amp;iacute;a muy malo: si una de sus dependencias desactualizadas tuviera un nuevo error, solo lo ver&amp;iacute;a &lt;em&gt;una vez&lt;/em&gt; porque una compilaci&amp;oacute;n posterior omitir&amp;iacute;a la compilaci&amp;oacute;n del proyecto ahora actualizado. Por esta raz&amp;oacute;n, &lt;code&gt;tsc -b&lt;/code&gt; act&amp;uacute;a efectivamente como si &lt;code&gt;noEmitOnError&lt;/code&gt; estuviera habilitado para todos los proyectos.</target>
        </trans-unit>
        <trans-unit id="9fd029d8465bd91c3c7282b62d1066fe73ce0eee" translate="yes" xml:space="preserve">
          <source>Normally, TypeScript would return silently on success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">No todas las combinaciones est&amp;aacute;n permitidas en TypeScript. Actualmente, las clases no se pueden fusionar con otras clases o con variables. Para obtener informaci&amp;oacute;n sobre c&amp;oacute;mo imitar la combinaci&amp;oacute;n de clases, consulte la secci&amp;oacute;n &lt;a href=&quot;mixins&quot;&gt;Mixins en TypeScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">Es posible que no se requieran todas las propiedades de una interfaz. Algunos existen bajo ciertas condiciones o pueden no estar all&amp;iacute; en absoluto. Estas propiedades opcionales son populares cuando se crean patrones como &quot;bolsas de opciones&quot; donde se pasa un objeto a una funci&amp;oacute;n que solo tiene un par de propiedades completadas.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">Tenga en cuenta que las etiquetas que no se enumeran expl&amp;iacute;citamente a continuaci&amp;oacute;n (como &lt;code&gt;@async&lt;/code&gt; ) a&amp;uacute;n no son compatibles.</target>
        </trans-unit>
        <trans-unit id="9f5feea3e404674922df60252466104fa5c5fc9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike TypeScript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;@enum&lt;/code&gt; es bastante diferente y mucho m&amp;aacute;s simple que la &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n de Typecript . Sin embargo, a diferencia de las enumeraciones de Typecript, &lt;code&gt;@enum&lt;/code&gt; puede tener cualquier tipo:</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;@extends&lt;/code&gt; solo funciona con clases. Actualmente, no hay forma de que una funci&amp;oacute;n constructora extienda una clase.</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; son tan &amp;uacute;tiles que se incluyen en la biblioteca est&amp;aacute;ndar de TypeScript junto con &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a8635b5b3c1a94603cc953231075f37144a428de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;keyof any&lt;/code&gt; represents the type of any value that can be used as an index to an object. In otherwords, &lt;code&gt;keyof any&lt;/code&gt; is currently equal to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;y&lt;/code&gt; tiene una propiedad de &lt;code&gt;location&lt;/code&gt; adicional , pero esto no crea un error. Solo los miembros del tipo de destino ( &lt;code&gt;Named&lt;/code&gt; en este caso) se consideran al verificar la compatibilidad.</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que TypeScript trata los valores &lt;code&gt;null&lt;/code&gt; y &lt;code&gt;undefined&lt;/code&gt; diferente para que coincida con la sem&amp;aacute;ntica de JavaScript. &lt;code&gt;string | null&lt;/code&gt; es un tipo diferente a &lt;code&gt;string | undefined&lt;/code&gt; y &lt;code&gt;string | undefined | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d964565fed797b8fe69da21280237178f8dd90d" translate="yes" xml:space="preserve">
          <source>Note that TypeScript will never write an output file to a directory outside of &lt;code&gt;outDir&lt;/code&gt;, and will never skip emitting a file. For this reason, &lt;code&gt;rootDir&lt;/code&gt; also enforces that all files which need to be emitted are underneath the &lt;code&gt;rootDir&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">Tenga en cuenta que, al igual que con &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; , no se respetar&amp;aacute;n las propiedades del proyecto TypeScript existente; todas las configuraciones deben administrarse utilizando su archivo tsconfig.</target>
        </trans-unit>
        <trans-unit id="49f454e4294f1faa6bdcf0d5b1903082b8d7d4af" translate="yes" xml:space="preserve">
          <source>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af06da8b751f486668f66523aec780426d9aaf88" translate="yes" xml:space="preserve">
          <source>Note that functions and arrays are objects at runtime, but have their own predicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que las variables globales declaradas con &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; no aparecen en &lt;code&gt;globalThis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">Tenga en cuenta que si &lt;code&gt;bar&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; , nuestro c&amp;oacute;digo seguir&amp;aacute; mostrando un error al acceder a &lt;code&gt;baz&lt;/code&gt; . Del mismo modo, si &lt;code&gt;baz&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; , encontraremos un error en el sitio de la llamada. &lt;code&gt;?.&lt;/code&gt; solo comprueba si el valor a la &lt;em&gt;izquierda&lt;/em&gt; es &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; , no ninguna de las propiedades posteriores.</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">Tenga en cuenta que en el modo &lt;code&gt;--strictNullChecks&lt;/code&gt; , cuando un tipo mapeado homom&amp;oacute;rfico elimina un &lt;code&gt;?&lt;/code&gt; modificador de una propiedad en el tipo subyacente, tambi&amp;eacute;n elimina &lt;code&gt;undefined&lt;/code&gt; del tipo de esa propiedad:</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">Obsérvese que en TypeScript 1.4,cuando se accede a un elemento fuera del conjunto de índices conocidos,se utiliza en su lugar un tipo de unión:</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">Tenga en cuenta que en este ejemplo, agregamos un valor al lado &lt;em&gt;est&amp;aacute;tico&lt;/em&gt; de &lt;code&gt;C&lt;/code&gt; (su funci&amp;oacute;n constructora). Esto se debe a que agregamos un &lt;em&gt;valor&lt;/em&gt; , y el contenedor para todos los valores es otro valor (los tipos est&amp;aacute;n contenidos por espacios de nombres y los espacios de nombres est&amp;aacute;n contenidos por otros espacios de nombres).</target>
        </trans-unit>
        <trans-unit id="4521e5d9ffa1f2a7a2398a1ba71b06034b84ba66" translate="yes" xml:space="preserve">
          <source>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare &lt;code&gt;map&lt;/code&gt; with the array first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">Tenga en cuenta que es posible definir muchos tipos en el &amp;aacute;mbito global al escribir un archivo de declaraci&amp;oacute;n global. Desaconsejamos encarecidamente esto, ya que conduce a posibles conflictos de nombres irresolubles cuando hay muchos archivos de declaraci&amp;oacute;n en un proyecto.</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">Nótese que los paréntesis son opcionales para los tipos de unión.</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">Tenga en cuenta que la superposición parcial sigue estando permitida siempre y cuando los tipos de propiedad sean válidos.</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">Tenga en cuenta que las importaciones de módulos relativos no se ven afectadas por la configuración de la baseUrl,ya que siempre se resuelven en relación con sus archivos de importación.</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">Tenga en cuenta que el campo &lt;code&gt;&quot;typings&quot;&lt;/code&gt; es sin&amp;oacute;nimo de &lt;code&gt;&quot;types&quot;&lt;/code&gt; y tambi&amp;eacute;n podr&amp;iacute;a utilizarse.</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">Tenga en cuenta que la &lt;code&gt;function pickCard(x): any&lt;/code&gt; pieza no forma parte de la lista de sobrecargas, por lo que solo tiene dos sobrecargas: una que toma un objeto y otra que toma un n&amp;uacute;mero. Llamar a &lt;code&gt;pickCard&lt;/code&gt; con cualquier otro tipo de par&amp;aacute;metro provocar&amp;iacute;a un error.</target>
        </trans-unit>
        <trans-unit id="8e52a12186dadc57595c17ea6c93216559c79848" translate="yes" xml:space="preserve">
          <source>Note that the return type of &lt;code&gt;area&lt;/code&gt; is inferred to be &lt;code&gt;number&lt;/code&gt; because TypeScript knows the function is total. If some variant is not covered, the return type of &lt;code&gt;area&lt;/code&gt; will be &lt;code&gt;number | undefined&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">Tenga en cuenta que este colapso sólo debe ocurrir cuando todas las sobrecargas tienen el mismo tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">Tenga en cuenta que esto no implica que las tuplas representen matrices inmutables,sino que es una convención implícita.</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que este es un cambio importante para algunos c&amp;oacute;digos. Si necesita recurrir al comportamiento original en el que las tuplas solo imponen una longitud m&amp;iacute;nima, puede usar una declaraci&amp;oacute;n similar que no defina expl&amp;iacute;citamente una propiedad de &lt;code&gt;length&lt;/code&gt; , volviendo al &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">Nótese que esta sintaxis describe un tipo más que un miembro.Si quieres añadir miembros,puedes usar un tipo de intersección:</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">Tenga en cuenta que esta inferencia de desenvolvimiento solo funciona en tipos mapeados homom&amp;oacute;rficos. Si el tipo mapeado no es homom&amp;oacute;rfico, tendr&amp;aacute; que dar un par&amp;aacute;metro de tipo expl&amp;iacute;cito a su funci&amp;oacute;n de desenvolver.</target>
        </trans-unit>
        <trans-unit id="ca498eaf7012359010349b6f8e9e80f634eacb51" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;export default&lt;/code&gt; in your .d.ts files requires &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt;&lt;code&gt;esModuleInterop: true&lt;/code&gt;&lt;/a&gt; to work. If you can&amp;rsquo;t have &lt;code&gt;esModuleInterop: true&lt;/code&gt; in your project, such as when you&amp;rsquo;re submitting a PR to Definitely Typed, you&amp;rsquo;ll have to use the &lt;code&gt;export=&lt;/code&gt; syntax instead. This older syntax is harder to use but works everywhere. Here&amp;rsquo;s how the above example would have to be written using &lt;code&gt;export=&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">Tenga en cuenta que no podemos agregar alias de &lt;code&gt;type s = string;&lt;/code&gt; ( tipo s = cadena; ) usando una interfaz.</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">Tenga en cuenta que actualmente sólo apoyamos las propiedades discriminantes de los tipos literales de cuerda.Tenemos la intención de añadir más adelante el soporte de tipos literales booleanos y numéricos.</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">Tenga en cuenta que no hicimos &lt;code&gt;b&lt;/code&gt; opcional aqu&amp;iacute; porque los tipos de devoluci&amp;oacute;n de las firmas son diferentes.</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">Tenga en cuenta que cuando un tipo de tupla se infiere de una secuencia de par&amp;aacute;metros y luego se expande en una lista de par&amp;aacute;metros, como es el caso de &lt;code&gt;U&lt;/code&gt; , los nombres de los par&amp;aacute;metros originales se usan en la expansi&amp;oacute;n (sin embargo, los nombres no tienen significado sem&amp;aacute;ntico y no son de otra manera observable).</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">Tenga en cuenta que cuando se usan estos indicadores juntos, TypeScript no necesariamente tiene que bajar el nivel de los archivos &lt;code&gt;.js&lt;/code&gt; . Si simplemente desea que TypeScript cree archivos &lt;code&gt;.d.ts&lt;/code&gt; , puede usar la opci&amp;oacute;n del compilador &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">Tenga en cuenta que si bien este ejemplo utiliza &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;componentes de funci&amp;oacute;n&lt;/a&gt; , tambi&amp;eacute;n podr&amp;iacute;amos hacer que nuestro ejemplo sea un poco &lt;em&gt;m&amp;aacute;s elegante&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">Nota: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; apunta a la &amp;uacute;ltima compatibilidad</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">Nota: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; apunta a las &amp;uacute;ltimas &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;funciones propuestas de ES&lt;/a&gt; compatibles .</target>
        </trans-unit>
        <trans-unit id="9d7cb6b652ecb3fc440c1897098d4132f67f5630" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;node&lt;/code&gt; module resolution is the most-commonly used in the TypeScript community and is recommended for most projects. If you are having resolution problems with &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;export&lt;/code&gt;s in TypeScript, try setting &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; to see if it fixes the issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b385aa9974c78d1114e7d19ac34ae3cecb189cbb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;outFile&lt;/code&gt; cannot be used unless &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt;, or &lt;code&gt;AMD&lt;/code&gt;. This option &lt;em&gt;cannot&lt;/em&gt; be used to bundle CommonJS or ES6 modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">Nota: Evite usar &lt;code&gt;Object&lt;/code&gt; en favor del tipo de &lt;code&gt;object&lt;/code&gt; no primitivo, como se describe en nuestra secci&amp;oacute;n &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Qu&amp;eacute; hacer y qu&amp;eacute; no hacer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93a51f16eac9cd871496fa3f38f5e48ecd5fea51" translate="yes" xml:space="preserve">
          <source>Note: Error messages only show up in JS codebases with &lt;a href=&quot;tsconfig-json&quot;&gt;a JSConfig&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">Nota: Los componentes de funci&amp;oacute;n se conoc&amp;iacute;an anteriormente como componentes de funci&amp;oacute;n sin estado (SFC). Como los componentes de funci&amp;oacute;n ya no pueden considerarse sin estado en las versiones recientes de react, el tipo &lt;code&gt;SFC&lt;/code&gt; y su alias &lt;code&gt;StatelessComponent&lt;/code&gt; quedaron obsoletos.</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">Nota: Si no se especifica &lt;code&gt;--lib&lt;/code&gt; , se inyecta una lista predeterminada de bibliotecas. Las bibliotecas predeterminadas inyectadas son:</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">Nota: Si un nombre de atributo no es un identificador JS v&amp;aacute;lido (como un atributo &lt;code&gt;data-*&lt;/code&gt; ), no se considera un error si no se encuentra en el tipo de atributos del elemento.</target>
        </trans-unit>
        <trans-unit id="019f04b9d1d907c729221ba8c0d3f15ea3b9e489" translate="yes" xml:space="preserve">
          <source>Note: In &lt;em&gt;very&lt;/em&gt; old versions of TypeScript namespaces were called &amp;lsquo;Internal Modules&amp;rsquo;, these pre-date JavaScript module systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">Nota:La mayoría de los cambios no requieren que instale una nueva versión del plugin VS TypeScript.</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">Nota:La sintaxis anterior que define los módulos internos sigue siendo compatible.</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">Nota: El tipo &lt;code&gt;Exclude&lt;/code&gt; es una implementaci&amp;oacute;n adecuada del tipo &lt;code&gt;Diff&lt;/code&gt; sugerido &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Hemos utilizado el nombre &lt;code&gt;Exclude&lt;/code&gt; para evitar romper el c&amp;oacute;digo existente que define un &lt;code&gt;Diff&lt;/code&gt; , adem&amp;aacute;s creemos que el nombre transmite mejor la sem&amp;aacute;ntica del tipo.</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Nota: El tipo &lt;code&gt;Exclude&lt;/code&gt; es una implementaci&amp;oacute;n adecuada del tipo &lt;code&gt;Diff&lt;/code&gt; sugerido &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Hemos utilizado el nombre &lt;code&gt;Exclude&lt;/code&gt; para evitar romper el c&amp;oacute;digo existente que define un &lt;code&gt;Diff&lt;/code&gt; , adem&amp;aacute;s creemos que el nombre transmite mejor la sem&amp;aacute;ntica del tipo. No incluimos el tipo &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; porque est&amp;aacute; escrito trivialmente como &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">Nota: El nuevo comportamiento se agrega bajo una bandera para evitar interrupciones injustificadas en las bases de c&amp;oacute;digo existentes. &lt;strong&gt;Recomendamos encarecidamente aplicarlo tanto a proyectos nuevos como existentes. &lt;/strong&gt;Para los proyectos existentes, las importaciones de espacio de nombres ( &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; ) deber&amp;aacute;n convertirse en importaciones predeterminadas ( &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">Nota: Este cambio trae un nuevo asistente de &lt;code&gt;__makeTemplateObject&lt;/code&gt; , __makeTemplateObject ; si est&amp;aacute; utilizando &lt;code&gt;--importHelpers&lt;/code&gt; con &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt; , una actualizaci&amp;oacute;n a la versi&amp;oacute;n 1.8 o posterior.</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">Nota: Este tipo solo funciona correctamente si &lt;code&gt;--strictFunctionTypes&lt;/code&gt; est&amp;aacute; habilitado. Ver &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;# 32964&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">Nota: Tambi&amp;eacute;n puede especificar un indexador de cadenas catch-all en &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">Nota: Deber&amp;aacute; configurar su proyecto para usar los paquetes NuGet. Consulte &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuraci&amp;oacute;n de proyectos de MSBuild para usar NuGet&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">Nota: primero, debemos asegurarnos de que nuestro tiempo de ejecuci&amp;oacute;n tenga una &lt;code&gt;Promise&lt;/code&gt; compatible con ECMAScript disponible a nivel mundial. Eso podr&amp;iacute;a implicar tomar &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;un polyfill&lt;/a&gt; para &lt;code&gt;Promise&lt;/code&gt; o confiar en uno que pueda tener en el tiempo de ejecuci&amp;oacute;n al que se dirige. Tambi&amp;eacute;n debemos asegurarnos de que TypeScript sepa que &lt;code&gt;Promise&lt;/code&gt; existe estableciendo su bandera &lt;code&gt;lib&lt;/code&gt; en algo como &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; o &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">Nota: si el archivo de declaraci&amp;oacute;n que est&amp;aacute; buscando no est&amp;aacute; presente, siempre puede contribuir con uno y ayudar al pr&amp;oacute;ximo desarrollador que lo busque. Consulte la &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;p&amp;aacute;gina de pautas de contribuci&amp;oacute;n&lt;/a&gt; DefinitelyTyped para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">Observe c&amp;oacute;mo eliminamos el &lt;code&gt;theName&lt;/code&gt; completo y simplemente usamos el par&amp;aacute;metro de &lt;code&gt;readonly name: string&lt;/code&gt; abreviado de solo lectura en el constructor para crear e inicializar el miembro de &lt;code&gt;name&lt;/code&gt; . Hemos consolidado las declaraciones y la asignaci&amp;oacute;n en un solo lugar.</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">Observe que &lt;code&gt;T&lt;/code&gt; se ha propagado desde &lt;code&gt;makeArray&lt;/code&gt; a la lista de par&amp;aacute;metros de tipo del tipo resultante. Esto significa que genericity de &lt;code&gt;compose&lt;/code&gt; argumentos &amp;lsquo;s se ha conservado y nuestra &lt;code&gt;makeBoxedArray&lt;/code&gt; muestra se acaba el trabajo!</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">Observe que &lt;code&gt;T&lt;/code&gt; tiene la restricci&amp;oacute;n adicional &lt;code&gt;any[]&lt;/code&gt; dentro de la rama verdadera de &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; y, por lo tanto, es posible referirse al tipo de elemento de la matriz como &lt;code&gt;T[number]&lt;/code&gt; . Adem&amp;aacute;s, observe c&amp;oacute;mo se distribuye el tipo condicional sobre el tipo de uni&amp;oacute;n en el &amp;uacute;ltimo ejemplo.</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;createCardPicker&lt;/code&gt; es una funci&amp;oacute;n que en s&amp;iacute; misma devuelve una funci&amp;oacute;n. Si intent&amp;aacute;ramos ejecutar el ejemplo, obtendr&amp;iacute;amos un error en lugar del cuadro de alerta esperado. Esto se debe a que el &lt;code&gt;this&lt;/code&gt; que se usa en la funci&amp;oacute;n creada por &lt;code&gt;createCardPicker&lt;/code&gt; se establecer&amp;aacute; en &lt;code&gt;window&lt;/code&gt; lugar de en nuestro objeto de &lt;code&gt;deck&lt;/code&gt; . Eso es porque llamamos &lt;code&gt;cardPicker()&lt;/code&gt; por s&amp;iacute; solo. Una llamada de sintaxis sin m&amp;eacute;todo de nivel superior como esta usar&amp;aacute; &lt;code&gt;window&lt;/code&gt; para &lt;code&gt;this&lt;/code&gt; . (Nota: en el modo estricto, &lt;code&gt;this&lt;/code&gt; ser&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; en lugar de &lt;code&gt;window&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;uglify&lt;/code&gt; en s&amp;iacute; tiene una sola llamada: las llamadas al &lt;code&gt;buffer&lt;/code&gt; y los &lt;code&gt;sourcemaps&lt;/code&gt; existen para asegurarse de que los mapas de origen sigan funcionando. Estas llamadas nos dan un archivo de mapa de origen separado en lugar de usar mapas de origen en l&amp;iacute;nea como antes. Ahora puede ejecutar Gulp y comprobar que &lt;code&gt;bundle.js&lt;/code&gt; se reduce a un l&amp;iacute;o ilegible:</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">Fíjense que Node.js saltó a un directorio en los pasos (4)y (7).</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que TypeScript no solo sabe que la &lt;code&gt;pet&lt;/code&gt; es un &lt;code&gt;Fish&lt;/code&gt; en la rama &lt;code&gt;if&lt;/code&gt; ; tambi&amp;eacute;n sabe que en la rama &lt;code&gt;else&lt;/code&gt; , &lt;em&gt;no&lt;/em&gt; tienes un &lt;code&gt;Fish&lt;/code&gt; , por lo que debes tener un &lt;code&gt;Bird&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">Tenga en cuenta que, aunque hubo errores, el archivo &lt;code&gt;greeter.js&lt;/code&gt; a&amp;uacute;n se crea. Puede usar TypeScript incluso si hay errores en su c&amp;oacute;digo. Pero en este caso, TypeScript advierte que su c&amp;oacute;digo probablemente no se ejecutar&amp;aacute; como se esperaba.</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">Tenga en cuenta que aunque usamos la sintaxis del m&amp;oacute;dulo ES2015, TypeScript emiti&amp;oacute; m&amp;oacute;dulos CommonJS que usa Node. Nos quedaremos con CommonJS para este tutorial, pero puede configurar el &lt;code&gt;module&lt;/code&gt; en el objeto de opciones para cambiar esto.</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">Observe que nuestro ejemplo ha cambiado para ser algo ligeramente diferente. En lugar de describir una funci&amp;oacute;n gen&amp;eacute;rica, ahora tenemos una firma de funci&amp;oacute;n no gen&amp;eacute;rica que es parte de un tipo gen&amp;eacute;rico. Cuando usamos &lt;code&gt;GenericIdentityFn&lt;/code&gt; , ahora tambi&amp;eacute;n necesitaremos especificar el argumento de tipo correspondiente (aqu&amp;iacute;: &lt;code&gt;number&lt;/code&gt; ), bloqueando efectivamente lo que usar&amp;aacute; la firma de llamada subyacente. Comprender cu&amp;aacute;ndo colocar el par&amp;aacute;metro de tipo directamente en la firma de la llamada y cu&amp;aacute;ndo colocarlo en la propia interfaz ser&amp;aacute; &amp;uacute;til para describir qu&amp;eacute; aspectos de un tipo son gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">Fíjese que los elementos de cada grupo mantienen el mismo orden,pero los grupos mismos se fusionan con conjuntos de sobrecarga posteriores ordenados primero.</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">Observe que no tuvimos que pasar expl&amp;iacute;citamente el tipo entre corchetes angulares ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ); el compilador s&amp;oacute;lo mir&amp;oacute; el valor &lt;code&gt;&quot;myString&quot;&lt;/code&gt; y estableci&amp;oacute; &lt;code&gt;T&lt;/code&gt; en su tipo. Si bien la inferencia de argumentos de tipo puede ser una herramienta &amp;uacute;til para mantener el c&amp;oacute;digo m&amp;aacute;s corto y legible, es posible que deba pasar expl&amp;iacute;citamente los argumentos de tipo como hicimos en el ejemplo anterior cuando el compilador no puede inferir el tipo, como puede suceder en ejemplos m&amp;aacute;s complejos .</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">Tenga en cuenta que no usamos la palabra clave &lt;code&gt;require&lt;/code&gt; ; en su lugar, asignamos directamente desde el nombre calificado del s&amp;iacute;mbolo que estamos importando. Esto es similar a usar &lt;code&gt;var&lt;/code&gt; , pero tambi&amp;eacute;n funciona con el tipo y los significados del espacio de nombres del s&amp;iacute;mbolo importado. Es importante destacar que, para los valores, la &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n es una referencia distinta del s&amp;iacute;mbolo original, por lo que los cambios en una &lt;code&gt;var&lt;/code&gt; con alias no se reflejar&amp;aacute;n en la variable original.</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">Note que tuvimos que rodear esta declaraci&amp;oacute;n entre par&amp;eacute;ntesis. JavaScript normalmente analiza un &lt;code&gt;{&lt;/code&gt; como el inicio del bloque.</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">Observe que tuvimos que usar afirmaciones de tipo varias veces. Ser&amp;iacute;a mucho mejor si una vez realizado el chequeo pudi&amp;eacute;ramos conocer el tipo de &lt;code&gt;pet&lt;/code&gt; dentro de cada rama.</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">Observe que instalamos TypeScript como una dependencia de desarrollo. Tambi&amp;eacute;n podr&amp;iacute;amos haber vinculado TypeScript a una copia global con el &lt;code&gt;npm link typescript&lt;/code&gt; , pero este es un escenario menos com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">Observe que especificamos &lt;code&gt;debug: true&lt;/code&gt; para Browserify. Esto hace que tsify emita mapas de origen dentro del archivo JavaScript incluido. Los mapas de origen le permiten depurar su c&amp;oacute;digo TypeScript original en el navegador en lugar del JavaScript incluido. Se puede probar que los mapas de c&amp;oacute;digo est&amp;aacute;n trabajando abriendo el depurador de su navegador y poner un punto de interrupci&amp;oacute;n en el interior &lt;code&gt;main.ts&lt;/code&gt; . Cuando actualiza la p&amp;aacute;gina, el punto de interrupci&amp;oacute;n debe pausar la p&amp;aacute;gina y permitirle depurar &lt;code&gt;greet.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que estamos incluyendo archivos desde dentro de &lt;code&gt;node_modules&lt;/code&gt; . Los paquetes npm de React y React-DOM incluyen archivos &lt;code&gt;.js&lt;/code&gt; independientes que puede incluir en una p&amp;aacute;gina web, y los estamos haciendo referencia directamente para que las cosas se muevan m&amp;aacute;s r&amp;aacute;pido. Si&amp;eacute;ntase libre de copiar estos archivos a otro directorio o, alternativamente, alojarlos en una red de entrega de contenido (CDN). Facebook pone a disposici&amp;oacute;n versiones de React alojadas en CDN, y puedes &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;leer m&amp;aacute;s sobre eso aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que, si bien no podemos usar el &lt;code&gt;name&lt;/code&gt; desde fuera de &lt;code&gt;Person&lt;/code&gt; , podemos usarlo desde dentro de un m&amp;eacute;todo de instancia de &lt;code&gt;Employee&lt;/code&gt; porque &lt;code&gt;Employee&lt;/code&gt; se deriva de &lt;code&gt;Person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">Tenga en cuenta que lo anterior no necesita anotaciones de tipo. La aserci&amp;oacute;n &lt;code&gt;const&lt;/code&gt; permiti&amp;oacute; a TypeScript tomar el tipo m&amp;aacute;s espec&amp;iacute;fico de expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">Observe que el argumento dado para &lt;code&gt;createSquare&lt;/code&gt; se escribe &lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt; lugar de &lt;code&gt;color&lt;/code&gt; . En JavaScript simple, este tipo de cosas falla silenciosamente.</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">Ahora la &lt;code&gt;search&lt;/code&gt; es &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; . La distribuci&amp;oacute;n de objetos es m&amp;aacute;s compleja que la distribuci&amp;oacute;n de matrices. Al igual que la distribuci&amp;oacute;n de matrices, procede de izquierda a derecha, pero el resultado sigue siendo un objeto. Esto significa que las propiedades que vienen m&amp;aacute;s adelante en el objeto de distribuci&amp;oacute;n sobrescriben las propiedades que vienen antes. Entonces, si modificamos el ejemplo anterior para difundir al final:</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">Ahora TypeScript sabe que &lt;code&gt;createCardPicker&lt;/code&gt; espera ser llamado en un objeto &lt;code&gt;Deck&lt;/code&gt; . Eso significa que &lt;code&gt;this&lt;/code&gt; es de tipo &lt;code&gt;Deck&lt;/code&gt; ahora, no &lt;code&gt;any&lt;/code&gt; , por lo que &lt;code&gt;--noImplicitThis&lt;/code&gt; no causar&amp;aacute; ning&amp;uacute;n error.</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">Ahora cambie &lt;code&gt;main.ts&lt;/code&gt; para actualizar la p&amp;aacute;gina:</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">Ahora cambie el c&amp;oacute;digo en &lt;code&gt;src/main.ts&lt;/code&gt; para importar &lt;code&gt;sayHello&lt;/code&gt; desde &lt;code&gt;greet.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">Ahora cambie su archivo de gulp a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Ahora, si anota el c&amp;oacute;digo de llamada con &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">Ahora las importaciones a &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; se &lt;code&gt;./modules/moduleA&lt;/code&gt; en ./modules/moduleA</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">Ahora veamos c&amp;oacute;mo se tratan los tipos de devoluci&amp;oacute;n, usando dos funciones que se diferencian solo por su tipo de devoluci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">Ahora muevamos este proyecto de Node al navegador. Para hacer esto, nos gustar&amp;iacute;a agrupar todos nuestros m&amp;oacute;dulos en un archivo JavaScript. Afortunadamente, eso es exactamente lo que hace Browserify. A&amp;uacute;n mejor, nos permite usar el sistema de m&amp;oacute;dulos CommonJS utilizado por Node, que es la emisi&amp;oacute;n predeterminada de TypeScript. Eso significa que nuestra configuraci&amp;oacute;n de TypeScript y Node se transferir&amp;aacute; al navegador b&amp;aacute;sicamente sin cambios.</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">Ahora usemos la uni&amp;oacute;n discriminada:</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">&amp;iexcl;Ahora abra &lt;code&gt;index.html&lt;/code&gt; en su navegador favorito y todo deber&amp;iacute;a estar listo para usar! Deber&amp;iacute;a ver una p&amp;aacute;gina que dice &quot;&amp;iexcl;Hola desde TypeScript y React!&quot;</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">Ahora haga clic derecho en &lt;code&gt;gulpfile.js&lt;/code&gt; y haga clic en Task Runner Explorer.</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">Ahora que estamos agrupando nuestro código con Browserify y tsify,podemos añadir varias características a nuestra construcción con los plugins de Browserify.</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">Ahora que hemos escrito la funci&amp;oacute;n, escribamos el tipo completo de la funci&amp;oacute;n mirando cada parte del tipo de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">Ahora que ha creado un archivo de declaración siguiendo los pasos de esta guía,es hora de publicarlo a npm.Hay dos maneras principales de publicar sus archivos de declaración a npm:</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">Ahora que sabe c&amp;oacute;mo ajustar las propiedades de un tipo, lo siguiente que querr&amp;aacute; hacer es desenvolverlas. Afortunadamente, eso es bastante f&amp;aacute;cil:</target>
        </trans-unit>
        <trans-unit id="6f30ea04179dac8c71c16f96f3f1582920ec3fad" translate="yes" xml:space="preserve">
          <source>Now the type of the array propagates into the &lt;code&gt;ArrayMetadata&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">Ahora, para ampliar esto y agregar soporte para la entrada con n&amp;uacute;meros en bases distintas de 10, creemos &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">Ahora escriba lo siguiente en &lt;code&gt;greeter.html&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">Ahora podemos &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; y luego cargar los m&amp;oacute;dulos usando &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; o &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">Ahora podemos empezar a aprovechar algunas de las nuevas herramientas que ofrece TypeScript. Agregue una anotaci&amp;oacute;n de tipo &lt;code&gt;: string&lt;/code&gt; al argumento de la funci&amp;oacute;n 'persona' como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">Ahora podemos usar &lt;code&gt;npm install&lt;/code&gt; para instalar paquetes. Primero instale &lt;code&gt;gulp-cli&lt;/code&gt; globalmente (si usa un sistema Unix, es posible que deba prefijar los comandos de &lt;code&gt;npm install&lt;/code&gt; en esta gu&amp;iacute;a con &lt;code&gt;sudo&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">Ahora convertiremos esta carpeta en un paquete npm.</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">Ahora, cuando se llaman estas funciones que &lt;code&gt;never&lt;/code&gt; regresan, TypeScript reconoce que afectan el gr&amp;aacute;fico de flujo de control y las tiene en cuenta.</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">Ahora, cuando ejecute Gulp, deber&amp;iacute;a comenzar y seguir funcionando. Intente cambiar el c&amp;oacute;digo de &lt;code&gt;showHello&lt;/code&gt; en &lt;code&gt;main.ts&lt;/code&gt; y gu&amp;aacute;rdelo . Deber&amp;iacute;a ver una salida que se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">Ahora puede importar cosas que coincidan con &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; o &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b80d5fe66868146461ed39d9590423def0cc437" translate="yes" xml:space="preserve">
          <source>Now, for the remainder of the &lt;code&gt;createElement&lt;/code&gt; definition: &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt;. The first argument &lt;code&gt;tagName&lt;/code&gt; is defined as the generic parameter &lt;code&gt;K&lt;/code&gt; . The TypeScript interpreter is smart enough to &lt;em&gt;infer&lt;/em&gt; the generic parameter from this argument. This means that the developer does not actually have to specify the generic parameter when using the method; whatever value is passed to the &lt;code&gt;tagName&lt;/code&gt; argument will be inferred as &lt;code&gt;K&lt;/code&gt; and thus can be used throughout the remainder of the definition. Which is exactly what happens; the return value &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; takes the &lt;code&gt;tagName&lt;/code&gt; argument and uses it to return the corresponding type. This definition is how the &lt;code&gt;p&lt;/code&gt; variable from the code snippet gets a type of &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. And if the code was &lt;code&gt;document.createElement('a')&lt;/code&gt;, then it would be an element of type &lt;code&gt;HTMLAnchorElement&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">Nulo e indefinido</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">Tipos de conocimiento nulo e indefinido</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">Tipos anulables</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">Los tipos que aceptan valores NULL solo tienen significado si &lt;code&gt;strictNullChecks&lt;/code&gt; est&amp;aacute; activado :</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">Coalescencia nula</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">Las propiedades de tipo numérico de un tipo de objeto son las que se declaran utilizando un nombre de propiedad numérico literal o calculado de un tipo numérico literal.</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">Tipos literales numéricos</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">Enumeraciones numéricas</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">Las enumeraciones num&amp;eacute;ricas se pueden mezclar en &lt;a href=&quot;#computed-and-constant-members&quot;&gt;miembros calculados y constantes (ver m&amp;aacute;s abajo)&lt;/a&gt; . La historia corta es que las enumeraciones sin inicializadores deben ser las primeras o deben ir despu&amp;eacute;s de las enumeraciones num&amp;eacute;ricas inicializadas con constantes num&amp;eacute;ricas u otros miembros de enumeraci&amp;oacute;n constante. En otras palabras, no se permite lo siguiente:</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">Separadores numéricos</target>
        </trans-unit>
        <trans-unit id="8ec915a9d6271aa88a6e6bab3fe9b7a8d9dc2808" translate="yes" xml:space="preserve">
          <source>OOP in TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e96ab681e7258c80946a74a514f141957d53b7" translate="yes" xml:space="preserve">
          <source>OOP programmers are accustomed to being able to query the type of any value, even a generic one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adeb8baadb7619ed1ee71c0d637100cf68745ddb" translate="yes" xml:space="preserve">
          <source>OOP programmers are often surprised by two particular aspects of structural typing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">Difusión y descanso del objeto</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">Desestructuración de objetos</target>
        </trans-unit>
        <trans-unit id="1ccb033a21e86f3dd077314deacc164caf7a1572" translate="yes" xml:space="preserve">
          <source>Object literal type syntax closely mirrors object literal value syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">Los literales de los objetos son abiertos</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">Los objetos literales se comportan como si tuvieran una firma de &amp;iacute;ndice &lt;code&gt;[x:string]: any&lt;/code&gt; que les permita ser tratados como mapas abiertos en lugar de objetos cerrados.</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">Los restos de objetos son el doble de las extensiones de objetos, ya que pueden extraer cualquier propiedad adicional que no se recoja al desestructurar un elemento:</target>
        </trans-unit>
        <trans-unit id="e39aafc54b41f807d4c66cedbf76e1c69bb09f15" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">La distribuci&amp;oacute;n de objetos tambi&amp;eacute;n tiene un par de otros l&amp;iacute;mites sorprendentes. Primero, solo incluye las &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;propiedades enumerables propias de&lt;/a&gt; un objeto . B&amp;aacute;sicamente, eso significa que pierde m&amp;eacute;todos cuando extiende instancias de un objeto:</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">Objetos con propiedades</target>
        </trans-unit>
        <trans-unit id="e74f2b06a5fbe1c04ad866d78d3e98d6af48f45f" translate="yes" xml:space="preserve">
          <source>Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8b413b8349b0d2cda00f56b58728dca71d8f18" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using TypeScript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">Por supuesto, cualquiera de estos tipos se puede declarar usando la sintaxis de &lt;code&gt;@typedef&lt;/code&gt; en una l&amp;iacute;nea @typedef :</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">Por supuesto, dado que esto es JavaScript, puede simplemente ignorar los elementos finales que no le interesan:</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">Por supuesto, puede que eso no se sienta bien. Si abre ese archivo en un editor compatible con TypeScript (o si ejecuta &lt;code&gt;tsc --pretty&lt;/code&gt; ), es posible que vea garabatos rojos en ciertas l&amp;iacute;neas. Deber&amp;iacute;a pensar en estos de la misma manera que pensar&amp;iacute;a en garabatos rojos en un editor como Microsoft Word. TypeScript a&amp;uacute;n traducir&amp;aacute; su c&amp;oacute;digo, al igual que Word le permitir&amp;aacute; imprimir sus documentos.</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">Es de destacar que solo los par&amp;aacute;metros y el tipo de retorno constituyen el tipo de funci&amp;oacute;n. Las variables capturadas no se reflejan en el tipo. En efecto, las variables capturadas son parte del &quot;estado oculto&quot; de cualquier funci&amp;oacute;n y no forman parte de su API.</target>
        </trans-unit>
        <trans-unit id="58d8c4b2203739a560ee5629e213ae51b2e9cc9a" translate="yes" xml:space="preserve">
          <source>Offers a way to configure the root directory for where declaration files are emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">Paquete oficial de TypeScript NuGet</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">A menudo, un proyecto tiene m&amp;uacute;ltiples objetivos de salida, por ejemplo, &lt;code&gt;ES5&lt;/code&gt; y &lt;code&gt;ES2015&lt;/code&gt; , depuraci&amp;oacute;n y producci&amp;oacute;n o &lt;code&gt;CommonJS&lt;/code&gt; y &lt;code&gt;System&lt;/code&gt; ; Solo algunas opciones de configuraci&amp;oacute;n cambian entre estos dos destinos, y mantener varios archivos &lt;code&gt;tsconfig.json&lt;/code&gt; puede ser una molestia.</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">A menudo, en las aplicaciones de Node.js, se necesita un &lt;code&gt;.json&lt;/code&gt; . Con TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; permite importar, extraer tipos y generar archivos &lt;code&gt;.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">A menudo los módulos amplían otros módulos y exponen parcialmente algunas de sus características.Una reexportación no la importa localmente,ni introduce una variable local.</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">A menudo hay archivos de fuente externa en su proyecto que pueden no estar escritos en TypeScript.Alternativamente,puede estar en medio de la conversión de un código base JS en TS,pero aún así quiere agrupar todo su código JS en un solo archivo con la salida de su nuevo código TS.</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">A menudo, necesitar&amp;aacute; ampliar la funcionalidad de un m&amp;oacute;dulo. Un patr&amp;oacute;n JS com&amp;uacute;n es aumentar el objeto original con &lt;em&gt;extensiones&lt;/em&gt; , similar a c&amp;oacute;mo funcionan las extensiones de JQuery. Como hemos mencionado antes, los m&amp;oacute;dulos no se &lt;em&gt;fusionan&lt;/em&gt; como lo har&amp;iacute;an los objetos de espacio de nombres globales. La soluci&amp;oacute;n recomendada es &lt;em&gt;no&lt;/em&gt; mutar el objeto original, sino exportar una nueva entidad que proporciona la nueva funcionalidad.</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">En una sola línea:</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">En múltiples líneas:</target>
        </trans-unit>
        <trans-unit id="b121f75269ef9070c6142e71c944032a79d56440" translate="yes" xml:space="preserve">
          <source>On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on &lt;code&gt;node_modules&lt;/code&gt; and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the of files in &lt;code&gt;node_modules&lt;/code&gt;, whereas there are way fewer directories to track.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">En la &amp;uacute;ltima l&amp;iacute;nea del fragmento, puede ver que incluso asignar el &lt;code&gt;ReadonlyArray&lt;/code&gt; completo a una matriz normal es ilegal. Sin embargo, a&amp;uacute;n puede anularlo con una aserci&amp;oacute;n de tipo:</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">En el frente de la organizaci&amp;oacute;n, los espacios de nombres son &amp;uacute;tiles para agrupar objetos y tipos relacionados l&amp;oacute;gicamente en el &amp;aacute;mbito global. Por ejemplo, en C #, encontrar&amp;aacute; todos los tipos de colecci&amp;oacute;n en System.Collections. Al organizar nuestros tipos en espacios de nombres jer&amp;aacute;rquicos, proporcionamos una buena experiencia de &quot;descubrimiento&quot; para los usuarios de esos tipos. Los m&amp;oacute;dulos, por otro lado, ya est&amp;aacute;n presentes en un sistema de archivos, necesariamente. Tenemos que resolverlos por ruta y nombre de archivo, por lo que hay un esquema de organizaci&amp;oacute;n l&amp;oacute;gico que podemos usar. Podemos tener una carpeta / collections / generic / con un m&amp;oacute;dulo de lista en ella.</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">Por otro lado, si no puede expresar alguna forma con una interfaz y necesita usar un tipo de uni&amp;oacute;n o tupla, los alias de tipo suelen ser el camino a seguir.</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">Por otro lado, m&amp;eacute;todos como &lt;code&gt;forEach&lt;/code&gt; ahora ser&amp;aacute;n invocables, pero bajo &lt;code&gt;noImplicitAny&lt;/code&gt; puede haber algunos problemas.</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">Una vez definido,podemos usar este tipo de función como lo haríamos con otras interfaces.Aquí mostramos cómo se puede crear una variable de un tipo de función y asignarle un valor de función del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">Una vez que se establece el tipo de clase, el tipo de instancia se determina mediante la uni&amp;oacute;n de los tipos de retorno de la construcci&amp;oacute;n del tipo de clase o firmas de llamada (lo que est&amp;eacute; presente). Entonces, nuevamente, en el caso de una clase ES6, el tipo de instancia ser&amp;iacute;a el tipo de una instancia de esa clase, y en el caso de una funci&amp;oacute;n de f&amp;aacute;brica, ser&amp;iacute;a el tipo del valor devuelto por la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">Una vez que haya varios archivos involucrados, tendremos que asegurarnos de que se cargue todo el c&amp;oacute;digo compilado. Hay dos formas de hacer esto.</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">Una vez que hemos escrito la funci&amp;oacute;n de identidad gen&amp;eacute;rica, podemos llamarla de dos formas. La primera forma es pasar todos los argumentos, incluido el argumento de tipo, a la funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="efd9fd3ef569813fe54f40f7a5348da23bd676a1" translate="yes" xml:space="preserve">
          <source>Once you start thinking of types as sets, certain operations become very natural. For example, in C#, it&amp;rsquo;s awkward to pass around a value that is &lt;em&gt;either&lt;/em&gt; a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, because there isn&amp;rsquo;t a single type that represents this sort of value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd09b9672aef2e12094c6286dae7bf22bea682c2" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re feeling comfortable, you can come back to read &lt;a href=&quot;typescript-in-5-minutes&quot;&gt;TypeScript for JavaScript Programmers&lt;/a&gt;, then start on &lt;a href=&quot;intro&quot;&gt;the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">Una ventaja de esto es que el patr&amp;oacute;n del constructor invocable se puede expresar f&amp;aacute;cilmente al mismo tiempo que permite que los espacios de nombres se fusionen con estas declaraciones (ya que las declaraciones &lt;code&gt;var&lt;/code&gt; no se pueden fusionar con los &lt;code&gt;namespace&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">Una tarea com&amp;uacute;n es tomar un tipo existente y hacer que cada una de sus propiedades sea completamente opcional. Digamos que tenemos una &lt;code&gt;Person&lt;/code&gt; a :</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">Una diferencia con el ejemplo anterior es que cada clase derivada que contiene una funci&amp;oacute;n constructora &lt;em&gt;debe&lt;/em&gt; llamar a &lt;code&gt;super()&lt;/code&gt; que ejecutar&amp;aacute; el constructor de la clase base. Lo que es m&amp;aacute;s, antes de que &lt;em&gt;alguna vez&lt;/em&gt; acceder a una propiedad de &lt;code&gt;this&lt;/code&gt; en un cuerpo del constructor, que &lt;em&gt;tenemos&lt;/em&gt; que llamar a &lt;code&gt;super()&lt;/code&gt; . Esta es una regla importante que TypeScript aplicar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">Una diferencia es que las interfaces crean un nuevo nombre que se usa en todas partes. Los alias de tipo no crean un nombre nuevo; por ejemplo, los mensajes de error no usar&amp;aacute;n el nombre de alias. En el c&amp;oacute;digo siguiente, al pasar el cursor sobre la &lt;code&gt;interfaced&lt;/code&gt; en un editor, se mostrar&amp;aacute; que devuelve una &lt;code&gt;Interface&lt;/code&gt; , pero mostrar&amp;aacute; que con &lt;code&gt;aliased&lt;/code&gt; devuelve el tipo de objeto literal.</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">Una excepci&amp;oacute;n a esta regla son las firmas especializadas. Si una firma tiene un par&amp;aacute;metro cuyo tipo es un tipo literal de cadena &lt;em&gt;&amp;uacute;nica&lt;/em&gt; (por ejemplo, no una uni&amp;oacute;n de literales de cadena), entonces aparecer&amp;aacute; en la parte superior de su lista de sobrecarga combinada.</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">Una &amp;uacute;ltima forma de evitar estas comprobaciones, que puede resultar un poco sorprendente, es asignar el objeto a otra variable: dado que &lt;code&gt;squareOptions&lt;/code&gt; no se someter&amp;aacute; a comprobaciones de propiedad excesivas, el compilador no le dar&amp;aacute; ning&amp;uacute;n error.</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">Una gran ventaja de esto es que usted ver&amp;aacute; &lt;em&gt;manera menos&lt;/em&gt; impl&amp;iacute;citos &lt;code&gt;any&lt;/code&gt; errores cuando se ejecuta con &lt;code&gt;--noImplicitAny&lt;/code&gt; . Impl&amp;iacute;citos &lt;code&gt;any&lt;/code&gt; errores que s&amp;oacute;lo se notifique cuando el compilador no es capaz de conocer el tipo de una variable sin una anotaci&amp;oacute;n de tipo.</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">Una diferencia importante entre las enumeraciones ambientales y no ambientales es que, en las enumeraciones regulares, los miembros que no tienen un inicializador se considerar&amp;aacute;n constantes si su miembro de enumeraci&amp;oacute;n anterior se considera constante. Por el contrario, un miembro de enumeraci&amp;oacute;n ambiental (y no constante) que no tiene inicializador &lt;em&gt;siempre se&lt;/em&gt; considera calculado.</target>
        </trans-unit>
        <trans-unit id="7b053fca39618dd4a858f60861664a6e5ed2adab" translate="yes" xml:space="preserve">
          <source>One is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">Uno de los principios b&amp;aacute;sicos de TypeScript es que la verificaci&amp;oacute;n de tipos se centra en la &lt;em&gt;forma&lt;/em&gt; que tienen los valores. Esto a veces se denomina &quot;tipificaci&amp;oacute;n de pato&quot; o &quot;subtipo estructural&quot;. En TypeScript, las interfaces cumplen la funci&amp;oacute;n de nombrar estos tipos y son una forma poderosa de definir contratos dentro de su c&amp;oacute;digo, as&amp;iacute; como contratos con c&amp;oacute;digo fuera de su proyecto.</target>
        </trans-unit>
        <trans-unit id="c757d0f6603eddb47aa6c55cbe608a6509f704fb" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural typing&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">Uno de los usos más comunes de las interfaces en lenguajes como C#y Java,el de hacer cumplir explícitamente que una clase cumple un contrato determinado,también es posible en TypeScript.</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">Una o m&amp;aacute;s asignaciones a &lt;code&gt;window.someName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48a39bde8026af120315f595a3ebaf87946a36c6" translate="yes" xml:space="preserve">
          <source>One style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added are included in the export.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">Un ejemplo de ello es un objeto que actúa tanto como función como objeto,con propiedades adicionales:</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">Una cosa a tener en cuenta es que las aserciones &lt;code&gt;const&lt;/code&gt; antes solo se pueden aplicar inmediatamente en expresiones literales simples.</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">Emite solo archivos de declaraci&amp;oacute;n '.d.ts'.</target>
        </trans-unit>
        <trans-unit id="7c44d3d53fcf28280aed7f275c80df87912e368d" translate="yes" xml:space="preserve">
          <source>Only emit &lt;code&gt;.d.ts&lt;/code&gt; declaration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">Abra &lt;code&gt;greeter.html&lt;/code&gt; en el navegador para ejecutar su primera aplicaci&amp;oacute;n web simple de TypeScript.</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">Abra &lt;strong&gt;Dependencias&amp;gt; Administrar paquetes NuGet&amp;gt; Examinar. &lt;/strong&gt;Busque e instale &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; y &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">Abra su archivo &lt;code&gt;Startup.cs&lt;/code&gt; y edite su funci&amp;oacute;n &lt;code&gt;Configure&lt;/code&gt; para que se vea as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">Option &lt;code&gt;--outDir&lt;/code&gt; duplica la jerarqu&amp;iacute;a de entrada en la salida. El compilador calcula la ra&amp;iacute;z de los archivos de entrada como la ruta com&amp;uacute;n m&amp;aacute;s larga de todos los archivos de entrada; y luego lo usa para replicar toda su subestructura en la salida.</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">Variables de cl&amp;aacute;usula &lt;code&gt;catch&lt;/code&gt; opcionales</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">Encadenamiento opcional</target>
        </trans-unit>
        <trans-unit id="7639a6c68ad000bff451144276aba49f18f3a141" translate="yes" xml:space="preserve">
          <source>Optional Global Usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">Carga del módulo opcional y otros escenarios de carga avanzada</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">Parámetros opcionales y parámetros de descanso</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">Parámetros opcionales en las llamadas de retorno</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">Propiedades opcionales</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">Parámetros opcionales y predeterminados</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">El encadenamiento opcional tambi&amp;eacute;n incluye otras dos operaciones. Primero est&amp;aacute; el &lt;em&gt;acceso al elemento opcional&lt;/em&gt; que act&amp;uacute;a de manera similar a los accesos a propiedades opcionales, pero nos permite acceder a propiedades que no son identificadores (por ejemplo, cadenas arbitrarias, n&amp;uacute;meros y s&amp;iacute;mbolos):</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">El encadenamiento opcional es el &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;n&amp;uacute;mero 16&lt;/a&gt; de nuestro rastreador de problemas. Para el contexto, ha habido m&amp;aacute;s de 23,000 problemas en el rastreador de problemas de TypeScript desde entonces.</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">Propiedades de clase opcionales</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">Elementos opcionales en los tipos de tupla</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">Elementos opcionales en los tipos de tupla.</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">Parámetros y propiedades opcionales</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">Los par&amp;aacute;metros y propiedades opcionales se agregan autom&amp;aacute;ticamente &lt;code&gt;undefined&lt;/code&gt; a sus tipos, incluso cuando sus anotaciones de tipo no incluyen espec&amp;iacute;ficamente &lt;code&gt;undefined&lt;/code&gt; . Por ejemplo, los dos tipos siguientes son id&amp;eacute;nticos:</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">Las propiedades y métodos opcionales pueden ahora ser declarados en clases,de manera similar a lo que ya se permite en las interfaces.</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">Opcional: abra &lt;code&gt;greeter.ts&lt;/code&gt; en Visual Studio o copie el c&amp;oacute;digo en el &amp;aacute;rea de juegos de TypeScript. Puede colocar el cursor sobre los identificadores para ver sus tipos. Tenga en cuenta que, en algunos casos, estos tipos se infieren autom&amp;aacute;ticamente. Vuelva a escribir la &amp;uacute;ltima l&amp;iacute;nea y vea las listas de finalizaci&amp;oacute;n y la ayuda de los par&amp;aacute;metros seg&amp;uacute;n los tipos de elementos DOM. Coloque el cursor en la referencia a la funci&amp;oacute;n de bienvenida y presione F12 para ir a su definici&amp;oacute;n. Tenga en cuenta tambi&amp;eacute;n que puede hacer clic con el bot&amp;oacute;n derecho en un s&amp;iacute;mbolo y usar la refactorizaci&amp;oacute;n para cambiarle el nombre.</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">Opcionalmente, un m&amp;oacute;dulo puede envolver uno o m&amp;aacute;s m&amp;oacute;dulos y combinar todas sus exportaciones usando la sintaxis &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df58492b3818e56d4c38cba029dab1a47423cc16" translate="yes" xml:space="preserve">
          <source>Or a number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c98dcc822443a4b856eb1d3e76f5a1ef879a05c5" translate="yes" xml:space="preserve">
          <source>Or by marking each export individually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">O ignorar los elementos que van a la zaga,u otros elementos:</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">O de otros elementos:</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">O podríamos querer una versión de sólo lectura:</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">O simplemente puede usar el tipo de &lt;code&gt;Function&lt;/code&gt; no especificado :</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">O,incluso,ajustar manualmente todos los valores en el enum:</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">O, podr&amp;iacute;amos describir la funci&amp;oacute;n de identidad usando &lt;code&gt;any&lt;/code&gt; tipo:</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">Tipos de organización</target>
        </trans-unit>
        <trans-unit id="62cda73390e4d48b545b79bfcdb477a68054f2e3" translate="yes" xml:space="preserve">
          <source>Other important TypeScript types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">Otros tipos de Closure también funcionan:</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">También se permiten otras variantes:</target>
        </trans-unit>
        <trans-unit id="9840b9a741b28ca4c8860ce6d87a0177a3a2e4c4" translate="yes" xml:space="preserve">
          <source>Otherwise</source>
          <target state="translated">Otherwise</target>
        </trans-unit>
        <trans-unit id="f12741a8f50c8d0742198f4cc7b9b0054355cfbe" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">De lo contrario, use la opci&amp;oacute;n del compilador &lt;code&gt;--keyofStringsOnly&lt;/code&gt; para deshabilitar el nuevo comportamiento.</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">De lo contrario,la condición depende de una o más variables de tipo y el tipo condicional se aplaza.</target>
        </trans-unit>
        <trans-unit id="2fe09ba85c2f62b83a765f71cc1cff43f6cbaef7" translate="yes" xml:space="preserve">
          <source>Otherwise, these functions accept any arguments and will return &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">De lo contrario, asumimos que ya est&amp;aacute; usando &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; con &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a8d8f3092b4cff717b9df2b61723845c6880cb0" translate="yes" xml:space="preserve">
          <source>Otherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the &lt;code&gt;@types&lt;/code&gt; organization on npm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">Nuestra primera interfaz</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">Nuestro paquete expone declaraciones de cada uno de ellos, por lo que cualquier usuario de nuestro &lt;code&gt;browserify-typescript-extension&lt;/code&gt; necesita tener estas dependencias tambi&amp;eacute;n. Por esa raz&amp;oacute;n, usamos &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; y no &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; , porque de lo contrario nuestros consumidores habr&amp;iacute;an necesitado instalar manualmente esos paquetes. Si acab&amp;aacute;bamos de escribir una aplicaci&amp;oacute;n de l&amp;iacute;nea de comandos y no esper&amp;aacute;bamos que nuestro paquete se usara como biblioteca, podr&amp;iacute;amos haber usado &lt;code&gt;devDependencies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be54203007d8d30f26947bb7d7851872869089d" translate="yes" xml:space="preserve">
          <source>Out - &lt;code&gt;out&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdf8d59b6859bfc492a315ea8318c5d9803cadf" translate="yes" xml:space="preserve">
          <source>Out Dir - &lt;code&gt;outDir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a751e953fed78cf12f40a39506ec48371ed775" translate="yes" xml:space="preserve">
          <source>Out File - &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">Extensión del archivo de salida</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">Directorio de salida para los archivos de declaración generados.</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">Generación de salida</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">Fuera de los archivos &lt;code&gt;.tsx&lt;/code&gt; , tambi&amp;eacute;n se puede utilizar la sintaxis de aserci&amp;oacute;n de corchetes angulares.</target>
        </trans-unit>
        <trans-unit id="c9668372e49b3da9f21e77e4a98e554bc74a9a36" translate="yes" xml:space="preserve">
          <source>Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript&amp;rsquo;s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">Estructura general</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">Función sobrecargada</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">Funciones sobrecargadas</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">Sobrecargas y retrollamadas</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3db8119e7d2abacd7ddc5a64f7223117366fcdc7" translate="yes" xml:space="preserve">
          <source>Package.json</source>
          <target state="translated">Package.json</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">Los paquetes de la organizaci&amp;oacute;n &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; se publican autom&amp;aacute;ticamente desde &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; utilizando la &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;herramienta de editor de tipos&lt;/a&gt; . Para que sus declaraciones se publiquen como un paquete @types, env&amp;iacute;e una solicitud de extracci&amp;oacute;n a &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt; . Puede encontrar m&amp;aacute;s detalles en la &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;p&amp;aacute;gina de pautas de contribuci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84bd5a555866968aa5aa6d7b7d92dc740334b9d1" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">Declaraciones dependientes de los embalajes</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">Decoradores de parámetros</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">Propiedades de los parámetros</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">Las propiedades de los par&amp;aacute;metros se declaran prefijando un par&amp;aacute;metro de constructor con un modificador de accesibilidad o &lt;code&gt;readonly&lt;/code&gt; , o ambos. El uso de &lt;code&gt;private&lt;/code&gt; para una propiedad de par&amp;aacute;metro declara e inicializa un miembro privado; Asimismo, se hace lo mismo para &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; y de &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">La declaraci&amp;oacute;n de par&amp;aacute;metros con nombres que comienzan con &lt;code&gt;_&lt;/code&gt; est&amp;aacute;n exentas de la verificaci&amp;oacute;n de par&amp;aacute;metros no utilizados. p.ej:</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">Analiza en modo estricto y emite &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; para cada archivo fuente</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">Analiza todo el código en modo estricto.</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">Parte de la intenci&amp;oacute;n con los proyectos compuestos ( &lt;code&gt;tsconfig.json&lt;/code&gt; s con &lt;code&gt;composite&lt;/code&gt; establecido en &lt;code&gt;true&lt;/code&gt; ) es que las referencias entre diferentes proyectos se pueden construir de forma incremental. Como tal, los proyectos compuestos &lt;strong&gt;siempre&lt;/strong&gt; producir&amp;aacute;n archivos &lt;code&gt;.tsbuildinfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b5be6f8582750be194de793f18c152404f2f31a1" translate="yes" xml:space="preserve">
          <source>Pass it an element id string and it will return either &lt;code&gt;HTMLElement&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; . This method introduces one of the most important types, &lt;code&gt;HTMLElement&lt;/code&gt;. It serves as the base interface for every other element interface. For example, the &lt;code&gt;p&lt;/code&gt; variable in the code example is of type &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. Also take note that this method can return &lt;code&gt;null&lt;/code&gt;. This is because the method can&amp;rsquo;t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new &lt;em&gt;optional chaining&lt;/em&gt; operator is used in order to call &lt;code&gt;appendChild&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">Pasar &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; junto con &lt;code&gt;--jsx react&lt;/code&gt; permite usar una f&amp;aacute;brica JSX diferente de la predeterminada &lt;code&gt;React&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">Mapeo de senderos</target>
        </trans-unit>
        <trans-unit id="a3a3e9569fa3eb5fb1f186e97032bcfd280061ac" translate="yes" xml:space="preserve">
          <source>Paths - &lt;code&gt;paths&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">Los patrones que se sabe que NO se apoyan</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">Las fábricas JSX por archivo</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">Realice verificaciones adicionales para asegurarse de que la compilaci&amp;oacute;n separada (como con &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescript&lt;/a&gt; ) sea segura.</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">Mejoras en el rendimiento</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">Los peligros de los espacios de nombres y los módulos</target>
        </trans-unit>
        <trans-unit id="b9fa3258f08647142ce462aa1c6002ef1e1b8662" translate="yes" xml:space="preserve">
          <source>Platform specific</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">Tenga en cuenta que el compilador no incluye archivos que puedan ser posibles salidas; por ejemplo, si la entrada incluye &lt;code&gt;index.ts&lt;/code&gt; , entonces se &lt;code&gt;index.d.ts&lt;/code&gt; e &lt;code&gt;index.js&lt;/code&gt; . En general, no se recomienda tener archivos que solo difieran en extensi&amp;oacute;n uno al lado del otro.</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">Tenga en cuenta que este comentario solo suprime el informe de errores y le recomendamos que utilice estos comentarios &lt;em&gt;con moderaci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">Tenga en cuenta que esto requiere una &lt;code&gt;Symbol.iterator&lt;/code&gt; nativa de Symbol.iterator o &lt;code&gt;Symbol.iterator&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n para cualquier valor que no sea de matriz.</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">Tengan en cuenta que el ts-loader no es el único cargador para la escritura.</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que las &lt;code&gt;&quot;paths&quot;&lt;/code&gt; se resuelven en relaci&amp;oacute;n con &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; . Cuando se establece &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; en un valor diferente a &lt;code&gt;&quot;.&quot;&lt;/code&gt; , es decir, el directorio de &lt;code&gt;tsconfig.json&lt;/code&gt; , las asignaciones deben cambiarse en consecuencia. Digamos que establece &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; en el ejemplo anterior, luego jquery debe asignarse a &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ee1de1fe598e71ad53be227754dfcb283d7c826" translate="yes" xml:space="preserve">
          <source>Plugins - &lt;code&gt;plugins&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d901da355d2ea7de032bab6160e7791b0cc0d9bd" translate="yes" xml:space="preserve">
          <source>Point-free programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6adebfdf8f61c41e82811b81640f526a81d347" translate="yes" xml:space="preserve">
          <source>Point-free programming &amp;mdash; heavy use of currying and function composition &amp;mdash; is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you&amp;rsquo;ll end up specifying type parameters instead of value parameters. The result is so verbose that it&amp;rsquo;s usually better to avoid point-free programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">Polim&amp;oacute;rfico &lt;code&gt;this&lt;/code&gt; tipo</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">Los polimórficos de este tipo</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">Los posibles valores son:</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">El sufijo es igual a un tipo de propiedad en un tipo de objeto literal no especifica una propiedad opcional:</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">Tipos condicionales predefinidos</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">Anteponer un proyecto incluir&amp;aacute; el resultado del proyecto por encima del resultado del proyecto actual. Esto funciona tanto para archivos &lt;code&gt;.js&lt;/code&gt; como para archivos &lt;code&gt;.d.ts&lt;/code&gt; , y los archivos de mapas de origen tambi&amp;eacute;n se emitir&amp;aacute;n correctamente.</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">Preprocesamiento de los archivos de entrada</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="3718a89b87a1c09f9d2b2ab9ae6694d53dd18a75" translate="yes" xml:space="preserve">
          <source>Preserve Const Enums - &lt;code&gt;preserveConstEnums&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144537ff5fbb1fe2e7112d7a59fca5f0abb8a715" translate="yes" xml:space="preserve">
          <source>Preserve Symlinks - &lt;code&gt;preserveSymlinks&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e1ce16ca2c523a57cb24a6559708ada861d29c" translate="yes" xml:space="preserve">
          <source>Preserve Watch Output - &lt;code&gt;preserveWatchOutput&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f0d63b565582e80417d45fc9ee92a490e7a966" translate="yes" xml:space="preserve">
          <source>Preserve: &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">M&amp;aacute;s bonita &lt;code&gt;--pretty&lt;/code&gt; de salida</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">Mensajes de error m&amp;aacute;s bonitos de &lt;code&gt;tsc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7570791dbea8739420c045a800b27168c94bfd74" translate="yes" xml:space="preserve">
          <source>Pretty - &lt;code&gt;pretty&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">Prevención de conflictos de nombres</target>
        </trans-unit>
        <trans-unit id="f3be47e0536b2f1e3942d188698143c3820e4e15" translate="yes" xml:space="preserve">
          <source>Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">Anteriormente,los módulos JS/AMD/UMD se trataban de la misma manera que los módulos ES6,lo que provocaba un par de problemas.A saber:</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">Anteriormente un error, ahora compatible con TypeScript 1.8. &lt;code&gt;let&lt;/code&gt; declaraciones let / &lt;code&gt;const&lt;/code&gt; dentro de bucles y capturadas en funciones ahora se emiten para coincidir correctamente con la sem&amp;aacute;ntica de frescura &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">Anteriormente marcado como una combinaci&amp;oacute;n de indicadores no v&amp;aacute;lida, &lt;code&gt;target: es5&lt;/code&gt; y 'module: es6' ahora son compatibles. Esto deber&amp;iacute;a facilitar el uso de vibradores de &amp;aacute;rboles basados ​​en ES2015 como &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">Anteriormente, los generadores solo eran compatibles si el objetivo era ES6 / ES2015 o posterior. Adem&amp;aacute;s, las construcciones que operan en el protocolo &lt;code&gt;for..of&lt;/code&gt; , por ejemplo, for..of , solo se admiten si operan en matrices para objetivos por debajo de ES6 / ES2015.</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">Anteriormente, el tipo de una variable &lt;code&gt;for..in&lt;/code&gt; se infiere a &lt;code&gt;any&lt;/code&gt; ; eso permiti&amp;oacute; al compilador ignorar usos inv&amp;aacute;lidos dentro del cuerpo de &lt;code&gt;for..in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">Antes había dos opciones:</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">Anteriormente, el tipo &lt;code&gt;{}&lt;/code&gt; se infiri&amp;oacute; para &lt;code&gt;obj&lt;/code&gt; y la segunda l&amp;iacute;nea posteriormente caus&amp;oacute; un error porque &lt;code&gt;obj&lt;/code&gt; parecer&amp;iacute;a no tener propiedades. Eso obviamente no fue ideal.</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">Anteriormente, a un sindicato no discriminado no se le realizar&amp;iacute;a &lt;em&gt;ninguna&lt;/em&gt; verificaci&amp;oacute;n de exceso de propiedad en sus miembros y, como resultado, la propiedad del &lt;code&gt;name&lt;/code&gt; escrito incorrectamente se desliz&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Anteriormente, si TypeScript no pod&amp;iacute;a averiguar el tipo de variable, eleg&amp;iacute;a &lt;code&gt;any&lt;/code&gt; tipo.</target>
        </trans-unit>
        <trans-unit id="ebc73e847f1b3cd8d1dfb14f901fe12098f69eb7" translate="yes" xml:space="preserve">
          <source>Previously, this document details the &lt;code&gt;HTMLElement&lt;/code&gt; interface extends from &lt;code&gt;Element&lt;/code&gt; which extends from &lt;code&gt;Node&lt;/code&gt;. In the DOM API there is a concept of &lt;em&gt;children&lt;/em&gt; elements. For example in the following HTML, the &lt;code&gt;p&lt;/code&gt; tags are children of the &lt;code&gt;div&lt;/code&gt; element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">Anteriormente,esta estructura era bastante incómoda de trabajar si se utilizaba un solo archivo tsconfig:</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">Imprime el mensaje de ayuda.</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">Imprime los nombres de los archivos que forman parte de la compilación.</target>
        </trans-unit>
        <trans-unit id="2c60c8260c586544fdf204a6918f732b286ae58d" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b896feedfc6257fcbba34c3460737798c67b71a9" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation to the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">Imprimir los nombres de los archivos generados es parte de la compilación.</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">Imprime la versi&amp;oacute;n del compilador.</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">Antes de 3.3, la construcci&amp;oacute;n de proyectos compuestos usando &lt;code&gt;--build --watch&lt;/code&gt; en realidad no usaba esta infraestructura de observaci&amp;oacute;n de archivos incremental. Una actualizaci&amp;oacute;n en un proyecto en el modo &lt;code&gt;--build --watch&lt;/code&gt; forzar&amp;iacute;a una compilaci&amp;oacute;n completa de ese proyecto, en lugar de determinar qu&amp;eacute; archivos dentro de ese proyecto se vieron afectados.</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">Antes de TypeScript 2.4,en el siguiente ejemplo</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">Antes de TypeScript 2.4, este ejemplo tendr&amp;iacute;a &amp;eacute;xito. Al relacionar los tipos de &lt;code&gt;map&lt;/code&gt; a , TypeScript relacionar&amp;iacute;a bidireccionalmente sus par&amp;aacute;metros (es decir, el tipo de &lt;code&gt;f&lt;/code&gt; ). Al relacionar cada &lt;code&gt;f&lt;/code&gt; , TypeScript tambi&amp;eacute;n relacionar&amp;iacute;a bidireccionalmente el tipo de &lt;em&gt;esos&lt;/em&gt; par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="9c8599d61f9484e744e8b2658bec61eec3a61688" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 3.8, you can import a type using &lt;code&gt;import&lt;/code&gt;. With TypeScript 3.8, you can import a type using the &lt;code&gt;import&lt;/code&gt; statement, or using &lt;code&gt;import type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">Constructores privados y protegidos</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">Los miembros privados y protegidos de una clase afectan su compatibilidad. Cuando se comprueba la compatibilidad de una instancia de una clase, si el tipo de destino contiene un miembro privado, entonces el tipo de origen tambi&amp;eacute;n debe contener un miembro privado que se origin&amp;oacute; en la misma clase. Asimismo, se aplica lo mismo para una instancia con un miembro protegido. Esto permite que una clase sea compatible con la asignaci&amp;oacute;n de su superclase, pero &lt;em&gt;no&lt;/em&gt; con clases de una jerarqu&amp;iacute;a de herencia diferente que de otra manera tienen la misma forma.</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">Los miembros privados y protegidos de las clases</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">Configuración del proyecto</target>
        </trans-unit>
        <trans-unit id="dff8cdae331a987352af975febbbf5bf3497c075" translate="yes" xml:space="preserve">
          <source>Project Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">Referencias del proyecto</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">Referencias del proyecto:Modo de construcción para TypeScript</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">Referencias del proyecto:Caveats</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">Referencias del proyecto:Advertencias para las referencias del proyecto</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">Referencias del proyecto:MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">Referencias del proyecto:Estructura general</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">Referencias del proyecto:Estructuración de archivos externos</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">Referencias del proyecto:Estructuración de los módulos relativos</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">Referencias del proyecto:¿Qué es una referencia de proyecto?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">Referencias del proyecto:composite</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">Referencias del proyecto:declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">Referencias del proyecto:prepárese con outFile</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">Referencias del proyecto:tsc -b Línea de mando</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">Las referencias de proyectos son una nueva característica de TypeScript 3.0 que permite estructurar los programas de TypeScript en piezas más pequeñas.</target>
        </trans-unit>
        <trans-unit id="c138392855d638ba9e2bf29899810a7e57e84035" translate="yes" xml:space="preserve">
          <source>Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">Las referencias de los proyectos pueden resolver todos estos problemas y más.</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">Las referencias de los proyectos tienen algunas compensaciones que debes tener en cuenta.</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">Soporte de proyectos a trav&amp;eacute;s de &lt;code&gt;tsconfig.json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">Las propiedades se infieren de las asignaciones en los cuerpos de clase</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">Declaraciones de propiedades en las funciones</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">Las propiedades en el patrón de unión de objetos que no tienen coincidencia en el literal del objeto deben tener un valor por defecto en el patrón de unión de objetos y se añaden automáticamente al tipo de literal del objeto.</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">Las propiedades en el literal del objeto que no coinciden con el patrón de unión del objeto son un error.</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">Las propiedades con valores por defecto en el patrón de unión de objetos se convierten en opcionales en el literal de objetos.</target>
        </trans-unit>
        <trans-unit id="1af723998a3965fbd8fb5f43c4ba52d973f2b4be" translate="yes" xml:space="preserve">
          <source>Properties with relative paths found in the configuration file, which aren&amp;rsquo;t excluded from inheritance, will be resolved relative to the configuration file they originated in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">Decoradores de propiedades</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">Las cesiones de propiedad y las expresiones de difusión no genéricas se fusionan en la mayor medida posible a ambos lados de una expresión de difusión genérica.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">El renombramiento de la propiedad</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">Asignación del prototipo</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">Brindar soporte completo para iterables en &lt;code&gt;for..of&lt;/code&gt; , spread y desestructuraci&amp;oacute;n cuando se dirigen a ES5 o ES3.</target>
        </trans-unit>
        <trans-unit id="d26fd4d0603b6fec3f71df5845863025dd055f63" translate="yes" xml:space="preserve">
          <source>Providing Type Hints in JS via JSDoc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">Público por defecto</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">Modificadores públicos,privados y protegidos</target>
        </trans-unit>
        <trans-unit id="51ca411182511e3fdf77719b4e3e0c22adc6e606" translate="yes" xml:space="preserve">
          <source>Publish to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">Publicar en &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">Publicar a npm</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">Publicación:Dependencias</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">Publicación:Publicar a @tipos</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">Publicación:Banderas rojas</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">Ponga un punto de ruptura en la línea con retorno.</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">Poniendo todas las reglas anteriores juntas en un ejemplo</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">Poniendo todo junto</target>
        </trans-unit>
        <trans-unit id="c25bd9f882a3a8b49796dbe73c56bf10103c4152" translate="yes" xml:space="preserve">
          <source>Question to ask yourself while looking at a library you are trying to type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f6fe9f8c69850190c5d7fab3738cc93bedaed0" translate="yes" xml:space="preserve">
          <source>Raise error on &amp;lsquo;this&amp;rsquo; expressions with an implied &amp;lsquo;any&amp;rsquo; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Genere un error en &lt;code&gt;this&lt;/code&gt; expresiones con &lt;code&gt;any&lt;/code&gt; tipo impl&amp;iacute;cito .</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Genera error en expresiones y declaraciones con &lt;code&gt;any&lt;/code&gt; tipo impl&amp;iacute;cito .</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">En lugar de ejecutar una construcción con las otras opciones de entrada y los archivos de configuración,mostrar el archivo de configuración final implícito en la salida.</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">Al volver a compilar, ver&amp;aacute; un error:</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">Re-declaraciones y Sombra</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">Reexportación para ampliar</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">Vuelva a ejecutar &lt;code&gt;tsc greeter.ts&lt;/code&gt; y ver&amp;aacute; que el JavaScript generado es el mismo que el c&amp;oacute;digo anterior. Las clases en TypeScript son solo una abreviatura del mismo OO basado en prototipos que se usa con frecuencia en JavaScript.</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">Reaccionar y Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React &amp;amp; Webpack: agregue un archivo de configuraci&amp;oacute;n de TypeScript</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React &amp;amp; Webpack: crea un archivo de configuraci&amp;oacute;n de paquete web</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React &amp;amp; Webpack: inicializa el proyecto</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React &amp;amp; Webpack: Instale nuestras dependencias</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React &amp;amp; Webpack: dise&amp;ntilde;e el proyecto</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React &amp;amp; Webpack: uniendo todo</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React &amp;amp; Webpack: escribe un c&amp;oacute;digo</target>
        </trans-unit>
        <trans-unit id="7f185bfe20f1f619f8c9bb6aa99786b71328866a" translate="yes" xml:space="preserve">
          <source>React 17 dev transform: &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d97070f74a67941c76e5ea64885d0e08627efa5" translate="yes" xml:space="preserve">
          <source>React 17 transform: &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4b21d845bd34b4e6b6216731b5271028fb8f60" translate="yes" xml:space="preserve">
          <source>React Namespace - &lt;code&gt;reactNamespace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa58cb746f54f27aa90a8d689bba8023af13c2bb" translate="yes" xml:space="preserve">
          <source>React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">Reaccionar la integración</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">La canalizaci&amp;oacute;n de compilaci&amp;oacute;n nativa de React espera que todos los archivos tengan una extensi&amp;oacute;n &lt;code&gt;.js&lt;/code&gt; incluso si el archivo contiene sintaxis JSX. El nuevo valor &lt;code&gt;--jsx&lt;/code&gt; &lt;code&gt;react-native&lt;/code&gt; mantendr&amp;aacute; la sintaxis JSX en el archivo de salida, pero le dar&amp;aacute; una extensi&amp;oacute;n &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab19aed84f407a0ba739f934e0edb923766280c" translate="yes" xml:space="preserve">
          <source>Read and understand commonly-used TypeScript syntax and patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">Lea cualquier archivo que comprenda en el directorio &lt;code&gt;src&lt;/code&gt; (con &lt;code&gt;include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc4702822c3373e5ee67caa1dc26cc74db6df18f" translate="yes" xml:space="preserve">
          <source>Read the full Handbook &lt;a href=&quot;intro&quot;&gt;from start to finish&lt;/a&gt; (30m)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">Propiedades de sólo lectura y firmas de índices</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">Las propiedades de sólo lectura pueden tener inicializadores y pueden asignarse en constructores dentro de la misma declaración de clase,pero por lo demás no se permiten las asignaciones a propiedades de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">Modificador de sólo lectura</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">Propiedades de sólo lectura</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">¿Listo? Echa un vistazo:</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">Las aplicaciones reales, sin embargo, se ven como &lt;code&gt;Readonly&lt;/code&gt; o &lt;code&gt;Partial&lt;/code&gt; arriba. Se basan en alg&amp;uacute;n tipo existente y transforman las propiedades de alguna manera. Ah&amp;iacute; es donde &lt;code&gt;keyof&lt;/code&gt; en juego los tipos de acceso keyof e indexado:</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">Recuerda cómo escribir una afirmación tipográfica:</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">Recuerde que Node.js busc&amp;oacute; un archivo llamado &lt;code&gt;moduleB.js&lt;/code&gt; , luego un &lt;code&gt;package.json&lt;/code&gt; aplicable y luego un &lt;code&gt;index.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">Recuerde que con nuestro ejemplo anterior de &lt;code&gt;setTimeout&lt;/code&gt; , terminamos necesitando usar un IIFE para capturar el estado de una variable para cada iteraci&amp;oacute;n del ciclo &lt;code&gt;for&lt;/code&gt; . En efecto, lo que est&amp;aacute;bamos haciendo era crear un nuevo entorno de variables para nuestras variables capturadas. Eso fue un poco molesto, pero afortunadamente, nunca tendr&amp;aacute;s que volver a hacer eso en TypeScript.</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="9ef937556efe782b8e9bf8ef16e540c185c5bf00" translate="yes" xml:space="preserve">
          <source>Recommended</source>
          <target state="translated">Recommended</target>
        </trans-unit>
        <trans-unit id="2d40a3d4b23c33dba91182fa7193e3bc8d084647" translate="yes" xml:space="preserve">
          <source>Recommended:</source>
          <target state="translated">Recommended:</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">Banderas rojas</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">Banderas rojas</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">Redirige la estructura de salida al directorio.</target>
        </trans-unit>
        <trans-unit id="f70cca9ad50ad5b8ed87a8010b088c10db5dda71" translate="yes" xml:space="preserve">
          <source>Reference Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">Los proyectos referenciados deben tener habilitada la nueva configuraci&amp;oacute;n &lt;code&gt;composite&lt;/code&gt; . Esta configuraci&amp;oacute;n es necesaria para garantizar que TypeScript pueda determinar r&amp;aacute;pidamente d&amp;oacute;nde encontrar los resultados del proyecto referenciado. Habilitar la bandera &lt;code&gt;composite&lt;/code&gt; cambia algunas cosas:</target>
        </trans-unit>
        <trans-unit id="4d6f89c160b09f2d6743dec6ea31f5aef184e7a5" translate="yes" xml:space="preserve">
          <source>References - &lt;code&gt;references&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7e105e2839b4e1b747e4c6dae363b4ac3c64d8" translate="yes" xml:space="preserve">
          <source>References to &lt;code&gt;const enum&lt;/code&gt; members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">Hacer referencia a objetos en el espacio de valores como tipos no funciona a menos que el objeto tambi&amp;eacute;n cree un tipo, como una funci&amp;oacute;n de constructor.</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">Los caminos relativos son bastante sencillos. Como ejemplo, consideremos un archivo ubicado en &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; , que contiene la importaci&amp;oacute;n &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resuelve esa importaci&amp;oacute;n en el siguiente orden:</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">Importaciones de módulos relativos vs.no relativos</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">Las declaraciones relajadas emiten reglas de visibilidad</target>
        </trans-unit>
        <trans-unit id="9811fea8059729e6e608294e42cacce36d4ff09d" translate="yes" xml:space="preserve">
          <source>Released:</source>
          <target state="translated">Released:</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">&amp;iquest;Recuerda lo que mencionamos anteriormente sobre la captura de variables? Cada expresi&amp;oacute;n de funci&amp;oacute;n que pasamos a &lt;code&gt;setTimeout&lt;/code&gt; en realidad se refiere a la misma &lt;code&gt;i&lt;/code&gt; del mismo &amp;aacute;mbito.</target>
        </trans-unit>
        <trans-unit id="4ae2f2f99c6da082f0672c95b34c59cd80c40a24" translate="yes" xml:space="preserve">
          <source>Remove Comments - &lt;code&gt;removeComments&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">&amp;iexcl;Elimine todos los comentarios, excepto los comentarios de encabezado de copy-right que comienzan con &lt;code&gt;/*!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">Elimina el par&amp;aacute;metro 'this' de un tipo de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d619a6862a4f7b32d4a58f285cc5c61b509d1673" translate="yes" xml:space="preserve">
          <source>Removes the &lt;a href=&quot;functions#this-parameters&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; parameter from &lt;code&gt;Type&lt;/code&gt;. If &lt;code&gt;Type&lt;/code&gt; has no explicitly declared &lt;code&gt;this&lt;/code&gt; parameter, the result is simply &lt;code&gt;Type&lt;/code&gt;. Otherwise, a new function type with no &lt;code&gt;this&lt;/code&gt; parameter is created from &lt;code&gt;Type&lt;/code&gt;. Generics are erased and only the last overload signature is propagated into the new function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">Reemplace el contenido del archivo &lt;code&gt;tsconfig.json&lt;/code&gt; con:</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">Informar de un error cuando no todas las rutas de código en la función devuelven un valor.</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">Informe de errores para los casos de fallos en la declaración del interruptor.</target>
        </trans-unit>
        <trans-unit id="28ff576f8c9a47a52a73ccec4dfa5490f20abc5a" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. This means you won&amp;rsquo;t accidentally ship a case fallthrough bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">Informar errores en archivos &lt;code&gt;.js&lt;/code&gt; . &amp;Uacute;selo junto con &lt;code&gt;--allowJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9859c2bfd11829e29389ef6176aef839ff246a67" translate="yes" xml:space="preserve">
          <source>Report errors on unused local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">Informar de los errores en los locales no utilizados.</target>
        </trans-unit>
        <trans-unit id="c070f2ba00c2432442f5870f3f9104c630e23e08" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters in functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters.</source>
          <target state="translated">Informar de los errores en los parámetros no utilizados.</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes" xml:space="preserve">
          <source>Report module resolution log messages.</source>
          <target state="translated">Informe de los mensajes de registro de la resolución del módulo.</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes" xml:space="preserve">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target state="translated">Los parámetros de tipo requeridos no deben seguir a los parámetros de tipo opcionales.</target>
        </trans-unit>
        <trans-unit id="6b52890a8d8bb281f971e8b6c6fc68eebe6bbc98" translate="yes" xml:space="preserve">
          <source>Required&amp;lt;T&amp;gt;</source>
          <target state="translated">Required&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes" xml:space="preserve">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target state="translated">Los par&amp;aacute;metros obligatorios, opcionales y predeterminados tienen una cosa en com&amp;uacute;n: hablan de un par&amp;aacute;metro a la vez. A veces, desea trabajar con varios par&amp;aacute;metros como un grupo, o puede que no sepa cu&amp;aacute;ntos par&amp;aacute;metros tomar&amp;aacute; finalmente una funci&amp;oacute;n. En JavaScript, puede trabajar con los argumentos directamente usando la variable de &lt;code&gt;arguments&lt;/code&gt; que est&amp;aacute; visible dentro de cada cuerpo de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6f3ece0cdbc888dc6e6e500ee3d259d041d3cdae" translate="yes" xml:space="preserve">
          <source>Requires either &lt;code&gt;sourceMap&lt;/code&gt; or &lt;code&gt;inlineSourceMap&lt;/code&gt; to be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes" xml:space="preserve">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target state="translated">Resuelva la &lt;code&gt;keyof&lt;/code&gt; de solo nombres de propiedades con valores de cadena (sin n&amp;uacute;meros ni s&amp;iacute;mbolos).</target>
        </trans-unit>
        <trans-unit id="6500c452861f317427f27ca99511d2efa2c4566a" translate="yes" xml:space="preserve">
          <source>Resolve JSON Module - &lt;code&gt;resolveJsonModule&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">Parámetros de descanso</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types</source>
          <target state="translated">Elementos de descanso en tipos de tupla</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types.</source>
          <target state="translated">Elementos de descanso en tipos de tupla.</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes" xml:space="preserve">
          <source>Rest parameters with tuple types</source>
          <target state="translated">Parámetros de descanso con tipos de tupla</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes" xml:space="preserve">
          <source>Results in an output such as:</source>
          <target state="translated">Resulta en una salida como:</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes" xml:space="preserve">
          <source>Results in the following generated code:</source>
          <target state="translated">Resulta en el siguiente código generado:</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">Resultados:</target>
        </trans-unit>
        <trans-unit id="acde6ca95b6974ed08c6f806127b9ecb63b7289c" translate="yes" xml:space="preserve">
          <source>Rethinking Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854f4c1b2de1f042fed1a2f43dfb41e328c62875" translate="yes" xml:space="preserve">
          <source>Rethinking the Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes" xml:space="preserve">
          <source>Return Types of Callbacks</source>
          <target state="translated">Tipos de devolución de llamadas</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes" xml:space="preserve">
          <source>Return types as inference targets</source>
          <target state="translated">Los tipos de retorno como objetivos de inferencia</target>
        </trans-unit>
        <trans-unit id="af8759585cf2cfe7a7c8a45a7ecabdbfd11cd2db" translate="yes" xml:space="preserve">
          <source>ReturnType&amp;lt;T&amp;gt;</source>
          <target state="translated">ReturnType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes" xml:space="preserve">
          <source>Reusable Types (Interfaces)</source>
          <target state="translated">Tipos reutilizables (Interfaces)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes" xml:space="preserve">
          <source>Reusable Types (Type Aliases)</source>
          <target state="translated">Tipos reutilizables (alias de tipos)</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes" xml:space="preserve">
          <source>Reverse mappings</source>
          <target state="translated">Mapeo inverso</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes" xml:space="preserve">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target state="translated">Haga clic derecho en los &lt;code&gt;scripts&lt;/code&gt; y haga clic en &lt;strong&gt;Nuevo elemento&lt;/strong&gt; . Luego elija &lt;strong&gt;Archivo TypeScript&lt;/strong&gt; y nombre el archivo &lt;code&gt;app.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target state="translated">Haga clic con el bot&amp;oacute;n derecho en la carpeta &lt;code&gt;wwwroot&lt;/code&gt; (si no ve la carpeta, intente crear el proyecto) y agregue un elemento nuevo llamado &lt;code&gt;index.html&lt;/code&gt; dentro. Utilice el siguiente c&amp;oacute;digo para &lt;code&gt;index.html &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77c4e77f51ec4dad132664992b8975f2dfbe92c9" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes" xml:space="preserve">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">Haga clic derecho en el proyecto y haga clic en &lt;strong&gt;Nuevo elemento&lt;/strong&gt; . Luego elija &lt;strong&gt;Archivo JavaScript&lt;/strong&gt; y use el nombre de &lt;code&gt;gulpfile.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes" xml:space="preserve">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target state="translated">Haga clic con el bot&amp;oacute;n derecho -&amp;gt; Administrar paquetes NuGet</target>
        </trans-unit>
        <trans-unit id="4404226825fd8913da119eed59015272595b178d" translate="yes" xml:space="preserve">
          <source>Root Dir - &lt;code&gt;rootDir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46607474e45e56af8b5a3efd5baf9b86a8244110" translate="yes" xml:space="preserve">
          <source>Root Dirs - &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5045f031d11028d3e898f4dd9c0e8f030ca21936" translate="yes" xml:space="preserve">
          <source>Root Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49cce94f7aee86f9844fd38022767d62fef80bd" translate="yes" xml:space="preserve">
          <source>Roughly speaking, once TypeScript&amp;rsquo;s compiler is done with checking your code, it &lt;em&gt;erases&lt;/em&gt; the types to produce the resulting &amp;ldquo;compiled&amp;rdquo; code. This means that once your code is compiled, the resulting plain JS code has no type information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target state="translated">Ejecute &lt;code&gt;tsc --init&lt;/code&gt; en un directorio para crear un &lt;code&gt;tsconfig.json&lt;/code&gt; inicial en este directorio con los valores predeterminados. Opcionalmente, pase los argumentos de la l&amp;iacute;nea de comando junto con &lt;code&gt;--init&lt;/code&gt; para que se almacenen en su tsconfig.json inicial en la creaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9aa34d67108614684377b79ebc1738ed47fa9c79" translate="yes" xml:space="preserve">
          <source>Run the TypeScript compiler to generate the corresponding d.ts files for JS files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes" xml:space="preserve">
          <source>Run the application and make sure that it works.</source>
          <target state="translated">Ejecute la aplicación y asegúrese de que funciona.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
