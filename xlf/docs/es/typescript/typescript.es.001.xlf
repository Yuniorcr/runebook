<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="07f99178b48153ac4d4332687d20d728a7c8bfd4" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2019 Microsoft</source>
          <target state="translated">&amp;copy; 2012-2019 Microsoft</target>
        </trans-unit>
        <trans-unit id="30e2637a4121a97d6d63991f19ff28a13222931e" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2020 Microsoft</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb191ccf7512349b3d99757bc9535f48ae81c17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</source>
          <target state="translated">Las &quot;declaraciones predeterminadas&quot; permiten inicializadores que hacen referencia al nombre declarado en el lado izquierdo de una l&amp;oacute;gica o:</target>
        </trans-unit>
        <trans-unit id="f1fdafe04dd11ea1809cd2cc0c324b66f3a11b35" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</source>
          <target state="translated">&quot;Normas</target>
        </trans-unit>
        <trans-unit id="0a462d0a363472f89aab32695c02164466ca6a9c" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;main&amp;rdquo;:&amp;ldquo;./dist/index.js&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;main&amp;rdquo;:&amp;ldquo;./dist/index.js&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a7a19458753d64363353ed730635e775ee136020" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;main&amp;rdquo;:&amp;ldquo;index.js&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;main&amp;rdquo;:&amp;ldquo;index.js&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="77f022a953afe741cc802b7587833dd3652f325c" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;types&amp;rdquo;: &amp;ldquo;./dist/main.js&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80dbbfebc33b03e9a8e299b3392e1bc5e89f27da" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;types&amp;rdquo;: &amp;ldquo;main.d.ts&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d479e429a32f573b7b23a67a8995da08eed47d" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</source>
          <target state="translated">'cl&amp;aacute;sico': reglas de resoluci&amp;oacute;n del m&amp;oacute;dulo utilizadas por el compilador TypeScript anterior a 1.6</target>
        </trans-unit>
        <trans-unit id="61c51288c27e2cc818fba1bd491d412143391547" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;node&amp;rsquo; - node-like module resolution</source>
          <target state="translated">'nodo' - resoluci&amp;oacute;n de m&amp;oacute;dulo similar a un nodo</target>
        </trans-unit>
        <trans-unit id="4547d63b41d1c75d2e1b5085da19d735e8dc595e" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</source>
          <target state="translated">'package.json' tiene &lt;strong&gt;'tipos'&lt;/strong&gt; campo './lib/typescript.d.ts' que hace referencia a 'node_modules / typescript / lib / typescript.d.ts'.</target>
        </trans-unit>
        <trans-unit id="ee44c32e65bc4a9d7773f18d0e20e44810833a3f" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-dependency /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-dependencia /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="934f0cd8be7ed1f9b7b8079909795f738f732556" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-module /&amp;gt;</source>
          <target state="translated">&amp;lt;m&amp;oacute;dulo-amd /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cd4898dc828f34abf0dca9dabec02736d522eceb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference lib = &quot;...&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="62141bcfe5cfcd51fc1a320d36520899bc9edd5f" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</source>
          <target state="translated">&amp;lt;referencia no-default-lib = &quot;true&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21029c886af7dc459626422aa0c5b6ca11e413cb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;ruta de referencia = &quot;...&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="120613f8d21d190c622bf610b91d69083361e489" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;tipos de referencia = &quot;...&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="105733a69ca97c742b5246c8891283fb75ef628c" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference&amp;gt;-ing a module</source>
          <target state="translated">&amp;lt;referencia&amp;gt; -ing un m&amp;oacute;dulo</target>
        </trans-unit>
        <trans-unit id="ccfac08210ff156925b259cf9224a7d62ab98fc8" translate="yes" xml:space="preserve">
          <source>(More) Recursive Type Aliases</source>
          <target state="translated">(M&amp;aacute;s) Alias ​​de tipo recursivo</target>
        </trans-unit>
        <trans-unit id="9c306edcd7029e4d6802fe5b57d73e67c702ff8a" translate="yes" xml:space="preserve">
          <source>(optional) Edit your package.json to reference the types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b244b1f4cdc07410d73db6d8271fb3aede63b0" translate="yes" xml:space="preserve">
          <source>*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</source>
          <target state="translated">* Nota: Puede especificar la funci&amp;oacute;n de f&amp;aacute;brica JSX que se utilizar&amp;aacute; al apuntar a react JSX &lt;code&gt;--jsxFactory&lt;/code&gt; con la opci&amp;oacute;n --jsxFactory (el valor predeterminado es &lt;code&gt;React.createElement&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fb61c992209f91996318a06868699d18ec06bb49" translate="yes" xml:space="preserve">
          <source>./dist/index.d.ts</source>
          <target state="translated">./dist/index.d.ts</target>
        </trans-unit>
        <trans-unit id="7d54547932b925cb04c81035e7676fa6182e3b7e" translate="yes" xml:space="preserve">
          <source>./main/main.d.ts</source>
          <target state="translated">./main/main.d.ts</target>
        </trans-unit>
        <trans-unit id="bcac7464521b8c19a2372c739f6dc9e9ab7dfc80" translate="yes" xml:space="preserve">
          <source>.babelrc</source>
          <target state="translated">.babelrc</target>
        </trans-unit>
        <trans-unit id="bdbc9a553b902daccdcb974134663c5cbb048999" translate="yes" xml:space="preserve">
          <source>1 - greeting: Mandatory string</source>
          <target state="translated">1-saludo:Cadena obligatoria</target>
        </trans-unit>
        <trans-unit id="13d790ef091c0d678928628f711d3a342ed79fdc" translate="yes" xml:space="preserve">
          <source>2 - duration: Optional length of time (in milliseconds)</source>
          <target state="translated">2-duración:Duración opcional (en milisegundos)</target>
        </trans-unit>
        <trans-unit id="ecb356c6c25d42fb0b2006e35569ce371868ed08" translate="yes" xml:space="preserve">
          <source>3 - color: Optional string, e.g. &amp;lsquo;#ff00ff&amp;rsquo;</source>
          <target state="translated">3 - color: cadena opcional, por ejemplo, '# ff00ff'</target>
        </trans-unit>
        <trans-unit id="dd1f243849fa29b29355c96a02e0cba354d5a774" translate="yes" xml:space="preserve">
          <source>3.7 API Changes</source>
          <target state="translated">3.7 Cambios en el API</target>
        </trans-unit>
        <trans-unit id="c2dbed9bb17a5c2fdd2db0b9dd5844f947a20c89" translate="yes" xml:space="preserve">
          <source>3.7 Breaking Changes</source>
          <target state="translated">3.7 Romper los cambios</target>
        </trans-unit>
        <trans-unit id="f93d8407b2959853084d09f0c851bf5d0e08f0b6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#allowJs&quot;&gt;&lt;code&gt;allowJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8964ae98596ed53789c768e5ec7b3994c6c70f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#alwaysStrict&quot;&gt;&lt;code&gt;alwaysStrict&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictNullChecks&quot;&gt;&lt;code&gt;strictNullChecks&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictBindCallApply&quot;&gt;&lt;code&gt;strictBindCallApply&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictFunctionTypes&quot;&gt;&lt;code&gt;strictFunctionTypes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictPropertyInitialization&quot;&gt;&lt;code&gt;strictPropertyInitialization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitAny&quot;&gt;&lt;code&gt;noImplicitAny&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitThis&quot;&gt;&lt;code&gt;noImplicitThis&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5eacc0bc20a210ca7f562d1dcc3f9914ec788f8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badedc9fbd49fc64159ae3e3285103c2215b1231" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5c6fc0beafcad83d2b6b97d85ab7a3f4ec9e95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#declarationDir&quot;&gt;&lt;code&gt;declarationDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd29cc36234c4eac24bd08b0eb7f3d7d4f112ffb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddac993a02e1f8c405d537e647fcf6c8af40be8d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d95311b8db4676f55e1e9cc9e97adb0d1405c5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bdfa25010df7871fccc20c32ead1f8e700ec6c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700909c3f1adfc70abc84a37875bd1c7e5f1ffab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12ed2ab3db736413d8125bf80d66ce2f131642f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsdoc-property-modifiers&quot;&gt;Property Modifiers&lt;/a&gt;&lt;code&gt;@public&lt;/code&gt;, &lt;code&gt;@private&lt;/code&gt;, &lt;code&gt;@protected&lt;/code&gt;, &lt;code&gt;@readonly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc6cd42c46b121f604de4e278b03e63d3fc187f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617124b58852d620746b0e2268ef8092a6b18811" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff88d2e32507d449d9725602353414158333ea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56648998908a0672096f6bf781cb50cdcab9a9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f442113fa72aea1d2a309e3551e6bdb58d220c1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#noEmitHelpers&quot;&gt;&lt;code&gt;noEmitHelpers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40f8e7b81466e628cd1d26c0f4d604250df0117" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f38543a8c287d6b6c4baaf9485cbf9c6434afc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841ccc42e3622be2086b39b4485fddb5faa8b194" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d8d7d93cd113005d851de63f1e7f8b91e504d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;As mentioned above&lt;/a&gt;, TypeScript 3.7 emits &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</source>
          <target state="translated">&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;Como se mencion&amp;oacute; anteriormente&lt;/a&gt; , TypeScript 3.7 emite &lt;code&gt;.d.ts&lt;/code&gt; &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; en archivos .d.ts que pueden causar cambios importantes para los consumidores en versiones anteriores de TypeScript como 3.5 y anteriores. Los usuarios de TypeScript 3.6 no se ver&amp;aacute;n afectados, ya que esa versi&amp;oacute;n fue preparada para el futuro para esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1b4fbbd23ecf68cc6d9a635cad72158cb53c80a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 also introduced &amp;ldquo;Generators&amp;rdquo;&lt;/a&gt;, which are functions that can be used to yield partial computation results via the &lt;code&gt;Iterator&lt;/code&gt; interface and the &lt;code&gt;yield&lt;/code&gt; keyword. Generators can also internally delegate calls to another iterable through &lt;code&gt;yield *&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 tambi&amp;eacute;n introdujo &amp;ldquo;Generadores&amp;rdquo;&lt;/a&gt; , que son funciones que se pueden utilizar para producir resultados de c&amp;aacute;lculo parciales a trav&amp;eacute;s de la interfaz &lt;code&gt;Iterator&lt;/code&gt; y la palabra clave &lt;code&gt;yield&lt;/code&gt; . Los generadores tambi&amp;eacute;n pueden delegar llamadas internamente a otro iterable a trav&amp;eacute;s de &lt;code&gt;yield *&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="55463e892e31113c861aadf5f93e77a57de6240a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 introduced &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which is an object that exposes three methods, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt;, as per the following interface:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 introdujo &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , que es un objeto que expone tres m&amp;eacute;todos, &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; , y &lt;code&gt;throw&lt;/code&gt; , seg&amp;uacute;n la siguiente interfaz:</target>
        </trans-unit>
        <trans-unit id="b6333d998c229faa742c2259393328f8ce5717b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.stroustrup.com/4th.html&quot;&gt;The C++ Programming Language&lt;/a&gt; is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: &lt;code&gt;x: string&lt;/code&gt; instead of &lt;code&gt;string x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c522a5a7799016630add0cfdae778f7d5c18f87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/DOM&quot;&gt;DOM&lt;/a&gt; definitions - &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc45d0d18af813393a85ab4e94d2f14b2851e9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Data_structures&quot;&gt;See the MDN page for more detail&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4092c59537e7cf28a262cdff3ec1a8a7b377cf2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;ECMAScript strict&lt;/a&gt; mode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aa33cea9b5a79c35ec84291696eb4b59f9da1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; es una sintaxis similar a XML incrustable. Est&amp;aacute; destinado a transformarse en JavaScript v&amp;aacute;lido, aunque la sem&amp;aacute;ntica de esa transformaci&amp;oacute;n es espec&amp;iacute;fica de la implementaci&amp;oacute;n. JSX gan&amp;oacute; popularidad con el marco &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; , pero desde entonces tambi&amp;eacute;n ha visto otras implementaciones. TypeScript admite la incrustaci&amp;oacute;n, la verificaci&amp;oacute;n de tipos y la compilaci&amp;oacute;n de JSX directamente en JavaScript.</target>
        </trans-unit>
        <trans-unit id="199e55c49a5efe4f7eea9b852e615fbd30d3d039" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Microsoft/typescript-styled-plugin&quot;&gt;typescript-styled-plugin&lt;/a&gt; &amp;mdash; Provides CSS linting inside template strings .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05658a1d8a717f441a947f4b3f5873629b2746f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Quramy/ts-graphql-plugin&quot;&gt;ts-graphql-plugin&lt;/a&gt; &amp;mdash; Provides validation and auto-completion inside GraphQL query template strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1d8571473f401bda993ef5f95107455716e497" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Quramy/typescript-eslint-language-service&quot;&gt;typescript-eslint-language-service&lt;/a&gt; &amp;mdash; Provides eslint error messaging and fix-its inside the compiler&amp;rsquo;s output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef2642d51385f769ab651c082c9dff225d74fc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Types in &lt;code&gt;lib.dom.d.ts&lt;/code&gt; have been updated&lt;/a&gt;. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Tipos de &lt;code&gt;lib.dom.d.ts&lt;/code&gt; se han actualizado&lt;/a&gt; . Estos cambios son en gran parte cambios de correcci&amp;oacute;n relacionados con la nulabilidad, pero el impacto depender&amp;aacute; en &amp;uacute;ltima instancia de su c&amp;oacute;digo base.</target>
        </trans-unit>
        <trans-unit id="0495fdef653ac880036cca0814e7297d71236b4d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD modules&lt;/a&gt; check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Los m&amp;oacute;dulos UMD&lt;/a&gt; comprueban la existencia de un entorno de cargador de m&amp;oacute;dulos. Este es un patr&amp;oacute;n f&amp;aacute;cil de detectar que se parece a esto:</target>
        </trans-unit>
        <trans-unit id="4501968243cb90a3d84dcd45006c29d533b0884d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/xialvjun/ts-sql-plugin#readme&quot;&gt;ts-sql-plugin&lt;/a&gt; &amp;mdash; Adds SQL linting with a template strings SQL builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6483def0fc8c609e15c97336fa075e9de577db1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs&quot;&gt;With TypeScript 3.7&lt;/a&gt;, TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279d25c3bce3f4af13a20f8e97e6c8096c2c8cff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;declaration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd7f9a4260cf4f7a8c5026d67e5c95d711d16e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ volver al principio&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdbdf4e1369a70ccce916824139e46a9847d97a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt; : significa el mismo nombre sin cambios, as&amp;iacute; que &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c73a6525d7eaa4824134e5210d19e488e565b563" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; significa el nombre del m&amp;oacute;dulo con un prefijo agregado &quot;generado&quot;, as&amp;iacute; que &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c85a37d09c2e1af4c5f31661b285d4d1e16f641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</source>
          <target state="translated">&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; es una buena idea siempre que est&amp;eacute; escribiendo un c&amp;oacute;digo nuevo; puede asegurarse de no escribir ning&amp;uacute;n c&amp;oacute;digo sin escribir por error. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; facilita la actualizaci&amp;oacute;n de su c&amp;oacute;digo en una aplicaci&amp;oacute;n web en ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fe58c3912d521e0998db0d63686a8a2d31499624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; especifica una lista de &lt;em&gt;ra&amp;iacute;ces&lt;/em&gt; cuyo contenido se espera que se fusione en tiempo de ejecuci&amp;oacute;n. Entonces, siguiendo nuestro ejemplo, el archivo &lt;code&gt;tsconfig.json&lt;/code&gt; deber&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="60134d0ac283a5c3d28bf080abb92e5b19e8fb5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; matches any directory nested to any level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c3c22aa0fd78209c6c0e383e2528e7c6b4250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</source>
          <target state="translated">&lt;code&gt;**/&lt;/code&gt; coincide de forma recursiva con cualquier subdirectorio</target>
        </trans-unit>
        <trans-unit id="5ff5a342935b5b9c3dc600fb9b3b727885179683" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; coincide con cero o m&amp;aacute;s caracteres (excluidos los separadores de directorio)</target>
        </trans-unit>
        <trans-unit id="8eb69c784cbac9dae7012fa8bd2d7bd07b8c923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; operadores binarios con expresiones de enumeraci&amp;oacute;n constante como operandos</target>
        </trans-unit>
        <trans-unit id="7bc75f886336759e26741a1a438d89e2625db989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--clean&lt;/code&gt; : elimina los resultados de los proyectos especificados (se puede combinar con &lt;code&gt;--dry&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d48e3154b28f82f1a4769c7208b3f989fff9e7b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--declaration&lt;/code&gt; y &lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed49d4e6bfaaf71c24b3551301b4023896fbba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</source>
          <target state="translated">&lt;code&gt;--declarationDir&lt;/code&gt; permite generar archivos de declaraci&amp;oacute;n en una ubicaci&amp;oacute;n diferente a los archivos JavaScript.</target>
        </trans-unit>
        <trans-unit id="3a925ebadad3dc034212a013d96a8d028eec0d77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</source>
          <target state="translated">&lt;code&gt;--dry&lt;/code&gt; : muestra lo que se har&amp;iacute;a pero en realidad no construye nada</target>
        </trans-unit>
        <trans-unit id="391e7b99672708dcc5a82b9ab142640e75686d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</source>
          <target state="translated">&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; &lt;em&gt;solo&lt;/em&gt; permite generar archivos de declaraci&amp;oacute;n; &lt;code&gt;.jsx&lt;/code&gt; generaci&amp;oacute;n de salida &lt;code&gt;.js&lt;/code&gt; / .jsx se omitir&amp;aacute; con esta bandera. La bandera es &amp;uacute;til cuando la generaci&amp;oacute;n de salida &lt;code&gt;.js&lt;/code&gt; es manejada por un transpilador diferente como Babel.</target>
        </trans-unit>
        <trans-unit id="e68274530cc65ca1af4f49f4f5cff04720ac0248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9fb3da74ef87ed6a6c5cc462731d82c9d0c65e88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5a457b35b9491157c629e0302940182ccb5e23a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; : act&amp;uacute;a como si todos los proyectos estuvieran desactualizados</target>
        </trans-unit>
        <trans-unit id="89e0256ea12246cd1a53115a0051e97b7166b303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--incremental&lt;/code&gt; improvements</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; mejoras incrementales</target>
        </trans-unit>
        <trans-unit id="e2680bfd978e11406b01f962d148789dcac08317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--init&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--init&lt;/code&gt; opci&amp;oacute;n de l&amp;iacute;nea de comando --init</target>
        </trans-unit>
        <trans-unit id="99720ca96a5b0e0056f6395f275543d0ff913fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; y opciones de l&amp;iacute;nea de comando &lt;code&gt;inlineSources&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c3e1a02d6406f9e0f2c99dcba3493dd92f9d8a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; hace que los archivos de mapas de origen se escriban en l&amp;iacute;nea en los archivos &lt;code&gt;.js&lt;/code&gt; generados en lugar de en un archivo &lt;code&gt;.js.map&lt;/code&gt; independiente . &lt;code&gt;--inlineSources&lt;/code&gt; permite incluir adicionalmente el archivo &lt;code&gt;.ts&lt;/code&gt; de origen en el archivo &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f213a09ff50e9dce71ecec1b24aff3aec8683c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--newLine&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--newLine&lt;/code&gt; opci&amp;oacute;n de l&amp;iacute;nea de comando newLine</target>
        </trans-unit>
        <trans-unit id="458f3a7228c6223004510906f46ddc5c2a2fd92d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--noEmitHelpers&lt;/code&gt; opci&amp;oacute;n de l&amp;iacute;nea de comando</target>
        </trans-unit>
        <trans-unit id="0312bee1e756b333574619a9dfc0a5e51d922e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--pretty&lt;/code&gt; output by default</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; salida por defecto</target>
        </trans-unit>
        <trans-unit id="4cacd6ae5c910b5d011312b91818b43c8dbca3da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; l&amp;iacute;nea de comando --rootDir</target>
        </trans-unit>
        <trans-unit id="ed17502152114f93d8a25c9ca4ba3c08cc11bea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; especifica el directorio de entrada que se reflejar&amp;aacute; en la salida en lugar de calcularlo.</target>
        </trans-unit>
        <trans-unit id="ce69107c4ebefc8f6c4b27a523e9c10b6bac6045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; cambia a un nuevo modo de comprobaci&amp;oacute;n nulo estricto.</target>
        </trans-unit>
        <trans-unit id="0e169771b2b9f04c32856782076ccdc93237e692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--target ESNext&lt;/code&gt; apunta a las &amp;uacute;ltimas &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;funciones propuestas de ES&lt;/a&gt; compatibles .</target>
        </trans-unit>
        <trans-unit id="77f5b91bdc31f6e92780c04a56ba964c398b7284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; ofrece una forma pr&amp;aacute;ctica de comprender c&amp;oacute;mo el compilador ha resuelto los m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="73f407030ac0547dfee747a39b87fbd94ad60948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</source>
          <target state="translated">&lt;code&gt;--verbose&lt;/code&gt; : imprime un registro detallado para explicar lo que est&amp;aacute; sucediendo (se puede combinar con cualquier otra bandera)</target>
        </trans-unit>
        <trans-unit id="51fc8c433aeda1db44c3bcf0bd26afcf1442b203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; la implementaci&amp;oacute;n del compilador se basa en &lt;code&gt;fs.watch&lt;/code&gt; y &lt;code&gt;fs.watchFile&lt;/code&gt; proporcionados por el nodo, ambos m&amp;eacute;todos tienen pros y contras.</target>
        </trans-unit>
        <trans-unit id="38362bf60068a8fc03024f53bf3a560d68cb7a68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; : modo reloj (no se puede combinar con ninguna bandera excepto &lt;code&gt;--verbose&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e3f3b3fa6bf342d93e8863e2d8e9e6b14addae36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</source>
          <target state="translated">&lt;code&gt;-noEmitOnError&lt;/code&gt; opci&amp;oacute;n de l&amp;iacute;nea de comandos</target>
        </trans-unit>
        <trans-unit id="327baae57d533178e63d7b713f4cf4788b983059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; archivos .js ahora se permiten como entrada para &lt;code&gt;tsc&lt;/code&gt; . El compilador de TypeScript comprueba los archivos &lt;code&gt;.js&lt;/code&gt; de entrada en busca de errores de sintaxis y emite una salida v&amp;aacute;lida basada en las &lt;code&gt;--target&lt;/code&gt; y &lt;code&gt;--module&lt;/code&gt; . La salida tambi&amp;eacute;n se puede combinar con otros archivos &lt;code&gt;.ts&lt;/code&gt; . Los mapas de origen a&amp;uacute;n se generan para archivos &lt;code&gt;.js&lt;/code&gt; al igual que con los archivos &lt;code&gt;.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03a3fca2c804aa362f9ea852d9bc2750659b10c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; archivos .js a&amp;uacute;n se revisan para asegurarse de que solo incluyan caracter&amp;iacute;sticas est&amp;aacute;ndar de ECMAScript; las anotaciones de tipo solo se permiten en archivos &lt;code&gt;.ts&lt;/code&gt; y se marcan como errores en archivos &lt;code&gt;.js&lt;/code&gt; . Los comentarios de JSDoc se pueden usar para agregar informaci&amp;oacute;n de tipo a su c&amp;oacute;digo JavaScript; consulte la &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;documentaci&amp;oacute;n de soporte de JSDoc&lt;/a&gt; para obtener m&amp;aacute;s detalles sobre las construcciones JSDoc compatibles.</target>
        </trans-unit>
        <trans-unit id="90ab280d51b93fdaebf109f5c00c1bac5af53c79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; en archivos TypeScript</target>
        </trans-unit>
        <trans-unit id="ccc749b3637aaa4c3979a2d33edcfc503506cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informa al compilador acerca de una dependencia de m&amp;oacute;dulo que no es TS que debe inyectarse en la llamada require del m&amp;oacute;dulo resultante.</target>
        </trans-unit>
        <trans-unit id="7288e5b9a9753f562fe49deb813afdbf0087fb3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informa al compilador acerca de una dependencia de un m&amp;oacute;dulo que no es TS que debe inyectarse en la llamada require del m&amp;oacute;dulo resultante; sin embargo, no hab&amp;iacute;a forma de consumir este m&amp;oacute;dulo en el c&amp;oacute;digo TS.</target>
        </trans-unit>
        <trans-unit id="9eece5866a10ade200011770d30646176a0b7c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; directivas de referencia</target>
        </trans-unit>
        <trans-unit id="68be6d84b0a2fdf1d5f2d8454eb02fa9cc63bc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; -ing un m&amp;oacute;dulo</target>
        </trans-unit>
        <trans-unit id="091d09657c7b31c654b189dcd1f225f1a0ec984a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (si especifica una propiedad &lt;code&gt;&quot;main&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="20ea10290a23b3740565e936d91702057ff37372" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (si especifica una propiedad de &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9df7b034b6621c779b27d7c4dc7f558da205013a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (si especifica una propiedad &lt;code&gt;&quot;main&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4296e7cb4bf2356c30d2093a8e9404e55c92de63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (si especifica una propiedad de &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ef30e25aeff39df1c13b00397846be84602cf411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (si especifica una propiedad de &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="98c853cb66dcb5dc8bcd3d05b08df126aa012e02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (si especifica una propiedad &lt;code&gt;&quot;main&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5253ab85bf2484b7491317cdace822fde2760762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (si especifica una propiedad de &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="69dd5451af8cbefbfd16c53fcdb71cc3040ab929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; coincide con cualquier car&amp;aacute;cter (excluidos los separadores de directorio)</target>
        </trans-unit>
        <trans-unit id="510d9eec82bb462d81447db0531174b45f1b80bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; es similar a &lt;code&gt;@typedef&lt;/code&gt; , pero especifica un tipo de funci&amp;oacute;n en lugar de un tipo de objeto:</target>
        </trans-unit>
        <trans-unit id="15e4ec66e698eca8fcacc4aef3b4a8740b21ad83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@class&lt;/code&gt; (o &lt;code&gt;@constructor&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d9926a14ef97939b4b2a7dc3f406f497b651cfe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@const&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/19672&quot;&gt;issue #19672&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cd9b641abd25c6590bb4318e0d96edab2387c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@extends&lt;/code&gt; (o &lt;code&gt;@augments&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7af159c170df9572411a5fc0ca1c714e2ddcfe48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@inheritdoc&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23215&quot;&gt;issue #23215&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e519c580e10173da9247b85e7b08d470854d616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@memberof&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/7237&quot;&gt;issue #7237&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b149f9a357b0a3ec024cce9f5c3dc2328ec70cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; (o &lt;code&gt;@arg&lt;/code&gt; o &lt;code&gt;@argument&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f17c616498694e2538a5c3a14034458ed215aaf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; permite una sintaxis similar para especificaciones de tipo &amp;uacute;nico. Tenga en cuenta que los nombres de las propiedades anidadas deben tener como prefijo el nombre del par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="dd0e55fe627686baab0559a9cdef55576fc8bd55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; y &lt;code&gt;@returns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7336752ac090f78d34c3d11b1ab23f55bc10fd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; usa la misma sintaxis de tipo que &lt;code&gt;@type&lt;/code&gt; , pero agrega un nombre de par&amp;aacute;metro. El par&amp;aacute;metro tambi&amp;eacute;n puede declararse opcional rodeando el nombre con corchetes:</target>
        </trans-unit>
        <trans-unit id="19809d43310d525637902c3117defc38e456422e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@private&lt;/code&gt; means that a property can only be used within the containing class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438ac9ff15896d350daae76a2cc4baf6653d6792" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@protected&lt;/code&gt; means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd4c7a40333b2bbb8dde7e82e8932abca84df9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@public&lt;/code&gt; is always implied and can be left off, but means that a property can be reached from anywhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bf6cf80df0aa9192ae7829c488911d16a03ac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@returns&lt;/code&gt; (o &lt;code&gt;@return&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e9b067c8654340c958784799626e7b4c6447e4ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; puede especificar un tipo de uni&amp;oacute;n; por ejemplo, algo puede ser una cadena o un booleano.</target>
        </trans-unit>
        <trans-unit id="6370c9d00688eca8044b474975739ec7c282690c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; puede usarse para definir tipos complejos. Una sintaxis similar funciona con &lt;code&gt;@param&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d98ac31d277f8f7a055ef6892de9b33cd522d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; , &lt;code&gt;@callback&lt;/code&gt; y &lt;code&gt;@param&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea9a050b838e7b222925bd33fe2491686e61638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@types&lt;/code&gt; , &lt;code&gt;typeRoots&lt;/code&gt; y &lt;code&gt;types&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bae124c1c173e712edc3d1ad0a19078f6a3f6f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@yields&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23857&quot;&gt;issue #23857&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced52b9dec509889f60aa7c87448b485409b7a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="50cd5cdee6eaf1adbc6e1a7075eb9ed268b7c53d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt; or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; , &lt;code&gt;CommonJs&lt;/code&gt; , &lt;code&gt;UMD&lt;/code&gt; , &lt;code&gt;System&lt;/code&gt; o &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dd47ffe31f15f736868359790118558f4c90d54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CRLF&lt;/code&gt; or &lt;code&gt;LF&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRLF&lt;/code&gt; o &lt;code&gt;LF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e18a27ec845bd07bc4bd92bd5a9491158c764b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Classic&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Classic&lt;/code&gt; o &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c7c57db6dc6560c30e85fd334a8c39710cd2a1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Combined&lt;/code&gt; has two properties, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so &lt;code&gt;Conflicting.a: number &amp;amp; string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d793b8dd668dd2130ea7391dfeaa61bed9c3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CommonJS&lt;/code&gt; (default if &lt;code&gt;target&lt;/code&gt; is &lt;code&gt;ES3&lt;/code&gt; or &lt;code&gt;ES5&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e28ff360e77827a000f56ca84a256c62cc3228" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2017&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2017&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="e44dc9aa61a49ecca89f1df117b8525c59bdcc98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2018&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2018&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="88589d0dd64cb35a2eed37b1a8b40cce5f9a53e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2019&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2019&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="12f37540cdb9c3492ed986234931fa1515ec2629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2020&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2020&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="5458962d81dee50f969981ff115b63eb43196cb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt; (default),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55b3dc1847df4cc22875b738b3f0488ec130264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt;, &lt;code&gt;ES5&lt;/code&gt;, or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES3&lt;/code&gt; , &lt;code&gt;ES5&lt;/code&gt; o &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59ffafcef9deaae4f4691bacf9ca573ae6ca0ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES5&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES5&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="91cc99c38cb2d95e5ad8900b70fbd04f54089424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt;/&lt;code&gt;ES2015&lt;/code&gt; (synonymous),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551adb5b78d1804a795f54cee1a99ae987b9a8ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt;/&lt;code&gt;ES2015&lt;/code&gt; (synonymous, default for &lt;code&gt;target&lt;/code&gt;&lt;code&gt;ES6&lt;/code&gt; and higher),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd82edcb863935c74f3c96030d44feb854613265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES7&lt;/code&gt;/&lt;code&gt;ES2016&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES7&lt;/code&gt;/&lt;code&gt;ES2016&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="a1c84b65c2899e07c2577094ba71268f82bb4348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Exclude from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; - Excluir de &lt;code&gt;T&lt;/code&gt; esos tipos que son asignables a &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37b118234127720a534c99dc56aab386dafc6292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Extract from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; - Extracto de &lt;code&gt;T&lt;/code&gt; esos tipos que son asignables a &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="731cd2078eec18fd1721cd773e8793bd578bbbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the instance type of a constructor function type.</source>
          <target state="translated">&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; : obtiene el tipo de instancia de un tipo de funci&amp;oacute;n constructora.</target>
        </trans-unit>
        <trans-unit id="9f4f46cf1c3e00a0668406b1af262c9ac954f250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MapToPromise&lt;/code&gt; takes a type &lt;code&gt;T&lt;/code&gt;, and when that type is a tuple like &lt;code&gt;Coordinate&lt;/code&gt;, only the numeric properties are converted. In &lt;code&gt;[number, number]&lt;/code&gt;, there are two numerically named properties: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. When given a tuple like that, &lt;code&gt;MapToPromise&lt;/code&gt; will create a new tuple where the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; properties are &lt;code&gt;Promise&lt;/code&gt;s of the original type. So the resulting type &lt;code&gt;PromiseCoordinate&lt;/code&gt; ends up with the type &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MapToPromise&lt;/code&gt; toma un tipo &lt;code&gt;T&lt;/code&gt; , y cuando ese tipo es una tupla como &lt;code&gt;Coordinate&lt;/code&gt; , solo se convierten las propiedades num&amp;eacute;ricas. En &lt;code&gt;[number, number]&lt;/code&gt; , hay dos propiedades nombradas num&amp;eacute;ricamente: &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; . Cuando se le da una tupla como esa, &lt;code&gt;MapToPromise&lt;/code&gt; crear&amp;aacute; una nueva tupla donde las propiedades &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; son &lt;code&gt;Promise&lt;/code&gt; del tipo original. Entonces, el tipo resultante &lt;code&gt;PromiseCoordinate&lt;/code&gt; termina con el tipo &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3876e328c2a892ca260659a39ae1af62fabdd14a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;: Tools only (&lt;code&gt;tsc.exe&lt;/code&gt;, &lt;code&gt;lib.d.ts&lt;/code&gt;, etc.) .</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt; : solo herramientas ( &lt;code&gt;tsc.exe&lt;/code&gt; , &lt;code&gt;lib.d.ts&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="50b10a71485a17634b805b9bf6d4a114d9b8719e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;: Tools as above, as well as MSBuild tasks and targets (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;, &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; : herramientas como las anteriores, as&amp;iacute; como tareas y objetivos de MSBuild ( &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; , &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; , etc.)</target>
        </trans-unit>
        <trans-unit id="754f9ca6c2a9d6b75591a792a94899f3972d0dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Exclude &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; - Excluir &lt;code&gt;null&lt;/code&gt; y &lt;code&gt;undefined&lt;/code&gt; de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89a15a098fe35b271129107f57ff56b0b96a908f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="bcae45288d3d0341f00e5f0a0c1e04f55875a283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; y &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ab4b2b1efc56a0da6b2f789333b4eeca92f504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.defineProperty&lt;/code&gt; declarations in JavaScript</source>
          <target state="translated">&lt;code&gt;Object.defineProperty&lt;/code&gt; Declaraciones de Object.defineProperty en JavaScript</target>
        </trans-unit>
        <trans-unit id="516acae2c43a860256900e06b27f3de21816c8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Readonly&lt;/code&gt;, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; y &lt;code&gt;Readonly&lt;/code&gt; , como se describi&amp;oacute; anteriormente, son construcciones muy &amp;uacute;tiles. Puede usarlos para describir algunas rutinas JS comunes como:</target>
        </trans-unit>
        <trans-unit id="8c5fb5be503d3cc99bc3891aa2f666671d256ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt;, &lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Record&lt;/code&gt;, and &lt;code&gt;Pick&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; , de solo &lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Record&lt;/code&gt; y &lt;code&gt;Pick&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9dce20c8a5593c22349b662be93f751022e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt; are homomorphic whereas &lt;code&gt;Record&lt;/code&gt; is not. One clue that &lt;code&gt;Record&lt;/code&gt; is not homomorphic is that it doesn&amp;rsquo;t take an input type to copy properties from:</source>
          <target state="translated">&lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Partial&lt;/code&gt; y &lt;code&gt;Pick&lt;/code&gt; son homom&amp;oacute;rficos, mientras que &lt;code&gt;Record&lt;/code&gt; no lo es. Una pista de que &lt;code&gt;Record&lt;/code&gt; no es homom&amp;oacute;rfico es que no se necesita un tipo de entrada para copiar propiedades desde:</target>
        </trans-unit>
        <trans-unit id="e7f09457e713627cb3ff92a240363946a791f063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the return type of a function type.</source>
          <target state="translated">&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; : obtiene el tipo de retorno de un tipo de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="555e1ab04d96fee8e1f7fce44305f90f1e1a16a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;System&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="4b99ac4ec7cc9b1967c0464330db6c92bcd93e5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UMD&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;UMD&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="f596f26b3a4a06ed8796e22604a1d5460910d96c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]&lt;/code&gt;, plus the value of &lt;code&gt;outDir&lt;/code&gt; if one is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4e295b21aab254df399f343e9636cc32c7a1ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[T, T]&lt;/code&gt; is a subtype of &lt;code&gt;T[]&lt;/code&gt;. This is different than Haskell, where tuples are not related to lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283c19901d75227a4d28c2d33fc35dbe35af5585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;files&lt;/code&gt; is specified, otherwise &lt;code&gt;[&quot;**/*&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a86605355daf9f91784a6e95367936d4e082b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; classes and methods</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; clases y m&amp;eacute;todos abstractos</target>
        </trans-unit>
        <trans-unit id="80eb1110b2f29a5b22fea8c7402e9b9f0d9e30b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt; is contagious, too &amp;mdash; if you initialise a variable with an expression of type &lt;code&gt;any&lt;/code&gt;, the variable has type &lt;code&gt;any&lt;/code&gt; too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9f50e030bc7a5ce9cb5b43dfb74328d401c7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; y &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7ed5d892c6e6d7a97395e1de27bc299c07f918b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asserts condition&lt;/code&gt; says that whatever gets passed into the &lt;code&gt;condition&lt;/code&gt; parameter must be true if the &lt;code&gt;assert&lt;/code&gt; returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we &lt;em&gt;do&lt;/em&gt; catch our original &lt;code&gt;yell&lt;/code&gt; example.</source>
          <target state="translated">&lt;code&gt;asserts condition&lt;/code&gt; dice que cualquier cosa que se pase al par&amp;aacute;metro &lt;code&gt;condition&lt;/code&gt; debe ser verdadera si la &lt;code&gt;assert&lt;/code&gt; regresa (porque de lo contrario arrojar&amp;iacute;a un error). Eso significa que para el resto del alcance, esa condici&amp;oacute;n debe ser veraz. A modo de ejemplo, el uso de este medio de la funci&amp;oacute;n de aserci&amp;oacute;n que &lt;em&gt;s&amp;iacute;&lt;/em&gt; cogemos nuestra original &lt;code&gt;yell&lt;/code&gt; ejemplo.</target>
        </trans-unit>
        <trans-unit id="4d81ac1481d5d350948454eb43f231d3dccd6195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support in ES6 targets (Node v4+)</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; apoyo en objetivos ES6 (Nodo v4 +)</target>
        </trans-unit>
        <trans-unit id="e0839c98cf0c1b0d32a7dad40585aa624f84509b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt; extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b0a7f614edcf50ca6da583f1bb124c1000c419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; takes two other functions:</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; toma otras dos funciones:</target>
        </trans-unit>
        <trans-unit id="a6f6815f367db078217340961910eed3f0c7f8e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; then returns a function which feeds its argument through &lt;code&gt;f&lt;/code&gt; and then &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; luego devuelve una funci&amp;oacute;n que alimenta su argumento a trav&amp;eacute;s de &lt;code&gt;f&lt;/code&gt; y luego &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb41a6e05b71eb6e7a7f237a3f9d9323ff52b694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs/base.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;configs/base.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f321739617311f53c301a43c80e999c6085eb60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const enum&lt;/code&gt; (completely inlined enums)</source>
          <target state="translated">&lt;code&gt;const enum&lt;/code&gt; ( enumeraciones completamente en l&amp;iacute;nea)</target>
        </trans-unit>
        <trans-unit id="7e3ba5db3958314705ea44cd88cec272faaabfcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; assertions</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; aserciones constantes</target>
        </trans-unit>
        <trans-unit id="012e49b5b90ab3812ce5d5459abd13d8a1d9c849" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; declaraciones constantes</target>
        </trans-unit>
        <trans-unit id="fe167491a7d42fefa52129b16e1e621a2c31788a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations are another way of declaring variables.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; declaraciones const son otra forma de declarar variables.</target>
        </trans-unit>
        <trans-unit id="f88c4d09927f47dc36c60e05f8c607beb8cd93c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; enums</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; enumeraciones</target>
        </trans-unit>
        <trans-unit id="8980d3e09baee4979420c9636f8b832f951f2861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70efaa5f183560f377cb84a1789fe0834b27d50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; solo est&amp;aacute; disponible cuando se dirige a ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5892822e96ef4ecfe925031773afe23c1bf575ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ad1e1356fede9b7c214d93508aae720dfa9cb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; must be turned on</source>
          <target state="translated">&lt;code&gt;declaration&lt;/code&gt; debe estar activada</target>
        </trans-unit>
        <trans-unit id="1401dfdf98b767d48685797471067283cd20a8d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declarationMap&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;declarationMap&lt;/code&gt;s</target>
        </trans-unit>
        <trans-unit id="70f1caf45465e3b2f9b33169a10a4b2656de7399" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports are really handy. For instance, a library like jQuery might have a default export of &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt;, which we&amp;rsquo;d probably also import under the name &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; exportaciones predeterminadas son realmente &amp;uacute;tiles. Por ejemplo, una biblioteca como jQuery podr&amp;iacute;a tener una exportaci&amp;oacute;n predeterminada de &lt;code&gt;jQuery&lt;/code&gt; o &lt;code&gt;$&lt;/code&gt; , que probablemente tambi&amp;eacute;n importar&amp;iacute;amos con el nombre &lt;code&gt;$&lt;/code&gt; o &lt;code&gt;jQuery&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f55dfa5aca95ffd4b7a09bd7b9cc8eb2fadbc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports can also be just values:</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; exportaciones predeterminadas tambi&amp;eacute;n pueden ser solo valores:</target>
        </trans-unit>
        <trans-unit id="fe376a04dc77749dab7c4dbd979df3cf8e5dd405" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamicPriorityPolling&lt;/code&gt;: Use a dynamic queue where less-frequently modified directories will be checked less often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c871853d0e750f1e6eeaefa64d36be33f6fd2e08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamicPriorityPolling&lt;/code&gt;: Use a dynamic queue where less-frequently modified files will be checked less often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288c5ada225ba27cfc87c34049e5392aaba3891d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt;: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8b5fd9f825e6be680dd3514510f69b4616113c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclude&lt;/code&gt; property support in tsconfig.json</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; soporte de propiedad en tsconfig.json</target>
        </trans-unit>
        <trans-unit id="4c9db716df5a416c78cae480a101fb21ea1e7a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export *&lt;/code&gt; can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</source>
          <target state="translated">&lt;code&gt;export *&lt;/code&gt; se puede utilizar para reexportar todas las exportaciones de otro m&amp;oacute;dulo. Esto es &amp;uacute;til para crear m&amp;oacute;dulos que agreguen las exportaciones de varios otros m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="6e636e798459cbffd9da7324b94596ca1840bafd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export =&lt;/code&gt; and &lt;code&gt;import = require()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; e &lt;code&gt;import = require()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d288a4c439ec79c9f01ed90667a909f760945ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is a new top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; es una nueva propiedad de nivel superior en &lt;code&gt;tsconfig.json&lt;/code&gt; (junto con &lt;code&gt;compilerOptions&lt;/code&gt; , &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; y &lt;code&gt;exclude&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9840158488dc62fdaa3cb62b51c0e8858b5791cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; which takes some argument (of type &lt;code&gt;A&lt;/code&gt;) and returns a value of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; que toma alg&amp;uacute;n argumento (de tipo &lt;code&gt;A&lt;/code&gt; ) y devuelve un valor de tipo &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f22e56762e33c4799141e66037e37470d49b81a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; raises compiler errors about unreachable code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b17f3db39a076d6901d31237e6962658b321a6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, unless &lt;code&gt;strict&lt;/code&gt; is set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44df04333c301a58f9a4eb14df232200a4137e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file.</source>
          <target state="translated">&lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; y &lt;code&gt;exclude&lt;/code&gt; del archivo de configuraci&amp;oacute;n heredado &lt;em&gt;sobrescribir&lt;/em&gt; los del archivo de configuraci&amp;oacute;n base.</target>
        </trans-unit>
        <trans-unit id="f14095026c89d29eb77a2786e83750935d903d15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fixedPollingInterval&lt;/code&gt;: Check every directory for changes several times a second at a fixed interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2d807f774a8f4511fd40887b6aa11dff8fd264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fixedPollingInterval&lt;/code&gt;: Check every file for changes several times a second at a fixed interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbea6b2144138c02935bdf65a3a5978cc7d89931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; loops over an iterable object, invoking the &lt;code&gt;Symbol.iterator&lt;/code&gt; property on the object. Here is a simple &lt;code&gt;for..of&lt;/code&gt; loop on an array:</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; recorre un objeto iterable, invocando la propiedad &lt;code&gt;Symbol.iterator&lt;/code&gt; en el objeto. Aqu&amp;iacute; hay un bucle &lt;code&gt;for..of&lt;/code&gt; simple en una matriz:</target>
        </trans-unit>
        <trans-unit id="e95fe318c23178a301fc252f057ad04a9fae6f4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; declaraciones</target>
        </trans-unit>
        <trans-unit id="12a8de33c0d1e331511a9ec2641ee2219e3cc903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support &lt;code&gt;Symbol.iterator&lt;/code&gt; in ES5/E3 if available when using &lt;code&gt;--downlevelIteration&lt;/code&gt;, but can be used on an Array even if it does not define &lt;code&gt;Symbol.iterator&lt;/code&gt; at run time or design time.</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; declaraciones for..of , Array Destructuring y Spread en Array, Call y New expresiones son compatibles con &lt;code&gt;Symbol.iterator&lt;/code&gt; en ES5 / E3 si est&amp;aacute; disponible cuando se usa &lt;code&gt;--downlevelIteration&lt;/code&gt; , pero se puede usar en un Array incluso si no define &lt;code&gt;Symbol.iterator&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n o tiempo de dise&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="8fb526d1bc7349c8b0a3895b057b40322758bab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; declaraciones</target>
        </trans-unit>
        <trans-unit id="8cf252545f201f3e3088e9c25cd8f91ad011a692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watch&lt;/code&gt; uses file system events to notify the changes in the file/directory. But this is OS dependent and the notification is not completely reliable and does not work as expected on many OS. Also there could be limit on number of watches that can be created, eg. linux and we could exhaust it pretty quickly with programs that include large number of files. But because this uses file system events, there is not much CPU cycle involved. Compiler typically uses &lt;code&gt;fs.watch&lt;/code&gt; to watch directories (eg. source directories included by config file, directories in which module resolution failed etc) These can handle the missing precision in notifying about the changes. But recursive watching is supported on only Windows and OSX. That means we need something to replace the recursive nature on other OS.</source>
          <target state="translated">&lt;code&gt;fs.watch&lt;/code&gt; usa eventos del sistema de archivos para notificar los cambios en el archivo / directorio. Pero esto depende del sistema operativo y la notificaci&amp;oacute;n no es completamente confiable y no funciona como se esperaba en muchos sistemas operativos. Tambi&amp;eacute;n podr&amp;iacute;a haber un l&amp;iacute;mite en el n&amp;uacute;mero de relojes que se pueden crear, por ejemplo. linux y podr&amp;iacute;amos agotarlo bastante r&amp;aacute;pido con programas que incluyen una gran cantidad de archivos. Pero debido a que esto usa eventos del sistema de archivos, no hay mucho ciclo de CPU involucrado. El compilador generalmente usa &lt;code&gt;fs.watch&lt;/code&gt; para ver directorios (por ejemplo, directorios de origen incluidos en el archivo de configuraci&amp;oacute;n, directorios en los que fall&amp;oacute; la resoluci&amp;oacute;n del m&amp;oacute;dulo, etc.). Estos pueden manejar la precisi&amp;oacute;n que falta al notificar los cambios. Pero la visualizaci&amp;oacute;n recursiva solo es compatible con Windows y OSX. Eso significa que necesitamos algo para reemplazar la naturaleza recursiva en otros sistemas operativos.</target>
        </trans-unit>
        <trans-unit id="ea889051fa717ee536ad67479b6a78c0ea9610ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. But this is the most reliable mechanism to get the update on the status of file/directory. Compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references) that means the CPU usage depends on number of files in the program.</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; usa sondeo y por lo tanto involucra ciclos de CPU. Pero este es el mecanismo m&amp;aacute;s confiable para obtener la actualizaci&amp;oacute;n sobre el estado del archivo / directorio. El compilador generalmente usa &lt;code&gt;fs.watchFile&lt;/code&gt; para ver archivos de origen, archivos de configuraci&amp;oacute;n y archivos faltantes (referencias de archivos faltantes), lo que significa que el uso de la CPU depende de la cantidad de archivos en el programa.</target>
        </trans-unit>
        <trans-unit id="d942c2a8b235d3c8b1abcc6b3de3eb5cad957fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; which takes an argument of type &lt;code&gt;B&lt;/code&gt; (the type &lt;code&gt;f&lt;/code&gt; returned), and returns a value of type &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; que toma un argumento de tipo &lt;code&gt;B&lt;/code&gt; (el tipo &lt;code&gt;f&lt;/code&gt; devuelto) y devuelve un valor de tipo &lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ff0b88d92dd631bb6081ce9db31f440e26b7928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; Accessors Are Allowed in Ambient Contexts</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; y &lt;code&gt;set&lt;/code&gt; accesores est&amp;aacute;n permitidos en contextos ambientales</target>
        </trans-unit>
        <trans-unit id="3124d2af4a7b268f86acefe54dcc4bd3f7d01f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import type&lt;/code&gt; is always guaranteed to be removed from your JavaScript, and tools like Babel can make better assumptions about your code via the &lt;code&gt;isolatedModules&lt;/code&gt; compiler flag. You can read more in the &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports&quot;&gt;3.8 release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49e1b432c62fc73ee50890c56c8ca86ec135992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; Support in SystemJS</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; Apoyo en SystemJS</target>
        </trans-unit>
        <trans-unit id="0481e74e61bd0bd88c8e2325d45f8276eb589abf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; is only allowed when targeting &lt;code&gt;ESNext&lt;/code&gt; modules and ECMAScript targets.</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; solo se permite cuando se dirige a m&amp;oacute;dulos &lt;code&gt;ESNext&lt;/code&gt; y destinos ECMAScript.</target>
        </trans-unit>
        <trans-unit id="24678ed6edc307f778f38669f8a75994d68cb176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; tipos de importaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="c20e5c61459139d6cecacbbae3c9ad3e255d665c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; support wildcard characters to make glob patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfe1d5b2564298c1ad9951a1d511481192d2cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; tipo guardias</target>
        </trans-unit>
        <trans-unit id="58f962df495c2ad38d952726f96435f0a9c82665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot;&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot; | &quot;ownersAddress&quot;&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96fbdf33bebac7a069682e69d1fd6d5b58e1236" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;keyof Car&lt;/code&gt; es completamente intercambiable con &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt; . La diferencia es que si agrega otra propiedad a &lt;code&gt;Car&lt;/code&gt; , diga &lt;code&gt;ownersAddress: string&lt;/code&gt; , entonces &lt;code&gt;keyof Car&lt;/code&gt; se actualizar&amp;aacute; autom&amp;aacute;ticamente para ser &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt; . Y puede usar &lt;code&gt;keyof&lt;/code&gt; en contextos gen&amp;eacute;ricos como &lt;code&gt;pluck&lt;/code&gt; , donde posiblemente no pueda conocer los nombres de las propiedades con anticipaci&amp;oacute;n. Eso significa que el compilador verificar&amp;aacute; que pase el conjunto correcto de nombres de propiedad para &lt;code&gt;pluck&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1987a917ef43df8bddaa16f892f8677d58abfb2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof X&lt;/code&gt; is a union of the literal types representing string-like, number-like, and symbol-like properties.</source>
          <target state="translated">&lt;code&gt;keyof X&lt;/code&gt; es una uni&amp;oacute;n de los tipos literales que representan propiedades similares a cadenas, n&amp;uacute;meros y s&amp;iacute;mbolos.</target>
        </trans-unit>
        <trans-unit id="a66b6fc8661361e20ef87ae35fc31efb3fbba84e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object[&quot;42&quot;]&lt;/code&gt;) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07209544abdfdc296d7eca721bd91539c66f16c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object['42'&lt;/code&gt;]) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; y &lt;code&gt;T[K]&lt;/code&gt; interact&amp;uacute;an con firmas de &amp;iacute;ndice. Un tipo de par&amp;aacute;metro de firma de &amp;iacute;ndice debe ser 'cadena' o 'n&amp;uacute;mero'. Si tiene un tipo con una firma de &amp;iacute;ndice de cadena, &lt;code&gt;keyof T&lt;/code&gt; ser&amp;aacute; &lt;code&gt;string | number&lt;/code&gt; (y no solo &lt;code&gt;string&lt;/code&gt; , ya que en JavaScript se puede acceder a una propiedad de objeto utilizando cadenas ( &lt;code&gt;object['42'&lt;/code&gt; ]) o n&amp;uacute;meros ( &lt;code&gt;object[42]&lt;/code&gt; )). Y &lt;code&gt;T[string]&lt;/code&gt; es solo el tipo de firma de &amp;iacute;ndice:</target>
        </trans-unit>
        <trans-unit id="23a74989aac5ff67841f237ba8439fe200c4f59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and Lookup Types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; y tipos de b&amp;uacute;squeda</target>
        </trans-unit>
        <trans-unit id="9157c1d1156017222354fdad58f5ebf6388c0fbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new concepts for variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7587ea139b16cb3066fc1193552ad0a697db99ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new types of variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript. &lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; son dos tipos relativamente nuevos de declaraciones de variables en JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;Como mencionamos anteriormente&lt;/a&gt; , &lt;code&gt;let&lt;/code&gt; es similar a &lt;code&gt;var&lt;/code&gt; en algunos aspectos, pero permite a los usuarios evitar algunas de las &quot;trampas&quot; comunes con las que se encuentran los usuarios en JavaScript. &lt;code&gt;const&lt;/code&gt; es un aumento de &lt;code&gt;let&lt;/code&gt; in que evita la reasignaci&amp;oacute;n a una variable.</target>
        </trans-unit>
        <trans-unit id="578f076915b9987c6c3b4ff784a24189b7365213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; support</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; apoyo</target>
        </trans-unit>
        <trans-unit id="6b776172d356ffcb9dd1ee020b2f44b56c7785dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; declaraciones</target>
        </trans-unit>
        <trans-unit id="644591ecf7a7ac1044c0183c3798f150809bbe15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope &lt;em&gt;per iteration&lt;/em&gt;. Since this is what we were doing anyway with our IIFE, we can change our old &lt;code&gt;setTimeout&lt;/code&gt; example to just use a &lt;code&gt;let&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; declaraciones tengan un comportamiento dr&amp;aacute;sticamente diferente cuando se declaran como parte de un bucle. En lugar de simplemente introducir un nuevo entorno al bucle en s&amp;iacute;, estas declaraciones crean un nuevo alcance &lt;em&gt;por iteraci&amp;oacute;n&lt;/em&gt; . Dado que esto es lo que est&amp;aacute;bamos haciendo de todos modos con nuestro IIFE, podemos cambiar nuestro antiguo ejemplo &lt;code&gt;setTimeout&lt;/code&gt; para usar simplemente una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f152c0c11e8b4f18e296dd980a05bfe53992b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; solo est&amp;aacute; disponible cuando se dirige a ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2604695bf1219c913e9ce6e43a919233bb300fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47597d61bef00139bb68777625c718cfe83c7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; declaraciones let , &lt;code&gt;const&lt;/code&gt; y &lt;code&gt;var&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a829bf2451c18e9c8300170bf81a48d5c7a14e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; or &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; o &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8aedd5acf8ab96c5aa7b3783ab936c10a1ae4b90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; palabra clave de espacio de nombres</target>
        </trans-unit>
        <trans-unit id="3757c64ba702c0e95ec29c43f6b3bcbac2dfaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is a subtype of and assignable to every type.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; es un subtipo de y asignable a todo tipo.</target>
        </trans-unit>
        <trans-unit id="dbf0fffc126fe6f7ef6fe8bd69ac432fc59ec7cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; also comes in handy for writing constructable functions, for example:</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; tambi&amp;eacute;n es &amp;uacute;til para escribir funciones construibles, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="38f8af0872a567ae1498db2400c8725c6f67981a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; comes in handy when &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or &lt;code&gt;__proto__&lt;/code&gt; needs to be set in a class constructor. One such use case is inheriting from &lt;code&gt;Error&lt;/code&gt; in NodeJS v4 and higher.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; es &amp;uacute;til cuando &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; o &lt;code&gt;__proto__&lt;/code&gt; necesita establecerse en un constructor de clase. Uno de esos casos de uso es heredar de &lt;code&gt;Error&lt;/code&gt; en NodeJS v4 y superior.</target>
        </trans-unit>
        <trans-unit id="c23e511cadd633529e9b1516004a6ec203d2f65d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; which is helpful if you never want to forget a &lt;code&gt;break&lt;/code&gt; statement between &lt;code&gt;case&lt;/code&gt;s in a &lt;code&gt;switch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; , que es &amp;uacute;til si nunca quiere olvidar una declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; entre los &lt;code&gt;case&lt;/code&gt; en un bloque de &lt;code&gt;switch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17b5ef3461c6310cbfb2829b36fa9f54629275f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitAny&lt;/code&gt; : Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;noImplicitAny&lt;/code&gt; : genera error en expresiones y declaraciones con &lt;code&gt;any&lt;/code&gt; tipo impl&amp;iacute;cito .</target>
        </trans-unit>
        <trans-unit id="8b684ebe24425d0ae00fe5f4dd392279dd756e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitReturns&lt;/code&gt; which prevents you from forgetting to return at the end of a function.</source>
          <target state="translated">&lt;code&gt;noImplicitReturns&lt;/code&gt; , que evita que se olvide de regresar al final de una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e88ad4b11b76f0b52388960f7fb144596753b33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is a type that represents the non-primitive type, i.e. anything that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; es un tipo que representa el tipo no primitivo, es decir, cualquier cosa que no sea &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; o , &lt;code&gt;bigint&lt;/code&gt; , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b459667b63171c9a2bfca987e324fd67266a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; tipo de objeto</target>
        </trans-unit>
        <trans-unit id="a1c2b17b7aa15d4b6c554df6d3c6079bd7ea6b62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target state="translated">&lt;code&gt;onEmitOnError&lt;/code&gt; : No emita salidas si se reportaron errores.</target>
        </trans-unit>
        <trans-unit id="962f6f62ca17f25220b1453a992b090209f2d675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt; lets you declare how TypeScript should resolve an import in your &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f089a00eed6e2a38161e562ca2eadbc3a0ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7271647d356fdf53e4881a83f2b3d24088d1ce22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pet is Fish&lt;/code&gt; is our type predicate in this example. A predicate takes the form &lt;code&gt;parameterName is Type&lt;/code&gt;, where &lt;code&gt;parameterName&lt;/code&gt; must be the name of a parameter from the current function signature.</source>
          <target state="translated">&lt;code&gt;pet is Fish&lt;/code&gt; es nuestro predicado de tipo en este ejemplo. Un predicado toma la forma &lt;code&gt;parameterName is Type&lt;/code&gt; , donde &lt;code&gt;parameterName&lt;/code&gt; debe ser el nombre de un par&amp;aacute;metro de la firma de funci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="d591a35ea43b09e97945e00e88029db5bb27c2b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepend&lt;/code&gt; with &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;prepend&lt;/code&gt; con &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a72fb1d0e76667fcc523f6bd09ef4ab9fea3ee72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preserve&lt;/code&gt;: Emit &lt;code&gt;.jsx&lt;/code&gt; files with the JSX unchanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759693d33e6545513f3137d1a8e8eb2237a7bdde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preserve&lt;/code&gt;: Preserves all &lt;code&gt;import&lt;/code&gt; statements whose values or types are never used. This can cause imports/side-effects to be preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b17c7abd7c031db77146a2cd28f258bded77d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;priorityPollingInterval&lt;/code&gt;: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45719cae5b4f1126bbe06a22e869a53683b4dee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsx&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-jsx&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="356b8546c5e9f87d62546e14302d659e5aac0d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsx&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the changed to &lt;code&gt;_jsx&lt;/code&gt; calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928e6b291318f0359ffca77cbc70fbead8ac5c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsxdev&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-jsxdev&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="8d018e282aac52faf1a5bce4dc9a51f6270555f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsxdev&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the JSX to &lt;code&gt;_jsx&lt;/code&gt; calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df5feb5a033ea926607a96dcf9030ae5dd911ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="cbd42a4c20856fac2215f1c094cdf7e0fe7a49a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the JSX unchanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35412f7057086a24e3247bacc81f6623d22727f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="f48ad12a1bd9b139a251683c44c9c037d0781daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-native&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; , &lt;code&gt;react-native&lt;/code&gt; , &lt;code&gt;preserve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf2cc92123c8f6b96a9b964e714c58ae52e0a976" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with JSX changed to the equivalent &lt;code&gt;React.createElement&lt;/code&gt; calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56520eb9a155723fc8f96c437620581627d43f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265f731b05abd126578741df3ef1317127023ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; mapped type modifiers and &lt;code&gt;readonly&lt;/code&gt; arrays</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; modificadores de tipo mapeados de solo &lt;code&gt;readonly&lt;/code&gt; y matrices de solo lectura</target>
        </trans-unit>
        <trans-unit id="0a72bebc41b3c89da2f3cb186861c5375dc8d827" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; tuplas de solo lectura</target>
        </trans-unit>
        <trans-unit id="8f3d715459a937e9292de095a19bf986d41e03e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc067980e88b210a1f21f1cb123315b9bd2081ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&lt;/code&gt;: The default behavior of dropping &lt;code&gt;import&lt;/code&gt; statements which only reference types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f5264bdd8f0f7da8b8b991265caec63e1a9c37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt; can be used to provide a separate &amp;ldquo;type layer&amp;rdquo; to files that are not TypeScript or JavaScript by providing a home for generated &lt;code&gt;.d.ts&lt;/code&gt; files in another folder. This is technique is useful for bundled applications where you use &lt;code&gt;import&lt;/code&gt; of files that aren&amp;rsquo;t necessarily code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204249cb0d243afb180412fa55d150953da5fecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="136678c68a61a393796c0532e6210ae786397708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s: string&lt;/code&gt; because &lt;code&gt;&quot;right&quot;&lt;/code&gt; widens to &lt;code&gt;string&lt;/code&gt; on assignment to a mutable variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4934c028db6c4d82b88f32de53708b229fb87e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sourceMap&lt;/code&gt; : Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; : genera el archivo &lt;code&gt;.map&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="d0b7403357a0651ddeff1c1122a8b2bb08ffe8e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictNullChecks&lt;/code&gt; is disabled</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; est&amp;aacute; deshabilitado</target>
        </trans-unit>
        <trans-unit id="aea90566bfe67f9e0c36ee7bab295a897337741f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is not assignable to &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3d1a64f83a79b3e78e4bbbb23a87b2e76a6983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; have built-in type predicates, conveniently leaving the object type for the &lt;code&gt;else&lt;/code&gt; branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it&amp;rsquo;s best to build only discriminated unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbbf233507908fb7d0aaad278a5681b3a14a678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symbol&lt;/code&gt; values are created by calling the &lt;code&gt;Symbol&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;symbol&lt;/code&gt; valores de s&amp;iacute;mbolo se crean llamando al constructor de &lt;code&gt;Symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3993556c0c777190448aa36a736f8d0fb775eeae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;synchronousWatchDirectory&lt;/code&gt;: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in &lt;code&gt;node_modules&lt;/code&gt; from running &lt;code&gt;npm install&lt;/code&gt;), but you might want to disable it with this flag for some less-common setups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df548ecfe43e1bd5edc74f5f9d9e11e7c489fabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; : Specify ECMAScript target version.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; : especifique la versi&amp;oacute;n de destino de ECMAScript.</target>
        </trans-unit>
        <trans-unit id="41807fdfe0d78a471df79e23ac828c29a48b1df2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this is T&lt;/code&gt; is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. &lt;code&gt;if&lt;/code&gt; statement), the type of the call expression target object would be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this is T&lt;/code&gt; ahora es una anotaci&amp;oacute;n de tipo de retorno v&amp;aacute;lida para m&amp;eacute;todos en clases e interfaces. Cuando se utiliza en una posici&amp;oacute;n tipo narowing (por ejemplo, &lt;code&gt;if&lt;/code&gt; la declaraci&amp;oacute;n), el tipo del objeto de destino expresi&amp;oacute;n llamada ser&amp;iacute;a reducido a &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3e8615ef6ee0889b418ba23a22ff83460487dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.accountType&lt;/code&gt; is set by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cd16ac9e7ad7a6244f1c16c39714b038a0f987" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.address&lt;/code&gt; is declared as potentially &lt;code&gt;undefined&lt;/code&gt; which means it does not have to be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7a1bd4a571b4f44bdc27ad1f004b76e910b450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.email&lt;/code&gt; is not set and raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a16b01ee1873ea69988138f8f89512d7f866c8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.name&lt;/code&gt; is set specifically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25fe4991728ca46519e506de1d8f666a6c8b7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; significa que &lt;code&gt;addClickListener&lt;/code&gt; espera que &lt;code&gt;onclick&lt;/code&gt; sea ​​una funci&amp;oacute;n que no requiera &lt;code&gt;this&lt;/code&gt; tipo.</target>
        </trans-unit>
        <trans-unit id="a9953e41bed91beb356ec58e55940c473593811e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type. Second, annotate your calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; significa que &lt;code&gt;addClickListener&lt;/code&gt; espera que &lt;code&gt;onclick&lt;/code&gt; sea ​​una funci&amp;oacute;n que no requiera &lt;code&gt;this&lt;/code&gt; tipo. En segundo lugar, anote su c&amp;oacute;digo de llamada con &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="239502a5db9c22853dabbf84a0a02ea54ae32760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; and arrow functions</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; y funciones de flecha</target>
        </trans-unit>
        <trans-unit id="f6b4a05163d3be8c272019de111de564106390bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; par&amp;aacute;metros</target>
        </trans-unit>
        <trans-unit id="9ba826b0f4b51964bc2dcb2689ad5e6718b4d812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters in callbacks</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; par&amp;aacute;metros en devoluciones de llamada</target>
        </trans-unit>
        <trans-unit id="76a17c6a78a4a91182cb755f2d1f82d0e8352047" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-based type guards</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; tipo de guardias</target>
        </trans-unit>
        <trans-unit id="80d7365686580943b61bcc0680fdd9fefd9bb9d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-typing</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;-typing</target>
        </trans-unit>
        <trans-unit id="6d97a427e5231bc7e7013c2328603de6d9b7acd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5626b5c92a5a1772a40e47f83129a6cdaba494c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt; is on, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;composite&lt;/code&gt; est&amp;aacute; activado, &lt;code&gt;false&lt;/code&gt; caso contrario</target>
        </trans-unit>
        <trans-unit id="f8eb24a65272e3cc37e19daeaae9de19be9d06d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a6e88c2494ea9288969156547c6f6523ee7397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unless piping to another program or redirecting output to a file</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; menos que se conecte a otro programa o redireccione la salida a un archivo</target>
        </trans-unit>
        <trans-unit id="2f4d5cb6b37ecf15d042f077e1921ffa51b29618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unreachable code is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5827602d127a01fcf210389ba5b4073a09f73f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -b&lt;/code&gt; Commandline</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; L&amp;iacute;nea de comandos</target>
        </trans-unit>
        <trans-unit id="5fbf7438323e3bbf152cf8686704d6a9b92eda48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -w&lt;/code&gt; can&amp;rsquo;t run on multiple config files at once</source>
          <target state="translated">&lt;code&gt;tsc -w&lt;/code&gt; no se puede ejecutar en varios archivos de configuraci&amp;oacute;n a la vez</target>
        </trans-unit>
        <trans-unit id="147a626c1d03568f0d86b81b12aca475f5e24705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt; will only ever use existing files on disk to do this process, so it&amp;rsquo;s possible to create a project where a correct output file can&amp;rsquo;t be generated because some project&amp;rsquo;s output would be present more than once in the resulting file. For example:</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; solo usar&amp;aacute; archivos existentes en el disco para hacer este proceso, por lo que es posible crear un proyecto donde no se puede generar un archivo de salida correcto porque la salida de alg&amp;uacute;n proyecto estar&amp;iacute;a presente m&amp;aacute;s de una vez en el archivo resultante. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="98564db040acf2bf7b395e1d0a36df38b4a8402f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt;, the TypeScript compiler, supports a new flag called &lt;code&gt;--showConfig&lt;/code&gt;. When running &lt;code&gt;tsc --showConfig&lt;/code&gt;, TypeScript will calculate the effective &lt;code&gt;tsconfig.json&lt;/code&gt; (after calculating options inherited from the &lt;code&gt;extends&lt;/code&gt; field) and print that out. This can be useful for diagnosing configuration issues in general.</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; , el compilador de TypeScript, admite una nueva &lt;code&gt;--showConfig&lt;/code&gt; llamada --showConfig . Cuando se ejecuta &lt;code&gt;tsc --showConfig&lt;/code&gt; , mecanografiado calcular&amp;aacute; el efectivo &lt;code&gt;tsconfig.json&lt;/code&gt; (despu&amp;eacute;s de las opciones heredadas del c&amp;aacute;lculo &lt;code&gt;extends&lt;/code&gt; campo) e imprimir eso. Esto puede resultar &amp;uacute;til para diagnosticar problemas de configuraci&amp;oacute;n en general.</target>
        </trans-unit>
        <trans-unit id="54a7f5e8734c14fa7d0a8d6777c5b5ac6fa8ca44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; files have a new top-level property, &lt;code&gt;references&lt;/code&gt;. It&amp;rsquo;s an array of objects that specifies projects to reference:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; archivos tsconfig.json tienen una nueva propiedad de nivel superior, &lt;code&gt;references&lt;/code&gt; . Es una matriz de objetos que especifica proyectos para hacer referencia:</target>
        </trans-unit>
        <trans-unit id="c8d62e6e595e456c5e9270cc34e832ead6a38881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; inheritance via Node.js packages</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; herencia tsconfig.json a trav&amp;eacute;s de paquetes Node.js</target>
        </trans-unit>
        <trans-unit id="e2d6ff9ec9b1c03f6c4865dd1b1475c13329c97c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; turns a folder into a &amp;ldquo;project&amp;rdquo;. Without specifying any &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; entries, all files in the folder containing the &lt;code&gt;tsconfig.json&lt;/code&gt; and all its sub-directories are included in your compilation. If you want to exclude some of the files use &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;, if you would rather specify all the files instead of letting the compiler look them up, use &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; convierte una carpeta en un &quot;proyecto&quot;. Sin especificar ninguna entrada de &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; o &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; , todos los archivos de la carpeta que contiene &lt;code&gt;tsconfig.json&lt;/code&gt; y todos sus subdirectorios se incluyen en su compilaci&amp;oacute;n. Si desea excluir algunos de los archivos, utilice &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; , si prefiere especificar todos los archivos en lugar de dejar que el compilador los busque, utilice &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44461f86b394f4690605fa32353147f0c499cba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dce89073ea61332463e4bc7ffcd226cfebb38fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="802c612cac10d8e06122f662232f3d40cbb16c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; tipo guardias</target>
        </trans-unit>
        <trans-unit id="ba1416688590a42ec8a707493a8a76f4bafb32ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typesVersions&lt;/code&gt; can support multiple fields where each field name is specified by the range to match on.</source>
          <target state="translated">&lt;code&gt;typesVersions&lt;/code&gt; puede admitir varios campos donde cada nombre de campo est&amp;aacute; especificado por el rango para coincidir.</target>
        </trans-unit>
        <trans-unit id="1b8b90af89196bf03c26d7dd07ee39139d34a210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; (default) provide suggestions as warnings to editors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b705485b2b636af977359d61c65b14f8f84a2c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEvents&lt;/code&gt; (the default): Attempt to use the operating system/file system&amp;rsquo;s native events for directory changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c594db4c6e1fb35a69bcfe903f083a12dd62b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEvents&lt;/code&gt; (the default): Attempt to use the operating system/file system&amp;rsquo;s native events for file changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34e428b0ba7d576912bfbed8dfbd6fd75f80e59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEventsOnParentDirectory&lt;/code&gt;: Attempt to use the operating system/file system&amp;rsquo;s native events to listen for changes on a file&amp;rsquo;s parent directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c59fd04173482af55d5dc102886aa00a3441e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; declaraciones var</target>
        </trans-unit>
        <trans-unit id="ab9085fb15ab9e328c2c89a7b70fa880194687cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations have some odd scoping rules for those used to other languages. Take the following example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; declaraciones de var tienen algunas reglas de alcance extra&amp;ntilde;as para las que se usan en otros lenguajes. Tome el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="e6f91793a72a6bf2a9f9865634b43e9fe9ffea71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; is a little like the opposite of &lt;code&gt;any&lt;/code&gt;: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; es un poco lo opuesto a &lt;code&gt;any&lt;/code&gt; : la ausencia de tener ning&amp;uacute;n tipo. Normalmente puede ver esto como el tipo de retorno de funciones que no devuelven un valor:</target>
        </trans-unit>
        <trans-unit id="5162ce142c852c721ea4c2f90dcd96e468cd2c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt; would have the type &lt;code&gt;any&lt;/code&gt;. This meant the program would type-check, but you could technically do anything with &lt;code&gt;y&lt;/code&gt;, such as the following:</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; tendr&amp;iacute;a el tipo &lt;code&gt;any&lt;/code&gt; . Esto significaba que el programa verificar&amp;iacute;a el tipo, pero t&amp;eacute;cnicamente podr&amp;iacute;a hacer cualquier cosa con &lt;code&gt;y&lt;/code&gt; , como lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7e0a0801dcb35d26012a58fcc2e418fc7f6f784d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{@link &amp;hellip;}&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/35524&quot;&gt;issue #35524&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cc4133a65e863977268415e96540e32efacbaa" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="c1b2e33284cd8b33b99364f12379b80c308e775f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(el directorio ra&amp;iacute;z com&amp;uacute;n se calcula a partir de la lista de archivos de entrada)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67f8a82845ea83174fddc0273791def9f3791ba2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(platform specific)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(plataforma espec&amp;iacute;fica)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6d59622e066b207853d896915edd6f8b0489e8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial strength string-padder example from earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd153da1f3527d871cddfa9877fa2d91c2500ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial string-padder example from earlier:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;instanceof&lt;/code&gt; Las guardas de tipo instanceof&lt;/em&gt; son una forma de restringir tipos usando su funci&amp;oacute;n constructora. Por ejemplo, tomemos prestado nuestro ejemplo de padder de cuerdas industrial de antes:</target>
        </trans-unit>
        <trans-unit id="71df9cb200fe1b9d9980debd24153321fc6684ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;An exploration into the &lt;code&gt;HTMLElement&lt;/code&gt; type&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c97a851324ff9563ea3a21efd2d3c3c258c8c52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any compiler option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Cualquier opci&amp;oacute;n de compilador&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6848663f06841c4836ef827c8d46d2b7df3d9e2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class Decorators&lt;/em&gt; are applied for the class.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Se solicitan &lt;em&gt;decoradores de clase&lt;/em&gt; para la clase.</target>
        </trans-unit>
        <trans-unit id="46261c91e2d02cefcc599506ebcf0fdd9241cca2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Code&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Code&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b095cf5579d916d24a5da3d12744c26e407ebcb8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Configure the TypeScript compiler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Configurar el compilador de TypeScript&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="116f39d7e603ae15f6176b14608384bdd2f4ccc5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Declaration&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Declaration&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3144417886ddc6e09e0cb50372c04d88ab6ff96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; depend on the npm type declaration package if it doesn&amp;rsquo;t package its declaration files.</source>
          <target state="translated">&lt;em&gt;Do&lt;/em&gt; dependen del paquete de declaraci&amp;oacute;n de tipo NPM si no empaquetar sus archivos de declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a89db8b7cceca187803f1966f48b0b78dc6807c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; sort overloads by putting the more general signatures after more specific signatures:</source>
          <target state="translated">&lt;em&gt;Hacer&lt;/em&gt; sobrecargas ordenar poniendo las firmas m&amp;aacute;s generales despu&amp;eacute;s de m&amp;aacute;s firmas espec&amp;iacute;ficas:</target>
        </trans-unit>
        <trans-unit id="74d4dbaa7a29534baf764d9d7745b59ff457b95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;Hacer&lt;/em&gt; uso &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="a8abf42191e985fd38d25cbfd61b4478044adfc0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use optional parameters whenever possible:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; utilizar par&amp;aacute;metros opcionales siempre que sea posible:</target>
        </trans-unit>
        <trans-unit id="e34280b76cbb108a56a72b557e087d65bbfca383" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the return type &lt;code&gt;void&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; utilizar el tipo de retorno &lt;code&gt;void&lt;/code&gt; de devoluciones de llamada cuyo valor ser&amp;aacute; ignorado:</target>
        </trans-unit>
        <trans-unit id="c2582d04d57e5a9ca2606283a30a617ee529f638" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; use los tipos de &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; o , y &lt;code&gt;symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ab3ac84230901f9c46e90452077394873671fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use union types whenever possible:</source>
          <target state="translated">&lt;em&gt;Hacer&lt;/em&gt; uso de tipos de uni&amp;oacute;n siempre que sea posible:</target>
        </trans-unit>
        <trans-unit id="be31bfe1264c4f25766db39e5b90a9fb18fca142" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write a single overload using the maximum arity:</source>
          <target state="translated">&lt;em&gt;Hacer&lt;/em&gt; escribir una sola sobrecarga utilizando el m&amp;aacute;ximo aridad:</target>
        </trans-unit>
        <trans-unit id="c1a8d257a217b5e0fad55b648d1b6493b9aaa989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write callback parameters as non-optional:</source>
          <target state="translated">&lt;em&gt;Hacer&lt;/em&gt; par&amp;aacute;metros de devoluci&amp;oacute;n de llamada de escritura como no opcional:</target>
        </trans-unit>
        <trans-unit id="2abc499e9803a9aa8309f8b0e08bf314ad4f3e5a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Documentation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Documentation&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb8f02b3c9fe34b16e4d7281860a58ffb5f1258c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; combine it with yours, keep each in their own file.</source>
          <target state="translated">&lt;em&gt;No lo&lt;/em&gt; combine con el suyo, mantenga cada uno en su propio archivo.</target>
        </trans-unit>
        <trans-unit id="55046e05caf1c72e4c96a87b22fa2202c7225227" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; copy the declarations in your package either.</source>
          <target state="translated">&lt;em&gt;Tampoco&lt;/em&gt; copie las declaraciones en su paquete.</target>
        </trans-unit>
        <trans-unit id="6641e250515c31ff4c29c3458f5aa359e7992e5f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dfadd00649442a356417e47981d6fcfedbf53f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; siempre tiene un tipo gen&amp;eacute;rico que no utiliza su par&amp;aacute;metro de tipo. Vea m&amp;aacute;s detalles en la &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;p&amp;aacute;gina de preguntas frecuentes de TypeScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aab2c6da00dd5473019faeda9ef13e58ed031a8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever use the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; utilizar nunca los tipos &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; , o &lt;code&gt;Object&lt;/code&gt; Estos tipos se refieren a objetos en caja no primitivos que casi nunca se usan apropiadamente en el c&amp;oacute;digo JavaScript.</target>
        </trans-unit>
        <trans-unit id="9fe264f4ba7251b442af48a3b5b9c4e1b135dfc4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; put more general overloads before more specific overloads:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; coloque sobrecargas m&amp;aacute;s generales antes que sobrecargas m&amp;aacute;s espec&amp;iacute;ficas:</target>
        </trans-unit>
        <trans-unit id="a603d4de241274517e1f16e58ef6ec739c4ebf0c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; in your declaration files.</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; en sus archivos de declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a55cf7c66dde349c496b594f4eb9369bf866bddb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;any&lt;/code&gt; as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler &lt;em&gt;effectively&lt;/em&gt; treats &lt;code&gt;any&lt;/code&gt; as &amp;ldquo;please turn off type checking for this thing&amp;rdquo;. It is similar to putting an &lt;code&gt;@ts-ignore&lt;/code&gt; comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven&amp;rsquo;t migrated yet as &lt;code&gt;any&lt;/code&gt;, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1399216a9d6759d0027db5ae960ecaf5e803541f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use optional parameters in callbacks unless you really mean it:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; use par&amp;aacute;metros opcionales en devoluciones de llamada a menos que realmente lo diga:</target>
        </trans-unit>
        <trans-unit id="9d00344d385328c471e2760c0b3a980265f52fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use the return type &lt;code&gt;any&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; use el tipo de retorno &lt;code&gt;any&lt;/code&gt; para devoluciones de llamada cuyo valor se ignorar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="7e23e9a1b88c2a712c6058479b769bb4d1ec3dfd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write overloads that differ by type in only one argument position:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; escriba sobrecargas que difieran seg&amp;uacute;n el tipo en una sola posici&amp;oacute;n de argumento:</target>
        </trans-unit>
        <trans-unit id="c0e439fdd1e71a139adb43b822a3f2aaba28d521" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write separate overloads that differ only on callback arity:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; escriba sobrecargas separadas que difieran solo en la aridad de devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="247c5c1a979d3fed5d8cc62a706484f0933fae19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write several overloads that differ only in trailing parameters:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; escriba varias sobrecargas que difieran solo en los par&amp;aacute;metros finales:</target>
        </trans-unit>
        <trans-unit id="7a458b0d98bbea39bc5c4fb3afb6e88d1dfd11e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First some ES2016 terminology:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Primero, algo de terminolog&amp;iacute;a ES2016:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e33a7ce58f99afe193351513fce2adb5fa23fa05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Complemento global&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42b74d2886feeb2bcc628ab0ed5f0f2c95a4fcba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global-modifying Modules&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M&amp;oacute;dulos de modificaci&amp;oacute;n global&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dcead9d078d5e6cb9c2a8d1954d8f1acb7bcdd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSBuild only option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Opci&amp;oacute;n &amp;uacute;nica de MSBuild&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5859e547903805656a797e0b51e85d7408c824b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module Plugin&lt;/em&gt; or &lt;em&gt;UMD Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Complemento de m&amp;oacute;dulo&lt;/em&gt; o &lt;em&gt;complemento UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d05eb70e7bf87cec96374f03c7bbd7c1a2dc4450" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module resolution&lt;/em&gt; is the process the compiler uses to figure out what an import refers to. Consider an import statement like &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt;; in order to check any use of &lt;code&gt;a&lt;/code&gt;, the compiler needs to know exactly what it represents, and will need to check its definition &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;La resoluci&amp;oacute;n del m&amp;oacute;dulo&lt;/em&gt; es el proceso que usa el compilador para averiguar a qu&amp;eacute; se refiere una importaci&amp;oacute;n. Considere una declaraci&amp;oacute;n de importaci&amp;oacute;n como &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt; ; Para comprobar cualquier uso de &lt;code&gt;a&lt;/code&gt; , el compilador necesita saber exactamente lo que representa, y deber&amp;aacute; comprobar su definici&amp;oacute;n &lt;code&gt;moduleA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58e6a2ccb2d8f44ed1c3e778056f2950ed113c53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not supported in MSBuild&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;No es compatible con MSBuild&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dac7371112f6ec5085b3b87e625a9052b4ee6a7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Currently TypeScript support in jspm is in 0.16beta&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: Actualmente, el soporte de TypeScript en jspm est&amp;aacute; en 0.16beta&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d7fac5427486f2e613c21aa283c576a7b6e2602" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If you hover over &lt;code&gt;MyBool&lt;/code&gt; above, you&amp;rsquo;ll see that it is classed as &lt;code&gt;boolean&lt;/code&gt;. That&amp;rsquo;s a property of the Structural Type System. More on this below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7bb0c2f049bd85bb9a3c22454271e46a22ff54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; In order for this to work like you would expect, your &lt;code&gt;tsx&lt;/code&gt; file must include an &lt;code&gt;export&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; so that it is considered a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b251d8e6b2dce1d359821b61fd4a66441a0a312c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: You can make JS emit terser by enabling &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e44bb4e42ffe01dfa1f4d3898748e7a02d03761" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Only&lt;/em&gt; emit &lt;code&gt;.d.ts&lt;/code&gt; files; do not emit &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cb755d2229785263aed32055f1123709bd7654" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt; are applied for the constructor.</source>
          <target state="translated">&lt;em&gt;Los decoradores de par&amp;aacute;metros&lt;/em&gt; se aplican al constructor.</target>
        </trans-unit>
        <trans-unit id="796db20a306e9b2dd3935de4aee308956682ef88" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each instance member.</source>
          <target state="translated">&lt;em&gt;Los decoradores de par&amp;aacute;metros&lt;/em&gt; , seguidos de los &lt;em&gt;decoradores&lt;/em&gt; de &lt;em&gt;m&amp;eacute;todo&lt;/em&gt; , &lt;em&gt;acceso&lt;/em&gt; o &lt;em&gt;propiedad,&lt;/em&gt; se aplican a cada miembro de instancia.</target>
        </trans-unit>
        <trans-unit id="5479469c16116549f61eeafcc9902b8ba05b63e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each static member.</source>
          <target state="translated">&lt;em&gt;Los decoradores de par&amp;aacute;metros&lt;/em&gt; , seguidos de los &lt;em&gt;decoradores&lt;/em&gt; de &lt;em&gt;m&amp;eacute;todos&lt;/em&gt; , &lt;em&gt;accesos&lt;/em&gt; o &lt;em&gt;propiedades,&lt;/em&gt; se aplican a cada miembro est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="5e31e103a79ad520b2c48fac19a5feaa38b4da57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rest parameters&lt;/em&gt; are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (&lt;code&gt;...&lt;/code&gt;), allowing you to use it in your function.</source>
          <target state="translated">&lt;em&gt;Los par&amp;aacute;metros de descanso&lt;/em&gt; se tratan como un n&amp;uacute;mero ilimitado de par&amp;aacute;metros opcionales. Al pasar argumentos para un par&amp;aacute;metro de descanso, puede usar tantos como desee; incluso puedes pasar ninguno. El compilador construir&amp;aacute; una matriz de los argumentos pasados ​​con el nombre dado despu&amp;eacute;s de los puntos suspensivos ( &lt;code&gt;...&lt;/code&gt; ), lo que le permitir&amp;aacute; usarlo en su funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="feac7405587931819084625ba52e25fde237d326" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384a6b578c237d923ecb9829216306571810a612" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;Configurar NPM&lt;/em&gt; #</target>
        </trans-unit>
        <trans-unit id="bb153592255ec6892092e3704ed2728ce144e9c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ac1e66f3bd63d151ee5473a7360afdc8a5dfb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;Configurar gulp&lt;/em&gt; #</target>
        </trans-unit>
        <trans-unit id="4f0a451725c04750b6fb4ecce8b55da356ae465a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but it performs no special checking or restructuring of data. It has no runtime impact and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dd4e00bd479a6cea3c982c3959ab8a78ce6226" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="translated">&lt;em&gt;Las afirmaciones de tipo&lt;/em&gt; son una forma de decirle al compilador &quot;conf&amp;iacute;a en m&amp;iacute;, s&amp;eacute; lo que estoy haciendo&quot;. Una aserci&amp;oacute;n de tipo es como una conversi&amp;oacute;n de tipo en otros lenguajes, pero no realiza ninguna verificaci&amp;oacute;n especial o reestructuraci&amp;oacute;n de datos. No tiene ning&amp;uacute;n impacto en el tiempo de ejecuci&amp;oacute;n y es utilizado exclusivamente por el compilador. TypeScript asume que usted, el programador, ha realizado las comprobaciones especiales que necesita.</target>
        </trans-unit>
        <trans-unit id="9b530738f60a429e40a0da7cd4905304cf2dcd24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UMD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55ac475adb38e0b57582081a72d1746f55ded573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: It&amp;rsquo;s always legal for a callback to disregard a parameter, so there&amp;rsquo;s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</source>
          <target state="translated">&lt;em&gt;Por qu&amp;eacute;&lt;/em&gt; : siempre es legal que una devoluci&amp;oacute;n de llamada ignore un par&amp;aacute;metro, por lo que no hay necesidad de una sobrecarga m&amp;aacute;s corta. Proporcionar una devoluci&amp;oacute;n de llamada m&amp;aacute;s corta primero permite que se pasen funciones escritas incorrectamente porque coinciden con la primera sobrecarga.</target>
        </trans-unit>
        <trans-unit id="bba95ff529a6d0256d8f93bf5b1f76f42a078259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for people who are &amp;ldquo;passing through&amp;rdquo; a value to your function:</source>
          <target state="translated">&lt;em&gt;Por qu&amp;eacute;&lt;/em&gt; : esto es importante para las personas que est&amp;aacute;n &quot;transmitiendo&quot; un valor a su funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="049ec47dfa02534ad24ffb14e28f3f5229781764" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for two reasons.</source>
          <target state="translated">&lt;em&gt;Por qu&amp;eacute;&lt;/em&gt; : esto es importante por dos razones.</target>
        </trans-unit>
        <trans-unit id="62327515a94c59f6d707eb154b79f5e5dbfb2a4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: TypeScript chooses the &lt;em&gt;first matching overload&lt;/em&gt; when resolving function calls. When an earlier overload is &amp;ldquo;more general&amp;rdquo; than a later one, the later one is effectively hidden and cannot be called.</source>
          <target state="translated">&lt;em&gt;Por qu&amp;eacute;&lt;/em&gt; : TypeScript elige la &lt;em&gt;primera sobrecarga coincidente&lt;/em&gt; al resolver llamadas a funciones. Cuando una sobrecarga anterior es &quot;m&amp;aacute;s general&quot; que una posterior, la &amp;uacute;ltima se oculta efectivamente y no se puede llamar.</target>
        </trans-unit>
        <trans-unit id="22083a1e79f664f58fd53b8457712dc488debc77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: Using &lt;code&gt;void&lt;/code&gt; is safer because it prevents you from accidentally using the return value of &lt;code&gt;x&lt;/code&gt; in an unchecked way:</source>
          <target state="translated">&lt;em&gt;Por qu&amp;eacute;&lt;/em&gt; : usar &lt;code&gt;void&lt;/code&gt; es m&amp;aacute;s seguro porque evita que uses accidentalmente el valor de retorno de &lt;code&gt;x&lt;/code&gt; de una manera no marcada:</target>
        </trans-unit>
        <trans-unit id="eb00c2127ec65942b8f8eaef0ef31ccfcc660872" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;automatic&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;automatic&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6df984511379d608600ad56856c6b7c90da664d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;Una nota sobre la terminolog&amp;iacute;a:&lt;/strong&gt; es importante tener en cuenta que en TypeScript 1.5, la nomenclatura ha cambiado. Los &quot;m&amp;oacute;dulos internos&quot; ahora son &quot;espacios de nombres&quot;. Los &quot;m&amp;oacute;dulos externos&quot; ahora son simplemente &quot;m&amp;oacute;dulos&quot;, para alinearse con la terminolog&amp;iacute;a de &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; , (es decir, que el &lt;code&gt;module X {&lt;/code&gt; es equivalente al &lt;code&gt;namespace X {&lt;/code&gt; preferido ahora X { ).</target>
        </trans-unit>
        <trans-unit id="cb823f67a7cbb8600c4f0350f1c2ad73fe2d021a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;After&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="156a1437d0d6c924eb6ca12562027ff2587f6045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Before&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="83af59348af09abe07910fb748be25518e341a5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;L&amp;iacute;nea de comando&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4a14a1385687f20b567e75759c59e54cfb6cc9ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default&lt;/strong&gt;: The longest common path of all non-declaration input files. If &lt;code&gt;composite&lt;/code&gt; is set, the default is instead the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979f72af53937fa00189a4108423e158a79f69c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re looking for more information about the compiler options in a tsconfig, check out the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e74e37bb8dd2fa2fd06958c252f8d1e1c0b9f1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: &lt;code&gt;exclude&lt;/code&gt;&lt;em&gt;only&lt;/em&gt; changes which files are included as a result of the &lt;code&gt;include&lt;/code&gt; setting. A file specified by &lt;code&gt;exclude&lt;/code&gt; can still become part of your codebase due to an &lt;code&gt;import&lt;/code&gt; statement in your code, a &lt;code&gt;types&lt;/code&gt; inclusion, a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive, or being specified in the &lt;code&gt;files&lt;/code&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6f93e3961e1411696baa4f771bbaaa46934b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can use &lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support&quot;&gt;the playground to explore JSDoc support&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f1a236aca787e2d4cec9e772e0a3c360a7f918" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; enabling &lt;code&gt;downlevelIteration&lt;/code&gt; does not improve compliance if &lt;code&gt;Symbol.iterator&lt;/code&gt; is not present in the runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd8a1d40fc5fe437da8ffe7085dd47f6e01c64d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this directive has been deprecated. Use &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; statements instead.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta directiva ha quedado obsoleta. Utilice la &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; declaraciones en su lugar.</target>
        </trans-unit>
        <trans-unit id="d5eef7e4ca0f22611baae36661abda073e29f1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Handbook Reference&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90c86a6f498b3ff28fdbaa9255f915348f2c482" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Handbook&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dca272af4b4983e9681bcffd62a12fd4abd3d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="87244e77c6f80d6ca60d4ab90f5e3a2c23bfbfb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="a30a3cb060aed8b038da2f590d07d1fab7bd3b38" translate="yes" xml:space="preserve">
          <source>&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</source>
          <target state="translated">&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; M&amp;aacute;s espec&amp;iacute;ficamente, tipos mapeados homom&amp;oacute;rficos como en el formulario anterior.</target>
        </trans-unit>
        <trans-unit id="18ae02156418abf2a28f0ac9092105d374823167" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</source>
          <target state="translated">&lt;sup&gt;[1]&lt;/sup&gt; Estas opciones son experimentales.</target>
        </trans-unit>
        <trans-unit id="fa0447115a5c58a31c601fe3ecaf85a07da3a091" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</source>
          <target state="translated">&lt;sup&gt;[2]&lt;/sup&gt; Estas opciones solo est&amp;aacute;n permitidas en &lt;code&gt;tsconfig.json&lt;/code&gt; , y no a trav&amp;eacute;s de modificadores de l&amp;iacute;nea de comandos.</target>
        </trans-unit>
        <trans-unit id="e1e2f277649e29a892f6243a1e9f85f91b903aeb" translate="yes" xml:space="preserve">
          <source>======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</source>
          <target state="translated">======== El nombre del m&amp;oacute;dulo 'mecanografiado' se &lt;strong&gt;resolvi&amp;oacute;&lt;/strong&gt; con &lt;strong&gt;&amp;eacute;xito&lt;/strong&gt; en 'node_modules / typescript / lib / typescript.d.ts'. ========</target>
        </trans-unit>
        <trans-unit id="54948ed17588662885addef180b7ef879ed0c37c" translate="yes" xml:space="preserve">
          <source>======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</source>
          <target state="translated">======== Resolviendo el m&amp;oacute;dulo &lt;strong&gt;'mecanografiado'&lt;/strong&gt; de &lt;strong&gt;'src / app.ts'&lt;/strong&gt; . ========</target>
        </trans-unit>
        <trans-unit id="d49ecc37e0ee034f2827da1fd607d32080808c90" translate="yes" xml:space="preserve">
          <source>@constructor</source>
          <target state="translated">@constructor</target>
        </trans-unit>
        <trans-unit id="1730f10972219035ab2f682b1ce4cece7df226d6" translate="yes" xml:space="preserve">
          <source>@extends</source>
          <target state="translated">@extends</target>
        </trans-unit>
        <trans-unit id="105f935c3c4b1ccfdad76f831916ed4a4587adbf" translate="yes" xml:space="preserve">
          <source>@param and @returns</source>
          <target state="translated">@param y @returns</target>
        </trans-unit>
        <trans-unit id="8ebf6ae3de6f1ca37540e2051a2b384cfa72a27f" translate="yes" xml:space="preserve">
          <source>@template</source>
          <target state="translated">@template</target>
        </trans-unit>
        <trans-unit id="ea9188bc22500c51ab1af4eb545fa93a9a0c4799" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;bare import&amp;rdquo; can be used to import a module only for its side-effects.</source>
          <target state="translated">Se puede utilizar una &quot;importaci&amp;oacute;n simple&quot; para importar un m&amp;oacute;dulo solo por sus efectos secundarios.</target>
        </trans-unit>
        <trans-unit id="6ab96675e2c97989bb0f021cb50b90f4796d5235" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;// @ts-ignore&lt;/code&gt; comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following &lt;code&gt;@ts-ignore&lt;/code&gt; explain which error is being suppressed.</source>
          <target state="translated">Un comentario &lt;code&gt;// @ts-ignore&lt;/code&gt; suprime todos los errores que se originan en la siguiente l&amp;iacute;nea. Se recomienda que el resto del comentario que sigue a &lt;code&gt;@ts-ignore&lt;/code&gt; explique qu&amp;eacute; error se est&amp;aacute; suprimiendo.</target>
        </trans-unit>
        <trans-unit id="6e0e525ad905e4c93bcdef14ca8854c2dbd392a9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;class&lt;/code&gt; declaration</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9321961f59ed7aa165b175642715594e39b66e6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;function&lt;/code&gt; declaration</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc5d6828693e8c2d48344e83137c9a8290909b26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.</source>
          <target state="translated">Se puede utilizar una declaraci&amp;oacute;n de &lt;code&gt;namespace&lt;/code&gt; para agregar nuevos tipos, valores y espacios de nombres de cualquier forma que no cree un conflicto.</target>
        </trans-unit>
        <trans-unit id="4dffc5c56bad813471caa1b06219f7ff387e0027" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration which contains a value</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;namespace&lt;/code&gt; o &lt;code&gt;module&lt;/code&gt; que contiene un valor</target>
        </trans-unit>
        <trans-unit id="0e1b65fe0101802b4d7f9ed8f568068bb52794bf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f40f5525adb3d03f58f4422b7d66754c7565a18" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file can inherit configurations from another file using the &lt;code&gt;extends&lt;/code&gt; property.</source>
          <target state="translated">Un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; puede heredar configuraciones de otro archivo utilizando la propiedad &lt;code&gt;extends&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bac130cd7375d2fa70c0cad6b27e7077fed8791a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file is permitted to be completely empty, which compiles all files included by default (as described above) with the default compiler options.</source>
          <target state="translated">Se &lt;code&gt;tsconfig.json&lt;/code&gt; archivo tsconfig.json est&amp;eacute; completamente vac&amp;iacute;o, que compila todos los archivos incluidos de forma predeterminada (como se describe anteriormente) con las opciones del compilador predeterminadas.</target>
        </trans-unit>
        <trans-unit id="2f15ae1c31705135e881325aff5e8a346aec850a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Class Decorator&lt;/em&gt; is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">Un &lt;em&gt;decorador de clase&lt;/em&gt; se declara justo antes de una declaraci&amp;oacute;n de clase. El decorador de clases se aplica al constructor de la clase y se puede usar para observar, modificar o reemplazar una definici&amp;oacute;n de clase. Un decorador de clase no se puede usar en un archivo de declaraci&amp;oacute;n o en cualquier otro contexto ambiental (como en una clase de &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="739e90613eeebc5ddc5aad4956b450c569d06044" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Decorator&lt;/em&gt; is a special kind of declaration that can be attached to a &lt;a href=&quot;#class-decorators&quot;&gt;class declaration&lt;/a&gt;, &lt;a href=&quot;#method-decorators&quot;&gt;method&lt;/a&gt;, &lt;a href=&quot;#accessor-decorators&quot;&gt;accessor&lt;/a&gt;, &lt;a href=&quot;#property-decorators&quot;&gt;property&lt;/a&gt;, or &lt;a href=&quot;#parameter-decorators&quot;&gt;parameter&lt;/a&gt;. Decorators use the form &lt;code&gt;@expression&lt;/code&gt;, where &lt;code&gt;expression&lt;/code&gt; must evaluate to a function that will be called at runtime with information about the decorated declaration.</source>
          <target state="translated">Un &lt;em&gt;decorador&lt;/em&gt; es un tipo especial de declaraci&amp;oacute;n que se puede adjuntar a una &lt;a href=&quot;#class-decorators&quot;&gt;declaraci&amp;oacute;n de clase&lt;/a&gt; , &lt;a href=&quot;#method-decorators&quot;&gt;m&amp;eacute;todo&lt;/a&gt; , &lt;a href=&quot;#accessor-decorators&quot;&gt;descriptor de acceso&lt;/a&gt; , &lt;a href=&quot;#property-decorators&quot;&gt;propiedad&lt;/a&gt; o &lt;a href=&quot;#parameter-decorators&quot;&gt;par&amp;aacute;metro&lt;/a&gt; . Los decoradores usan la forma &lt;code&gt;@expression&lt;/code&gt; , donde la &lt;code&gt;expression&lt;/code&gt; debe evaluar una funci&amp;oacute;n que se llamar&amp;aacute; en tiempo de ejecuci&amp;oacute;n con informaci&amp;oacute;n sobre la declaraci&amp;oacute;n decorada.</target>
        </trans-unit>
        <trans-unit id="9d56f6c32829ea8275bf6ee5b435cef5ea1f700d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Method Decorator&lt;/em&gt; is declared just before a method declaration. The decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">Un &lt;em&gt;Decorador de m&amp;eacute;todos&lt;/em&gt; se declara justo antes de una declaraci&amp;oacute;n de m&amp;eacute;todo. El decorador se aplica al &lt;em&gt;descriptor de propiedades&lt;/em&gt; del m&amp;eacute;todo y se puede utilizar para observar, modificar o reemplazar la definici&amp;oacute;n de un m&amp;eacute;todo. Un decorador de m&amp;eacute;todos no se puede usar en un archivo de declaraci&amp;oacute;n, en una sobrecarga o en cualquier otro contexto ambiental (como en una clase de &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fccf751dfd4d98326bc686f6800698c46d17f29f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Parameter Decorator&lt;/em&gt; is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">Un &lt;em&gt;decorador de par&amp;aacute;metros&lt;/em&gt; se declara justo antes de una declaraci&amp;oacute;n de par&amp;aacute;metros. El decorador de par&amp;aacute;metros se aplica a la funci&amp;oacute;n para un constructor de clase o declaraci&amp;oacute;n de m&amp;eacute;todo. Un decorador de par&amp;aacute;metros no se puede usar en un archivo de declaraci&amp;oacute;n, una sobrecarga o en cualquier otro contexto ambiental (como en una clase de &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d07f771fa09284a877bbd7b7a8c2200cc1db787" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Property Decorator&lt;/em&gt; is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">Un &lt;em&gt;decorador de propiedades&lt;/em&gt; se declara justo antes de una declaraci&amp;oacute;n de propiedad. Un decorador de propiedades no se puede usar en un archivo de declaraci&amp;oacute;n o en cualquier otro contexto ambiental (como en una clase de &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f6b5887333ec599f15cdbb7f6b7e41fb24767d5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;UMD&lt;/em&gt; module is one that can &lt;em&gt;either&lt;/em&gt; be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, are written this way. For example, in Node.js or using RequireJS, you would write:</source>
          <target state="translated">A &lt;em&gt;UMD&lt;/em&gt; m&amp;oacute;dulo es uno que puede &lt;em&gt;o bien&lt;/em&gt; ser utilizado como m&amp;oacute;dulo (a trav&amp;eacute;s de una importaci&amp;oacute;n), o como un mundial (cuando se ejecuta en un entorno sin un cargador de m&amp;oacute;dulo). Muchas bibliotecas populares, como &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; , se escriben de esta manera. Por ejemplo, en Node.js o usando RequireJS, escribir&amp;iacute;as:</target>
        </trans-unit>
        <trans-unit id="2e831c596f2ba69b8fe1db558042cf1c087c1093" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;discriminant property type guard&lt;/em&gt; is an expression of the form &lt;code&gt;x.p == v&lt;/code&gt;, &lt;code&gt;x.p === v&lt;/code&gt;, &lt;code&gt;x.p != v&lt;/code&gt;, or &lt;code&gt;x.p !== v&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of &lt;code&gt;x&lt;/code&gt; to those constituent types of &lt;code&gt;x&lt;/code&gt; that have a discriminant property &lt;code&gt;p&lt;/code&gt; with one of the possible values of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Una &lt;em&gt;protecci&amp;oacute;n de tipo de propiedad discriminante&lt;/em&gt; es una expresi&amp;oacute;n de la forma &lt;code&gt;x.p == v&lt;/code&gt; , &lt;code&gt;x.p === v&lt;/code&gt; , &lt;code&gt;x.p != v&lt;/code&gt; , o &lt;code&gt;x.p !== v&lt;/code&gt; , donde &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;v&lt;/code&gt; son una propiedad y una expresi&amp;oacute;n de un tipo literal de cadena o una uni&amp;oacute;n de tipos literales de cadena. La protecci&amp;oacute;n de tipo de propiedad discriminante reduce el tipo de &lt;code&gt;x&lt;/code&gt; a los tipos constituyentes de &lt;code&gt;x&lt;/code&gt; que tienen una propiedad discriminante &lt;code&gt;p&lt;/code&gt; con uno de los valores posibles de &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af1a45bc532371f09945859192093e4e8e7412f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global plugin&lt;/em&gt; is global code that changes the shape of some global. As with &lt;em&gt;global-modifying modules&lt;/em&gt;, these raise the possibility of runtime conflict.</source>
          <target state="translated">Un &lt;em&gt;complemento global&lt;/em&gt; es un c&amp;oacute;digo global que cambia la forma de algunos globales. Al igual que con &lt;em&gt;los m&amp;oacute;dulos de modificaci&amp;oacute;n global&lt;/em&gt; , estos aumentan la posibilidad de un conflicto de tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2cc8c7dc8fcaba1930b06da38f845e8f6f69fa81" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global-modifying module&lt;/em&gt; alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to &lt;code&gt;String.prototype&lt;/code&gt; when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.</source>
          <target state="translated">Un &lt;em&gt;m&amp;oacute;dulo de modificaci&amp;oacute;n global&lt;/em&gt; altera los valores existentes en el &amp;aacute;mbito global cuando se importan. Por ejemplo, podr&amp;iacute;a existir una biblioteca que agregue nuevos miembros a &lt;code&gt;String.prototype&lt;/code&gt; cuando se importa. Este patr&amp;oacute;n es algo peligroso debido a la posibilidad de conflictos en tiempo de ejecuci&amp;oacute;n, pero a&amp;uacute;n podemos escribir un archivo de declaraci&amp;oacute;n para &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="feba008bb2bcd964cfc399bbc4dcc4618c8ee5e2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global&lt;/em&gt; library is one that can be accessed from the global scope (i.e. without using any form of &lt;code&gt;import&lt;/code&gt;). Many libraries simply expose one or more global variables for use. For example, if you were using &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, the &lt;code&gt;$&lt;/code&gt; variable can be used by simply referring to it:</source>
          <target state="translated">Una biblioteca &lt;em&gt;global&lt;/em&gt; es aquella a la que se puede acceder desde el &amp;aacute;mbito global (es decir, sin utilizar ninguna forma de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n ). Muchas bibliotecas simplemente exponen una o m&amp;aacute;s variables globales para su uso. Por ejemplo, si estaba usando &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; , la variable &lt;code&gt;$&lt;/code&gt; se puede usar simplemente refiri&amp;eacute;ndose a ella:</target>
        </trans-unit>
        <trans-unit id="d2289bfc724a5518dc15e4cf5caddd6815845abb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module plugin&lt;/em&gt; changes the shape of another module (either UMD or module). For example, in Moment.js, &lt;code&gt;moment-range&lt;/code&gt; adds a new &lt;code&gt;range&lt;/code&gt; method to the &lt;code&gt;moment&lt;/code&gt; object.</source>
          <target state="translated">Un &lt;em&gt;complemento de m&amp;oacute;dulo&lt;/em&gt; cambia la forma de otro m&amp;oacute;dulo (ya sea UMD o m&amp;oacute;dulo). Por ejemplo, en Moment.js, &lt;code&gt;moment-range&lt;/code&gt; agrega un nuevo m&amp;eacute;todo de &lt;code&gt;range&lt;/code&gt; al objeto de &lt;code&gt;moment&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="36ef51072168e8fd07bcbf75e20f6fc4027a24cd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative import&lt;/em&gt; is one that starts with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt;. Some examples include:</source>
          <target state="translated">Una &lt;em&gt;importaci&amp;oacute;n relativa&lt;/em&gt; es aquella que comienza con &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; o &lt;code&gt;../&lt;/code&gt; . Algunos ejemplos incluyen:</target>
        </trans-unit>
        <trans-unit id="8b0f2d1642b6ff9d5026c5e25f91e02a415f34ce" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin class&lt;/strong&gt; is a class declaration or expression that &lt;code&gt;extends&lt;/code&gt; an expression of a type parameter type. The following rules apply to mixin class declarations:</source>
          <target state="translated">Una &lt;strong&gt;clase mixin&lt;/strong&gt; es una declaraci&amp;oacute;n o expresi&amp;oacute;n de clase que &lt;code&gt;extends&lt;/code&gt; una expresi&amp;oacute;n de un tipo de par&amp;aacute;metro de tipo. Las siguientes reglas se aplican a las declaraciones de clases mixtas:</target>
        </trans-unit>
        <trans-unit id="bc78810f3bf6a5a9528d8023bc05c6167ef7eaf5" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin constructor type&lt;/strong&gt; refers to a type that has a single construct signature with a single rest argument of type &lt;code&gt;any[]&lt;/code&gt; and an object-like return type. For example, given an object-like type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; is a mixin constructor type with an instance type &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Un &lt;strong&gt;tipo de constructor mixin se&lt;/strong&gt; refiere a un tipo que tiene una &amp;uacute;nica firma de construcci&amp;oacute;n con un &amp;uacute;nico argumento rest de tipo &lt;code&gt;any[]&lt;/code&gt; y un tipo de retorno similar a un objeto. Por ejemplo, dado un objeto similar tipo &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; es un tipo constructor mixin con un tipo de instancia &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e3913101a43966f2ccebcc4061aa10428b79384" translate="yes" xml:space="preserve">
          <source>A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.</source>
          <target state="translated">Un valor booleano que indica que un objeto debe ser aplanado a sus elementos de la matriz por Array.prototype.concat.</target>
        </trans-unit>
        <trans-unit id="b6e0c2d8bf86efa81f30b4c26580fc67ebbeb4fa" translate="yes" xml:space="preserve">
          <source>A Note on Soundness</source>
          <target state="translated">Una nota sobre la solidez</target>
        </trans-unit>
        <trans-unit id="1fed6c2698af466cd828f08e21a3d01c917783df" translate="yes" xml:space="preserve">
          <source>A String value that is used in the creation of the default string description of an object. Called by the built-in method &lt;code&gt;Object.prototype.toString&lt;/code&gt;.</source>
          <target state="translated">Un valor de cadena que se utiliza en la creaci&amp;oacute;n de la descripci&amp;oacute;n de cadena predeterminada de un objeto. Llamado por el m&amp;eacute;todo &lt;code&gt;Object.prototype.toString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a9182f58f65016d093319fe062109a9686adac2" translate="yes" xml:space="preserve">
          <source>A TSConfig file in a directory indicates that the directory is the root of a TypeScript or JavaScript project. The TSConfig file can be either a &lt;code&gt;tsconfig.json&lt;/code&gt; or &lt;code&gt;jsconfig.json&lt;/code&gt;, both have the same behavior and the same set of config variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855d73d13b972d2597c136c97ec4024c17beeaa2" translate="yes" xml:space="preserve">
          <source>A Typed Superset of JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef0b6dff4f7313a8976b0f0d521140ee41e223c" translate="yes" xml:space="preserve">
          <source>A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">Un paso de compilaci&amp;oacute;n copiar&amp;aacute; los archivos en &lt;code&gt;/src/views&lt;/code&gt; y &lt;code&gt;/generated/templates/views&lt;/code&gt; en el mismo directorio en la salida. En tiempo de ejecuci&amp;oacute;n, una vista puede esperar que su plantilla exista junto a ella y, por lo tanto, deber&amp;iacute;a importarla con un nombre relativo como &lt;code&gt;&quot;./template&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e30e8a952193f7d1df77a0d6d1fd7f212ffd28d" translate="yes" xml:space="preserve">
          <source>A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to &lt;code&gt;any&lt;/code&gt;. For example:</source>
          <target state="translated">Una llamada a una funci&amp;oacute;n gen&amp;eacute;rica usa los argumentos para inferir los par&amp;aacute;metros de tipo. A veces, este proceso no logra inferir ning&amp;uacute;n tipo, principalmente debido a la falta de fuentes de inferencia; en estos casos, los par&amp;aacute;metros de tipo se establecer&amp;aacute;n de forma predeterminada en &lt;code&gt;any&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8884cee9c569ba73051b4c3340106f32892db818" translate="yes" xml:space="preserve">
          <source>A class constructor may be marked &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt;. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</source>
          <target state="translated">Un constructor de clases puede estar marcado como &lt;code&gt;private&lt;/code&gt; o &lt;code&gt;protected&lt;/code&gt; . No se puede crear una instancia de una clase con un constructor privado fuera del cuerpo de la clase y no se puede extender. No se puede crear una instancia de una clase con un constructor protegido fuera del cuerpo de la clase, pero se puede extender.</target>
        </trans-unit>
        <trans-unit id="714c30cc5bf310cba2527f465ba3e4937c25903e" translate="yes" xml:space="preserve">
          <source>A class declaration (&lt;code&gt;class C { }&lt;/code&gt;)</source>
          <target state="translated">Una declaraci&amp;oacute;n de clase ( &lt;code&gt;class C { }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1596db92a712b48a7d481d2882462ab7d550ed38" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</source>
          <target state="translated">Una declaración de clase o interfaz que se fusiona con una declaración de clase o interfaz existente puede introducir un valor por defecto para un parámetro de tipo existente.</target>
        </trans-unit>
        <trans-unit id="fe8ffa4d7e2dafe57b8f8b2aa2642caf1ac898fd" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</source>
          <target state="translated">Una declaración de clase o interfaz que se fusiona con una declaración de clase o interfaz existente puede introducir un nuevo parámetro de tipo siempre que especifique un valor por defecto.</target>
        </trans-unit>
        <trans-unit id="e2f827247ace6a9f06365439ae3c387f57673379" translate="yes" xml:space="preserve">
          <source>A collection of extra checks, which somewhat cross the boundaries of compiler vs linter. You may prefer to use a tool like &lt;a href=&quot;https://github.com/typescript-eslint/typescript-eslint#typescript-eslint&quot;&gt;eslint&lt;/a&gt; over these options if you are looking for more in-depth rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50811af3fd1732eb86ab44223050144ba8d75bb" translate="yes" xml:space="preserve">
          <source>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</source>
          <target state="translated">Un error común y peligroso es olvidarse de invocar una función,especialmente si la función tiene cero argumentos o se nombra de manera que implique que podría ser una propiedad en lugar de una función.</target>
        </trans-unit>
        <trans-unit id="e559cf07cd2ab15a57eb14b846956299870d3251" translate="yes" xml:space="preserve">
          <source>A common case for their use is for describing config values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012e1680ac04035d05806ae768fbd8f7e9e4d64b" translate="yes" xml:space="preserve">
          <source>A common case where you might think to use &lt;code&gt;skipLibCheck&lt;/code&gt; is when there are two copies of a library&amp;rsquo;s types in your &lt;code&gt;node_modules&lt;/code&gt;. In these cases, you should consider using a feature like &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/selective-version-resolutions/&quot;&gt;yarn&amp;rsquo;s resolutions&lt;/a&gt; to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804ef8425f60cc16494a3ecb8868620fc1d13254" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to use the &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; syntax to refer to a module file, rather than using an &lt;code&gt;import&lt;/code&gt; statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an &lt;code&gt;import&lt;/code&gt; (e.g. the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt;, &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt;, etc.) path.</source>
          <target state="translated">Un error com&amp;uacute;n es intentar usar la sintaxis &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; para referirse a un archivo de m&amp;oacute;dulo, en lugar de usar una declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n . Para entender la diferencia, primero tenemos que entender c&amp;oacute;mo el compilador puede localizar la informaci&amp;oacute;n de tipo para un m&amp;oacute;dulo basado en la ruta de acceso de una &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n (por ejemplo, la &lt;code&gt;...&lt;/code&gt; en &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt; , &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt; etc.) ruta.</target>
        </trans-unit>
        <trans-unit id="dd6d372643d97ce6592522ce945c126f9d03b1c9" translate="yes" xml:space="preserve">
          <source>A common pattern in JavaScript is to use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;instanceof&lt;/code&gt; to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">Un patr&amp;oacute;n com&amp;uacute;n en JavaScript es usar &lt;code&gt;typeof&lt;/code&gt; o &lt;code&gt;instanceof&lt;/code&gt; para examinar el tipo de una expresi&amp;oacute;n en tiempo de ejecuci&amp;oacute;n. TypeScript ahora comprende estas condiciones y cambiar&amp;aacute; la inferencia de tipo en consecuencia cuando se use en un bloque &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4ced30fbc2cc726d8b092795387c4127143776" translate="yes" xml:space="preserve">
          <source>A common task is to take an existing type and make each of its properties optional:</source>
          <target state="translated">Una tarea común es tomar un tipo existente y hacer que cada una de sus propiedades sea opcional:</target>
        </trans-unit>
        <trans-unit id="d835d6d7b039c2f6e80d9f60ed8e2cfe5e3e986f" translate="yes" xml:space="preserve">
          <source>A common technique for working with unions is to have a single field which uses literal types which you can use to let TypeScript narrow down the possible current type. For example, we&amp;rsquo;re going to create a union of three types which have a single shared field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a0349d4a486bbf82efbf586f7757d0e2680533" translate="yes" xml:space="preserve">
          <source>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture &lt;code&gt;i&lt;/code&gt; at each iteration:</source>
          <target state="translated">Una soluci&amp;oacute;n com&amp;uacute;n es usar un IIFE (una expresi&amp;oacute;n de funci&amp;oacute;n invocada inmediatamente) para capturar &lt;code&gt;i&lt;/code&gt; en cada iteraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="80959b7998a3c5a6f92da1dbaffb14e14087102c" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. When &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; contains type variables, whether to resolve to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or to defer, is determined by whether or not the type system has enough information to conclude that &lt;code&gt;T&lt;/code&gt; is always assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&amp;iquest;Un tipo condicional &lt;code&gt;T extends U ? X : Y&lt;/code&gt; se &lt;em&gt;resuelve&lt;/em&gt; en &lt;code&gt;X&lt;/code&gt; o &lt;code&gt;Y&lt;/code&gt; , o se &lt;em&gt;aplaza&lt;/em&gt; porque la condici&amp;oacute;n depende de una o m&amp;aacute;s variables de tipo. Cuando &lt;code&gt;T&lt;/code&gt; o &lt;code&gt;U&lt;/code&gt; contiene variables de tipo, ya sea para determinaci&amp;oacute;n de &lt;code&gt;X&lt;/code&gt; o &lt;code&gt;Y&lt;/code&gt; , o para Defer, est&amp;aacute; determinada por si o no el sistema de tipo tiene suficiente informaci&amp;oacute;n para concluir que &lt;code&gt;T&lt;/code&gt; es siempre asignable a &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ca32ef30629a0ef6871441758cc40ce1b420bb" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:</source>
          <target state="translated">&amp;iquest;Un tipo condicional &lt;code&gt;T extends U ? X : Y&lt;/code&gt; se &lt;em&gt;resuelve&lt;/em&gt; en &lt;code&gt;X&lt;/code&gt; o &lt;code&gt;Y&lt;/code&gt; , o se &lt;em&gt;aplaza&lt;/em&gt; porque la condici&amp;oacute;n depende de una o m&amp;aacute;s variables de tipo. Si resolver o aplazar se determina de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="3632cf4e26292b0e76ecac870e4423c2cd5b98f7" translate="yes" xml:space="preserve">
          <source>A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd55e1e2d504c4f5bd31948eb3ce7aa0ce3cb13" translate="yes" xml:space="preserve">
          <source>A constructor may also be marked &lt;code&gt;protected&lt;/code&gt;. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,</source>
          <target state="translated">Un constructor tambi&amp;eacute;n puede estar marcado como &lt;code&gt;protected&lt;/code&gt; . Esto significa que no se puede crear una instancia de la clase fuera de la clase que la contiene, pero se puede extender. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="cadb83f444b2961a4d934d5f3d490b70e4dd1268" translate="yes" xml:space="preserve">
          <source>A couple of limitations</source>
          <target state="translated">Un par de limitaciones</target>
        </trans-unit>
        <trans-unit id="a24cf92f2108f7fc6dfb574930ec5df83db3eb0b" translate="yes" xml:space="preserve">
          <source>A couple of things to note about accessors:</source>
          <target state="translated">Un par de cosas a tener en cuenta sobre los accesorios:</target>
        </trans-unit>
        <trans-unit id="e092fc815a872b9563a100f8c02b2d0d350825ab" translate="yes" xml:space="preserve">
          <source>A decorator is:</source>
          <target state="translated">Un decorador lo es:</target>
        </trans-unit>
        <trans-unit id="4f1b6da91369927675bbf031b2ce4d5a731e97d7" translate="yes" xml:space="preserve">
          <source>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</source>
          <target state="translated">Una declaración de desestructuración introduce una o más variables con nombre y las inicializa con valores extraídos de las propiedades de un objeto o elementos de un conjunto.</target>
        </trans-unit>
        <trans-unit id="bba8a48bfe00ec663b6ebb1eceade9d3fff1e679" translate="yes" xml:space="preserve">
          <source>A file whose only top-level declaration is &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (remove &lt;code&gt;Foo&lt;/code&gt; and move everything &amp;lsquo;up&amp;rsquo; a level)</source>
          <target state="translated">Un archivo cuya &amp;uacute;nica declaraci&amp;oacute;n de nivel superior es &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (elimine &lt;code&gt;Foo&lt;/code&gt; y mueva todo 'hacia arriba' un nivel)</target>
        </trans-unit>
        <trans-unit id="1dc68bdd4f9a61f11fcf8696eedfc299f303d8bd" translate="yes" xml:space="preserve">
          <source>A function valued property that is the constructor function that is used to create derived objects.</source>
          <target state="translated">Una función de valorización de la propiedad que es la función de construcción que se utiliza para crear objetos derivados.</target>
        </trans-unit>
        <trans-unit id="83ddd76ccda8c0cc52ac61d7fddcd8fcbe5f3cba" translate="yes" xml:space="preserve">
          <source>A function whose body has a reference to the &lt;code&gt;arguments&lt;/code&gt; reference is implicitly considered to have a var-arg parameter (i.e. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt;). Use JSDoc var-arg syntax to specify the type of the arguments.</source>
          <target state="translated">Una funci&amp;oacute;n cuyo cuerpo tiene una referencia a la referencia de &lt;code&gt;arguments&lt;/code&gt; se considera impl&amp;iacute;citamente que tiene un par&amp;aacute;metro var-arg (es decir, &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt; ). Use la sintaxis JSDoc var-arg para especificar el tipo de argumentos.</target>
        </trans-unit>
        <trans-unit id="0ea0b4e5327f594259519fd62a19b6890ab37c08" translate="yes" xml:space="preserve">
          <source>A function&amp;rsquo;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</source>
          <target state="translated">El tipo de una funci&amp;oacute;n tiene las mismas dos partes: el tipo de argumentos y el tipo de retorno. Al escribir todo el tipo de funci&amp;oacute;n, se requieren ambas partes. Escribimos los tipos de par&amp;aacute;metros como una lista de par&amp;aacute;metros, dando a cada par&amp;aacute;metro un nombre y un tipo. Este nombre es solo para ayudar con la legibilidad. En su lugar, podr&amp;iacute;amos haber escrito:</target>
        </trans-unit>
        <trans-unit id="6091230201a03184d43d1bf3ecad6c4e357aa7e8" translate="yes" xml:space="preserve">
          <source>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</source>
          <target state="translated">Una función del generador puede tener una anotación de tipo de retorno,al igual que una función.La anotación representa el tipo de generador devuelto por la función.He aquí un ejemplo:</target>
        </trans-unit>
        <trans-unit id="3058f8f1fd4d84d69ca0c3d8c31e05fc06865a11" translate="yes" xml:space="preserve">
          <source>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</source>
          <target state="translated">Una función generadora sin anotación de tipo puede hacer que se deduzca el tipo de anotación.Así que en el siguiente caso,el tipo se deducirá a partir de las declaraciones de rendimiento:</target>
        </trans-unit>
        <trans-unit id="c6e63dbd0af2ae2aa5dc876191453fa9346622e3" translate="yes" xml:space="preserve">
          <source>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) following the name of the class.</source>
          <target state="translated">Una clase gen&amp;eacute;rica tiene una forma similar a una interfaz gen&amp;eacute;rica. Las clases gen&amp;eacute;ricas tienen una lista de par&amp;aacute;metros de tipo gen&amp;eacute;rico entre par&amp;eacute;ntesis angulares ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) despu&amp;eacute;s del nombre de la clase.</target>
        </trans-unit>
        <trans-unit id="96453b7ccf72e8b01e41461635fa60edbe83b5ea" translate="yes" xml:space="preserve">
          <source>A generic parameter default follows the following rules:</source>
          <target state="translated">Un parámetro genérico por defecto sigue las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="58295366adbe5e286eb8eb3bd14ff3824be0727b" translate="yes" xml:space="preserve">
          <source>A good first read for your daily TS work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6264a6174402b53e580cc927dfee79a2d86c4b7" translate="yes" xml:space="preserve">
          <source>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value &lt;code&gt;2&lt;/code&gt; but weren&amp;rsquo;t sure what that mapped to in the &lt;code&gt;Color&lt;/code&gt; enum above, we could look up the corresponding name:</source>
          <target state="translated">Una caracter&amp;iacute;stica &amp;uacute;til de las enumeraciones es que tambi&amp;eacute;n puede pasar de un valor num&amp;eacute;rico al nombre de ese valor en la enumeraci&amp;oacute;n. Por ejemplo, si tuvi&amp;eacute;ramos el valor &lt;code&gt;2&lt;/code&gt; pero no estuvi&amp;eacute;ramos seguros de a qu&amp;eacute; se asign&amp;oacute; en la enumeraci&amp;oacute;n de &lt;code&gt;Color&lt;/code&gt; anterior, podr&amp;iacute;amos buscar el nombre correspondiente:</target>
        </trans-unit>
        <trans-unit id="2a3d8efbbf391dd508c0f59ddc90ddfd5e9cb8ce" translate="yes" xml:space="preserve">
          <source>A helpful addition to the standard set of datatypes from JavaScript is the &lt;code&gt;enum&lt;/code&gt;. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</source>
          <target state="translated">Una adici&amp;oacute;n &amp;uacute;til al conjunto est&amp;aacute;ndar de tipos de datos de JavaScript es la &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n . Como en lenguajes como C #, una enumeraci&amp;oacute;n es una forma de dar nombres m&amp;aacute;s descriptivos a conjuntos de valores num&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="ae627315bc177e68b8b178eb3fe934f925ae5a99" translate="yes" xml:space="preserve">
          <source>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there&amp;rsquo;s no need to proactively wrap up the exported symbols in a namespace.</source>
          <target state="translated">Una caracter&amp;iacute;stica clave de los m&amp;oacute;dulos en TypeScript es que dos m&amp;oacute;dulos diferentes nunca contribuir&amp;aacute;n con nombres al mismo &amp;aacute;mbito. Dado que el consumidor de un m&amp;oacute;dulo decide qu&amp;eacute; nombre asignarle, no es necesario envolver de forma proactiva los s&amp;iacute;mbolos exportados en un espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="10dfd449e653eb5c28991f082b6ab993db0f38fc" translate="yes" xml:space="preserve">
          <source>A library can consist of multiple modules, such as</source>
          <target state="translated">Una biblioteca puede constar de múltiples módulos,como</target>
        </trans-unit>
        <trans-unit id="0e8770c272f2840fccfa97bc4c9d703b31f41107" translate="yes" xml:space="preserve">
          <source>A literal is a more concrete sub-type of a collective type. What this means is that &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, but a &lt;code&gt;string&lt;/code&gt; is not &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; inside the type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="408eb52ef9fae5ded272c34e2fb8532daf7f4ceb" translate="yes" xml:space="preserve">
          <source>A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the &lt;code&gt;--build&lt;/code&gt; flag with &lt;code&gt;tsc&lt;/code&gt;. This is effectively a new entry point for &lt;code&gt;tsc&lt;/code&gt; that behaves more like a build orchestrator than a simple compiler.</source>
          <target state="translated">Una caracter&amp;iacute;stica muy esperada son las compilaciones incrementales inteligentes para proyectos de TypeScript. En 3.0 puede usar la &lt;code&gt;--build&lt;/code&gt; con &lt;code&gt;tsc&lt;/code&gt; . Este es efectivamente un nuevo punto de entrada para &lt;code&gt;tsc&lt;/code&gt; que se comporta m&amp;aacute;s como un orquestador de compilaci&amp;oacute;n que como un simple compilador.</target>
        </trans-unit>
        <trans-unit id="763f393de249964da063f318cee51c3e7602546a" translate="yes" xml:space="preserve">
          <source>A lot of the time the answer is &lt;em&gt;&amp;ldquo;it depends&amp;rdquo;&lt;/em&gt;, or &lt;em&gt;&amp;ldquo;someone may have decided for you&amp;rdquo;&lt;/em&gt; depending on the project. If you are building your project with an existing framework like &lt;a href=&quot;https://tsdx.io&quot;&gt;tsdx&lt;/a&gt;, &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;, &lt;a href=&quot;https://nestjs.com/&quot;&gt;NestJS&lt;/a&gt; or any framework mentioned in the &lt;a href=&quot;https://www.typescriptlang.org/docs/home&quot;&gt;Getting Started&lt;/a&gt; then this decision is handled for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf50654387dec069aed329536e7230529d81996c" translate="yes" xml:space="preserve">
          <source>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</source>
          <target state="translated">Una parte importante de la ingeniería de software consiste en construir componentes que no sólo tengan APIs bien definidas y consistentes,sino que también sean reutilizables.Los componentes que son capaces de trabajar con los datos de hoy así como con los datos de mañana le darán las capacidades más flexibles para construir grandes sistemas de software.</target>
        </trans-unit>
        <trans-unit id="d9bcb6811c5b2878897a2775d961f00651e45117" translate="yes" xml:space="preserve">
          <source>A mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permits any &lt;code&gt;K&lt;/code&gt; assignable to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">Un tipo mapeado &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permite cualquier &lt;code&gt;K&lt;/code&gt; asignable a la &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29451e8b78ccc3f4b9ac772135d8ff18632a054a" translate="yes" xml:space="preserve">
          <source>A method that converts an object to a corresponding primitive value. Called by the &lt;code&gt;ToPrimitive&lt;/code&gt; abstract operation.</source>
          <target state="translated">Un m&amp;eacute;todo que convierte un objeto en un valor primitivo correspondiente. Llamado por la &lt;code&gt;ToPrimitive&lt;/code&gt; abstracta ToPrimitive .</target>
        </trans-unit>
        <trans-unit id="116f6b876af45833882c2bd0e4ed75e7920c3f86" translate="yes" xml:space="preserve">
          <source>A method that determines if a constructor object recognizes an object as one of the constructor&amp;rsquo;s instances. Called by the semantics of the instanceof operator.</source>
          <target state="translated">Un m&amp;eacute;todo que determina si un objeto constructor reconoce un objeto como una de las instancias del constructor. Llamado por la sem&amp;aacute;ntica del operador instanceof.</target>
        </trans-unit>
        <trans-unit id="790df4f5d480d1c7b853c049c80823994596880d" translate="yes" xml:space="preserve">
          <source>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</source>
          <target state="translated">Un método que devuelve el iterador por defecto de un objeto.Llamado por la semántica de la declaración for-of.</target>
        </trans-unit>
        <trans-unit id="db447b4ab93c0844fc4e212f82c10b11c2a634ec" translate="yes" xml:space="preserve">
          <source>A modifier with no &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; prefix is the same as a modifier with a &lt;code&gt;+&lt;/code&gt; prefix. So, the &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; type above corresponds to</source>
          <target state="translated">Un modificador sin prefijo &lt;code&gt;+&lt;/code&gt; o &lt;code&gt;-&lt;/code&gt; es lo mismo que un modificador con un prefijo &lt;code&gt;+&lt;/code&gt; . Por tanto, el tipo &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; anterior corresponde a</target>
        </trans-unit>
        <trans-unit id="3dbeca90d263824170468112465310c954b28b6b" translate="yes" xml:space="preserve">
          <source>A module name will be computed for each module based on its relative location to &lt;code&gt;rootDir&lt;/code&gt;.</source>
          <target state="translated">Se calcular&amp;aacute; un nombre de m&amp;oacute;dulo para cada m&amp;oacute;dulo en funci&amp;oacute;n de su ubicaci&amp;oacute;n relativa a &lt;code&gt;rootDir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fc81a9321caa5212d8c955b9d7611a22e0e64b3" translate="yes" xml:space="preserve">
          <source>A module using CommonJS patterns uses &lt;code&gt;module.exports&lt;/code&gt; to describe the exported values. For example, here is a module which exports a function and a numerical constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcfc7285f1ba3d870a6928e1733a7273fde019a" translate="yes" xml:space="preserve">
          <source>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</source>
          <target state="translated">Un ejemplo más avanzado utiliza la propiedad del prototipo para inferir y restringir las relaciones entre la función constructora y el lado de la instancia de los tipos de clase.</target>
        </trans-unit>
        <trans-unit id="51dd9695c995c08645a93f5859af50c64ef61af8" translate="yes" xml:space="preserve">
          <source>A more common error that this feature catches is adding a newline after a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">Un error m&amp;aacute;s com&amp;uacute;n que detecta esta caracter&amp;iacute;stica es agregar una nueva l&amp;iacute;nea despu&amp;eacute;s de una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02309890136fe9803436c2b1bde34201107f663d" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a type, &lt;code&gt;Y&lt;/code&gt;)</source>
          <target state="translated">Un espacio de nombres &lt;code&gt;X&lt;/code&gt; (porque la declaraci&amp;oacute;n del &lt;code&gt;namespace&lt;/code&gt; contiene un tipo, &lt;code&gt;Y&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7ae465077e189312db19e43d1c7bdbb04e391e9f" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;Z&lt;/code&gt;</source>
          <target state="translated">Un espacio de nombres &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77bbec5ff2f5cfc37ba667daafc8343e4c27cc4d" translate="yes" xml:space="preserve">
          <source>A namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) is now correctly flagged as uncallable. Calling it will result in an error.</source>
          <target state="translated">Una importaci&amp;oacute;n de espacio de nombres (es decir, &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ) ahora est&amp;aacute; correctamente marcada como incallable. Llamarlo resultar&amp;aacute; en un error.</target>
        </trans-unit>
        <trans-unit id="2830a5f5ce7dd5eaff83de00bb84188237d5ac6f" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;!&lt;/code&gt; post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation &lt;code&gt;x!&lt;/code&gt; produces a value of the type of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; excluded. Similar to type assertions of the forms &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; and &lt;code&gt;x as T&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; non-null assertion operator is simply removed in the emitted JavaScript code.</source>
          <target state="translated">&amp;iexcl;Un nuevo &lt;code&gt;!&lt;/code&gt; El operador de expresi&amp;oacute;n posterior a la correcci&amp;oacute;n puede usarse para afirmar que su operando no es nulo y no est&amp;aacute; definido en contextos donde el verificador de tipos no puede concluir ese hecho. En concreto, la operaci&amp;oacute;n &lt;code&gt;x!&lt;/code&gt; produce un valor del tipo de &lt;code&gt;x&lt;/code&gt; con &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; excluidos. Similar al tipo afirmaciones de las formas &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; y &lt;code&gt;x as T&lt;/code&gt; , la &lt;code&gt;!&lt;/code&gt; El operador de aserci&amp;oacute;n no nula simplemente se elimina en el c&amp;oacute;digo JavaScript emitido.</target>
        </trans-unit>
        <trans-unit id="2655be7a46ceb733d0fd15d66bae85ebe5cb1eb1" translate="yes" xml:space="preserve">
          <source>A new flag is also added in TypeScript 2.0 to flag all uses of &lt;code&gt;this&lt;/code&gt; in functions without an explicit type annotation.</source>
          <target state="translated">Tambi&amp;eacute;n se agrega una nueva marca en TypeScript 2.0 para marcar todos los usos de &lt;code&gt;this&lt;/code&gt; en funciones sin una anotaci&amp;oacute;n de tipo expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="74e05c5f83ee7f74c16bbdd86c8307c4e68ce786" translate="yes" xml:space="preserve">
          <source>A new suite of errors which tackle a new problem domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3e808c856b4c4b90bbc578b4afa30e7e8a218" translate="yes" xml:space="preserve">
          <source>A new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt;</source>
          <target state="translated">Una nueva sintaxis para &lt;code&gt;ReadonlyArray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4571ad9d84c9c7959037752a1b8faca40bbe10a7" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to NPM and NuGet. Here is how you can get it and use it with your tools.</source>
          <target state="translated">Una compilaci&amp;oacute;n nocturna de la rama &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt; &lt;code&gt;master&lt;/code&gt; &lt;/a&gt; de TypeScript se publica antes de la medianoche PST en NPM y NuGet. As&amp;iacute; es como puede obtenerlo y usarlo con sus herramientas.</target>
        </trans-unit>
        <trans-unit id="26136197b0e619c7a477a0ede27ddf26c086e432" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to npm. Here is how you can get it and use it with your tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a025aabca041d8656b9b41a0f1be5a93ff1fe1" translate="yes" xml:space="preserve">
          <source>A non-relative import can be resolved relative to &lt;code&gt;baseUrl&lt;/code&gt;, or through path mapping, which we&amp;rsquo;ll cover below. They can also resolve to &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declarations&lt;/a&gt;. Use non-relative paths when importing any of your external dependencies.</source>
          <target state="translated">Una importaci&amp;oacute;n no relativa se puede resolver en relaci&amp;oacute;n con &lt;code&gt;baseUrl&lt;/code&gt; , o mediante el mapeo de rutas, que cubriremos a continuaci&amp;oacute;n. Tambi&amp;eacute;n pueden resolver &lt;a href=&quot;modules#ambient-modules&quot;&gt;declaraciones de m&amp;oacute;dulos ambientales&lt;/a&gt; . Utilice rutas no relativas al importar cualquiera de sus dependencias externas.</target>
        </trans-unit>
        <trans-unit id="036c7405ac8596f3f842074ad7095463b1af061e" translate="yes" xml:space="preserve">
          <source>A non-relative import to &lt;code&gt;moduleB&lt;/code&gt; such as &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt;, in a source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;, would result in attempting the following locations for locating &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">Una importaci&amp;oacute;n no relativa a &lt;code&gt;moduleB&lt;/code&gt; como &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; , en un archivo fuente &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; , resultar&amp;iacute;a en intentar las siguientes ubicaciones para ubicar &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="908464f8d4f6e5d96a7983c65456609769299d87" translate="yes" xml:space="preserve">
          <source>A note about &amp;lsquo;let&amp;rsquo;</source>
          <target state="translated">Una nota sobre 'dejar'</target>
        </trans-unit>
        <trans-unit id="bfe7c80c1a11cfefa188943b94c8dce4cafd7212" translate="yes" xml:space="preserve">
          <source>A note about &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">Una nota sobre &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34d8d6a247e4459c0dd02162269341b98212407d" translate="yes" xml:space="preserve">
          <source>A partial version of it would be:</source>
          <target state="translated">Una versión parcial de ella sería:</target>
        </trans-unit>
        <trans-unit id="43fa7e787c62527d93ae270a4c2aa47ce163ffcd" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism, a lot of people know it as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent API&lt;/a&gt; pattern. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc358ce5550ca2f28f0b4972670dc958c4e4327" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="translated">Un polim&amp;oacute;rfico de &lt;code&gt;this&lt;/code&gt; tipo representa un tipo que es el &lt;em&gt;subtipo&lt;/em&gt; de la clase o interfaz que lo contiene. Esto se denomina polimorfismo limitado por &lt;em&gt;F. &lt;/em&gt;Esto hace que las interfaces jer&amp;aacute;rquicas fluidas sean mucho m&amp;aacute;s f&amp;aacute;ciles de expresar, por ejemplo. Tome una calculadora simple que devuelva &lt;code&gt;this&lt;/code&gt; despu&amp;eacute;s de cada operaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="2ed3773d514d4c4811918e29ff471fbec8ab9085" translate="yes" xml:space="preserve">
          <source>A popular use-case for union types is to describe the set of &lt;code&gt;string&lt;/code&gt;s or &lt;code&gt;number&lt;/code&gt;s &lt;a href=&quot;literal-types&quot;&gt;literal&lt;/a&gt; that a value is allowed to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365b081b2090ee2d0d1ba0c0f61def91ecb0e717" translate="yes" xml:space="preserve">
          <source>A project is compiled in one of the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfc09c2ed20b76aa6a3b9cc810f2a50f0733568" translate="yes" xml:space="preserve">
          <source>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling &lt;code&gt;.ts&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</source>
          <target state="translated">El dise&amp;ntilde;o de una fuente de proyecto a veces no coincide con el de la salida. Por lo general, un conjunto de pasos de construcci&amp;oacute;n dan como resultado la generaci&amp;oacute;n del resultado final. Estos incluyen la compilaci&amp;oacute;n de archivos &lt;code&gt;.ts&lt;/code&gt; en &lt;code&gt;.js&lt;/code&gt; y la copia de dependencias de diferentes ubicaciones de origen en una &amp;uacute;nica ubicaci&amp;oacute;n de salida. El resultado neto es que los m&amp;oacute;dulos en tiempo de ejecuci&amp;oacute;n pueden tener nombres diferentes a los de los archivos fuente que contienen sus definiciones. O las rutas de los m&amp;oacute;dulos en la salida final pueden no coincidir con sus rutas de archivo fuente correspondientes en el momento de la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="282c27706098563c877f1ff268884923d740e395" translate="yes" xml:space="preserve">
          <source>A property access or a function call produces a compile-time error if the object or function is of a type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. However, type guards are extended to support non-null and non-undefined checks.</source>
          <target state="translated">Un acceso a la propiedad o una llamada a una funci&amp;oacute;n produce un error en tiempo de compilaci&amp;oacute;n si el objeto o la funci&amp;oacute;n es de un tipo que incluye &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . Sin embargo, las protecciones de tipos se ampl&amp;iacute;an para admitir comprobaciones no nulas ni indefinidas.</target>
        </trans-unit>
        <trans-unit id="59344ab2361c175ea781e369233d17a3ef1173a2" translate="yes" xml:space="preserve">
          <source>A property declared with a &lt;code&gt;get&lt;/code&gt; accessor and no &lt;code&gt;set&lt;/code&gt; accessor is considered read-only.</source>
          <target state="translated">Una propiedad declarada con un &lt;code&gt;get&lt;/code&gt; acceso get y ning&amp;uacute;n &lt;code&gt;set&lt;/code&gt; acceso establecido se considera de solo lectura.</target>
        </trans-unit>
        <trans-unit id="b689c46a292974d609ea79412658e0ee92a02aed" translate="yes" xml:space="preserve">
          <source>A property or index signature can now be declared with the &lt;code&gt;readonly&lt;/code&gt; modifier is considered read-only.</source>
          <target state="translated">Ahora se puede declarar una propiedad o firma de &amp;iacute;ndice con el modificador de &lt;code&gt;readonly&lt;/code&gt; se considera de solo lectura.</target>
        </trans-unit>
        <trans-unit id="14c9c9574f47af69ee1d2d4201e7c958df2ed786" translate="yes" xml:space="preserve">
          <source>A reader who completes the walkthrough should be able to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d52bcb9c5e9671606eed7fffb194263c9890a7a" translate="yes" xml:space="preserve">
          <source>A regular expression method that matches the regular expression against a string. Called by the &lt;code&gt;String.prototype.match&lt;/code&gt; method.</source>
          <target state="translated">Un m&amp;eacute;todo de expresi&amp;oacute;n regular que compara la expresi&amp;oacute;n regular con una cadena. Llamado por el m&amp;eacute;todo &lt;code&gt;String.prototype.match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd6edb9d65460dc36b50f0399530c31b1e87d57" translate="yes" xml:space="preserve">
          <source>A regular expression method that replaces matched substrings of a string. Called by the &lt;code&gt;String.prototype.replace&lt;/code&gt; method.</source>
          <target state="translated">Un m&amp;eacute;todo de expresi&amp;oacute;n regular que reemplaza subcadenas coincidentes de una cadena. Llamado por el m&amp;eacute;todo &lt;code&gt;String.prototype.replace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d5cbe9a0d4a216822033b575ab84161f890fd4" translate="yes" xml:space="preserve">
          <source>A regular expression method that returns the index within a string that matches the regular expression. Called by the &lt;code&gt;String.prototype.search&lt;/code&gt; method.</source>
          <target state="translated">Un m&amp;eacute;todo de expresi&amp;oacute;n regular que devuelve el &amp;iacute;ndice dentro de una cadena que coincide con la expresi&amp;oacute;n regular. Llamado por el m&amp;eacute;todo &lt;code&gt;String.prototype.search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38d40fad27af50b9cfc4c1b7935edd018faa338e" translate="yes" xml:space="preserve">
          <source>A regular expression method that splits a string at the indices that match the regular expression. Called by the &lt;code&gt;String.prototype.split&lt;/code&gt; method.</source>
          <target state="translated">Un m&amp;eacute;todo de expresi&amp;oacute;n regular que divide una cadena en los &amp;iacute;ndices que coinciden con la expresi&amp;oacute;n regular. Llamado por el m&amp;eacute;todo &lt;code&gt;String.prototype.split&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc17888ce2ecd41d7b6b0d5fb3a3670f069072bf" translate="yes" xml:space="preserve">
          <source>A relative import is resolved relative to the importing file and &lt;em&gt;cannot&lt;/em&gt; resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</source>
          <target state="translated">Una importaci&amp;oacute;n relativa se resuelve en relaci&amp;oacute;n con el archivo de importaci&amp;oacute;n y &lt;em&gt;no se puede&lt;/em&gt; resolver en una declaraci&amp;oacute;n de m&amp;oacute;dulo ambiental. Debe usar importaciones relativas para sus propios m&amp;oacute;dulos que est&amp;aacute;n garantizados para mantener su ubicaci&amp;oacute;n relativa en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="28de4947ee9f22a7989c024ed424c3f367678816" translate="yes" xml:space="preserve">
          <source>A relative import will be resolved relative to the importing file. So &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">Una importaci&amp;oacute;n relativa se resolver&amp;aacute; en relaci&amp;oacute;n con el archivo de importaci&amp;oacute;n. As&amp;iacute; que la &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; en el archivo fuente &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; dar&amp;iacute;a como resultado las siguientes b&amp;uacute;squedas:</target>
        </trans-unit>
        <trans-unit id="d9edb5186e2748078674706a60a9cf32f84d1333" translate="yes" xml:space="preserve">
          <source>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</source>
          <target state="translated">Se permite que un parámetro de reposo tenga un tipo genérico que esté restringido a un tipo de conjunto,y la inferencia de tipo puede inferir tipos tuplicados para tales parámetros de reposo genéricos.Esto permite la captura y difusión de listas de parámetros parciales de orden superior:</target>
        </trans-unit>
        <trans-unit id="10834bc0f63c36734ac19d004f786a265bea8f0c" translate="yes" xml:space="preserve">
          <source>A series of entries which re-map imports to lookup locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;, there is a larger coverage of &lt;code&gt;paths&lt;/code&gt; in &lt;a href=&quot;docs/handbook/module-resolution#path-mapping&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7553b7e9850da0e4309ead9e8788fc38bf0c98" translate="yes" xml:space="preserve">
          <source>A simple rule to follow is to only declare types &lt;em&gt;namespaced&lt;/em&gt; by whatever global variable the library defines. For example, if the library defines the global value &amp;lsquo;cats&amp;rsquo;, you should write</source>
          <target state="translated">Una regla simple a seguir es declarar solo tipos &lt;em&gt;espaciados&lt;/em&gt; por cualquier variable global que defina la biblioteca. Por ejemplo, si la biblioteca define el valor global 'gatos', debe escribir</target>
        </trans-unit>
        <trans-unit id="70f69678357ce810ac7be6d3a7871e410f98bb81" translate="yes" xml:space="preserve">
          <source>A triple-slash reference path is resolved relative to the containing file, if unrooted.</source>
          <target state="translated">Un camino de referencia de triple barra se resuelve en relación con el archivo que contiene,si no está arraigado.</target>
        </trans-unit>
        <trans-unit id="353474e46afb00c48588800a3c6d0c5342041035" translate="yes" xml:space="preserve">
          <source>A tsconfig.json file that doesn&amp;rsquo;t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</source>
          <target state="translated">Un archivo tsconfig.json que no especifica una propiedad de archivos (y por lo tanto hace referencia impl&amp;iacute;citamente a todos los archivos * .ts en todos los subdirectorios) ahora puede contener una propiedad de exclusi&amp;oacute;n que especifica una lista de archivos y / o directorios para excluir de la compilaci&amp;oacute;n. La propiedad de exclusi&amp;oacute;n debe ser una matriz de cadenas, cada una de las cuales especifica un nombre de archivo o carpeta en relaci&amp;oacute;n con la ubicaci&amp;oacute;n del archivo tsconfig.json. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="df0d20ca9dd32bdd7425a8bf1f2869e727193b73" translate="yes" xml:space="preserve">
          <source>A tuple type permits an element to be omitted if it has a postfix &lt;code&gt;?&lt;/code&gt; modifier on its type and all elements to the right of it also have &lt;code&gt;?&lt;/code&gt; modifiers.</source>
          <target state="translated">&amp;iquest;Un tipo de tupla permite omitir un elemento si tiene un sufijo &lt;code&gt;?&lt;/code&gt; modificador en su tipo y todos los elementos a su derecha tambi&amp;eacute;n tienen &lt;code&gt;?&lt;/code&gt; modificadores.</target>
        </trans-unit>
        <trans-unit id="c0fda59c87a9ce8c6218af973a8a318d8c48726a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;C&lt;/code&gt; in the &lt;code&gt;X.Z&lt;/code&gt; namespace</source>
          <target state="translated">Un tipo &lt;code&gt;C&lt;/code&gt; en el espacio de nombres &lt;code&gt;X.Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b8cb0beae34b84268f8712bb01776f705387774" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">A tipo &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="882188abb4f22a21291e791a69d7bc7153c6ea49" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Y&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace</source>
          <target state="translated">Un tipo &lt;code&gt;Y&lt;/code&gt; en el espacio de nombres &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74378f84a7232e7c818036a1aa4f8e790357dad0" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Z&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace (the instance shape of the class)</source>
          <target state="translated">Un tipo &lt;code&gt;Z&lt;/code&gt; en el espacio de nombres &lt;code&gt;X&lt;/code&gt; (la forma de instancia de la clase)</target>
        </trans-unit>
        <trans-unit id="c1687cc1f239d5cbfef8dd21147b9dd24d76a0c8" translate="yes" xml:space="preserve">
          <source>A type alias declaration (&lt;code&gt;type sn = number | string;&lt;/code&gt;)</source>
          <target state="translated">Una declaraci&amp;oacute;n de alias de tipo ( &lt;code&gt;type sn = number | string;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bf4c2689d169ce1d458db13d7d40fdbf2f6b6244" translate="yes" xml:space="preserve">
          <source>A type alias that takes the union of those types &amp;mdash; the &lt;em&gt;union&lt;/em&gt;.</source>
          <target state="translated">Un alias de tipo que toma la uni&amp;oacute;n de esos tipos: la &lt;em&gt;uni&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2efd539d70b51bc5ae0611e5b848813a9078c1" translate="yes" xml:space="preserve">
          <source>A type can include an index signature to explicitly indicate that excess properties are permitted:</source>
          <target state="translated">Un tipo puede incluir una firma de índice para indicar explícitamente que se permite el exceso de propiedades:</target>
        </trans-unit>
        <trans-unit id="7923f87ba1b11ff5aadde3784a645b7bf0213b2d" translate="yes" xml:space="preserve">
          <source>A type cannot be changed after being created</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c383b7f56821c1f9a53cd7d2c78316dfd7e93b" translate="yes" xml:space="preserve">
          <source>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for &lt;code&gt;x.y.z&lt;/code&gt; will have no effect following an assignment to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y&lt;/code&gt;, or &lt;code&gt;x.y.z&lt;/code&gt;.</source>
          <target state="translated">Una protecci&amp;oacute;n de tipo para un nombre con puntos no tiene efecto despu&amp;eacute;s de una asignaci&amp;oacute;n a cualquier parte del nombre con puntos. Por ejemplo, una protecci&amp;oacute;n de tipo para &lt;code&gt;x.y.z&lt;/code&gt; no tendr&amp;aacute; ning&amp;uacute;n efecto despu&amp;eacute;s de una asignaci&amp;oacute;n &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x.y&lt;/code&gt; o &lt;code&gt;x.y.z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a377432dffa8ea7066844e2455d6987bca2958f" translate="yes" xml:space="preserve">
          <source>A type parameter is deemed optional if it has a default.</source>
          <target state="translated">Un parámetro de tipo se considera opcional si tiene un valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="cc781420c33da6107d9682c46a6f8b3ef934ac7b" translate="yes" xml:space="preserve">
          <source>A type-system based only on inference with JavaScript code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d14b0d6b21fc7288313f91b187510fabde9b646" translate="yes" xml:space="preserve">
          <source>A types package is a folder with a file called &lt;code&gt;index.d.ts&lt;/code&gt; or a folder with a &lt;code&gt;package.json&lt;/code&gt; that has a &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="translated">Un paquete de tipos es una carpeta con un archivo llamado &lt;code&gt;index.d.ts&lt;/code&gt; o una carpeta con un &lt;code&gt;package.json&lt;/code&gt; que tiene un campo de &lt;code&gt;types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14d41e9733c26726f7735bdd4c4e805ad6e0b738" translate="yes" xml:space="preserve">
          <source>A union type describes a value that can be one of several types. We use the vertical bar (&lt;code&gt;|&lt;/code&gt;) to separate each type, so &lt;code&gt;number | string | boolean&lt;/code&gt; is the type of a value that can be a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">Un tipo de uni&amp;oacute;n describe un valor que puede ser de varios tipos. Usamos la barra vertical ( &lt;code&gt;|&lt;/code&gt; ) para separar cada tipo, entonces &lt;code&gt;number | string | boolean&lt;/code&gt; es el tipo de valor que puede ser un &lt;code&gt;number&lt;/code&gt; , una &lt;code&gt;string&lt;/code&gt; o un &lt;code&gt;boolean&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="77032b55ce2cb4248190b5e5184e5e0b38ee393b" translate="yes" xml:space="preserve">
          <source>A user could express &lt;code&gt;2 * 5 + 1&lt;/code&gt; as</source>
          <target state="translated">Un usuario podr&amp;iacute;a expresar &lt;code&gt;2 * 5 + 1&lt;/code&gt; como</target>
        </trans-unit>
        <trans-unit id="199d562e0a71e63f245aa31f49c36513d849c222" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;C&lt;/code&gt; that is a property of the &lt;code&gt;X.Z&lt;/code&gt; value</source>
          <target state="translated">Un valor &lt;code&gt;C&lt;/code&gt; que es una propiedad del valor &lt;code&gt;X.Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e079e6071fdb5e16a79cbbbac36f7c59e77e29" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a value, &lt;code&gt;Z&lt;/code&gt;)</source>
          <target state="translated">Un valor &lt;code&gt;X&lt;/code&gt; (porque la declaraci&amp;oacute;n del &lt;code&gt;namespace&lt;/code&gt; contiene un valor, &lt;code&gt;Z&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="72326d369b07efe650b4c687b18320a6555b7a1a" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Y&lt;/code&gt; (of type &lt;code&gt;number&lt;/code&gt;) that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">Un valor &lt;code&gt;Y&lt;/code&gt; (de tipo &lt;code&gt;number&lt;/code&gt; ) que es una propiedad del valor &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2db8707fec6d748cc12ab97735dc5f33a19182c2" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">Un valor &lt;code&gt;Z&lt;/code&gt; que es una propiedad del valor &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ce9a077fea19a3768255595563e3f325b99287" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value (the constructor function of the class)</source>
          <target state="translated">Un valor &lt;code&gt;Z&lt;/code&gt; que es una propiedad del valor &lt;code&gt;X&lt;/code&gt; (la funci&amp;oacute;n constructora de la clase)</target>
        </trans-unit>
        <trans-unit id="2ac5e8f9f24c7489cdb9a76f63355463e38d2ed2" translate="yes" xml:space="preserve">
          <source>A variable declared with no type annotation and an initial value of &lt;code&gt;[]&lt;/code&gt; is considered an implicit &lt;code&gt;any[]&lt;/code&gt; variable. However, each subsequent &lt;code&gt;x.push(value)&lt;/code&gt;, &lt;code&gt;x.unshift(value)&lt;/code&gt; or &lt;code&gt;x[n] = value&lt;/code&gt; operation &lt;em&gt;evolves&lt;/em&gt; the type of the variable in accordance with what elements are added to it.</source>
          <target state="translated">Una variable declarada sin anotaci&amp;oacute;n de tipo y un valor inicial de &lt;code&gt;[]&lt;/code&gt; se considera una variable impl&amp;iacute;cita de &lt;code&gt;any[]&lt;/code&gt; . Sin embargo, cada subsiguiente &lt;code&gt;x.push(value)&lt;/code&gt; , &lt;code&gt;x.unshift(value)&lt;/code&gt; o &lt;code&gt;x[n] = value&lt;/code&gt; operaci&amp;oacute;n &lt;em&gt;evoluciona&lt;/em&gt; el tipo de la variable de acuerdo con lo que los elementos se a&amp;ntilde;aden a la misma.</target>
        </trans-unit>
        <trans-unit id="70d19e4c7a5fa9d0f738254cc159113f3fd200b2" translate="yes" xml:space="preserve">
          <source>AMD / RequireJS SimpleModule.js</source>
          <target state="translated">AMD/RequireJS SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="d64764987e4f302df4936aa982040ba263c5581e" translate="yes" xml:space="preserve">
          <source>AMD Module names</source>
          <target state="translated">Los nombres de los módulos de AMD</target>
        </trans-unit>
        <trans-unit id="b4e985e77edef4f93404d5e6768643dd9e768f9b" translate="yes" xml:space="preserve">
          <source>AMD-dependency optional names</source>
          <target state="translated">Nombres opcionales de la dependencia de la DMA</target>
        </trans-unit>
        <trans-unit id="62845d0d9af23cbc1eec333eb2ecfd163d55a726" translate="yes" xml:space="preserve">
          <source>API Changes</source>
          <target state="translated">Cambios en la API</target>
        </trans-unit>
        <trans-unit id="4a2fd182a22546b9a5411efbef21d9ce9da6d56a" translate="yes" xml:space="preserve">
          <source>APIs available in &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;WebWorker&lt;/a&gt; contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514c168cf5e4e1365917faccfdc0926188272b5f" translate="yes" xml:space="preserve">
          <source>APIs for the &lt;a href=&quot;https://wikipedia.org/wiki/Windows_Script_Host&quot;&gt;Windows Script Hosting System&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512a3dad0b0ce90df79e253450f20d82200891c0" translate="yes" xml:space="preserve">
          <source>APIs to Support &lt;code&gt;--build&lt;/code&gt; and &lt;code&gt;--incremental&lt;/code&gt;</source>
          <target state="translated">API de soporte &lt;code&gt;--build&lt;/code&gt; e &lt;code&gt;--incremental&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes" xml:space="preserve">
          <source>ASP.NET Core</source>
          <target state="translated">Núcleo de ASP.NET</target>
        </trans-unit>
        <trans-unit id="366e9dcb2473f425157fef0b4dc8e68450d4a527" translate="yes" xml:space="preserve">
          <source>ASP.NET Core + TypeScript</source>
          <target state="translated">ASP.NET Core+TypeScript</target>
        </trans-unit>
        <trans-unit id="fd2bfb743d58034cf4f2ef0407bda4991e6e266a" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Add TypeScript</source>
          <target state="translated">Núcleo ASP.NET:Agregar el TypeScript</target>
        </trans-unit>
        <trans-unit id="26ca92c515719697094cd865e18cbd056f86e90b" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Setup</source>
          <target state="translated">ASP.NET Core:Configuración</target>
        </trans-unit>
        <trans-unit id="50eed69def791463bbdef9085e70b4aade82ea60" translate="yes" xml:space="preserve">
          <source>About &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b106ce4000d8d8c80eef39d6b34b6a0ccaab29" translate="yes" xml:space="preserve">
          <source>About this Handbook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8462d6e971391c5728bd5c55cd114f6c45225c83" translate="yes" xml:space="preserve">
          <source>Above, all inferences for &lt;code&gt;T&lt;/code&gt; originate in contravariant positions, and we therefore infer the &lt;em&gt;best common subtype&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;. This contrasts with inferences from covariant positions, where we infer the &lt;em&gt;best common supertype&lt;/em&gt;.</source>
          <target state="translated">Por encima, todas las inferencias para &lt;code&gt;T&lt;/code&gt; se originan en posiciones contravariant, y por lo tanto inferir la &lt;em&gt;mejor subtipo com&amp;uacute;n&lt;/em&gt; para &lt;code&gt;T&lt;/code&gt; . Esto contrasta con las inferencias de posiciones covariantes, donde inferimos el &lt;em&gt;mejor supertipo com&amp;uacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d99c638eab09eef692bca448341109f58d65928f" translate="yes" xml:space="preserve">
          <source>Above, we have a &lt;code&gt;StringArray&lt;/code&gt; interface that has an index signature. This index signature states that when a &lt;code&gt;StringArray&lt;/code&gt; is indexed with a &lt;code&gt;number&lt;/code&gt;, it will return a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Arriba, tenemos una interfaz &lt;code&gt;StringArray&lt;/code&gt; que tiene una firma de &amp;iacute;ndice. Esta firma de &amp;iacute;ndice indica que cuando un &lt;code&gt;StringArray&lt;/code&gt; se indexa con un &lt;code&gt;number&lt;/code&gt; , devolver&amp;aacute; una &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29268223f69d326a5adbf22aa200f48337d3383a" translate="yes" xml:space="preserve">
          <source>Above, we have a numeric enum where &lt;code&gt;Up&lt;/code&gt; is initialized with &lt;code&gt;1&lt;/code&gt;. All of the following members are auto-incremented from that point on. In other words, &lt;code&gt;Direction.Up&lt;/code&gt; has the value &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; has &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;Left&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;Right&lt;/code&gt; has &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Arriba, tenemos una enumeraci&amp;oacute;n num&amp;eacute;rica donde &lt;code&gt;Up&lt;/code&gt; se inicializa con &lt;code&gt;1&lt;/code&gt; . Todos los miembros siguientes se incrementan autom&amp;aacute;ticamente a partir de ese momento. En otras palabras, &lt;code&gt;Direction.Up&lt;/code&gt; tiene el valor &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;Down&lt;/code&gt; tiene &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;Left&lt;/code&gt; tiene &lt;code&gt;3&lt;/code&gt; y &lt;code&gt;Right&lt;/code&gt; tiene &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes" xml:space="preserve">
          <source>Abstract Classes</source>
          <target state="translated">Clases de resumen</target>
        </trans-unit>
        <trans-unit id="92d2d55c032fde11e5fb12992c8af2dbab612b6c" translate="yes" xml:space="preserve">
          <source>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The &lt;code&gt;abstract&lt;/code&gt; keyword is used to define abstract classes as well as abstract methods within an abstract class.</source>
          <target state="translated">Las clases abstractas son clases base de las que se pueden derivar otras clases. No se pueden crear instancias directamente. A diferencia de una interfaz, una clase abstracta puede contener detalles de implementaci&amp;oacute;n para sus miembros. La palabra clave &lt;code&gt;abstract&lt;/code&gt; a se utiliza para definir clases abstractas, as&amp;iacute; como m&amp;eacute;todos abstractos dentro de una clase abstracta.</target>
        </trans-unit>
        <trans-unit id="90c7ee5a4b4ef6e67fa95b9c12e51b21561cd41f" translate="yes" xml:space="preserve">
          <source>Abstract properties and accessors</source>
          <target state="translated">Propiedades y accesorios abstractos</target>
        </trans-unit>
        <trans-unit id="bc1eac0b05aa68bdf95d2d14137e5c9213052598" translate="yes" xml:space="preserve">
          <source>Accept JavaScript files as inputs (with &lt;code&gt;allowJs&lt;/code&gt;).</source>
          <target state="translated">Acepte archivos JavaScript como entradas (con &lt;code&gt;allowJs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f52e0a010fa39d93f5775a9f132d6deb5746c842" translate="yes" xml:space="preserve">
          <source>Accessing an element outside the set of known indices fails with an error:</source>
          <target state="translated">Acceder a un elemento fuera del conjunto de índices conocidos falla con un error:</target>
        </trans-unit>
        <trans-unit id="9211673b68532807a6d2c852f45d3d0a3786afaf" translate="yes" xml:space="preserve">
          <source>Accessor Decorators</source>
          <target state="translated">Decoradores de accesorios</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="63486368539a5a919d2c26a960c13aeb3604f62b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;declare module &quot;[libname]&quot; { }&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba917141f6a1280321df068fb903677e998c5655" translate="yes" xml:space="preserve">
          <source>Add TypeScript</source>
          <target state="translated">Añada el tipo de letra</target>
        </trans-unit>
        <trans-unit id="03f2f0c4f330f17bca1624a3a414eba729371bb6" translate="yes" xml:space="preserve">
          <source>Add TypeScript code</source>
          <target state="translated">Añade el código de TypeScript</target>
        </trans-unit>
        <trans-unit id="46b617acf1ae2b67fe01caa83a0ba7b8ee5a4ac7" translate="yes" xml:space="preserve">
          <source>Add TypeScript to your dev dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3415f2a3b0ab2d336eb4c1382554b771158a6ea" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;tsconfig.json&lt;/code&gt; to configure TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2826bcb0cd82d31aa891fcd966fb1d7028f4f052" translate="yes" xml:space="preserve">
          <source>Add a TypeScript configuration file</source>
          <target state="translated">Añadir un archivo de configuración de TypeScript</target>
        </trans-unit>
        <trans-unit id="d15c277560e45ee3069031db7b1443def54bf1e5" translate="yes" xml:space="preserve">
          <source>Add an index signature to the weak type (i.e. &lt;code&gt;[propName: string]: {}&lt;/code&gt;).</source>
          <target state="translated">Agregue una firma de &amp;iacute;ndice al tipo d&amp;eacute;bil (es decir, &lt;code&gt;[propName: string]: {}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d86f6887abf355322f84124fc796c5eca75b3b63" translate="yes" xml:space="preserve">
          <source>Add example code</source>
          <target state="translated">Añadir código de ejemplo</target>
        </trans-unit>
        <trans-unit id="030eb6eab9d9ce5260b44edf17a0969d1e22a783" translate="yes" xml:space="preserve">
          <source>Add modules to the code</source>
          <target state="translated">Añadir módulos al código</target>
        </trans-unit>
        <trans-unit id="0897ccd0a932866daaf546a1ee6c09bc49494aa1" translate="yes" xml:space="preserve">
          <source>Add the following code to the &lt;code&gt;app.ts&lt;/code&gt; file.</source>
          <target state="translated">Agregue el siguiente c&amp;oacute;digo al archivo &lt;code&gt;app.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63b990890227ea0e4c75e4a3fe72a5643f059cf0" translate="yes" xml:space="preserve">
          <source>Add the template inside the braces of the declare module, and see where your usage breaks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6d6723ea89a80d4cba5523c3c76499f133755b" translate="yes" xml:space="preserve">
          <source>Adding TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2583d632f0a677d9ba11848beebe77e200bfeb" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">Agregar un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; en un directorio indica que el directorio es la ra&amp;iacute;z de un proyecto de TypeScript. El archivo tsconfig.json especifica los archivos ra&amp;iacute;z y las opciones del compilador necesarias para compilar el proyecto. Un proyecto se compila de una de las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="8c611c8266b493d4250ab1994cb67dac5e5d7db4" translate="yes" xml:space="preserve">
          <source>Adding new fields to an existing interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbea2ea77887f1c86da0aa25a3f25ac23ead618" translate="yes" xml:space="preserve">
          <source>Adding using a &lt;code&gt;namespace&lt;/code&gt;</source>
          <target state="translated">Agregar usando un &lt;code&gt;namespace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51ec7e9fd3e27aeb0e50a50e1368f25d547f3a58" translate="yes" xml:space="preserve">
          <source>Adding using an &lt;code&gt;interface&lt;/code&gt;</source>
          <target state="translated">Agregar usando una &lt;code&gt;interface&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd37b199ac0e5e434243b868db9e5bf59fc0b12" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2015 (also known as ES6) - &lt;code&gt;array.find&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Proxy&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Reflect&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee0d1e5c7cb32ad383fffbe67322822cc7ffc56" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2016 - &lt;code&gt;array.include&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e994571e74a140e2c02e5a1c020db032be8f18" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2017 - &lt;code&gt;Object.entries&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Atomics&lt;/code&gt;, &lt;code&gt;SharedArrayBuffer&lt;/code&gt;, &lt;code&gt;date.formatToParts&lt;/code&gt;, typed arrays, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbb8fc3866150fbae3eb7909abccd9056ff25fb" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2018 - &lt;code&gt;async&lt;/code&gt; iterables, &lt;code&gt;promise.finally&lt;/code&gt;, &lt;code&gt;Intl.PluralRules&lt;/code&gt;, &lt;code&gt;rexexp.groups&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c596730da78330f273d9f27482a3622097fc44" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2019 - &lt;code&gt;array.flat&lt;/code&gt;, &lt;code&gt;array.flatMap&lt;/code&gt;, &lt;code&gt;Object.fromEntries&lt;/code&gt;, &lt;code&gt;string.trimStart&lt;/code&gt;, &lt;code&gt;string.trimEnd&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f239d6c54edfc279434f6bfed958b9f60c0681c3" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2020 - &lt;code&gt;string.matchAll&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5945ef8d12f1d6daf29632bc72ac7f3e5760f6" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ESNext - This changes as the JavaScript specification evolves</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b365969c1cff42268e57d78eee550841c3962e45" translate="yes" xml:space="preserve">
          <source>Additional module resolution flags</source>
          <target state="translated">Banderas de resolución de módulos adicionales</target>
        </trans-unit>
        <trans-unit id="5bc0373dbdf9447ae6c7d80c2c34b8dc3091badc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;another caveat&lt;/a&gt; of this new functionality is that due to certain limitations, &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; can&amp;rsquo;t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (&lt;code&gt;{}&lt;/code&gt;), and when used on a function with overloads, only the last overload will ever be modeled.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;otra advertencia&lt;/a&gt; de esta nueva funcionalidad es que debido a ciertas limitaciones, &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; y &lt;code&gt;apply&lt;/code&gt; a&amp;uacute;n no puede modelar completamente funciones gen&amp;eacute;ricas o funciones que tienen sobrecargas. Cuando se utilizan estos m&amp;eacute;todos en una funci&amp;oacute;n gen&amp;eacute;rica, los par&amp;aacute;metros de tipo se sustituir&amp;aacute;n por el tipo de objeto vac&amp;iacute;o ( &lt;code&gt;{}&lt;/code&gt; ), y cuando se utilicen en una funci&amp;oacute;n con sobrecargas, solo se modelar&amp;aacute; la &amp;uacute;ltima sobrecarga.</target>
        </trans-unit>
        <trans-unit id="15ac4ccfaca700b5bb61ababb10985733b43516f" translate="yes" xml:space="preserve">
          <source>Additionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c07f0e3695aef1b4eb4f9692657a313d0394be" translate="yes" xml:space="preserve">
          <source>Additionally, generators just assumed the type of &lt;code&gt;yield&lt;/code&gt; was always &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, los generadores simplemente asumieron que el tipo de &lt;code&gt;yield&lt;/code&gt; siempre era &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9897d524bc1adaf827ec23a4f3fb80edccd67b36" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; interface can be used to specify extra properties used by the JSX framework which are not generally used by the components&amp;rsquo; props or arguments - for instance &lt;code&gt;key&lt;/code&gt; in React. Specializing further, the generic &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the &lt;code&gt;ref&lt;/code&gt; attribute of type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.</source>
          <target state="translated">Adem&amp;aacute;s, la interfaz &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; se puede usar para especificar propiedades adicionales utilizadas por el marco JSX que generalmente no son utilizadas por los accesorios o argumentos de los componentes, por ejemplo, la &lt;code&gt;key&lt;/code&gt; en React. Especializ&amp;aacute;ndose a&amp;uacute;n m&amp;aacute;s, el tipo gen&amp;eacute;rico &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; tambi&amp;eacute;n se puede usar para especificar el mismo tipo de atributos adicionales solo para los componentes de la clase (y no los Componentes de la funci&amp;oacute;n). En este tipo, el par&amp;aacute;metro gen&amp;eacute;rico corresponde al tipo de instancia de clase. En React, esto se usa para permitir el atributo &lt;code&gt;ref&lt;/code&gt; de tipo &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; . En t&amp;eacute;rminos generales, todas las propiedades de estas interfaces deben ser opcionales, a menos que tenga la intenci&amp;oacute;n de que los usuarios de su marco JSX necesiten proporcionar alg&amp;uacute;n atributo en cada etiqueta.</target>
        </trans-unit>
        <trans-unit id="b91aefeee6c1829819327d9dfe82ea027b26c097" translate="yes" xml:space="preserve">
          <source>Additionally, to preserve compatibility with existing build workflows, &lt;code&gt;tsc&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; automatically build dependencies unless invoked with the &lt;code&gt;--build&lt;/code&gt; switch. Let&amp;rsquo;s learn more about &lt;code&gt;--build&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, para mantener la compatibilidad con los flujos de trabajo de construcci&amp;oacute;n existentes, &lt;code&gt;tsc&lt;/code&gt; ser&amp;aacute; &lt;em&gt;no&lt;/em&gt; construir autom&amp;aacute;ticamente las dependencias a no ser que se invoca con el &lt;code&gt;--build&lt;/code&gt; interruptor. Aprendamos m&amp;aacute;s sobre &lt;code&gt;--build&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb5aba76318fd8538ec6382a2c356952caebc47" translate="yes" xml:space="preserve">
          <source>Adjustments in module resolution logic</source>
          <target state="translated">Ajustes en la lógica de resolución del módulo</target>
        </trans-unit>
        <trans-unit id="4d064726954a17487f94e931f5b157b733ec22ed" translate="yes" xml:space="preserve">
          <source>Advanced</source>
          <target state="translated">Advanced</target>
        </trans-unit>
        <trans-unit id="051f9a673eec5b48c922324c96f3a02ca352b664" translate="yes" xml:space="preserve">
          <source>Advanced Combinations</source>
          <target state="translated">Combinaciones avanzadas</target>
        </trans-unit>
        <trans-unit id="af1b06d1c8791683bf16e52630b903baefea447c" translate="yes" xml:space="preserve">
          <source>Advanced Techniques</source>
          <target state="translated">Técnicas avanzadas</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">Temas avanzados</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">Tipos avanzados</target>
        </trans-unit>
        <trans-unit id="fb80c67075198375c2e70ac850bebb21868957d3" translate="yes" xml:space="preserve">
          <source>After all, remember that all the convenience of &lt;code&gt;any&lt;/code&gt; comes at the cost of losing type safety. Type safety is one of the main motivations for using TypeScript and you should try to avoid using &lt;code&gt;any&lt;/code&gt; when not necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54113ef438de5a4b862decfc768acf29d440c666" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;bundle&lt;/code&gt; we use &lt;code&gt;source&lt;/code&gt; (our alias for vinyl-source-stream) to name our output bundle &lt;code&gt;bundle.js&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de llamar a &lt;code&gt;bundle&lt;/code&gt; usamos &lt;code&gt;source&lt;/code&gt; (nuestro alias para vinyl-source-stream) para nombrar nuestro paquete de salida &lt;code&gt;bundle.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="408851febc5890c19a84d2e33af34c246f1e0287" translate="yes" xml:space="preserve">
          <source>After capturing the &lt;code&gt;div&lt;/code&gt; element, the &lt;code&gt;children&lt;/code&gt; prop will return a &lt;code&gt;HTMLCollection&lt;/code&gt; list containing the &lt;code&gt;HTMLParagraphElements&lt;/code&gt;. The &lt;code&gt;childNodes&lt;/code&gt; property will return a similar &lt;code&gt;NodeList&lt;/code&gt; list of nodes. Each &lt;code&gt;p&lt;/code&gt; tag will still be of type &lt;code&gt;HTMLParagraphElements&lt;/code&gt;, but the &lt;code&gt;NodeList&lt;/code&gt; can contain additional &lt;em&gt;HTML nodes&lt;/em&gt; that the &lt;code&gt;HTMLCollection&lt;/code&gt; list cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a74c2ec05571930c83fcba6df212a860c81677b" translate="yes" xml:space="preserve">
          <source>After compiling and running the &lt;em&gt;index.html&lt;/em&gt; page, the resulting HTML will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f00e5874f2361b655fbe3423460af4e2465d08" translate="yes" xml:space="preserve">
          <source>After that, you&amp;rsquo;ll be able to import lodash with no issues, and get accurate completions.</source>
          <target state="translated">Despu&amp;eacute;s de eso, podr&amp;aacute; importar lodash sin problemas y obtener finalizaciones precisas.</target>
        </trans-unit>
        <trans-unit id="06c3fc331ac388b23fddf0085ca5e76cb6b8d9ba" translate="yes" xml:space="preserve">
          <source>After you should see an &lt;code&gt;npm&lt;/code&gt; folder in your solution explorer</source>
          <target state="translated">Despu&amp;eacute;s, deber&amp;iacute;a ver una carpeta &lt;code&gt;npm&lt;/code&gt; en el explorador de soluciones</target>
        </trans-unit>
        <trans-unit id="b4510f26185d545e1f9aaebb5b614087f1eb1769" translate="yes" xml:space="preserve">
          <source>Again, being explicit, the following things create values:</source>
          <target state="translated">De nuevo,siendo explícitos,las siguientes cosas crean valores:</target>
        </trans-unit>
        <trans-unit id="5eae1c48b28511e25caa33f05cb9d4dfab638b20" translate="yes" xml:space="preserve">
          <source>Again, the above code is equivalent to the following.</source>
          <target state="translated">De nuevo,el código anterior es equivalente a lo siguiente.</target>
        </trans-unit>
        <trans-unit id="57d29b61eba4579f79786a30e1c6e7ebb0cec52d" translate="yes" xml:space="preserve">
          <source>Again, this isn&amp;rsquo;t an error because the &lt;em&gt;structures&lt;/em&gt; of these classes are the same. While this may seem like a potential source of confusion, in practice, identical classes that shouldn&amp;rsquo;t be related are not common.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfe030bc3f42b42dc5c919d01197fcd0004b2c5" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;mdash; they&amp;rsquo;re independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf3fd22ac6a36d88878ca8d53a1d82c01a94dc2" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;ndash; they&amp;rsquo;re independent.</source>
          <target state="translated">Nuevamente, hemos usado &lt;code&gt;Bar&lt;/code&gt; como tipo y valor aqu&amp;iacute;. Tenga en cuenta que no tuvimos que declarar el valor de &lt;code&gt;Bar&lt;/code&gt; como del tipo &lt;code&gt;Bar&lt;/code&gt; , son independientes.</target>
        </trans-unit>
        <trans-unit id="f0dcad08135c25e6858c7a0bc8fc97fa602084c7" translate="yes" xml:space="preserve">
          <source>Alias for &amp;ldquo;ES2015&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bc045865e0b8f9a9b71594259251243e592051" translate="yes" xml:space="preserve">
          <source>Alias for &amp;ldquo;ES2016&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="3cb27e3d6bbfd0f085fdbe02b42dec5e1744a340" translate="yes" xml:space="preserve">
          <source>Aliasing doesn&amp;rsquo;t actually create a new type - it creates a new &lt;em&gt;name&lt;/em&gt; to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</source>
          <target state="translated">En realidad, el alias no crea un nuevo tipo, sino un nuevo &lt;em&gt;nombre&lt;/em&gt; para referirse a ese tipo. Poner un alias en una primitiva no es muy &amp;uacute;til, aunque se puede usar como una forma de documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9d6c399afd60c09e251a03e83d9bc9a1c384d822" translate="yes" xml:space="preserve">
          <source>All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; section in your &lt;code&gt;package.json&lt;/code&gt;. For example, imagine we authored a package that used Browserify and TypeScript.</source>
          <target state="translated">Todas las dependencias son administradas por npm. Aseg&amp;uacute;rese de que todos los paquetes de declaraci&amp;oacute;n de los que depende est&amp;eacute;n marcados correctamente en la secci&amp;oacute;n &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; de su &lt;code&gt;package.json&lt;/code&gt; . Por ejemplo, imagina que creamos un paquete que usa Browserify y TypeScript.</target>
        </trans-unit>
        <trans-unit id="45d806df121ff13261ffaf919876e11a01813f29" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified</source>
          <target state="translated">Todos los archivos de implementaci&amp;oacute;n deben coincidir con un patr&amp;oacute;n de &lt;code&gt;include&lt;/code&gt; o aparecer en la matriz de &lt;code&gt;files&lt;/code&gt; . Si se viola esta restricci&amp;oacute;n, &lt;code&gt;tsc&lt;/code&gt; le informar&amp;aacute; qu&amp;eacute; archivos no se especificaron</target>
        </trans-unit>
        <trans-unit id="4e5c880db21c996cec3fc4988c560583fa9982e1" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd3b6e7826e2d43235c94e25c6703e5515d96cd" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Todas las importaciones de un m&amp;oacute;dulo de taquigraf&amp;iacute;a tendr&amp;aacute;n el tipo &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0df7a5916e9a8c72882caaac651848e0eeba01" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the any type.</source>
          <target state="translated">Todas las importaciones de un módulo de taquigrafía tendrán el tipo que sea.</target>
        </trans-unit>
        <trans-unit id="fee6f3b1a8be543040dd1ce13fd64e1e346a330f" translate="yes" xml:space="preserve">
          <source>All imports to any module under &lt;code&gt;myLibrary&lt;/code&gt; would be considered to have the type &lt;code&gt;any&lt;/code&gt; by the compiler; thus, shutting down any checking on the shapes or types of these modules.</source>
          <target state="translated">El &lt;code&gt;myLibrary&lt;/code&gt; considerar&amp;aacute; que todas las importaciones a cualquier m&amp;oacute;dulo de myLibrary tienen el tipo &lt;code&gt;any&lt;/code&gt; ; por lo tanto, cerrando cualquier control sobre las formas o tipos de estos m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="711241f4a2d9733149f5b0fa0a9c433a6be2957f" translate="yes" xml:space="preserve">
          <source>All of the above types have a field named &lt;code&gt;state&lt;/code&gt;, and then they also have their own fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57b961e5b675a38b262426fe4a67078aecb1477" translate="yes" xml:space="preserve">
          <source>All of the following are red flags for module structuring. Double-check that you&amp;rsquo;re not trying to namespace your external modules if any of these apply to your files:</source>
          <target state="translated">Todas las siguientes son se&amp;ntilde;ales de alerta para la estructuraci&amp;oacute;n de m&amp;oacute;dulos. Vuelva a verificar que no est&amp;aacute; intentando asignar un espacio de nombres a sus m&amp;oacute;dulos externos si alguno de estos se aplica a sus archivos:</target>
        </trans-unit>
        <trans-unit id="5f48504d51c20fbd89324cd74339cdb9e81a6c89" translate="yes" xml:space="preserve">
          <source>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">Todas las rutas relativas encontradas en el archivo de configuración se resolverán en relación con el archivo de configuración en el que se originaron.</target>
        </trans-unit>
        <trans-unit id="315057eae22d62b0d6ed2f001a47c88ccf49ba08" translate="yes" xml:space="preserve">
          <source>All the strictness flags (including just &lt;code&gt;strict&lt;/code&gt;)</source>
          <target state="translated">Todas las banderas de rigor (incluidas las &lt;code&gt;strict&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="11378de3ed9317ae1cc9f1d37c886e6088970d68" translate="yes" xml:space="preserve">
          <source>AllValidators.ts</source>
          <target state="translated">AllValidators.ts</target>
        </trans-unit>
        <trans-unit id="fc58b8ed05bcec6a23ae0f9b780d0d812c7a4f62" translate="yes" xml:space="preserve">
          <source>Allow JS - &lt;code&gt;allowJs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20b06e157c57d9a78b57caf9d2b542ef2e984fd" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be compiled.</source>
          <target state="translated">Permita que se compilen los archivos de JavaScript.</target>
        </trans-unit>
        <trans-unit id="4127f7dca17f65d3e9f2da7cd048b313c157835a" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be imported inside your project, instead of just &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files. For example, this JS file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5f4564c78948840747ee82f21c0e6f8232869a" translate="yes" xml:space="preserve">
          <source>Allow Synthetic Default Imports - &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03080da287c39d6533842b0d5b99bb15bf6a11b4" translate="yes" xml:space="preserve">
          <source>Allow Umd Global Access - &lt;code&gt;allowUmdGlobalAccess&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f45a74002920f6a947fa3ad7930927614185e1d" translate="yes" xml:space="preserve">
          <source>Allow Unreachable Code - &lt;code&gt;allowUnreachableCode&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c098cda1fb5e0449f54b4fa69bd2ca68f4c38505" translate="yes" xml:space="preserve">
          <source>Allow Unused Labels - &lt;code&gt;allowUnusedLabels&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817e523690a2903bd65bba96f5e1a75cd990d338" translate="yes" xml:space="preserve">
          <source>Allow accessing UMD globals from modules.</source>
          <target state="translated">Permitir el acceso a los globos UMD desde los módulos.</target>
        </trans-unit>
        <trans-unit id="fe8c273574466d1f1e8e48a9866bca1049e958da" translate="yes" xml:space="preserve">
          <source>Allow captured &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; in loops</source>
          <target state="translated">Permitir &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; capturados en bucles</target>
        </trans-unit>
        <trans-unit id="0313de72619ba05b9f37beba9bc65ea42f27f39d" translate="yes" xml:space="preserve">
          <source>Allow comments in tsconfig.json</source>
          <target state="translated">Permitir comentarios en tsconfig.json</target>
        </trans-unit>
        <trans-unit id="243a0709c425e1dcc854b129a4e90d01a36f16eb" translate="yes" xml:space="preserve">
          <source>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</source>
          <target state="translated">Permitir importaciones por defecto de módulos sin exportación por defecto.Esto no afecta a la emisión de código,sólo a la comprobación de tipos.</target>
        </trans-unit>
        <trans-unit id="2fe77e2c3c1c895a9de9714c2ee0a698b6a26f2c" translate="yes" xml:space="preserve">
          <source>Allow duplicate identifiers across declarations</source>
          <target state="translated">Permitir la duplicación de identificadores en las declaraciones</target>
        </trans-unit>
        <trans-unit id="c3d79af7df869c57746cb28085bd6d2457c5fb38" translate="yes" xml:space="preserve">
          <source>Allowed Values</source>
          <target state="translated">Valores permitidos</target>
        </trans-unit>
        <trans-unit id="51d3649666c81adc66e5aee277f0deb4bbad2747" translate="yes" xml:space="preserve">
          <source>Allowed:</source>
          <target state="translated">Allowed:</target>
        </trans-unit>
        <trans-unit id="e0a0783e9856d0e09d989d44bcf6f4ac7421085b" translate="yes" xml:space="preserve">
          <source>Allows importing modules with a &amp;lsquo;.json&amp;rsquo; extension, which is a common practice in node projects. This includes generating a type for the &lt;code&gt;import&lt;/code&gt; based on the static JSON shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc170000d6a67459bf8aeff3519c663382fe747" translate="yes" xml:space="preserve">
          <source>Almost all features of an &lt;code&gt;interface&lt;/code&gt; are available in &lt;code&gt;type&lt;/code&gt;, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7d1a9e4958d2fb8851168702553d5b6855aea3" translate="yes" xml:space="preserve">
          <source>Almost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13463866162e9452fc9466d99aed31c7a984ccdc" translate="yes" xml:space="preserve">
          <source>Along with setting &lt;code&gt;--strict&lt;/code&gt; on by default, &lt;code&gt;tsc --init&lt;/code&gt; has an enhanced output. Default &lt;code&gt;tsconfig.json&lt;/code&gt; files generated by &lt;code&gt;tsc --init&lt;/code&gt; now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</source>
          <target state="translated">Junto con la configuraci&amp;oacute;n &lt;code&gt;--strict&lt;/code&gt; de --strict on, &lt;code&gt;tsc --init&lt;/code&gt; tiene una salida mejorada. Los archivos &lt;code&gt;tsconfig.json&lt;/code&gt; predeterminados generados por &lt;code&gt;tsc --init&lt;/code&gt; ahora incluyen un conjunto de opciones comunes del compilador junto con sus descripciones comentadas. Simplemente elimine los comentarios de la configuraci&amp;oacute;n que desea establecer para obtener el comportamiento deseado; esperamos que la nueva salida simplifique la configuraci&amp;oacute;n de nuevos proyectos y mantenga los archivos de configuraci&amp;oacute;n legibles a medida que crecen los proyectos.</target>
        </trans-unit>
        <trans-unit id="000392e9a54edfab5429407c52d48703930eb447" translate="yes" xml:space="preserve">
          <source>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</source>
          <target state="translated">Junto con las jerarquías tradicionales de OO,otra forma popular de construir clases a partir de componentes reutilizables es construirlas combinando clases parciales más simples.Puede que estés familiarizado con la idea de las mezclas o rasgos para lenguajes como Scala,y el patrón también ha alcanzado cierta popularidad en la comunidad de JavaScript.</target>
        </trans-unit>
        <trans-unit id="d76c0268868384341c5ebe547b3dfcde453c7e8e" translate="yes" xml:space="preserve">
          <source>Also functions that are only called within their own bodies are considered unused.</source>
          <target state="translated">También las funciones que sólo se llaman dentro de sus propios cuerpos se consideran no utilizadas.</target>
        </trans-unit>
        <trans-unit id="540904303a257559b0aeb7e9b92f1cd1b53941db" translate="yes" xml:space="preserve">
          <source>Also important to note is that &lt;code&gt;bigint&lt;/code&gt;s produce a new string when using the &lt;code&gt;typeof&lt;/code&gt; operator: the string &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;. Thus, TypeScript correctly narrows using &lt;code&gt;typeof&lt;/code&gt; as you&amp;rsquo;d expect.</source>
          <target state="translated">Tambi&amp;eacute;n es importante tener en cuenta que &lt;code&gt;bigint&lt;/code&gt; s produce una nueva cadena cuando se usa el operador &lt;code&gt;typeof&lt;/code&gt; : la cadena &lt;code&gt;&quot;bigint&quot;&lt;/code&gt; . Por lo tanto, TypeScript se reduce correctamente usando &lt;code&gt;typeof&lt;/code&gt; como era de esperar.</target>
        </trans-unit>
        <trans-unit id="fdd80e664a9b3ce76fb4d4f379a35bae6ecbe4f1" translate="yes" xml:space="preserve">
          <source>Also note that if your main declaration file is named &lt;code&gt;index.d.ts&lt;/code&gt; and lives at the root of the package (next to &lt;code&gt;index.js&lt;/code&gt;) you do not need to mark the &lt;code&gt;&quot;types&quot;&lt;/code&gt; property, though it is advisable to do so.</source>
          <target state="translated">Tambi&amp;eacute;n tenga en cuenta que si su archivo de declaraci&amp;oacute;n principal se llama &lt;code&gt;index.d.ts&lt;/code&gt; y se encuentra en la ra&amp;iacute;z del paquete (junto a &lt;code&gt;index.js&lt;/code&gt; ), no necesita marcar la propiedad &lt;code&gt;&quot;types&quot;&lt;/code&gt; , aunque es aconsejable hacerlo.</target>
        </trans-unit>
        <trans-unit id="1b4972f01952c5c6e56d36346995929543d00951" translate="yes" xml:space="preserve">
          <source>Also note that when passing &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;, the compiler will only skip checking files with &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n tenga en cuenta que al pasar &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt; , el compilador solo saltar&amp;aacute; los archivos de verificaci&amp;oacute;n con &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6107d072614a65187bd05ede831a6df1fe3accb4" translate="yes" xml:space="preserve">
          <source>Also of note, the use of &lt;code&gt;public&lt;/code&gt; on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</source>
          <target state="translated">Tambi&amp;eacute;n es de destacar que el uso de &lt;code&gt;public&lt;/code&gt; en argumentos para el constructor es una forma abreviada que nos permite crear autom&amp;aacute;ticamente propiedades con ese nombre.</target>
        </trans-unit>
        <trans-unit id="cffaed40200024bd111a6ac8089de97648f831c1" translate="yes" xml:space="preserve">
          <source>Also see our wiki page on &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;using a custom language service file&lt;/a&gt;.</source>
          <target state="translated">Consulte tambi&amp;eacute;n nuestra p&amp;aacute;gina wiki sobre el &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;uso de un archivo de servicio de idioma personalizado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="776519898394bb463eff6e30826aacacc1c3da0d" translate="yes" xml:space="preserve">
          <source>Also, a nightly NuGet package to match the &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;nightly npm package&lt;/a&gt; is available on &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt;:</source>
          <target state="translated">Adem&amp;aacute;s, un paquete NuGet nocturno que coincide con el &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;paquete npm nocturno&lt;/a&gt; est&amp;aacute; disponible en &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dc2ac39874f5d402cff8a6371fac18a2bf87ae7f" translate="yes" xml:space="preserve">
          <source>Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc570dc40e9dd67a1355d20ed4669b96242c78db" translate="yes" xml:space="preserve">
          <source>Alternative Pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92083d2d24448d6d4118e25e1f3cea32d46ea66c" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&amp;rsquo;ll need to use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags on our webpage to load each emitted file in the appropriate order, for example:</source>
          <target state="translated">Alternativamente, podemos usar la compilaci&amp;oacute;n por archivo (la predeterminada) para emitir un archivo JavaScript para cada archivo de entrada. Si se producen varios archivos JS, necesitaremos usar etiquetas &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; en nuestra p&amp;aacute;gina web para cargar cada archivo emitido en el orden apropiado, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d4887b96a506ca1d0dee1e635003357f0a6d33ea" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just say &lt;code&gt;options&lt;/code&gt; has the type &lt;code&gt;any&lt;/code&gt; which is the easiest thing to do, but which will benefit you the least.</source>
          <target state="translated">Alternativamente, puede decir que &lt;code&gt;options&lt;/code&gt; tiene el tipo &lt;code&gt;any&lt;/code&gt; que es lo m&amp;aacute;s f&amp;aacute;cil de hacer, pero que le beneficiar&amp;aacute; menos.</target>
        </trans-unit>
        <trans-unit id="14390732b26f6b4f21409bfe475cf716ae549d14" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use a per-file pragma to set this option, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43606c68a4c7cf72a0b682885c31d5f52ead2334" translate="yes" xml:space="preserve">
          <source>Alternatives:</source>
          <target state="translated">Alternatives:</target>
        </trans-unit>
        <trans-unit id="8b0c73776c390d3a5733d04f89fdf034e34ec53e" translate="yes" xml:space="preserve">
          <source>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let&amp;rsquo;s look at a toy Observable example:</source>
          <target state="translated">Aunque los m&amp;oacute;dulos JavaScript no admiten la combinaci&amp;oacute;n, puede parchear objetos existentes import&amp;aacute;ndolos y luego actualiz&amp;aacute;ndolos. Veamos un ejemplo de juguete observable:</target>
        </trans-unit>
        <trans-unit id="e5310a8c4e94d0ca71a8f44c68a436f3effe3b6a" translate="yes" xml:space="preserve">
          <source>Always Strict - &lt;code&gt;alwaysStrict&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee099122cb78c5739b4f82dcc4924480f635a80" translate="yes" xml:space="preserve">
          <source>Ambient Classes and Functions Can Merge</source>
          <target state="translated">Las clases y funciones del ambiente pueden fusionarse</target>
        </trans-unit>
        <trans-unit id="6b6f848cded8d022fa12717b22d3680a848ad354" translate="yes" xml:space="preserve">
          <source>Ambient Modules</source>
          <target state="translated">Módulos de ambiente</target>
        </trans-unit>
        <trans-unit id="4a2667f9b3defd3ff5b3a3b96ac30b540f477156" translate="yes" xml:space="preserve">
          <source>Ambient Namespaces</source>
          <target state="translated">Espacios de nombres ambientales</target>
        </trans-unit>
        <trans-unit id="072993bc8b201bfe9df293be81dcb3aa09bada66" translate="yes" xml:space="preserve">
          <source>Ambient enums</source>
          <target state="translated">Enums de ambiente</target>
        </trans-unit>
        <trans-unit id="13d6b6f06f272969887a807bdfd8080d800b8ed3" translate="yes" xml:space="preserve">
          <source>Ambient enums are used to describe the shape of already existing enum types.</source>
          <target state="translated">Los enums de ambiente se utilizan para describir la forma de los tipos de enum ya existentes.</target>
        </trans-unit>
        <trans-unit id="b111c707b73d7237aae28fc1288868f165c43e0a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;FString&lt;/code&gt; is just like a normal string, except that the compiler thinks it has a property named &lt;code&gt;__compileTimeOnly&lt;/code&gt; that doesn&amp;rsquo;t actually exist. This means that &lt;code&gt;FString&lt;/code&gt; can still be assigned to &lt;code&gt;string&lt;/code&gt;, but not the other way round.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66df472a2808c10e6e2267da8ee23d33589aa345" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; declaration</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="96131132b1fece4018da08fbe5ae8cdc0f0bbe7c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a type</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n que se refiere a un tipo</target>
        </trans-unit>
        <trans-unit id="9e546120c9b08c182111a543340edaa52f8faa73" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a value</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n que se refiere a un valor.</target>
        </trans-unit>
        <trans-unit id="9c85d60a22bfc72f8be52c9d3473a14b494ef936" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;Accessor Decorator&lt;/em&gt; is declared just before an accessor declaration. The accessor decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the accessor and can be used to observe, modify, or replace an accessor&amp;rsquo;s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">Un &lt;em&gt;Decorador de&lt;/em&gt; acceso se declara justo antes de una declaraci&amp;oacute;n de acceso. El decorador de &lt;em&gt;descriptor&lt;/em&gt; de acceso se aplica al &lt;em&gt;descriptor de propiedad del descriptor&lt;/em&gt; de acceso y se puede utilizar para observar, modificar o reemplazar las definiciones de un &lt;em&gt;descriptor&lt;/em&gt; de acceso. Un decorador de accesor no se puede usar en un archivo de declaraci&amp;oacute;n o en cualquier otro contexto ambiental (como en una clase de &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="637fccf99e1ca3360a8e160638d580b112623960" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async function&lt;/em&gt; is a function or method that has been prefixed with the &lt;code&gt;async&lt;/code&gt; modifier. This modifier informs the compiler that function body transposition is required, and that the keyword &lt;code&gt;await&lt;/code&gt; should be treated as a unary expression instead of an identifier. An &lt;em&gt;Async Function&lt;/em&gt; must provide a return type annotation that points to a compatible &lt;code&gt;Promise&lt;/code&gt; type. Return type inference can only be used if there is a globally defined, compatible &lt;code&gt;Promise&lt;/code&gt; type.</source>
          <target state="translated">Una &lt;em&gt;funci&amp;oacute;n as&amp;iacute;ncrona&lt;/em&gt; es una funci&amp;oacute;n o m&amp;eacute;todo que se ha prefijado con el modificador &lt;code&gt;async&lt;/code&gt; . Este modificador informa al compilador que se requiere la transposici&amp;oacute;n del cuerpo de la funci&amp;oacute;n y que la palabra clave &lt;code&gt;await&lt;/code&gt; debe tratarse como una expresi&amp;oacute;n unaria en lugar de un identificador. Una &lt;em&gt;funci&amp;oacute;n asincr&amp;oacute;nica&lt;/em&gt; debe proporcionar una anotaci&amp;oacute;n de tipo de retorno que apunte a un tipo de &lt;code&gt;Promise&lt;/code&gt; compatible . La inferencia de tipo de retorno solo se puede usar si hay un tipo de &lt;code&gt;Promise&lt;/code&gt; compatible definido globalmente .</target>
        </trans-unit>
        <trans-unit id="e0c5ee8216b1102dc214045b20531cb28dca3422" translate="yes" xml:space="preserve">
          <source>An Example Project</source>
          <target state="translated">Un proyecto de ejemplo</target>
        </trans-unit>
        <trans-unit id="08a8a8bcfbc30a10a37d2f8c0745492817b04bd8" translate="yes" xml:space="preserve">
          <source>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</source>
          <target state="translated">Un IIFE que devuelve literalmente una función,una clase o un objeto vacío,también se reconoce como un espacio de nombres:</target>
        </trans-unit>
        <trans-unit id="4b482032e9b848d1769fffddba6728c3f513e97d" translate="yes" xml:space="preserve">
          <source>An Object whose own property names are property names that are excluded from the &amp;lsquo;with&amp;rsquo; environment bindings of the associated objects.</source>
          <target state="translated">Un objeto cuyos propios nombres de propiedad son nombres de propiedad que est&amp;aacute;n excluidos de los enlaces de entorno 'con' de los objetos asociados.</target>
        </trans-unit>
        <trans-unit id="9346f4c4433fdb2ea0b41faaa1f055ba9e22c515" translate="yes" xml:space="preserve">
          <source>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</source>
          <target state="translated">Una clase abstracta puede declarar propiedades y/o accesorios abstractos.Cualquier subclase tendrá que declarar las propiedades del resumen o ser marcada como tal.Las propiedades abstractas no pueden tener un inicializador.Los accesorios de los resúmenes no pueden tener cuerpos.</target>
        </trans-unit>
        <trans-unit id="c01bf8fd95c1254c73cd6a7e1bf75eab586904fa" translate="yes" xml:space="preserve">
          <source>An entity accessed through an ES2015 namespace import is considered read-only (e.g. &lt;code&gt;foo.x&lt;/code&gt; is read-only when &lt;code&gt;foo&lt;/code&gt; is declared as &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;).</source>
          <target state="translated">Una entidad a la que se accede a trav&amp;eacute;s de una importaci&amp;oacute;n de espacio de nombres ES2015 se considera de solo lectura (por ejemplo, &lt;code&gt;foo.x&lt;/code&gt; es de solo lectura cuando &lt;code&gt;foo&lt;/code&gt; se declara como &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="42ee76cce09b6dda0af497e582271e9daeb1fa9e" translate="yes" xml:space="preserve">
          <source>An entity declared in an &lt;code&gt;import&lt;/code&gt; statement is considered read-only.</source>
          <target state="translated">Una entidad declarada en una declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n se considera de solo lectura.</target>
        </trans-unit>
        <trans-unit id="010036a4ed3e6887f0a662f6e45e32f749a00f87" translate="yes" xml:space="preserve">
          <source>An enum declaration (&lt;code&gt;enum E { A, B, C }&lt;/code&gt;)</source>
          <target state="translated">Una declaraci&amp;oacute;n de enumeraci&amp;oacute;n ( &lt;code&gt;enum E { A, B, C }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0f0c7003bdcd58ff3b43d23382bd37a83d58b4a2" translate="yes" xml:space="preserve">
          <source>An example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can&amp;rsquo;t access it with an import.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a85dd24cd070fb5512fd0ef92b9518fceb29e8c" translate="yes" xml:space="preserve">
          <source>An export default declaration specifies an expression that becomes the default export of a module:</source>
          <target state="translated">Una declaración de exportación por defecto especifica una expresión que se convierte en la exportación por defecto de un módulo:</target>
        </trans-unit>
        <trans-unit id="1dbd631e886efac25134c1822d5fc8c0a3f82701" translate="yes" xml:space="preserve">
          <source>An import to a module with no declaration file will still be flagged as an error under &lt;code&gt;--noImplicitAny&lt;/code&gt;.</source>
          <target state="translated">Una importaci&amp;oacute;n a un m&amp;oacute;dulo sin un archivo de declaraci&amp;oacute;n todav&amp;iacute;a se marcar&amp;aacute; como un error en &lt;code&gt;--noImplicitAny&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4089846541ea3f66ca0b3aa8324eb27446bfa87c" translate="yes" xml:space="preserve">
          <source>An important rule is that &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; declarations export or import &lt;em&gt;all meanings&lt;/em&gt; of their targets.</source>
          <target state="translated">Una regla importante es que &lt;code&gt;export&lt;/code&gt; declaraciones de exportaci&amp;oacute;n e &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n exportan o importan &lt;em&gt;todos los significados&lt;/em&gt; de sus objetivos.</target>
        </trans-unit>
        <trans-unit id="9829bd2aaefcc0a918548bdfb97be8f7716b574b" translate="yes" xml:space="preserve">
          <source>An index type &lt;code&gt;keyof T&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">Una &lt;code&gt;keyof T&lt;/code&gt; tipo &amp;iacute;ndice de T para alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; es un subtipo de &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3dee51effab23215f94b19b5e6ce849dbbb11b" translate="yes" xml:space="preserve">
          <source>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</source>
          <target state="translated">Una interfaz puede extender múltiples interfaces,creando una combinación de todas las interfaces.</target>
        </trans-unit>
        <trans-unit id="8dfb2cf00eea3daab08c8ac76409915d529976bc" translate="yes" xml:space="preserve">
          <source>An interface declaration (&lt;code&gt;interface I { x: number[]; }&lt;/code&gt;)</source>
          <target state="translated">Una declaraci&amp;oacute;n de interfaz ( &lt;code&gt;interface I { x: number[]; }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="051272f0126c6f4c635d623e56a437da25ba082a" translate="yes" xml:space="preserve">
          <source>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">Un tipo de intersecci&amp;oacute;n combina varios tipos en uno. Esto le permite sumar tipos existentes para obtener un solo tipo que tenga todas las caracter&amp;iacute;sticas que necesita. Por ejemplo, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; es una &lt;code&gt;Person&lt;/code&gt; a&lt;em&gt;y &lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;y &lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; . Eso significa que un objeto de este tipo tendr&amp;aacute; todos los miembros de los tres tipos.</target>
        </trans-unit>
        <trans-unit id="99cc1cc22b07e8cafd4c0a4ab5a6f60816a8100b" translate="yes" xml:space="preserve">
          <source>An object is deemed iterable if it has an implementation for the &lt;a href=&quot;symbols#symboliterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; property. Some built-in types like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int32Array&lt;/code&gt;, &lt;code&gt;Uint32Array&lt;/code&gt;, etc. have their &lt;code&gt;Symbol.iterator&lt;/code&gt; property already implemented. &lt;code&gt;Symbol.iterator&lt;/code&gt; function on an object is responsible for returning the list of values to iterate on.</source>
          <target state="translated">Un objeto se considera iterable si tiene una implementaci&amp;oacute;n para la propiedad &lt;a href=&quot;symbols#symboliterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt; . Algunos tipos integrados como &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Int32Array&lt;/code&gt; , &lt;code&gt;Uint32Array&lt;/code&gt; , etc. tienen su propiedad &lt;code&gt;Symbol.iterator&lt;/code&gt; ya implementada. &lt;code&gt;Symbol.iterator&lt;/code&gt; funci&amp;oacute;n Symbol.iterator en un objeto es responsable de devolver la lista de valores para iterar.</target>
        </trans-unit>
        <trans-unit id="8f02b61e8ec8b6f2bec26f2bedf23c11ecf77a29" translate="yes" xml:space="preserve">
          <source>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</source>
          <target state="translated">Un tipo de objeto literal es ahora asignable a un tipo con una firma de índice si todas las propiedades conocidas en el objeto literal son asignables a esa firma de índice.Esto hace posible pasar una variable que fue inicializada con un objeto literal como parámetro a una función que espera un mapa o un diccionario:</target>
        </trans-unit>
        <trans-unit id="8cb8cf874c7b3539ef5e517ffab6e8f6b9569d43" translate="yes" xml:space="preserve">
          <source>An object that supports async iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; method that returns an &lt;code&gt;AsyncIterator&lt;/code&gt; object.</source>
          <target state="translated">Se dice que un objeto que admite la iteraci&amp;oacute;n as&amp;iacute;ncrona es &quot;iterable&quot; si tiene un m&amp;eacute;todo &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; que devuelve un objeto &lt;code&gt;AsyncIterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8447e71f06bf05be69e3922802bfe818075f229" translate="yes" xml:space="preserve">
          <source>An operand is considered nullable if the type of the operand is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or a union type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Note that the union type case only only occurs in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; disappear from unions in classic type checking mode.</source>
          <target state="translated">Un operando se considera anulable si el tipo del operando es &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; o un tipo de uni&amp;oacute;n que incluye &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . Tenga en cuenta que el caso de tipo de uni&amp;oacute;n solo ocurre en el modo &lt;code&gt;--strictNullChecks&lt;/code&gt; porque &lt;code&gt;null&lt;/code&gt; y &lt;code&gt;undefined&lt;/code&gt; desaparecen de las uniones en el modo de verificaci&amp;oacute;n de tipo cl&amp;aacute;sico.</target>
        </trans-unit>
        <trans-unit id="e1d5ca7f2497f214678abf18ecf2b51c0278100b" translate="yes" xml:space="preserve">
          <source>An unspecified type argument in JSDoc defaults to any:</source>
          <target state="translated">Un argumento de tipo no especificado en el JSDoc por defecto es cualquiera:</target>
        </trans-unit>
        <trans-unit id="9add44f9c257c0dbb7eebf6fe551aa600ac3c7bf" translate="yes" xml:space="preserve">
          <source>And help in Japanese:</source>
          <target state="translated">Y ayuda en japonés:</target>
        </trans-unit>
        <trans-unit id="dd197d67b41beb4bb9080f0bf626d0c8feceb7c4" translate="yes" xml:space="preserve">
          <source>And it does so while you are typing, so that after typing &lt;code&gt;o.&lt;/code&gt;, you get completions for the property &lt;code&gt;inference&lt;/code&gt;, along with any other properties you&amp;rsquo;d have in a real program. Altogether, this feature can make TypeScript&amp;rsquo;s inference look a bit like a unifying type inference engine, but it is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d2481f5dabbff44ec8dc3190a715bb12f127f0" translate="yes" xml:space="preserve">
          <source>And it has a specific &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c2dac2f30e99536de68e97cb2b18f2d5db2533" translate="yes" xml:space="preserve">
          <source>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.</source>
          <target state="translated">Y al igual que las firmas de predicados,estas firmas de afirmación son increíblemente expresivas.Podemos expresar algunas ideas bastante sofisticadas con estas.</target>
        </trans-unit>
        <trans-unit id="e5f7abc94bd4652b1940c01f38e4cdba6a7de10d" translate="yes" xml:space="preserve">
          <source>And results in</source>
          <target state="translated">Y resulta en</target>
        </trans-unit>
        <trans-unit id="524218ceeaedc01c8daaf35729b043a8754e652f" translate="yes" xml:space="preserve">
          <source>And the other is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">Y el otro es la &lt;code&gt;as&lt;/code&gt; - sintaxis:</target>
        </trans-unit>
        <trans-unit id="cb4e175c07b2c59dcc273c9702501096dcd31801" translate="yes" xml:space="preserve">
          <source>And this also generates this json map:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7683ba2ccf1b61a19dd6dd9bbbf3a532801e3252" translate="yes" xml:space="preserve">
          <source>And to use it:</source>
          <target state="translated">Y para usarla:</target>
        </trans-unit>
        <trans-unit id="a379f1e77206b5fa5615fc791f830626638ff5b9" translate="yes" xml:space="preserve">
          <source>And usage would be:</source>
          <target state="translated">Y el uso sería:</target>
        </trans-unit>
        <trans-unit id="955c6169edfe74a318e323004916b98e713d7add" translate="yes" xml:space="preserve">
          <source>And with parameters to a function:</source>
          <target state="translated">Y con parámetros para una función:</target>
        </trans-unit>
        <trans-unit id="35f50d63beef167dd9ca426c97e6076057b81ce3" translate="yes" xml:space="preserve">
          <source>And you can use an expression of type &lt;code&gt;any&lt;/code&gt; anywhere:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce043e3a6fddbda09013e27b4641adddde08990" translate="yes" xml:space="preserve">
          <source>And, for pre-ES2015 code, it can be used to simulate static methods:</source>
          <target state="translated">Y,para el código pre-ES2015,puede ser usado para simular métodos estáticos:</target>
        </trans-unit>
        <trans-unit id="ec45c0ce446cf8fa2dd6d9617073a81b5ee50c12" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0355996ea2c36fc48cd0c3c40221f8808eb765" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="translated">Otra caracter&amp;iacute;stica de ECMAScript 2015 que tiene TypeScript es la desestructuraci&amp;oacute;n. Para obtener una referencia completa, consulte &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;el art&amp;iacute;culo sobre Mozilla Developer Network&lt;/a&gt; . En esta secci&amp;oacute;n, daremos una breve descripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f1a7f2f6380d7122bad959764252b9e24c79240a" translate="yes" xml:space="preserve">
          <source>Another distinction is that &lt;code&gt;for..in&lt;/code&gt; operates on any object; it serves as a way to inspect properties on this object. &lt;code&gt;for..of&lt;/code&gt; on the other hand, is mainly interested in values of iterable objects. Built-in objects like &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; implement &lt;code&gt;Symbol.iterator&lt;/code&gt; property allowing access to stored values.</source>
          <target state="translated">Otra distinci&amp;oacute;n es que &lt;code&gt;for..in&lt;/code&gt; opera sobre cualquier objeto; sirve como una forma de inspeccionar las propiedades de este objeto. &lt;code&gt;for..of&lt;/code&gt; por otro lado, est&amp;aacute; interesado principalmente en valores de objetos iterables. Los objetos &lt;code&gt;Symbol.iterator&lt;/code&gt; como &lt;code&gt;Map&lt;/code&gt; y &lt;code&gt;Set&lt;/code&gt; implementan la propiedad Symbol.iterator que permite el acceso a los valores almacenados.</target>
        </trans-unit>
        <trans-unit id="80278db3392e36b25471320c2c5c53b5cfd9afc0" translate="yes" xml:space="preserve">
          <source>Another example would be the &lt;code&gt;TypeName&lt;/code&gt; type alias, which uses nested conditional types:</source>
          <target state="translated">Otro ejemplo ser&amp;iacute;a el alias de tipo &lt;code&gt;TypeName&lt;/code&gt; , que usa tipos condicionales anidados:</target>
        </trans-unit>
        <trans-unit id="08d5a0729b5af0f7633b6230c048cf4b29055065" translate="yes" xml:space="preserve">
          <source>Another frequent source of surprise comes with identical types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59923c5b5918e19407ea7e824fe9454f6b96dd6d" translate="yes" xml:space="preserve">
          <source>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &lt;code&gt;string&lt;/code&gt; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (&lt;code&gt;&quot;&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;) to surround string data.</source>
          <target state="translated">Otra parte fundamental de la creaci&amp;oacute;n de programas en JavaScript tanto para p&amp;aacute;ginas web como para servidores es trabajar con datos textuales. Como en otros idiomas, usamos el tipo &lt;code&gt;string&lt;/code&gt; para referirnos a estos tipos de datos textuales. Al igual que JavaScript, TypeScript tambi&amp;eacute;n usa comillas dobles ( &lt;code&gt;&quot;&lt;/code&gt; ) o comillas simples ( &lt;code&gt;'&lt;/code&gt; ) para rodear los datos de cadena.</target>
        </trans-unit>
        <trans-unit id="e22e08f461a07d2394e4b0372b16fbe2608c33ae" translate="yes" xml:space="preserve">
          <source>Another good practice is to have a &amp;ldquo;solution&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; file that simply has &lt;code&gt;references&lt;/code&gt; to all of your leaf-node projects and sets &lt;code&gt;files&lt;/code&gt; to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty &lt;code&gt;files&lt;/code&gt; array if you have at least one &lt;code&gt;reference&lt;/code&gt; in a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">Otra buena pr&amp;aacute;ctica es tener un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; de &amp;ldquo;soluci&amp;oacute;n&amp;rdquo; que simplemente tenga &lt;code&gt;references&lt;/code&gt; a todos sus proyectos de nodo hoja y establezca los &lt;code&gt;files&lt;/code&gt; en una matriz vac&amp;iacute;a (de lo contrario, el archivo de soluci&amp;oacute;n provocar&amp;aacute; una doble compilaci&amp;oacute;n de archivos). Tenga en cuenta que a partir de 3.0, ya no es un error tener una matriz de &lt;code&gt;files&lt;/code&gt; vac&amp;iacute;a si tiene al menos una &lt;code&gt;reference&lt;/code&gt; en un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3ed357192d33940721ba58d1e4e4f234af944b" translate="yes" xml:space="preserve">
          <source>Another property of block-scoped variables is that they can&amp;rsquo;t be read or written to before they&amp;rsquo;re actually declared. While these variables are &amp;ldquo;present&amp;rdquo; throughout their scope, all points up until their declaration are part of their &lt;em&gt;temporal dead zone&lt;/em&gt;. This is just a sophisticated way of saying you can&amp;rsquo;t access them before the &lt;code&gt;let&lt;/code&gt; statement, and luckily TypeScript will let you know that.</source>
          <target state="translated">Otra propiedad de las variables de &amp;aacute;mbito de bloque es que no se pueden leer ni escribir en ellas antes de que se declaren. Si bien estas variables est&amp;aacute;n &amp;ldquo;presentes&amp;rdquo; en todo su alcance, todos los puntos hasta su declaraci&amp;oacute;n forman parte de su &lt;em&gt;zona muerta temporal&lt;/em&gt; . Esta es solo una forma sofisticada de decir que no puede acceder a ellos antes de la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; , y afortunadamente TypeScript se lo har&amp;aacute; saber.</target>
        </trans-unit>
        <trans-unit id="6536ca406ade59e49db35f06a2bc4ae98274b219" translate="yes" xml:space="preserve">
          <source>Another simple way is to use class expressions:</source>
          <target state="translated">Otra forma sencilla es usar expresiones de clase:</target>
        </trans-unit>
        <trans-unit id="eb0433a2f2345ca65e0ca8af5f86b17a73375f6b" translate="yes" xml:space="preserve">
          <source>Another thing to keep in mind is that &lt;code&gt;const&lt;/code&gt; contexts don&amp;rsquo;t immediately convert an expression to be fully immutable.</source>
          <target state="translated">Otra cosa a tener en cuenta es que los contextos &lt;code&gt;const&lt;/code&gt; no convierten inmediatamente una expresi&amp;oacute;n para que sea completamente inmutable.</target>
        </trans-unit>
        <trans-unit id="a0272d130e56f355222a749eeba841dae92661ec" translate="yes" xml:space="preserve">
          <source>Another way that you can simplify working with namespaces is to use &lt;code&gt;import q = x.y.z&lt;/code&gt; to create shorter names for commonly-used objects. Not to be confused with the &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</source>
          <target state="translated">Otra forma en la que puede simplificar el trabajo con espacios de nombres es usar &lt;code&gt;import q = x.y.z&lt;/code&gt; para crear nombres m&amp;aacute;s cortos para los objetos de uso com&amp;uacute;n. No debe confundirse con la sintaxis &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; utilizada para cargar m&amp;oacute;dulos, esta sintaxis simplemente crea un alias para el s&amp;iacute;mbolo especificado. Puede usar este tipo de importaciones (com&amp;uacute;nmente conocidas como alias) para cualquier tipo de identificador, incluidos los objetos creados a partir de importaciones de m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="ad06f386aa38881eb01e3e498f2167a151b8b1e6" translate="yes" xml:space="preserve">
          <source>Another way to describe the example is that the type &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; is &lt;em&gt;bivariant&lt;/em&gt; (i.e. covariant &lt;em&gt;or&lt;/em&gt; contravariant) for &lt;code&gt;T&lt;/code&gt; in default type checking mode, but &lt;em&gt;contravariant&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; in strict function types mode.</source>
          <target state="translated">Otra forma de describir el ejemplo es que el tipo &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; es &lt;em&gt;bivariante&lt;/em&gt; (es decir, covariante &lt;em&gt;o&lt;/em&gt; contravariante) para &lt;code&gt;T&lt;/code&gt; en el modo de verificaci&amp;oacute;n de tipos predeterminado, pero &lt;em&gt;contravariante&lt;/em&gt; para &lt;code&gt;T&lt;/code&gt; en el modo de tipos de funci&amp;oacute;n estricta.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="5d5c745343bd6b12cb5e63f20e6477505f1a8f8f" translate="yes" xml:space="preserve">
          <source>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the &lt;code&gt;export&lt;/code&gt; keyword.</source>
          <target state="translated">Cualquier declaraci&amp;oacute;n (como una variable, funci&amp;oacute;n, clase, alias de tipo o interfaz) se puede exportar agregando la palabra clave &lt;code&gt;export&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874ba9764ea4968c93711ccd48458d3687016ab7" translate="yes" xml:space="preserve">
          <source>Any files that are referenced by files included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are also included. Similarly, if a file &lt;code&gt;B.ts&lt;/code&gt; is referenced by another file &lt;code&gt;A.ts&lt;/code&gt;, then &lt;code&gt;B.ts&lt;/code&gt; cannot be excluded unless the referencing file &lt;code&gt;A.ts&lt;/code&gt; is also specified in the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; list.</source>
          <target state="translated">Tambi&amp;eacute;n se incluyen todos los archivos a los que hacen referencia los archivos incluidos a trav&amp;eacute;s de las propiedades &lt;code&gt;&quot;files&quot;&lt;/code&gt; o &lt;code&gt;&quot;include&quot;&lt;/code&gt; . De manera similar, si otro archivo &lt;code&gt;B.ts&lt;/code&gt; hace referencia a un archivo &lt;code&gt;A.ts&lt;/code&gt; , entonces &lt;code&gt;B.ts&lt;/code&gt; no se puede excluir a menos que el archivo de referencia &lt;code&gt;A.ts&lt;/code&gt; tambi&amp;eacute;n se especifique en la lista &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b984d3931194d80c596d87494a4cd0260323982" translate="yes" xml:space="preserve">
          <source>Any identifier or dotted identifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d3fbb8847e7adc33f00a67766bcf84d23be884" translate="yes" xml:space="preserve">
          <source>Any optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</source>
          <target state="translated">Cualquier parámetro opcional debe seguir los parámetros requeridos.Si quisiéramos que el nombre de pila fuera opcional,en lugar del apellido,tendríamos que cambiar el orden de los parámetros de la función,poniendo el nombre de pila en último lugar en la lista.</target>
        </trans-unit>
        <trans-unit id="71f5a252552c3c04d4828a9b0a56671420fcd2c6" translate="yes" xml:space="preserve">
          <source>Any other import is considered &lt;strong&gt;non-relative&lt;/strong&gt;. Some examples include:</source>
          <target state="translated">Cualquier otra importaci&amp;oacute;n se considera &lt;strong&gt;no relativa&lt;/strong&gt; . Algunos ejemplos incluyen:</target>
        </trans-unit>
        <trans-unit id="f54cc3c33db9d0cc0052e3d3a5370d1f5fb94ee9" translate="yes" xml:space="preserve">
          <source>Any time &lt;code&gt;isFish&lt;/code&gt; is called with some variable, TypeScript will &lt;em&gt;narrow&lt;/em&gt; that variable to that specific type if the original type is compatible.</source>
          <target state="translated">Cualquier momento &lt;code&gt;isFish&lt;/code&gt; se llama con alguna variable, mecanografiado ser&amp;aacute; &lt;em&gt;estrechar&lt;/em&gt; esa variable a ese tipo espec&amp;iacute;fico si el tipo de original es compatible.</target>
        </trans-unit>
        <trans-unit id="3bab2aa131866dfb42803d6fff4f7d0f0c52622a" translate="yes" xml:space="preserve">
          <source>Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.</source>
          <target state="translated">Cualquier variable,parámetro o propiedad que se inicialice con nulo o indefinido tendrá el tipo any,incluso si se activan los controles estrictos de nulo.Cualquier variable,parámetro o propiedad que se inicialice con []tendrá el tipo any[],incluso si se activan los controles estrictos nulos.La única excepción es para las propiedades que tienen múltiples inicializadores como se ha descrito anteriormente.</target>
        </trans-unit>
        <trans-unit id="2e2c98bb415f3297c0331ba25fa80d4c29b187e3" translate="yes" xml:space="preserve">
          <source>Anywhere a greeting is expected, you can provide a &lt;code&gt;string&lt;/code&gt;, a function returning a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;Greeter&lt;/code&gt; instance.</source>
          <target state="translated">En cualquier lugar se espera un saludo, puede proporcionar una &lt;code&gt;string&lt;/code&gt; , una funci&amp;oacute;n que devuelve una &lt;code&gt;string&lt;/code&gt; o una &lt;code&gt;Greeter&lt;/code&gt; ejemplo.</target>
        </trans-unit>
        <trans-unit id="a2721bd2d72a316000ef90a03336789e7221fe00" translate="yes" xml:space="preserve">
          <source>Apache Cordova Apps still have the existing limitation of a single &lt;code&gt;tsconfig.json&lt;/code&gt; file, which must be in either the root or the &lt;code&gt;scripts&lt;/code&gt; folder.</source>
          <target state="translated">Las aplicaciones Apache Cordova a&amp;uacute;n tienen la limitaci&amp;oacute;n existente de un solo archivo &lt;code&gt;tsconfig.json&lt;/code&gt; , que debe estar en la carpeta ra&amp;iacute;z o en la carpeta de &lt;code&gt;scripts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a72aa9f35599ef319f4bdce587da34e4ef96d8ee" translate="yes" xml:space="preserve">
          <source>App.ts</source>
          <target state="translated">App.ts</target>
        </trans-unit>
        <trans-unit id="f6775dc00da9c4ef2c019649d89650724f0bc81f" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="translated">Aplicando el &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principio de privilegio m&amp;iacute;nimo&lt;/a&gt; , todas las declaraciones distintas de las que planea modificar deben usar &lt;code&gt;const&lt;/code&gt; . La raz&amp;oacute;n es que si no es necesario escribir en una variable, otras personas que trabajen en la misma base de c&amp;oacute;digo no deber&amp;iacute;an poder escribir autom&amp;aacute;ticamente en el objeto, y deber&amp;aacute;n considerar si realmente necesitan reasignar a la variable. El uso de &lt;code&gt;const&lt;/code&gt; tambi&amp;eacute;n hace que el c&amp;oacute;digo sea m&amp;aacute;s predecible al razonar sobre el flujo de datos.</target>
        </trans-unit>
        <trans-unit id="feeba9502a1e0f85eacb0af7f74c1820da8711e4" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes" xml:space="preserve">
          <source>Array destructuring</source>
          <target state="translated">Desestructuración de la matriz</target>
        </trans-unit>
        <trans-unit id="e6ac01c9abf0d89c7b3cace9c5d3ec391bebfef5" translate="yes" xml:space="preserve">
          <source>Arrow functions use the contextual type to type their parameters, so the compiler gives &lt;code&gt;o: { inference: string }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5851b2384facd082dae02e6048cf9a0298dc5eb" translate="yes" xml:space="preserve">
          <source>As a heads up, when using &lt;code&gt;strictNullChecks&lt;/code&gt;, your dependencies may need to be updated to use &lt;code&gt;strictNullChecks&lt;/code&gt; as well.</source>
          <target state="translated">Como &lt;code&gt;strictNullChecks&lt;/code&gt; , cuando se usa estrictoNullChecks , es posible que sus dependencias deban actualizarse para usar &lt;code&gt;strictNullChecks&lt;/code&gt; tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="8d3e12e810f587516dce0ec17be3db602fa8d496" translate="yes" xml:space="preserve">
          <source>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading &lt;code&gt;.d.ts&lt;/code&gt; files from duplicate packages.</source>
          <target state="translated">Como una buena ventaja, esto tambi&amp;eacute;n puede reducir la memoria y la huella del tiempo de ejecuci&amp;oacute;n del compilador y el servicio de lenguaje al evitar cargar archivos &lt;code&gt;.d.ts&lt;/code&gt; de paquetes duplicados.</target>
        </trans-unit>
        <trans-unit id="ba3d749ddb3000672893220ada4f38c622aabbb5" translate="yes" xml:space="preserve">
          <source>As a note: we encourage the use of &lt;code&gt;--strictNullChecks&lt;/code&gt; when possible, but for the purposes of this handbook, we will assume it is turned off.</source>
          <target state="translated">Como nota: &lt;code&gt;--strictNullChecks&lt;/code&gt; el uso de --strictNullChecks cuando sea posible, pero para los prop&amp;oacute;sitos de este manual, asumiremos que est&amp;aacute; desactivado.</target>
        </trans-unit>
        <trans-unit id="977dbb0a6075f870e0e4b082c7e83acf8cacfabb" translate="yes" xml:space="preserve">
          <source>As a result, TypeScript 3.2 considers the &lt;code&gt;error&lt;/code&gt; property in the following example to be a discriminant, whereas before it wouldn&amp;rsquo;t since &lt;code&gt;Error&lt;/code&gt; isn&amp;rsquo;t a singleton type. Thanks to this, narrowing works correctly in the body of the &lt;code&gt;unwrap&lt;/code&gt; function.</source>
          <target state="translated">Como resultado, TypeScript 3.2 considera que la propiedad de &lt;code&gt;error&lt;/code&gt; en el siguiente ejemplo es un discriminante, mientras que antes no lo har&amp;iacute;a, ya que &lt;code&gt;Error&lt;/code&gt; no es un tipo singleton. Gracias a esto, el estrechamiento funciona correctamente en el cuerpo de la funci&amp;oacute;n &lt;code&gt;unwrap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368d21349de8cec5ff1bdfc7896830a65df05b5c" translate="yes" xml:space="preserve">
          <source>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</source>
          <target state="translated">Como resultado,los usuarios pueden escribir getters y setters en contextos ambientales en TypeScript 3.6.</target>
        </trans-unit>
        <trans-unit id="7895ee4a93d7fa1bb09b06ce0af1d11a32158318" translate="yes" xml:space="preserve">
          <source>As an alternative to individual imports, a namespace import can be used to import an entire module:</source>
          <target state="translated">Como alternativa a las importaciones individuales,la importación de un espacio de nombres puede utilizarse para importar un módulo completo:</target>
        </trans-unit>
        <trans-unit id="9fa46177b5c4d16d6b6bc058d8b30ad17e80456e" translate="yes" xml:space="preserve">
          <source>As an example of new errors you might spot as a result:</source>
          <target state="translated">Como ejemplo de los nuevos errores que se pueden detectar como resultado:</target>
        </trans-unit>
        <trans-unit id="a43f82802df7af1b9c148a7744a7e8b03aeeec58" translate="yes" xml:space="preserve">
          <source>As an example of some types that are immediately resolved, we can take a look at the following example:</source>
          <target state="translated">Como ejemplo de algunos tipos que se resuelven de forma inmediata,podemos echar un vistazo al siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="d5d1fff48d37907013a550ea65a80338a2731aa0" translate="yes" xml:space="preserve">
          <source>As an example, consider the need to escape a string that contains the character &amp;lsquo;𠮷&amp;rsquo;. In UTF-16/UCS2, &amp;lsquo;𠮷&amp;rsquo; is represented as a surrogate pair, meaning that it&amp;rsquo;s encoded using a pair of 16-bit code units of values, specifically &lt;code&gt;0xD842&lt;/code&gt; and &lt;code&gt;0xDFB7&lt;/code&gt;. Previously this meant that you&amp;rsquo;d have to escape the codepoint as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;. This has the major downside that it&amp;rsquo;s difficult to discern two independent characters from a surrogate pair.</source>
          <target state="translated">Como ejemplo, considere la necesidad de escapar de una cadena que contiene el car&amp;aacute;cter '𠮷'. En UTF-16 / UCS2, '𠮷' se representa como un par sustituto, lo que significa que se codifica utilizando un par de unidades de valores de c&amp;oacute;digo de 16 bits, espec&amp;iacute;ficamente &lt;code&gt;0xD842&lt;/code&gt; y &lt;code&gt;0xDFB7&lt;/code&gt; . Anteriormente, esto significaba que tendr&amp;iacute;a que escapar del punto de c&amp;oacute;digo como &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; . Esto tiene el principal inconveniente de que es dif&amp;iacute;cil distinguir dos personajes independientes de una pareja sustituta.</target>
        </trans-unit>
        <trans-unit id="7cef5c14af957c7ec054d83d89e6e1099bf750eb" translate="yes" xml:space="preserve">
          <source>As an example, getting the declarations for a library like lodash takes nothing more than the following command</source>
          <target state="translated">Por ejemplo,para obtener las declaraciones de una biblioteca como Lodash no hace falta nada más que el siguiente comando</target>
        </trans-unit>
        <trans-unit id="57cdcd63d828e3b22ca9083f5b988b61d9d275fa" translate="yes" xml:space="preserve">
          <source>As an example, on many Unix-like systems, the standard output stream is accessible by the file &lt;code&gt;/dev/stdout&lt;/code&gt;.</source>
          <target state="translated">Como ejemplo, en muchos sistemas similares a Unix, el archivo &lt;code&gt;/dev/stdout&lt;/code&gt; puede acceder al flujo de salida est&amp;aacute;ndar .</target>
        </trans-unit>
        <trans-unit id="04db06e8634e811fc030ab034631e6269dc8b211" translate="yes" xml:space="preserve">
          <source>As an example, the following code snippet</source>
          <target state="translated">Como ejemplo,el siguiente fragmento de código</target>
        </trans-unit>
        <trans-unit id="5b7043bfc26c1ba1d57755926f65d96698dcbdc6" translate="yes" xml:space="preserve">
          <source>As an example, we can pipe our emitted JavaScript into a pretty printer like &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt;:</source>
          <target state="translated">Como ejemplo, podemos canalizar nuestro JavaScript emitido a una impresora &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;bonita&lt;/a&gt; como pretty-js :</target>
        </trans-unit>
        <trans-unit id="2d4eabd9999e1e12bdc9f231452f5d0852a3e159" translate="yes" xml:space="preserve">
          <source>As another example, this is JavaScript code that you can run in your browser, and it &lt;em&gt;will&lt;/em&gt; print a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acab1badefe292ebd417e66a3c779d99e6f3970" translate="yes" xml:space="preserve">
          <source>As discussed earlier, the compiler can visit files outside the current folder when resolving a module. This can be hard when diagnosing why a module is not resolved, or is resolved to an incorrect definition. Enabling the compiler module resolution tracing using &lt;code&gt;--traceResolution&lt;/code&gt; provides insight in what happened during the module resolution process.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, el compilador puede visitar archivos fuera de la carpeta actual al resolver un m&amp;oacute;dulo. Esto puede resultar dif&amp;iacute;cil al diagnosticar por qu&amp;eacute; un m&amp;oacute;dulo no se resuelve o se resuelve con una definici&amp;oacute;n incorrecta. Habilitar el seguimiento de la resoluci&amp;oacute;n del m&amp;oacute;dulo del compilador mediante &lt;code&gt;--traceResolution&lt;/code&gt; proporciona informaci&amp;oacute;n sobre lo que sucedi&amp;oacute; durante el proceso de resoluci&amp;oacute;n del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="2af5d0e8e829dfb3c74ed1966383405987ec7afa" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are either floating point values or BigIntegers. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;, while BigIntegers get the type &lt;code&gt;bigint&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd062263fc01b5e1d46bab04d2fc86323793b16" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="translated">Como en JavaScript, todos los n&amp;uacute;meros en TypeScript son valores de punto flotante. Estos n&amp;uacute;meros de coma flotante obtienen el &lt;code&gt;number&lt;/code&gt; tipo . Adem&amp;aacute;s de los literales hexadecimales y decimales, TypeScript tambi&amp;eacute;n admite literales binarios y octales introducidos en ECMAScript 2015.</target>
        </trans-unit>
        <trans-unit id="1bd66e26a872b778f91b4e166644723ee3f84de0" translate="yes" xml:space="preserve">
          <source>As long as the parameter types line up, it&amp;rsquo;s considered a valid type for the function, regardless of the names you give the parameters in the function type.</source>
          <target state="translated">Siempre que los tipos de par&amp;aacute;metros est&amp;eacute;n alineados, se considera un tipo v&amp;aacute;lido para la funci&amp;oacute;n, independientemente de los nombres que le d&amp;eacute; a los par&amp;aacute;metros en el tipo de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="840af689a0703390b87203932fb9e888f4976db7" translate="yes" xml:space="preserve">
          <source>As mentioned above, TypeScript now errors when functions appear to be uncalled within &lt;code&gt;if&lt;/code&gt; statement conditions. An error is issued when a function type is checked in &lt;code&gt;if&lt;/code&gt; conditions unless any of the following apply:</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, TypeScript ahora genera errores cuando las funciones parecen no ser llamadas dentro de las condiciones de la declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; . Se emite un error cuando se registra un tipo de funci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; existen condiciones, a menos que se aplique cualquiera de las siguientes:</target>
        </trans-unit>
        <trans-unit id="2a5c086b08f5e14213b1e066b50db36d669f8f91" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;our section on enums&lt;/a&gt;, enum members have types when every member is literal-initialized.</source>
          <target state="translated">Como se mencion&amp;oacute; en &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;nuestra secci&amp;oacute;n sobre enumeraciones&lt;/a&gt; , los miembros de enumeraci&amp;oacute;n tienen tipos cuando cada miembro se inicializa literalmente.</target>
        </trans-unit>
        <trans-unit id="ef133c43f210eb19ff5fbc570648cdd98a773f66" translate="yes" xml:space="preserve">
          <source>As our application grows, we&amp;rsquo;ll want to split the code across multiple files to make it easier to maintain.</source>
          <target state="translated">A medida que nuestra aplicaci&amp;oacute;n crece, queremos dividir el c&amp;oacute;digo en varios archivos para facilitar su mantenimiento.</target>
        </trans-unit>
        <trans-unit id="a1bb7cf0157b073ec01dbb6472be74930da9d121" translate="yes" xml:space="preserve">
          <source>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">Como parte del trabajo de firmas de aserci&amp;oacute;n, TypeScript necesitaba codificar m&amp;aacute;s sobre d&amp;oacute;nde y qu&amp;eacute; funciones se llamaban. Esto nos dio la oportunidad de ampliar el soporte para otra clase de funciones: funciones que &lt;code&gt;never&lt;/code&gt; regresan .</target>
        </trans-unit>
        <trans-unit id="390fe60664424f4e52cb8b9bdf97c3dba17b9a17" translate="yes" xml:space="preserve">
          <source>As specified in ECMAScript, mixing &lt;code&gt;number&lt;/code&gt;s and &lt;code&gt;bigint&lt;/code&gt;s in arithmetic operations is an error. You&amp;rsquo;ll have to explicitly convert values to &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">Como se especifica en ECMAScript, mezclar &lt;code&gt;number&lt;/code&gt; sy &lt;code&gt;bigint&lt;/code&gt; s en operaciones aritm&amp;eacute;ticas es un error. Tendr&amp;aacute; que convertir expl&amp;iacute;citamente valores a &lt;code&gt;BigInt&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="6b12aa1f9da2310999311b7475d8a9700fd525f1" translate="yes" xml:space="preserve">
          <source>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</source>
          <target state="translated">Como tal,los siguientes pasos se realizan cuando se evalúan varios decoradores en una sola declaración en TypeScript:</target>
        </trans-unit>
        <trans-unit id="7c6bf56e61f5837d2d137d88d1a894bdddcce94e" translate="yes" xml:space="preserve">
          <source>As the name suggests, the component is defined as a JavaScript function where its first argument is a &lt;code&gt;props&lt;/code&gt; object. TS enforces that its return type must be assignable to &lt;code&gt;JSX.Element&lt;/code&gt;.</source>
          <target state="translated">Como sugiere el nombre, el componente se define como una funci&amp;oacute;n de JavaScript donde su primer argumento es un objeto &lt;code&gt;props&lt;/code&gt; . TS obliga a que su tipo de retorno se pueda &lt;code&gt;JSX.Element&lt;/code&gt; a JSX.Element .</target>
        </trans-unit>
        <trans-unit id="f3ca06e4caafd2fed96f322e77c268ce050caf98" translate="yes" xml:space="preserve">
          <source>As we add more validators, we&amp;rsquo;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&amp;rsquo;s wrap up our objects into a namespace.</source>
          <target state="translated">A medida que agreguemos m&amp;aacute;s validadores, querremos tener alg&amp;uacute;n tipo de esquema de organizaci&amp;oacute;n para poder realizar un seguimiento de nuestros tipos y no preocuparnos por las colisiones de nombres con otros objetos. En lugar de poner muchos nombres diferentes en el espacio de nombres global, envolvemos nuestros objetos en un espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="f8a201a25fd7790f05a2ecb442c622ccca689a7b" translate="yes" xml:space="preserve">
          <source>As we covered in &lt;a href=&quot;classes&quot;&gt;our section on classes&lt;/a&gt;, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&amp;rsquo;s type parameter.</source>
          <target state="translated">Como cubrimos en &lt;a href=&quot;classes&quot;&gt;nuestra secci&amp;oacute;n sobre clases&lt;/a&gt; , una clase tiene dos lados de su tipo: el lado est&amp;aacute;tico y el lado de la instancia. Las clases gen&amp;eacute;ricas solo son gen&amp;eacute;ricas en el lado de la instancia en lugar de en el lado est&amp;aacute;tico, por lo que cuando se trabaja con clases, los miembros est&amp;aacute;ticos no pueden usar el par&amp;aacute;metro de tipo de la clase.</target>
        </trans-unit>
        <trans-unit id="e39977ca24b8e7d4979279054a3ddcd2072307e9" translate="yes" xml:space="preserve">
          <source>As we improve the playground and the website, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;we welcome feedback and pull requests on GitHub&lt;/a&gt;!</source>
          <target state="translated">A medida que mejoramos el &amp;aacute;rea de juegos y el sitio web, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;agradecemos sus comentarios y solicitudes de extracci&amp;oacute;n en GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e0926e0c8d61335ab6e159abc80a290ccf182a2" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&amp;rsquo;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</source>
          <target state="translated">Como mencionamos anteriormente, las interfaces pueden describir los tipos enriquecidos presentes en JavaScript del mundo real. Debido a la naturaleza din&amp;aacute;mica y flexible de JavaScript, es posible que ocasionalmente encuentre un objeto que funcione como una combinaci&amp;oacute;n de algunos de los tipos descritos anteriormente.</target>
        </trans-unit>
        <trans-unit id="e667d5c6d0aea6aea249141e0079b9aabfe0e442" translate="yes" xml:space="preserve">
          <source>As we mentioned, BigInt support is only available for the &lt;code&gt;esnext&lt;/code&gt; target. It may not be obvious, but because BigInts have different behavior for mathematical operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc., providing functionality for older targets where the feature doesn&amp;rsquo;t exist (like &lt;code&gt;es2017&lt;/code&gt; and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</source>
          <target state="translated">Como mencionamos, el soporte de BigInt solo est&amp;aacute; disponible para el objetivo &lt;code&gt;esnext&lt;/code&gt; . Puede que no sea obvio, pero debido a que los BigInts tienen un comportamiento diferente para los operadores matem&amp;aacute;ticos como &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , etc., proporcionar funcionalidad para objetivos m&amp;aacute;s antiguos donde la funci&amp;oacute;n no existe (como &lt;code&gt;es2017&lt;/code&gt; y m&amp;aacute;s abajo) implicar&amp;iacute;a reescribir cada una de estas operaciones. . TypeScript necesitar&amp;iacute;a distribuirse al comportamiento correcto seg&amp;uacute;n el tipo, por lo que cada adici&amp;oacute;n, concatenaci&amp;oacute;n de cadenas, multiplicaci&amp;oacute;n, etc. implicar&amp;iacute;a una llamada a funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0bec2ed7fb7091a8ef64c32bc287724bfc0cce55" translate="yes" xml:space="preserve">
          <source>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</source>
          <target state="translated">Como mencionamos,los alias de tipo pueden actuar como interfaces;sin embargo,hay algunas diferencias sutiles.</target>
        </trans-unit>
        <trans-unit id="c55f71cd30e6435a112a945f64ecb9e401e4684b" translate="yes" xml:space="preserve">
          <source>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</source>
          <target state="translated">Como dijimos en la sección anterior,una declaración de clase crea dos cosas:un tipo que representa instancias de la clase y una función constructora.Dado que las clases crean tipos,se pueden utilizar en los mismos lugares en los que se podrían utilizar las interfaces.</target>
        </trans-unit>
        <trans-unit id="eca7c3fc0aeea895ca68482e3282da249688fb4f" translate="yes" xml:space="preserve">
          <source>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global &lt;code&gt;Promise&lt;/code&gt; implementation (either native or an ES2015-compatible polyfill), in addition to a valid &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; reference (either a native symbol or a shim).</source>
          <target state="translated">Al igual que con los generadores, los generadores as&amp;iacute;ncronos solo pueden ser declaraciones de funci&amp;oacute;n, expresiones de funci&amp;oacute;n o m&amp;eacute;todos de clases o literales de objeto. Las funciones de flecha no pueden ser generadores as&amp;iacute;ncronos. Los generadores as&amp;iacute;ncronos requieren una implementaci&amp;oacute;n de &lt;code&gt;Promise&lt;/code&gt; global v&amp;aacute;lida (ya sea nativa o un polyfill compatible con ES2015), adem&amp;aacute;s de una referencia v&amp;aacute;lida de &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; (ya sea un s&amp;iacute;mbolo nativo o un shim).</target>
        </trans-unit>
        <trans-unit id="e4960adc215b4ac881e5c35568584f22fd6212eb" translate="yes" xml:space="preserve">
          <source>As with arrays, you can destructure the rest of the tuple with &lt;code&gt;...&lt;/code&gt;, to get a shorter tuple:</source>
          <target state="translated">Al igual que con las matrices, puede desestructurar el resto de la tupla con &lt;code&gt;...&lt;/code&gt; , para obtener una tupla m&amp;aacute;s corta:</target>
        </trans-unit>
        <trans-unit id="1c88c0ca9b6b6b4f95fa0f5e0a3945111347bb7f" translate="yes" xml:space="preserve">
          <source>As with assertion functions, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;read up more at the same pull request&lt;/a&gt;.</source>
          <target state="translated">Al igual que con las funciones de aserci&amp;oacute;n, puede &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;leer m&amp;aacute;s en la misma solicitud de extracci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13942b127f03a86eed04c8af9e4662496adae711" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of &lt;a href=&quot;#module&quot;&gt;a UMD&lt;/a&gt; module, so be sure to check the code or documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ebe0449790b742a22a4412bec079981f0005a3" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.</source>
          <target state="translated">Como en el caso de los módulos globales,puede que veas estos ejemplos en la documentación de un módulo UMD,así que asegúrate de comprobar el código o la documentación.</target>
        </trans-unit>
        <trans-unit id="0705018bf7b343a8a49c9a07104949e0fe3a4e7a" translate="yes" xml:space="preserve">
          <source>As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example &lt;code&gt;let x = 5;&lt;/code&gt; creates a value called &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Al igual que con los tipos, probablemente ya comprenda qu&amp;eacute; es un valor. Los valores son nombres en tiempo de ejecuci&amp;oacute;n a los que podemos hacer referencia en expresiones. Por ejemplo, &lt;code&gt;let x = 5;&lt;/code&gt; crea un valor llamado &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1a48f4680185d0a1c25499af1056b570588fb64" translate="yes" xml:space="preserve">
          <source>As you might&amp;rsquo;ve figured out, we just declared a variable named &lt;code&gt;a&lt;/code&gt; with the value &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">Como habr&amp;aacute;s descubierto, acabamos de declarar una variable llamada &lt;code&gt;a&lt;/code&gt; con el valor &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72457daa6f50ff48a819ba7cfab041aeb483b454" translate="yes" xml:space="preserve">
          <source>As you type on the boxes you should see the message appear/change!</source>
          <target state="translated">A medida que escribes en las casillas deberías ver aparecer/cambiar el mensaje!</target>
        </trans-unit>
        <trans-unit id="bc4a6547aa8a5fff93868acf4c855dc352b78b55" translate="yes" xml:space="preserve">
          <source>Ask the file named &lt;code&gt;/root/src/moduleB.js&lt;/code&gt;, if it exists.</source>
          <target state="translated">Pregunte al archivo llamado &lt;code&gt;/root/src/moduleB.js&lt;/code&gt; , si existe.</target>
        </trans-unit>
        <trans-unit id="ae145f96f9923e53fbb6e9f3f9610452236976e4" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;index.js&lt;/code&gt;. That file is implicitly considered that folder&amp;rsquo;s &amp;ldquo;main&amp;rdquo; module.</source>
          <target state="translated">Pregunte a la carpeta &lt;code&gt;/root/src/moduleB&lt;/code&gt; si contiene un archivo llamado &lt;code&gt;index.js&lt;/code&gt; . Ese archivo se considera impl&amp;iacute;citamente el m&amp;oacute;dulo &quot;principal&quot; de esa carpeta.</target>
        </trans-unit>
        <trans-unit id="8b89fe51a739705208f8a298ea55bb588950f3b6" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;package.json&lt;/code&gt; that specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; module. In our example, if Node.js found the file &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; containing &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt;, then Node.js will refer to &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;.</source>
          <target state="translated">Pregunte a la carpeta &lt;code&gt;/root/src/moduleB&lt;/code&gt; si contiene un archivo llamado &lt;code&gt;package.json&lt;/code&gt; que especifica un m&amp;oacute;dulo &lt;code&gt;&quot;main&quot;&lt;/code&gt; . En nuestro ejemplo, si Node.js encontr&amp;oacute; el archivo &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; que contiene &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt; , entonces Node.js har&amp;aacute; referencia a &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b89f9c9a7b547e368f3dab7225883398658593d9" translate="yes" xml:space="preserve">
          <source>Assertion Functions</source>
          <target state="translated">Funciones de afirmación</target>
        </trans-unit>
        <trans-unit id="98c46e5ab2ffec3f635dbcdf5bc83e5353066495" translate="yes" xml:space="preserve">
          <source>Assertions in JavaScript are often used to guard against improper types being passed in. For example,</source>
          <target state="translated">Las afirmaciones en JavaScript se utilizan a menudo para evitar que se pasen tipos inapropiados.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="d8da00b586664722cbf919d60c3a4ea73823442f" translate="yes" xml:space="preserve">
          <source>Assigned-before-use checking</source>
          <target state="translated">Comprobación de la asignación antes del uso</target>
        </trans-unit>
        <trans-unit id="3a3dd9c1b7f42e306408c3dfe2c8989c03230b2e" translate="yes" xml:space="preserve">
          <source>Assignment to union types works very intuitively &amp;ndash; anything you could assign to one of the union type&amp;rsquo;s members is assignable to the union:</source>
          <target state="translated">La asignaci&amp;oacute;n a tipos de sindicatos funciona de manera muy intuitiva: todo lo que pueda asignar a uno de los miembros del tipo de sindicato se puede asignar al sindicato:</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="f204f370193bea63fc30347377344ab8d15db4a7" translate="yes" xml:space="preserve">
          <source>Assignments at the top-level should behave the same way; in other words, a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; declaration is not required.</source>
          <target state="translated">Las asignaciones en el nivel superior deben comportarse de la misma manera; en otras palabras, no se requiere una declaraci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; o &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62de5df53249972bb9af1fc4eb134121b22de084" translate="yes" xml:space="preserve">
          <source>Assignments to &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">Asignaciones a &lt;code&gt;exports&lt;/code&gt; o &lt;code&gt;module.exports&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3538682165ab749b99e78129248b3c38f0d9b" translate="yes" xml:space="preserve">
          <source>Assignments to properties of &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">Asignaciones a propiedades de &lt;code&gt;window&lt;/code&gt; o &lt;code&gt;global&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d5e5ece4fa70386a240680d096df0f39138ad3f" translate="yes" xml:space="preserve">
          <source>Assume Changes Only Affect Direct Dependencies - &lt;code&gt;assumeChangesOnlyAffectDirectDependencies&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58799777e41ae1e8d930adcb89c0780ba66e38d5" translate="yes" xml:space="preserve">
          <source>Assume that each of these modules exports an array of strings. For example &lt;code&gt;./zh/messages&lt;/code&gt; might contain:</source>
          <target state="translated">Suponga que cada uno de estos m&amp;oacute;dulos exporta una matriz de cadenas. Por ejemplo, &lt;code&gt;./zh/messages&lt;/code&gt; podr&amp;iacute;a contener:</target>
        </trans-unit>
        <trans-unit id="e528328da4f68ed5eb912249e43e3e2e00accde0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;__dirname&lt;/code&gt; is always available on &lt;code&gt;import.meta&lt;/code&gt;, the declaration would be done through reopening &lt;code&gt;ImportMeta&lt;/code&gt; interface:</source>
          <target state="translated">Suponiendo que &lt;code&gt;__dirname&lt;/code&gt; siempre est&amp;eacute; disponible en &lt;code&gt;import.meta&lt;/code&gt; , la declaraci&amp;oacute;n se har&amp;iacute;a reabriendo la interfaz &lt;code&gt;ImportMeta&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="63c86e37952421654714f44ff0a3e0b511f5f15f" translate="yes" xml:space="preserve">
          <source>Assumptions that DOM primitives like &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; exist</source>
          <target state="translated">Supuestos de que existen primitivas DOM como &lt;code&gt;document&lt;/code&gt; o o &lt;code&gt;window&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fb1a430a57e52b71176eabf0a0a52ccef1c8fac" translate="yes" xml:space="preserve">
          <source>Astute readers will notice that, for example, &lt;code&gt;class&lt;/code&gt; appeared in both the &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; lists. The declaration &lt;code&gt;class C { }&lt;/code&gt; creates two things: a &lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the instance shape of the class, and a &lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the constructor function of the class. Enum declarations behave similarly.</source>
          <target state="translated">Los lectores astutos notar&amp;aacute;n que, por ejemplo, la &lt;code&gt;class&lt;/code&gt; apareci&amp;oacute; tanto en la lista de &lt;em&gt;tipos&lt;/em&gt; como en la de &lt;em&gt;valores&lt;/em&gt; . La declaraci&amp;oacute;n de &lt;code&gt;class C { }&lt;/code&gt; crea dos cosas: un &lt;em&gt;tipo &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; que se refiere a la forma de instancia de la clase y un &lt;em&gt;valor &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; que se refiere a la funci&amp;oacute;n constructora de la clase. Las declaraciones de enumeraci&amp;oacute;n se comportan de manera similar.</target>
        </trans-unit>
        <trans-unit id="6bd2a8a7dd2324b3dfc1a250fed0f9daa6541f3a" translate="yes" xml:space="preserve">
          <source>Async Generators</source>
          <target state="translated">Generadores Async</target>
        </trans-unit>
        <trans-unit id="3c1b53675cb58d1ec8542ffe7447c2dc8ed8d373" translate="yes" xml:space="preserve">
          <source>Async Iteration</source>
          <target state="translated">Iteración asíncrona</target>
        </trans-unit>
        <trans-unit id="fec7372c392b06a860ac46991a72a2226276fba1" translate="yes" xml:space="preserve">
          <source>Async iterators</source>
          <target state="translated">Iteradores de asíncronos</target>
        </trans-unit>
        <trans-unit id="5bec73a232efba048470ae0342c82f3228e1af2d" translate="yes" xml:space="preserve">
          <source>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. The star of the show in optional chaining is the new &lt;code&gt;?.&lt;/code&gt; operator for &lt;em&gt;optional property accesses&lt;/em&gt;. When we write code like</source>
          <target state="translated">En esencia, el encadenamiento opcional nos permite escribir c&amp;oacute;digo donde TypeScript puede detener inmediatamente la ejecuci&amp;oacute;n de algunas expresiones si nos encontramos con un &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . La estrella del espect&amp;aacute;culo en encadenamiento opcional es la nueva &lt;code&gt;?.&lt;/code&gt; operador para &lt;em&gt;accesos opcionales a la propiedad&lt;/em&gt; . Cuando escribimos c&amp;oacute;digo como</target>
        </trans-unit>
        <trans-unit id="d1167ef7e58858fe2a166efd826d59d4d9cd2ba5" translate="yes" xml:space="preserve">
          <source>At the command line, run the TypeScript compiler:</source>
          <target state="translated">En la línea de comandos,ejecute el compilador TypeScript:</target>
        </trans-unit>
        <trans-unit id="e78da82abc219a055bfa736ddf690eb4d03a6708" translate="yes" xml:space="preserve">
          <source>At this point, if you try running &lt;code&gt;tsc&lt;/code&gt; at the root of your project, you should see output files in the &lt;code&gt;built&lt;/code&gt; directory. The layout of files in &lt;code&gt;built&lt;/code&gt; should look identical to the layout of &lt;code&gt;src&lt;/code&gt;. You should now have TypeScript working with your project.</source>
          <target state="translated">En este punto, si intenta ejecutar &lt;code&gt;tsc&lt;/code&gt; en la ra&amp;iacute;z de su proyecto, deber&amp;iacute;a ver los archivos de salida en el directorio &lt;code&gt;built&lt;/code&gt; . El dise&amp;ntilde;o de los archivos en &lt;code&gt;built&lt;/code&gt; debe verse id&amp;eacute;ntico al dise&amp;ntilde;o de &lt;code&gt;src&lt;/code&gt; . Ahora deber&amp;iacute;a tener TypeScript trabajando con su proyecto.</target>
        </trans-unit>
        <trans-unit id="378f484fcf34a8ed1dd8027e59916eb7638d8ea5" translate="yes" xml:space="preserve">
          <source>At this point, the compiler will ask &amp;ldquo;what&amp;rsquo;s the shape of &lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo; While this sounds straightforward, &lt;code&gt;moduleA&lt;/code&gt; could be defined in one of your own &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files, or in a &lt;code&gt;.d.ts&lt;/code&gt; that your code depends on.</source>
          <target state="translated">En este punto, el compilador preguntar&amp;aacute; &quot;&amp;iquest;cu&amp;aacute;l es la forma del &lt;code&gt;moduleA&lt;/code&gt; ?&quot; Si bien esto suena sencillo, &lt;code&gt;moduleA&lt;/code&gt; podr&amp;iacute;a definirse en uno de sus propios archivos &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; , o en un &lt;code&gt;.d.ts&lt;/code&gt; del que depende su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="ed32a39d243798f06b391e5f95f8515b64a1895b" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;re probably ready to start using TypeScript files. The first step is to rename one of your &lt;code&gt;.js&lt;/code&gt; files to &lt;code&gt;.ts&lt;/code&gt;. If your file uses JSX, you&amp;rsquo;ll need to rename it to &lt;code&gt;.tsx&lt;/code&gt;.</source>
          <target state="translated">En este punto, probablemente est&amp;eacute; listo para comenzar a usar archivos TypeScript. El primer paso es cambiar el nombre de uno de sus archivos &lt;code&gt;.js&lt;/code&gt; a &lt;code&gt;.ts&lt;/code&gt; . Si su archivo usa JSX, deber&amp;aacute; cambiarle el nombre a &lt;code&gt;.tsx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e7ccc595171e95a7eb1f834393506196fbc0ea1" translate="yes" xml:space="preserve">
          <source>Attribute type checking</source>
          <target state="translated">Comprobación del tipo de atributo</target>
        </trans-unit>
        <trans-unit id="1cfeae50596a1c82d93481a9895a732d259c70b1" translate="yes" xml:space="preserve">
          <source>Augmenting global/module scope from modules</source>
          <target state="translated">Aumentar el alcance global/modular de los módulos</target>
        </trans-unit>
        <trans-unit id="78d9210af9045d4fe60bdb145dcc8d78ae6da80c" translate="yes" xml:space="preserve">
          <source>Automatically set to PreferredUILang value</source>
          <target state="translated">Automáticamente se ajusta al valor de PreferredUILang</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="d20e2c01b6a2f58cc429d37f014c475da407fd6a" translate="yes" xml:space="preserve">
          <source>Babel for transpiling, &lt;code&gt;tsc&lt;/code&gt; for types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adcde08c76f527a1993685af5dc553eeaf5a112d" translate="yes" xml:space="preserve">
          <source>Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn&amp;rsquo;t support.</source>
          <target state="translated">Babel es un compilador enormemente flexible que convierte ES2015 y m&amp;aacute;s all&amp;aacute; en ES5 y ES3. Esto le permite agregar transformaciones extensas y personalizadas que TypeScript no admite.</target>
        </trans-unit>
        <trans-unit id="e9d398ffcbadffa21d8b3f31a932766b42449e22" translate="yes" xml:space="preserve">
          <source>Babel vs &lt;code&gt;tsc&lt;/code&gt; for TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca918fb61ddb9faae466290b72a8013b7e396e6" translate="yes" xml:space="preserve">
          <source>Babel&amp;rsquo;s ES5 output should be very similar to TypeScript&amp;rsquo;s output for such a simple script.</source>
          <target state="translated">La salida ES5 de Babel deber&amp;iacute;a ser muy similar a la salida de TypeScript para un script tan simple.</target>
        </trans-unit>
        <trans-unit id="5ad5cf24690d2882eba4d3f2b0e0a8bf277990a5" translate="yes" xml:space="preserve">
          <source>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</source>
          <target state="translated">Cuando TypeScript implementó los campos de clase pública,asumimos,en la medida de nuestras posibilidades,que el siguiente código</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="c2fd3a989facf50da271d674c14207aa8ad92548" translate="yes" xml:space="preserve">
          <source>Bare Import</source>
          <target state="translated">Importación desnuda</target>
        </trans-unit>
        <trans-unit id="1dbd61f556fe3f920e0c1bc1a21ce34dd73099d6" translate="yes" xml:space="preserve">
          <source>Base URL</source>
          <target state="translated">URL de la base</target>
        </trans-unit>
        <trans-unit id="6f8087950b61f86d74cf472c3db8209a3e21e0bb" translate="yes" xml:space="preserve">
          <source>Base Url - &lt;code&gt;baseUrl&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172793b0e3b408efe74b0d9f46aaf934fcd5496f" translate="yes" xml:space="preserve">
          <source>Base directory to resolve non-relative module names. See &lt;a href=&quot;module-resolution#base-url&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Directorio base para resolver nombres de m&amp;oacute;dulos no relativos. Consulte la &lt;a href=&quot;module-resolution#base-url&quot;&gt;documentaci&amp;oacute;n de Resoluci&amp;oacute;n del m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4833160c36b89ddb86e6b6fbca4d0e967b129ce3" translate="yes" xml:space="preserve">
          <source>Based on the description, it sounds easy to downlevel to ES5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356e91f1e0248e37e452abdcd998b2dddab60e58" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, TypeScript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so TypeScript will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c8a7205576c1623baf3a7cfcb0a92c99932a66" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, Typescript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so Typescript will throw an error.</source>
          <target state="translated">Con base en el hecho de que la funci&amp;oacute;n anterior se le ha asignado a &lt;code&gt;Window.onscroll&lt;/code&gt; , Letra de imprenta sabe que &lt;code&gt;uiEvent&lt;/code&gt; es un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt; , y no un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; como el ejemplo anterior. &lt;code&gt;UIEvent&lt;/code&gt; objetos UIEvent no contienen ninguna propiedad de &lt;code&gt;button&lt;/code&gt; , por lo que Typecript arrojar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">Conceptos básicos</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7519044f052a17daead9b75e1d213e160e8c8476" translate="yes" xml:space="preserve">
          <source>Basic Gruntfile.js</source>
          <target state="translated">Básico Gruntfile.js</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">Tipos básicos</target>
        </trans-unit>
        <trans-unit id="bf61ba3f6509ba114cc8faf2b40e8e71ed35a95e" translate="yes" xml:space="preserve">
          <source>Basic Types: Any</source>
          <target state="translated">Tipos básicos:Cualquier</target>
        </trans-unit>
        <trans-unit id="d61d7e43d7dc9242055a885bc7b2bde15bb723db" translate="yes" xml:space="preserve">
          <source>Basic Types: Array</source>
          <target state="translated">Tipos básicos:Matriz</target>
        </trans-unit>
        <trans-unit id="ed07881f050cc30ef0327d36d1271fbb6c104615" translate="yes" xml:space="preserve">
          <source>Basic Types: Enum</source>
          <target state="translated">Tipos básicos:Enum</target>
        </trans-unit>
        <trans-unit id="243307eb146b441d38c323662afa7897483a957d" translate="yes" xml:space="preserve">
          <source>Basic Types: Never</source>
          <target state="translated">Tipos básicos:Nunca</target>
        </trans-unit>
        <trans-unit id="682c83570d93e651a69c5cc3c77d360b30490fae" translate="yes" xml:space="preserve">
          <source>Basic Types: Tuple</source>
          <target state="translated">Tipos básicos:Tupla</target>
        </trans-unit>
        <trans-unit id="58a2993e94f23073b254c35171c856f14023d41f" translate="yes" xml:space="preserve">
          <source>Basic Types: Void</source>
          <target state="translated">Tipos básicos:Vacío</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">Uso básico</target>
        </trans-unit>
        <trans-unit id="61d56735d306d59953f3983c85541271068dbd2d" translate="yes" xml:space="preserve">
          <source>Basic gulpfile.js</source>
          <target state="translated">Archivo gulp básico.js</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">Uso básico</target>
        </trans-unit>
        <trans-unit id="412b5f9fcb13b09d7c79dbb054f0b03a03299e53" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 1</source>
          <target state="translated">Webpack.config.js básico cuando se usa el Webpack 1</target>
        </trans-unit>
        <trans-unit id="4eb989b59b1f0bb11bab44b3981ea2961cb73436" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 2</source>
          <target state="translated">Webpack.config.js básico al usar Webpack 2</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="74f706e43bf557f0281375454415863443ab6f79" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote &amp;ldquo;The Impact of ES6 on Module Call Signatures&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">Aseg&amp;uacute;rese de leer la &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;nota a pie de p&amp;aacute;gina &quot;El impacto de ES6 en las firmas de llamadas del m&amp;oacute;dulo&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9079f4cebe690d974b574d363d2382dfc53aa88d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.</source>
          <target state="translated">Debido a que &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;una propiedad ideal del software est&amp;aacute; abierta a la extensi&amp;oacute;n&lt;/a&gt; , siempre debe usar una interfaz sobre un alias de tipo si es posible.</target>
        </trans-unit>
        <trans-unit id="5334136ac4ebd83a783dcba6f8148dc9c2a1da75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Dog&lt;/code&gt; extends the functionality from &lt;code&gt;Animal&lt;/code&gt;, we were able to create an instance of &lt;code&gt;Dog&lt;/code&gt; that could both &lt;code&gt;bark()&lt;/code&gt; and &lt;code&gt;move()&lt;/code&gt;.</source>
          <target state="translated">Debido a que &lt;code&gt;Dog&lt;/code&gt; extiende la funcionalidad de &lt;code&gt;Animal&lt;/code&gt; , pudimos crear una instancia de &lt;code&gt;Dog&lt;/code&gt; que podr&amp;iacute;a tanto &lt;code&gt;bark()&lt;/code&gt; como &lt;code&gt;move()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60995ae598e05ed025f86ab90ffdb0762aef9f1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;s first parameter is of type &lt;code&gt;ClockConstructor&lt;/code&gt;, in &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;, it checks that &lt;code&gt;AnalogClock&lt;/code&gt; has the correct constructor signature.</source>
          <target state="translated">Debido &lt;code&gt;createClock&lt;/code&gt; primer par&amp;aacute;metro &amp;lsquo;s es de tipo &lt;code&gt;ClockConstructor&lt;/code&gt; , en &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt; , se comprueba que &lt;code&gt;AnalogClock&lt;/code&gt; tiene la firma constructor correcta.</target>
        </trans-unit>
        <trans-unit id="fc9360e6a9694db19840df20dcd21ab49ff88f74" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;haveMuscles&lt;/code&gt; is not exported, only the &lt;code&gt;animalsHaveMuscles&lt;/code&gt; function that shares the same un-merged namespace can see the symbol. The &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; function, even though it&amp;rsquo;s part of the merged &lt;code&gt;Animal&lt;/code&gt; namespace can not see this un-exported member.</source>
          <target state="translated">Debido a que &lt;code&gt;haveMuscles&lt;/code&gt; no se exporta, solo la funci&amp;oacute;n &lt;code&gt;animalsHaveMuscles&lt;/code&gt; que comparte el mismo espacio de nombres no combinado puede ver el s&amp;iacute;mbolo. La funci&amp;oacute;n &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; , aunque es parte del espacio de nombres &lt;code&gt;Animal&lt;/code&gt; fusionado, no puede ver este miembro no exportado.</target>
        </trans-unit>
        <trans-unit id="889f24f65391ea32e9fe866488efa3356b72acf4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</source>
          <target state="translated">Debido a que &lt;code&gt;never&lt;/code&gt; es un subtipo de todos los tipos, siempre se omite de los tipos de uni&amp;oacute;n y se ignora en la inferencia del tipo de retorno de la funci&amp;oacute;n siempre que se devuelvan otros tipos.</target>
        </trans-unit>
        <trans-unit id="b3b5c5e8091b38c11351f7ff855704d831cd693e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is assignable to every type, a function returning &lt;code&gt;never&lt;/code&gt; can be used when a callback returning a more specific type is required:</source>
          <target state="translated">Debido a que &lt;code&gt;never&lt;/code&gt; se puede asignar a todos los tipos, una funci&amp;oacute;n que devuelve &lt;code&gt;never&lt;/code&gt; se puede usar cuando se requiere una devoluci&amp;oacute;n de llamada que devuelva un tipo m&amp;aacute;s espec&amp;iacute;fico:</target>
        </trans-unit>
        <trans-unit id="860ec81e43c9b6e92f6dbbf8cdf9b9d2197d4f6a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onClickGood&lt;/code&gt; specifies its &lt;code&gt;this&lt;/code&gt; type as &lt;code&gt;void&lt;/code&gt;, it is legal to pass to &lt;code&gt;addClickListener&lt;/code&gt;. Of course, this also means that it can&amp;rsquo;t use &lt;code&gt;this.info&lt;/code&gt;. If you want both then you&amp;rsquo;ll have to use an arrow function:</source>
          <target state="translated">Debido a que &lt;code&gt;onClickGood&lt;/code&gt; especifica &lt;code&gt;this&lt;/code&gt; tipo como &lt;code&gt;void&lt;/code&gt; , es legal pasar a &lt;code&gt;addClickListener&lt;/code&gt; . Por supuesto, esto tambi&amp;eacute;n significa que no puede usar &lt;code&gt;this.info&lt;/code&gt; . Si quieres ambos, tendr&amp;aacute;s que usar una funci&amp;oacute;n de flecha:</target>
        </trans-unit>
        <trans-unit id="153757f182ba0912b5361e2742146aeb4241a619" translate="yes" xml:space="preserve">
          <source>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</source>
          <target state="translated">Debido a que TypeScript es un sistema de tipo estructural,los parámetros de tipo sólo afectan al tipo resultante cuando se consumen como parte del tipo de un miembro.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="926c5ce8de1d04093ea0f5a3309faccac7464c9c" translate="yes" xml:space="preserve">
          <source>Because TypeScript is structural, it doesn&amp;rsquo;t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to &lt;em&gt;propagate&lt;/em&gt; type information, such as constraining parameters to be the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a031100a59ee4b651a08813917a85230e2c2bcaf" translate="yes" xml:space="preserve">
          <source>Because TypeScript used to infer the type &lt;code&gt;BasicCalculator&lt;/code&gt; for each method in &lt;code&gt;BasicCalculator&lt;/code&gt; that returned &lt;code&gt;this&lt;/code&gt;, the type system would forget that it had &lt;code&gt;ScientificCalculator&lt;/code&gt; whenever using a &lt;code&gt;BasicCalculator&lt;/code&gt; method.</source>
          <target state="translated">Debido a que TypeScript sol&amp;iacute;a inferir el tipo &lt;code&gt;BasicCalculator&lt;/code&gt; para cada m&amp;eacute;todo en &lt;code&gt;BasicCalculator&lt;/code&gt; que devolv&amp;iacute;a &lt;code&gt;this&lt;/code&gt; , el sistema de tipos olvidar&amp;iacute;a que ten&amp;iacute;a &lt;code&gt;ScientificCalculator&lt;/code&gt; siempre que usara un m&amp;eacute;todo &lt;code&gt;BasicCalculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bedf22fdedc00ef56a14dec85f7bb3b3494d73cc" translate="yes" xml:space="preserve">
          <source>Because TypeScript&amp;rsquo;s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b1d39859ec43b815d699d91662781b5301f06b" translate="yes" xml:space="preserve">
          <source>Because a Function Component is simply a JavaScript function, function overloads may be used here as well:</source>
          <target state="translated">Debido a que un componente de función es simplemente una función de JavaScript,las sobrecargas de función pueden ser usadas aquí también:</target>
        </trans-unit>
        <trans-unit id="805d3d429e696b76e1abd7a4044863cf0873570b" translate="yes" xml:space="preserve">
          <source>Because an interface more closely maps how JavaScript objects work &lt;a href=&quot;https://wikipedia.org/wiki/Open/closed_principle&quot;&gt;by being open to extension&lt;/a&gt;, we recommend using an interface over a type alias when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346e805975d898d144111246435e10f969746b37" translate="yes" xml:space="preserve">
          <source>Because dependent projects make use of &lt;code&gt;.d.ts&lt;/code&gt; files that are built from their dependencies, you&amp;rsquo;ll either have to check in certain build outputs &lt;em&gt;or&lt;/em&gt; build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. We&amp;rsquo;re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</source>
          <target state="translated">Debido a que los proyectos dependientes utilizan archivos &lt;code&gt;.d.ts&lt;/code&gt; que se crean a partir de sus dependencias, tendr&amp;aacute; que verificar ciertos resultados de compilaci&amp;oacute;n &lt;em&gt;o&lt;/em&gt; compilar un proyecto despu&amp;eacute;s de clonarlo antes de poder navegar por el proyecto en un editor sin ver errores falsos. Estamos trabajando en un proceso de generaci&amp;oacute;n de .d.ts detr&amp;aacute;s de escena que deber&amp;iacute;a poder mitigar esto, pero por ahora recomendamos informar a los desarrolladores que deben compilar despu&amp;eacute;s de la clonaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="83ecbcc6afccbb397b118fab2ee6414e3c837482" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;unique symbol&lt;/code&gt; has a completely separate identity, no two &lt;code&gt;unique symbol&lt;/code&gt; types are assignable or comparable to each other.</source>
          <target state="translated">Debido a que cada &lt;code&gt;unique symbol&lt;/code&gt; tiene una identidad completamente separada, no hay dos tipos de &lt;code&gt;unique symbol&lt;/code&gt; asignables o comparables entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="bd9b4625ee3434502c77baac6fb3b4163197cdca" translate="yes" xml:space="preserve">
          <source>Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new &lt;code&gt;watchOptions&lt;/code&gt; field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7c5c8de643b44139d21f506a256a1fa4c079dd" translate="yes" xml:space="preserve">
          <source>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn&amp;rsquo;t need to be eagerly built out, TypeScript has no problem working with this structure.</source>
          <target state="translated">Debido a que las interfaces (y otros tipos de objetos) introducen un nivel de indirecci&amp;oacute;n y su estructura completa no necesita construirse con entusiasmo, TypeScript no tiene problemas para trabajar con esta estructura.</target>
        </trans-unit>
        <trans-unit id="f30f185f6397eb98d238c4bebb2ebc5adf9430be" translate="yes" xml:space="preserve">
          <source>Because it&amp;rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have &lt;em&gt;no&lt;/em&gt; dependencies) may still be global.</source>
          <target state="translated">Debido a que generalmente es f&amp;aacute;cil convertir una biblioteca global en una biblioteca UMD, muy pocas bibliotecas populares todav&amp;iacute;a se escriben en el estilo global. Sin embargo, las bibliotecas que son peque&amp;ntilde;as y requieren DOM (o &lt;em&gt;no&lt;/em&gt; tienen dependencias) pueden seguir siendo globales.</target>
        </trans-unit>
        <trans-unit id="8323beb09423cac98a2130445e161c576b080307" translate="yes" xml:space="preserve">
          <source>Because of that, they are now included by default in the standard library.</source>
          <target state="translated">Por eso,ahora están incluidos por defecto en la biblioteca estándar.</target>
        </trans-unit>
        <trans-unit id="21ce5edafa407b8340ea3cb9742b87949fcfb1fa" translate="yes" xml:space="preserve">
          <source>Because of the variety of supported JavaScript, upgrading to a new version of TypeScript can uncover two types of errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c12007f3b8d8a541217ea17e828d1c39d86708" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;number&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;number | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;code&gt;--strictNullChecks&lt;/code&gt; does not always work with old code.</source>
          <target state="translated">Debido a que el &lt;code&gt;switch&lt;/code&gt; ya no es exhaustivo, TypeScript es consciente de que la funci&amp;oacute;n a veces puede devolver &lt;code&gt;undefined&lt;/code&gt; . Si tiene un &lt;code&gt;number&lt;/code&gt; tipo de devoluci&amp;oacute;n expl&amp;iacute;cito , obtendr&amp;aacute; un error de que el tipo de devoluci&amp;oacute;n es en realidad &lt;code&gt;number | undefined&lt;/code&gt; . Sin embargo, este m&amp;eacute;todo es bastante sutil y, adem&amp;aacute;s, &lt;code&gt;--strictNullChecks&lt;/code&gt; no siempre funciona con c&amp;oacute;digo antiguo.</target>
        </trans-unit>
        <trans-unit id="a169ffc6d01ce9e9e1170f6d035a3b9d98c04e7e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;string&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;string | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt; does not always work with old code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef956693dc6ba68c2dd1bf8874b51293ed083ef" translate="yes" xml:space="preserve">
          <source>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</source>
          <target state="translated">Dado que el mejor tipo común debe elegirse entre los tipos candidatos proporcionados,hay algunos casos en los que los tipos comparten una estructura común,pero ningún tipo es el supertipo de todos los tipos candidatos.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="61eeffa792a60ab404349a9470da23f0926e8080" translate="yes" xml:space="preserve">
          <source>Because the generic function is now constrained, it will no longer work over any and all types:</source>
          <target state="translated">Debido a que la función genérica está ahora restringida,ya no funcionará sobre todos y cada uno de los tipos:</target>
        </trans-unit>
        <trans-unit id="d1ed1478bf3076f9798d93562781e783237eee9e" translate="yes" xml:space="preserve">
          <source>Because there&amp;rsquo;s no value for &lt;code&gt;someType&lt;/code&gt;, the emitted &lt;code&gt;export&lt;/code&gt; will not try to export it (this would be a runtime error in JavaScript):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aaed882fdf6dc6a4a05e269679bc56b985060ef" translate="yes" xml:space="preserve">
          <source>Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.</source>
          <target state="translated">Debido a que estos dos tipos de elementos basados en valores son indistinguibles entre sí en una expresión JSX,primero TS trata de resolver la expresión como un Componente de Función usando una resolución de sobrecarga.Si el proceso tiene éxito,entonces TS termina de resolver la expresión a su declaración.Si el valor no se resuelve como un Componente de Función,TS entonces intentará resolverlo como un componente de clase.Si eso falla,TS informará de un error.</target>
        </trans-unit>
        <trans-unit id="1803d91fbdbc9a61174b895ce63bd9e9db8a1a69" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve captured &lt;code&gt;city&lt;/code&gt; from within its environment, we&amp;rsquo;re still able to access it despite the fact that the &lt;code&gt;if&lt;/code&gt; block finished executing.</source>
          <target state="translated">Debido a que capturamos la &lt;code&gt;city&lt;/code&gt; desde su entorno, a&amp;uacute;n podemos acceder a ella a pesar de que el bloque &lt;code&gt;if&lt;/code&gt; termin&amp;oacute; de ejecutarse.</target>
        </trans-unit>
        <trans-unit id="d29eaff4a22709cf598b50d66101efbf59839265" translate="yes" xml:space="preserve">
          <source>Before ES2015, Javascript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.</source>
          <target state="translated">Antes de ES2015,Javascript usaba funciones constructoras en lugar de clases.El compilador soporta este patrón y entiende las funciones constructoras como equivalentes a las clases de ES2015.Las reglas de inferencia de propiedades descritas anteriormente funcionan exactamente de la misma manera.</target>
        </trans-unit>
        <trans-unit id="5da503870a40cc51e10eea3a3855e0636fb12368" translate="yes" xml:space="preserve">
          <source>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt;, the compiler looked up the definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.js.ts&lt;/code&gt; or &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;. This made it hard to use bundling/loading tools like &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; that expect URI&amp;rsquo;s in their module identifier.</source>
          <target state="translated">Antes de TypeScript 2.0, siempre se supon&amp;iacute;a que un identificador de m&amp;oacute;dulo no ten&amp;iacute;a extensi&amp;oacute;n; por ejemplo, dada una importaci&amp;oacute;n como &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt; , el compilador busc&amp;oacute; la definici&amp;oacute;n de &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; en &lt;code&gt;./moduleA.js.ts&lt;/code&gt; o &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt; . Esto dificult&amp;oacute; el uso de herramientas de agrupaci&amp;oacute;n / carga como &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; que esperan URI en su identificador de m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="67d8456dd67e313605647faf280117c02dfc9eeb" translate="yes" xml:space="preserve">
          <source>Before getting started with &lt;a href=&quot;basic-types&quot;&gt;Basic Types&lt;/a&gt;, we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7118581b77027e58723abfe83ca47073c2beca97" translate="yes" xml:space="preserve">
          <source>Before we get to Browserify, let&amp;rsquo;s build our code out and add modules to the mix. This is the structure you&amp;rsquo;re more likely to use for a real app.</source>
          <target state="translated">Antes de llegar a Browserify, construyamos nuestro c&amp;oacute;digo y agreguemos m&amp;oacute;dulos a la mezcla. Esta es la estructura que es m&amp;aacute;s probable que uses para una aplicaci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="d3fafb80e647f5908678c0a1365fa6a9b3b25a53" translate="yes" xml:space="preserve">
          <source>Bellow both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; will be marked as unused, because their values are never &lt;em&gt;read&lt;/em&gt;. Previously TypeScript would only check whether their values were &lt;em&gt;referenced&lt;/em&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, tanto &lt;code&gt;n&lt;/code&gt; como &lt;code&gt;m&lt;/code&gt; se marcar&amp;aacute;n como no utilizados, porque sus valores nunca se &lt;em&gt;leen&lt;/em&gt; . Anteriormente, TypeScript solo verificaba si se hac&amp;iacute;a &lt;em&gt;referencia a&lt;/em&gt; sus valores .</target>
        </trans-unit>
        <trans-unit id="b1593ec79184963de3c26cd55f6cd6ff5fde3164" translate="yes" xml:space="preserve">
          <source>Below, we&amp;rsquo;ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</source>
          <target state="translated">A continuaci&amp;oacute;n, consolidamos las implementaciones de Validator utilizadas en ejemplos anteriores para exportar solo una exportaci&amp;oacute;n con nombre de cada m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="23b1b090e17cb993e2e92ba109a6404125e1c084" translate="yes" xml:space="preserve">
          <source>Best common type</source>
          <target state="translated">El mejor tipo común</target>
        </trans-unit>
        <trans-unit id="73f4d62437edf5f4e4d12a007397acc1aef2efe1" translate="yes" xml:space="preserve">
          <source>Better Module Visibility Rules</source>
          <target state="translated">Mejores reglas de visibilidad del módulo</target>
        </trans-unit>
        <trans-unit id="24fe9a5afd90b3567ffa5a70e33cace7ce8a2cd6" translate="yes" xml:space="preserve">
          <source>Better Support for &lt;code&gt;never&lt;/code&gt;-Returning Functions</source>
          <target state="translated">Mejor soporte para funciones que &lt;code&gt;never&lt;/code&gt; regresan</target>
        </trans-unit>
        <trans-unit id="21657adf3906ba19a9fc0bf5880e4ab0670a6b78" translate="yes" xml:space="preserve">
          <source>Better Type Inference</source>
          <target state="translated">Mejor tipo de inferencia</target>
        </trans-unit>
        <trans-unit id="7d2959d47c022c161218042546a51da5d892926e" translate="yes" xml:space="preserve">
          <source>Better Unicode Support for Identifiers</source>
          <target state="translated">Mejor soporte de Unicode para los identificadores</target>
        </trans-unit>
        <trans-unit id="9a0ba3945bacbf9283dac7172d7a127f0967cb4d" translate="yes" xml:space="preserve">
          <source>Better checking for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; in operands of expressions</source>
          <target state="translated">Mejor comprobaci&amp;oacute;n de &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; en operandos de expresiones</target>
        </trans-unit>
        <trans-unit id="1edbfa311bc15bdb82e37657789378148ae24f62" translate="yes" xml:space="preserve">
          <source>Better handling for namespace patterns in &lt;code&gt;.js&lt;/code&gt; files</source>
          <target state="translated">Mejor manejo de patrones de espacio de nombres en archivos &lt;code&gt;.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1459fb8ee8a9e746ee1ec8bc34a675600de96aa9" translate="yes" xml:space="preserve">
          <source>Better inference for literal types</source>
          <target state="translated">Mejor inferencia para los tipos literales</target>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes" xml:space="preserve">
          <source>BigInt</source>
          <target state="translated">BigInt</target>
        </trans-unit>
        <trans-unit id="288d51c5150441fed0b9e86f5152123e527ee75c" translate="yes" xml:space="preserve">
          <source>BigInt support in TypeScript introduces a new primitive type called the &lt;code&gt;bigint&lt;/code&gt; (all lowercase). You can get a &lt;code&gt;bigint&lt;/code&gt; by calling the &lt;code&gt;BigInt()&lt;/code&gt; function or by writing out a BigInt literal by adding an &lt;code&gt;n&lt;/code&gt; to the end of any integer numeric literal:</source>
          <target state="translated">El soporte de BigInt en TypeScript introduce un nuevo tipo primitivo llamado &lt;code&gt;bigint&lt;/code&gt; (todo en min&amp;uacute;sculas). Puede obtener un &lt;code&gt;bigint&lt;/code&gt; llamando a la funci&amp;oacute;n &lt;code&gt;BigInt()&lt;/code&gt; o escribiendo un literal BigInt agregando una &lt;code&gt;n&lt;/code&gt; al final de cualquier literal num&amp;eacute;rico entero:</target>
        </trans-unit>
        <trans-unit id="554ca025eac7b2c84da4d87e6d9f6fd09932aeac" translate="yes" xml:space="preserve">
          <source>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">Los BigInts son parte de una pr&amp;oacute;xima propuesta en ECMAScript que nos permite modelar te&amp;oacute;ricamente n&amp;uacute;meros enteros arbitrariamente grandes. TypeScript 3.2 ofrece verificaci&amp;oacute;n de tipo para BigInts, as&amp;iacute; como soporte para emitir literales BigInt al apuntar a &lt;code&gt;esnext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="680e45e0d9641fb72fe09a5f60291f49ec52f51b" translate="yes" xml:space="preserve">
          <source>Block scoped</source>
          <target state="translated">Bloque de alcance</target>
        </trans-unit>
        <trans-unit id="6a8c3370d98498723b46771881ba81defd0dc40c" translate="yes" xml:space="preserve">
          <source>Block-scoped variable capturing</source>
          <target state="translated">Captura de variables en bloque</target>
        </trans-unit>
        <trans-unit id="a849fb31e66cbf4e00c81e17be0f996cdee6ecbd" translate="yes" xml:space="preserve">
          <source>Block-scoping</source>
          <target state="translated">Block-scoping</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="1e4200b2f583d0dc3a8f8c9ca192857c23373085" translate="yes" xml:space="preserve">
          <source>Boolean Literal Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34e54cea707257c0130f46138224a1c1962a392" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;for..of&lt;/code&gt; and &lt;code&gt;for..in&lt;/code&gt; statements iterate over lists; the values iterated on are different though, &lt;code&gt;for..in&lt;/code&gt; returns a list of &lt;em&gt;keys&lt;/em&gt; on the object being iterated, whereas &lt;code&gt;for..of&lt;/code&gt; returns a list of &lt;em&gt;values&lt;/em&gt; of the numeric properties of the object being iterated.</source>
          <target state="translated">Tanto las &lt;code&gt;for..of&lt;/code&gt; como &lt;code&gt;for..in&lt;/code&gt; iteran sobre listas; los valores iterados son diferentes sin embargo, &lt;code&gt;for..in&lt;/code&gt; devuelve una lista de &lt;em&gt;claves&lt;/em&gt; en el objeto que se itera, mientras que &lt;code&gt;for..of&lt;/code&gt; devuelve una lista de &lt;em&gt;valores&lt;/em&gt; de las propiedades num&amp;eacute;ricas del objeto que se itera.</target>
        </trans-unit>
        <trans-unit id="883409a532b5058d1cc5b8f4b490cb78e4d78575" translate="yes" xml:space="preserve">
          <source>Both CommonJS and AMD generally have the concept of an &lt;code&gt;exports&lt;/code&gt; object which contains all exports from a module.</source>
          <target state="translated">Tanto CommonJS como AMD generalmente tienen el concepto de un objeto de &lt;code&gt;exports&lt;/code&gt; que contiene todas las exportaciones de un m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="e51d223984b330914b72e271341f74aef8d2cd0b" translate="yes" xml:space="preserve">
          <source>Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript&amp;rsquo;s standard configuration file named &lt;code&gt;tsconfig.json&lt;/code&gt;. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating &lt;em&gt;its own&lt;/em&gt; sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.</source>
          <target state="translated">Ambas dependencias permitir&amp;aacute;n que TypeScript y webpack funcionen bien juntos. ts-loader ayuda a Webpack a compilar su c&amp;oacute;digo TypeScript utilizando el archivo de configuraci&amp;oacute;n est&amp;aacute;ndar de TypeScript llamado &lt;code&gt;tsconfig.json&lt;/code&gt; . source-map-loader utiliza cualquier salida de mapa de origen de TypeScript para informar al paquete web cuando genera &lt;em&gt;sus propios&lt;/em&gt; mapas de origen. Esto le permitir&amp;aacute; depurar su archivo de salida final como si estuviera depurando su c&amp;oacute;digo fuente original de TypeScript.</target>
        </trans-unit>
        <trans-unit id="1e8845429ecea7d81d05bd48bc682718054a7086" translate="yes" xml:space="preserve">
          <source>Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in &lt;em&gt;lib.dom.d.ts&lt;/em&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a3e07fa1f601ed37521339b8334bccb8a1dfdc" translate="yes" xml:space="preserve">
          <source>Boxed types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">Cambios de ruptura</target>
        </trans-unit>
        <trans-unit id="b27e195ce4797e99f5340bc74096020036597226" translate="yes" xml:space="preserve">
          <source>Broadly speaking, the way you &lt;em&gt;structure&lt;/em&gt; your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you&amp;rsquo;ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.</source>
          <target state="translated">En t&amp;eacute;rminos generales, la forma en que &lt;em&gt;estructura&lt;/em&gt; su archivo de declaraci&amp;oacute;n depende de c&amp;oacute;mo se consume la biblioteca. Hay muchas formas de ofrecer una biblioteca para el consumo en JavaScript, y deber&amp;aacute; escribir su archivo de declaraci&amp;oacute;n para que coincida. Esta gu&amp;iacute;a cubre c&amp;oacute;mo identificar patrones de biblioteca comunes y c&amp;oacute;mo escribir archivos de declaraci&amp;oacute;n que correspondan a ese patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="edcb28a656230c4acfe867a59a63fd0995d0aef6" translate="yes" xml:space="preserve">
          <source>Build Mode for TypeScript</source>
          <target state="translated">Modo de construcción para TypeScript</target>
        </trans-unit>
        <trans-unit id="97e7d70d841f68a4ff5d6072efb212e8b37ee112" translate="yes" xml:space="preserve">
          <source>Build mode (see below) will automatically build the referenced project if needed</source>
          <target state="translated">El modo de construcción (ver abajo)construirá automáticamente el proyecto de referencia si es necesario</target>
        </trans-unit>
        <trans-unit id="9a92faaf499ddda5acb18453d8927f47fed81460" translate="yes" xml:space="preserve">
          <source>Build out-of-date projects in the correct order</source>
          <target state="translated">Construir proyectos obsoletos en el orden correcto</target>
        </trans-unit>
        <trans-unit id="2764e7dc64a6afa8f6572a70be9cc2ef88d207b2" translate="yes" xml:space="preserve">
          <source>Build tools</source>
          <target state="translated">Construir herramientas</target>
        </trans-unit>
        <trans-unit id="75ec9400efe849c1db62787034008d1f92c2c91f" translate="yes" xml:space="preserve">
          <source>Build-Free Editing with Project References</source>
          <target state="translated">Edición libre de construcción con referencias de proyectos</target>
        </trans-unit>
        <trans-unit id="4af30b251537bff0e947429ed6b58b4a863bc66d" translate="yes" xml:space="preserve">
          <source>Building on that work, the new &lt;code&gt;Generator&lt;/code&gt; type is an &lt;code&gt;Iterator&lt;/code&gt; that always has both the &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; methods present, and is also iterable.</source>
          <target state="translated">Sobre la base de ese trabajo, el nuevo tipo de &lt;code&gt;Generator&lt;/code&gt; es un &lt;code&gt;Iterator&lt;/code&gt; que siempre tiene presentes los m&amp;eacute;todos de &lt;code&gt;return&lt;/code&gt; y &lt;code&gt;throw&lt;/code&gt; , y tambi&amp;eacute;n es iterable.</target>
        </trans-unit>
        <trans-unit id="7a2e862f607c464ec5aa4c11cde1137378e9c2a2" translate="yes" xml:space="preserve">
          <source>Building your first TypeScript file</source>
          <target state="translated">Construyendo su primer archivo de TypeScript</target>
        </trans-unit>
        <trans-unit id="03b24ded4facb2cf945d4c05f6eb1ab851a39a94" translate="yes" xml:space="preserve">
          <source>Builds this project and all of its dependencies specified by &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt;. Note that this flag is not compatible with others on this page. See more &lt;a href=&quot;project-references&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Construye este proyecto y todas sus dependencias especificadas por &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt; . Tenga en cuenta que esta bandera no es compatible con otras en esta p&amp;aacute;gina. Ver m&amp;aacute;s &lt;a href=&quot;project-references&quot;&gt;aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="343555e3e4e0ac83e26882ec6baa2142ba94e980" translate="yes" xml:space="preserve">
          <source>Built-in &lt;em&gt;lib&lt;/em&gt; files are referenced in the same fashion as the &lt;code&gt;&quot;lib&quot;&lt;/code&gt; compiler option in &lt;em&gt;tsconfig.json&lt;/em&gt; (e.g. use &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; and not &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt;, etc.).</source>
          <target state="translated">Los archivos &lt;em&gt;lib&lt;/em&gt; integrados se referencian de la misma manera que la opci&amp;oacute;n del compilador &lt;code&gt;&quot;lib&quot;&lt;/code&gt; en &lt;em&gt;tsconfig.json&lt;/em&gt; (por ejemplo, use &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; y no &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="baf48ef674c1f3f27e6a46bcb471b4b64069504c" translate="yes" xml:space="preserve">
          <source>Built-in Combinations</source>
          <target state="translated">Combinaciones incorporadas</target>
        </trans-unit>
        <trans-unit id="0f6bebd51ff8927e6e3679a7b2412429e9c60cb6" translate="yes" xml:space="preserve">
          <source>Built-in types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f915eb393ecd85cb63e15dffe8826e1553f8b829" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;not&lt;/em&gt;</source>
          <target state="translated">Pero &lt;em&gt;no&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b6d682a32e9471d3d56044de293812fad6102" translate="yes" xml:space="preserve">
          <source>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</source>
          <target state="translated">Pero como ejemplo de un lugar donde se aplazan los tipos condicionales-donde se quedan en lugar de coger una rama-sería en lo siguiente:</target>
        </trans-unit>
        <trans-unit id="280120ab44ab2249440ce6b53b7137cb76018378" translate="yes" xml:space="preserve">
          <source>But it also infers types in a few other places that you may not expect if you&amp;rsquo;ve worked with other C-syntax languages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7399465efb16f2292f334ce116d2782df394ded" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s more useful to have a general version.</source>
          <target state="translated">Pero es m&amp;aacute;s &amp;uacute;til tener una versi&amp;oacute;n general.</target>
        </trans-unit>
        <trans-unit id="52aa7f7d640381262f44bf2422e0184ae5802614" translate="yes" xml:space="preserve">
          <source>But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.</source>
          <target state="translated">Pero especificar los valores por defecto es más común para los parámetros,y conseguir los valores por defecto correctamente con la desestructuración puede ser difícil.En primer lugar,hay que recordar que hay que poner el patrón antes del valor por defecto.</target>
        </trans-unit>
        <trans-unit id="5085629431a212a779f2b5de79ca5c3f88994593" translate="yes" xml:space="preserve">
          <source>But workaround of introducing the interface wasn&amp;rsquo;t intuitive for users. And in principle there really wasn&amp;rsquo;t anything wrong with the original version of &lt;code&gt;ValueOrArray&lt;/code&gt; that used &lt;code&gt;Array&lt;/code&gt; directly. If the compiler was a little bit &amp;ldquo;lazier&amp;rdquo; and only calculated the type arguments to &lt;code&gt;Array&lt;/code&gt; when necessary, then TypeScript could express these correctly.</source>
          <target state="translated">Pero la soluci&amp;oacute;n alternativa para introducir la interfaz no fue intuitiva para los usuarios. Y, en principio, realmente no hab&amp;iacute;a nada malo con la versi&amp;oacute;n original de &lt;code&gt;ValueOrArray&lt;/code&gt; que usaba &lt;code&gt;Array&lt;/code&gt; directamente. Si el compilador era un poco m&amp;aacute;s &quot;vago&quot; y solo calculaba los argumentos de tipo para &lt;code&gt;Array&lt;/code&gt; cuando era necesario, TypeScript podr&amp;iacute;a expresarlos correctamente.</target>
        </trans-unit>
        <trans-unit id="4960285f41cfd516633e4d60d8fcdf547d96a1af" translate="yes" xml:space="preserve">
          <source>By Example</source>
          <target state="translated">Por ejemplo</target>
        </trans-unit>
        <trans-unit id="56013fe0821df629b3c4ad53f4b6924be246e572" translate="yes" xml:space="preserve">
          <source>By Example: Classes</source>
          <target state="translated">Por ejemplo:Clases</target>
        </trans-unit>
        <trans-unit id="6b36dc2d84d25fdd51b964cd61bedec7d9e60902" translate="yes" xml:space="preserve">
          <source>By Example: Global Functions</source>
          <target state="translated">Por ejemplo:Funciones Globales</target>
        </trans-unit>
        <trans-unit id="3744ba63d2d3cc6574aaf71d98c1674b39508a8a" translate="yes" xml:space="preserve">
          <source>By Example: Global Variables</source>
          <target state="translated">Por ejemplo:Variables globales</target>
        </trans-unit>
        <trans-unit id="eea9b1c9ef5abea178ee5d4cd53163ad4f035d14" translate="yes" xml:space="preserve">
          <source>By Example: Objects with Properties</source>
          <target state="translated">Por ejemplo:Objetos con propiedades</target>
        </trans-unit>
        <trans-unit id="74283c34f93d05517451768bcffe2038c4e7a212" translate="yes" xml:space="preserve">
          <source>By Example: Organizing Types</source>
          <target state="translated">Por ejemplo:Tipos de organización</target>
        </trans-unit>
        <trans-unit id="786404ba943c8314507c329a9d6f9d54f3179127" translate="yes" xml:space="preserve">
          <source>By Example: Overloaded Functions</source>
          <target state="translated">Por ejemplo:Funciones sobrecargadas</target>
        </trans-unit>
        <trans-unit id="c20e92aa75ef55f57a42b723ab0f280766d7b7fe" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Interfaces)</source>
          <target state="translated">Por ejemplo:Tipos reutilizables (Interfaces)</target>
        </trans-unit>
        <trans-unit id="7a1f49420a7b27a3ee7b0e838fa3b2dbec6f81a8" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Type Aliases)</source>
          <target state="translated">Por ejemplo:Tipos reutilizables (alias de tipos)</target>
        </trans-unit>
        <trans-unit id="7bae2a3265a68393939ee4d97179b68dd46cb074" translate="yes" xml:space="preserve">
          <source>By default (with &lt;code&gt;esModuleInterop&lt;/code&gt; false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a082a066e7a09d6b1c6e75f3176d5a38819ca5b2" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are subtypes of all other types. That means you can assign &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; to something like &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Por defecto, &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; son subtipos de todos los dem&amp;aacute;s tipos. Eso significa que puede asignar &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; a algo como &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88529c44919e2de860ade6d72375e6a6ee709e4e" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">Por defecto, los m&amp;oacute;dulos AMD se generan de forma an&amp;oacute;nima. Esto puede generar problemas cuando se utilizan otras herramientas para procesar los m&amp;oacute;dulos resultantes como paquetes (por ejemplo, &lt;code&gt;r.js&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c715e4fe44b99c0302712a9e167af08e84c2d13" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">Por defecto, los m&amp;oacute;dulos AMD se generan de forma an&amp;oacute;nima. Esto puede generar problemas cuando se utilizan otras herramientas para procesar los m&amp;oacute;dulos resultantes, como paquetes (por ejemplo, &lt;code&gt;r.js&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4d87e4e57028fc486e676c2ecdd8c6471f91d0c" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;; specifically, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="translated">De forma predeterminada, todos los paquetes &quot; &lt;code&gt;@types&lt;/code&gt; &quot; &lt;em&gt;visibles&lt;/em&gt; se incluyen en su compilaci&amp;oacute;n. Los paquetes en los &lt;code&gt;node_modules/@types&lt;/code&gt; de cualquier carpeta adjunta se consideran &lt;em&gt;visibles&lt;/em&gt; ; espec&amp;iacute;ficamente, eso significa paquetes dentro &lt;code&gt;./node_modules/@types/&lt;/code&gt; , &lt;code&gt;../node_modules/@types/&lt;/code&gt; , &lt;code&gt;../../node_modules/@types/&lt;/code&gt; , y as&amp;iacute; sucesivamente.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8d004cf1198829c9480cb66e1fa5db152e6f49b" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;rdquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;. For example, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe14b4afe246d0c7517495f8c1f6da852617e95" translate="yes" xml:space="preserve">
          <source>By default converts to this JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e369ee47538940ad2b625bd062454fb84b462ef8" translate="yes" xml:space="preserve">
          <source>By default the TypeScript compiler does not report any errors in .js files including using &lt;code&gt;--allowJs&lt;/code&gt;. With TypeScript 2.3 type-checking errors can also be reported in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, el compilador de TypeScript no informa ning&amp;uacute;n error en los archivos .js, incluido el uso de &lt;code&gt;--allowJs&lt;/code&gt; . Con TypeScript 2.3, los errores de verificaci&amp;oacute;n de tipo tambi&amp;eacute;n se pueden informar en archivos &lt;code&gt;.js&lt;/code&gt; con &lt;code&gt;--checkJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e6fef05048e1036967e644248934ab3290242b" translate="yes" xml:space="preserve">
          <source>By default the output new line character is &lt;code&gt;\r\n&lt;/code&gt; on Windows based systems and &lt;code&gt;\n&lt;/code&gt; on *nix based systems. &lt;code&gt;--newLine&lt;/code&gt; command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</source>
          <target state="translated">Por defecto, el car&amp;aacute;cter de nueva l&amp;iacute;nea de salida es &lt;code&gt;\r\n&lt;/code&gt; en sistemas basados ​​en Windows y &lt;code&gt;\n&lt;/code&gt; en sistemas basados ​​en * nix. &lt;code&gt;--newLine&lt;/code&gt; l&amp;iacute;nea de comando --newLine permite anular este comportamiento y especificar el car&amp;aacute;cter de nueva l&amp;iacute;nea que se utilizar&amp;aacute; en los archivos de salida generados.</target>
        </trans-unit>
        <trans-unit id="2b8dc7f5bdcc1f900ed0076c9443382574f8ede2" translate="yes" xml:space="preserve">
          <source>By default the result of a JSX expression is typed as &lt;code&gt;any&lt;/code&gt;. You can customize the type by specifying the &lt;code&gt;JSX.Element&lt;/code&gt; interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</source>
          <target state="translated">De forma predeterminada, el resultado de una expresi&amp;oacute;n JSX se escribe como &lt;code&gt;any&lt;/code&gt; . Puede personalizar el tipo especificando la interfaz &lt;code&gt;JSX.Element&lt;/code&gt; . Sin embargo, no es posible recuperar informaci&amp;oacute;n de tipo sobre el elemento, atributos o hijos de JSX desde esta interfaz. Es una caja negra.</target>
        </trans-unit>
        <trans-unit id="ab2b32ff0e315d45d6fc02e2a6cbedac511ef9df" translate="yes" xml:space="preserve">
          <source>By default the type of &lt;code&gt;this&lt;/code&gt; inside a function is &lt;code&gt;any&lt;/code&gt;. Starting with TypeScript 2.0, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">Por defecto, el tipo de &lt;code&gt;this&lt;/code&gt; dentro de una funci&amp;oacute;n es &lt;code&gt;any&lt;/code&gt; . A partir de TypeScript 2.0, puede proporcionar un &lt;code&gt;this&lt;/code&gt; par&amp;aacute;metro expl&amp;iacute;cito . &lt;code&gt;this&lt;/code&gt; par&amp;aacute;metros son par&amp;aacute;metros falsos que aparecen primero en la lista de par&amp;aacute;metros de una funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="b1b20c9a3a0cc7d25cfbb8affbd8cc2de8f4531f" translate="yes" xml:space="preserve">
          <source>By default with these settings, when we run &lt;code&gt;tsc&lt;/code&gt;, TypeScript will look for a file called &lt;code&gt;.tsbuildinfo&lt;/code&gt; in the output directory (&lt;code&gt;./lib&lt;/code&gt;). If &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; doesn&amp;rsquo;t exist, it&amp;rsquo;ll be generated. But if it does, &lt;code&gt;tsc&lt;/code&gt; will try to use that file to incrementally type-check and update our output files.</source>
          <target state="translated">De forma predeterminada, con esta configuraci&amp;oacute;n, cuando ejecutamos &lt;code&gt;tsc&lt;/code&gt; , TypeScript buscar&amp;aacute; un archivo llamado &lt;code&gt;.tsbuildinfo&lt;/code&gt; en el directorio de salida ( &lt;code&gt;./lib&lt;/code&gt; ). Si &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; no existe, se generar&amp;aacute;. Pero si lo hace, &lt;code&gt;tsc&lt;/code&gt; intentar&amp;aacute; usar ese archivo para verificar de forma incremental y actualizar nuestros archivos de salida.</target>
        </trans-unit>
        <trans-unit id="978c0bcb7dd8270885bef9e6f191062a2f183d1b" translate="yes" xml:space="preserve">
          <source>By default, TypeScript assumes that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are in the domain of every type. That means anything declared with the type &lt;code&gt;number&lt;/code&gt; could be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Since &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the &lt;code&gt;strictNullChecks&lt;/code&gt; option to spare you the stress of worrying about these issues.</source>
          <target state="translated">De forma predeterminada, TypeScript asume que &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute;n en el dominio de cada tipo. Eso significa que cualquier cosa declarada con el &lt;code&gt;number&lt;/code&gt; tipo podr&amp;iacute;a ser &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . Dado que &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; son una fuente tan frecuente de errores en JavaScript y TypeScript, TypeScript tiene la opci&amp;oacute;n &lt;code&gt;strictNullChecks&lt;/code&gt; para evitarle el estr&amp;eacute;s de preocuparse por estos problemas.</target>
        </trans-unit>
        <trans-unit id="81ae234f340bd85fd153e90ec1d2e0c01b304e39" translate="yes" xml:space="preserve">
          <source>By default, TypeScript will examine the initial set of files for &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;&amp;lt;reference&lt;/code&gt; directives and add these resolved files to your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a8ae67117a0b9e1048859af200beff97bdb1a4" translate="yes" xml:space="preserve">
          <source>By default, enums begin numbering their members starting at &lt;code&gt;0&lt;/code&gt;. You can change this by manually setting the value of one of its members. For example, we can start the previous example at &lt;code&gt;1&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">De forma predeterminada, las enumeraciones comienzan a numerar a sus miembros a partir de &lt;code&gt;0&lt;/code&gt; . Puede cambiar esto configurando manualmente el valor de uno de sus miembros. Por ejemplo, podemos comenzar el ejemplo anterior en &lt;code&gt;1&lt;/code&gt; en lugar de &lt;code&gt;0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b2f3061b8b67ef271d84bdab07aa0d4586d6daa" translate="yes" xml:space="preserve">
          <source>By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href=&quot;https://wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132e01557f70ffea3b32aeb9180827e17d27b06d" translate="yes" xml:space="preserve">
          <source>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</source>
          <target state="translated">Haciendo esto,puedes mejorar enormemente los tiempos de construcción,reforzar la separación lógica entre componentes y organizar tu código de nuevas y mejores maneras.</target>
        </trans-unit>
        <trans-unit id="692f9bb4646bcb36f65c5f7ab233f8f2764f0cb4" translate="yes" xml:space="preserve">
          <source>By installing TypeScript&amp;rsquo;s Visual Studio plugins</source>
          <target state="translated">Instalando los complementos de Visual Studio de TypeScript</target>
        </trans-unit>
        <trans-unit id="86eb4b62601e3e81ff1dca5cc4e6dbdc4a89a2c0" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</source>
          <target state="translated">Invocando a tsc sin archivos de entrada y una opción de línea de comandos -proyecto (o sólo -p)que especifica la ruta de un directorio que contiene un archivo tsconfig.json.</target>
        </trans-unit>
        <trans-unit id="ad9887b67e7c7119b9c0b607afc13f555d0df339" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a &lt;code&gt;--project&lt;/code&gt; (or just &lt;code&gt;-p&lt;/code&gt;) command line option that specifies the path of a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or a path to a valid &lt;code&gt;.json&lt;/code&gt; file containing the configurations.</source>
          <target state="translated">Al invocar tsc sin archivos de entrada y una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--project&lt;/code&gt; (o simplemente &lt;code&gt;-p&lt;/code&gt; ) que especifica la ruta de un directorio que contiene un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; , o una ruta a un archivo &lt;code&gt;.json&lt;/code&gt; v&amp;aacute;lido que contiene las configuraciones.</target>
        </trans-unit>
        <trans-unit id="3c63c6b34aecd8a89f4657217a7bc97d993bf39e" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the &lt;code&gt;tsconfig.json&lt;/code&gt; file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">Al invocar tsc sin archivos de entrada, en cuyo caso el compilador busca el archivo &lt;code&gt;tsconfig.json&lt;/code&gt; comenzando en el directorio actual y continuando hacia arriba en la cadena del directorio principal.</target>
        </trans-unit>
        <trans-unit id="e89553a08b737777f431dc9d9801f1465f3a4fb2" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">Invocando a tsc sin archivos de entrada,en cuyo caso el compilador busca el archivo tsconfig.json comenzando en el directorio actual y continuando hacia arriba en la cadena de directorios padre.</target>
        </trans-unit>
        <trans-unit id="79537a92f4047372fecdfd37460ca2a8188a29b0" translate="yes" xml:space="preserve">
          <source>By just passing the &lt;code&gt;--pretty&lt;/code&gt; command line option, TypeScript gives more colorful output with context about where things are going wrong.</source>
          <target state="translated">Con solo pasar la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--pretty&lt;/code&gt; , TypeScript brinda una salida m&amp;aacute;s colorida con contexto sobre d&amp;oacute;nde las cosas van mal.</target>
        </trans-unit>
        <trans-unit id="e52ec44ebc49650e959b28d0b5dbe4cdf8ee0312" translate="yes" xml:space="preserve">
          <source>By leveraging &lt;code&gt;rootDirs&lt;/code&gt; we can inform the compiler of this mapping and thereby allow it to safely resolve &lt;code&gt;./#{locale}/messages&lt;/code&gt;, even though the directory will never exist. For example, with the following &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">Al aprovechar &lt;code&gt;rootDirs&lt;/code&gt; , podemos informar al compilador de esta asignaci&amp;oacute;n y, por lo tanto, permitir que resuelva de manera segura &lt;code&gt;./#{locale}/messages&lt;/code&gt; , aunque el directorio nunca existir&amp;aacute;. Por ejemplo, con el siguiente &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7a6554ec42c2340c5fe50c2d315a5a222a594fab" translate="yes" xml:space="preserve">
          <source>By now you&amp;rsquo;ve figured out that &lt;code&gt;var&lt;/code&gt; has some problems, which is precisely why &lt;code&gt;let&lt;/code&gt; statements were introduced. Apart from the keyword used, &lt;code&gt;let&lt;/code&gt; statements are written the same way &lt;code&gt;var&lt;/code&gt; statements are.</source>
          <target state="translated">A estas alturas ya se habr&amp;aacute; dado cuenta de que &lt;code&gt;var&lt;/code&gt; tiene algunos problemas, que es precisamente la raz&amp;oacute;n por la &lt;code&gt;let&lt;/code&gt; se introdujeron las sentencias let . Aparte de la palabra clave utilizada, las sentencias &lt;code&gt;let&lt;/code&gt; se escriben de la misma forma que las sentencias &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d522062326dbb5972e36c53a7116048922cfac7" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cb72c1385357bc15ce05b98a7efaf15553d757" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex definition files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="translated">Al leer esta gu&amp;iacute;a, tendr&amp;aacute; las herramientas para escribir archivos de definici&amp;oacute;n complejos que exponen una superficie API amigable. Esta gu&amp;iacute;a se centra en las bibliotecas de m&amp;oacute;dulos (o UMD) porque las opciones aqu&amp;iacute; son m&amp;aacute;s variadas.</target>
        </trans-unit>
        <trans-unit id="411c4003c83ae27481aabc4631e018c37321d319" translate="yes" xml:space="preserve">
          <source>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</source>
          <target state="translated">Al separarse en múltiples proyectos,puede mejorar enormemente la velocidad de comprobación y compilación,reducir el uso de la memoria al utilizar un editor y mejorar la aplicación de las agrupaciones lógicas de su programa.</target>
        </trans-unit>
        <trans-unit id="3214b1c0cea1d0e9f41edbd469679a29258a29b8" translate="yes" xml:space="preserve">
          <source>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript&amp;rsquo;s structural type system.</source>
          <target state="translated">Por cierto, tenga en cuenta que mientras que algunos lenguajes (por ejemplo, C # y Scala) requieren anotaciones de variaci&amp;oacute;n ( &lt;code&gt;out&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; o &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; ), la variaci&amp;oacute;n surge naturalmente del uso real de un par&amp;aacute;metro de tipo dentro de un tipo gen&amp;eacute;rico debido al sistema de tipos estructurales de TypeScript.</target>
        </trans-unit>
        <trans-unit id="37a5bb86f5de627c75eefc01c9440b9728e21c0e" translate="yes" xml:space="preserve">
          <source>By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That&amp;rsquo;s how TypeScript knows that &lt;code&gt;helloWorld&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt; in the above example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970dc4b5ed34cee139d022f1ef1a7253a84f38eb" translate="yes" xml:space="preserve">
          <source>By using babel&amp;rsquo;s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7e951244c6dc6091c5c81158c926700438ad75" translate="yes" xml:space="preserve">
          <source>C# and Java are what we might call &lt;em&gt;mandatory OOP&lt;/em&gt; languages. In these languages, the &lt;em&gt;class&lt;/em&gt; is the basic unit of code organization, and also the basic container of all data &lt;em&gt;and&lt;/em&gt; behavior at runtime. Forcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain &lt;em&gt;needs&lt;/em&gt; to be represented this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ff01863822bd01179d80d30eb7f560237e6bf" translate="yes" xml:space="preserve">
          <source>Cache tagged template objects in modules</source>
          <target state="translated">Objetos de plantilla etiquetados en caché en módulos</target>
        </trans-unit>
        <trans-unit id="3ca09b900f387b256b85a63942148d4d37afb51a" translate="yes" xml:space="preserve">
          <source>Calculator.ts</source>
          <target state="translated">Calculator.ts</target>
        </trans-unit>
        <trans-unit id="401d915f4e82bf6c954f6cd72e5e9f45a0aa5cb6" translate="yes" xml:space="preserve">
          <source>Callback Types</source>
          <target state="translated">Tipos de llamadas</target>
        </trans-unit>
        <trans-unit id="fafd26147b30637f1273073910f82f95e1d409ec" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;showHello&lt;/code&gt; calls &lt;code&gt;sayHello&lt;/code&gt; to change the paragraph&amp;rsquo;s text. Now change your gulpfile to the following:</source>
          <target state="translated">Llamar a &lt;code&gt;showHello&lt;/code&gt; llama a &lt;code&gt;sayHello&lt;/code&gt; para cambiar el texto del p&amp;aacute;rrafo. Ahora cambie su archivo gulp a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b5a615e5088a07823ba43f480f4662c6c1a80354" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;define(...)&lt;/code&gt;</source>
          <target state="translated">Llamadas para &lt;code&gt;define(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54ab62e91bddb3f6354c13e8b487593b38248ac3" translate="yes" xml:space="preserve">
          <source>Can be used in a non-module file &lt;code&gt;global-script.ts&lt;/code&gt;:</source>
          <target state="translated">Se puede utilizar en un archivo &lt;code&gt;global-script.ts&lt;/code&gt; que no es de m&amp;oacute;dulo :</target>
        </trans-unit>
        <trans-unit id="4380ba68d466c9670378cbd5fc0514cb1373ac15" translate="yes" xml:space="preserve">
          <source>Case clause fall-throughs</source>
          <target state="translated">Caída de la cláusula del caso</target>
        </trans-unit>
        <trans-unit id="e7500c883cdd17fa4172ea83911ebf91a32625de" translate="yes" xml:space="preserve">
          <source>Casts</source>
          <target state="translated">Casts</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="3b3bc5f42ea5021b780ab4b12ba77a349aaacc40" translate="yes" xml:space="preserve">
          <source>Caveats for Project References</source>
          <target state="translated">Advertencias para las referencias del proyecto</target>
        </trans-unit>
        <trans-unit id="1c2ce6c0623a19e14dbf0dfa2aff6c6b8a60ed59" translate="yes" xml:space="preserve">
          <source>Certain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add &lt;code&gt;esnext.bigint&lt;/code&gt; to the &lt;code&gt;lib&lt;/code&gt; setting in your compiler options.</source>
          <target state="translated">Ciertos destinos pueden incluir un objeto de tiempo de ejecuci&amp;oacute;n polyfill o similar a BigInt. Para esos fines, es posible que desee agregar &lt;code&gt;esnext.bigint&lt;/code&gt; a la configuraci&amp;oacute;n de &lt;code&gt;lib&lt;/code&gt; en las opciones del compilador.</target>
        </trans-unit>
        <trans-unit id="0d793fe93a13b689ec59340423e9412ead64313c" translate="yes" xml:space="preserve">
          <source>Changes include:</source>
          <target state="translated">Los cambios incluyen:</target>
        </trans-unit>
        <trans-unit id="b2f9c51be50e36d425334b6ef56e24f1966fdfc5" translate="yes" xml:space="preserve">
          <source>Changes the function called in &lt;code&gt;.js&lt;/code&gt; files when compiling JSX Elements using the classic JSX runtime. The most common change is to use &lt;code&gt;&quot;h&quot;&lt;/code&gt; or &lt;code&gt;&quot;preact.h&quot;&lt;/code&gt; instead of the default &lt;code&gt;&quot;React.createElement&quot;&lt;/code&gt; if using &lt;code&gt;preact&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e20420d40f382739b91cf88de0439e6594790f" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;@types/React&lt;/code&gt;</source>
          <target state="translated">Cambios en &lt;code&gt;@types/React&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de22ad0ca9b556e61bbb70c5ec83a398c3b619a4" translate="yes" xml:space="preserve">
          <source>Changing &lt;code&gt;module&lt;/code&gt; affects &lt;a href=&quot;#moduleResolution&quot;&gt;&lt;code&gt;moduleResolution&lt;/code&gt;&lt;/a&gt; which &lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;also has a reference page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dba2ca91863c573a72dfc7f990cbc67e554c68" translate="yes" xml:space="preserve">
          <source>Changing &lt;code&gt;target&lt;/code&gt; also changes the default value of &lt;a href=&quot;#lib&quot;&gt;&lt;code&gt;lib&lt;/code&gt;&lt;/a&gt;. You may &amp;ldquo;mix and match&amp;rdquo; &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; settings as desired, but you could just set &lt;code&gt;target&lt;/code&gt; for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8221b7b528304e76abf18d987bda46c6ee653964" translate="yes" xml:space="preserve">
          <source>Changing just the &lt;em&gt;internals&lt;/em&gt; in the implementation files required &lt;em&gt;typechecking&lt;/em&gt; the tests again, even though this wouldn&amp;rsquo;t ever cause new errors</source>
          <target state="translated">Cambiar solo los &lt;em&gt;componentes &lt;/em&gt;&lt;em&gt;internos&lt;/em&gt; en los archivos de implementaci&amp;oacute;n requer&amp;iacute;a &lt;em&gt;volver a revisar&lt;/em&gt; las pruebas, aunque esto nunca causar&amp;iacute;a nuevos errores</target>
        </trans-unit>
        <trans-unit id="e5d9c66f05e816b7f1607245dc26fd6d3d736699" translate="yes" xml:space="preserve">
          <source>Changing just the tests required typechecking the implementation again, even if nothing changed</source>
          <target state="translated">Cambiar sólo las pruebas requería revisar la implementación de nuevo,incluso si nada cambiaba.</target>
        </trans-unit>
        <trans-unit id="1dc59cc2161e54b7687bb52a2c3f693c96a5e443" translate="yes" xml:space="preserve">
          <source>Charset - &lt;code&gt;charset&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd93b75e5598d54991c74a1d1b0a5f56438c081" translate="yes" xml:space="preserve">
          <source>Check JS - &lt;code&gt;checkJs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d270f4e0779e7abe44cf1c7ade9171d4da1e226" translate="yes" xml:space="preserve">
          <source>Checks for, or usage of, module loaders like &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">Comprobaciones o uso de cargadores de m&amp;oacute;dulos como &lt;code&gt;require&lt;/code&gt; o &lt;code&gt;define&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9de74e418fac1f9142ff12fe9c9f76d1ed611d6" translate="yes" xml:space="preserve">
          <source>Children Type Checking</source>
          <target state="translated">Comprobación del tipo de niños</target>
        </trans-unit>
        <trans-unit id="2afdd953eb19ed2481028f5c1801be583a951e01" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;File&lt;/strong&gt;</source>
          <target state="translated">Elija &lt;strong&gt;Archivo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0d9877ea63ee92b17d066ea8709fa9a3bb445" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;New Project&lt;/strong&gt; (Ctrl + Shift + N)</source>
          <target state="translated">Elija &lt;strong&gt;Nuevo proyecto&lt;/strong&gt; (Ctrl + Shift + N)</target>
        </trans-unit>
        <trans-unit id="1fd5281fc9dbfe31531daf20b8c332f350b4edfb" translate="yes" xml:space="preserve">
          <source>Choosing a value of &amp;ldquo;insert&amp;rdquo; or &amp;ldquo;remove&amp;rdquo; also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of &amp;ldquo;ignore&amp;rdquo; makes generated code match the semicolon preference detected in the current file.</source>
          <target state="translated">La elecci&amp;oacute;n de un valor de &quot;insertar&quot; o &quot;eliminar&quot; tambi&amp;eacute;n afecta el formato de las importaciones autom&amp;aacute;ticas, los tipos extra&amp;iacute;dos y otro c&amp;oacute;digo generado proporcionado por los servicios de TypeScript. Dejar la configuraci&amp;oacute;n en su valor predeterminado de &quot;ignorar&quot; hace que el c&amp;oacute;digo generado coincida con la preferencia de punto y coma detectada en el archivo actual.</target>
        </trans-unit>
        <trans-unit id="78bc86498e55d8a5d31b0d503b4da787d8e95ab6" translate="yes" xml:space="preserve">
          <source>Circularity between configuration files is not allowed.</source>
          <target state="translated">No se permite la circularidad entre los archivos de configuración.</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="c0951e6f10fd3da585b65324801b21d429796cf4" translate="yes" xml:space="preserve">
          <source>Class Component</source>
          <target state="translated">Componente de la clase</target>
        </trans-unit>
        <trans-unit id="ed903b055db990734f20c5294ee8b8fe9164b593" translate="yes" xml:space="preserve">
          <source>Class Decorators</source>
          <target state="translated">Decoradores de la clase</target>
        </trans-unit>
        <trans-unit id="114686c97766613a29d4825a44b3554d85c66bb1" translate="yes" xml:space="preserve">
          <source>Class Field Mitigations</source>
          <target state="translated">Mitigaciones de campo de clase</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">Tipos de clase</target>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes" xml:space="preserve">
          <source>Class expressions</source>
          <target state="translated">Expresiones de clase</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="a84d6a1a8b04f068d6de8792f2128d31b00ac8e8" translate="yes" xml:space="preserve">
          <source>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</source>
          <target state="translated">Las declaraciones de clases y funciones pueden autorizarse directamente como exportaciones predeterminadas.Los nombres de las declaraciones de clases y funciones de exportación por defecto son opcionales.</target>
        </trans-unit>
        <trans-unit id="d45b7fb00541f6a8767f301189945313b46aa644" translate="yes" xml:space="preserve">
          <source>Classes are namespaces in &lt;code&gt;.js&lt;/code&gt; files. This can be used to nest classes, for example:</source>
          <target state="translated">Las clases son espacios de nombres en archivos &lt;code&gt;.js&lt;/code&gt; . Esto se puede usar para anidar clases, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="521ef0588bf6981159e4b30671900a891602e592" translate="yes" xml:space="preserve">
          <source>Classes can be declared as ES6 classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b983fc3a70e6b758f289e140144ef55d05f6582" translate="yes" xml:space="preserve">
          <source>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</source>
          <target state="translated">Las clases funcionan de manera similar a los tipos literales de objetos e interfaces con una excepción:tienen un tipo estático y un tipo de instancia.Cuando se comparan dos objetos de un tipo de clase,sólo se comparan los miembros de la instancia.Los miembros estáticos y los constructores no afectan a la compatibilidad.</target>
        </trans-unit>
        <trans-unit id="eb3e378460b98ee4b6e31c2d2b4b1e98ab972d3c" translate="yes" xml:space="preserve">
          <source>Classes, functions, and object literals are namespaces</source>
          <target state="translated">Las clases,funciones y literales de objetos son espacios de nombres</target>
        </trans-unit>
        <trans-unit id="130cd7fe33343e419f107596f21d6c9f9d976849" translate="yes" xml:space="preserve">
          <source>Classic</source>
          <target state="translated">Classic</target>
        </trans-unit>
        <trans-unit id="f6c75e6aaeff53723e2a1e6793923cd37ed98551" translate="yes" xml:space="preserve">
          <source>Cleaner output in &lt;code&gt;--watch&lt;/code&gt; mode</source>
          <target state="translated">Salida m&amp;aacute;s limpia en modo &lt;code&gt;--watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94996b319b013869345bb5ec0b653754bbab2bb2" translate="yes" xml:space="preserve">
          <source>Co-learning JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f49daf62d5f581a04097acf72f7a587d200db2" translate="yes" xml:space="preserve">
          <source>Code Generation for Modules</source>
          <target state="translated">Generación de código para los módulos</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes" xml:space="preserve">
          <source>Code generation</source>
          <target state="translated">Generación de código</target>
        </trans-unit>
        <trans-unit id="87b36e1c52e858cb2c770a584f49971497c4d447" translate="yes" xml:space="preserve">
          <source>Code that&amp;rsquo;s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</source>
          <target state="translated">El c&amp;oacute;digo que se ve afectado por el cambio de campos de clase puede solucionar el problema convirtiendo los inicializadores de campo en asignaciones en los cuerpos del constructor.</target>
        </trans-unit>
        <trans-unit id="8d618575aa117c6b80915c9311258252626feb94" translate="yes" xml:space="preserve">
          <source>Colorization of JSX code in VS 2015</source>
          <target state="translated">Coloración del código JSX en VS 2015</target>
        </trans-unit>
        <trans-unit id="fb53519c43ebafe25dcbd0027128dc98a8b8ab12" translate="yes" xml:space="preserve">
          <source>Comma-separated list of strings</source>
          <target state="translated">Lista de cuerdas separadas por comas</target>
        </trans-unit>
        <trans-unit id="59b0754344014d9d6347724f39bcacbaf47c2e7d" translate="yes" xml:space="preserve">
          <source>Command Line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a06fdc1de7c2a221587196452cc0c3db471910" translate="yes" xml:space="preserve">
          <source>Common CommonJS Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f955b144e5934e2a13c8a6e25bf74ab9af19e8c" translate="yes" xml:space="preserve">
          <source>Common Questions</source>
          <target state="translated">Preguntas comunes</target>
        </trans-unit>
        <trans-unit id="095e91de81638c9fb4d8559305b99b20bbe45f1b" translate="yes" xml:space="preserve">
          <source>CommonJS / Node SimpleModule.js</source>
          <target state="translated">CommonJS/Nodo SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="bda542b3ab64c958c7a9092f48843c2d942bdc34" translate="yes" xml:space="preserve">
          <source>CommonJS modules are supported</source>
          <target state="translated">Los módulos de CommonJS están soportados</target>
        </trans-unit>
        <trans-unit id="49c7d204d4bf5859f005b121118317373b38a4db" translate="yes" xml:space="preserve">
          <source>CommonJS/Node.js-style imports of the form &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</source>
          <target state="translated">Importaciones al estilo CommonJS / Node.js de la forma &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721f3299d51791dbb75d2bfe7f0acc090e15e4e0" translate="yes" xml:space="preserve">
          <source>Comparing JavaScript to an example DTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf7acb84f79d901460975c5fdc7458a15a93f19" translate="yes" xml:space="preserve">
          <source>Comparing two functions</source>
          <target state="translated">Comparando dos funciones</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="d6b8ebf2c598d92ddec51164751b02621841cd23" translate="yes" xml:space="preserve">
          <source>Compile a project given a valid configuration file.</source>
          <target state="translated">Compilar un proyecto con un archivo de configuración válido.</target>
        </trans-unit>
        <trans-unit id="bc74f0ec68df0086c27ed702abf06db93a06c411" translate="yes" xml:space="preserve">
          <source>Compiled with:</source>
          <target state="translated">Compilado con:</target>
        </trans-unit>
        <trans-unit id="34dce96703c9facc673665ace0f6e41d2baf12d1" translate="yes" xml:space="preserve">
          <source>Compiler Option</source>
          <target state="translated">Opción del compilador</target>
        </trans-unit>
        <trans-unit id="f05a88eb5583088cfb5f3af23ae435a9c43d6850" translate="yes" xml:space="preserve">
          <source>Compiler Options</source>
          <target state="translated">Opciones del compilador</target>
        </trans-unit>
        <trans-unit id="819847cb3aeaa240fbb932fa94d563cc19eec903" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild</source>
          <target state="translated">Opciones del compilador en MSBuild</target>
        </trans-unit>
        <trans-unit id="e90bb90e5e03ec7e90a57bd240d9219ac649a200" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: Mappings</source>
          <target state="translated">Opciones del compilador en MSBuild:Mapeos</target>
        </trans-unit>
        <trans-unit id="4e625c081c57011a6a742bfd97d6371d46e1c009" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: ToolsVersion</source>
          <target state="translated">Opciones del compilador en MSBuild:ToolsVersion</target>
        </trans-unit>
        <trans-unit id="c90111a236cc10e2295d1a4cb78fc2a7200d0283" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: TypeScriptCompileBlocked</source>
          <target state="translated">Opciones del compilador en MSBuild:TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="83eca665c1a302a482766697ff41e3f51468ae7d" translate="yes" xml:space="preserve">
          <source>Compiler configuration reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630ca760deb5ffc09b9902125668d2e2290de0ec" translate="yes" xml:space="preserve">
          <source>Compiler options can be specified using MSBuild properties within an MSBuild project.</source>
          <target state="translated">Las opciones del compilador pueden ser especificadas usando las propiedades de MSBuild dentro de un proyecto MSBuild.</target>
        </trans-unit>
        <trans-unit id="93e477a43886859b1bbfebb3d31cc0e1afe3973d" translate="yes" xml:space="preserve">
          <source>Compiler options specified on the command line override those specified in the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">Las opciones del compilador especificadas en la l&amp;iacute;nea de comandos anulan las especificadas en el archivo &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c791e1a441b19fea45de958fa56f9b5653c4878" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using compiler flags in TypeScript 3.8+, and environment variables before that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121ebc6937d17411ed69a6c37b96c6c30daba6d8" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using the environment variables.</source>
          <target state="translated">El compilador soporta la configuración de cómo ver los archivos y directorios usando las variables de entorno.</target>
        </trans-unit>
        <trans-unit id="25e701e70295cdeed377c2a897dc9eb65d813980" translate="yes" xml:space="preserve">
          <source>Compiles to exactly:</source>
          <target state="translated">Compila exactamente:</target>
        </trans-unit>
        <trans-unit id="e358939ee8802319ad1e9d8583fade153122cd2d" translate="yes" xml:space="preserve">
          <source>Compiling &lt;code&gt;app.ts&lt;/code&gt; using &lt;code&gt;--noResolve&lt;/code&gt; should result in:</source>
          <target state="translated">Compilar &lt;code&gt;app.ts&lt;/code&gt; usando &lt;code&gt;--noResolve&lt;/code&gt; deber&amp;iacute;a resultar en:</target>
        </trans-unit>
        <trans-unit id="f9f6b87f27d7b70599485207ca9ad09ebb893c0b" translate="yes" xml:space="preserve">
          <source>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</source>
          <target state="translated">Compilar y ejecutar la salida debería resultar en el comportamiento correcto en un motor ES3/ES5.</target>
        </trans-unit>
        <trans-unit id="fc95d4c78f2f929f78993906b2bc165b4228618b" translate="yes" xml:space="preserve">
          <source>Compiling with &lt;code&gt;sourceMap&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; creates the following JavaScript file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ad9c5360eb345b6e3abac1b97c83060143ba82" translate="yes" xml:space="preserve">
          <source>Compiling your code</source>
          <target state="translated">Compilar su código</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
