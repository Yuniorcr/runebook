<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="7ac670e2b8d400f3afe02add218c2edb8400544b" translate="yes" xml:space="preserve">
          <source>Run the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes" xml:space="preserve">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href=&quot;configuring-watch&quot;&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target state="translated">Ejecute el compilador en modo reloj. Observe los archivos de entrada y active la recopilaci&amp;oacute;n de cambios. La implementaci&amp;oacute;n de los archivos y directorios de observaci&amp;oacute;n se puede configurar mediante la variable de entorno. Consulte &lt;a href=&quot;configuring-watch&quot;&gt;configuraci&amp;oacute;n del reloj&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes" xml:space="preserve">
          <source>Run the project</source>
          <target state="translated">Dirigir el proyecto</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target state="translated">Ejecutar &lt;code&gt;tsc --build&lt;/code&gt; ( &lt;code&gt;tsc -b&lt;/code&gt; para abreviar) har&amp;aacute; lo siguiente:</target>
        </trans-unit>
        <trans-unit id="e7c0aa1e021efe3fc4486d609d25246d6751785f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc&lt;/code&gt; locally will compile the closest project defined by a &lt;code&gt;tsconfig.json&lt;/code&gt;, you can compile a set of TypeScript files by passing in a glob of files you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a53f5887ae342b4a1cd086cadce904823bf70ae" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc&lt;/code&gt; with these settings moves the files into the specified &lt;code&gt;dist&lt;/code&gt; folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes" xml:space="preserve">
          <source>Running your TypeScript web app</source>
          <target state="translated">Ejecutando tu aplicación web de TypeScript</target>
        </trans-unit>
        <trans-unit id="2ccf2f0429535a5298f720be36cb9ea9f08e1bc4" translate="yes" xml:space="preserve">
          <source>Runtime Behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target state="translated">Muestra:Carga del módulo dinámico en System.js</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target state="translated">Muestra:Módulo dinámico Cargando en require.js</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes" xml:space="preserve">
          <source>Schema can be found at: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target state="translated">El esquema se puede encontrar en: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">Reglas de alcance</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes" xml:space="preserve">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target state="translated">Busque &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes" xml:space="preserve">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target state="translated">Busque &lt;strong&gt;.NET Core&lt;/strong&gt; en la barra de b&amp;uacute;squeda del proyecto</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes" xml:space="preserve">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target state="translated">En segundo lugar, compile sus archivos usando &lt;code&gt;--importHelpers&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bcf02982afce00389878abc0de341f295e01470c" translate="yes" xml:space="preserve">
          <source>Second, the TypeScript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes" xml:space="preserve">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">En segundo lugar, el compilador de TypeScript no permite la propagaci&amp;oacute;n de par&amp;aacute;metros de tipo de funciones gen&amp;eacute;ricas. Esa caracter&amp;iacute;stica se espera en futuras versiones del idioma.</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes" xml:space="preserve">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target state="translated">En segundo lugar, el uso de campos de clase para especializar propiedades de clases base tampoco funcionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes" xml:space="preserve">
          <source>Sections</source>
          <target state="translated">Sections</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../project-references&quot;&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target state="translated">Consulte la &lt;a href=&quot;../project-references&quot;&gt;p&amp;aacute;gina del manual de referencias de proyectos&lt;/a&gt; para obtener m&amp;aacute;s documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target state="translated">Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Resoluci&amp;oacute;n del m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target state="translated">Consulte el &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;n&amp;uacute;mero 1256&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Consulte la &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;documentaci&amp;oacute;n de verificaci&amp;oacute;n de tipos de archivos JavaScript&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target state="translated">Vea &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;m&amp;aacute;s detalles sobre ts-loader aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aaee337bc1d3ed089284b88a7fb251a773a6ed9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.typescriptlang.org/5bc00d38ab2cd134cf9690e7a4343bf5/module-function.d.ts.md&quot;&gt;Module: Functions&lt;/a&gt; for details of how that works, and the &lt;a href=&quot;../../modules&quot;&gt;Modules reference&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target state="translated">Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d47a58ff1cef92314017a04dfa6b2492cbc2ccce" translate="yes" xml:space="preserve">
          <source>See how both lists change. &lt;code&gt;children&lt;/code&gt; now only contains the &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element, and the &lt;code&gt;childNodes&lt;/code&gt; contains a &lt;code&gt;text&lt;/code&gt; node rather than two &lt;code&gt;p&lt;/code&gt; nodes. The &lt;code&gt;text&lt;/code&gt; part of the &lt;code&gt;NodeList&lt;/code&gt; is the literal &lt;code&gt;Node&lt;/code&gt; containing the text &lt;code&gt;TypeScript!&lt;/code&gt;. The &lt;code&gt;children&lt;/code&gt; list does not contain this &lt;code&gt;Node&lt;/code&gt; because it is not considered an &lt;code&gt;HTMLElement&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd93541328dd959138d1a2b853dfd1eceeacb71d" translate="yes" xml:space="preserve">
          <source>See main content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">Consulte la &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;p&amp;aacute;gina wiki tsconfig.json&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="6b065cbab34dec1a1806260f05403e1952398509" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about ES Modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about TypeScript namespaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target state="translated">Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;modules&quot;&gt;M&amp;oacute;dulos&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los m&amp;oacute;dulos. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;namespaces&quot;&gt;espacios de nombres&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los espacios de nombres.</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes" xml:space="preserve">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target state="translated">Vea la página wiki [[JSX]]para más información sobre el uso de JSX en TypeScript.</target>
        </trans-unit>
        <trans-unit id="2260a25895164f2770eb15c55e0e16389d6b104b" translate="yes" xml:space="preserve">
          <source>See where your usage of the module breaks, and start to fill out the index.d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target state="translated">Seleccione &lt;strong&gt;Aplicaci&amp;oacute;n web ASP.NET Core&lt;/strong&gt; y presione el bot&amp;oacute;n &lt;em&gt;Siguiente&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes" xml:space="preserve">
          <source>Semicolon Formatter Option</source>
          <target state="translated">Opción de Formato de Semicolon</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes" xml:space="preserve">
          <source>Semicolon-Aware Code Edits</source>
          <target state="translated">Edición de código con punto y coma</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes" xml:space="preserve">
          <source>Sequentially Added Properties</source>
          <target state="translated">Propiedades añadidas secuencialmente</target>
        </trans-unit>
        <trans-unit id="1676c891c1accface87dfecc3ee263cbd0629e6e" translate="yes" xml:space="preserve">
          <source>Set to false to disable warnings about unused labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes" xml:space="preserve">
          <source>Set up the build</source>
          <target state="translated">Prepara la construcción</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes" xml:space="preserve">
          <source>Set up the server</source>
          <target state="translated">Configurar el servidor</target>
        </trans-unit>
        <trans-unit id="c027e79283f2d26edaa3eee382f8854c8daded5d" translate="yes" xml:space="preserve">
          <source>Sets the module system for the program. See the &lt;a href=&quot;docs/handbook/modules&quot;&gt;Modules&lt;/a&gt; reference page for more information. You very likely want &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; for node projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">La configuraci&amp;oacute;n de &lt;code&gt;baseUrl&lt;/code&gt; informa al compilador d&amp;oacute;nde encontrar m&amp;oacute;dulos. Se supone que todas las importaciones de m&amp;oacute;dulos con nombres no relativos son relativas a &lt;code&gt;baseUrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2b91c337f2f0946708a5154da2e0832a39c7b5b" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;strictNullChecks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; will raise an error that you have not made a guarantee that the &lt;code&gt;loggedInUser&lt;/code&gt; exists before trying to use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes" xml:space="preserve">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target state="translated">Establecer una propiedad de nivel superior &lt;code&gt;compileOnSave&lt;/code&gt; env&amp;iacute;a se&amp;ntilde;ales al IDE para generar todos los archivos para un tsconfig.json dado al guardar.</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild projects&lt;/a&gt;.</source>
          <target state="translated">Configuraci&amp;oacute;n de las opciones del compilador en &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;proyectos de MSBuild&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">Configuraci&amp;oacute;n de las opciones del compilador en archivos &lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes" xml:space="preserve">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target state="translated">Establecer el nuevo indicador del compilador &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indica que el cargador del m&amp;oacute;dulo realiza alg&amp;uacute;n tipo de creaci&amp;oacute;n de miembros de importaci&amp;oacute;n predeterminados sint&amp;eacute;ticos no indicados en los .ts o .d.ts importados. El compilador inferir&amp;aacute; la existencia de una exportaci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; que tiene la forma de todo el m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes" xml:space="preserve">
          <source>Setting up your Directories</source>
          <target state="translated">Preparando sus directorios...</target>
        </trans-unit>
        <trans-unit id="62cd1351e8c4eaed3d7e33f00093319c1143b315" translate="yes" xml:space="preserve">
          <source>Setting up your Project to emit .d.ts files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes" xml:space="preserve">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target state="translated">Por lo &lt;em&gt;general, se&lt;/em&gt; debe evitar el sombreado en aras de escribir un c&amp;oacute;digo m&amp;aacute;s claro. Si bien hay algunos escenarios en los que puede ser apropiado aprovecharlo, debe usar su mejor criterio.</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes" xml:space="preserve">
          <source>Shorthand ambient module declarations</source>
          <target state="translated">Declaraciones abreviadas del módulo ambiental</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes" xml:space="preserve">
          <source>Shorthand ambient modules</source>
          <target state="translated">Módulos ambientales de taquigrafía</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes" xml:space="preserve">
          <source>Show diagnostic information.</source>
          <target state="translated">Mostrar información de diagnóstico.</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes" xml:space="preserve">
          <source>Show verbose diagnostic information</source>
          <target state="translated">Mostrar información de diagnóstico verbosa</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes" xml:space="preserve">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target state="translated">Similar a una directiva &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; , que sirve como declaraci&amp;oacute;n de &lt;em&gt;dependencia&lt;/em&gt; , una directiva &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; declara una dependencia en un paquete.</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes" xml:space="preserve">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target state="translated">De manera similar a la dispersión de la matriz,la dispersión de un objeto puede ser útil para obtener una copia superficial:</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes" xml:space="preserve">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">Al igual que los tipos de unión e intersección,los tipos condicionales no pueden referirse a sí mismos de forma recursiva.Por ejemplo,lo siguiente es un error.</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes" xml:space="preserve">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; or &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; are not allowed.</source>
          <target state="translated">De manera similar, una importaci&amp;oacute;n predeterminada (es decir, &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt; ) para un m&amp;oacute;dulo CommonJS / AMD / UMD como equivalente a &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt; .La mayor&amp;iacute;a de los m&amp;oacute;dulos CommonJS / AMD / UMD disponibles en la actualidad no tienen una exportaci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; , lo que hace que este patr&amp;oacute;n de importaci&amp;oacute;n sea pr&amp;aacute;cticamente inutilizable para importar m&amp;oacute;dulos que no son de ES (es decir, CommonJS / AMD / UMD). Por ejemplo, no se permite &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; ni &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes" xml:space="preserve">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target state="translated">De manera similar a c&amp;oacute;mo podemos usar interfaces para describir tipos de funciones, tambi&amp;eacute;n podemos describir tipos en los que podemos &amp;ldquo;indexar&amp;rdquo; como &lt;code&gt;a[10]&lt;/code&gt; o &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt; . Los tipos indexables tienen una &lt;em&gt;firma de &amp;iacute;ndice&lt;/em&gt; que describe los tipos que podemos usar para indexar en el objeto, junto con los tipos de retorno correspondientes al indexar. Tomemos un ejemplo:</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes" xml:space="preserve">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target state="translated">Al igual que las interfaces,los espacios de nombres del mismo nombre también fusionarán sus miembros.Dado que los espacios de nombres crean tanto un espacio de nombres como un valor,necesitamos entender cómo se fusionan ambos.</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">De manera similar, &lt;code&gt;--target ES2017&lt;/code&gt; le indicar&amp;aacute; al compilador que no transforme caracter&amp;iacute;sticas espec&amp;iacute;ficas de ES2017 como &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes" xml:space="preserve">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">De manera similar, una importaci&amp;oacute;n no relativa seguir&amp;aacute; la l&amp;oacute;gica de resoluci&amp;oacute;n de Node.js, primero buscando un archivo y luego buscando una carpeta aplicable. Entonces, &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; en el archivo fuente &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; dar&amp;iacute;a como resultado las siguientes b&amp;uacute;squedas:</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes" xml:space="preserve">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target state="translated">Análogamente,la desestructuración puede utilizarse en las declaraciones de los parámetros de función:</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes" xml:space="preserve">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target state="translated">Del mismo modo,los espacios de nombres pueden utilizarse para extender enums con miembros estáticos:</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes" xml:space="preserve">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target state="translated">De manera similar, el alcance global se puede aumentar a partir de m&amp;oacute;dulos utilizando una &lt;code&gt;declare global&lt;/code&gt; declaraciones:</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes" xml:space="preserve">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target state="translated">Del mismo modo,intenta eliminar todos los argumentos de la llamada de bienvenida.TypeScript te hará saber que has llamado a esta función con un número inesperado de parámetros.En ambos casos,TypeScript puede ofrecer un análisis estático basado tanto en la estructura de su código,como en las anotaciones de tipo que usted proporciona.</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes" xml:space="preserve">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">Del mismo modo, puede fusionar varios objetos diferentes. En el siguiente ejemplo, &lt;code&gt;merged&lt;/code&gt; tendr&amp;aacute; propiedades de &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; y &lt;code&gt;baz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes" xml:space="preserve">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target state="translated">Del mismo modo, se podr&amp;iacute;a escribir un tipo de utilidad como &lt;code&gt;Writable&lt;/code&gt; mapeado tipo que se despoja de &lt;code&gt;readonly&lt;/code&gt; -ness, y que convertir&amp;iacute;a &lt;code&gt;readonly&lt;/code&gt; contenedores de matriz de vuelta a sus equivalentes mutables.</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes" xml:space="preserve">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target state="translated">Combinaciones simples:Un nombre,múltiples significados</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">Ejemplo simple</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes" xml:space="preserve">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes" xml:space="preserve">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target state="translated">Gesti&amp;oacute;n de tipos de &lt;code&gt;props&lt;/code&gt; simplificada en React</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target state="translated">Dado que &lt;code&gt;keyof&lt;/code&gt; ahora refleja la presencia de una firma de &amp;iacute;ndice num&amp;eacute;rico al incluir el &lt;code&gt;number&lt;/code&gt; tipo en el tipo de clave, los tipos mapeados como &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; funcionan correctamente cuando se aplican a tipos de objeto con firmas de &amp;iacute;ndice num&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes" xml:space="preserve">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target state="translated">Dado que JavaScript termina autom&amp;aacute;ticamente la declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; al final de la l&amp;iacute;nea, el objeto literal se convierte en un bloque.</target>
        </trans-unit>
        <trans-unit id="e7f102f64416cbc39d1e3262772e0a216eb7ce37" translate="yes" xml:space="preserve">
          <source>Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes" xml:space="preserve">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target state="translated">Dado que las declaraciones en un archivo pueden afectar la verificaci&amp;oacute;n de tipos en otros archivos, es posible que algunos errores no se detecten cuando se especifica &lt;code&gt;--skipLibCheck&lt;/code&gt; . Por ejemplo, si un archivo de no declaraci&amp;oacute;n aumenta un tipo declarado en un archivo de declaraci&amp;oacute;n, pueden producirse errores que solo se informan cuando se comprueba el archivo de declaraci&amp;oacute;n. Sin embargo, en la pr&amp;aacute;ctica estas situaciones son raras.</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes" xml:space="preserve">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target state="translated">Dado que los tipos que aceptan valores NULL se implementan con una uni&amp;oacute;n, debe usar un protector de tipos para deshacerse del &lt;code&gt;null&lt;/code&gt; . Afortunadamente, este es el mismo c&amp;oacute;digo que escribir&amp;iacute;as en JavaScript:</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes" xml:space="preserve">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target state="translated">Dado que los rangos tienen el potencial de superponerse, determinar qu&amp;eacute; redireccionamiento se aplica es espec&amp;iacute;fico del pedido. Eso significa que en el ejemplo anterior, aunque tanto los comparadores &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; como los &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; admiten TypeScript 3.2 y superior, invertir el orden podr&amp;iacute;a tener un comportamiento diferente, por lo que el ejemplo anterior no ser&amp;iacute;a equivalente al siguiente.</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes" xml:space="preserve">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target state="translated">Dado que la sintaxis anterior no se puede usar en archivos &lt;code&gt;.tsx&lt;/code&gt; , se debe usar un operador de aserci&amp;oacute;n de tipo alternativo: &lt;code&gt;as&lt;/code&gt; . El ejemplo se puede reescribir f&amp;aacute;cilmente con el operador &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes" xml:space="preserve">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target state="translated">Dado que la clase usa &lt;code&gt;this&lt;/code&gt; tipos, puede extenderla y la nueva clase puede usar los m&amp;eacute;todos antiguos sin cambios.</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes" xml:space="preserve">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target state="translated">Dado que las comprobaciones m&amp;aacute;s estrictas pueden descubrir errores no &lt;code&gt;--strict&lt;/code&gt; previamente, este es un cambio radical en el modo estricto .</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes" xml:space="preserve">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Dado que no existe una sintaxis natural para especificar par&amp;aacute;metros de tipo gen&amp;eacute;rico en Javascript, un par&amp;aacute;metro de tipo no especificado tiene como valor predeterminado &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes" xml:space="preserve">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target state="translated">Dado que no hay forma de especificar la opcionalidad en los par&amp;aacute;metros en Javascript anterior a ES2015, todos los par&amp;aacute;metros de funci&amp;oacute;n en el archivo &lt;code&gt;.js&lt;/code&gt; se consideran opcionales. Se permiten llamadas con menos argumentos que el n&amp;uacute;mero declarado de par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes" xml:space="preserve">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target state="translated">Dado que se trata de un cambio radical,es posible que necesite conocer las soluciones alternativas,que son las mismas que las de los controles literales estrictos de los objetos:</target>
        </trans-unit>
        <trans-unit id="29a785f99454f565683fe81e09a33e40c8e76702" translate="yes" xml:space="preserve">
          <source>Single-file transpilers don&amp;rsquo;t know whether &lt;code&gt;someType&lt;/code&gt; produces a value or not, so it&amp;rsquo;s an error to export a name that only refers to a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e13335331cc080e9ba88a13ad1230b8a0576896" translate="yes" xml:space="preserve">
          <source>Skip Default Lib Check - &lt;code&gt;skipDefaultLibCheck&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234395dee2758492ba2797c4d5cd3f566645aff3" translate="yes" xml:space="preserve">
          <source>Skip Lib Check - &lt;code&gt;skipLibCheck&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes" xml:space="preserve">
          <source>Skip type checking of &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;default library declaration files&lt;/a&gt;.</source>
          <target state="translated">Omita la verificaci&amp;oacute;n de tipo de &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;los archivos de declaraci&amp;oacute;n de biblioteca predeterminados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes" xml:space="preserve">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target state="translated">Omitir la verificaci&amp;oacute;n de tipo de todos los archivos de declaraci&amp;oacute;n ( &lt;code&gt;*.d.ts&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d66051d7634cd7ff52bac26aa8397aa830ebea55" translate="yes" xml:space="preserve">
          <source>Skip type checking of declaration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597c64f117d2aa2c1f26f6d20a44dfe498e5769f" translate="yes" xml:space="preserve">
          <source>Smaller samples for different types of libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes" xml:space="preserve">
          <source>Smarter Auto-Import Syntax</source>
          <target state="translated">Sintaxis de autoimportación más inteligente</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes" xml:space="preserve">
          <source>Smarter union type checking</source>
          <target state="translated">Comprobación de tipo de unión más inteligente</target>
        </trans-unit>
        <trans-unit id="4597cc07c4a8e366226dba892e751bcdcaed8c3c" translate="yes" xml:space="preserve">
          <source>So far, the handbook has covered types which are atomic objects. However, as you model more types you find yourself looking for tools which let you compose or combine existing types instead of creating them from scratch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target state="translated">Hasta ahora, hemos utilizado &quot;compatible&quot;, que no es un t&amp;eacute;rmino definido en la especificaci&amp;oacute;n del idioma. En TypeScript, hay dos tipos de compatibilidad: subtipo y asignaci&amp;oacute;n. Estos difieren solo en que la asignaci&amp;oacute;n extiende la compatibilidad de subtipos con las reglas para permitir la asignaci&amp;oacute;n hacia y desde &lt;code&gt;any&lt;/code&gt; , y hacia y desde &lt;code&gt;enum&lt;/code&gt; con los valores num&amp;eacute;ricos correspondientes.</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes" xml:space="preserve">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target state="translated">Entonces, dada la siguiente entrada, el archivo &lt;code&gt;.js&lt;/code&gt; resultante incluir&amp;aacute; una importaci&amp;oacute;n a &lt;code&gt;tslib&lt;/code&gt; y usar&amp;aacute; el ayudante &lt;code&gt;__assign&lt;/code&gt; en lugar de incluirlo.</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes" xml:space="preserve">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">Entonces, en el ejemplo anterior, si estamos importando desde &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; , intentaremos resolver desde &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (y otros rutas) cuando se ejecuta en TypeScript 3.1. Si importamos desde &lt;code&gt;package-name/foo&lt;/code&gt; , intentaremos buscar &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; y &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes" xml:space="preserve">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target state="translated">Entonces, para excluir un archivo de la compilaci&amp;oacute;n, debe excluirlo y &lt;strong&gt;todos los&lt;/strong&gt; archivos que tengan una directiva de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n o &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d182650064f5464ef393db53c7c8e6d35c2c988e" translate="yes" xml:space="preserve">
          <source>Some elements do not exhibit unique properties and so they just return &lt;code&gt;HTMLElement&lt;/code&gt;, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement &lt;code&gt;HTMLElement&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e17d206c518dbadda1af7b806ce18ec461ecfb" translate="yes" xml:space="preserve">
          <source>Some examples of code which does not work when &lt;code&gt;isolatedModules&lt;/code&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes" xml:space="preserve">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">Algunos ejemplos de funciones que &lt;code&gt;never&lt;/code&gt; regresan :</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes" xml:space="preserve">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">Algunos ejemplos de uso de funciones que &lt;code&gt;never&lt;/code&gt; regresan :</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes" xml:space="preserve">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target state="translated">Algunos ejemplos usan la biblioteca &lt;code&gt;reflect-metadata&lt;/code&gt; que agrega un polyfill para una &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;API de metadatos experimental&lt;/a&gt; . Esta biblioteca a&amp;uacute;n no forma parte del est&amp;aacute;ndar ECMAScript (JavaScript). Sin embargo, una vez que los decoradores se adopten oficialmente como parte del est&amp;aacute;ndar ECMAScript, estas extensiones se propondr&amp;aacute;n para su adopci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes" xml:space="preserve">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">Algunos tipos de declaraciones se pueden combinar en varias declaraciones. Por ejemplo, la &lt;code&gt;class C { }&lt;/code&gt; y la &lt;code&gt;interface C { }&lt;/code&gt; pueden coexistir y ambas contribuyen con propiedades a los tipos &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target state="translated">Algunas bibliotecas est&amp;aacute;n dise&amp;ntilde;adas para usarse en muchos cargadores de m&amp;oacute;dulos, o sin carga de m&amp;oacute;dulos (variables globales). Estos se conocen como m&amp;oacute;dulos &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; . Se puede acceder a estas bibliotecas mediante una importaci&amp;oacute;n o una variable global. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; or &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target state="translated">Algunas bibliotecas est&amp;aacute;n dise&amp;ntilde;adas para usarse en muchos cargadores de m&amp;oacute;dulos, o sin carga de m&amp;oacute;dulos (variables globales). Estos se conocen como m&amp;oacute;dulos &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; o &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; . Se puede acceder a estas bibliotecas mediante una importaci&amp;oacute;n o una variable global.</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes" xml:space="preserve">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">Algunas bibliotecas solo funcionan en un entorno de cargador de m&amp;oacute;dulos. Por ejemplo, &lt;code&gt;express&lt;/code&gt; solo funciona en Node.js y debe cargarse usando la funci&amp;oacute;n &lt;code&gt;require&lt;/code&gt; de CommonJS .</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">Algunos cargadores de m&amp;oacute;dulos, como &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; y &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD,&lt;/a&gt; permiten importar contenido que no sea JavaScript. Por lo general, usan un prefijo o sufijo para indicar la sem&amp;aacute;ntica de carga especial. Las declaraciones de m&amp;oacute;dulos comod&amp;iacute;n se pueden utilizar para cubrir estos casos.</target>
        </trans-unit>
        <trans-unit id="b9daed87f8143d8fb1626c2d066b5622304dcdba" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes" xml:space="preserve">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target state="translated">Algunos de los conceptos &amp;uacute;nicos en TypeScript describen la forma de los objetos JavaScript en el nivel de tipo. Un ejemplo que es especialmente exclusivo de TypeScript es el concepto de 'combinaci&amp;oacute;n de declaraciones'. Comprender este concepto le dar&amp;aacute; una ventaja cuando trabaje con JavaScript existente. Tambi&amp;eacute;n abre la puerta a conceptos de abstracci&amp;oacute;n m&amp;aacute;s avanzados.</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes" xml:space="preserve">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target state="translated">Algunas personas encuentran más agradable estéticamente crear un objeto y añadirle propiedades inmediatamente después:</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes" xml:space="preserve">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target state="translated">Algunos plugins añaden o modifican exportaciones de alto nivel en módulos existentes.Aunque esto es legal en CommonJS y otros cargadores,los módulos ES6 se consideran inmutables y este patrón no será posible.Debido a que TypeScript es agnóstico a los cargadores,no se aplica esta política en tiempo de compilación,pero los desarrolladores que pretendan hacer la transición a un cargador de módulos ES6 deben ser conscientes de ello.</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes" xml:space="preserve">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target state="translated">Algunas propiedades solo deber&amp;iacute;an ser modificables cuando se crea un objeto por primera vez. Puede especificar esto poniendo &lt;code&gt;readonly&lt;/code&gt; antes del nombre de la propiedad:</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes" xml:space="preserve">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target state="translated">Algunos lectores podr&amp;iacute;an dar una doble vuelta a este ejemplo. La variable &lt;code&gt;x&lt;/code&gt; se declar&amp;oacute; &lt;em&gt;dentro del bloque &lt;code&gt;if&lt;/code&gt; &lt;/em&gt; y, sin embargo, pudimos acceder a ella desde fuera de ese bloque. Esto se debe a que las declaraciones &lt;code&gt;var&lt;/code&gt; son accesibles en cualquier lugar dentro de su funci&amp;oacute;n contenedora, m&amp;oacute;dulo, espacio de nombres o alcance global, todo lo cual veremos m&amp;aacute;s adelante, independientemente del bloque contenedor. Algunas personas llaman a esto &lt;em&gt; &lt;code&gt;var&lt;/code&gt; -scoping&lt;/em&gt; o &lt;em&gt;function-scoping&lt;/em&gt; . Los par&amp;aacute;metros tambi&amp;eacute;n tienen un &amp;aacute;mbito de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes" xml:space="preserve">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target state="translated">Algunos equipos han configurado flujos de trabajo basados ​​en msbuild en los que los archivos tsconfig tienen el mismo orden de gr&amp;aacute;ficos &lt;em&gt;impl&amp;iacute;cito&lt;/em&gt; que los proyectos administrados con los que est&amp;aacute;n emparejados. Si su soluci&amp;oacute;n es as&amp;iacute;, puede continuar usando &lt;code&gt;msbuild&lt;/code&gt; con &lt;code&gt;tsc -p&lt;/code&gt; junto con las referencias del proyecto; estos son completamente interoperables.</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes" xml:space="preserve">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target state="translated">Algo a tener en cuenta es que a&amp;uacute;n puede &lt;em&gt;capturar&lt;/em&gt; una variable de &amp;aacute;mbito de bloque antes de que se declare. El &amp;uacute;nico inconveniente es que es ilegal llamar a esa funci&amp;oacute;n antes de la declaraci&amp;oacute;n. Si tiene como objetivo ES2015, un tiempo de ejecuci&amp;oacute;n moderno arrojar&amp;aacute; un error; sin embargo, en este momento TypeScript es permisivo y no informar&amp;aacute; esto como un error.</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">A veces, los m&amp;oacute;dulos no se encuentran directamente debajo de &lt;em&gt;baseUrl&lt;/em&gt; . Por ejemplo, una importaci&amp;oacute;n a un m&amp;oacute;dulo &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; se traducir&amp;iacute;a en tiempo de ejecuci&amp;oacute;n a &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; . Los cargadores utilizan una configuraci&amp;oacute;n de mapeo para mapear nombres de m&amp;oacute;dulos a archivos en tiempo de ejecuci&amp;oacute;n, consulte la &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;documentaci&amp;oacute;n de &lt;/a&gt;&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;RequireJs&lt;/a&gt; y la documentaci&amp;oacute;n de SystemJS .</target>
        </trans-unit>
        <trans-unit id="37b66ff014eda83e2b1e8f0a114fdd628d5f0100" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">A veces, los m&amp;oacute;dulos no se encuentran directamente debajo de &lt;em&gt;baseUrl&lt;/em&gt; . Los cargadores utilizan una configuraci&amp;oacute;n de mapeo para mapear nombres de m&amp;oacute;dulos a archivos en tiempo de ejecuci&amp;oacute;n, consulte la &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;documentaci&amp;oacute;n de &lt;/a&gt;&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;RequireJs&lt;/a&gt; y la documentaci&amp;oacute;n de SystemJS .</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes" xml:space="preserve">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target state="translated">A veces, las fuentes del proyecto de varios directorios en tiempo de compilaci&amp;oacute;n se combinan para generar un &amp;uacute;nico directorio de salida. Esto se puede ver como un conjunto de directorios de origen que crea un directorio &quot;virtual&quot;.</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes" xml:space="preserve">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target state="translated">A veces esto no es deseable, por ejemplo, las entradas &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; y &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; dar&amp;iacute;an como resultado una estructura de salida que reflejara &lt;code&gt;FolderA\FolderB\&lt;/code&gt; . Ahora, si se agrega un nuevo archivo &lt;code&gt;FolderA\3.ts&lt;/code&gt; a la entrada, la estructura de salida aparecer&amp;aacute; en el espejo &lt;code&gt;FolderA\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">A veces, terminar&amp;aacute; en una situaci&amp;oacute;n en la que sabr&amp;aacute; m&amp;aacute;s sobre un valor que TypeScript. Por lo general, esto suceder&amp;aacute; cuando sepa que el tipo de alguna entidad podr&amp;iacute;a ser m&amp;aacute;s espec&amp;iacute;fico que su tipo actual.</target>
        </trans-unit>
        <trans-unit id="db9ad13d4e098d7519b16265367b7512e89b4d5d" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually, this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target state="translated">A veces, sobrescribir&amp;aacute; por completo el objeto de exportaci&amp;oacute;n. Este es un patr&amp;oacute;n com&amp;uacute;n que la gente usa para hacer que sus m&amp;oacute;dulos se puedan llamar inmediatamente como en este fragmento:</target>
        </trans-unit>
        <trans-unit id="d728f725e5c3a9034a8a3fe4df81013d14f602c4" translate="yes" xml:space="preserve">
          <source>Source Map - &lt;code&gt;sourceMap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5774da7b802f7af9150c4273aaf57f7387c8eb1d" translate="yes" xml:space="preserve">
          <source>Source Maps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa38cdf5131675218c181d7b11184e4109a5125" translate="yes" xml:space="preserve">
          <source>Source Root - &lt;code&gt;sourceRoot&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="48eef677f8e006bcedd3e0792da013d963078bac" translate="yes" xml:space="preserve">
          <source>Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we&amp;rsquo;ll include links to background reading that you can use to read up on those concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="efbbb58a99e1f76d9d3034bd2b5e0e968683bf5a" translate="yes" xml:space="preserve">
          <source>Specifies an allowlist of files to include in the program. An error occurs if any of the files can&amp;rsquo;t be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74f7553e5ec8cdb8bab2e09b9d4de6b751389a2" translate="yes" xml:space="preserve">
          <source>Specifies an array of filenames or patterns that should be skipped when resolving &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89dfbe46f3600605d13d83998972af673fa40e0" translate="yes" xml:space="preserve">
          <source>Specifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target state="translated">Especifica la ubicación en la que el depurador debe localizar los archivos de TypeScript en lugar de las ubicaciones de origen.Utilice este indicador si las fuentes se ubicarán en tiempo de ejecución en una ubicación diferente a la del tiempo de diseño.La ubicación especificada se incrustará en el mapa de fuentes para dirigir al depurador hacia donde se ubicarán los archivos de origen.</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target state="translated">Especifica la ubicación en la que el depurador debe localizar los archivos de mapas en lugar de las ubicaciones generadas.Utilice esta bandera si los archivos .map se ubicarán en tiempo de ejecución en una ubicación diferente a la de los archivos .js.La ubicación especificada se incrustará en el mapa de fuentes para dirigir al depurador hacia donde se ubicarán los archivos de mapas.Esta bandera no creará la ruta especificada y generará los archivos de mapas en esa ubicación.En su lugar,crea un paso de post construcción que mueve los archivos a la ruta especificada.</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes" xml:space="preserve">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX emit.</source>
          <target state="translated">Especifica el objeto invocado para &lt;code&gt;createElement&lt;/code&gt; y &lt;code&gt;__spread&lt;/code&gt; al apuntar a &lt;code&gt;&quot;react&quot;&lt;/code&gt; emitir JSX.</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes" xml:space="preserve">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target state="translated">Especifica el directorio ra&amp;iacute;z de los archivos de entrada. &lt;code&gt;--outDir&lt;/code&gt; solo para controlar la estructura del directorio de salida con --outDir .</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target state="translated">Especifique &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; para deshabilitar la inclusi&amp;oacute;n autom&amp;aacute;tica de paquetes &lt;code&gt;@types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes" xml:space="preserve">
          <source>Specify ECMAScript target version:</source>
          <target state="translated">Especifique la versión de destino de ECMAScript:</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes" xml:space="preserve">
          <source>Specify module code generation: &lt;code&gt;&quot;None&quot;&lt;/code&gt;, &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt;, &lt;code&gt;&quot;AMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;UMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;.</source>
          <target state="translated">Especifique la generaci&amp;oacute;n del c&amp;oacute;digo del m&amp;oacute;dulo: &lt;code&gt;&quot;None&quot;&lt;/code&gt; , &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; , &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; , &lt;code&gt;&quot;System&quot;&lt;/code&gt; , &lt;code&gt;&quot;UMD&quot;&lt;/code&gt; , &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; , &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; o &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes" xml:space="preserve">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">Especifique la funci&amp;oacute;n de f&amp;aacute;brica JSX que se utilizar&amp;aacute; cuando se &lt;code&gt;React.createElement&lt;/code&gt; a react JSX emit , por ejemplo, React.createElement o &lt;code&gt;h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94543a650f9ea4384e3c9b4aac1aeb2ec999debb" translate="yes" xml:space="preserve">
          <source>Specify the JSX fragment factory function to use when targeting react JSX emit with &lt;code&gt;jsxFactory&lt;/code&gt; compiler option is specified, e.g. &lt;code&gt;Fragment&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e9087ffaa1788a738669c2468f437d80a3e672" translate="yes" xml:space="preserve">
          <source>Specify the JSX fragment factory function to use when targeting react JSX emit, e.g. &lt;code&gt;Fragment&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006fc315897b9c6dedc4127db9dec8f57c88bcec" translate="yes" xml:space="preserve">
          <source>Specify the end of line sequence to be used when emitting files: &amp;lsquo;CRLF&amp;rsquo; (dos) or &amp;lsquo;LF&amp;rsquo; (unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2563c439e791b9170655cc14e7d00ffe51b0db65" translate="yes" xml:space="preserve">
          <source>Specify the location where a debugger should locate TypeScript files instead of relative source locations. This string is treated verbatim inside the source-map where you can use a path or a URL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93da90b91643eb92c65e310443608e67c5f5f30" translate="yes" xml:space="preserve">
          <source>Specify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c04e27a5ae61b1904c200b896f04e66fb3130e" translate="yes" xml:space="preserve">
          <source>Specify the module resolution strategy: &lt;code&gt;'node'&lt;/code&gt; (Node.js) or &lt;code&gt;'classic'&lt;/code&gt; (used in TypeScript before the release of 1.6). You probably won&amp;rsquo;t need to use &lt;code&gt;classic&lt;/code&gt; in modern code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes" xml:space="preserve">
          <source>Specify what file to store incremental build information in.</source>
          <target state="translated">Especificar en qué archivo almacenar la información de construcción incremental.</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target state="translated">Especificar &lt;code&gt;--outFile&lt;/code&gt; junto con &lt;code&gt;--module amd&lt;/code&gt; o &lt;code&gt;--module system&lt;/code&gt; concatenar&amp;aacute; todos los m&amp;oacute;dulos en la compilaci&amp;oacute;n en un solo archivo de salida que contiene m&amp;uacute;ltiples cierres de m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes" xml:space="preserve">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target state="translated">Especificando el tipo de &lt;code&gt;this&lt;/code&gt; para funciones</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">Mejoras en la velocidad</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes" xml:space="preserve">
          <source>Splitting Across Files</source>
          <target state="translated">Dividiendo los archivos</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes" xml:space="preserve">
          <source>Spread</source>
          <target state="translated">Spread</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes" xml:space="preserve">
          <source>Spread expressions with tuple types</source>
          <target state="translated">Difundir expresiones con tipos de tupla</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes" xml:space="preserve">
          <source>Stable packages are available here:</source>
          <target state="translated">Los paquetes estables están disponibles aquí:</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes" xml:space="preserve">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target state="translated">Los errores de inicio de TypeScript 2.9 se muestran en &lt;code&gt;--pretty&lt;/code&gt; de forma predeterminada si el dispositivo de salida es aplicable para texto colorido. TypeScript comprobar&amp;aacute; si el vapor de salida tiene la propiedad &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt; &lt;code&gt;isTty&lt;/code&gt; &lt;/a&gt; establecida.</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes" xml:space="preserve">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target state="translated">A partir de la versi&amp;oacute;n 1.6, el compilador de TypeScript utilizar&amp;aacute; un conjunto diferente de reglas para resolver los nombres de los m&amp;oacute;dulos cuando se dirija a 'commonjs'. Estas &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;reglas&lt;/a&gt; intentaron modelar el procedimiento de b&amp;uacute;squeda de m&amp;oacute;dulos utilizado por Node. Esto significa efectivamente que los m&amp;oacute;dulos de nodo pueden incluir informaci&amp;oacute;n sobre sus tipificaciones y el compilador de TypeScript podr&amp;aacute; encontrarla. Sin embargo, el usuario puede anular las reglas de resoluci&amp;oacute;n del m&amp;oacute;dulo seleccionadas por el compilador usando la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--moduleResolution&lt;/code&gt; . Los posibles valores son:</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes" xml:space="preserve">
          <source>Starting out</source>
          <target state="translated">Empezando...</target>
        </trans-unit>
        <trans-unit id="b8e934aecb8f4ca462a04840430ac40704a0da90" translate="yes" xml:space="preserve">
          <source>Starting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">A partir de ECMAScript 2015, el &lt;code&gt;symbol&lt;/code&gt; es un tipo de datos primitivo, al igual que el &lt;code&gt;number&lt;/code&gt; y la &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target state="translated">A partir de ECMAScript 2015,JavaScript tiene un concepto de módulos.TypeScript comparte este concepto.</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target state="translated">A partir de ECMAScript 2015,los módulos son parte nativa del lenguaje,y deben ser soportados por todas las implementaciones de motores compatibles.Por lo tanto,para los nuevos proyectos los módulos serían el mecanismo de organización de código recomendado.</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target state="translated">A partir de TypeScript 1.8, los paquetes oficiales de NuGet est&amp;aacute;n disponibles para &lt;code&gt;tsc.exe&lt;/code&gt; Compiler ( tsc.exe ), as&amp;iacute; como para la integraci&amp;oacute;n de MSBuild ( &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; y &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8:</source>
          <target state="translated">Empezando con TypeScript 1.8:</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; setting in the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target state="translated">Comenzando con TypeScript 2.3, el &lt;code&gt;tsconfig.json&lt;/code&gt; predeterminado generado por &lt;code&gt;tsc --init&lt;/code&gt; incluye una configuraci&amp;oacute;n &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; en la secci&amp;oacute;n &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; . Por lo tanto, los proyectos nuevos que se inicien con &lt;code&gt;tsc --init&lt;/code&gt; tendr&amp;aacute;n de forma predeterminada el nivel m&amp;aacute;s alto de seguridad de tipos habilitado.</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes" xml:space="preserve">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target state="translated">Las declaraciones que se garantiza que no se ejecutar&amp;aacute;n en tiempo de ejecuci&amp;oacute;n ahora se marcan correctamente como errores de c&amp;oacute;digo inalcanzables. Por ejemplo, las declaraciones que siguen a declaraciones incondicionales de &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; o &lt;code&gt;continue&lt;/code&gt; se consideran inalcanzables. Utilice &lt;code&gt;--allowUnreachableCode&lt;/code&gt; para deshabilitar la detecci&amp;oacute;n y los informes de c&amp;oacute;digos inalcanzables.</target>
        </trans-unit>
        <trans-unit id="4834b04199e24094cfa37dc3df47bc9740ccc20d" translate="yes" xml:space="preserve">
          <source>Static Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="translated">Propiedades estáticas</target>
        </trans-unit>
        <trans-unit id="1e94b9fe73132ea714175037fe0cd997356ca7ce" translate="yes" xml:space="preserve">
          <source>Static Property Mixins &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/17829&quot;&gt;&lt;code&gt;#17829&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes" xml:space="preserve">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target state="translated">Los métodos estáticos en una clase exportada tienen un problema similar:la clase misma agrega una capa de anidación.A menos que aumente la expresividad o la intención de una manera claramente útil,considere simplemente la posibilidad de exportar una función de ayuda.</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes" xml:space="preserve">
          <source>StaticZipCodeValidator.ts</source>
          <target state="translated">StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="11dc9e1952928d4ca947651277656b4d8b55fffc" translate="yes" xml:space="preserve">
          <source>Status:</source>
          <target state="translated">Status:</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="c5a651c6a5ca45d3200e3822a71c808cfc9ddee0" translate="yes" xml:space="preserve">
          <source>Strict - &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes" xml:space="preserve">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target state="translated">Cheques &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; estrictos</target>
        </trans-unit>
        <trans-unit id="7db7be7d078caf461b753e0214a03c98e722bffe" translate="yes" xml:space="preserve">
          <source>Strict Bind Call Apply - &lt;code&gt;strictBindCallApply&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d933d28761202efe8959a2abfc0ee0653e25ea29" translate="yes" xml:space="preserve">
          <source>Strict Checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes" xml:space="preserve">
          <source>Strict Class Initialization</source>
          <target state="translated">Inicialización de clase estricta</target>
        </trans-unit>
        <trans-unit id="117936c45339446360a285051720e74fb1e1a712" translate="yes" xml:space="preserve">
          <source>Strict Function Types - &lt;code&gt;strictFunctionTypes&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138584497ea8db53d6fe3a0d2d6a889f35fd24b1" translate="yes" xml:space="preserve">
          <source>Strict Null Checks - &lt;code&gt;strictNullChecks&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73209b516ae52a149a4f72b4ba6803dd3a89c92b" translate="yes" xml:space="preserve">
          <source>Strict Property Initialization - &lt;code&gt;strictPropertyInitialization&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes" xml:space="preserve">
          <source>Strict contravariance for callback parameters</source>
          <target state="translated">Contravención estricta de los parámetros de devolución de llamada</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes" xml:space="preserve">
          <source>Strict function types</source>
          <target state="translated">Tipos de función estrictos</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes" xml:space="preserve">
          <source>Stricter Generators</source>
          <target state="translated">Generadores más estrictos</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes" xml:space="preserve">
          <source>Stricter Generics</source>
          <target state="translated">Genéricos más estrictos</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes" xml:space="preserve">
          <source>Stricter checking for generic functions</source>
          <target state="translated">Comprobación más estricta de las funciones genéricas</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes" xml:space="preserve">
          <source>Stricter object literal assignment checks</source>
          <target state="translated">Comprobaciones de asignación literal de objetos más estrictas</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes" xml:space="preserve">
          <source>String Enums</source>
          <target state="translated">Enumeración de las cuerdas</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes" xml:space="preserve">
          <source>String Literal Types</source>
          <target state="translated">Tipos literales de cuerdas</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes" xml:space="preserve">
          <source>String enums</source>
          <target state="translated">Enums de cuerdas</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes" xml:space="preserve">
          <source>String enums are a similar concept, but have some subtle &lt;a href=&quot;#enums-at-runtime&quot;&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target state="translated">Las enumeraciones de cadenas son un concepto similar, pero tienen algunas &lt;a href=&quot;#enums-at-runtime&quot;&gt;diferencias&lt;/a&gt; sutiles en el tiempo de ejecuci&amp;oacute;n, como se documenta a continuaci&amp;oacute;n. En una enumeraci&amp;oacute;n de cadena, cada miembro debe inicializarse de forma constante con un literal de cadena o con otro miembro de enumeraci&amp;oacute;n de cadena.</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes" xml:space="preserve">
          <source>String literal types</source>
          <target state="translated">Tipos literales de cuerdas</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes" xml:space="preserve">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">Los tipos literales de cadena permiten especificar el valor exacto que debe tener una cadena.En la práctica,los tipos literales de cadena se combinan muy bien con los tipos de unión,los tipos de guarda y los alias de tipos.Puedes usar estas características juntas para obtener un comportamiento tipo enum con las cuerdas.</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes" xml:space="preserve">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target state="translated">Los tipos literales de cuerdas pueden usarse de la misma manera para distinguir las sobrecargas:</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes" xml:space="preserve">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target state="translated">Los tipos literales de cadena, num&amp;eacute;ricos y booleanos (por ejemplo, &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;true&lt;/code&gt; ) se infirieron previamente solo en presencia de una anotaci&amp;oacute;n de tipo expl&amp;iacute;cita. A partir de TypeScript 2.1, los tipos literales &lt;em&gt;siempre se&lt;/em&gt; infieren para las variables &lt;code&gt;const&lt;/code&gt; y las propiedades de &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes" xml:space="preserve">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target state="translated">Las propiedades tipo cadena de un tipo de objeto son las declaradas mediante un identificador,un literal de cadena o un nombre de propiedad calculado de un tipo literal de cadena.</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes" xml:space="preserve">
          <source>StringValidator.ts</source>
          <target state="translated">StringValidator.ts</target>
        </trans-unit>
        <trans-unit id="67a09ff3eda42cceb49c2b8ebb950c7b003be45b" translate="yes" xml:space="preserve">
          <source>Strip Internal - &lt;code&gt;stripInternal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbdcec4c2b576f7ec50907da018377d2da918dc" translate="yes" xml:space="preserve">
          <source>Strips all comments from TypeScript files when converting into JavaScript. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9844396a455fe52a669fba664343368aae3a4790" translate="yes" xml:space="preserve">
          <source>Structural Type System</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e7907c7ea5243abaf83cc6cc7257a835787796" translate="yes" xml:space="preserve">
          <source>Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes" xml:space="preserve">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target state="translated">Los tipos de clase estructuralmente idénticos,pero distintos,se conservan ahora en tipos de unión (en lugar de eliminar todos menos uno).</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes" xml:space="preserve">
          <source>Structuring for outFiles</source>
          <target state="translated">Estructuración de los archivos</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes" xml:space="preserve">
          <source>Structuring for relative modules</source>
          <target state="translated">Estructuración de los módulos relativos</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes" xml:space="preserve">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target state="translated">Estructurar m&amp;oacute;dulos para dar la forma API exacta que desea puede ser complicado. Por ejemplo, podr&amp;iacute;amos querer un m&amp;oacute;dulo que se pueda invocar con o sin &lt;code&gt;new&lt;/code&gt; para producir diferentes tipos, que tenga una variedad de tipos nombrados expuestos en una jerarqu&amp;iacute;a y que tambi&amp;eacute;n tenga algunas propiedades en el objeto del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="1d1df78833ce77fa7da034e63ad69c3819501b68" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context, this is on by default &amp;mdash; offers you a chance to have less terse, single colored messages from the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context.</source>
          <target state="translated">Estilizar los errores y mensajes usando el color y el contexto.</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">Texto sublime</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes" xml:space="preserve">
          <source>Subtype vs Assignment</source>
          <target state="translated">Subtipo vs.Asignación</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes" xml:space="preserve">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target state="translated">Soporte 'target: es5' con 'm&amp;oacute;dulo: es6'</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes" xml:space="preserve">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target state="translated">Admite propiedades con &lt;code&gt;keyof&lt;/code&gt; &lt;code&gt;number&lt;/code&gt; y &lt;code&gt;symbol&lt;/code&gt; con tipos keyof y asignados</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes" xml:space="preserve">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;&quot;react&quot;&lt;/code&gt;, &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;. See &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;.</source>
          <target state="translated">Admite JSX en archivos &lt;code&gt;.tsx&lt;/code&gt; : &lt;code&gt;&quot;react&quot;&lt;/code&gt; , &lt;code&gt;&quot;preserve&quot;&lt;/code&gt; , &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; . Ver &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target state="translated">Soporte para &lt;code&gt;--target ES2016&lt;/code&gt; , &lt;code&gt;--target ES2017&lt;/code&gt; y &lt;code&gt;--target ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target state="translated">Soporte para &lt;code&gt;--target ES6&lt;/code&gt; con &lt;code&gt;--module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target state="translated">Soporte para salida de m&amp;oacute;dulo de &lt;code&gt;System&lt;/code&gt; y &lt;code&gt;UMD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target state="translated">Soporte para la interoperabilidad de importaci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; con SystemJS</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target state="translated">Soporte para &lt;code&gt;defaultProps&lt;/code&gt; en JSX</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">Soporte para &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; desde m&amp;oacute;dulos &lt;code&gt;--esModuleInterop&lt;/code&gt; con --esModuleInterop</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target state="translated">Soporte para &lt;code&gt;import.meta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target state="translated">Soporte para &lt;code&gt;new.target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes" xml:space="preserve">
          <source>Support for Mix-in classes</source>
          <target state="translated">Apoyo a las clases mixtas</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes" xml:space="preserve">
          <source>Support for UMD module definitions</source>
          <target state="translated">Soporte para definiciones de módulos UMD</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes" xml:space="preserve">
          <source>Support for decorators when targeting ES3</source>
          <target state="translated">Apoyo a los decoradores cuando apuntan al ES3</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes" xml:space="preserve">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target state="translated">Soporte para biblioteca de ayudantes externos ( &lt;code&gt;tslib&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes" xml:space="preserve">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target state="translated">Soporte para archivos JavaScript simples (usando &lt;code&gt;allowJS&lt;/code&gt; y opcionalmente &lt;code&gt;checkJs&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes" xml:space="preserve">
          <source>Support for spread operator on JSX element children</source>
          <target state="translated">Apoyo al operador de difusión en los niños del elemento JSX</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes" xml:space="preserve">
          <source>Support output to IPC-driven files</source>
          <target state="translated">Soportar la salida a los archivos manejados por el IPC</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes" xml:space="preserve">
          <source>Supported JSDoc</source>
          <target state="translated">Apoyado por JSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes" xml:space="preserve">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target state="translated">Reprimir &lt;code&gt;--noImplicitAny&lt;/code&gt; errores de los objetos de indexaci&amp;oacute;n que carecen de firmas de &amp;iacute;ndice. Consulte el &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;n&amp;uacute;mero 1232&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="73191a43587818ef0ca4822c9bcaeab0705aafe7" translate="yes" xml:space="preserve">
          <source>Suppress Excess Property Errors - &lt;code&gt;suppressExcessPropertyErrors&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77daf91d977b3d49eec9b3c6d5f3a69ff849e689" translate="yes" xml:space="preserve">
          <source>Suppress Implicit Any Index Errors - &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes" xml:space="preserve">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target state="translated">Suprima errores en archivos .ts usando comentarios '// @ ts-ignore'</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes" xml:space="preserve">
          <source>Suppress excess property checks for object literals.</source>
          <target state="translated">Suprimir el exceso de controles de propiedad de los objetos literales.</target>
        </trans-unit>
        <trans-unit id="9e53c6e8e58d38245a243cf6a1ed6b86dd7097bc" translate="yes" xml:space="preserve">
          <source>Svelte</source>
          <target state="translated">Svelte</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes" xml:space="preserve">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target state="translated">Las propiedades simbólicas de un tipo de objeto son las que se declaran utilizando un nombre de propiedad calculado de un tipo de símbolo único.</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes" xml:space="preserve">
          <source>Symbols are immutable, and unique.</source>
          <target state="translated">Los símbolos son inmutables y únicos.</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes" xml:space="preserve">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target state="translated">Los símbolos también pueden combinarse con declaraciones de propiedades computarizadas para declarar las propiedades de los objetos y los miembros de la clase.</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes" xml:space="preserve">
          <source>Symbols: match</source>
          <target state="translated">Los símbolos:coinciden</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes" xml:space="preserve">
          <source>Symbols: split</source>
          <target state="translated">Símbolos:dividido</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes" xml:space="preserve">
          <source>System SimpleModule.js</source>
          <target state="translated">Sistema SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes" xml:space="preserve">
          <source>System modules have this flag on by default.</source>
          <target state="translated">Los módulos del sistema tienen esta bandera encendida por defecto.</target>
        </trans-unit>
        <trans-unit id="fc1f7c12fc55ff47463b0071310d36fbecc062ae" translate="yes" xml:space="preserve">
          <source>TS Build Info File - &lt;code&gt;tsBuildInfoFile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab624ca73eb89a17acc6188413b3be19da770c27" translate="yes" xml:space="preserve">
          <source>TS for Functional Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07673a3de2879cfe1db52c3e95c21b5cff20a04e" translate="yes" xml:space="preserve">
          <source>TS for Java/C# Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5625ebb46a7cebb6fe457d6cbe88c67e28246af" translate="yes" xml:space="preserve">
          <source>TS for the New Programmer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6b15580278437277b53f9bfd85bf02c341afd0" translate="yes" xml:space="preserve">
          <source>TSConfig</source>
          <target state="translated">TSConfig</target>
        </trans-unit>
        <trans-unit id="f0d1d3519955d1c177014af7b8de56104426d555" translate="yes" xml:space="preserve">
          <source>TSConfig Bases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3faa3a6af48373d85bf84403340df39a4e0870f" translate="yes" xml:space="preserve">
          <source>TSConfig Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">Índice</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">Tabla de contenido</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes" xml:space="preserve">
          <source>Tagged template strings in ES3/ES5</source>
          <target state="translated">Etiquetado de cadenas de plantillas en ES3/ES5</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes" xml:space="preserve">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target state="translated">Las plantillas etiquetadas son una forma de invocación introducida en ECMAScript 2015.Como las expresiones de llamada,las funciones genéricas pueden ser usadas en una plantilla etiquetada y TypeScript inferirá los argumentos de tipo utilizados.</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes" xml:space="preserve">
          <source>Tagged union types</source>
          <target state="translated">Tipos de unión etiquetados</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes" xml:space="preserve">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target state="translated">Tómese un segundo rápido para adivinar cuál es el resultado del siguiente fragmento:</target>
        </trans-unit>
        <trans-unit id="f7a6cee3faadf5126dbb6508921d3788cba5ee9b" translate="yes" xml:space="preserve">
          <source>Target - &lt;code&gt;target&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes" xml:space="preserve">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target state="translated">Apuntando a ECMAScript 2015 y superior</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes" xml:space="preserve">
          <source>Targeting ES5 and ES3</source>
          <target state="translated">Apuntando al ES5 y al ES3</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes" xml:space="preserve">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target state="translated">T&amp;eacute;cnicamente, las enumeraciones se pueden mezclar con miembros num&amp;eacute;ricos y de cadena, pero no est&amp;aacute; claro por qu&amp;eacute; querr&amp;iacute;a hacerlo:</target>
        </trans-unit>
        <trans-unit id="426c95cfc85b6cd93af3f2a51c05fff5f6d8d622" translate="yes" xml:space="preserve">
          <source>Tells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of &lt;code&gt;.tsbuildinfo&lt;/code&gt; files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag&quot;&gt;3.4 release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">Cadenas de plantillas</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="8988c52340753c090a90538d2331c181cc676927" translate="yes" xml:space="preserve">
          <source>Templates For Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes" xml:space="preserve">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target state="translated">Pruebe la p&amp;aacute;gina ejecutando gulp y luego abriendo &lt;code&gt;dist/index.html&lt;/code&gt; en un navegador. Deber&amp;iacute;a ver &quot;Hola desde TypeScript&quot; en la p&amp;aacute;gina.</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes" xml:space="preserve">
          <source>Test the resulting app</source>
          <target state="translated">Pruebe la aplicación resultante</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes" xml:space="preserve">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes" xml:space="preserve">
          <source>TestCalculator.ts</source>
          <target state="translated">TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes" xml:space="preserve">
          <source>TestProgrammerCalculator.ts</source>
          <target state="translated">TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="b57f29315e481e12c1ed5e16efc76553f50ab9b4" translate="yes" xml:space="preserve">
          <source>Testing your types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes" xml:space="preserve">
          <source>Thanks to work done by &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target state="translated">Gracias al trabajo realizado por &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt; , TypeScript 2.5 implementa una nueva funci&amp;oacute;n ECMAScript que permite a los usuarios omitir la variable en &lt;code&gt;catch&lt;/code&gt; cl&amp;aacute;usulas catch . Por ejemplo, al usar &lt;code&gt;JSON.parse&lt;/code&gt; , es posible que deba ajustar las llamadas a la funci&amp;oacute;n con un &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; , pero es posible que no termine usando &lt;code&gt;SyntaxError&lt;/code&gt; que se genera cuando la entrada es err&amp;oacute;nea.</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;&quot;react&quot;&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target state="translated">Ese &lt;code&gt;@types/&lt;/code&gt; prefix significa que tambi&amp;eacute;n queremos obtener los archivos de declaraci&amp;oacute;n para React y React-DOM. Por lo general, cuando importa una ruta como &lt;code&gt;&quot;react&quot;&lt;/code&gt; , se ver&amp;aacute; dentro del paquete &lt;code&gt;react&lt;/code&gt; ; sin embargo, no todos los paquetes incluyen archivos de declaraci&amp;oacute;n, por lo que TypeScript tambi&amp;eacute;n busca en el paquete &lt;code&gt;@types/react&lt;/code&gt; . Ver&amp;aacute;s que ni siquiera tendremos que pensar en esto m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes" xml:space="preserve">
          <source>That is, in the example:</source>
          <target state="translated">Es decir,en el ejemplo:</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes" xml:space="preserve">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target state="translated">Ese &amp;uacute;ltimo ejemplo no es realmente seguro para los tipos.</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes" xml:space="preserve">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target state="translated">Eso podr&amp;iacute;a resultar en la divisi&amp;oacute;n de &lt;code&gt;undefined&lt;/code&gt; , raz&amp;oacute;n por la cual en &lt;code&gt;strictNullChecks&lt;/code&gt; , lo siguiente es un error.</target>
        </trans-unit>
        <trans-unit id="f0f467baf30c5d87a58b511c11bcb6972b602339" translate="yes" xml:space="preserve">
          <source>That said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript&amp;rsquo;s support for JavaScript classes will make these models even more powerful. TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes" xml:space="preserve">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target state="translated">Esa fue la inclusi&amp;oacute;n autom&amp;aacute;tica de &lt;code&gt;tsconfig.json&lt;/code&gt; . Eso no incluye la resoluci&amp;oacute;n del m&amp;oacute;dulo como se discuti&amp;oacute; anteriormente. Si el compilador identific&amp;oacute; un archivo como destino de la importaci&amp;oacute;n de un m&amp;oacute;dulo, se incluir&amp;aacute; en la compilaci&amp;oacute;n independientemente de si se excluy&amp;oacute; en los pasos anteriores.</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target state="translated">Eso es porque &lt;code&gt;S&lt;/code&gt; no se puede asignar a &lt;code&gt;{ done: false, value: number }&lt;/code&gt; ni a &lt;code&gt;{ done: true, value: number }&lt;/code&gt; . &amp;iquest;Por qu&amp;eacute;? Debido a que la propiedad &lt;code&gt;done&lt;/code&gt; en &lt;code&gt;S&lt;/code&gt; no es lo suficientemente espec&amp;iacute;fica, es &lt;code&gt;boolean&lt;/code&gt; a mientras que cada constituyente de &lt;code&gt;T&lt;/code&gt; tiene una propiedad &lt;code&gt;done&lt;/code&gt; que es espec&amp;iacute;ficamente &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . Eso es lo que quer&amp;iacute;amos decir con cada tipo de constituyente que se verifica de forma aislada: TypeScript no solo une cada propiedad y ve si &lt;code&gt;S&lt;/code&gt; se puede asignar a eso. Si lo hiciera, alg&amp;uacute;n c&amp;oacute;digo incorrecto podr&amp;iacute;a pasar como el siguiente:</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target state="translated">Eso es exactamente lo que introduce TypeScript 3.7. En el &quot;nivel superior&quot; de un alias de tipo, TypeScript aplazar&amp;aacute; la resoluci&amp;oacute;n de argumentos de tipo para permitir estos patrones.</target>
        </trans-unit>
        <trans-unit id="caa5997b70498ef9dc82ab15a96dfd070e25828b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">Eso no quiere decir que la variable de &amp;aacute;mbito de bloque nunca pueda declararse con una variable de &amp;aacute;mbito de funci&amp;oacute;n. La variable de &amp;aacute;mbito de bloque solo necesita declararse dentro de un bloque claramente diferente.</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target state="translated">El comportamiento de &quot;cortocircuito&quot; que tienen las cadenas opcionales es el acceso limitado a propiedades, llamadas, accesos a elementos; no se expande m&amp;aacute;s lejos de estas expresiones. En otras palabras,</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes" xml:space="preserve">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target state="translated">El compilador 1.1 suele ser 4 veces m&amp;aacute;s r&amp;aacute;pido que cualquier versi&amp;oacute;n anterior. Consulte &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;esta publicaci&amp;oacute;n de blog para ver algunos gr&amp;aacute;ficos impresionantes.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target state="translated">La &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;propuesta de iteraci&amp;oacute;n&lt;/a&gt; as&amp;iacute;ncrona introduce los &amp;ldquo;generadores as&amp;iacute;ncronos&amp;rdquo;, que son funciones as&amp;iacute;ncronas que tambi&amp;eacute;n se pueden utilizar para producir resultados de c&amp;aacute;lculo parciales. Los generadores asincr&amp;oacute;nicos tambi&amp;eacute;n pueden delegar llamadas a trav&amp;eacute;s de &lt;code&gt;yield*&lt;/code&gt; a un iterable o async iterable:</target>
        </trans-unit>
        <trans-unit id="f02cc7fd88e051d39dd94c7b8ad656951cb0464f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">La gu&amp;iacute;a de &lt;a href=&quot;library-structures&quot;&gt;estructuras de biblioteca lo&lt;/a&gt; ayuda a comprender los formatos de biblioteca comunes y c&amp;oacute;mo escribir un archivo de declaraci&amp;oacute;n correcto para cada formato. Si est&amp;aacute; editando un archivo existente, probablemente no necesite leer esta secci&amp;oacute;n. Los autores de nuevos archivos de declaraci&amp;oacute;n deben leer esta secci&amp;oacute;n para comprender correctamente c&amp;oacute;mo el formato de la biblioteca influye en la escritura del archivo de declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="227e047dd56cbfa40dd19f72261ee33cba429b50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a proper declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target state="translated">La secci&amp;oacute;n &lt;a href=&quot;publishing&quot;&gt;Publicaci&amp;oacute;n&lt;/a&gt; explica c&amp;oacute;mo publicar sus archivos de declaraci&amp;oacute;n en un paquete npm y muestra c&amp;oacute;mo administrar sus paquetes dependientes.</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;compiler-options&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">La propiedad &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; se puede omitir, en cuyo caso se utilizan los valores predeterminados del compilador. Consulte nuestra lista completa de &lt;a href=&quot;compiler-options&quot;&gt;opciones de compilador&lt;/a&gt; compatibles .</target>
        </trans-unit>
        <trans-unit id="0001ea5843eb39fe0b55fd06eada6c514b9a65f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;files&quot;&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target state="translated">La propiedad &lt;code&gt;&quot;files&quot;&lt;/code&gt; toma una lista de rutas de archivo relativas o absolutas. Las propiedades &lt;code&gt;&quot;include&quot;&lt;/code&gt; y &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; toman una lista de patrones de archivo tipo glob. Los comodines glob admitidos son:</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target state="translated">El operador &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; agrega &lt;code&gt;null&lt;/code&gt; y / o &lt;code&gt;undefined&lt;/code&gt; al tipo del operando derecho dependiendo de cu&amp;aacute;les est&amp;eacute;n presentes en el tipo del operando izquierdo, y &lt;code&gt;||&lt;/code&gt; El operador elimina tanto el &lt;code&gt;null&lt;/code&gt; como el &lt;code&gt;undefined&lt;/code&gt; del tipo del operando izquierdo en el tipo de uni&amp;oacute;n resultante.</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target state="translated">La bandera &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target state="translated">El indicador &lt;code&gt;--declaration&lt;/code&gt; en TypeScript nos permite generar archivos &lt;code&gt;.d.ts&lt;/code&gt; (archivos de declaraci&amp;oacute;n) a partir de archivos fuente de TypeScript (es decir, archivos &lt;code&gt;.ts&lt;/code&gt; y &lt;code&gt;.tsx&lt;/code&gt; ). Estos archivos &lt;code&gt;.d.ts&lt;/code&gt; son importantes por un par de razones.</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target state="translated">Las opciones del compilador &lt;code&gt;--noResolve&lt;/code&gt; le indican al compilador que no &quot;agregue&quot; ning&amp;uacute;n archivo a la compilaci&amp;oacute;n que no se haya pasado en la l&amp;iacute;nea de comandos. Seguir&amp;aacute; intentando resolver el m&amp;oacute;dulo en archivos, pero si no se especifica el archivo, no se incluir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target state="translated">La &lt;code&gt;--preserveSymlinks&lt;/code&gt; compilador --preserveSymlinks</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target state="translated">El &lt;code&gt;--project&lt;/code&gt; ( &lt;code&gt;-p&lt;/code&gt; ) ahora puede tomar cualquier ruta de archivo</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target state="translated">La opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--project&lt;/code&gt; originalmente solo pod&amp;iacute;a tomar rutas a una carpeta que contiene un &lt;code&gt;tsconfig.json&lt;/code&gt; . Dados los diferentes escenarios para las configuraciones de compilaci&amp;oacute;n, ten&amp;iacute;a sentido permitir que &lt;code&gt;--project&lt;/code&gt; apunte a cualquier otro archivo JSON compatible. Por ejemplo, un usuario podr&amp;iacute;a querer apuntar a ES2015 con m&amp;oacute;dulos CommonJS para el Nodo 5, pero ES5 con m&amp;oacute;dulos AMD para el navegador. Con este nuevo trabajo, los usuarios pueden administrar f&amp;aacute;cilmente dos destinos de compilaci&amp;oacute;n separados usando &lt;code&gt;tsc&lt;/code&gt; solo sin tener que realizar soluciones hacky como colocar archivos &lt;code&gt;tsconfig.json&lt;/code&gt; en directorios separados.</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">El indicador &lt;code&gt;--strictNullChecks&lt;/code&gt; corrige esto: cuando declaras una variable, no incluye autom&amp;aacute;ticamente &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . Puede incluirlos expl&amp;iacute;citamente usando un tipo de uni&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="55039ea9d10371eccc73bd4e7f114e096aeca2ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on using &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; which are provided by node, both of these methods have pros and cons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d240e7152b3bafeb38e60b7f07cc2b34d2b2256a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.d.ts&lt;/code&gt; syntax intentionally looks like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES Modules&lt;/a&gt; syntax. ES Modules was ratified by TC39 in 2019, while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22cea6dc461395ba18169f7540ed681c6226e15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.js&lt;/code&gt; files will in turn contain a sourcemap comment to indicate to tools where the files are to external tools, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target state="translated">La directiva &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; es la m&amp;aacute;s com&amp;uacute;n de este grupo. Sirve como declaraci&amp;oacute;n de &lt;em&gt;dependencia&lt;/em&gt; entre archivos.</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;??&lt;/code&gt; el operador puede reemplazar los usos de &lt;code&gt;||&lt;/code&gt; al intentar utilizar un valor predeterminado. Por ejemplo, el siguiente fragmento de c&amp;oacute;digo intenta recuperar el volumen que se guard&amp;oacute; por &amp;uacute;ltima vez en &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt; &lt;code&gt;localStorage&lt;/code&gt; &lt;/a&gt; (si alguna vez lo fue); sin embargo, tiene un error porque usa &lt;code&gt;||&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target state="translated">La etiqueta &lt;code&gt;@enum&lt;/code&gt; le permite crear un objeto literal cuyos miembros son todos de un tipo espec&amp;iacute;fico. A diferencia de la mayor&amp;iacute;a de los objetos literales en Javascript, no permite otros miembros.</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target state="translated">El &lt;code&gt;@enumerable(false)&lt;/code&gt; aqu&amp;iacute; es una &lt;a href=&quot;#decorator-factories&quot;&gt;f&amp;aacute;brica de decoradores&lt;/a&gt; . Cuando se llama al decorador &lt;code&gt;@enumerable(false)&lt;/code&gt; , modifica la propiedad &lt;code&gt;enumerable&lt;/code&gt; del descriptor de propiedad.</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target state="translated">El &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; aqu&amp;iacute; es una &lt;a href=&quot;#decorator-factories&quot;&gt;f&amp;aacute;brica de decoradores&lt;/a&gt; . Cuando se &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; , agrega una entrada de metadatos para la propiedad utilizando la funci&amp;oacute;n &lt;code&gt;Reflect.metadata&lt;/code&gt; de la biblioteca reflect &lt;code&gt;reflect-metadata&lt;/code&gt; . Cuando se llama a &lt;code&gt;getFormat&lt;/code&gt; , lee el valor de metadatos del formato.</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target state="translated">El decorador &lt;code&gt;@required&lt;/code&gt; agrega una entrada de metadatos que marca el par&amp;aacute;metro como requerido. El decorador &lt;code&gt;@validate&lt;/code&gt; luego envuelve el m&amp;eacute;todo &lt;code&gt;greet&lt;/code&gt; existente en una funci&amp;oacute;n que valida los argumentos antes de invocar el m&amp;eacute;todo original.</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target state="translated">El tipo &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; nos permite extraer todos los tipos de par&amp;aacute;metros de un tipo de funci&amp;oacute;n constructora. Produce un tipo de tupla con todos los tipos de par&amp;aacute;metros (o el tipo &lt;code&gt;never&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; no es una funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="83d02d02d5620960b36d464619c7937c85cc9171" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Document&lt;/code&gt; Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target state="translated">El &lt;code&gt;Iterator&lt;/code&gt; tipo ahora permite a los usuarios especificar el tipo dado, el tipo devuelto, y el tipo que &lt;code&gt;next&lt;/code&gt; puede aceptar.</target>
        </trans-unit>
        <trans-unit id="c806f2503a2c301fc142862aa6123f9229b59408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target state="translated">El tipo de ayuda &lt;code&gt;Omit&lt;/code&gt; ir</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target state="translated">El &lt;code&gt;ReadonlyArray&lt;/code&gt; tipo se describen &lt;code&gt;Array&lt;/code&gt; s que s&amp;oacute;lo se pueden leer. Cualquier variable con una referencia a &lt;code&gt;ReadonlyArray&lt;/code&gt; no puede agregar, eliminar ni reemplazar ning&amp;uacute;n elemento de la matriz.</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target state="translated">El &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marcador de interfaz es simplemente una interfaz vac&amp;iacute;a declarada en &lt;code&gt;lib.d.ts&lt;/code&gt; . M&amp;aacute;s all&amp;aacute; de ser reconocida en el tipo contextual de un objeto literal, la interfaz act&amp;uacute;a como cualquier interfaz vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target state="translated">La directiva &lt;code&gt;amd-dependency&lt;/code&gt; tambi&amp;eacute;n puede tener una propiedad de &lt;code&gt;name&lt;/code&gt; opcional ; esto permite pasar un nombre opcional para una dependencia amd:</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target state="translated">La directiva &lt;code&gt;amd-module&lt;/code&gt; permite pasar un nombre de m&amp;oacute;dulo opcional al compilador:</target>
        </trans-unit>
        <trans-unit id="3a42e83d7ce322bb05576e69237c913e674e94ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target state="translated">La &lt;code&gt;any&lt;/code&gt; tipo es una poderosa forma de trabajo con JavaScript existente, lo que le permite gradualmente opt-in y opt-out de comprobaci&amp;oacute;n de tipos durante la compilaci&amp;oacute;n. Es de esperar que &lt;code&gt;Object&lt;/code&gt; juegue un papel similar, como lo hace en otros idiomas. Sin embargo, las variables de tipo &lt;code&gt;Object&lt;/code&gt; solo permiten asignarles alg&amp;uacute;n valor. No puede llamar a m&amp;eacute;todos arbitrarios sobre ellos, incluso los que realmente existen:</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target state="translated">El tipo &lt;code&gt;any&lt;/code&gt; tambi&amp;eacute;n es &amp;uacute;til si conoce alguna parte del tipo, pero quiz&amp;aacute;s no todo. Por ejemplo, puede tener una matriz, pero la matriz tiene una combinaci&amp;oacute;n de diferentes tipos:</target>
        </trans-unit>
        <trans-unit id="d1d41de80e1caf6129e3e280267f6e09abe3bf99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; will continue to propagate through your objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">El &lt;code&gt;as&lt;/code&gt; operador</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target state="translated">El operador &lt;code&gt;as&lt;/code&gt; est&amp;aacute; disponible en archivos &lt;code&gt;.ts&lt;/code&gt; y &lt;code&gt;.tsx&lt;/code&gt; , y tiene un comportamiento id&amp;eacute;ntico al estilo de aserci&amp;oacute;n de tipo de corchetes angulares.</target>
        </trans-unit>
        <trans-unit id="3eeb3c7a58b8f984aa019a2e9e3c1db1552b14c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;composite&lt;/code&gt; option enforces certain constraints which make it possible for build tools (including TypeScript itself, under &lt;code&gt;--build&lt;/code&gt; mode) to quickly determine if a project has been built yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec99f693ec8e29469547cb939cd2051d5a6580d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;document.getElementById&lt;/code&gt; function returns an &lt;code&gt;HTMLElement&lt;/code&gt;. &lt;code&gt;HTMLElement&lt;/code&gt; interface extends the &lt;code&gt;Element&lt;/code&gt; interface which extends the &lt;code&gt;Node&lt;/code&gt; interface. This prototypal extension allows for all &lt;code&gt;HTMLElements&lt;/code&gt; to utilize a subset of standard methods. In the code snippet, we use a property defined on the &lt;code&gt;Node&lt;/code&gt; interface to append the new &lt;code&gt;p&lt;/code&gt; element to the website.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target state="translated">La lista de &lt;code&gt;exclude&lt;/code&gt; no admite tarjetas wilcards. Debe ser simplemente una lista de archivos y / o directorios.</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target state="translated">La sintaxis &lt;code&gt;export =&lt;/code&gt; especifica un &amp;uacute;nico objeto que se exporta desde el m&amp;oacute;dulo. Puede ser una clase, interfaz, espacio de nombres, funci&amp;oacute;n o enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target state="translated">La cl&amp;aacute;usula &lt;code&gt;extends&lt;/code&gt; de una clase anteriormente requer&amp;iacute;a que se especificara una referencia de tipo. Ahora acepta una expresi&amp;oacute;n seguida opcionalmente por una lista de argumentos de tipo. El tipo de la expresi&amp;oacute;n debe ser un tipo de funci&amp;oacute;n de constructor con al menos una firma de construcci&amp;oacute;n que tenga el mismo n&amp;uacute;mero de par&amp;aacute;metros de tipo que el n&amp;uacute;mero de argumentos de tipo especificado en la cl&amp;aacute;usula &lt;code&gt;extends&lt;/code&gt; . El tipo de retorno de la (s) firma (s) de construcci&amp;oacute;n coincidente es el tipo base del cual hereda el tipo de instancia de clase. Efectivamente, esto permite especificar tanto clases reales como expresiones &quot;similares a clases&quot; en la cl&amp;aacute;usula &lt;code&gt;extends&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">La &lt;code&gt;extends&lt;/code&gt; es una propiedad de nivel superior en &lt;code&gt;tsconfig.json&lt;/code&gt; (junto con &lt;code&gt;compilerOptions&lt;/code&gt; , &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; y &lt;code&gt;exclude&lt;/code&gt; ). El valor &lt;code&gt;extends&lt;/code&gt; es una cadena que contiene una ruta a otro archivo de configuraci&amp;oacute;n para heredar. La ruta puede usar una resoluci&amp;oacute;n de estilo Node.js.</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target state="translated">La declaraci&amp;oacute;n &lt;code&gt;for-await-of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;for..await..of&lt;/code&gt; solo es legal dentro de una funci&amp;oacute;n as&amp;iacute;ncrona o un generador as&amp;iacute;ncrono.</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;getWidget&lt;/code&gt; acepta un n&amp;uacute;mero y devuelve un widget, o acepta una cadena y devuelve una matriz de widgets.</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target state="translated">El objeto de &lt;code&gt;greeter&lt;/code&gt; puede registrarse en un archivo o mostrar una alerta. Puede proporcionar LogOptions a &lt;code&gt;.log(...)&lt;/code&gt; y opciones de alerta a &lt;code&gt;.alert(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="681ed2c77b2f124166709179044128a1509b2444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator also acts as a narrowing expression for types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target state="translated">El operador &lt;code&gt;in&lt;/code&gt; ahora act&amp;uacute;a como una expresi&amp;oacute;n de restricci&amp;oacute;n para tipos.</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target state="translated">La propiedad de &lt;code&gt;length&lt;/code&gt; de un tipo de tupla con elementos opcionales es una uni&amp;oacute;n de tipos literales num&amp;eacute;ricos que representan las longitudes posibles. Por ejemplo, el tipo de la propiedad de &lt;code&gt;length&lt;/code&gt; en el tipo de tupla &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; Es &lt;code&gt;1 | 2 | 3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edc3cf84bfebfe901fb4d4669024b6fb12e9c7d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;moment&lt;/code&gt; import would be fully typed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target state="translated">El tipo &lt;code&gt;never&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target state="translated">El tipo &lt;code&gt;never&lt;/code&gt; tiene las siguientes caracter&amp;iacute;sticas:</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;never&lt;/code&gt; es un subtipo y se puede asignar a todos los tipos; sin embargo, &lt;em&gt;ning&amp;uacute;n&lt;/em&gt; tipo es un subtipo de, o asignable a, &lt;code&gt;never&lt;/code&gt; (excepto &lt;code&gt;never&lt;/code&gt; en s&amp;iacute; mismo). Incluso &lt;code&gt;any&lt;/code&gt; no se puede asignar a &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09dccd3b70d3efcf8ad49b20ad7c607d29406b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">El tipo &lt;code&gt;never&lt;/code&gt; representa el tipo de valores que nunca ocurren. Por ejemplo, &lt;code&gt;never&lt;/code&gt; es el tipo de retorno para una expresi&amp;oacute;n de funci&amp;oacute;n o una expresi&amp;oacute;n de funci&amp;oacute;n de flecha que siempre arroja una excepci&amp;oacute;n o una que nunca devuelve; Las variables tambi&amp;eacute;n adquieren el tipo &lt;code&gt;never&lt;/code&gt; cuando se reducen por cualquier tipo de guardias que nunca pueden ser verdaderas.</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;new.target&lt;/code&gt; es una nueva sintaxis introducida en ES2015. Cuando se crea una instancia de un constructor a trav&amp;eacute;s de &lt;code&gt;new&lt;/code&gt; , el valor de &lt;code&gt;new.target&lt;/code&gt; se establece como una referencia a la funci&amp;oacute;n del constructor que se us&amp;oacute; inicialmente para asignar la instancia. Si se llama a una funci&amp;oacute;n en lugar de construirla mediante &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;new.target&lt;/code&gt; se establece en &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target state="translated">Los tipos &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; &lt;em&gt;no se&lt;/em&gt; ampl&amp;iacute;an a &lt;code&gt;any&lt;/code&gt; en el modo de comprobaci&amp;oacute;n nulo estricto.</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target state="translated">La eliminaci&amp;oacute;n &lt;code&gt;null&lt;/code&gt; es bastante obvia aqu&amp;iacute;, pero tambi&amp;eacute;n puede usar operadores terser:</target>
        </trans-unit>
        <trans-unit id="ce2eedc44ab0659afbd8a1934f33562f60e3a770" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;out&lt;/code&gt; option computes the final file location in a way that is not predictable or consistent. This option is retained for backward compatibility only and is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target state="translated">La propiedad de &lt;code&gt;path&lt;/code&gt; de cada referencia puede apuntar a un directorio que contiene un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; , o al archivo de configuraci&amp;oacute;n en s&amp;iacute; (que puede tener cualquier nombre).</target>
        </trans-unit>
        <trans-unit id="2afabb5c4140f687a8b8b854febbb675c40d2812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; variable is never declared to be a &lt;code&gt;Point&lt;/code&gt; type. However, TypeScript compares the shape of &lt;code&gt;point&lt;/code&gt; to the shape of &lt;code&gt;Point&lt;/code&gt; in the type-check. They have the same shape, so the code passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target state="translated">El modo de &lt;code&gt;preserve&lt;/code&gt; mantendr&amp;aacute; las expresiones JSX como parte de la salida para ser consumidas por otro paso de transformaci&amp;oacute;n. &lt;em&gt;Adem&amp;aacute;s, la salida tendr&amp;aacute; una extensi&amp;oacute;n de archivo &lt;code&gt;.jsx&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target state="translated">El modificador &lt;code&gt;protected&lt;/code&gt; act&amp;uacute;a de manera muy similar al modificador &lt;code&gt;private&lt;/code&gt; con la excepci&amp;oacute;n de que tambi&amp;eacute;n se puede acceder a los miembros declarados &lt;code&gt;protected&lt;/code&gt; dentro de las clases derivadas. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="6d895e4e8795254dd65da4c62b6624de0640eaf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;querySelector&lt;/code&gt; and &lt;code&gt;querySelectorAll&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb559dc4cb94749b099fdff9ab41761d1224d04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;querySelectorAll&lt;/code&gt; definition is similar to &lt;code&gt;getElementsByTagName&lt;/code&gt;, except it returns a new type: &lt;code&gt;NodeListOf&lt;/code&gt;. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing &lt;code&gt;NodeListOf&amp;lt;E&amp;gt;&lt;/code&gt; with &lt;code&gt;E[]&lt;/code&gt; would result in a very similar user experience. &lt;code&gt;NodeListOf&lt;/code&gt; only implements the following properties and methods: &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;item(index)&lt;/code&gt;, &lt;code&gt;forEach((value, key, parent) =&amp;gt; void)&lt;/code&gt; , and numeric indexing. Additionally, this method returns a list of &lt;em&gt;elements&lt;/em&gt;, not &lt;em&gt;nodes&lt;/em&gt;, which is what &lt;code&gt;NodeList&lt;/code&gt; was returning from the &lt;code&gt;.childNodes&lt;/code&gt; method. While this may appear as a discrepancy, take note that interface &lt;code&gt;Element&lt;/code&gt; extends from &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">El modo de &lt;code&gt;react&lt;/code&gt; emitir&amp;aacute; &lt;code&gt;React.createElement&lt;/code&gt; , no necesita pasar por una transformaci&amp;oacute;n JSX antes de su uso, y la salida tendr&amp;aacute; una extensi&amp;oacute;n de archivo &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target state="translated">Las propiedades de &lt;code&gt;ref&lt;/code&gt; erencia y &lt;code&gt;key&lt;/code&gt; aparecer&amp;aacute;n con los tipos correctos en todos los componentes.</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target state="translated">La propiedad &lt;code&gt;ref&lt;/code&gt; est&amp;aacute; correctamente prohibida en instancias de componentes de funci&amp;oacute;n sin estado</target>
        </trans-unit>
        <trans-unit id="ac59872f32d7b3a719d54a776ba1d5030bee34ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target state="translated">La configuraci&amp;oacute;n de &lt;code&gt;rootDir&lt;/code&gt; , si no se establece expl&amp;iacute;citamente, toma el directorio que contiene el archivo &lt;code&gt;tsconfig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8756ccc79f64c7c4f7907edf57709c722c3dc27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the &lt;em&gt;strict mode family&lt;/em&gt; options, which are outlined below. You can then turn off individual strict mode family checks as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target state="translated">La opci&amp;oacute;n de &lt;code&gt;target&lt;/code&gt; (que permite a los usuarios cambiar de &lt;code&gt;es5&lt;/code&gt; a &lt;code&gt;es3&lt;/code&gt; , &lt;code&gt;es2015&lt;/code&gt; , &lt;code&gt;esnext&lt;/code&gt; , etc.)</target>
        </trans-unit>
        <trans-unit id="d58e04ff8c5c532dba7b8207798261684e83b514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; setting changes which JS features are downleveled and which are left intact. For example, an arrow function &lt;code&gt;() =&amp;gt; this&lt;/code&gt; will be turned into an equivalent &lt;code&gt;function&lt;/code&gt; expression if &lt;code&gt;target&lt;/code&gt; is ES5 or lower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target state="translated">El &lt;code&gt;this&lt;/code&gt; tipo tambi&amp;eacute;n es &amp;uacute;til con los tipos de intersecci&amp;oacute;n en la descripci&amp;oacute;n de las bibliotecas (por ejemplo Ember.js) que los patrones de uso de estilo mixin para describir la herencia:</target>
        </trans-unit>
        <trans-unit id="22032c123849dac540221c1f0c198bc84d0e5030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsconfig.json&lt;/code&gt; Schema can be found at &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;the JSON Schema Store&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target state="translated">El indicador &lt;code&gt;useDefineForClassFields&lt;/code&gt; y el modificador &lt;code&gt;declare&lt;/code&gt; Property</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">El &lt;em&gt;descriptor de propiedad&lt;/em&gt; del miembro.</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target state="translated">El &lt;em&gt;operador de fusi&amp;oacute;n nula&lt;/em&gt; es otra caracter&amp;iacute;stica pr&amp;oacute;xima de ECMAScript que va de la mano con el encadenamiento opcional, y que nuestro equipo ha estado involucrado en promover en TC39.</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes" xml:space="preserve">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target state="translated">La iteraci&amp;oacute;n &lt;code&gt;AsyncIterator&lt;/code&gt; introduce un AsyncIterator , que es similar a &lt;code&gt;Iterator&lt;/code&gt; . La diferencia radica en el hecho de que los m&amp;eacute;todos &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; y &lt;code&gt;throw&lt;/code&gt; de un &lt;code&gt;AsyncIterator&lt;/code&gt; devuelven una &lt;code&gt;Promise&lt;/code&gt; para el resultado de la iteraci&amp;oacute;n, en lugar del resultado en s&amp;iacute;. Esto permite que la persona que llama se inscriba en una notificaci&amp;oacute;n asincr&amp;oacute;nica para el momento en el que &lt;code&gt;AsyncIterator&lt;/code&gt; ha avanzado hasta el punto de producir un valor. Un &lt;code&gt;AsyncIterator&lt;/code&gt; tiene la siguiente forma:</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264fd8a4a9ece4731967069d64f52539be927716" translate="yes" xml:space="preserve">
          <source>The Declaration Files section is broken down into the following sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7ab3e11b9b6277a216f46b871ce84ce2b9abe1" translate="yes" xml:space="preserve">
          <source>The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes" xml:space="preserve">
          <source>The Examples</source>
          <target state="translated">Los ejemplos</target>
        </trans-unit>
        <trans-unit id="6e513416df8e3dfac45e1c52226655ef81089278" translate="yes" xml:space="preserve">
          <source>The Handbook also isn&amp;rsquo;t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript&amp;rsquo;s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven&amp;rsquo;t read about yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8fc72f4ed0ac1173879adc908fcb0666497c3e" translate="yes" xml:space="preserve">
          <source>The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won&amp;rsquo;t be covered in order to keep things short.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target state="translated">El impacto del ES6 en las firmas de llamada de los módulos</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Plugins</source>
          <target state="translated">El impacto del ES6 en los enchufes de los módulos</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes" xml:space="preserve">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target state="translated">El protocolo Iterator tambi&amp;eacute;n define el destino de algunas de las caracter&amp;iacute;sticas de &lt;code&gt;for..of&lt;/code&gt; como for..of y spread operator y la matriz descansa en asignaciones de desestructuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes" xml:space="preserve">
          <source>The JSX result type</source>
          <target state="translated">El tipo de resultado JSX</target>
        </trans-unit>
        <trans-unit id="2d7cc01d800025ab217a381f554be9b732cc9fcf" translate="yes" xml:space="preserve">
          <source>The JavaScript output is still the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318584735a5f4a0cd6e19d4529dc37491fd1acf3" translate="yes" xml:space="preserve">
          <source>The TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c164a656b844ad909a272419ed0cbe9548f88f5" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5f2e3eae34731098e1b7b55bd45c047f7f4695" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target state="translated">El compilador de TypeScript tiene un conjunto de indicadores adicionales para &lt;em&gt;informar&lt;/em&gt; al compilador de las transformaciones que se espera que ocurran en las fuentes para generar el resultado final.</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target state="translated">El compilador de TypeScript admite la declaraci&amp;oacute;n de dichas asignaciones mediante la propiedad &lt;code&gt;&quot;paths&quot;&lt;/code&gt; en los archivos &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target state="translated">El compilador de TypeScript admite la declaraci&amp;oacute;n de dichas asignaciones mediante la propiedad &lt;code&gt;&quot;paths&quot;&lt;/code&gt; en los archivos &lt;code&gt;tsconfig.json&lt;/code&gt; . Aqu&amp;iacute; hay un ejemplo de c&amp;oacute;mo especificar la propiedad &lt;code&gt;&quot;paths&quot;&lt;/code&gt; para &lt;code&gt;jquery&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target state="translated">El compilador de TypeScript inyectar&amp;aacute; informaci&amp;oacute;n de tipo en tiempo de dise&amp;ntilde;o utilizando el decorador &lt;code&gt;@Reflect.metadata&lt;/code&gt; . Podr&amp;iacute;a considerarlo el equivalente del siguiente TypeScript:</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target state="translated">El compilador de TypeScript transpondrá para...de los arreglos a JavaScript idiomático ES3/ES5 cuando apunte a esas versiones:</target>
        </trans-unit>
        <trans-unit id="7c695dd66f4a120dfae2df4de90b84e627a92bcc" translate="yes" xml:space="preserve">
          <source>The TypeScript playground can show you the &lt;code&gt;.d.ts&lt;/code&gt; equivalent for JavaScript code. You can &lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA&quot;&gt;try it yourself here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b307cc503023513bc14bb0a27ac57aa8f44ce9" translate="yes" xml:space="preserve">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target state="translated">&amp;iexcl;El patio de juegos de TypeScript ha recibido una actualizaci&amp;oacute;n muy necesaria con una nueva y pr&amp;aacute;ctica funcionalidad! El nuevo parque infantil es en gran parte un tenedor de &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt; &amp;lsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;mecanografiado parque infantil&lt;/a&gt; miembros de la comunidad que han estado utilizando cada vez m&amp;aacute;s. &amp;iexcl;Le debemos a Artem un gran agradecimiento por ayudarnos aqu&amp;iacute;!</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes" xml:space="preserve">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target state="translated">El compilador TypeSript emite algunos ayudantes como &lt;code&gt;__extends&lt;/code&gt; cuando es necesario. Los ayudantes se emiten en cada archivo en el que se hace referencia. Si desea consolidar todos los ayudantes en un solo lugar, o anular el comportamiento predeterminado, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; para indicar al compilador que no los emita.</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes" xml:space="preserve">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target state="translated">El c&amp;oacute;digo anterior resultar&amp;aacute; en un error ya que no puede dividir una cadena por un n&amp;uacute;mero. La salida, cuando se usa la opci&amp;oacute;n de &lt;code&gt;preserve&lt;/code&gt; , se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes" xml:space="preserve">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target state="translated">La soluci&amp;oacute;n anterior funcionar&amp;aacute; siempre que tenga una propiedad com&amp;uacute;n entre &lt;code&gt;squareOptions&lt;/code&gt; y &lt;code&gt;SquareConfig&lt;/code&gt; . En este ejemplo, fue el &lt;code&gt;width&lt;/code&gt; la propiedad . Sin embargo, fallar&amp;aacute; si la variable no tiene ninguna propiedad de objeto com&amp;uacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes" xml:space="preserve">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target state="translated">El acto de introducir un nuevo nombre en un &amp;aacute;mbito m&amp;aacute;s anidado se denomina &lt;em&gt;sombreado&lt;/em&gt; . Es un arma de doble filo, ya que puede introducir ciertos errores por s&amp;iacute; solo en caso de sombreado accidental, al mismo tiempo que previene ciertos errores. Por ejemplo, imagina que hemos escrito nuestra funci&amp;oacute;n &lt;code&gt;sumMatrix&lt;/code&gt; anterior usando las variables &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes" xml:space="preserve">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target state="translated">La ventaja de las propiedades opcionales es que puede describir estas posibles propiedades disponibles y al mismo tiempo evitar el uso de propiedades que no forman parte de la interfaz. Por ejemplo, si hubi&amp;eacute;ramos escrito mal el nombre de la propiedad de &lt;code&gt;color&lt;/code&gt; en &lt;code&gt;createSquare&lt;/code&gt; , obtendr&amp;iacute;amos un mensaje de error inform&amp;aacute;ndonos:</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes" xml:space="preserve">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target state="translated">La alternativa era, en cambio, reescribir el c&amp;oacute;digo para que el lenguaje pudiera analizarlo, pero esto no es conveniente.</target>
        </trans-unit>
        <trans-unit id="99e538489907af6acf36979924fc373420776d09" translate="yes" xml:space="preserve">
          <source>The answer is that you can&amp;rsquo;t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes" xml:space="preserve">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target state="translated">La respuesta es proporcionar varios tipos de funciones para la misma funci&amp;oacute;n como una lista de sobrecargas. Esta lista es la que utilizar&amp;aacute; el compilador para resolver las llamadas a funciones. &lt;code&gt;pickCard&lt;/code&gt; una lista de sobrecargas que describa lo que acepta nuestra pickCard y lo que devuelve.</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes" xml:space="preserve">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">El argumento puede ser una ruta de archivo a un archivo de configuraci&amp;oacute;n JSON v&amp;aacute;lido o una ruta de directorio a un directorio que contenga un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes" xml:space="preserve">
          <source>The as operator</source>
          <target state="translated">El como operador</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes" xml:space="preserve">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target state="translated">La regla b&amp;aacute;sica para el sistema de tipos estructurales de TypeScript es que &lt;code&gt;x&lt;/code&gt; es compatible con &lt;code&gt;y&lt;/code&gt; si &lt;code&gt;y&lt;/code&gt; tiene al menos los mismos miembros que &lt;code&gt;x&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c55521452311c3ac39fa2cd2823a7857ecfdacde" translate="yes" xml:space="preserve">
          <source>The best part about the &lt;em&gt;lib.dom.d.ts&lt;/em&gt; type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the &lt;code&gt;HTMLElement&lt;/code&gt; interface is documented by this &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement&quot;&gt;HTMLElement page&lt;/a&gt; on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the &lt;a href=&quot;https://www.w3.org/TR/html52/dom.html#htmlelement&quot;&gt;W3C Recommendation for HTMLElement&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes" xml:space="preserve">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; to get the string &lt;code&gt;&quot;Red&quot;&lt;/code&gt;.</source>
          <target state="translated">La advertencia es que las enumeraciones inicializadas en cadena no se pueden asignar de forma inversa para obtener el nombre del miembro de enumeraci&amp;oacute;n original. En otras palabras, no puede escribir &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; para obtener la cadena &lt;code&gt;&quot;Red&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes" xml:space="preserve">
          <source>The character set of the input files.</source>
          <target state="translated">El conjunto de caracteres de los archivos de entrada.</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes" xml:space="preserve">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target state="translated">La clasificaci&amp;oacute;n se puede personalizar a&amp;uacute;n m&amp;aacute;s cambiando la configuraci&amp;oacute;n de fuente y color para la configuraci&amp;oacute;n de fuente y color de &lt;code&gt;VB XML&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;Options&lt;/code&gt; -&amp;gt; &lt;code&gt;Environment&lt;/code&gt; -&amp;gt; P&amp;aacute;gina de &lt;code&gt;Fonts and Colors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a2f1531f75511fb5bed9929c49deede45519a7c" translate="yes" xml:space="preserve">
          <source>The closest equivalent to &lt;code&gt;data&lt;/code&gt; is a union of types with discriminant properties, normally called discriminated unions in TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bd7d1cbccc678687cdc4d4130a670d13f976d9" translate="yes" xml:space="preserve">
          <source>The closest equivalent to &lt;code&gt;newtype&lt;/code&gt; is a &lt;em&gt;tagged intersection&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes" xml:space="preserve">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target state="translated">El ejemplo de c&amp;oacute;digo comienza con las dos clases que actuar&amp;aacute;n como nuestros mixins. Puede ver que cada uno se centra en una actividad o capacidad en particular. M&amp;aacute;s tarde, los mezclaremos para formar una nueva clase de ambas capacidades.</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes" xml:space="preserve">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target state="translated">La versión pragmática del comentario puede utilizarse así (en TypeScript 2.8):</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes" xml:space="preserve">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target state="translated">El compilador normalmente puede averiguar el tipo de &lt;code&gt;this&lt;/code&gt; cuando tiene alg&amp;uacute;n contexto con el que trabajar. Cuando no es as&amp;iacute;, puede especificar expl&amp;iacute;citamente el tipo de &lt;code&gt;this&lt;/code&gt; con &lt;code&gt;@this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes" xml:space="preserve">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">El compilador verifica que el &lt;code&gt;manufacturer&lt;/code&gt; y el &lt;code&gt;model&lt;/code&gt; o sean realmente propiedades en &lt;code&gt;Car&lt;/code&gt; . El ejemplo presenta un par de nuevos operadores de tipo. Primero est&amp;aacute; &lt;code&gt;keyof T&lt;/code&gt; , el &lt;strong&gt;operador de consulta de tipo &amp;iacute;ndice&lt;/strong&gt; . Para cualquier tipo &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;keyof T&lt;/code&gt; es la uni&amp;oacute;n de los nombres conocidos, de propiedad p&amp;uacute;blica de &lt;code&gt;T&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes" xml:space="preserve">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target state="translated">El compilador verifica que las variables est&amp;eacute;n definitivamente asignadas realizando un &lt;em&gt;an&amp;aacute;lisis de tipo basado en el flujo de control&lt;/em&gt; . Consulte m&amp;aacute;s adelante para obtener m&amp;aacute;s detalles sobre este tema.</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes" xml:space="preserve">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target state="translated">El compilador detecta si cada m&amp;oacute;dulo se utiliza en el JavaScript emitido. Si un identificador de m&amp;oacute;dulo solo se usa como parte de anotaciones de tipo y nunca como una expresi&amp;oacute;n, entonces no se emite ninguna llamada &lt;code&gt;require&lt;/code&gt; para ese m&amp;oacute;dulo. Esta elisi&amp;oacute;n de referencias no utilizadas es una buena optimizaci&amp;oacute;n del rendimiento y tambi&amp;eacute;n permite la carga opcional de esos m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes" xml:space="preserve">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target state="translated">El compilador infiere funciones de constructor en funci&amp;oacute;n de las asignaciones de esta propiedad, pero puede hacer que la verificaci&amp;oacute;n sea m&amp;aacute;s estricta y las sugerencias mejor si agrega una etiqueta &lt;code&gt;@constructor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes" xml:space="preserve">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target state="translated">El compilador realiza un pase de preprocesamiento de los archivos de entrada para resolver todas las directivas de referencia de la barra triple.Durante este proceso,se añaden archivos adicionales a la compilación.</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes" xml:space="preserve">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target state="translated">El compilador ordenará automáticamente el archivo de salida basándose en las etiquetas de referencia presentes en los archivos.También puede especificar cada archivo individualmente:</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes" xml:space="preserve">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target state="translated">El compilador generar&amp;aacute; un sencillo &lt;code&gt;for&lt;/code&gt; bucle para un &lt;code&gt;for..of&lt;/code&gt; bucle, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes" xml:space="preserve">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target state="translated">El compilador ahora resolver&amp;aacute; &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; para &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; con fines de herramientas, lo que permitir&amp;aacute; el desarrollo de una manera independiente de la configuraci&amp;oacute;n regional sin comprometer el tiempo de dise&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes" xml:space="preserve">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">El compilador intentar&amp;aacute; encontrar un &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; y luego un &lt;code&gt;.d.ts&lt;/code&gt; con la ruta adecuada. Si no se pudo encontrar un archivo espec&amp;iacute;fico, el compilador buscar&amp;aacute; una &lt;em&gt;declaraci&amp;oacute;n de m&amp;oacute;dulo ambiental&lt;/em&gt; . Recuerde que estos deben declararse en un archivo &lt;code&gt;.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target state="translated">La configuración del archivo base se carga primero y luego es anulada por las del archivo de configuración heredado.</target>
        </trans-unit>
        <trans-unit id="c6ca65192f8fe43f587bc1a3d765c8a0613852b7" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target state="translated">La configuración del archivo base se carga primero,y luego es anulada por las del archivo de configuración heredado.Si se encuentra una circularidad,informamos de un error.</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes" xml:space="preserve">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target state="translated">El constructor de una clase mixin (si existe) debe tener un solo par&amp;aacute;metro rest de tipo &lt;code&gt;any[]&lt;/code&gt; y debe usar el operador de propagaci&amp;oacute;n para pasar esos par&amp;aacute;metros como argumentos en una llamada &lt;code&gt;super(...args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes" xml:space="preserve">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target state="translated">La idea central del patr&amp;oacute;n es que la declaraci&amp;oacute;n &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; nos da acceso a los tipos expuestos por el m&amp;oacute;dulo. El cargador de m&amp;oacute;dulos se invoca (a trav&amp;eacute;s de &lt;code&gt;require&lt;/code&gt; ) din&amp;aacute;micamente, como se muestra en los bloques &lt;code&gt;if&lt;/code&gt; a continuaci&amp;oacute;n. Esto aprovecha la optimizaci&amp;oacute;n de elisi&amp;oacute;n de referencia para que el m&amp;oacute;dulo solo se cargue cuando sea necesario. Para que este patr&amp;oacute;n funcione, es importante que el s&amp;iacute;mbolo definido a trav&amp;eacute;s de una &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n solo se use en posiciones de tipo (es decir, nunca en una posici&amp;oacute;n que se emitir&amp;iacute;a en JavaScript).</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target state="translated">El &lt;code&gt;tsconfig.json&lt;/code&gt; correspondiente se ver&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes" xml:space="preserve">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target state="translated">La combinaci&amp;oacute;n de declaraci&amp;oacute;n de &lt;code&gt;Animals&lt;/code&gt; en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="70be9c837970cfde212fa7a4b8b2cbb0b2ae3596" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;const enum&lt;/code&gt; behavior is to convert any &lt;code&gt;Album.Something&lt;/code&gt; to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes" xml:space="preserve">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target state="translated">El comportamiento predeterminado del compilador de TypeScript es seguir emitiendo archivos .js si hubo errores de tipo (por ejemplo, un intento de asignar una &lt;code&gt;string&lt;/code&gt; a un &lt;code&gt;number&lt;/code&gt; ). Esto puede ser indeseable en servidores de compilaci&amp;oacute;n u otros escenarios en los que solo se desea la salida de una compilaci&amp;oacute;n &quot;limpia&quot;. El nuevo indicador &lt;code&gt;noEmitOnError&lt;/code&gt; evita que el compilador emita c&amp;oacute;digo .js si hubiera alg&amp;uacute;n error.</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes" xml:space="preserve">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target state="translated">Las propiedades de default-ed se infieren del tipo de propiedad &lt;code&gt;defaultProps&lt;/code&gt; . Si se agrega una anotaci&amp;oacute;n de tipo expl&amp;iacute;cita, por ejemplo, &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; el compilador no podr&amp;aacute; identificar qu&amp;eacute; propiedades tienen valores predeterminados (ya que el tipo de &lt;code&gt;defaultProps&lt;/code&gt; incluye todas las propiedades de &lt;code&gt;Props&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes" xml:space="preserve">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target state="translated">La aserci&amp;oacute;n de asignaci&amp;oacute;n definida es una caracter&amp;iacute;stica que permite a &lt;code&gt;!&lt;/code&gt; debe colocarse despu&amp;eacute;s de las declaraciones de propiedades y variables de instancia para transmitir a TypeScript que una variable est&amp;aacute; efectivamente asignada para todos los efectos, incluso si los an&amp;aacute;lisis de TypeScript no pueden detectarlo.</target>
        </trans-unit>
        <trans-unit id="2f7101961a50144f9479602939dcc578c0e8ab45" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;super-greeter&amp;rdquo;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c352ae274c34e758530bef83a57917473d389588" translate="yes" xml:space="preserve">
          <source>The definition for this method is (I have omitted the &lt;em&gt;deprecated&lt;/em&gt; definition):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259a9b27dc71c892950403f889ab6e29b1d0b36a" translate="yes" xml:space="preserve">
          <source>The definition for this method is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes" xml:space="preserve">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target state="translated">La propiedad distributiva de los tipos condicionales se puede utilizar convenientemente para &lt;em&gt;filtrar&lt;/em&gt; tipos de uni&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="6d56b3f7891cbe61db5bb0920e006dd158d21b55" translate="yes" xml:space="preserve">
          <source>The downside to using babel is that you don&amp;rsquo;t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes" xml:space="preserve">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target state="translated">El dual de esto son &lt;em&gt;los tipos de acceso indexados&lt;/em&gt; , tambi&amp;eacute;n llamados &lt;em&gt;tipos de b&amp;uacute;squeda&lt;/em&gt; . Sint&amp;aacute;cticamente, se ven exactamente como un acceso a elementos, pero est&amp;aacute;n escritos como tipos:</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes" xml:space="preserve">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de recordar si usar &lt;code&gt;readonly&lt;/code&gt; o &lt;code&gt;const&lt;/code&gt; es preguntar si lo est&amp;aacute; usando en una variable o en una propiedad. Las variables usan &lt;code&gt;const&lt;/code&gt; mientras que las propiedades usan &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes" xml:space="preserve">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target state="translated">La forma más fácil de ver cómo funcionan las interfaces es empezar con un simple ejemplo:</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes" xml:space="preserve">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target state="translated">El tipo de atributo del elemento se utiliza para comprobar los atributos en el JSX.Se admiten propiedades opcionales y obligatorias.</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes" xml:space="preserve">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target state="translated">El tipo de instancia del elemento es interesante porque debe ser asignable a &lt;code&gt;JSX.ElementClass&lt;/code&gt; o resultar&amp;aacute; en un error. Por defecto, &lt;code&gt;JSX.ElementClass&lt;/code&gt; es &lt;code&gt;{}&lt;/code&gt; , pero se puede aumentar para limitar el uso de JSX solo a aquellos tipos que se ajustan a la interfaz adecuada.</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes" xml:space="preserve">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target state="translated">La elipsis también se utiliza en el tipo de función con parámetros de reposo:</target>
        </trans-unit>
        <trans-unit id="4206f608291d0b44e696abdeb0d5bfe75f33351e" translate="yes" xml:space="preserve">
          <source>The emitted JavaScript from TypeScript is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes" xml:space="preserve">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target state="translated">El miembro del &quot;enum&quot; está inicializado con una expresión constante &quot;enum&quot;.Una expresión constante enum es un subconjunto de expresiones TypeScript que pueden ser evaluadas completamente en tiempo de compilación.Una expresión es una expresión constante enum si lo es:</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes" xml:space="preserve">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; instead of &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de f&amp;aacute;brica exacta utilizada por la opci&amp;oacute;n del compilador &lt;code&gt;jsx: react&lt;/code&gt; es configurable. Se puede configurar usando la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;jsxFactory&lt;/code&gt; , o un pragma de comentario &lt;code&gt;@jsx&lt;/code&gt; en l&amp;iacute;nea para configurarlo por archivo. Por ejemplo, si configura &lt;code&gt;jsxFactory&lt;/code&gt; en &lt;code&gt;createElement&lt;/code&gt; , &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; se emitir&amp;aacute; como &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; lugar de &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes" xml:space="preserve">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target state="translated">El ejemplo tambi&amp;eacute;n muestra c&amp;oacute;mo anular m&amp;eacute;todos en la clase base con m&amp;eacute;todos especializados para la subclase. Aqu&amp;iacute;, tanto &lt;code&gt;Snake&lt;/code&gt; como &lt;code&gt;Horse&lt;/code&gt; crean un m&amp;eacute;todo de &lt;code&gt;move&lt;/code&gt; que anula el &lt;code&gt;move&lt;/code&gt; de &lt;code&gt;Animal&lt;/code&gt; , d&amp;aacute;ndole una funcionalidad espec&amp;iacute;fica para cada clase. Tenga en cuenta que aunque &lt;code&gt;tom&lt;/code&gt; se declara como &lt;code&gt;Animal&lt;/code&gt; , dado que su valor es &lt;code&gt;Horse&lt;/code&gt; , llamar a &lt;code&gt;tom.move(34)&lt;/code&gt; llamar&amp;aacute; al m&amp;eacute;todo de reemplazo en &lt;code&gt;Horse&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes" xml:space="preserve">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target state="translated">El ejemplo usa una funci&amp;oacute;n anidada aqu&amp;iacute; porque el compilador no puede eliminar nulos dentro de una funci&amp;oacute;n anidada (excepto las expresiones de funci&amp;oacute;n invocadas inmediatamente). Eso es porque no puede rastrear todas las llamadas a la funci&amp;oacute;n anidada, especialmente si la devuelve desde la funci&amp;oacute;n externa. Sin saber d&amp;oacute;nde se llama a la funci&amp;oacute;n, no puede saber cu&amp;aacute;l ser&amp;aacute; el tipo de &lt;code&gt;name&lt;/code&gt; en el momento en que se ejecute el cuerpo.</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes" xml:space="preserve">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">La expresión para el decorador de accesorios se llamará como una función en tiempo de ejecución,con los siguientes tres argumentos:</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes" xml:space="preserve">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target state="translated">La expresión para el decorador de la clase se llamará como una función en tiempo de ejecución,con el constructor de la clase decorada como único argumento.</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes" xml:space="preserve">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">La expresión para el método decorador se llamará como una función en tiempo de ejecución,con los siguientes tres argumentos:</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes" xml:space="preserve">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">La expresión para el parámetro decorador se llamará como una función en tiempo de ejecución,con los siguientes tres argumentos:</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes" xml:space="preserve">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target state="translated">La expresión para el decorador de la propiedad se llamará como una función en tiempo de ejecución,con los siguientes dos argumentos:</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes" xml:space="preserve">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target state="translated">Las expresiones para cada decorador se evalúan de arriba a abajo.</target>
        </trans-unit>
        <trans-unit id="8ca9fb0afa1d2d7ae4017f7909cdf00932efdab7" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">La f&amp;aacute;brica elegida tambi&amp;eacute;n afectar&amp;aacute; d&amp;oacute;nde se busca el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; (para obtener informaci&amp;oacute;n de verificaci&amp;oacute;n de tipo) antes de volver al global. Si la f&amp;aacute;brica se define como &lt;code&gt;React.createElement&lt;/code&gt; (el valor predeterminado), el compilador buscar&amp;aacute; &lt;code&gt;React.JSX&lt;/code&gt; antes de buscar un &lt;code&gt;JSX&lt;/code&gt; global . Si la f&amp;aacute;brica se define como &lt;code&gt;h&lt;/code&gt; , buscar&amp;aacute; &lt;code&gt;h.JSX&lt;/code&gt; antes de un &lt;code&gt;JSX&lt;/code&gt; global .</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes" xml:space="preserve">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target state="translated">La primera asignaci&amp;oacute;n ahora es un error. Efectivamente, &lt;code&gt;T&lt;/code&gt; es contravariante en &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; porque se usa solo en posiciones de par&amp;aacute;metros de tipo de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes" xml:space="preserve">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target state="translated">La primera asignaci&amp;oacute;n est&amp;aacute; permitida en el modo de verificaci&amp;oacute;n de tipo predeterminado, pero marcada como un error en el modo de tipos de funci&amp;oacute;n estricta. Intuitivamente, el modo predeterminado permite la asignaci&amp;oacute;n porque &lt;em&gt;posiblemente&lt;/em&gt; sea &lt;em&gt;correcto&lt;/em&gt; , mientras que el modo de tipos de funci&amp;oacute;n estricta lo convierte en un error porque no es &lt;em&gt;probadamente correcto&lt;/em&gt; . En cualquier modo, la tercera asignaci&amp;oacute;n es un error porque &lt;em&gt;nunca&lt;/em&gt; es s&amp;oacute;lida.</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes" xml:space="preserve">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target state="translated">La primera es que los miembros de la enumeraci&amp;oacute;n tambi&amp;eacute;n se convierten en tipos. Por ejemplo, podemos decir que ciertos miembros &lt;em&gt;solo&lt;/em&gt; pueden tener el valor de un miembro enum:</target>
        </trans-unit>
        <trans-unit id="f1597b8ab64d75c9fce4d84614baa27283e2feea" translate="yes" xml:space="preserve">
          <source>The first is that the &lt;em&gt;empty type&lt;/em&gt; seems to defy expectation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82698594e79b48b6fa7cb117ffc18b411c17a2c9" translate="yes" xml:space="preserve">
          <source>The first line of the TypeScript code uses a global variable &lt;code&gt;document&lt;/code&gt;. Inspecting the variable shows it is defined by the &lt;code&gt;Document&lt;/code&gt; interface from the &lt;em&gt;lib.dom.d.ts&lt;/em&gt; file. The code snippet contains calls to two methods, &lt;code&gt;getElementById&lt;/code&gt; and &lt;code&gt;createElement&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes" xml:space="preserve">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target state="translated">La primera l&amp;iacute;nea le dice a Visual Studio que ejecute la tarea 'predeterminada' despu&amp;eacute;s de que finalice la compilaci&amp;oacute;n. Tambi&amp;eacute;n ejecutar&amp;aacute; la tarea 'limpiar' cuando le pida a Visual Studio que limpie la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes" xml:space="preserve">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target state="translated">El primer paso para escribir los atributos de verificaci&amp;oacute;n es determinar el &lt;em&gt;tipo de atributos&lt;/em&gt; del &lt;em&gt;elemento&lt;/em&gt; . Esto es ligeramente diferente entre elementos intr&amp;iacute;nsecos y basados ​​en valores.</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes" xml:space="preserve">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href=&quot;declaration-merging&quot;&gt;declaration merging&lt;/a&gt;.</source>
          <target state="translated">Lo primero que puede notar en lo anterior es que en lugar de intentar extender &lt;code&gt;Disposable&lt;/code&gt; y &lt;code&gt;Activatable&lt;/code&gt; en la clase &lt;code&gt;SmartObject&lt;/code&gt; , los extendemos en la interfaz &lt;code&gt;SmartObject&lt;/code&gt; . &lt;code&gt;SmartObject&lt;/code&gt; interfaz SmartObject se mezclar&amp;aacute; con la clase &lt;code&gt;SmartObject&lt;/code&gt; debido a la &lt;a href=&quot;declaration-merging&quot;&gt;combinaci&amp;oacute;n de declaraciones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes" xml:space="preserve">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target state="translated">El primer tipo de modelos de la firma afirmaci&amp;oacute;n de la forma en que el Nodo &lt;code&gt;assert&lt;/code&gt; funci&amp;oacute;n funciona. Asegura que cualquier condici&amp;oacute;n que se est&amp;eacute; verificando debe ser verdadera para el resto del alcance contenedor.</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes" xml:space="preserve">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target state="translated">La flexibilidad de &lt;code&gt;rootDirs&lt;/code&gt; no se limita a especificar una lista de directorios de origen f&amp;iacute;sicos que se fusionan l&amp;oacute;gicamente. La matriz suministrada puede incluir cualquier n&amp;uacute;mero de nombres de directorio arbitrarios ad hoc, independientemente de si existen o no. Esto permite al compilador capturar caracter&amp;iacute;sticas sofisticadas de agrupaci&amp;oacute;n y tiempo de ejecuci&amp;oacute;n, como la inclusi&amp;oacute;n condicional y los complementos de carga espec&amp;iacute;ficos del proyecto, de una manera segura.</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target state="translated">El siguiente ejemplo demuestra cómo el hecho de que haya varios candidatos para el mismo tipo de variable en posiciones co-variantes hace que se infiera un tipo de unión:</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes" xml:space="preserve">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">El siguiente es un ejemplo de un decorador de clase ( &lt;code&gt;@sealed&lt;/code&gt; ) aplicado a la clase &lt;code&gt;Greeter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes" xml:space="preserve">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">El siguiente es un ejemplo de un decorador de m&amp;eacute;todos ( &lt;code&gt;@enumerable&lt;/code&gt; ) aplicado a un m&amp;eacute;todo en la clase &lt;code&gt;Greeter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes" xml:space="preserve">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">El siguiente es un ejemplo de un decorador de par&amp;aacute;metros ( &lt;code&gt;@required&lt;/code&gt; ) aplicado al par&amp;aacute;metro de un miembro de la clase &lt;code&gt;Greeter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes" xml:space="preserve">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target state="translated">El siguiente es un ejemplo de un decorador de &lt;code&gt;@configurable&lt;/code&gt; ( @configurable ) aplicado a un miembro de la clase &lt;code&gt;Point&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78b3414d6c6279a9a7d36fd763a26f60ecb80162" translate="yes" xml:space="preserve">
          <source>The following tags have open issues to support them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb147db5e9640faf772e0ff23a000f02eb6a9092" translate="yes" xml:space="preserve">
          <source>The following types have built-in predicates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target state="translated">La variable global &lt;code&gt;foo&lt;/code&gt; contiene el n&amp;uacute;mero de widgets presentes.</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target state="translated">La variable global &lt;code&gt;myLib&lt;/code&gt; tiene una funci&amp;oacute;n &lt;code&gt;makeGreeting&lt;/code&gt; para crear saludos y una propiedad &lt;code&gt;numberOfGreetings&lt;/code&gt; que indica el n&amp;uacute;mero de saludos realizados hasta el momento.</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes" xml:space="preserve">
          <source>The guide is broken down into the following sections.</source>
          <target state="translated">La guía se divide en las siguientes secciones.</target>
        </trans-unit>
        <trans-unit id="a089c228c5ebe31ca69e3f47fd0070706f6094d2" translate="yes" xml:space="preserve">
          <source>The handbook is split into two sections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604cbcf9b1655f8dee840e0d141897f7e64d6d7e" translate="yes" xml:space="preserve">
          <source>The handbook reference is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes" xml:space="preserve">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target state="translated">El proceso de inferencia es bastante sencillo aqu&amp;iacute; porque &lt;code&gt;getDisplayName&lt;/code&gt; y &lt;code&gt;getLength&lt;/code&gt; usan tipos a los que se puede hacer referencia f&amp;aacute;cilmente. Sin embargo, en TypeScript 3.3 y versiones anteriores, las funciones gen&amp;eacute;ricas como &lt;code&gt;compose&lt;/code&gt; no funcionaban tan bien cuando se pasaban otras funciones gen&amp;eacute;ricas.</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes" xml:space="preserve">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target state="translated">El tipo de retorno inferido de una función puede ser un tipo declarado localmente dentro de la función.No es posible que los llamantes de la función hagan referencia a un tipo local de este tipo,pero por supuesto que se puede hacer coincidir estructuralmente.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="78b1c8f9ed0f4d721027df616536d2627988df99" translate="yes" xml:space="preserve">
          <source>The inferred value for &lt;code&gt;rootDir&lt;/code&gt; is the longest common path of all non-declaration input files, which in this case is &lt;code&gt;core/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes" xml:space="preserve">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target state="translated">El lado de la instancia de una declaración de clase ambiental puede extenderse mediante una declaración de interfaz El objeto constructor de la clase no está modificado.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes" xml:space="preserve">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">La intenci&amp;oacute;n de cualquier funci&amp;oacute;n que &lt;code&gt;never&lt;/code&gt; regresa es que nunca regrese. Indica que se lanz&amp;oacute; una excepci&amp;oacute;n, se produjo una condici&amp;oacute;n de error de detenci&amp;oacute;n o que el programa sali&amp;oacute;. Por ejemplo, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt; &lt;code&gt;process.exit(...)&lt;/code&gt; en &lt;code&gt;@types/node&lt;/code&gt; &lt;/a&gt; se especifica para devolver &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes" xml:space="preserve">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target state="translated">La interfaz La &lt;code&gt;LabeledValue&lt;/code&gt; es un nombre que ahora podemos usar para describir el requisito en el ejemplo anterior. Todav&amp;iacute;a representa tener una sola propiedad llamada &lt;code&gt;label&lt;/code&gt; que es de tipo &lt;code&gt;string&lt;/code&gt; . Tenga en cuenta que no tuvimos que decir expl&amp;iacute;citamente que el objeto que pasamos a &lt;code&gt;printLabel&lt;/code&gt; implementa esta interfaz como deber&amp;iacute;amos hacerlo en otros lenguajes. Aqu&amp;iacute;, solo importa la forma. Si el objeto que pasamos a la funci&amp;oacute;n cumple con los requisitos enumerados, entonces est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes" xml:space="preserve">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target state="translated">La diferencia clave no est&amp;aacute; en la sintaxis, sino en la sem&amp;aacute;ntica, en la que ahora nos sumergiremos.</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes" xml:space="preserve">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target state="translated">El &amp;uacute;ltimo elemento de un tipo de tupla puede ser un elemento de descanso de la forma &lt;code&gt;...X&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un tipo de matriz. Un elemento de descanso indica que el tipo de tupla es abierto y puede tener cero o m&amp;aacute;s elementos adicionales del tipo de elemento de matriz. Por ejemplo, &lt;code&gt;[number, ...string[]]&lt;/code&gt; significa tuplas con un elemento &lt;code&gt;number&lt;/code&gt; seguido de cualquier n&amp;uacute;mero de elementos de &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea7d1078a9be532038ef2deef32790daf490bb8c" translate="yes" xml:space="preserve">
          <source>The last line of the code snippet is &lt;code&gt;app?.appendChild(p)&lt;/code&gt;. The previous, &lt;code&gt;document.getElementById&lt;/code&gt; , section detailed that the &lt;em&gt;optional chaining&lt;/em&gt; operator is used here because &lt;code&gt;app&lt;/code&gt; can potentially be null at runtime. The &lt;code&gt;appendChild&lt;/code&gt; method is defined by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1fa816d66a94a39a64dba4ddbbaa3fb384695f" translate="yes" xml:space="preserve">
          <source>The last line of the previous code sample would raise an error in TypeScript, but it doesn&amp;rsquo;t by default in a JS project. To enable errors in your JavaScript files add: &lt;code&gt;// @ts-check&lt;/code&gt; to the first line in your &lt;code&gt;.js&lt;/code&gt; files to have TypeScript raise it as an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3425f6446014efd7d54ccc807ba0bd462046777c" translate="yes" xml:space="preserve">
          <source>The latter style is more common but both are allowed, even in the same file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes" xml:space="preserve">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target state="translated">La disposición de sus archivos de declaración debería reflejar la disposición de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes" xml:space="preserve">
          <source>The library can then be used as an import within modules:</source>
          <target state="translated">La biblioteca puede utilizarse entonces como una importación dentro de los módulos:</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes" xml:space="preserve">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target state="translated">La siguiente lista resume qué construcciones son actualmente soportadas cuando se usan las anotaciones de JSDoc para proporcionar información de tipo en los archivos JavaScript.</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes" xml:space="preserve">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target state="translated">El lugar a utilizar para mostrar los mensajes de error,por ejemplo,en-us.</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes" xml:space="preserve">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target state="translated">La mayor&amp;iacute;a de este manual utiliza declaraciones &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5361e797afb54e7fafd11ab7165d6157098d98b" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under &lt;code&gt;node_modules&lt;/code&gt; and load JavaScript files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">La profundidad de dependencia m&amp;aacute;xima para buscar en node_modules y cargar archivos JavaScript. Solo se aplica con &lt;code&gt;--allowJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="617a4a49e4615a56e38ae287aca4e940a80853ed" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at &lt;a href=&quot;https://jsdoc.app&quot;&gt;jsdoc.app&lt;/a&gt;. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">El significado suele ser el mismo,o un superconjunto,del significado de la etiqueta dada en usejsdoc.org.El siguiente código describe las diferencias y da algún ejemplo de uso de cada etiqueta.</target>
        </trans-unit>
        <trans-unit id="942184e9d11609161fd758335e2cb598f79fd707" translate="yes" xml:space="preserve">
          <source>The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes" xml:space="preserve">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target state="translated">El nombre del m&amp;oacute;dulo se resuelve de la misma forma que los especificadores de m&amp;oacute;dulo en la &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n / &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n . Consulte &lt;a href=&quot;modules&quot;&gt;M&amp;oacute;dulos&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n. Luego, las declaraciones en un aumento se fusionan como si estuvieran declaradas en el mismo archivo que el original.</target>
        </trans-unit>
        <trans-unit id="e4ef072c2703c60524da107c05a2dfe78d02a391" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than TypeScript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">El soporte de m&amp;oacute;dulos en Javascript es mucho m&amp;aacute;s indulgente sint&amp;aacute;cticamente que el soporte de m&amp;oacute;dulos de Typescript. Se admiten la mayor&amp;iacute;a de combinaciones de asignaciones y declaraciones.</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes" xml:space="preserve">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">El tipo de datos m&amp;aacute;s b&amp;aacute;sico es el valor simple verdadero / falso, que JavaScript y TypeScript llaman valor &lt;code&gt;boolean&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="a03cd6c7e32b9f93ac936ffc0acd7964734f63ea" translate="yes" xml:space="preserve">
          <source>The most common case for learning how .d.ts files work is that you&amp;rsquo;re typing an npm package with no types. In that case, you can jump straight to &lt;a href=&quot;templates/module-d-ts&quot;&gt;Modules .d.ts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7640814a5033d876fc4ba4a5004fadadb312ca3" translate="yes" xml:space="preserve">
          <source>The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f7f6f667f2904bbc6c5b01fab0ba1c74724d50" translate="yes" xml:space="preserve">
          <source>The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export. Typescript can handle this for you, if you have &lt;a href=&quot;https://www.typescriptlang.org/tsconfig/#esModuleInterop&quot;&gt;&lt;code&gt;&quot;esModuleInterop&quot;: true&lt;/code&gt;&lt;/a&gt; in tsconfig.json.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes" xml:space="preserve">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target state="translated">El resultado más impactante de esta característica puede ser un poco sutil:con TypeScript 3.7,los usuarios pueden escribir bibliotecas en JavaScript anotado en JSDoc y apoyar a los usuarios de TypeScript.</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes" xml:space="preserve">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target state="translated">El ejemplo motivador es el patrón común de una función que toma una llamada de retorno y la invoca con algún número predecible (para el programador)pero desconocido (para el sistema de tipos)de argumentos:</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes" xml:space="preserve">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target state="translated">El nombre de un aumento de m&amp;oacute;dulo se resuelve utilizando el mismo conjunto de reglas que los especificadores de m&amp;oacute;dulo en &lt;code&gt;export&lt;/code&gt; declaraciones de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n y exportaci&amp;oacute;n . Las declaraciones en un aumento de m&amp;oacute;dulo se fusionan con cualquier declaraci&amp;oacute;n existente de la misma manera que lo har&amp;iacute;an si estuvieran declaradas en el mismo archivo.</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
          <target state="translated">El nombre del miembro.</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target state="translated">La nueva bandera &lt;code&gt;--showConfig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target state="translated">La nueva opci&amp;oacute;n del compilador &lt;code&gt;--strict&lt;/code&gt; representa la configuraci&amp;oacute;n recomendada de varias opciones de verificaci&amp;oacute;n de tipos. Espec&amp;iacute;ficamente, especificar - &lt;code&gt;--strict&lt;/code&gt; corresponde a especificar todas las siguientes opciones (y en el futuro puede incluir m&amp;aacute;s opciones):</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target state="translated">La nueva propiedad de &lt;code&gt;amd-dependency name&lt;/code&gt; permite pasar un nombre opcional para una dependencia de amd:</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target state="translated">La nueva etiqueta de &lt;code&gt;amd-module name&lt;/code&gt; permite pasar un nombre de m&amp;oacute;dulo opcional al compilador:</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target state="translated">El nuevo modificador &lt;code&gt;protected&lt;/code&gt; en clases funciona como lo hace en lenguajes familiares como C ++, C # y Java. Un miembro &lt;code&gt;protected&lt;/code&gt; de una clase es visible solo dentro de las subclases de la clase en la que est&amp;aacute; declarado:</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes" xml:space="preserve">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target state="translated">La nueva palabra clave de ES6 &lt;code&gt;let&lt;/code&gt; , ahora compatible con TypeScript, declara una variable con sem&amp;aacute;ntica de &quot;bloque&quot; m&amp;aacute;s intuitiva. Solo se puede hacer referencia a una variable &lt;code&gt;let&lt;/code&gt; despu&amp;eacute;s de su declaraci&amp;oacute;n, y tiene como &amp;aacute;mbito el bloque sint&amp;aacute;ctico donde se define:</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes" xml:space="preserve">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target state="translated">El nuevo nombre de f&amp;aacute;brica se usar&amp;aacute; para llamar a las funciones &lt;code&gt;createElement&lt;/code&gt; y &lt;code&gt;__spread&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes" xml:space="preserve">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target state="translated">Las nuevas funciones est&amp;aacute;n dise&amp;ntilde;adas de modo que se puedan utilizar tanto en el modo de comprobaci&amp;oacute;n nulo estricto como en el modo de comprobaci&amp;oacute;n de tipo regular. En particular, los tipos &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; se borran autom&amp;aacute;ticamente de los tipos de uni&amp;oacute;n en el modo de verificaci&amp;oacute;n de tipos normal (porque son subtipos de todos los dem&amp;aacute;s tipos), y el &lt;code&gt;!&lt;/code&gt; El operador de expresi&amp;oacute;n de aserci&amp;oacute;n no nula est&amp;aacute; permitido pero no tiene ning&amp;uacute;n efecto en el modo de verificaci&amp;oacute;n de tipo regular. Por lo tanto, los archivos de declaraci&amp;oacute;n que se actualizan para usar tipos nulos e indefinidos a&amp;uacute;n se pueden usar en el modo de verificaci&amp;oacute;n de tipos normal para compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="c30cd7e33232b4d2a28f205e7ae9088fbd691c02" translate="yes" xml:space="preserve">
          <source>The new handbook which is a work in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes" xml:space="preserve">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target state="translated">La nueva implementación también trae consigo mejoras en el rendimiento de la observación en el tsserver.La lógica del observador ha sido completamente reescrita para responder más rápido a los eventos de cambio.</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes" xml:space="preserve">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target state="translated">El nuevo m&amp;oacute;dulo &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exporta una forma de API similar a la del m&amp;oacute;dulo &lt;code&gt;Calculator&lt;/code&gt; original , pero no aumenta ning&amp;uacute;n objeto en el m&amp;oacute;dulo original. Aqu&amp;iacute; hay una prueba para nuestra clase ProgrammerCalculator:</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes" xml:space="preserve">
          <source>The new playground now supports many new options including:</source>
          <target state="translated">El nuevo patio de recreo ahora soporta muchas nuevas opciones,incluyendo:</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes" xml:space="preserve">
          <source>The nightlies are available on &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;.</source>
          <target state="translated">Las noches est&amp;aacute;n disponibles en &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes" xml:space="preserve">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target state="translated">La construcción nocturna actualmente no incluye la configuración completa del plugin,pero estamos trabajando en la publicación de un instalador sobre una base nocturna también.</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes" xml:space="preserve">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">El comportamiento anterior sigue siendo el mismo si se le da un directorio: el compilador intentar&amp;aacute; encontrar un archivo en el directorio llamado &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes" xml:space="preserve">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target state="translated">El orden de especificar las operaciones de propagaci&amp;oacute;n determina qu&amp;eacute; propiedades terminan en el objeto resultante; las propiedades en extensiones posteriores &amp;ldquo;ganan&amp;rdquo; sobre las propiedades creadas previamente.</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target state="translated">El &amp;iacute;ndice ordinal del par&amp;aacute;metro en la lista de par&amp;aacute;metros de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href=&quot;advanced-types#union-types&quot;&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">El otro cambio es que los tipos de enumeraci&amp;oacute;n se convierten efectivamente en una &lt;em&gt;uni&amp;oacute;n&lt;/em&gt; de cada miembro de enumeraci&amp;oacute;n. Si bien a&amp;uacute;n no hemos discutido &lt;a href=&quot;advanced-types#union-types&quot;&gt;los tipos de uni&amp;oacute;n&lt;/a&gt; , todo lo que necesita saber es que con las enumeraciones de uni&amp;oacute;n, el sistema de tipos puede aprovechar el hecho de que conoce el conjunto exacto de valores que existen en la enumeraci&amp;oacute;n misma. Por eso, TypeScript puede detectar errores tontos en los que podr&amp;iacute;amos estar comparando valores incorrectamente. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3a3f850fae27464de0a91f4fe484b577d056f476" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes" xml:space="preserve">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target state="translated">El otro nuevo tipo de declaraci&amp;oacute;n de ES6 compatible con TypeScript es &lt;code&gt;const&lt;/code&gt; . No se puede asignar una variable &lt;code&gt;const&lt;/code&gt; y se debe inicializar donde se declara. Esto es &amp;uacute;til para declaraciones en las que no desea cambiar el valor despu&amp;eacute;s de su inicializaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes" xml:space="preserve">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target state="translated">El otro tipo de firma de aserci&amp;oacute;n no busca una condici&amp;oacute;n, sino que le dice a TypeScript que una variable o propiedad espec&amp;iacute;fica tiene un tipo diferente.</target>
        </trans-unit>
        <trans-unit id="26c97f765ee648970cd74d22ecbbec1a076a2371" translate="yes" xml:space="preserve">
          <source>The other version is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c65d0a0ca356ee8f50f381bfb9e081e37ee13c6" translate="yes" xml:space="preserve">
          <source>The pattern relies on using Generics with class inheritance to extend a base class. TypeScript&amp;rsquo;s best mixin support is done via the class expression pattern. You can read more about how this pattern works in &lt;a href=&quot;https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;JavaScript here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes" xml:space="preserve">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target state="translated">La popular biblioteca D3 define su funcionalidad en un objeto global llamado &lt;code&gt;d3&lt;/code&gt; . Debido a que esta biblioteca se carga a trav&amp;eacute;s de una etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; (en lugar de un cargador de m&amp;oacute;dulo), su declaraci&amp;oacute;n usa espacios de nombres para definir su forma. Para que el compilador de TypeScript vea esta forma, usamos una declaraci&amp;oacute;n de espacio de nombres ambiental. Por ejemplo, podr&amp;iacute;amos comenzar a escribirlo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="97b95eb4ae7f59dc40bbd1fbc533cb87a64d1c85" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the TypeScript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">Los dos tipos anteriores son equivalentes a los tipos de TypeScript &lt;code&gt;{ [x: string]: number }&lt;/code&gt; y &lt;code&gt;{ [x: number]: any }&lt;/code&gt; . El compilador comprende ambas sintaxis.</target>
        </trans-unit>
        <trans-unit id="c60fafa2ef6625ee2c00e943de3aab278fabf81d" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">La presencia de un archivo &lt;code&gt;tsconfig.json&lt;/code&gt; en un directorio indica que el directorio es la ra&amp;iacute;z de un proyecto de TypeScript. El archivo &lt;code&gt;tsconfig.json&lt;/code&gt; especifica los archivos ra&amp;iacute;z y las opciones del compilador necesarias para compilar el proyecto. Un proyecto se compila de una de las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="a2cfab90b0c3ba6c1eea59f4039e7816d4601aa6" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; in the above example is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">El problema con &lt;code&gt;padLeft&lt;/code&gt; es que su par&amp;aacute;metro de &lt;code&gt;padding&lt;/code&gt; se escribe como &lt;code&gt;any&lt;/code&gt; . Eso significa que podemos llamarlo con un argumento que no es ni un &lt;code&gt;number&lt;/code&gt; ni una &lt;code&gt;string&lt;/code&gt; , pero TypeScript estar&amp;aacute; bien con eso.</target>
        </trans-unit>
        <trans-unit id="25342fc4c0a8b53d44f277b4df381a59c493566a" translate="yes" xml:space="preserve">
          <source>The process of going from an infinite number of potential cases (there are an infinite number of possible string values) to a smaller, finite number of potential case (in &lt;code&gt;helloWorld&lt;/code&gt;&amp;rsquo;s case: 1) is called narrowing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes" xml:space="preserve">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target state="translated">El proceso de resoluci&amp;oacute;n de estos nombres de paquetes es similar al proceso de resoluci&amp;oacute;n de nombres de m&amp;oacute;dulos en una declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n . Una forma f&amp;aacute;cil de pensar en las directivas de tipos de referencia de triple barra es como una &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n para paquetes de declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes" xml:space="preserve">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;&quot;files&quot;&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target state="translated">El proceso comienza con un conjunto de &lt;em&gt;archivos ra&amp;iacute;z&lt;/em&gt; ; estos son los nombres de archivo especificados en la l&amp;iacute;nea de comandos o en la lista &lt;code&gt;&quot;files&quot;&lt;/code&gt; en el archivo &lt;code&gt;tsconfig.json&lt;/code&gt; . Estos archivos ra&amp;iacute;z se preprocesan en el mismo orden en que se especifican. Antes de agregar un archivo a la lista, se procesan todas las referencias de triple barra y se incluyen sus destinos. Las referencias de triple barra se resuelven primero en profundidad, en el orden en que se han visto en el archivo.</target>
        </trans-unit>
        <trans-unit id="1064046bee0ce7e01c8bf16c1b03dac0a5d9f8ee" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;ldquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target state="translated">El programa deber&amp;iacute;a imprimir &quot;&amp;iexcl;Hola desde TypeScript!&quot;.</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target state="translated">El propósito de esta guía es enseñarle a escribir un archivo de definición de alta calidad.Esta guía está estructurada mostrando la documentación de alguna API,junto con ejemplos de uso de esa API,y explicando cómo escribir la declaración correspondiente.</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes" xml:space="preserve">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target state="translated">La etiqueta de referencia aqu&amp;iacute; nos permite ubicar el archivo de declaraci&amp;oacute;n que contiene la declaraci&amp;oacute;n para el m&amp;oacute;dulo ambiental. As&amp;iacute; es como se &lt;code&gt;node.d.ts&lt;/code&gt; archivo node.d.ts que utilizan varias de las muestras de TypeScript.</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes" xml:space="preserve">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target state="translated">El resto de esta secci&amp;oacute;n asume que &lt;code&gt;typescript@next&lt;/code&gt; ya est&amp;aacute; instalado.</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes" xml:space="preserve">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target state="translated">El resultado ser&amp;aacute; un archivo &lt;code&gt;greeter.js&lt;/code&gt; que contiene el mismo JavaScript que introdujo. &amp;iexcl;Estamos en funcionamiento usando TypeScript en nuestra aplicaci&amp;oacute;n JavaScript!</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes" xml:space="preserve">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target state="translated">La declaraci&amp;oacute;n combinada resultante de &lt;code&gt;Document&lt;/code&gt; o ser&amp;aacute; la siguiente:</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes" xml:space="preserve">
          <source>The resulting type of the property.</source>
          <target state="translated">El tipo de propiedad resultante.</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes" xml:space="preserve">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target state="translated">Los resultados se llaman entonces como funciones de abajo a arriba.</target>
        </trans-unit>
        <trans-unit id="6d00e7101737114bac2225ce67379aba61f8af21" translate="yes" xml:space="preserve">
          <source>The return type of a call uses the contextual type for inferences, so the compiler infers that &lt;code&gt;T={ inference: string }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes" xml:space="preserve">
          <source>The return value of the parameter decorator is ignored.</source>
          <target state="translated">El valor de retorno del parámetro decorador es ignorado.</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes" xml:space="preserve">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target state="translated">El lado derecho de &lt;code&gt;instanceof&lt;/code&gt; debe ser una funci&amp;oacute;n de constructor, y TypeScript se reducir&amp;aacute; a:</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target state="translated">La misma &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;nota&lt;/a&gt; a pie de p&amp;aacute;gina se aplica a estos m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="e77f3244150969c173e8b081e427e7953f3f7fd4" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;awesome-typescript-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Lo mismo ocurre con &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt; , otro cargador de TypeScript para Webpack. Puede leer m&amp;aacute;s sobre las diferencias entre los dos &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes" xml:space="preserve">
          <source>The same is true for optional properties:</source>
          <target state="translated">Lo mismo ocurre con las propiedades opcionales:</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes" xml:space="preserve">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target state="translated">La misma regla para la asignación se utiliza cuando se comprueban los argumentos de llamada de la función:</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes" xml:space="preserve">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target state="translated">El mismo tipo de rastreo se hace ahora también para las matrices vacías.</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes" xml:space="preserve">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">De la misma manera que las tuplas ordinarias son tipos que se extienden desde &lt;code&gt;Array&lt;/code&gt; - una tupla con elementos de tipo &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; , &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; ,&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extiende desde &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - las tuplas de &lt;code&gt;readonly&lt;/code&gt; son tipos que se extienden desde &lt;code&gt;ReadonlyArray&lt;/code&gt; . Entonces, una tupla de &lt;code&gt;readonly&lt;/code&gt; con elementos &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; , &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; ,&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extiende desde &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes" xml:space="preserve">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target state="translated">La segunda asignaci&amp;oacute;n es un error, porque &lt;code&gt;y&lt;/code&gt; tiene un segundo par&amp;aacute;metro requerido que &lt;code&gt;x&lt;/code&gt; no tiene, por lo que la asignaci&amp;oacute;n no est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes" xml:space="preserve">
          <source>The second block creates the following name meanings:</source>
          <target state="translated">El segundo bloque crea los siguientes significados de los nombres:</target>
        </trans-unit>
        <trans-unit id="bb7b2f9c2d9be074838810a47661fb544c2c7a54" translate="yes" xml:space="preserve">
          <source>The second example failed because the array&amp;rsquo;s &lt;code&gt;find&lt;/code&gt; function looks a bit like this simplification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes" xml:space="preserve">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target state="translated">El segundo m&amp;eacute;todo usa el tipo &lt;code&gt;never&lt;/code&gt; que usa el compilador para verificar la exhaustividad:</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">El segundo operador es &lt;code&gt;T[K]&lt;/code&gt; , el &lt;strong&gt;operador de acceso indexado&lt;/strong&gt; . Aqu&amp;iacute;, la sintaxis de tipo refleja la sintaxis de la expresi&amp;oacute;n. Eso significa que la &lt;code&gt;person['name']&lt;/code&gt; tiene el tipo &lt;code&gt;Person['name']&lt;/code&gt; , que en nuestro ejemplo es solo una &lt;code&gt;string&lt;/code&gt; . Sin embargo, al igual que las consultas de tipo &amp;iacute;ndice, puede utilizar &lt;code&gt;T[K]&lt;/code&gt; en un contexto gen&amp;eacute;rico, que es donde cobra vida su verdadero poder. S&amp;oacute;lo hay que asegurarse de que el tipo de variable &lt;code&gt;K extends keyof T&lt;/code&gt; . Aqu&amp;iacute; hay otro ejemplo con una funci&amp;oacute;n llamada &lt;code&gt;getProperty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395e59dd3d587260540f24beb9cdd8492f3b1ca0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;taxi[&quot;manufacturer&quot;]&lt;/code&gt; has the type &lt;code&gt;Car[&quot;manufacturer&quot;]&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">La segunda parte es el tipo de devoluci&amp;oacute;n. Dejamos claro cu&amp;aacute;l es el tipo de retorno mediante el uso de una flecha gruesa ( &lt;code&gt;=&amp;gt;&lt;/code&gt; ) entre los par&amp;aacute;metros y el tipo de retorno. Como se mencion&amp;oacute; anteriormente, esta es una parte requerida del tipo de funci&amp;oacute;n, por lo que si la funci&amp;oacute;n no devuelve un valor, usar&amp;iacute;a &lt;code&gt;void&lt;/code&gt; en lugar de omitirlo.</target>
        </trans-unit>
        <trans-unit id="ee75b3015ae814b5df851e6a3b58e1c66c58fec3" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using an arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes" xml:space="preserve">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target state="translated">La segunda raz&amp;oacute;n es cuando un consumidor utiliza la funci&amp;oacute;n de &quot;comprobaci&amp;oacute;n nula estricta&quot; de TypeScript. Debido a que los par&amp;aacute;metros no especificados aparecen como &lt;code&gt;undefined&lt;/code&gt; en JavaScript, generalmente est&amp;aacute; bien pasar un &lt;code&gt;undefined&lt;/code&gt; expl&amp;iacute;cito a una funci&amp;oacute;n con argumentos opcionales. Este c&amp;oacute;digo, por ejemplo, deber&amp;iacute;a estar bien bajo nulos estrictos:</target>
        </trans-unit>
        <trans-unit id="ddaeafe60f623f16494e16010fd0027a89f657dc" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;mdash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">La segunda forma tambi&amp;eacute;n es quiz&amp;aacute;s la m&amp;aacute;s com&amp;uacute;n. Aqu&amp;iacute; usamos la &lt;em&gt;inferencia de argumento de tipo&lt;/em&gt; , es decir, queremos que el compilador establezca el valor de &lt;code&gt;T&lt;/code&gt; para nosotros autom&amp;aacute;ticamente en funci&amp;oacute;n del tipo de argumento que pasamos:</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes" xml:space="preserve">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">La segunda forma utiliza un tipo de matriz gen&amp;eacute;rico, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dc5448e0198755908cad47574593cb637412ed51" translate="yes" xml:space="preserve">
          <source>The shape-matching only requires a subset of the object&amp;rsquo;s fields to match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes" xml:space="preserve">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target state="translated">La forma más simple de desestructuración es la asignación de destructores de matrices:</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes" xml:space="preserve">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target state="translated">El tipo más simple,y quizás más común,de fusión de declaración es la fusión de interfaz.En el nivel más básico,la fusión une mecánicamente los miembros de ambas declaraciones en una única interfaz con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes" xml:space="preserve">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target state="translated">El fragmento anterior es un ejemplo de inferencia de tipo,que se explica más adelante en el manual.</target>
        </trans-unit>
        <trans-unit id="ecda9eae0951be3e74181af1517711ce10156b9c" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;ESNext&lt;/code&gt; value refers to the highest version your version of TypeScript supports. This setting should be used with caution, since it doesn&amp;rsquo;t mean the same thing between different TypeScript versions and can make upgrades less predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes" xml:space="preserve">
          <source>The spread operator also works:</source>
          <target state="translated">El operador del esparcidor también trabaja:</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes" xml:space="preserve">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target state="translated">El operador de difusión es lo opuesto a la desestructuración.Le permite extender una matriz en otra matriz,o un objeto en otro objeto.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="347a245a04ce2dd0b84ae05cdc6937a6bfd2e8ec" translate="yes" xml:space="preserve">
          <source>The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed87e7da393e9ebf4b65dddbe2b2c6508ed02ce5" translate="yes" xml:space="preserve">
          <source>The strategy for how individual files are watched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes" xml:space="preserve">
          <source>The strategy the compiler is following</source>
          <target state="translated">La estrategia que el compilador está siguiendo</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes" xml:space="preserve">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target state="translated">La comprobaci&amp;oacute;n m&amp;aacute;s estricta se aplica a todos los tipos de funciones, &lt;em&gt;excepto a&lt;/em&gt; las que se originan en declaraciones de m&amp;eacute;todos o constructores. Los m&amp;eacute;todos se excluyen espec&amp;iacute;ficamente para garantizar que las clases e interfaces gen&amp;eacute;ricas (como &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; ) contin&amp;uacute;en relacion&amp;aacute;ndose principalmente de forma covariable.</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes" xml:space="preserve">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target state="translated">&lt;code&gt;Keys&lt;/code&gt; uni&amp;oacute;n literal de cadena , que contiene los nombres de las propiedades sobre las que iterar.</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes" xml:space="preserve">
          <source>The supported glob wildcards are:</source>
          <target state="translated">Los comodines globales apoyados son:</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes" xml:space="preserve">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target state="translated">La sintaxis se parece a la sintaxis de las firmas de &amp;iacute;ndice con un &lt;code&gt;for .. in&lt;/code&gt; interior. Hay tres partes:</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes" xml:space="preserve">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target state="translated">La sintaxis deber&amp;iacute;a resultarle familiar si ha utilizado C # o Java antes. Declaramos una nueva clase &lt;code&gt;Greeter&lt;/code&gt; . Esta clase tiene tres miembros: una propiedad llamada &lt;code&gt;greeting&lt;/code&gt; , un constructor y un m&amp;eacute;todo &lt;code&gt;greet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">El archivo de plantilla &lt;a href=&quot;templates/global-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt; define una biblioteca de ejemplo &lt;code&gt;myLib&lt;/code&gt; . Aseg&amp;uacute;rese de leer la &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;nota al pie de p&amp;aacute;gina &amp;ldquo;Prevenci&amp;oacute;n de conflictos de nombres&amp;rdquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4661397a216a4756287dc9945d770b9dd77b8574" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes" xml:space="preserve">
          <source>The test files import the implementation files and do some testing:</source>
          <target state="translated">Los archivos de prueba importan los archivos de implementación y hacen algunas pruebas:</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes" xml:space="preserve">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target state="translated">Las tres interfaces se fusionarán para crear una única declaración como tal:</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes" xml:space="preserve">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target state="translated">El m&amp;oacute;dulo de nivel superior aqu&amp;iacute; &lt;code&gt;Shapes&lt;/code&gt; envuelve &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; sin ninguna raz&amp;oacute;n. Esto es confuso y molesto para los consumidores de su m&amp;oacute;dulo:</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes" xml:space="preserve">
          <source>The two biggest changes are the following:</source>
          <target state="translated">Los dos cambios más importantes son los siguientes:</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes" xml:space="preserve">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target state="translated">Las dos opciones dejaban más que desear;agrupar a los ayudantes en cada archivo era un punto doloroso para los clientes que trataban de mantener el tamaño de su paquete pequeño.Y sin incluir los ayudantes,los clientes tenían que mantener su propia biblioteca de ayudantes.</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes" xml:space="preserve">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target state="translated">Las dos muestras son equivalentes. Usar uno sobre el otro es principalmente una elecci&amp;oacute;n de preferencia; sin embargo, cuando se utiliza mecanografiado con JSX, solamente &lt;code&gt;as&lt;/code&gt; se permiten afirmaciones al estilo.</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes" xml:space="preserve">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">El tipo anterior medios cuando &lt;code&gt;T&lt;/code&gt; es asignable a &lt;code&gt;U&lt;/code&gt; el tipo es &lt;code&gt;X&lt;/code&gt; , de lo contrario el tipo es &lt;code&gt;Y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes" xml:space="preserve">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target state="translated">El verificador de tipos comprueba la llamada a &lt;code&gt;printLabel&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;printLabel&lt;/code&gt; tiene un solo par&amp;aacute;metro que requiere que el objeto pasado tenga una propiedad llamada &lt;code&gt;label&lt;/code&gt; de tipo &lt;code&gt;string&lt;/code&gt; . Observe que nuestro objeto en realidad tiene m&amp;aacute;s propiedades que esta, pero el compilador solo verifica que &lt;em&gt;al menos&lt;/em&gt; las requeridas est&amp;eacute;n presentes y coincidan con los tipos requeridos. Hay algunos casos en los que TypeScript no es tan indulgente, que cubriremos en un momento.</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes" xml:space="preserve">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target state="translated">El verificador de tipos anteriormente se consideraba &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; asignable a cualquier cosa. Efectivamente, &lt;code&gt;null&lt;/code&gt; e &lt;code&gt;undefined&lt;/code&gt; eran valores v&amp;aacute;lidos de &lt;em&gt;todo&lt;/em&gt; tipo y no era posible excluirlos espec&amp;iacute;ficamente (y por tanto no era posible detectar un uso err&amp;oacute;neo de ellos).</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes" xml:space="preserve">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target state="translated">El tipo inferido para una variable &lt;code&gt;const&lt;/code&gt; o propiedad de &lt;code&gt;readonly&lt;/code&gt; sin una anotaci&amp;oacute;n de tipo es el tipo del inicializador literal. El tipo inferido para una variable &lt;code&gt;let&lt;/code&gt; , variable &lt;code&gt;var&lt;/code&gt; , par&amp;aacute;metro o propiedad que no es de &lt;code&gt;readonly&lt;/code&gt; con un inicializador y sin anotaci&amp;oacute;n de tipo es el tipo literal ampliado del inicializador. Donde el tipo ampliado para un tipo de literal de cadena es &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; para tipos de literal num&amp;eacute;rico, &lt;code&gt;boolean&lt;/code&gt; o para &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; y la enumeraci&amp;oacute;n que contiene para los tipos de literal enum.</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes" xml:space="preserve">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target state="translated">La informaci&amp;oacute;n de tipo proporcionada funciona junto con las herramientas para trabajar con JavaScript a escala de aplicaci&amp;oacute;n. Para obtener m&amp;aacute;s ejemplos de lo que es posible en TypeScript, consulte la secci&amp;oacute;n Muestras del sitio web.</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target state="translated">El tipo de &lt;code&gt;import.meta&lt;/code&gt; es el mundial &lt;code&gt;ImportMeta&lt;/code&gt; tipo que se define en &lt;code&gt;lib.es5.d.ts&lt;/code&gt; . Esta interfaz es extremadamente limitada. Agregar propiedades conocidas para Node o navegadores requiere la combinaci&amp;oacute;n de interfaces y posiblemente un aumento global seg&amp;uacute;n el contexto.</target>
        </trans-unit>
        <trans-unit id="8e56de6acd1d580bed0b7dbc97a0025ddbff4368" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;o&lt;/code&gt; is determined to be &lt;code&gt;{ inference: string }&lt;/code&gt; because</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes" xml:space="preserve">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">El tipo de una variable declarada en una instrucci&amp;oacute;n &lt;code&gt;for..in&lt;/code&gt; es impl&amp;iacute;citamente &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes" xml:space="preserve">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target state="translated">El tipo de funciones genéricas es igual al de las funciones no genéricas,con los parámetros del tipo enumerados en primer lugar,de manera similar a las declaraciones de funciones:</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">El tipo de la propiedad &lt;code&gt;length&lt;/code&gt; de un tipo de tupla con un elemento rest es &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target state="translated">Se infiere que el tipo de la variable &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;number&lt;/code&gt; . Este tipo de inferencia tiene lugar al inicializar variables y miembros, establecer valores predeterminados de par&amp;aacute;metros y determinar los tipos de retorno de funciones.</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes" xml:space="preserve">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target state="translated">El tipo de par&amp;aacute;metro de tipo de la expresi&amp;oacute;n &lt;code&gt;extends&lt;/code&gt; debe limitarse a un tipo de constructor mixin.</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes" xml:space="preserve">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target state="translated">El sistema de tipos exige que el tipo de retorno de la funci&amp;oacute;n de origen sea un subtipo del tipo de retorno del tipo de destino.</target>
        </trans-unit>
        <trans-unit id="80a0ca38923f448a6bc1a30ea77dea5fb6863b0e" translate="yes" xml:space="preserve">
          <source>The type system in TypeScript has different levels of strictness when working with a codebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target state="translated">La variable de tipo &lt;code&gt;K&lt;/code&gt; , que se vincula a cada propiedad a su vez.</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes" xml:space="preserve">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target state="translated">Los tipos de atributos que se pasan en el elemento JSX deben buscarse de manera diferente. Los atributos de los elementos intr&amp;iacute;nsecos deben conocerse &lt;em&gt;intr&amp;iacute;nsecamente,&lt;/em&gt; mientras que los componentes probablemente deseen especificar su propio conjunto de atributos.</target>
        </trans-unit>
        <trans-unit id="fe3cafbbb2e988a60a62d633a3631e8dd7b2a154" translate="yes" xml:space="preserve">
          <source>The types which are exported can then be re-used by consumers of the modules using either &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;import type&lt;/code&gt; in TypeScript code or &lt;a href=&quot;../../jsdoc-supported-types#import-types&quot;&gt;JSDoc imports&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target state="translated">El valor de la propiedad &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; en el archivo del proyecto identifica la versi&amp;oacute;n del compilador que se usar&amp;aacute; para compilar (1.7 en este ejemplo). Esto permite que un proyecto se compile con las mismas versiones del compilador en diferentes m&amp;aacute;quinas.</target>
        </trans-unit>
        <trans-unit id="ff912358477db4602c58e3b0cd86822e8bf58dbb" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target state="translated">El valor de &lt;code&gt;extends&lt;/code&gt; debe ser una cadena que contenga una ruta a otro archivo de configuraci&amp;oacute;n del que heredar.</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes" xml:space="preserve">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target state="translated">No es necesario que las variables tengan un alcance de bloque para que TypeScript nos diga que hay un problema.</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">Las reglas de visibilidad para miembros fusionados son las mismas que se describen en la secci&amp;oacute;n 'Fusionar espacios de nombres', por lo que debemos exportar la clase &lt;code&gt;AlbumLabel&lt;/code&gt; para que la clase fusionada la vea. El resultado final es una clase administrada dentro de otra clase. Tambi&amp;eacute;n puede usar espacios de nombres para agregar m&amp;aacute;s miembros est&amp;aacute;ticos a una clase existente.</target>
        </trans-unit>
        <trans-unit id="243a2c277506b9bd8ad79e2eb6c0a571a75e9611" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &lt;a href=&quot;declaration-merging#merging-namespaces&quot;&gt;Merging Namespaces&lt;/a&gt; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea042e37fe3dfdb85a33f2ea55e58e9f6f78eed8" translate="yes" xml:space="preserve">
          <source>The watching of directory on platforms that don&amp;rsquo;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target state="translated">La observaci&amp;oacute;n de directorios en plataformas que no admiten la observaci&amp;oacute;n recursiva de directorios de forma nativa en el nodo se admite mediante la creaci&amp;oacute;n recursiva de un observador de directorios para los directorios secundarios utilizando diferentes opciones seleccionadas por &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; . Tenga en cuenta que en las plataformas que admiten la observaci&amp;oacute;n de directorios recursiva nativa (por ejemplo, Windows), el valor de esta variable de entorno se ignora.</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes" xml:space="preserve">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges&lt;/a&gt;.</source>
          <target state="translated">La forma en que TypeScript decide si una versi&amp;oacute;n del compilador y el lenguaje coincide es utilizando los &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;rangos semver&lt;/a&gt; de Node .</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes" xml:space="preserve">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target state="translated">La forma en que esto funciona es que cuando se utilizan &lt;code&gt;allowJs&lt;/code&gt; , TypeScript tiene algunos an&amp;aacute;lisis de mejor esfuerzo para comprender los patrones comunes de JavaScript; sin embargo, la forma en que algunos patrones se expresan en JavaScript no necesariamente se parecen a sus equivalentes en TypeScript. Cuando la emisi&amp;oacute;n de &lt;code&gt;declaration&lt;/code&gt; est&amp;aacute; activada, TypeScript descubre la mejor manera de transformar los comentarios JSDoc y las exportaciones CommonJS en declaraciones de tipo v&amp;aacute;lidas y similares en los archivos &lt;code&gt;.d.ts&lt;/code&gt; de salida .</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes" xml:space="preserve">
          <source>Then consumed it:</source>
          <target state="translated">Luego lo consumió:</target>
        </trans-unit>
        <trans-unit id="b4e2cc009128e2db8e40c27a6eddddf19f0ce8db" translate="yes" xml:space="preserve">
          <source>Then enable building it with &lt;code&gt;inlineSourceMap&lt;/code&gt; enabled there is a comment at the bottom of the file which includes a source-map for the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e16808203379c44a60c8ea98dbc5730307f3ef5" translate="yes" xml:space="preserve">
          <source>Then enable building it with &lt;code&gt;inlineSources&lt;/code&gt; and &lt;code&gt;inlineSourceMap&lt;/code&gt; enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in &lt;a href=&quot;#inlineSourceMap&quot;&gt;&lt;code&gt;inlineSourceMap&lt;/code&gt;&lt;/a&gt; because the source-map now contains the original source code also.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bfce3f975bdf3b7775facbf050990abd13d246" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target state="translated">Luego instale &lt;code&gt;typescript&lt;/code&gt; , &lt;code&gt;gulp&lt;/code&gt; y &lt;code&gt;gulp-typescript&lt;/code&gt; en las dependencias de desarrollo de su proyecto. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; es un complemento de gulp para Typescript.</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt;, which is not what we want in this case.</source>
          <target state="translated">Entonces, la propiedad de &lt;code&gt;food&lt;/code&gt; en los &lt;code&gt;defaults&lt;/code&gt; sobrescribe la &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt; , que no es lo que queremos en este caso.</target>
        </trans-unit>
        <trans-unit id="becbc2214d8bce0fa238270073a5869333572174" translate="yes" xml:space="preserve">
          <source>Then turning on both &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;importHelpers&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0de2b0a81fcb1c9fa6824131d9c2d4117e4121" translate="yes" xml:space="preserve">
          <source>Then use the template &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7e9ae9703590946457d53a865fb4cbb6b63b7c" translate="yes" xml:space="preserve">
          <source>Then you can create mixins which only work when you have a particular base to build on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b21ce8f02b992c174e280059fa4ec67556da04" translate="yes" xml:space="preserve">
          <source>Then you need a type and a factory function which returns a class expression extending the base class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes" xml:space="preserve">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target state="translated">Entonces, dado un tipo &lt;code&gt;T''&lt;/code&gt; que es una instancia de &lt;code&gt;T&lt;/code&gt; donde todos &lt;code&gt;infer&lt;/code&gt; ir variables de tipo se sustituyen con los tipos inferidos en el paso anterior, si &lt;code&gt;T''&lt;/code&gt; es &lt;em&gt;definitivamente asignable&lt;/em&gt; a &lt;code&gt;U&lt;/code&gt; , el tipo condicional se resolvi&amp;oacute; &lt;code&gt;X&lt;/code&gt; . La relaci&amp;oacute;n definitivamente asignable es la misma que la relaci&amp;oacute;n asignable regular, excepto que no se consideran las restricciones de la variable de tipo. De manera intuitiva, cuando un tipo es definitivamente asignable a otro tipo, sabemos que ser&amp;aacute; asignable para &lt;em&gt;todas las instanciaciones&lt;/em&gt; de esos tipos.</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes" xml:space="preserve">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target state="translated">Luego, debe recordar dar un valor predeterminado para las propiedades opcionales en la propiedad desestructurada en lugar del inicializador principal. Recuerde que &lt;code&gt;C&lt;/code&gt; se defini&amp;oacute; con &lt;code&gt;b&lt;/code&gt; opcional:</target>
        </trans-unit>
        <trans-unit id="6d2f25ea43cbbc9a4a4d0cca6420fdb8cc7a3eaa" translate="yes" xml:space="preserve">
          <source>There are already a small set of primitive types available in JavaScript: &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt;, which you can use in an interface. TypeScript extends this list with a few more, such as &lt;code&gt;any&lt;/code&gt; (allow anything), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt;&lt;code&gt;unknown&lt;/code&gt;&lt;/a&gt; (ensure someone using this type declares what the type is), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt;&lt;code&gt;never&lt;/code&gt;&lt;/a&gt; (it&amp;rsquo;s not possible that this type could happen), and &lt;code&gt;void&lt;/code&gt; (a function which returns &lt;code&gt;undefined&lt;/code&gt; or has no return value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes" xml:space="preserve">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n hay algunos indicadores espec&amp;iacute;ficos de &lt;code&gt;tsc -b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes" xml:space="preserve">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target state="translated">Hay básicamente tres cambios aquí,pero requieren que refactorices un poco tu código.</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes" xml:space="preserve">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target state="translated">Hay ciertos casos en los que TypeScript no puede determinar cu&amp;aacute;les deber&amp;iacute;an ser ciertos tipos. Para ser lo m&amp;aacute;s indulgente posible, decidir&amp;aacute; utilizar el tipo &lt;code&gt;any&lt;/code&gt; en su lugar. Si bien esto es excelente para la migraci&amp;oacute;n, usar &lt;code&gt;any&lt;/code&gt; medio para que no obtenga ning&amp;uacute;n tipo de seguridad y no obtenga el mismo soporte de herramientas que obtendr&amp;iacute;a en otros lugares. Puede decirle a TypeScript que marque estas ubicaciones y d&amp;eacute; un error con la opci&amp;oacute;n &lt;code&gt;noImplicitAny&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes" xml:space="preserve">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target state="translated">Hay ciertos escenarios en los que las propiedades se pueden inicializar indirectamente (tal vez mediante un m&amp;eacute;todo auxiliar o una biblioteca de inyecci&amp;oacute;n de dependencia), en cuyo caso puede usar los nuevos &lt;em&gt;modificadores de aserci&amp;oacute;n de asignaci&amp;oacute;n definida&lt;/em&gt; para sus propiedades (que se describen a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="eba634610df41341637e71be5bcbf8bb0ed87e8f" translate="yes" xml:space="preserve">
          <source>There are four templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36d4bfc03b98451d8b8eedb5746119736591728" translate="yes" xml:space="preserve">
          <source>There are many ways to import a module in modern consuming code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea4fb6f37fc741965c275705e62ed0016df0d89" translate="yes" xml:space="preserve">
          <source>There are many, many resources available for programmers to learn JavaScript; you should &lt;em&gt;not&lt;/em&gt; ignore these resources if you&amp;rsquo;re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged &lt;code&gt;javascript&lt;/code&gt; than &lt;code&gt;typescript&lt;/code&gt;, but &lt;em&gt;all&lt;/em&gt; of the &lt;code&gt;javascript&lt;/code&gt; questions also apply to TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b49ffaf8a00ef0b4948f5d604ea58ab037be14" translate="yes" xml:space="preserve">
          <source>There are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes" xml:space="preserve">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target state="translated">Hay varios tipos de dependencias que su biblioteca podría tener.Esta sección muestra cómo importarlas al archivo de declaración.</target>
        </trans-unit>
        <trans-unit id="54d5d5df37f41afa88246489b4794d1549724fce" translate="yes" xml:space="preserve">
          <source>There are three sets of literal types available in TypeScript today: strings, numbers, and booleans; by using literal types you can allow an exact value which a string, number, or boolean must have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb53f7de48cbccf0073a458e4977f8e2bef7683" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hay tres plantillas disponibles para m&amp;oacute;dulos, &lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3175acff50e94eb51400e6dbf17df6396ef9e4b3" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript available for your project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target state="translated">Hay dos formas principales de obtener las herramientas de TypeScript:</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes" xml:space="preserve">
          <source>There are two packages:</source>
          <target state="translated">Hay dos paquetes:</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; otherwise.</source>
          <target state="translated">Hay dos posibles estrategias de resoluci&amp;oacute;n de m&amp;oacute;dulos: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; y &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; . Puede usar la &lt;code&gt;--moduleResolution&lt;/code&gt; para especificar la estrategia de resoluci&amp;oacute;n del m&amp;oacute;dulo. Si no se especifica, el valor predeterminado es &lt;a href=&quot;#classic&quot;&gt;Cl&amp;aacute;sico&lt;/a&gt; para &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; o &lt;a href=&quot;#node&quot;&gt;Node de&lt;/a&gt; otro modo.</target>
        </trans-unit>
        <trans-unit id="7bb5339d9e6a87194928e1205da42e556f4c0c78" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; for &lt;code&gt;--module commonjs&lt;/code&gt;, and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; otherwise (including when &lt;code&gt;--module&lt;/code&gt; is set to &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;umd&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes" xml:space="preserve">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;&quot;100&quot;&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target state="translated">Hay dos tipos de firmas de &amp;iacute;ndice admitidas: cadena y n&amp;uacute;mero. Es posible admitir ambos tipos de indexadores, pero el tipo devuelto por un indexador num&amp;eacute;rico debe ser un subtipo del tipo devuelto por el indexador de cadenas. Esto se debe a que al indexar con un &lt;code&gt;number&lt;/code&gt; , JavaScript realmente lo convertir&amp;aacute; en una &lt;code&gt;string&lt;/code&gt; antes de indexarlo en un objeto. Eso significa que indexar con &lt;code&gt;100&lt;/code&gt; (un &lt;code&gt;number&lt;/code&gt; ) es lo mismo que indexar con &lt;code&gt;&quot;100&quot;&lt;/code&gt; (una &lt;code&gt;string&lt;/code&gt; ), por lo que los dos deben ser consistentes.</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes" xml:space="preserve">
          <source>There are two ways to define a value-based element:</source>
          <target state="translated">Hay dos maneras de definir un elemento basado en valores:</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes" xml:space="preserve">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target state="translated">Hay dos maneras de hacer esto. La primera es activar &lt;code&gt;--strictNullChecks&lt;/code&gt; y especificar un tipo de retorno:</target>
        </trans-unit>
        <trans-unit id="cf2a0ce7bafc915c076e238a70bcad502f45e2dc" translate="yes" xml:space="preserve">
          <source>There have been cases where a feature is compelling enough to be an exception to that rule, and these live as experimental compiler flags. It is possible that a version of these features may be different when/if they are added to the JavaScript language, and thus are considered risky.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007f160b174984bad6b726d50666ccbaf286b22c" translate="yes" xml:space="preserve">
          <source>There is a handbook reference page on &lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;Module Resolution&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes" xml:space="preserve">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target state="translated">Hay un subconjunto especial de miembros de enumeraci&amp;oacute;n constante que no se calculan: miembros de enumeraci&amp;oacute;n literal. Un miembro de enumeraci&amp;oacute;n literal es un miembro de enumeraci&amp;oacute;n constante sin valor inicializado o con valores que se inicializan en</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes" xml:space="preserve">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target state="translated">Hay un orden bien definido de cómo se aplican los decoradores a varias declaraciones dentro de una clase:</target>
        </trans-unit>
        <trans-unit id="c03a7a9feb4e16d6584fcc6c1888330ee99b47fa" translate="yes" xml:space="preserve">
          <source>There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59854d2178396e55e332123995b42b2847acef61" translate="yes" xml:space="preserve">
          <source>There is no difference between how classes and objects conform to shapes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes" xml:space="preserve">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target state="translated">No existe una plantilla para &lt;code&gt;tsconfig.json&lt;/code&gt; en la mayor&amp;iacute;a de los tipos de proyectos.</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target state="translated">Hay un conjunto espec&amp;iacute;fico de funciones que &lt;code&gt;throw&lt;/code&gt; un error si sucede algo inesperado. Se llaman funciones de &quot;afirmaci&amp;oacute;n&quot;. Como ejemplo, Node.js tiene una funci&amp;oacute;n dedicada para esto llamado &lt;code&gt;assert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay &lt;em&gt;una llamada opcional&lt;/em&gt; , que nos permite llamar condicionalmente expresiones si no son &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target state="translated">No hay una verificaci&amp;oacute;n integrada y actualizada, por lo que siempre termina ejecutando &lt;code&gt;tsc&lt;/code&gt; dos veces</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">Estos archivos &lt;code&gt;.tsbuildinfo&lt;/code&gt; se pueden eliminar de forma segura y no tienen ning&amp;uacute;n impacto en nuestro c&amp;oacute;digo en tiempo de ejecuci&amp;oacute;n; se utilizan &amp;uacute;nicamente para hacer compilaciones m&amp;aacute;s r&amp;aacute;pidas. Tambi&amp;eacute;n podemos nombrarlos como queramos y colocarlos en cualquier lugar que queramos usando la bandera &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4432967bf84b9c64e93637b08f3be2a8d76030ec" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; can be one of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description&quot;&gt;&lt;code&gt;typeof&lt;/code&gt; operator&amp;rsquo;s return values&lt;/a&gt; (&lt;code&gt;&quot;undefined&quot;&lt;/code&gt;, &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;, &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;, &lt;code&gt;&quot;object&quot;&lt;/code&gt;, or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; must be &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, or &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">Estos &lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; guardias tipo&lt;/em&gt; se reconocen en dos formas diferentes: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; y &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; , Donde &lt;code&gt;&quot;typename&quot;&lt;/code&gt; debe ser &lt;code&gt;&quot;number&quot;&lt;/code&gt; , &lt;code&gt;&quot;string&quot;&lt;/code&gt; , &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; o &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; . Si bien TypeScript no le impedir&amp;aacute; comparar con otras cadenas, el lenguaje no reconocer&amp;aacute; esas expresiones como protectores de tipo.</target>
        </trans-unit>
        <trans-unit id="6e2d65d5a90ac869c2cc90b8e3534ec2395fdf41" translate="yes" xml:space="preserve">
          <source>These are emitted as &lt;code&gt;.map&lt;/code&gt; files which live alongside the file they represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes" xml:space="preserve">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target state="translated">Rara vez se escriben de forma explícita,pero pueden ser útiles para reducir los problemas y pueden atrapar insectos:</target>
        </trans-unit>
        <trans-unit id="07491a8375f8e779f9a5bd9a9bd4a7fcc0120b03" translate="yes" xml:space="preserve">
          <source>These aspects describe a &lt;em&gt;reified, nominal&lt;/em&gt; type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes" xml:space="preserve">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target state="translated">Estas firmas de afirmación son muy similares a las firmas de predicado de tipo escrito:</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes" xml:space="preserve">
          <source>These could be imported as</source>
          <target state="translated">Estos podrían ser importados como</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes" xml:space="preserve">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target state="translated">Estos ejemplos están ordenados en un orden de complejidad aproximadamente creciente.</target>
        </trans-unit>
        <trans-unit id="c149ccf644eec42a0be9ed6e4d8cf9bb1991cb19" translate="yes" xml:space="preserve">
          <source>These limitations can cause runtime problems with some TypeScript features like &lt;code&gt;const enum&lt;/code&gt;s and &lt;code&gt;namespace&lt;/code&gt;s. Setting the &lt;code&gt;isolatedModules&lt;/code&gt; flag tells TypeScript to warn you if you write certain code that can&amp;rsquo;t be correctly interpreted by a single-file transpilation process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51753d058d70c80473068ff593cd4ffa3d3364fb" translate="yes" xml:space="preserve">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;ldquo;oh, don&amp;rsquo;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;rdquo;.</source>
          <target state="translated">Estas opciones tambi&amp;eacute;n persisten cuando se comparten enlaces a muestras de juegos, lo que permite a los usuarios compartir ejemplos de manera m&amp;aacute;s confiable sin tener que decirle al destinatario &amp;ldquo;&amp;iexcl;oh, no olvide activar la opci&amp;oacute;n &lt;code&gt;noImplicitAny&lt;/code&gt; !&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="1e044a651893f38dabaa6219c410c2660102bcf0" translate="yes" xml:space="preserve">
          <source>These options make up the bulk of TypeScript&amp;rsquo;s configuration and it covers how the language should work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes" xml:space="preserve">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target state="translated">Estas reglas de alcance pueden causar varios tipos de errores.Un problema que exacerban es el hecho de que no es un error declarar la misma variable varias veces:</target>
        </trans-unit>
        <trans-unit id="869e555c5337a018666cb0666e0939a7d84b21dd" translate="yes" xml:space="preserve">
          <source>These settings are used to define the runtime expectations of your project, how and where you want the JavaScript to be emitted and the level of integration you want with existing JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cfb58f6d95b6c9be936d843cbb719495c0847fb" translate="yes" xml:space="preserve">
          <source>These settings help you ensure that TypeScript picks up the right files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed62e5cae7d2c803744fdf8f9b3ad988309267c" translate="yes" xml:space="preserve">
          <source>These warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes" xml:space="preserve">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target state="translated">Tambi&amp;eacute;n sirven como m&amp;eacute;todo para ordenar la salida cuando se usa &lt;code&gt;--out&lt;/code&gt; o &lt;code&gt;--outFile&lt;/code&gt; . Los archivos se emiten a la ubicaci&amp;oacute;n del archivo de salida en el mismo orden que la entrada despu&amp;eacute;s de la pasada de preprocesamiento.</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes" xml:space="preserve">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target state="translated">Tambi&amp;eacute;n admiten la sustituci&amp;oacute;n del objeto de &lt;code&gt;exports&lt;/code&gt; con un &amp;uacute;nico objeto personalizado. Las exportaciones predeterminadas est&amp;aacute;n destinadas a reemplazar este comportamiento; sin embargo, los dos son incompatibles. TypeScript admite &lt;code&gt;export =&lt;/code&gt; para modelar el flujo de trabajo tradicional de CommonJS y AMD.</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes" xml:space="preserve">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target state="translated">Son como declaraciones &lt;code&gt;let&lt;/code&gt; pero, como su nombre lo indica, su valor no se puede cambiar una vez que est&amp;aacute;n vinculadas. En otras palabras, tienen las mismas reglas de alcance que &lt;code&gt;let&lt;/code&gt; , pero no puede reasignarlas.</target>
        </trans-unit>
        <trans-unit id="3ba589ad465e9addde0a355ab070f5063bbe5659" translate="yes" xml:space="preserve">
          <source>They can also be declared as constructor functions, as described in the next section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes" xml:space="preserve">
          <source>They will rarely have:</source>
          <target state="translated">Rara vez lo harán:</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes" xml:space="preserve">
          <source>Things to look out for</source>
          <target state="translated">Cosas que hay que tener en cuenta</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target state="translated">Este &lt;code&gt;package.json&lt;/code&gt; le dice a TypeScript que verifique si la versi&amp;oacute;n actual de TypeScript se est&amp;aacute; ejecutando. Si es 3.1 o posterior, determina la ruta que ha importado en relaci&amp;oacute;n con el paquete y lee desde la carpeta &lt;code&gt;ts3.1&lt;/code&gt; del paquete . Eso es lo que significa &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; : si est&amp;aacute; familiarizado con el mapeo de rutas hoy en d&amp;iacute;a, funciona exactamente as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="2359d0122889cba1caee9c6fd11f3a61b8a57f14" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/jest&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">Este archivo &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;em&gt;solo&lt;/em&gt; incluir&amp;aacute; &lt;code&gt;./node_modules/@types/node&lt;/code&gt; , &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; y &lt;code&gt;./node_modules/@types/express&lt;/code&gt; . No se incluir&amp;aacute;n otros paquetes en &lt;code&gt;node_modules/@types/*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee5dcc9ee441574b7eb98ac0562e02ba448d0a4" translate="yes" xml:space="preserve">
          <source>This TSX file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes" xml:space="preserve">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target state="translated">Esto agrega la tarea &lt;code&gt;copy-html&lt;/code&gt; y la agrega como una dependencia &lt;code&gt;default&lt;/code&gt; . Eso significa que cada vez que se ejecuta el &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;copy-html&lt;/code&gt; debe ejecutarse primero. Tambi&amp;eacute;n cambiamos el &lt;code&gt;default&lt;/code&gt; para llamar a Browserify con el complemento tsify en lugar de gulp-typescript. Convenientemente, ambos nos permiten pasar el mismo objeto de opciones al compilador de TypeScript.</target>
        </trans-unit>
        <trans-unit id="99d926e2aab031119cddb8cc6d74ab38f013eea1" translate="yes" xml:space="preserve">
          <source>This allows for creating classes which only work with constrained base classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes" xml:space="preserve">
          <source>This also applies to numeric and string literals.</source>
          <target state="translated">Esto también se aplica a los literales numéricos y de cuerda.</target>
        </trans-unit>
        <trans-unit id="4819d75c2e64c6891ffbc7a26bcbfbdf36fb3616" translate="yes" xml:space="preserve">
          <source>This also means that TypeScript never changes the &lt;em&gt;behavior&lt;/em&gt; of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes" xml:space="preserve">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target state="translated">Esto tambi&amp;eacute;n funciona en los comentarios JSDoc para referirse a tipos de otros m&amp;oacute;dulos en &lt;code&gt;.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes" xml:space="preserve">
          <source>This also works with classes:</source>
          <target state="translated">Esto también funciona con las clases:</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes" xml:space="preserve">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">Esto afirma que la &lt;code&gt;bar&lt;/code&gt; ra de variables tiene el tipo &lt;code&gt;foo&lt;/code&gt; . Dado que TypeScript tambi&amp;eacute;n usa corchetes angulares para las afirmaciones de tipo, combinarlo con la sintaxis de JSX introducir&amp;iacute;a ciertas dificultades de an&amp;aacute;lisis. Como resultado, TypeScript no permite las afirmaciones de tipo de corchetes angulares en archivos &lt;code&gt;.tsx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f85fb60fbb15b3106e3e22c3ddc01338d2c58122" translate="yes" xml:space="preserve">
          <source>This can be considered a &amp;lsquo;fast &amp;amp; loose&amp;rsquo; implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5432dead64ccc9df023d2796e15b77df708ad37" translate="yes" xml:space="preserve">
          <source>This can be described by the following &lt;code&gt;.d.ts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162b366ea578762d34bc51102f5149c7ad80c399" translate="yes" xml:space="preserve">
          <source>This can be described with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes" xml:space="preserve">
          <source>This can be used to pipe output between commands as well.</source>
          <target state="translated">Esto puede ser usado para canalizar la salida entre los comandos también.</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes" xml:space="preserve">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target state="translated">Esto puede causar algunas consecuencias para el c&amp;oacute;digo existente que usa herencia. En primer lugar, los &lt;code&gt;set&lt;/code&gt; acceso establecidos de las clases base no se activar&amp;aacute;n, se sobrescribir&amp;aacute;n por completo.</target>
        </trans-unit>
        <trans-unit id="ec76fbaf129c54c7b42ac5e553e9239c220251e5" translate="yes" xml:space="preserve">
          <source>This can cause some errors to be missed, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes" xml:space="preserve">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target state="translated">Esto incluso se puede usar para habilitar patrones similares a &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n en c&amp;oacute;digo JavaScript simple si elige no usar la construcci&amp;oacute;n de &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n de TypeScript .</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes" xml:space="preserve">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target state="translated">Esto tambi&amp;eacute;n puede ir m&amp;aacute;s all&amp;aacute; de las funciones b&amp;aacute;sicas con etiquetas &lt;code&gt;@param&lt;/code&gt; , donde el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="608ec68b1f29faf0c91c96f151172e130a6c7a7f" translate="yes" xml:space="preserve">
          <source>This can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same &lt;code&gt;type&lt;/code&gt; in an inconsistent way. Rather than doing a full check of all &lt;code&gt;d.ts&lt;/code&gt; files, TypeScript will type check the code you specifically refer to in your app&amp;rsquo;s source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes" xml:space="preserve">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Este cambio implica una interrupci&amp;oacute;n en el comportamiento de las clases integradas extendidas como &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , etc. Por favor, consulte la &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;documentaci&amp;oacute;n de cambios de ruptura de las extensiones integradas&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes" xml:space="preserve">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">Este cheque es un cambio rotundo, pero por esa raz&amp;oacute;n los cheques son muy conservadores. Este error solo se emite en condiciones &lt;code&gt;if&lt;/code&gt; , y no se emite en propiedades opcionales, si &lt;code&gt;strictNullChecks&lt;/code&gt; est&amp;aacute; desactivado o si la funci&amp;oacute;n se llama m&amp;aacute;s tarde dentro del cuerpo del &lt;code&gt;if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="374f1cb2ee64d2f9699be7c65dce331865c022ca" translate="yes" xml:space="preserve">
          <source>This code raises an error because there isn&amp;rsquo;t a &lt;code&gt;default&lt;/code&gt; object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn&amp;rsquo;t created. Making the module look a bit more like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes" xml:space="preserve">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target state="translated">Este proceso de comparación procede de manera recursiva,explorando el tipo de cada miembro y submiembro.</target>
        </trans-unit>
        <trans-unit id="afe60521b82bce04c80aea228c02c6ad2c6227cb" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt; and &lt;code&gt;./vendor/types&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;. All paths are relative to the &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target state="translated">Este archivo de configuraci&amp;oacute;n incluir&amp;aacute; &lt;em&gt;todos los&lt;/em&gt; paquetes de &lt;code&gt;./typings&lt;/code&gt; y ning&amp;uacute;n paquete de &lt;code&gt;./node_modules/@types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target state="translated">Esto crea un archivo &lt;code&gt;package.json&lt;/code&gt; con valores predeterminados.</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes" xml:space="preserve">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target state="translated">Esto crea nuevas variables &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; de &lt;code&gt;o.a&lt;/code&gt; y &lt;code&gt;o.b&lt;/code&gt; . Tenga en cuenta que puede omitir &lt;code&gt;c&lt;/code&gt; si no lo necesita.</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes" xml:space="preserve">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target state="translated">Esto crea dos nuevas variables denominadas &lt;code&gt;first&lt;/code&gt; y &lt;code&gt;second&lt;/code&gt; . Esto es equivalente a usar la indexaci&amp;oacute;n, pero es mucho m&amp;aacute;s conveniente:</target>
        </trans-unit>
        <trans-unit id="a31ee5e23e03dea8a90fcb22ead8da9a4160723e" translate="yes" xml:space="preserve">
          <source>This defaults to &lt;code&gt;false&lt;/code&gt;, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes" xml:space="preserve">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">Esta directiva permite que un archivo incluya expl&amp;iacute;citamente un archivo &lt;em&gt;lib&lt;/em&gt; incorporado existente .</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes" xml:space="preserve">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target state="translated">Esta directiva indica al compilador que &lt;em&gt;no&lt;/em&gt; incluya la biblioteca predeterminada (es decir, &lt;code&gt;lib.d.ts&lt;/code&gt; ) en la compilaci&amp;oacute;n. El impacto aqu&amp;iacute; es similar a pasar &lt;code&gt;--noLib&lt;/code&gt; en la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes" xml:space="preserve">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target state="translated">Esta directiva marca un archivo como &lt;em&gt;biblioteca predeterminada&lt;/em&gt; . Ver&amp;aacute; este comentario en la parte superior de &lt;code&gt;lib.d.ts&lt;/code&gt; y sus diferentes variantes.</target>
        </trans-unit>
        <trans-unit id="a4de1039913e973b35b634a72b6cbe6e6a97bca6" translate="yes" xml:space="preserve">
          <source>This disables reporting of excess property errors, such as the one shown in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d44ce0ab64cf8784d2c30b139d5f95c5d7e18fd" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;mdash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">Esta distinci&amp;oacute;n es sutil e importante: aqu&amp;iacute;, &lt;code&gt;A.B&lt;/code&gt; no es necesariamente un tipo o un valor.</target>
        </trans-unit>
        <trans-unit id="a93e12d2539079ddf00741243f25ccfa0ea0beac" translate="yes" xml:space="preserve">
          <source>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2afe5428bad556646a3ee1b89d282383eef7d8" translate="yes" xml:space="preserve">
          <source>This does not affect errors on the basis of code which &lt;em&gt;appears&lt;/em&gt; to be unreachable due to type analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235deb669a8da9c7c9faf57f9268bb2d8bdddfcd" translate="yes" xml:space="preserve">
          <source>This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8238728f0c2b5909a1676078b8fa412e525129da" translate="yes" xml:space="preserve">
          <source>This essentially makes such &lt;code&gt;const enums&lt;/code&gt; a source-code feature only, with no runtime traces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes" xml:space="preserve">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target state="translated">Este ejemplo cubre algunas otras caracter&amp;iacute;sticas que no mencionamos anteriormente. Una vez m&amp;aacute;s, vemos la &lt;code&gt;extends&lt;/code&gt; palabras clave utilizadas para crear dos nuevas subclases de &lt;code&gt;Animal&lt;/code&gt; : &lt;code&gt;Horse&lt;/code&gt; y &lt;code&gt;Snake&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7234716f41fc7048658a32b671efefbe1e85d8e" translate="yes" xml:space="preserve">
          <source>This example is a good case for &lt;a href=&quot;../../generics#generic-types&quot;&gt;using generics&lt;/a&gt; to provide richer type information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes" xml:space="preserve">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target state="translated">Este ejemplo muestra la caracter&amp;iacute;stica de herencia m&amp;aacute;s b&amp;aacute;sica: las clases heredan propiedades y m&amp;eacute;todos de las clases base. Aqu&amp;iacute;, &lt;code&gt;Dog&lt;/code&gt; es una clase &lt;em&gt;derivada&lt;/em&gt; que se deriva de la clase &lt;em&gt;base &lt;/em&gt; &lt;code&gt;Animal&lt;/code&gt; usando la palabra clave &lt;code&gt;extends&lt;/code&gt; . Las clases derivadas a menudo se denominan &lt;em&gt;subclases&lt;/em&gt; y las clases base a menudo se denominan &lt;em&gt;superclases&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes" xml:space="preserve">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target state="translated">Esta característica puede ser extremadamente útil para organizaciones más grandes,o proyectos con muchas dependencias distribuidas.</target>
        </trans-unit>
        <trans-unit id="be730b705da0032c97a8590e06766b7025ca507f" translate="yes" xml:space="preserve">
          <source>This feature differs from &lt;a href=&quot;#typeRoots&quot;&gt;&lt;code&gt;typeRoots&lt;/code&gt;&lt;/a&gt; in that it is about specifying only the exact types you want included, whereas &lt;a href=&quot;#typeRoots&quot;&gt;&lt;code&gt;typeRoots&lt;/code&gt;&lt;/a&gt; supports saying you want particular folders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes" xml:space="preserve">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target state="translated">Actualmente, esta funci&amp;oacute;n es compatible con Visual Studio 2015 con TypeScript 1.8.4 y superior, y el complemento &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes" xml:space="preserve">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target state="translated">Esta característica significa que los tipos que de otro modo se utilizarían sólo para insinuar la inmutabilidad al compilador a menudo pueden ser omitidos.</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes" xml:space="preserve">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target state="translated">Esta funci&amp;oacute;n era compatible antes de TypeScript 2.1, pero solo cuando estaba dirigida a ES6 / ES2015. TypeScript 2.1 brinda la capacidad a los tiempos de ejecuci&amp;oacute;n de ES3 y ES5, lo que significa que podr&amp;aacute; aprovecharla sin importar el entorno que est&amp;eacute; utilizando.</target>
        </trans-unit>
        <trans-unit id="9421d77a04111011ab6beef18cfeb6c8d63af606" translate="yes" xml:space="preserve">
          <source>This file can be opened in a chromium based browser like Chrome or Edge Developer in &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution&quot;&gt;the CPU profiler&lt;/a&gt; section. You can learn more about understanding the compilers performance in the &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;TypeScript wiki section on performance&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03daf218ff5e7e04ba0dbd060b544935bee12587" translate="yes" xml:space="preserve">
          <source>This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to true parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to false, and vice-versa).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3c28c49643333e70e3aa93241b77d9ccca003c" translate="yes" xml:space="preserve">
          <source>This flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files to live along-side existing JavaScript files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beef474bfe013c43dfd3fc9834ca6f76a220aa71" translate="yes" xml:space="preserve">
          <source>This flag can be used to remove that check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02550f5639d55abc97d434d6a95eabab62ce1e5d" translate="yes" xml:space="preserve">
          <source>This flag changes the &lt;code&gt;keyof&lt;/code&gt; type operator to return &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;string | number&lt;/code&gt; when applied to a type with a string index signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fdd70a602e988b83dd1c9ee9e588260d2cf64b" translate="yes" xml:space="preserve">
          <source>This flag controls how &lt;code&gt;import&lt;/code&gt; works, there are 3 different options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398bb4b75ca048c92726a3040a7e54918a529c96" translate="yes" xml:space="preserve">
          <source>This flag does not affect the JavaScript emitted by TypeScript, it only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c54f09bdcf2f574ecdbd28c8e632480e1cbf37e" translate="yes" xml:space="preserve">
          <source>This flag is can only be used when &lt;a href=&quot;#allowJs&quot;&gt;&lt;code&gt;allowJs&lt;/code&gt;&lt;/a&gt; is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe930b46ead3b4863a06b153b429c72e1989bb9" translate="yes" xml:space="preserve">
          <source>This flag is something you can use to increase responsiveness in large composite projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c5bbc71b97120a03c50e10dd688658f1a73436" translate="yes" xml:space="preserve">
          <source>This flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript&amp;rsquo;s implementation but the same syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7614651c915d92a89c51c2b71b121f1d197ef79" translate="yes" xml:space="preserve">
          <source>This flag is used to help people keep this behavior from &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types&quot;&gt;before TypeScript 2.9&amp;rsquo;s release&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f97d0d2ab256285ee26208bdac4978420f77519" translate="yes" xml:space="preserve">
          <source>This flag is useful in two cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69247477a2922fa672b9ac6953e5f0f9de79aa95" translate="yes" xml:space="preserve">
          <source>This flag switches to the upcoming ECMA runtime behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386f8e03fb6e0f7dc1ee712a3c5377db2629c8d3" translate="yes" xml:space="preserve">
          <source>This flag was added to help people migrate to the stricter checking of new object literals in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks&quot;&gt;TypeScript 1.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281c5c0d6057938bd9f41eb87fb85816e087f3c9" translate="yes" xml:space="preserve">
          <source>This flag works because you can use &lt;code&gt;import type&lt;/code&gt; to explicitly create an &lt;code&gt;import&lt;/code&gt; statement which should never be emitted into JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes" xml:space="preserve">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target state="translated">Esto le da a bothPlus el valor &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt; . La difusi&amp;oacute;n crea una copia superficial del &lt;code&gt;first&lt;/code&gt; y &lt;code&gt;second&lt;/code&gt; . No se modifican con la propagaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes" xml:space="preserve">
          <source>This gives the user a way of describing inner classes.</source>
          <target state="translated">Esto le da al usuario una forma de describir las clases internas.</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes" xml:space="preserve">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target state="translated">Esta orientación también garantiza que la biblioteca pueda pasar a UMD sin que los usuarios de los archivos de declaración se vean afectados.</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes" xml:space="preserve">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target state="translated">Esta guía está diseñada para enseñarte a escribir un archivo de declaración de alta calidad.</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;.</source>
          <target state="translated">Esta gu&amp;iacute;a le ense&amp;ntilde;ar&amp;aacute; c&amp;oacute;mo conectar TypeScript con &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; y &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target state="translated">Esto sucede con suficiente frecuencia en JavaScript que TypeScript proporciona una forma de crear nuevos tipos basados ​​en tipos antiguos: tipos &lt;strong&gt;mapeados&lt;/strong&gt; . En un tipo mapeado, el nuevo tipo transforma cada propiedad en el tipo antiguo de la misma manera. Por ejemplo, puede hacer que todas las propiedades de un tipo sean de &lt;code&gt;readonly&lt;/code&gt; u opcionales. Aqu&amp;iacute; hay un par de ejemplos:</target>
        </trans-unit>
        <trans-unit id="fc63d58d10daddcb3a784f47122524cdbfabe76f" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties optional or of a type &lt;code&gt;readonly&lt;/code&gt;. Here are a couple of examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99783df1b2487790d2f6fc6e2f815d703f49e8c" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;mdash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">Esto tiene un significado muy espec&amp;iacute;fico: la devoluci&amp;oacute;n de llamada &lt;code&gt;done&lt;/code&gt; puede invocarse con 1 argumento o podr&amp;iacute;a invocarse con 2 argumentos. El autor probablemente pretend&amp;iacute;a decir que a la devoluci&amp;oacute;n de llamada podr&amp;iacute;a no importarle el par&amp;aacute;metro &lt;code&gt;elapsedTime&lt;/code&gt; , pero no es necesario que el par&amp;aacute;metro sea opcional para lograr esto; siempre es legal proporcionar una devoluci&amp;oacute;n de llamada que acepte menos argumentos.</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes" xml:space="preserve">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target state="translated">Esta ha sido una fuente común de errores de definición duplicados.Múltiples archivos de declaración que definen los mismos miembros en las interfaces.</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes" xml:space="preserve">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target state="translated">Esto tiene los mismos problemas que mencionamos anteriormente: f&amp;aacute;cilmente podr&amp;iacute;amos haber escrito mal &lt;code&gt;getDistance&lt;/code&gt; y no haber obtenido un error. Por esta raz&amp;oacute;n, TypeScript tiene la opci&amp;oacute;n &lt;code&gt;noImplicitThis&lt;/code&gt; . Cuando se establece esta opci&amp;oacute;n, mecanografiado emitir&amp;aacute; un error cuando &lt;code&gt;this&lt;/code&gt; se utiliza sin un tipo expl&amp;iacute;cito (o inferida). La soluci&amp;oacute;n es usar un par&amp;aacute;metro &lt;code&gt;this&lt;/code&gt; para dar un tipo expl&amp;iacute;cito en la interfaz o en la funci&amp;oacute;n en s&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7f4508bf6985c57eb5ac26662f4d0528d2a5b77d" translate="yes" xml:space="preserve">
          <source>This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83dcbc6c7495e940551fddfd7a52d3f6c2bfa958" translate="yes" xml:space="preserve">
          <source>This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell&amp;rsquo;s type system. It also describes unique features of TypeScript&amp;rsquo;s type system that arise from its modelling of JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes" xml:space="preserve">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target state="translated">Este es un cambio rotundo; anteriormente, el operador &lt;code&gt;keyof&lt;/code&gt; y los tipos asignados solo admit&amp;iacute;an propiedades con nombre de &lt;code&gt;string&lt;/code&gt; . El c&amp;oacute;digo que asum&amp;iacute;a que los valores escritos con la &lt;code&gt;keyof T&lt;/code&gt; siempre eran una &lt;code&gt;string&lt;/code&gt; s, ahora se marcar&amp;aacute; como error.</target>
        </trans-unit>
        <trans-unit id="2c0826ad129c5fa63f6532465e3caa896ed6cad2" translate="yes" xml:space="preserve">
          <source>This is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes" xml:space="preserve">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target state="translated">Este es un uso bastante literal de la clase &lt;code&gt;GenericNumber&lt;/code&gt; , pero es posible que haya notado que nada la restringe para usar solo el tipo de &lt;code&gt;number&lt;/code&gt; . En su lugar, podr&amp;iacute;amos haber usado &lt;code&gt;string&lt;/code&gt; o incluso objetos m&amp;aacute;s complejos.</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes" xml:space="preserve">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Esta es una restricci&amp;oacute;n razonable porque cualquier uso de &lt;code&gt;Foo&lt;/code&gt; tendr&amp;iacute;a que ser reemplazado por &lt;code&gt;Foo&lt;/code&gt; ,el cual tendr&amp;iacute;a que ser reemplazado por &lt;code&gt;Foo&lt;/code&gt; , que tendr&amp;iacute;a que ser reemplazado por &lt;code&gt;Foo&lt;/code&gt; , que&amp;hellip; bueno, &amp;iexcl;espero que entiendas la idea! Al final, no hay un tipo que tenga sentido en lugar de &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes" xml:space="preserve">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">Esto se logra mediante la introducci&amp;oacute;n de dos nuevos tipos, &lt;code&gt;CallableFunction&lt;/code&gt; y &lt;code&gt;NewableFunction&lt;/code&gt; , en &lt;code&gt;lib.d.ts&lt;/code&gt; . Estos tipos contienen declaraciones de m&amp;eacute;todos gen&amp;eacute;ricos especializados para &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; y &lt;code&gt;apply&lt;/code&gt; para funciones regulares y funciones de constructor, respectivamente. Las declaraciones usan par&amp;aacute;metros de descanso gen&amp;eacute;ricos (ver # 24897) para capturar y reflejar listas de par&amp;aacute;metros de una manera fuertemente tipada. En el modo &lt;code&gt;--strictBindCallApply&lt;/code&gt; , estas declaraciones se utilizan en lugar de las declaraciones (muy permisivas) proporcionadas por el tipo &lt;code&gt;Function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07d4ef20e57dcee6e52ef28b64c55fa254a3690c" translate="yes" xml:space="preserve">
          <source>This is an array spread:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0babfe78fc11f36da1fdc5ec919d6b94975c4775" translate="yes" xml:space="preserve">
          <source>This is an overloaded function definition. The second overload is simplest and works a lot like the &lt;code&gt;getElementById&lt;/code&gt; method does. Pass it any &lt;code&gt;string&lt;/code&gt; and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e698f027e54b69d38b4a233c428be4f83585527" translate="yes" xml:space="preserve">
          <source>This is an overview, from here you should read &lt;a href=&quot;intro&quot;&gt;through the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes" xml:space="preserve">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target state="translated">Esto se debe a que cuando una clase implementa una interfaz,sólo se comprueba el lado de la instancia de la clase.Dado que el constructor se sienta en el lado estático,no se incluye en esta comprobación.</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes" xml:space="preserve">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target state="translated">Esto se denomina &quot;tipificaci&amp;oacute;n contextual&quot;, una forma de inferencia de tipos. Esto ayuda a reducir la cantidad de esfuerzo para mantener el programa escrito.</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes" xml:space="preserve">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target state="translated">Esto es equivalente a declarar una &lt;code&gt;sentence&lt;/code&gt; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes" xml:space="preserve">
          <source>This is fairly &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target state="translated">Esto es bastante &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistente con la forma en que otros lenguajes tratan los alias de tipo&lt;/a&gt; , pero da lugar a algunos escenarios ligeramente sorprendentes sobre c&amp;oacute;mo los usuarios aprovechan la funci&amp;oacute;n. Por ejemplo, en TypeScript 3.6 y versiones anteriores, lo siguiente provoca un error.</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes" xml:space="preserve">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target state="translated">Esto es legal siempre que no genere un conflicto. Una regla general es que los valores siempre entran en conflicto con otros valores del mismo nombre a menos que se declaren como &lt;code&gt;namespace&lt;/code&gt; , los tipos entrar&amp;aacute;n en conflicto si se declaran con una declaraci&amp;oacute;n de alias de &lt;code&gt;type s = string&lt;/code&gt; ( tipo s = cadena ) y los espacios de nombres nunca entrar&amp;aacute;n en conflicto.</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes" xml:space="preserve">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target state="translated">Este ya no es el caso: TypeScript ahora infiere que &lt;code&gt;this&lt;/code&gt; tiene un tipo especial llamado &lt;code&gt;this&lt;/code&gt; siempre que est&amp;eacute; dentro de un m&amp;eacute;todo de instancia de una clase. El &lt;code&gt;this&lt;/code&gt; tipo se escribe como as&amp;iacute;, y b&amp;aacute;sicamente significa &amp;ldquo;el tipo de la parte izquierda del punto en una llamada al m&amp;eacute;todo&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes" xml:space="preserve">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target state="translated">Este es ahora el valor por defecto de los proyectos MSBuild;esto permite que la construcción incremental de MSBuild funcione como se espera,ya que los resultados sólo se generan en construcciones limpias.</target>
        </trans-unit>
        <trans-unit id="17ee6c7a17ecddf72cfa4cd21d7420a20690b42c" translate="yes" xml:space="preserve">
          <source>This is often what people expect, but it&amp;rsquo;s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a &lt;code&gt;.length&lt;/code&gt; of 2 (or even more!), but should iterate as 1 unit in a &lt;code&gt;for-of&lt;/code&gt; loop. See &lt;a href=&quot;https://blog.jonnew.com/posts/poo-dot-length-equals-two&quot;&gt;this blog post by Jonathan New&lt;/a&gt; for a longer explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes" xml:space="preserve">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target state="translated">Esto solo est&amp;aacute; habilitado si &lt;code&gt;--noImplicitAny&lt;/code&gt; est&amp;aacute; configurado.</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes" xml:space="preserve">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target state="translated">Esto es &amp;oacute;ptimo para los consumidores. Pueden nombrar su tipo como quieran ( &lt;code&gt;t&lt;/code&gt; en este caso) y no tienen que hacer demasiados puntos para encontrar sus objetos.</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes" xml:space="preserve">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target state="translated">Esto es aún estrictamente más capaz en TypeScript 3.3,y añadir una anotación tipográfica explícita funcionará.</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes" xml:space="preserve">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target state="translated">Esto es extraño porque técnicamente no hay nada malo con cualquier uso los usuarios siempre podían escribir lo que efectivamente era el mismo código introduciendo una interfaz.</target>
        </trans-unit>
        <trans-unit id="a85985f698519bc5006290fca9b3c770afc4331a" translate="yes" xml:space="preserve">
          <source>This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes" xml:space="preserve">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target state="translated">Esto no es s&amp;oacute;lido desde la perspectiva del sistema de tipos, pero desde el punto de vista del tiempo de ejecuci&amp;oacute;n, la idea de un par&amp;aacute;metro opcional generalmente no se aplica bien, ya que pasar &lt;code&gt;undefined&lt;/code&gt; en esa posici&amp;oacute;n es equivalente para la mayor&amp;iacute;a de las funciones.</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes" xml:space="preserve">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target state="translated">Esto es &amp;uacute;til cuando tiene una jerarqu&amp;iacute;a de herencia grande, pero desea especificar que su c&amp;oacute;digo funciona solo con subclases que tienen ciertas propiedades. Las subclases no tienen que estar relacionadas adem&amp;aacute;s de heredar de la clase base. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="edfa7337b75e8a1603e456ce30e9130e6824a45e" translate="yes" xml:space="preserve">
          <source>This is useful when you only have a small number of files and don&amp;rsquo;t need to use a glob to reference many files. If you need that then use &lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c743dac20c102f17500a10837b687c3c8b807f9f" translate="yes" xml:space="preserve">
          <source>This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;homepage&lt;/a&gt; has a list of editors which have TypeScript plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5993fdefbd1dda848027db50f46bbc6c1c3844" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the sort of code you would want in your codebase however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes" xml:space="preserve">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target state="translated">Este tipo de iterador es &amp;uacute;til para iterar sobre valores disponibles sincr&amp;oacute;nicamente, como los elementos de una matriz o las claves de un mapa. Se dice que un objeto que admite iteraci&amp;oacute;n es &quot;iterable&quot; si tiene un m&amp;eacute;todo &lt;code&gt;Symbol.iterator&lt;/code&gt; que devuelve un objeto &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2e9d1d03b4a1362369564c77ee95ce233702dd8" translate="yes" xml:space="preserve">
          <source>This lets your &lt;code&gt;tsconfig.json&lt;/code&gt; focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we&amp;rsquo;re hoping the community can add more for different environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd6b551c716ce479c9efb44f5745eec1d50b86b" translate="yes" xml:space="preserve">
          <source>This list may be out of date, you can see the full list in the &lt;a href=&quot;https://github.com/microsoft/TypeScript/tree/master/lib&quot;&gt;TypeScript source code&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa1d11a7b7e51ebc3e166a5662abdb4c99a2fdc" translate="yes" xml:space="preserve">
          <source>This makes room for another tool like &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt;, or &lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt; to handle converting the TypeScript file to a file which can run inside a JavaScript environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes" xml:space="preserve">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target state="translated">Esto puede parecer confuso, pero en realidad es muy conveniente siempre que no sobrecarguemos demasiado las cosas. Veamos algunos aspectos &amp;uacute;tiles de este comportamiento de combinaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="acc607e6369c64f4e86ed2006f7e56509541116e" translate="yes" xml:space="preserve">
          <source>This may seem surprising, but it&amp;rsquo;s ultimately a very similar relationship to one enforced in nominal OOP languages. A subclass cannot &lt;em&gt;remove&lt;/em&gt; a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base. Structural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes" xml:space="preserve">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target state="translated">Esto significa que un c&amp;oacute;digo como el siguiente que intentaba representar JSON ...</target>
        </trans-unit>
        <trans-unit id="935744b5a109e03d6e5fdd0bc4f2ed2b0d65c339" translate="yes" xml:space="preserve">
          <source>This means that having a file like &lt;code&gt;jquery.js&lt;/code&gt; in your project would not automatically download the types for JQuery from DefinitelyTyped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc1af0b95468e7c0be508ef7ed287acbbf8bf7a" translate="yes" xml:space="preserve">
          <source>This means that if you move code from JavaScript to TypeScript, it is &lt;strong&gt;guaranteed&lt;/strong&gt; to run the same way, even if TypeScript thinks that the code has type errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes" xml:space="preserve">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target state="translated">Esto significa que los tipos de uni&amp;oacute;n y la &lt;code&gt;instanceof&lt;/code&gt; distinguen adecuadamente entre clases estructuralmente id&amp;eacute;nticas.</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes" xml:space="preserve">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target state="translated">Esto significa que puede importar de forma condicional y perezosa otros m&amp;oacute;dulos y bibliotecas. Por ejemplo, aqu&amp;iacute; hay una funci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; que solo importa una biblioteca de utilidades cuando es necesaria:</target>
        </trans-unit>
        <trans-unit id="43b4176bbe758e3980ce4c378a5b0c74800846b0" translate="yes" xml:space="preserve">
          <source>This means that your comments will show up in the JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524598ce79eaafea873d07fe2c5f1daf5dd60c42" translate="yes" xml:space="preserve">
          <source>This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33df278507c445ec5629c94f1025fbe3e4d0c772" translate="yes" xml:space="preserve">
          <source>This method works similarly to the &lt;code&gt;createElement&lt;/code&gt; method as the generic parameter &lt;code&gt;T&lt;/code&gt; is inferred from the &lt;code&gt;newChild&lt;/code&gt; argument. &lt;code&gt;T&lt;/code&gt; is &lt;em&gt;constrained&lt;/em&gt; to another base interface &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b9c67d02646774dbf2986763ff463559dd77f1" translate="yes" xml:space="preserve">
          <source>This mis-match causes these two issues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes" xml:space="preserve">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target state="translated">Este modo añade flexibilidad para mezclar y emparejar la forma de las bibliotecas de terceros,donde los globos que las bibliotecas declaran siempre pueden ser consumidos,incluso desde dentro de los módulos.</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes" xml:space="preserve">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target state="translated">Este modelo de fusión de espacios de nombres es un punto de partida útil,pero también tenemos que entender lo que sucede con los miembros no exportados.Los miembros no exportados sólo son visibles en el espacio de nombres original (no fusionado).Esto significa que,después de la fusión,los miembros fusionados que proceden de otras declaraciones no pueden ver los miembros no exportados.</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes" xml:space="preserve">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target state="translated">Este nuevo comportamiento solo se activa cuando como m&amp;aacute;ximo un tipo en la uni&amp;oacute;n tiene m&amp;uacute;ltiples sobrecargas y como m&amp;aacute;ximo un tipo en la uni&amp;oacute;n tiene una firma gen&amp;eacute;rica. Eso significa m&amp;eacute;todos en el &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (que es gen&amp;eacute;rico) a&amp;uacute;n no se podr&amp;aacute; llamar.</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes" xml:space="preserve">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target state="translated">Esta nueva relajación también nos permite referirnos recursivamente a los alias de tipo en tuplas también.El siguiente código que antes era un error,ahora es un código TypeScript válido.</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes" xml:space="preserve">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target state="translated">Este patr&amp;oacute;n de aspecto extra&amp;ntilde;o es bastante com&amp;uacute;n. La &lt;code&gt;i&lt;/code&gt; en la lista de par&amp;aacute;metros en realidad oculta la &lt;code&gt;i&lt;/code&gt; declarada en el ciclo &lt;code&gt;for&lt;/code&gt; , pero como los nombramos igual, no tuvimos que modificar demasiado el cuerpo del ciclo.</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes" xml:space="preserve">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target state="translated">Esto a menudo abre formas muy elegantes de escribir c&amp;oacute;digo; sin embargo, hubo un problema para las clases que quer&amp;iacute;an extenderse desde &lt;code&gt;BasicCalculator&lt;/code&gt; . Imagine que un usuario quisiera empezar a escribir una &lt;code&gt;ScientificCalculator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes" xml:space="preserve">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target state="translated">Esto solo se aplica a los tipos con una firma de &amp;iacute;ndice de cadena &lt;em&gt;expl&amp;iacute;cita&lt;/em&gt; . Sigue siendo un error acceder a propiedades desconocidas en un tipo que usa &lt;code&gt;.&lt;/code&gt; notaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8eb687938c9fb814d547d871195ddff75c8d4f13" translate="yes" xml:space="preserve">
          <source>This option can be used on a per-file basis too similar to &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom&quot;&gt;Babel&amp;rsquo;s &lt;code&gt;/** @jsx h */&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdba5f3f1154fdf39f0e94523953d163115e35ae" translate="yes" xml:space="preserve">
          <source>This option can be used on a per-file basis too similar to &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments&quot;&gt;Babel&amp;rsquo;s &lt;code&gt;/* @jsxFrag h */&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6106ecf0ac5a2b09e236e72c0e2cedcd5d1ae862" translate="yes" xml:space="preserve">
          <source>This option can only be used from the CLI via: &lt;code&gt;--generateCpuProfile tsc-output.cpuprofile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c327bf1c9c3b71c013b7f4a7d7fedc6e7d7f8e7" translate="yes" xml:space="preserve">
          <source>This option does not affect how &lt;code&gt;@types/*&lt;/code&gt; are included in your application code, for example if you had the above &lt;code&gt;compilerOptions&lt;/code&gt; example with code like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57239aa523124655738236cda5cd80c7601972ef" translate="yes" xml:space="preserve">
          <source>This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target state="translated">Esta opci&amp;oacute;n es similar a &lt;code&gt;UseFsEvents&lt;/code&gt; , excepto que al no poder crear un reloj usando &lt;code&gt;fs.watch&lt;/code&gt; , la observaci&amp;oacute;n de respaldo ocurre a trav&amp;eacute;s de colas de sondeo din&amp;aacute;micas (como se explica en &lt;code&gt;DynamicPriorityPolling&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8d193ba5c4532991da9bb0f8500297f04dae9a97" translate="yes" xml:space="preserve">
          <source>This option offers a way to configure the place where TypeScript keeps track of the files it stores on the disk to indicate a project&amp;rsquo;s build state &amp;mdash; by default, they are in the same folder as your emitted JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes" xml:space="preserve">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target state="translated">Esta opci&amp;oacute;n observa el directorio principal del archivo con &lt;code&gt;fs.watch&lt;/code&gt; (usando eventos del sistema de archivos), por lo que tiene poca CPU pero puede comprometer la precisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bc504c6e0f3c053460e82d0c935b1ef42c4c0ed5" translate="yes" xml:space="preserve">
          <source>This page covers all of the different flags available inside a TSConfig file. It starts with an overview of every flag, then moves into the root attributes in the JSON file, then the &lt;code&gt;compilerOptions&lt;/code&gt; which are the bulk of the options and wraps up with &lt;code&gt;watchOptions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7ae2cfaba7b6eecc420557a0116e17b9d17b15" translate="yes" xml:space="preserve">
          <source>This page lists some of the more advanced ways in which you can model types, it works in tandem with the &lt;a href=&quot;utility-types&quot;&gt;Utility Types&lt;/a&gt; doc which includes types which are included in TypeScript and available globally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58c92c51ad6f1ff869baee49d21faa7424e2034" translate="yes" xml:space="preserve">
          <source>This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01e7dba8069ec2ba7bcc3ad7e5d0d4b677661b1" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using modules and namespaces in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target state="translated">Esta publicaci&amp;oacute;n describe las diversas formas de organizar su c&amp;oacute;digo utilizando espacios de nombres (anteriormente &quot;m&amp;oacute;dulos internos&quot;) en TypeScript. Como mencionamos en nuestra nota sobre terminolog&amp;iacute;a, los &quot;m&amp;oacute;dulos internos&quot; ahora se denominan &quot;espacios de nombres&quot;. Adem&amp;aacute;s, en cualquier lugar donde se utiliz&amp;oacute; la palabra clave del &lt;code&gt;module&lt;/code&gt; al declarar un m&amp;oacute;dulo interno, la palabra clave del &lt;code&gt;namespace&lt;/code&gt; puede y debe usarse en su lugar. Esto evita confundir a los nuevos usuarios al sobrecargarlos con t&amp;eacute;rminos con nombres similares.</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">Esta publicaci&amp;oacute;n describe las diversas formas de organizar su c&amp;oacute;digo utilizando espacios de nombres y m&amp;oacute;dulos en TypeScript. Tambi&amp;eacute;n repasaremos algunos temas avanzados sobre c&amp;oacute;mo usar espacios de nombres y m&amp;oacute;dulos, y abordaremos algunos errores comunes al usarlos en TypeScript.</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes" xml:space="preserve">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target state="translated">Esto presenta un simple punto de entrada; por ejemplo, en el repositorio de TypeScript simplemente ejecutamos &lt;code&gt;tsc -b src&lt;/code&gt; para construir todos los puntos finales porque enumeramos todos los subproyectos en &lt;code&gt;src/tsconfig.json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes" xml:space="preserve">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target state="translated">Esto presenta una muy buena oportunidad para desestructurar el código de consumo:</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes" xml:space="preserve">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; and then add &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;, &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;, or &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; functionality using &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;.</source>
          <target state="translated">Esta gu&amp;iacute;a de inicio r&amp;aacute;pido le ense&amp;ntilde;ar&amp;aacute; c&amp;oacute;mo crear TypeScript con &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; y luego agregar &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt; , &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt; o &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; a la tuber&amp;iacute;a de gulp. Esta gu&amp;iacute;a tambi&amp;eacute;n muestra c&amp;oacute;mo agregar la funcionalidad de &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; usando &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes" xml:space="preserve">
          <source>This resolution strategy attempts to mimic the &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target state="translated">Esta estrategia de resoluci&amp;oacute;n intenta imitar el mecanismo de resoluci&amp;oacute;n del m&amp;oacute;dulo &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; en tiempo de ejecuci&amp;oacute;n. El algoritmo de resoluci&amp;oacute;n completa Node.js se describe en la &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;documentaci&amp;oacute;n del m&amp;oacute;dulo Node.js&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87bf34158eb20c72cb4fd37812305a408c19d43a" translate="yes" xml:space="preserve">
          <source>This restriction doesn&amp;rsquo;t apply to &lt;code&gt;.d.ts&lt;/code&gt; files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes" xml:space="preserve">
          <source>This results in the generated JS</source>
          <target state="translated">Esto resulta en la generación de JS</target>
        </trans-unit>
        <trans-unit id="6111a68e7f42d3cedbb929558c29d3873d82bb3c" translate="yes" xml:space="preserve">
          <source>This sample code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes" xml:space="preserve">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target state="translated">Esta secci&amp;oacute;n asume algunos conocimientos b&amp;aacute;sicos sobre m&amp;oacute;dulos. Consulte la documentaci&amp;oacute;n de los &lt;a href=&quot;modules&quot;&gt;m&amp;oacute;dulos&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="349a068c7f9dd73c8443e8d5def76fa3544a4bfe" translate="yes" xml:space="preserve">
          <source>This set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase. TypeScript supports most JSDoc tags, you can find &lt;a href=&quot;../type-checking-javascript-files#supported-jsdoc&quot;&gt;the reference here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e978dce6e27d24e2aafb780acc90f0cc8b6fb6" translate="yes" xml:space="preserve">
          <source>This setting is useful in two cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd3157d320740251f355d5814d6ffa211bfc011" translate="yes" xml:space="preserve">
          <source>This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects &lt;a href=&quot;docs/handbook/project-references&quot;&gt;in the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes" xml:space="preserve">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target state="translated">Esto no debe confundirse con la idea de que los valores a los que se refieren son &lt;em&gt;inmutables&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes" xml:space="preserve">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target state="translated">Este sencillo ejemplo muestra cómo los nombres utilizados durante la importación y la exportación se traducen en el código de carga del módulo.</target>
        </trans-unit>
        <trans-unit id="acb7a478bd6024141f079e21fce02f772fec3fbc" translate="yes" xml:space="preserve">
          <source>This syntactically-legal program prints &lt;code&gt;Infinity&lt;/code&gt;. TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d828b3379cd2b4debebfb5ffcff651af177e54" translate="yes" xml:space="preserve">
          <source>This syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field. Right now, the best documentation for these private fields is in the TypeScript 3.8 &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields&quot;&gt;release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1008cf885d8164f0c0972e2e3403d26e6889f71" translate="yes" xml:space="preserve">
          <source>This takes all of the dependencies from a module and makes it an exported field, you could import it like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adafebdcb218187a19ac5c230d995b12afd1bc7" translate="yes" xml:space="preserve">
          <source>This technique is a hybrid approach, using Babel&amp;rsquo;s &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-typescript&quot;&gt;preset-typescript&lt;/a&gt; to generate your JS files, and then using TypeScript to do type checking and &lt;code&gt;.d.ts&lt;/code&gt; file generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f579bee1621a210e4228f42fa55f672b307fc3" translate="yes" xml:space="preserve">
          <source>This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file&amp;rsquo;s location. For example &lt;code&gt;./src/index.ts&lt;/code&gt; can import the file &lt;code&gt;./src/css/main.css&lt;/code&gt; and TypeScript will be aware of the bundler&amp;rsquo;s behavior for that filetype via the corresponding generated declaration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes" xml:space="preserve">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;&quot;*&quot;&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target state="translated">Esto le dice al compilador para cualquier importaci&amp;oacute;n de m&amp;oacute;dulo que coincida con el patr&amp;oacute;n &lt;code&gt;&quot;*&quot;&lt;/code&gt; (es decir, todos los valores), que busque en dos ubicaciones:</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes" xml:space="preserve">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target state="translated">Esto trata las clases como interfaces y solo mezcla los tipos detr&amp;aacute;s de Disposable y Activatable en el tipo SmartObject en lugar de la implementaci&amp;oacute;n. Esto significa que tendremos que proporcionar la implementaci&amp;oacute;n en clase. Excepto que eso es exactamente lo que queremos evitar al usar mixins.</target>
        </trans-unit>
        <trans-unit id="7c25450c61dcd13ee0d8fae944687b4f32fa002e" translate="yes" xml:space="preserve">
          <source>This tutorial provides a brief overview of TypeScript, focusing on its type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes" xml:space="preserve">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target state="translated">Esta sol&amp;iacute;a ser la estrategia de resoluci&amp;oacute;n predeterminada de TypeScript. Hoy en d&amp;iacute;a, esta estrategia est&amp;aacute; presente principalmente por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="93a8071076c50e947fcd54554c47e1e5fc4fac05" translate="yes" xml:space="preserve">
          <source>This uses &lt;a href=&quot;../../declaration-merging&quot;&gt;declaration merging&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cd525962f56ec03ce869171a31b0c1c0befaf8" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;a href=&quot;functions#this&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">Esta utilidad no devuelve un tipo transformado. En cambio, sirve como marcador para un contexto de &lt;code&gt;this&lt;/code&gt; tipo. Tenga en cuenta que la &lt;code&gt;--noImplicitThis&lt;/code&gt; debe estar habilitada para usar esta utilidad.</target>
        </trans-unit>
        <trans-unit id="84c1c214044cdc8f4303327fab0eacb4bcad4a14" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">Esta utilidad es &amp;uacute;til para representar expresiones de asignaci&amp;oacute;n que fallar&amp;aacute;n en tiempo de ejecuci&amp;oacute;n (es decir, cuando se intenta reasignar propiedades de un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;objeto congelado&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes" xml:space="preserve">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target state="translated">Esta versi&amp;oacute;n del bucle realmente realizar&amp;aacute; la suma correctamente porque la &lt;code&gt;i&lt;/code&gt; del bucle interno sombrea &lt;code&gt;i&lt;/code&gt; del bucle externo.</target>
        </trans-unit>
        <trans-unit id="8382d7d850d9a5a4ffcaae61d648e575486c6e4e" translate="yes" xml:space="preserve">
          <source>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes" xml:space="preserve">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target state="translated">Esto funciona porque las funciones de flecha usan el exterior &lt;code&gt;this&lt;/code&gt; , por lo que siempre puede pasarlas a algo que espera &lt;code&gt;this: void&lt;/code&gt; . La desventaja es que se crea una funci&amp;oacute;n de flecha por objeto de tipo Handler. Los m&amp;eacute;todos, por otro lado, solo se crean una vez y se adjuntan al prototipo de Handler. Se comparten entre todos los objetos de tipo Handler.</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes" xml:space="preserve">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target state="translated">Esto tambi&amp;eacute;n funciona bien en TypeScript, pero el compilador no conoce &lt;code&gt;Observable.prototype.map&lt;/code&gt; . Puede usar el aumento de m&amp;oacute;dulos para informar al compilador sobre esto:</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes" xml:space="preserve">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Esto funciona bastante bien, pero podr&amp;iacute;a imaginar que &lt;code&gt;SomeType&lt;/code&gt; y &lt;code&gt;SomeVar&lt;/code&gt; estaban muy estrechamente relacionados de tal manera que le gustar&amp;iacute;a que tener el mismo nombre. Podemos usar la combinaci&amp;oacute;n para presentar estos dos objetos diferentes (el valor y el tipo) bajo el mismo nombre &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b919e153a19bd055003acaa3a57d606c66fa69e5" translate="yes" xml:space="preserve">
          <source>This would allow you to be able to write &lt;code&gt;import &quot;jquery&quot;&lt;/code&gt;, and get all of the correct typing locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57eefd52c82d3d36b6718a0eea84949e73f282d" translate="yes" xml:space="preserve">
          <source>This would have the following &lt;code&gt;.d.ts&lt;/code&gt; equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes" xml:space="preserve">
          <source>ThisParameterType</source>
          <target state="translated">ThisParameterType</target>
        </trans-unit>
        <trans-unit id="476185d9e02b1c2446403ce730e896811f7c5c6c" translate="yes" xml:space="preserve">
          <source>ThisType&amp;lt;T&amp;gt;</source>
          <target state="translated">ThisType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes" xml:space="preserve">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target state="translated">Aunque no es una práctica recomendada,algunos módulos establecen algún estado global que puede ser utilizado por otros módulos.Estos módulos pueden no tener ninguna exportación,o el consumidor no está interesado en ninguna de sus exportaciones.Para importar estos módulos,utilice:</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes" xml:space="preserve">
          <source>Thus, the following calls are equivalent:</source>
          <target state="translated">Por lo tanto,las siguientes llamadas son equivalentes:</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="789b874f65900275e1feb81853ccba2146efe3f2" translate="yes" xml:space="preserve">
          <source>To add creation of .d.ts files in your project, you will need to do up-to four steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes" xml:space="preserve">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target state="translated">Para permitir la diferenciaci&amp;oacute;n entre los valores devueltos y los valores obtenidos, TypeScript 3.6 convierte el tipo &lt;code&gt;IteratorResult&lt;/code&gt; en un tipo de uni&amp;oacute;n discriminada:</target>
        </trans-unit>
        <trans-unit id="dab773ebdeb56f5d4d302abac7504ce08a873ba8" translate="yes" xml:space="preserve">
          <source>To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes" xml:space="preserve">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target state="translated">Para empezar, al igual que en JavaScript, las funciones de TypeScript se pueden crear como una funci&amp;oacute;n con nombre o como una funci&amp;oacute;n an&amp;oacute;nima. Esto le permite elegir el enfoque m&amp;aacute;s apropiado para su aplicaci&amp;oacute;n, ya sea que est&amp;eacute; creando una lista de funciones en una API o una funci&amp;oacute;n &amp;uacute;nica para transferirla a otra funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes" xml:space="preserve">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target state="translated">Para comprobar si &lt;code&gt;x&lt;/code&gt; es asignable a &lt;code&gt;y&lt;/code&gt; , en primer vistazo a la lista de par&amp;aacute;metros. Cada par&amp;aacute;metro en &lt;code&gt;x&lt;/code&gt; debe tener un par&amp;aacute;metro correspondiente en &lt;code&gt;y&lt;/code&gt; con un tipo compatible. Tenga en cuenta que no se consideran los nombres de los par&amp;aacute;metros, solo sus tipos. En este caso, cada par&amp;aacute;metro de &lt;code&gt;x&lt;/code&gt; tiene un par&amp;aacute;metro compatible correspondiente en &lt;code&gt;y&lt;/code&gt; , por lo que la asignaci&amp;oacute;n est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes" xml:space="preserve">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target state="translated">Para comprobar si &lt;code&gt;y&lt;/code&gt; se puede asignar &lt;code&gt;x&lt;/code&gt; , el compilador comprueba cada propiedad de &lt;code&gt;x&lt;/code&gt; para encontrar una propiedad compatible correspondiente en &lt;code&gt;y&lt;/code&gt; . En este caso, &lt;code&gt;y&lt;/code&gt; debe tener un miembro llamado &lt;code&gt;name&lt;/code&gt; que sea una cadena. Lo hace, por lo que la asignaci&amp;oacute;n est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes" xml:space="preserve">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target state="translated">Para compilar, debemos especificar un destino de m&amp;oacute;dulo en la l&amp;iacute;nea de comando. Para Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt; ; para require.js, use &lt;code&gt;--module amd&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5bd0f12b21d35f79d32b5a8c2a9e7ab064c0bb0a" translate="yes" xml:space="preserve">
          <source>To control which folders you want to the files to be built to, use the config option &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes" xml:space="preserve">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target state="translated">Para representar correctamente los tipos que se pueden pasar a un generador desde las llamadas a &lt;code&gt;next()&lt;/code&gt; , TypeScript 3.6 tambi&amp;eacute;n infiere ciertos usos del &lt;code&gt;yield&lt;/code&gt; dentro del cuerpo de una funci&amp;oacute;n generadora.</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes" xml:space="preserve">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target state="translated">Para definir una protecci&amp;oacute;n de tipo, simplemente necesitamos definir una funci&amp;oacute;n cuyo tipo de retorno sea un &lt;em&gt;predicado de tipo&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes" xml:space="preserve">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target state="translated">Para describir un tipo de función con una interfaz,le damos a la interfaz una firma de llamada.Esto es como una declaración de función con sólo la lista de parámetros y el tipo de retorno dado.Cada parámetro de la lista de parámetros requiere tanto el nombre como el tipo.</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target state="translated">Para describir la forma de las bibliotecas no escritas en TypeScript,necesitamos declarar la API que la biblioteca expone.</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target state="translated">Para describir la forma de las bibliotecas no escritas en TypeScript,necesitamos declarar la API que la biblioteca expone.Debido a que la mayoría de las bibliotecas de JavaScript sólo exponen unos pocos objetos de alto nivel,los espacios de nombres son una buena forma de representarlos.</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes" xml:space="preserve">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target state="translated">Para detectar el problema en torno a los accesos, TypeScript 3.7 ahora emitir&amp;aacute; &lt;code&gt;.d.ts&lt;/code&gt; &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; en archivos .d.ts para que en TypeScript se puedan comprobar accesos anulados.</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target state="translated">Para hacerlo, crearemos una interfaz que describa nuestra restricci&amp;oacute;n. A continuaci&amp;oacute;n, vamos a crear una interfaz que tiene una sola &lt;code&gt;.length&lt;/code&gt; propiedad y luego vamos a utilizar esta interfaz y la &lt;code&gt;extends&lt;/code&gt; palabra clave para referirse a nuestra limitaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes" xml:space="preserve">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target state="translated">Para hacer esto, necesitar&amp;aacute; crear un &lt;code&gt;tsconfig.json&lt;/code&gt; que contenga una lista de sus archivos de entrada, as&amp;iacute; como todas sus configuraciones de compilaci&amp;oacute;n. Simplemente cree un nuevo archivo en la ra&amp;iacute;z de su proyecto llamado &lt;code&gt;tsconfig.json&lt;/code&gt; y rell&amp;eacute;nelo con el siguiente contenido:</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes" xml:space="preserve">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">Para habilitar el soporte experimental para decoradores, debe habilitar la opci&amp;oacute;n del compilador &lt;code&gt;experimentalDecorators&lt;/code&gt; ya sea en la l&amp;iacute;nea de comando o en su &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes" xml:space="preserve">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target state="translated">Para habilitar los patrones de alias de tipo recursivo descritos anteriormente, la propiedad &lt;code&gt;typeArguments&lt;/code&gt; se ha eliminado de la interfaz &lt;code&gt;TypeReference&lt;/code&gt; . Los usuarios deben utilizar en su lugar el &lt;code&gt;getTypeArguments&lt;/code&gt; funci&amp;oacute;n de &lt;code&gt;TypeChecker&lt;/code&gt; casos.</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes" xml:space="preserve">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target state="translated">Para permitir el tratamiento de s&amp;iacute;mbolos como literales &lt;code&gt;unique symbol&lt;/code&gt; encuentra disponible un nuevo tipo de s&amp;iacute;mbolo &amp;uacute;nico . &lt;code&gt;unique symbol&lt;/code&gt; es un subtipo de &lt;code&gt;symbol&lt;/code&gt; y se produce solo a partir de la llamada de &lt;code&gt;Symbol()&lt;/code&gt; o &lt;code&gt;Symbol.for()&lt;/code&gt; , o de anotaciones de tipo expl&amp;iacute;citas. El nuevo tipo solo est&amp;aacute; permitido en declaraciones &lt;code&gt;const&lt;/code&gt; y propiedades &lt;code&gt;readonly static&lt;/code&gt; , y para hacer referencia a un s&amp;iacute;mbolo &amp;uacute;nico espec&amp;iacute;fico, deber&amp;aacute; usar el operador &lt;code&gt;typeof&lt;/code&gt; . Cada referencia a un &lt;code&gt;unique symbol&lt;/code&gt; implica una identidad completamente &amp;uacute;nica que est&amp;aacute; vinculada a una declaraci&amp;oacute;n determinada.</target>
        </trans-unit>
        <trans-unit id="a2a8ede1fa38a59757413a66a422de02420747b4" translate="yes" xml:space="preserve">
          <source>To fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; and ensuring these flags are enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca735a8b247a6d501055cf55a7c32e4798d2f35" translate="yes" xml:space="preserve">
          <source>To get an error when TypeScript produces an &lt;code&gt;any&lt;/code&gt;, use &lt;code&gt;&quot;noImplicitAny&quot;: true&lt;/code&gt;, or &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes" xml:space="preserve">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target state="translated">Para ser m&amp;aacute;s espec&amp;iacute;ficos, desarrollemos algo de motivaci&amp;oacute;n y consideremos la siguiente funci&amp;oacute;n de &lt;code&gt;compose&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="45a47ec78d51136ebeb7c0035a7c5da00cc87248" translate="yes" xml:space="preserve">
          <source>To get started, we&amp;rsquo;ll need a class which will have the mixin&amp;rsquo;s applied on top of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66869d0f99755ea08df36056766e3e90f0cd610" translate="yes" xml:space="preserve">
          <source>To get the same code working via property accessors, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes" xml:space="preserve">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">Para que funcione el mismo c&amp;oacute;digo, necesitaremos usar una aserci&amp;oacute;n de tipo:</target>
        </trans-unit>
        <trans-unit id="35beccf47f973d38e356b224393b06f7953333cd" translate="yes" xml:space="preserve">
          <source>To give you an idea of how all these pieces can come together, here is a reference &lt;code&gt;.d.ts&lt;/code&gt; to start with when making a new module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fec9382d2cac44b5a2760a5f5fd406c2cf32f49" translate="yes" xml:space="preserve">
          <source>To handle both importing via UMD and modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes" xml:space="preserve">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target state="translated">Para ayudar a mitigar el segundo problema, puede agregar un inicializador expl&amp;iacute;cito o agregar un modificador de &lt;code&gt;declare&lt;/code&gt; para indicar que una propiedad no debe tener emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e6a579a27d8288d6f9fa099e50e47bee7c5f5359" translate="yes" xml:space="preserve">
          <source>To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes" xml:space="preserve">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target state="translated">Para inferir el tipo de &lt;code&gt;x&lt;/code&gt; en el ejemplo anterior, debemos considerar el tipo de cada elemento de la matriz. Aqu&amp;iacute; tenemos dos opciones para el tipo de matriz: &lt;code&gt;number&lt;/code&gt; y &lt;code&gt;null&lt;/code&gt; . El mejor algoritmo de tipo com&amp;uacute;n considera cada tipo de candidato y elige el tipo que es compatible con todos los dem&amp;aacute;s candidatos.</target>
        </trans-unit>
        <trans-unit id="c3a042083562f94184f2e9a526e92d4624f7a75c" translate="yes" xml:space="preserve">
          <source>To learn all of the features available in JSDoc, see &lt;a href=&quot;jsdoc-supported-types&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2445c46ae38decbdcceb4e18f8e4d29d8ec207" translate="yes" xml:space="preserve">
          <source>To learn more about how JavaScript is interpreted by TypeScript read &lt;a href=&quot;type-checking-javascript-files&quot;&gt;How TS Type Checks JS&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808177508af689c394e654a499a68e6b1a4ab02a" translate="yes" xml:space="preserve">
          <source>To learn more about the hundreds of configuration options in the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes" xml:space="preserve">
          <source>To learn more, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;consulte la solicitud de extracci&amp;oacute;n original en GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d48e164ebf0706bbeef6b8d4d1ffab98e9301fa2" translate="yes" xml:space="preserve">
          <source>To learn the type of a variable, use &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes" xml:space="preserve">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target state="translated">Para mantener la seguridad de los tipos, podemos usar la &lt;code&gt;typeof&lt;/code&gt; clave typeof . La &lt;code&gt;typeof&lt;/code&gt; clave typeof , cuando se usa en una posici&amp;oacute;n de tipo, produce el tipo de un valor, en este caso el tipo del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes" xml:space="preserve">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target state="translated">Para fusionar el valor del espacio de nombres,en cada lugar de declaración,si ya existe un espacio de nombres con el nombre dado,se amplía aún más tomando el espacio de nombres existente y añadiendo los miembros exportados del segundo espacio de nombres al primero.</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes" xml:space="preserve">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target state="translated">Para fusionar los espacios de nombres,las definiciones de tipos de las interfaces exportadas declaradas en cada espacio de nombres se fusionan a su vez,formando un único espacio de nombres con definiciones de interfaces fusionadas en su interior.</target>
        </trans-unit>
        <trans-unit id="601f6a1ad7b275eaa55ff8112b05048d0ec9e5bc" translate="yes" xml:space="preserve">
          <source>To model this, we modify the original constructor type to accept a generic argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes" xml:space="preserve">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target state="translated">Para preservar la funcionalidad existente, tambi&amp;eacute;n agregamos un getter simple que recupera &lt;code&gt;fullName&lt;/code&gt; sin modificar.</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes" xml:space="preserve">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target state="translated">Para probarnos a nosotros mismos que nuestro accesorio está comprobando ahora la longitud de los valores,podemos intentar asignar un nombre de más de 10 caracteres y verificar que obtenemos un error.</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes" xml:space="preserve">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target state="translated">Para recapitular rápidamente cómo se ven estos dos enfoques en JavaScript:</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes" xml:space="preserve">
          <source>To read up more about assertion signatures, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las firmas de aserci&amp;oacute;n, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;consulte la solicitud de extracci&amp;oacute;n original&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes" xml:space="preserve">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target state="translated">Para reiterar por qu&amp;eacute; no debe intentar espaciar el contenido de su m&amp;oacute;dulo de nombres, la idea general del espacio de nombres es proporcionar agrupaciones l&amp;oacute;gicas de construcciones y evitar colisiones de nombres. Debido a que el archivo del m&amp;oacute;dulo en s&amp;iacute; ya es una agrupaci&amp;oacute;n l&amp;oacute;gica y su nombre de nivel superior est&amp;aacute; definido por el c&amp;oacute;digo que lo importa, no es necesario utilizar una capa de m&amp;oacute;dulo adicional para los objetos exportados.</target>
        </trans-unit>
        <trans-unit id="1ea09d0dcf7792b419d55f46f04da3421ddf5acc" translate="yes" xml:space="preserve">
          <source>To see these methods in action modify the existing code to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes" xml:space="preserve">
          <source>To specify this relationship to the compiler, use&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt;. &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">Para especificar esta relaci&amp;oacute;n con el compilador, use &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; . &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; especifica una lista de &lt;em&gt;ra&amp;iacute;ces&lt;/em&gt; cuyo contenido se espera que se fusione en tiempo de ejecuci&amp;oacute;n. Entonces, siguiendo nuestro ejemplo, el archivo &lt;code&gt;tsconfig.json&lt;/code&gt; deber&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes" xml:space="preserve">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target state="translated">Para empezar, hagamos el &amp;ldquo;hola mundo&amp;rdquo; de los gen&amp;eacute;ricos: la funci&amp;oacute;n de identidad. La funci&amp;oacute;n de identidad es una funci&amp;oacute;n que devolver&amp;aacute; todo lo que se le pase. Puede pensar en esto de manera similar al comando &lt;code&gt;echo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target state="translated">Para empezar, vamos a estructurar nuestro proyecto de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="3c02e0a11dcbbd64ac3f3d468a0774d3ea7e3a4b" translate="yes" xml:space="preserve">
          <source>To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own &lt;em&gt;quirks&lt;/em&gt; &amp;mdash; oddities and surprises, and JavaScript&amp;rsquo;s humble beginning makes it have &lt;em&gt;many&lt;/em&gt; of these. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9fedcb5b02e069b5600cc79446eace7ee0e944" translate="yes" xml:space="preserve">
          <source>To this JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff04291bfbc2b0841bede7f6b8fa3e70667afd9" translate="yes" xml:space="preserve">
          <source>To understand how namespaces work in &lt;code&gt;.d.ts&lt;/code&gt; files read the &lt;a href=&quot;../deep-dive&quot;&gt;&lt;code&gt;.d.ts&lt;/code&gt; deep dive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes" xml:space="preserve">
          <source>To understand the full impact, read &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">Para entender el impacto total, lea &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;la secci&amp;oacute;n anterior sobre el &lt;code&gt;useDefineForClassFields&lt;/code&gt; bandera&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes" xml:space="preserve">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target state="translated">Para entender qu&amp;eacute; pasos seguir&amp;aacute; el compilador de TS, es importante aclarar un poco los m&amp;oacute;dulos de Node.js. Tradicionalmente, las importaciones en Node.js se realizan llamando a una funci&amp;oacute;n llamada &lt;code&gt;require&lt;/code&gt; . El comportamiento que adopte Node.js ser&amp;aacute; diferente dependiendo de si a &lt;code&gt;require&lt;/code&gt; se le da una ruta relativa o no relativa.</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes" xml:space="preserve">
          <source>To use JSX with React you should use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target state="translated">Para usar JSX con React, debe usar los &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;tipos de React&lt;/a&gt; . Estas tipificaciones definen el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; de forma adecuada para su uso con React.</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes" xml:space="preserve">
          <source>To use JSX-support with React you should use the &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target state="translated">Para usar el soporte JSX con React, debe usar los &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;tipos de React&lt;/a&gt; . Estas tipificaciones definen el espacio de nombres &lt;code&gt;JSX&lt;/code&gt; para que TypeScript pueda verificar correctamente las expresiones JSX para React. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes" xml:space="preserve">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target state="translated">Hoy en d&amp;iacute;a, las bibliotecas de acceso global m&amp;aacute;s populares est&amp;aacute;n escritas como bibliotecas UMD (ver m&amp;aacute;s abajo). La documentaci&amp;oacute;n de la biblioteca UMD es dif&amp;iacute;cil de distinguir de la documentaci&amp;oacute;n de la biblioteca global. Antes de escribir un archivo de declaraci&amp;oacute;n global, aseg&amp;uacute;rese de que la biblioteca no sea realmente UMD.</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes" xml:space="preserve">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target state="translated">Juntos (1) y (2) significan que tenemos que mover nuestra llamada para &lt;code&gt;browserify&lt;/code&gt; fuera de la tarea &lt;code&gt;default&lt;/code&gt; . Y tenemos que darle un nombre &lt;code&gt;default&lt;/code&gt; la funci&amp;oacute;n, ya que tanto Watchify como Gulp necesitan llamarla. Agregar registro con (3) es opcional pero muy &amp;uacute;til para depurar su configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eff2d319ea219f2ac59917c5f301c263edd3b652" translate="yes" xml:space="preserve">
          <source>Together with &lt;a href=&quot;unions-and-intersections&quot;&gt;intersection&lt;/a&gt; types, we can make some pretty mind-bending types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes" xml:space="preserve">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target state="translated">Junto con los tipos de intersección,podemos hacer algunos tipos bastante alucinantes:</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes" xml:space="preserve">
          <source>Too many/too few arguments</source>
          <target state="translated">Demasiados/demasiados pocos argumentos</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes" xml:space="preserve">
          <source>ToolsVersion</source>
          <target state="translated">ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target state="translated">Declaraciones &lt;code&gt;var&lt;/code&gt; de nivel superior o declaraciones de &lt;code&gt;function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfe242d3ed392dcc4dc72844403f2e430bfe4d50" translate="yes" xml:space="preserve">
          <source>Trace Resolution - &lt;code&gt;traceResolution&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes" xml:space="preserve">
          <source>Tracing module resolution</source>
          <target state="translated">Resolución del módulo de rastreo</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes" xml:space="preserve">
          <source>Trade-offs of Modules</source>
          <target state="translated">Intercambio de módulos</target>
        </trans-unit>
        <trans-unit id="b8db22bc5c87c60fca81d73b716c1fab4571ecab" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">El JavaScript tradicional utiliza funciones y herencia basada en prototipos para construir componentes reutilizables,pero esto puede resultar un poco incómodo para los programadores que se sienten más cómodos con un enfoque orientado a los objetos,donde las clases heredan la funcionalidad y los objetos se construyen a partir de estas clases.A partir de ECMAScript 2015,también conocido como ECMAScript 6,los programadores de JavaScript serán capaces de construir sus aplicaciones usando este enfoque orientado a objetos basado en clases.En TypeScript,permitimos a los desarrolladores usar estas técnicas ahora,y compilarlas hasta el JavaScript que funciona en todos los principales navegadores y plataformas,sin tener que esperar a la próxima versión de JavaScript.</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes" xml:space="preserve">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target state="translated">Ahora se permiten las comas finales en las listas de par&amp;aacute;metros y argumentos de la funci&amp;oacute;n. Esta es una implementaci&amp;oacute;n para una &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;propuesta de ECMAScript Stage-3&lt;/a&gt; que emite hasta un ES3 / ES5 / ES6 v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes" xml:space="preserve">
          <source>Trailing commas in function parameter and argument lists</source>
          <target state="translated">Las comillas en las listas de parámetros y argumentos de las funciones</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes" xml:space="preserve">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target state="translated">Traduzca las construcciones de JavaScript m&amp;aacute;s nuevas a una versi&amp;oacute;n anterior como ECMAScript 5 (usando &lt;code&gt;target&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes" xml:space="preserve">
          <source>Triple-Slash Directives</source>
          <target state="translated">Directivas de triple barra</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target state="translated">Las directivas de triple barra &lt;strong&gt;solo&lt;/strong&gt; son v&amp;aacute;lidas en la parte superior de su archivo contenedor. Una directiva de triple barra solo puede ir precedida de comentarios de una o varias l&amp;iacute;neas, incluidas otras directivas de triple barra. Si se encuentran despu&amp;eacute;s de una declaraci&amp;oacute;n o declaraci&amp;oacute;n, se tratan como comentarios regulares de una sola l&amp;iacute;nea y no tienen un significado especial.</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target state="translated">Las directivas de barra triple son comentarios de una sola línea que contienen una sola etiqueta XML.El contenido del comentario se utiliza como directivas del compilador.</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes" xml:space="preserve">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target state="translated">Las referencias de la barra triple indican al compilador que incluya archivos adicionales en el proceso de compilación.</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="209d1157417fde29537d214407cbb04f2fb26b89" translate="yes" xml:space="preserve">
          <source>Trying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn&amp;rsquo;t provide enough tools to describe the exports then you can use &lt;code&gt;namespaces&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes" xml:space="preserve">
          <source>Tuple destructuring</source>
          <target state="translated">Desestructuración de la tupla</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">Tipos de tupla</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes" xml:space="preserve">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">Los tipos de tupla le permiten expresar una matriz con un n&amp;uacute;mero fijo de elementos cuyos tipos son conocidos, pero no es necesario que sean los mismos. Por ejemplo, es posible que desee representar un valor como un par de una &lt;code&gt;string&lt;/code&gt; y un &lt;code&gt;number&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes" xml:space="preserve">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target state="translated">Los tipos de tupla expresan una matriz en la que se conoce el tipo de ciertos elementos, pero no es necesario que sea el mismo. Por ejemplo, es posible que desee representar una matriz con una &lt;code&gt;string&lt;/code&gt; en la posici&amp;oacute;n 0 y un &lt;code&gt;number&lt;/code&gt; en la posici&amp;oacute;n 1:</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">Los tipos de tupla ahora permiten un &lt;code&gt;?&lt;/code&gt; sufijo en tipos de elementos para indicar que el elemento es opcional:</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">Tuplas en los parámetros de reposo y expresiones de difusión</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">Las tuplas pueden ser desestructuradas como matrices;las variables de desestructuración obtienen los tipos de los elementos de la tupla correspondiente:</target>
        </trans-unit>
        <trans-unit id="13179f7189ca168af29df9bd58b2fd52c0614eb0" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6db2244dd129bbdb09e4163ada76293caa34a3" translate="yes" xml:space="preserve">
          <source>Turning on &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;importHelpers&lt;/code&gt; is still false:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0352b1bc1bd302b11a3202f8ca77b3b6a6074227" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;esModuleInterop&lt;/code&gt; will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler,the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f09cc50104b5125d833de6822dd696f449bdb66" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noImplicitAny&lt;/code&gt; however TypeScript will issue an error whenever it would have inferred &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dda13edded0b19f61e1d98b9a246afd41365ec8" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noUncheckedIndexedAccess&lt;/code&gt; will add &lt;code&gt;undefined&lt;/code&gt; to any un-declared field in the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="0bdb148b80769233155853c95838bff4924234bc" translate="yes" xml:space="preserve">
          <source>Type Acquisition - &lt;code&gt;typeAcquisition&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">Tipo Alias</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">tipo alias</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">Comprobación del tipo</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">Escriba la comprobación de los archivos JavaScript</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">Escriba &quot;Checking JavaScript Files&quot;:@enum</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">Escriba &quot;Checking JavaScript Files&quot;:Esto...</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">Escriba &quot;Checking JavaScript Files&quot;:@tipo</target>
        </trans-unit>
        <trans-unit id="e19333b8380c7528aa2f3c6afed5b2505d7443bf" translate="yes" xml:space="preserve">
          <source>Type Checking and d.ts file generation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">Compatibilidad de tipos</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">Compatibilidad de tipos:Enums</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">Tipo Guardias</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">Guardias de tipos y tipos diferenciados</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">Tipo Inferencia</target>
        </trans-unit>
        <trans-unit id="c50d144660c5c67e814a21e78a048bb4d4c2ec30" translate="yes" xml:space="preserve">
          <source>Type Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b024dbff803f7c06dae7d9c5ea0e61258a676b0c" translate="yes" xml:space="preserve">
          <source>Type Roots - &lt;code&gt;typeRoots&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">Los alias de los tipos son exactamente iguales a sus tipos originales;son simplemente nombres alternativos.</target>
        </trans-unit>
        <trans-unit id="0a723dcef74bc94a2959e3631f83bac96553dbc6" translate="yes" xml:space="preserve">
          <source>Type aliases are mere aliases, just like &lt;code&gt;type&lt;/code&gt; in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">Los alias de tipo crean un nuevo nombre para un tipo. Los alias de tipo a veces son similares a las interfaces, pero pueden nombrar primitivas, uniones, tuplas y cualquier otro tipo que de otra manera tendr&amp;iacute;a que escribir a mano.</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">Los alias de tipo siempre han tenido una limitaci&amp;oacute;n en la forma en que se pueden hacer referencia &quot;recursivamente&quot;. La raz&amp;oacute;n es que cualquier uso de un alias de tipo debe poder sustituirse por cualquier alias que tenga. En algunos casos, eso no es posible, por lo que el compilador rechaza ciertos alias recursivos como los siguientes:</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">Escriba las anotaciones</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">Las anotaciones en TypeScript son formas ligeras de registrar el contrato previsto de la función o variable.En este caso,pretendemos que la función de bienvenida se llame con un único parámetro de cadena.Podemos intentar cambiar la llamada greeter para pasar una matriz en su lugar:</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">Tipo de afirmaci&amp;oacute;n / sintaxis fundido en &lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; modo de</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">Aseveraciones de tipo</target>
        </trans-unit>
        <trans-unit id="e17ca89e78f9f5ce2baa8b85a25ab01c83ae36fb" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">Las afirmaciones de tipo tienen dos formas. Uno es la sintaxis de &quot;corchetes angulares&quot;:</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">La verificaci&amp;oacute;n de tipo del operador &lt;code&gt;instanceof&lt;/code&gt; ahora se basa en si el tipo del operando izquierdo se &lt;em&gt;deriva del&lt;/em&gt; tipo indicado por el operando derecho (a diferencia de una verificaci&amp;oacute;n de subtipo estructural).</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">La compatibilidad de tipos en TypeScript se basa en la subtipificación estructural.La tipografía estructural es una forma de relacionar tipos basada únicamente en sus miembros.Esto contrasta con la tipografía nominal.Considere el siguiente código:</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">Escribir guardias y aseveraciones de tipo</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">Las protecciones de tipos para nombres con puntos tambi&amp;eacute;n funcionan con funciones de protecci&amp;oacute;n de tipos definidas por el usuario y los operadores &lt;code&gt;typeof&lt;/code&gt; e &lt;code&gt;instanceof&lt;/code&gt; y no dependen de la opci&amp;oacute;n del compilador &lt;code&gt;--strictNullChecks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">Guardias de tipo inferirse a partir &lt;code&gt;in&lt;/code&gt; operador</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">Escriba a máquina a los guardias en la propiedad común.</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">Los protectores de tipo anteriormente solo admit&amp;iacute;an la verificaci&amp;oacute;n de variables y par&amp;aacute;metros locales. Los protectores de tipos ahora admiten la comprobaci&amp;oacute;n de &quot;nombres con puntos&quot; que consisten en un nombre de par&amp;aacute;metro o variable seguido de uno o m&amp;aacute;s accesos a la propiedad.</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">Escriba en las casillas y confirme que el punto de ruptura se encuentra en el código de TypeScript y que la inspección funciona correctamente.</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">La inferencia de tipo tambi&amp;eacute;n funciona en &quot;la otra direcci&amp;oacute;n&quot; en algunos casos en TypeScript. Esto se conoce como &quot;escritura contextual&quot;. La escritura contextual ocurre cuando el tipo de expresi&amp;oacute;n est&amp;aacute; impl&amp;iacute;cito en su ubicaci&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">Inferencia de tipos en los tipos condicionales</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">Inferencia de parámetros de tipo a partir de tipos contextuales</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">Parámetros de tipo como restricciones</target>
        </trans-unit>
        <trans-unit id="638d8954b09678865ded4d60dc34a31605942b14" translate="yes" xml:space="preserve">
          <source>Type syntax of a C-descended language.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
