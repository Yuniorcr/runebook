<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="e93d86b822e12c4d9ce33d7af413f341c5867140" translate="yes" xml:space="preserve">
          <source>Shared table support for Nim. Use plain old non GC'ed keys and values or you'll be in trouble. Uses a single lock to protect the table, lockfree implementations welcome but if lock contention is so high that you need a lockfree hash table, you're doing it wrong.</source>
          <target state="translated">Soporte de mesa compartido para Nim.Usa las viejas y simples claves y valores no GC'ed o estarás en problemas.Usa un solo candado para proteger la tabla,las implementaciones sin candado son bienvenidas pero si la contención del candado es tan alta que necesitas una tabla de hash sin candado,lo estás haciendo mal.</target>
        </trans-unit>
        <trans-unit id="ec91193d5f88e5c879887f1193cd72ef6a694d25" translate="yes" xml:space="preserve">
          <source>Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</source>
          <target state="translated">Se desplaza a la derecha empujando copias del trozo más izquierdo desde la izquierda,y deja que los trozos más derechos se caigan.</target>
        </trans-unit>
        <trans-unit id="05a85db16fbdbc68d6790c4c1c6d2377589785de" translate="yes" xml:space="preserve">
          <source>Short description of Nim's modules</source>
          <target state="translated">Breve descripción de los módulos de Nim</target>
        </trans-unit>
        <trans-unit id="3aea3a391a6ebfd7b559fa27a009254bdee9654e" translate="yes" xml:space="preserve">
          <source>Short notation for:</source>
          <target state="translated">Anotación corta para:</target>
        </trans-unit>
        <trans-unit id="1b40ffe9db9b97f7227d428a8e93cd1910e5bd51" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a *(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">Atajo para &lt;code&gt;?(a *(b a))&lt;/code&gt; . Suele utilizarse para separadores.</target>
        </trans-unit>
        <trans-unit id="0fea2072669df686bfd29fd3b1504df5061432af" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a +(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">Atajo para &lt;code&gt;?(a +(b a))&lt;/code&gt; . Suele utilizarse para separadores.</target>
        </trans-unit>
        <trans-unit id="cb96e2c575443083f6d3ddc0cd31cddbe58784dd" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt;</source>
          <target state="translated">Atajo para &lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f9539002b86530179421f52fa92949ef36aae77" translate="yes" xml:space="preserve">
          <source>Shortcut version to assign in let blocks. Example:</source>
          <target state="translated">Versión abreviada para asignar bloques de entrada.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="7f2812564b5e2e84d2a67a63d392d651dcda3d10" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dt.inZone(local())&lt;/code&gt; de dt.inZone (local ()) .</target>
        </trans-unit>
        <trans-unit id="088f96652b3ac9c5f1a3b23e8ff7e823708ee634" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dt.inZone(utc())&lt;/code&gt; de dt.inZone (utc ()) .</target>
        </trans-unit>
        <trans-unit id="7cc17510fc204a22966fffd1886072211dea19a4" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;getTime().local&lt;/code&gt;.</source>
          <target state="translated">Abreviatura de &lt;code&gt;getTime().local&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccefd273539ba57e397a1a987afc4b367d6fd0cb" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t.inZone(local())&lt;/code&gt; de t.inZone (local ()) .</target>
        </trans-unit>
        <trans-unit id="4d38209d424b19a4a50f30394d53391f0377fef8" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t.inZone(utc())&lt;/code&gt; de t.inZone (utc ()) .</target>
        </trans-unit>
        <trans-unit id="6166daff0169e3dc89cc83eb9c8606a8a6917a8d" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;dt&lt;/code&gt;.</source>
          <target state="translated">Abreviatura para construir un &lt;code&gt;TimeFormat&lt;/code&gt; y usarlo para formatear &lt;code&gt;dt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f394b42391f134971c4fd4caf836bd1af83856ed" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;time&lt;/code&gt;. Will use the timezone specified by &lt;code&gt;zone&lt;/code&gt;.</source>
          <target state="translated">Abreviatura para construir un &lt;code&gt;TimeFormat&lt;/code&gt; y usarlo para formatear la &lt;code&gt;time&lt;/code&gt; . Utilizar&amp;aacute; la zona horaria especificada por &lt;code&gt;zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="719276957fc6ed6b9a172fd432c232dc57b61097" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;, then converting it a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Abreviatura para construir un &lt;code&gt;TimeFormat&lt;/code&gt; y usarlo para analizar la &lt;code&gt;input&lt;/code&gt; como &lt;code&gt;DateTime&lt;/code&gt; , luego convertirlo en &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="634ede6a595bd79a1f089d455148e4b9e1b829dc" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Abreviatura para construir un &lt;code&gt;TimeFormat&lt;/code&gt; y usarlo para analizar la &lt;code&gt;input&lt;/code&gt; como &lt;code&gt;DateTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a88a0a1d83dbc4654c51021948189560a75286b" translate="yes" xml:space="preserve">
          <source>Shows global variables declarations.</source>
          <target state="translated">Muestra las declaraciones de las variables globales.</target>
        </trans-unit>
        <trans-unit id="0e16604c6fe1879f13dbc7c436126fd3ae0ebb67" translate="yes" xml:space="preserve">
          <source>Shows the cursor.</source>
          <target state="translated">Muestra el cursor.</target>
        </trans-unit>
        <trans-unit id="5ddc127fefceccd7916455147b0c6cd1bfd5eb59" translate="yes" xml:space="preserve">
          <source>Shows when the C compiler is called.</source>
          <target state="translated">Muestra cuando se llama al compilador C.</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="65a4950085292c6592af7d8392c4038e653ea152" translate="yes" xml:space="preserve">
          <source>Sign function. Returns -1 for negative numbers and &lt;em&gt;NegInf&lt;/em&gt;, 1 for positive numbers and &lt;em&gt;Inf&lt;/em&gt;, and 0 for positive zero, negative zero and &lt;em&gt;NaN&lt;/em&gt;.</source>
          <target state="translated">Funci&amp;oacute;n de signo. Devuelve -1 para n&amp;uacute;meros negativos y &lt;em&gt;NegInf&lt;/em&gt; , 1 para n&amp;uacute;meros positivos e &lt;em&gt;Inf&lt;/em&gt; , y 0 para cero positivo, cero negativo y &lt;em&gt;NaN&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8831fa9078748ee02f2347f5d90c34f992582819" translate="yes" xml:space="preserve">
          <source>Signal handling in Nim</source>
          <target state="translated">Manejo de la señal en Nim</target>
        </trans-unit>
        <trans-unit id="f006508366ff589e263e35089658634396886e2b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;recvLine&lt;/code&gt; but designed for non-blocking sockets.</source>
          <target state="translated">Similar a &lt;code&gt;recvLine&lt;/code&gt; pero dise&amp;ntilde;ado para enchufes sin bloqueo.</target>
        </trans-unit>
        <trans-unit id="3088f8f41c176a8c6c078dcbb7290cd8f5dcfe1d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;write&lt;/code&gt;, but treating terminal style arguments specially. When some argument is &lt;code&gt;Style&lt;/code&gt;, &lt;code&gt;set[Style]&lt;/code&gt;, &lt;code&gt;ForegroundColor&lt;/code&gt;, &lt;code&gt;BackgroundColor&lt;/code&gt; or &lt;code&gt;TerminalCmd&lt;/code&gt; then it is not sent directly to &lt;code&gt;f&lt;/code&gt;, but instead corresponding terminal style proc is called.</source>
          <target state="translated">Similar a &lt;code&gt;write&lt;/code&gt; , pero tratando especialmente los argumentos de estilo terminal. Cuando alg&amp;uacute;n argumento es &lt;code&gt;Style&lt;/code&gt; , &lt;code&gt;set[Style]&lt;/code&gt; , &lt;code&gt;ForegroundColor&lt;/code&gt; , &lt;code&gt;BackgroundColor&lt;/code&gt; o &lt;code&gt;TerminalCmd&lt;/code&gt; , entonces no se env&amp;iacute;a directamente a &lt;code&gt;f&lt;/code&gt; , sino que se llama al proceso de estilo de terminal correspondiente.</target>
        </trans-unit>
        <trans-unit id="775c84deb7fd1acce89cc09f380ce7f83b7c3680" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;</source>
          <target state="translated">Similar al &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt; de POSIX&lt;span id=&quot;getpeername_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9112c6f819f5ac3102803b1b46b40279bc4dc6e4" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">Similar al &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt; de POSIX .</target>
        </trans-unit>
        <trans-unit id="d23f8837af17d948ac41ffcd02bd63cca20c677c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importcpp&lt;/code&gt; pragma can be used to import &lt;span id=&quot;cplusplus_2&quot;&gt;C++&lt;/span&gt; methods or C++ symbols in general. The generated code then uses the C++ method calling syntax: &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt;. In combination with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in C++:</source>
          <target state="translated">Similar a la &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;pragma importc para C&lt;/a&gt; , el &lt;code&gt;importcpp&lt;/code&gt; pragma se puede utilizar para importar &lt;span id=&quot;cplusplus_2&quot;&gt;C ++&lt;/span&gt; m&amp;eacute;todos o s&amp;iacute;mbolos C ++ en general. El c&amp;oacute;digo generado luego usa la sintaxis de llamada al m&amp;eacute;todo C ++: &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt; . En combinaci&amp;oacute;n con los &lt;code&gt;header&lt;/code&gt; y &lt;code&gt;emit&lt;/code&gt; pragmas esto permite &lt;em&gt;descuidado&lt;/em&gt; interfaz con bibliotecas escritas en C ++:</target>
        </trans-unit>
        <trans-unit id="f0db59dc951868b6d9e5ad7d56c503fc95dfe4f0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importobjc&lt;/code&gt; pragma can be used to import &lt;span id=&quot;objective-c_2&quot;&gt;Objective C&lt;/span&gt; methods. The generated code then uses the Objective C method calling syntax: &lt;code&gt;[obj method param1: arg]&lt;/code&gt;. In addition with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in Objective C:</source>
          <target state="translated">Al igual que &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma para C&lt;/a&gt; , &lt;code&gt;importobjc&lt;/code&gt; pragma se puede utilizar para importar m&amp;eacute;todos de &lt;span id=&quot;objective-c_2&quot;&gt;Objective C. &lt;/span&gt;El c&amp;oacute;digo generado luego usa la sintaxis de llamada al m&amp;eacute;todo Objective C: &lt;code&gt;[obj method param1: arg]&lt;/code&gt; . Adem&amp;aacute;s con los &lt;code&gt;header&lt;/code&gt; y &lt;code&gt;emit&lt;/code&gt; pragmas esto permite &lt;em&gt;descuidado&lt;/em&gt; interfaz con bibliotecas escritas en C Objetivo:</target>
        </trans-unit>
        <trans-unit id="3adf311c5dd828b7c450080b9fe51795b3cb57d5" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;code&gt;import&lt;/code&gt; statement, the AST is different for &lt;code&gt;export ... except&lt;/code&gt;.</source>
          <target state="translated">Similar a la declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n , el AST es diferente para la &lt;code&gt;export ... except&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17f571225bcdb0061542084cc744c2d22c9a95bd" translate="yes" xml:space="preserve">
          <source>Similarly to &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; in C, it is possible to call &lt;code&gt;paramStr(0)&lt;/code&gt; but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; instead.</source>
          <target state="translated">De manera similar a &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; en C, es posible llamar a &lt;code&gt;paramStr(0)&lt;/code&gt; pero esto devolver&amp;aacute; contenido espec&amp;iacute;fico del sistema operativo (generalmente el nombre del ejecutable invocado). Debe evitar esto y llamar a &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename () en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="0836ce8cc993ea5e6c237d5e13b1926310dd2fc9" translate="yes" xml:space="preserve">
          <source>Similarly to the old &lt;code&gt;doc&lt;/code&gt; command the old &lt;code&gt;jsondoc&lt;/code&gt; command has been renamed &lt;code&gt;jsondoc0&lt;/code&gt;.</source>
          <target state="translated">De manera similar al antiguo comando &lt;code&gt;doc&lt;/code&gt; , el antiguo comando &lt;code&gt;jsondoc&lt;/code&gt; ha sido renombrado como &lt;code&gt;jsondoc0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="923d2208cc2a00f7a0f1b3452857f4ae436b40d2" translate="yes" xml:space="preserve">
          <source>Similarly, any procedure and procedure type declarations that are longer than one line should do the same thing.</source>
          <target state="translated">Del mismo modo,cualquier declaración de procedimiento y de tipo de procedimiento que sea más larga que una línea debería hacer lo mismo.</target>
        </trans-unit>
        <trans-unit id="03199fb1565fa787d6b802de955cc02879b12e5f" translate="yes" xml:space="preserve">
          <source>Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note: Matching performance is hopefully competitive with optimized regular expression engines.</source>
          <target state="translated">Simple coincidencia de PEG (gramática de expresión de análisis).No utiliza la memorización,pero utiliza superoperadores y símbolos en línea para mejorar el rendimiento.Nota:Se espera que el rendimiento del emparejamiento sea competitivo con motores de expresión regular optimizados.</target>
        </trans-unit>
        <trans-unit id="642d63f4b98668cb5f7dde10bc28bf59ccdf215c" translate="yes" xml:space="preserve">
          <source>Simple assertions</source>
          <target state="translated">Afirmaciones simples</target>
        </trans-unit>
        <trans-unit id="edcc542b12309c356f091b9913fd4380c94b4828" translate="yes" xml:space="preserve">
          <source>Simple example that parses the &lt;code&gt;/etc/passwd&lt;/code&gt; file line by line:</source>
          <target state="translated">Ejemplo simple que analiza el &lt;code&gt;/etc/passwd&lt;/code&gt; l&amp;iacute;nea por l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="e8a60d51d4165fef55cc82ac2db54d5e0a688774" translate="yes" xml:space="preserve">
          <source>Simply add --os:nintendoswitch to your usual &lt;code&gt;nim c&lt;/code&gt; or &lt;code&gt;nim cpp&lt;/code&gt; command and set the &lt;code&gt;passC&lt;/code&gt; and &lt;code&gt;passL&lt;/code&gt; command line switches to something like:</source>
          <target state="translated">Simplemente agregue --os: nintendoswitch a su comando &lt;code&gt;nim c&lt;/code&gt; o &lt;code&gt;nim cpp&lt;/code&gt; habitual y configure los interruptores de l&amp;iacute;nea de comando &lt;code&gt;passC&lt;/code&gt; y &lt;code&gt;passL&lt;/code&gt; en algo como:</target>
        </trans-unit>
        <trans-unit id="b090179dd62a9781100bf21383b86b639866ae6b" translate="yes" xml:space="preserve">
          <source>Since Nim generates C++ directly, any destructor is called implicitly by the C++ compiler at the scope exits. This means that often one can get away with not wrapping the destructor at all! However when it needs to be invoked explicitly, it needs to be wrapped. The pattern language provides everything that is required:</source>
          <target state="translated">Como Nim genera C++directamente,cualquier destructor es llamado implícitamente por el compilador de C++en las salidas del alcance.Esto significa que a menudo uno puede salirse con la suya sin envolver el destructor en absoluto! Sin embargo cuando necesita ser invocado explicitamente,necesita ser envuelto.El lenguaje de patrones proporciona todo lo que se requiere:</target>
        </trans-unit>
        <trans-unit id="2836b4cd35895fbe3e4607ab829e68b8adca5bab" translate="yes" xml:space="preserve">
          <source>Since Nim is implemented in Nim, one of the nice things of this feature is that any user with an IDE supporting it can quickly jump around the standard library implementation and see exactly what a proc does, learning about the language and seeing real life examples of how to write/implement specific features.</source>
          <target state="translated">Desde que Nim es implementado en Nim,una de las cosas buenas de esta caracteristica es que cualquier usuario con un IDE que lo soporte puede saltar rapidamente alrededor de la implementacion de la libreria estandar y ver exactamente lo que hace un proc,aprendiendo sobre el lenguaje y viendo ejemplos de la vida real de como escribir/implementar caracteristicas especificas.</target>
        </trans-unit>
        <trans-unit id="81d6398a9d34106da960c47713538b3d721fae12" translate="yes" xml:space="preserve">
          <source>Since Nim's garbage collector is not aware of the C code, once the &lt;code&gt;gimme&lt;/code&gt; proc has finished it can reclaim the memory of the &lt;code&gt;cstring&lt;/code&gt;. However, from a practical standpoint, the C code invoking the &lt;code&gt;gimme&lt;/code&gt; function directly will be able to use it since Nim's garbage collector has not had a chance to run &lt;em&gt;yet&lt;/em&gt;. This gives you enough time to make a copy for the C side of the program, as calling any further Nim procs &lt;em&gt;might&lt;/em&gt; trigger garbage collection making the previously returned string garbage. Or maybe you are &lt;a href=&quot;gc&quot;&gt;yourself triggering the collection&lt;/a&gt;.</source>
          <target state="translated">Dado que el recolector de basura de Nim no conoce el c&amp;oacute;digo C, una vez que el proceso de &lt;code&gt;gimme&lt;/code&gt; ha finalizado, puede recuperar la memoria del &lt;code&gt;cstring&lt;/code&gt; . Sin embargo, desde un punto de vista pr&amp;aacute;ctico, el c&amp;oacute;digo C invocando la &lt;code&gt;gimme&lt;/code&gt; funci&amp;oacute;n directamente ser&amp;aacute; capaz de utilizarlo desde recolector de basura de Nim no ha tenido la oportunidad de correr &lt;em&gt;todav&amp;iacute;a&lt;/em&gt; . Esto le da tiempo suficiente para hacer una copia para el lado C del programa, ya que llamar a cualquier otro proceso de Nim &lt;em&gt;podr&amp;iacute;a&lt;/em&gt; desencadenar la recolecci&amp;oacute;n de basura haciendo que la cadena devuelta previamente sea basura. O tal vez sea usted &lt;a href=&quot;gc&quot;&gt;mismo quien active la colecci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2d2708a6e9c531e547adff103c4d9f239c3ef0" translate="yes" xml:space="preserve">
          <source>Since closures capture local variables by reference it is often not wanted behavior inside loop bodies. See &lt;a href=&quot;system#closureScope&quot;&gt;closureScope&lt;/a&gt; for details on how to change this behavior.</source>
          <target state="translated">Dado que los cierres capturan variables locales por referencia, a menudo no se desea un comportamiento dentro de los cuerpos de los bucles. Consulte &lt;a href=&quot;system#closureScope&quot;&gt;CloserScope&lt;/a&gt; para obtener detalles sobre c&amp;oacute;mo cambiar este comportamiento.</target>
        </trans-unit>
        <trans-unit id="433b2057ed04740122c7f9487a7fd644b8ab062a" translate="yes" xml:space="preserve">
          <source>Since counting up occurs so often in programs, Nim also has a &lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt; iterator that does the same:</source>
          <target state="translated">Dado que el conteo ocurre con tanta frecuencia en los programas, Nim tambi&amp;eacute;n tiene un &lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt; iterador que hace lo mismo:</target>
        </trans-unit>
        <trans-unit id="3f5358496f3a495272baef5ad9c4459080748780" translate="yes" xml:space="preserve">
          <source>Since module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.</source>
          <target state="translated">Dado que los nombres de los módulos suelen ser largos para ser descriptivos,también puede definir un alias más corto para utilizarlo al calificar los símbolos.</target>
        </trans-unit>
        <trans-unit id="eeb691770c7129b48bc1fbd85364e037b06e51a3" translate="yes" xml:space="preserve">
          <source>Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:</source>
          <target state="translated">Dado que los objetos pueden residir en el montón o en la pila,esto aumenta enormemente la expresividad del lenguaje:</target>
        </trans-unit>
        <trans-unit id="d18abb59d5555a0cd68ad92ca498969b76edc73a" translate="yes" xml:space="preserve">
          <source>Since some cases are specific to either &lt;code&gt;ProcRun&lt;/code&gt; or &lt;code&gt;CaasRun&lt;/code&gt; modes, you can prefix a line with the mode and the line will be processed only in that mode.</source>
          <target state="translated">Dado que algunos casos son espec&amp;iacute;ficos de los modos &lt;code&gt;ProcRun&lt;/code&gt; o &lt;code&gt;CaasRun&lt;/code&gt; , puede prefijar una l&amp;iacute;nea con el modo y la l&amp;iacute;nea se procesar&amp;aacute; solo en ese modo.</target>
        </trans-unit>
        <trans-unit id="d1b539956855f09af0d247b1afd8148391989674" translate="yes" xml:space="preserve">
          <source>Since templates and macros that are not declared as &lt;code&gt;immediate&lt;/code&gt; participate in overloading resolution it's essential to have a way to pass unresolved expressions to a template or macro. This is what the meta-type &lt;code&gt;untyped&lt;/code&gt; accomplishes:</source>
          <target state="translated">Dado que las plantillas y macros que no se declaran como &lt;code&gt;immediate&lt;/code&gt; participan en la resoluci&amp;oacute;n de sobrecarga, es esencial tener una forma de pasar las expresiones no resueltas a una plantilla o macro. Esto es lo que logra el meta-tipo sin &lt;code&gt;untyped&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="20070e544008a5d9a536d614aa3a8b327168b8fa" translate="yes" xml:space="preserve">
          <source>Since the input is not modified you can use this version of &lt;code&gt;map&lt;/code&gt; to transform the type of the elements in the input container.</source>
          <target state="translated">Dado que la entrada no se modifica, puede usar esta versi&amp;oacute;n del &lt;code&gt;map&lt;/code&gt; a para transformar el tipo de los elementos en el contenedor de entrada.</target>
        </trans-unit>
        <trans-unit id="8bd7e9132b57aa66fa0c89392e52a98747d0fab5" translate="yes" xml:space="preserve">
          <source>Since types are graphs which can have cycles, the above algorithm needs an auxiliary set &lt;code&gt;s&lt;/code&gt; to detect this case.</source>
          <target state="translated">Dado que los tipos son gr&amp;aacute;ficos que pueden tener ciclos, el algoritmo anterior necesita un conjunto auxiliar &lt;code&gt;s&lt;/code&gt; para detectar este caso.</target>
        </trans-unit>
        <trans-unit id="693c97bf55b6187119c714b7b185fa6734646019" translate="yes" xml:space="preserve">
          <source>Since we adopt the &quot;replay the top level statements&quot; idea, the natural solution to this problem is to emit pseudo top level statements that reflect the mutations done to the global variable. However, this is MUCH harder than it sounds, for example &lt;code&gt;squeaknim&lt;/code&gt; uses this snippet:</source>
          <target state="translated">Dado que adoptamos la idea de &quot;reproducir las declaraciones de nivel superior&quot;, la soluci&amp;oacute;n natural a este problema es emitir declaraciones de nivel superior pseudo que reflejan las mutaciones realizadas a la variable global. Sin embargo, esto es MUCHO m&amp;aacute;s dif&amp;iacute;cil de lo que parece, por ejemplo, &lt;code&gt;squeaknim&lt;/code&gt; usa este fragmento:</target>
        </trans-unit>
        <trans-unit id="d11cd8a4ff2f39268c05039e2c72e08ef63a5b60" translate="yes" xml:space="preserve">
          <source>Since we are building on the previous example generating source code, we will only mention the differences to it. Instead of creating a temporary &lt;code&gt;string&lt;/code&gt; variable and writing into it source code as if it were written &lt;em&gt;by hand&lt;/em&gt;, we use the &lt;code&gt;result&lt;/code&gt; variable directly and create a statement list node (&lt;code&gt;nnkStmtList&lt;/code&gt;) which will hold our children (line 7).</source>
          <target state="translated">Dado que estamos construyendo sobre el ejemplo anterior generando c&amp;oacute;digo fuente, solo mencionaremos las diferencias. En lugar de crear una variable de &lt;code&gt;string&lt;/code&gt; temporal y escribir en ella el c&amp;oacute;digo fuente como si estuviera escrita &lt;em&gt;a mano&lt;/em&gt; , usamos la variable de &lt;code&gt;result&lt;/code&gt; ado directamente y creamos un nodo de lista de instrucciones ( &lt;code&gt;nnkStmtList&lt;/code&gt; ) que contendr&amp;aacute; a nuestros hijos (l&amp;iacute;nea 7).</target>
        </trans-unit>
        <trans-unit id="67281e7beeac085659bafd0aefa97a7715dd587c" translate="yes" xml:space="preserve">
          <source>Skips &lt;code&gt;size&lt;/code&gt; amount of bytes.</source>
          <target state="translated">Omite el &lt;code&gt;size&lt;/code&gt; cantidad de bytes.</target>
        </trans-unit>
        <trans-unit id="caa40925a8a5ba1ec2c47da0074b9498483ee486" translate="yes" xml:space="preserve">
          <source>Skips all characters until one char from the set &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">Omite todos los caracteres hasta que un carb&amp;oacute;n de le&amp;ntilde;a de la serie &lt;em&gt;hasta que&lt;/em&gt; se encuentra o se llega al final. Devuelve el n&amp;uacute;mero de caracteres omitidos.</target>
        </trans-unit>
        <trans-unit id="c0250535bb44963b382eb260412b12ae060f9664" translate="yes" xml:space="preserve">
          <source>Skips all characters until the char &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">Omite todos los caracteres hasta que se encuentra el car&amp;aacute;cter &lt;em&gt;hasta que&lt;/em&gt; se encuentra o se llega al final. Devuelve el n&amp;uacute;mero de caracteres omitidos.</target>
        </trans-unit>
        <trans-unit id="82c633400ddfee46423e0bdfdd5bf1035984706d" translate="yes" xml:space="preserve">
          <source>Skips all characters while one char from the set &lt;em&gt;token&lt;/em&gt; is found. Returns number of characters skipped.</source>
          <target state="translated">Omite todos los caracteres mientras se encuentra un car&amp;aacute;cter del &lt;em&gt;token&lt;/em&gt; establecido . Devuelve el n&amp;uacute;mero de caracteres omitidos.</target>
        </trans-unit>
        <trans-unit id="e7c8076f2280bb4f56da2f4ba9faf089bdaf35a9" translate="yes" xml:space="preserve">
          <source>Skips optional whitespace.</source>
          <target state="translated">Salta el espacio en blanco opcional.</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="3b0fe98905d1d18450c150302cb674830bef8f5f" translate="yes" xml:space="preserve">
          <source>Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a &lt;code&gt;parallel&lt;/code&gt; section.</source>
          <target state="translated">Los cortes est&amp;aacute;n optimizados para que no se realice ninguna copia. Esta optimizaci&amp;oacute;n a&amp;uacute;n no se ha realizado para cortes ordinarios fuera de una secci&amp;oacute;n &lt;code&gt;parallel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4413ae4cc49215fae1d8456ab98bdf32cdd690" translate="yes" xml:space="preserve">
          <source>Slices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.</source>
          <target state="translated">Los sectores se parecen a los tipos de subrangos en sintaxis, pero se utilizan en un contexto diferente. Una rebanada es s&amp;oacute;lo un objeto de tipo Slice que contiene dos l&amp;iacute;mites, &lt;em&gt;una&lt;/em&gt; y &lt;em&gt;b&lt;/em&gt; . Por s&amp;iacute; mismo, un segmento no es muy &amp;uacute;til, pero otros tipos de colecci&amp;oacute;n definen operadores que aceptan objetos Slice para definir rangos.</target>
        </trans-unit>
        <trans-unit id="c3fee626664b2a86ccfce0881ad458405c843067" translate="yes" xml:space="preserve">
          <source>Slightly different version of &lt;code&gt;acceptAddr&lt;/code&gt;.</source>
          <target state="translated">Versi&amp;oacute;n ligeramente diferente de &lt;code&gt;acceptAddr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee7a8ef42831f93c54af4a6309b748729834ca0" translate="yes" xml:space="preserve">
          <source>SmallLshouldNotBeUsed</source>
          <target state="translated">SmallLshouldNotBeUsed</target>
        </trans-unit>
        <trans-unit id="75f4dd2393a33188b388008b159b576f9d6c37ce" translate="yes" xml:space="preserve">
          <source>So &quot;pure object oriented&quot; code is easy to write:</source>
          <target state="translated">Así que el código &quot;orientado a objetos puros&quot; es fácil de escribir:</target>
        </trans-unit>
        <trans-unit id="1884ef29a0caad9d01db393c26a4dacb7998bb83" translate="yes" xml:space="preserve">
          <source>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</source>
          <target state="translated">Por lo tanto,en muchos casos una llamada no hace que el compilador sea demasiado conservador en su análisis de los efectos.</target>
        </trans-unit>
        <trans-unit id="d04b96e54f57571cb5f26f417c712886d005cc49" translate="yes" xml:space="preserve">
          <source>So it is not necessary to write &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; in the above example.</source>
          <target state="translated">Por tanto, no es necesario escribir &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; en el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="8675cecc3e20035fc6e573ebf270227f7c7eb995" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;G.c&lt;/code&gt; MUST contain both &lt;code&gt;P1&lt;/code&gt; and &lt;code&gt;P2&lt;/code&gt;, but we haven't even loaded &lt;code&gt;P1&lt;/code&gt; from the symbol file, nor do we want to because we then quickly would restore large parts of the whole program.</source>
          <target state="translated">As&amp;iacute; que ahora &lt;code&gt;G.c&lt;/code&gt; DEBE contener tanto &lt;code&gt;P1&lt;/code&gt; como &lt;code&gt;P2&lt;/code&gt; , pero ni siquiera hemos cargado &lt;code&gt;P1&lt;/code&gt; desde el archivo de s&amp;iacute;mbolos, ni queremos hacerlo porque luego restaurar&amp;iacute;amos r&amp;aacute;pidamente grandes partes de todo el programa.</target>
        </trans-unit>
        <trans-unit id="d2837e373a9e08b8e4ae0fadd7bcf34bea8bba71" translate="yes" xml:space="preserve">
          <source>So the string &lt;code&gt;b&lt;/code&gt; is of length 19, and two different ways of specifying the indices are</source>
          <target state="translated">Entonces la cadena &lt;code&gt;b&lt;/code&gt; tiene una longitud de 19, y dos formas diferentes de especificar los &amp;iacute;ndices son</target>
        </trans-unit>
        <trans-unit id="e588b1291d20c18b6f2648d5846b37301ef51066" translate="yes" xml:space="preserve">
          <source>So what about &lt;code&gt;2 * a&lt;/code&gt;? We should tell the compiler &lt;code&gt;*&lt;/code&gt; is commutative. We cannot really do that however as the following code only swaps arguments blindly:</source>
          <target state="translated">Entonces, &amp;iquest;qu&amp;eacute; pasa con &lt;code&gt;2 * a&lt;/code&gt; ? Deber&amp;iacute;amos decirle al compilador &lt;code&gt;*&lt;/code&gt; es conmutativo. Sin embargo, realmente no podemos hacer eso, ya que el siguiente c&amp;oacute;digo solo intercambia argumentos a ciegas:</target>
        </trans-unit>
        <trans-unit id="b4e6066da4ec97671c84015a233816abeed1a8d1" translate="yes" xml:space="preserve">
          <source>So, now that we are done with the basics, let's see what Nim offers apart from a nice syntax for procedural programming: &lt;a href=&quot;tut2&quot;&gt;Part II&lt;/a&gt;</source>
          <target state="translated">Entonces, ahora que hemos terminado con lo b&amp;aacute;sico, veamos qu&amp;eacute; ofrece Nim adem&amp;aacute;s de una buena sintaxis para la programaci&amp;oacute;n procedimental: &lt;a href=&quot;tut2&quot;&gt;Parte II&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99f2336f838a801c19d553e0c88c363ba411da59" translate="yes" xml:space="preserve">
          <source>SockClosed</source>
          <target state="translated">SockClosed</target>
        </trans-unit>
        <trans-unit id="2e364384ea1af26a7ae5749a4ee47846386614a6" translate="yes" xml:space="preserve">
          <source>SockConnected</source>
          <target state="translated">SockConnected</target>
        </trans-unit>
        <trans-unit id="ecb1db9b50d2375a93db032e8269b906e3a2d434" translate="yes" xml:space="preserve">
          <source>SockConnecting</source>
          <target state="translated">SockConnecting</target>
        </trans-unit>
        <trans-unit id="f96262d38e15e56e293b395e3a4e585d00445d21" translate="yes" xml:space="preserve">
          <source>SockIdle</source>
          <target state="translated">SockIdle</target>
        </trans-unit>
        <trans-unit id="49173abf46e65756efd207d62345b6562084170d" translate="yes" xml:space="preserve">
          <source>SockListening</source>
          <target state="translated">SockListening</target>
        </trans-unit>
        <trans-unit id="540e5e4a700a40f5403f5305e76a47af819360b6" translate="yes" xml:space="preserve">
          <source>SockUDPBound</source>
          <target state="translated">SockUDPBound</target>
        </trans-unit>
        <trans-unit id="22beb4639862a7b9b676d1e4836131999f91ce5b" translate="yes" xml:space="preserve">
          <source>Socket has been closed.</source>
          <target state="translated">El enchufe ha sido cerrado.</target>
        </trans-unit>
        <trans-unit id="879f6e69a5675653a92a791913da83a48c7fb678" translate="yes" xml:space="preserve">
          <source>Socket has only just been initialised, not connected or closed.</source>
          <target state="translated">El enchufe acaba de ser inicializado,no está conectado ni cerrado.</target>
        </trans-unit>
        <trans-unit id="af4d7eba62345b81d526d2643d898eb239b5cdcf" translate="yes" xml:space="preserve">
          <source>Socket is a UDP socket which is listening for data.</source>
          <target state="translated">El zócalo es un zócalo UDP que está a la escucha de datos.</target>
        </trans-unit>
        <trans-unit id="54b2d18985d4b7f5023824f4fcfddd48ab27cdff" translate="yes" xml:space="preserve">
          <source>Socket is a server socket and is listening for connections.</source>
          <target state="translated">El zócalo es un zócalo de servidor y está a la escucha de las conexiones.</target>
        </trans-unit>
        <trans-unit id="b53ea21e56f48fba083f112fde7dee58dc547eb7" translate="yes" xml:space="preserve">
          <source>Socket is connected to a server.</source>
          <target state="translated">El zócalo está conectado a un servidor.</target>
        </trans-unit>
        <trans-unit id="84e26ccd61f472edc6a5d97a690d05af186f5bed" translate="yes" xml:space="preserve">
          <source>Socket is in the process of connecting to a server.</source>
          <target state="translated">El zócalo está en proceso de conectarse a un servidor.</target>
        </trans-unit>
        <trans-unit id="53b421c08a7dc0ab4bbd194fdc55f0c8077afbc0" translate="yes" xml:space="preserve">
          <source>Sockets which are &lt;strong&gt;not&lt;/strong&gt; ready for reading, writing or which don't have errors waiting on them are removed from the &lt;code&gt;readfds&lt;/code&gt;, &lt;code&gt;writefds&lt;/code&gt;, &lt;code&gt;exceptfds&lt;/code&gt; sequences respectively.</source>
          <target state="translated">Los sockets que &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute;n listos para leer, escribir o que no tienen errores esperando se eliminan de las &lt;code&gt;readfds&lt;/code&gt; , &lt;code&gt;writefds&lt;/code&gt; , &lt;code&gt;exceptfds&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="441c0981544196354c221a53804d865bc53f74b3" translate="yes" xml:space="preserve">
          <source>Solution ~~~~~~~~</source>
          <target state="translated">Solución</target>
        </trans-unit>
        <trans-unit id="a18f034cd6a34c65d1fee4d43db529e754f206cf" translate="yes" xml:space="preserve">
          <source>Some builtins set an error flag. This is then turned into a proper exception. &lt;strong&gt;Note&lt;/strong&gt;: Ordinary application code should not call this.</source>
          <target state="translated">Algunas incorporaciones establecen un indicador de error. Esto luego se convierte en una excepci&amp;oacute;n adecuada. &lt;strong&gt;Nota&lt;/strong&gt; : el c&amp;oacute;digo de aplicaci&amp;oacute;n ordinario no deber&amp;iacute;a llamar a esto.</target>
        </trans-unit>
        <trans-unit id="ab83d5be81d7366ced8b35ee80f8254106e6acd0" translate="yes" xml:space="preserve">
          <source>Some child may be missing. A missing child is a node of kind &lt;code&gt;nnkEmpty&lt;/code&gt;; a child can never be nil.</source>
          <target state="translated">Puede que falte alg&amp;uacute;n ni&amp;ntilde;o. Un ni&amp;ntilde;o perdido es un nodo del tipo &lt;code&gt;nnkEmpty&lt;/code&gt; ; un ni&amp;ntilde;o nunca puede ser nulo.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="fe96e74863b969e67aadbcee97242dea95a7b5c7" translate="yes" xml:space="preserve">
          <source>Some file not essential for the compiler's working could not be opened.</source>
          <target state="translated">Algún archivo no esencial para el funcionamiento del compilador no pudo ser abierto.</target>
        </trans-unit>
        <trans-unit id="a01546d483ad56932b56e6f4f843c335f7232622" translate="yes" xml:space="preserve">
          <source>Some keywords are unused; they are reserved for future developments of the language.</source>
          <target state="translated">Algunas palabras clave no se utilizan;están reservadas para futuros desarrollos del lenguaje.</target>
        </trans-unit>
        <trans-unit id="7cb6d242fa43323b661e091ed4496920bf211e2d" translate="yes" xml:space="preserve">
          <source>Some terminology: in the example &lt;code&gt;question&lt;/code&gt; is called a (formal) &lt;em&gt;parameter&lt;/em&gt;, &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; is called an &lt;em&gt;argument&lt;/em&gt; that is passed to this parameter.</source>
          <target state="translated">Algo de terminolog&amp;iacute;a: en la &lt;code&gt;question&lt;/code&gt; ejemplo se llama &lt;em&gt;par&amp;aacute;metro&lt;/em&gt; (formal) , &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; se llama &lt;em&gt;argumento&lt;/em&gt; que se pasa a este par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="6e93c59acfbd4ca81868fe83cdee12101d3d70c7" translate="yes" xml:space="preserve">
          <source>Some user defined warning.</source>
          <target state="translated">Alguna advertencia definida por el usuario.</target>
        </trans-unit>
        <trans-unit id="3e528bc25235f43baac24e5a82e6fba6ce5447ef" translate="yes" xml:space="preserve">
          <source>Sometimes a C++ class has a private copy constructor and so code like &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; must not be generated but instead &lt;code&gt;Class c(1,2);&lt;/code&gt;. For this purpose the Nim proc that wraps a C++ constructor needs to be annotated with the &lt;span id=&quot;constructor_1&quot;&gt;constructor&lt;/span&gt; pragma. This pragma also helps to generate faster C++ code since construction then doesn't invoke the copy constructor:</source>
          <target state="translated">A veces, una clase C ++ tiene un constructor de copia privado y, por lo tanto, un c&amp;oacute;digo como &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; no se debe generar sino &lt;code&gt;Class c(1,2);&lt;/code&gt; . Para este prop&amp;oacute;sito, el proceso de Nim que envuelve un constructor de C ++ debe anotarse con el pragma del &lt;span id=&quot;constructor_1&quot;&gt;constructor&lt;/span&gt; . Este pragma tambi&amp;eacute;n ayuda a generar c&amp;oacute;digo C ++ m&amp;aacute;s r&amp;aacute;pido ya que la construcci&amp;oacute;n no invoca al constructor de copia:</target>
        </trans-unit>
        <trans-unit id="e2bd3dc5145a046d8756e4c3b5e6319385dd6c64" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, &lt;code&gt;spawn&lt;/code&gt; is also used in the &lt;code&gt;parallel&lt;/code&gt; statement with slightly different semantics. &lt;code&gt;spawn&lt;/code&gt; always takes a call expression of the form &lt;code&gt;f(a, ...)&lt;/code&gt;. Let &lt;code&gt;T&lt;/code&gt; be &lt;code&gt;f&lt;/code&gt;'s return type. If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt; then &lt;code&gt;spawn&lt;/code&gt;'s return type is also &lt;code&gt;void&lt;/code&gt; otherwise it is &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">De manera algo confusa, &lt;code&gt;spawn&lt;/code&gt; tambi&amp;eacute;n se usa en la declaraci&amp;oacute;n &lt;code&gt;parallel&lt;/code&gt; con sem&amp;aacute;ntica ligeramente diferente. &lt;code&gt;spawn&lt;/code&gt; siempre toma una expresi&amp;oacute;n de llamada de la forma &lt;code&gt;f(a, ...)&lt;/code&gt; . Deje que &lt;code&gt;T&lt;/code&gt; sea &lt;code&gt;f&lt;/code&gt; 's tipo de retorno. Si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;void&lt;/code&gt; entonces el tipo de retorno de &lt;code&gt;spawn&lt;/code&gt; tambi&amp;eacute;n es &lt;code&gt;void&lt;/code&gt; contrario, es &lt;code&gt;FlowVar[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="e2de8e03eb7da80a014273d286391bd6a4e6c758" translate="yes" xml:space="preserve">
          <source>Source Code Filters</source>
          <target state="translated">Filtros de código fuente</target>
        </trans-unit>
        <trans-unit id="3c6c119ba4476a2d13a835d7d4fcadc52e3ed050" translate="yes" xml:space="preserve">
          <source>Source code filters</source>
          <target state="translated">Filtros de código fuente</target>
        </trans-unit>
        <trans-unit id="c53df7c2a21cf1297f0d2b03c1f92cdd4f7da3c4" translate="yes" xml:space="preserve">
          <source>Source highlighter for programming or markup languages. Currently only few languages are supported, other languages may be added. The interface supports one language nested in another.</source>
          <target state="translated">Resaltador de fuentes para lenguajes de programación o de marcado.Actualmente sólo se soportan unos pocos lenguajes,se pueden añadir otros.La interfaz soporta un lenguaje anidado en otro.</target>
        </trans-unit>
        <trans-unit id="97ec2600b2e9e2b39f1b45d05ed5cf67fa2a6b53" translate="yes" xml:space="preserve">
          <source>Spacing also determines whether &lt;code&gt;(a, b)&lt;/code&gt; is parsed as an the argument list of a call or whether it is parsed as a tuple constructor:</source>
          <target state="translated">El espaciado tambi&amp;eacute;n determina si &lt;code&gt;(a, b)&lt;/code&gt; se analiza como una lista de argumentos de una llamada o si se analiza como un constructor de tuplas:</target>
        </trans-unit>
        <trans-unit id="49958459a4b8e1eb5bdebb01446519ea2cfeeae3" translate="yes" xml:space="preserve">
          <source>Spacing and Whitespace Conventions</source>
          <target state="translated">Convenciones sobre el espacio y el espacio blanco</target>
        </trans-unit>
        <trans-unit id="f85b49adfe2544a4256034716240a926337b5692" translate="yes" xml:space="preserve">
          <source>Spawn statement</source>
          <target state="translated">Declaración de desove</target>
        </trans-unit>
        <trans-unit id="491354246b5eb961b32b192cc1c055827162214c" translate="yes" xml:space="preserve">
          <source>Special Operators</source>
          <target state="translated">Operadores especiales</target>
        </trans-unit>
        <trans-unit id="e552d4b23e8c0dfe309d5166ff7dd844ec3d8ffe" translate="yes" xml:space="preserve">
          <source>Special Types</source>
          <target state="translated">Tipos especiales</target>
        </trans-unit>
        <trans-unit id="b23516a1efd1b704e237ef91f3620e190e02d0f3" translate="yes" xml:space="preserve">
          <source>Special built-in that takes a variable number of arguments. Each argument is converted to a string via &lt;code&gt;$&lt;/code&gt;, so it works for user-defined types that have an overloaded &lt;code&gt;$&lt;/code&gt; operator. It is roughly equivalent to &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt;, but available for the JavaScript target too.</source>
          <target state="translated">Incorporado especial que toma un n&amp;uacute;mero variable de argumentos. Cada argumento se convierte en una cadena a trav&amp;eacute;s de &lt;code&gt;$&lt;/code&gt; , por lo que funciona para tipos definidos por el usuario que tienen un operador &lt;code&gt;$&lt;/code&gt; sobrecargado . Es aproximadamente equivalente a &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt; , pero tambi&amp;eacute;n disponible para el destino de JavaScript.</target>
        </trans-unit>
        <trans-unit id="f05b76e5943515524507d846a60375ad51a71e57" translate="yes" xml:space="preserve">
          <source>Special care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure &lt;code&gt;GCunref&lt;/code&gt; has to be called before freeing the untraced memory manually:</source>
          <target state="translated">Se debe tener especial cuidado si un objeto sin rastrear contiene objetos con rastreo como referencias, cadenas o secuencias rastreadas: para liberar todo correctamente, se debe llamar al procedimiento &lt;code&gt;GCunref&lt;/code&gt; antes de liberar la memoria sin rastrear manualmente:</target>
        </trans-unit>
        <trans-unit id="a17ccd8347abd9eacd874ea7f27e074ed74467ae" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; can be compiled without any semantic error. This can be used to check whether a type supports some operation:</source>
          <target state="translated">Procedimiento especial en tiempo de compilaci&amp;oacute;n que comprueba si &lt;em&gt;x&lt;/em&gt; se puede compilar sin ning&amp;uacute;n error sem&amp;aacute;ntico. Esto se puede usar para verificar si un tipo admite alguna operaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a820fa7aa10cc8d5c0e8b3e7af391dbbe69898ef" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared in the current scope. &lt;em&gt;x&lt;/em&gt; has to be an identifier.</source>
          <target state="translated">Procedimiento especial en tiempo de compilaci&amp;oacute;n que comprueba si &lt;em&gt;x&lt;/em&gt; est&amp;aacute; declarado en el &amp;aacute;mbito actual. &lt;em&gt;x&lt;/em&gt; tiene que ser un identificador.</target>
        </trans-unit>
        <trans-unit id="a4043ead367d4586fd4c1c0c21c211b7645a7f10" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared. &lt;em&gt;x&lt;/em&gt; has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:</source>
          <target state="translated">Procedimiento especial en tiempo de compilaci&amp;oacute;n que comprueba si se declara &lt;em&gt;x&lt;/em&gt; . &lt;em&gt;x&lt;/em&gt; tiene que ser un identificador o un identificador calificado. Esto se puede usar para verificar si una biblioteca proporciona una caracter&amp;iacute;stica determinada o no:</target>
        </trans-unit>
        <trans-unit id="7c5d0a758aca8fbe6d34b755784c8711b34f72c9" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is defined. &lt;em&gt;x&lt;/em&gt; is an external symbol introduced through the compiler's &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d:x switch&lt;/a&gt; to enable build time conditionals:</source>
          <target state="translated">Procedimiento especial en tiempo de compilaci&amp;oacute;n que comprueba si &lt;em&gt;x&lt;/em&gt; est&amp;aacute; definido. &lt;em&gt;x&lt;/em&gt; es un s&amp;iacute;mbolo externo introducido a trav&amp;eacute;s del modificador &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d: x&lt;/a&gt; del compilador para habilitar los condicionales de tiempo de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9417dbf6690f564bf56645ff26108dd839309071" translate="yes" xml:space="preserve">
          <source>Special future that acts as a queue. Its API is still experimental and so is subject to change.</source>
          <target state="translated">Futuro especial que actúa como una cola.Su API es todavía experimental y por lo tanto está sujeto a cambios.</target>
        </trans-unit>
        <trans-unit id="57782b746713c4b81ac3390082e47036bd29bd10" translate="yes" xml:space="preserve">
          <source>Special node kinds</source>
          <target state="translated">Tipos de nodos especiales</target>
        </trans-unit>
        <trans-unit id="202355e0f6c77c7ad33ab91f862395103c925576" translate="yes" xml:space="preserve">
          <source>Specifies an OS Error Code.</source>
          <target state="translated">Especifica un código de error del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="8fff1eb8c0263a617b1052dd18dc76abb01e14c4" translate="yes" xml:space="preserve">
          <source>Specifies the default calling convention for all procedures (and procedure types) that follow.</source>
          <target state="translated">Especifica la convención de llamada por defecto para todos los procedimientos (y tipos de procedimientos)que siguen.</target>
        </trans-unit>
        <trans-unit id="33f3e9bd75e7c34e8805079b75662d2523e05166" translate="yes" xml:space="preserve">
          <source>Specifies whether this attribute was specified in the original document</source>
          <target state="translated">Especifica si este atributo se especificó en el documento original</target>
        </trans-unit>
        <trans-unit id="9340a269dc5c3688e5ddd09b6883c53291b53287" translate="yes" xml:space="preserve">
          <source>Specify the suite name delimited by &lt;code&gt;&quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">Especifique el nombre de la suite delimitado por &lt;code&gt;&quot;::&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba777a0b8be9b27a2fc0aebaa99a53bd014d0bab" translate="yes" xml:space="preserve">
          <source>Specify the test name as a command line argument.</source>
          <target state="translated">Especifique el nombre de la prueba como argumento de la línea de comandos.</target>
        </trans-unit>
        <trans-unit id="9ce8d37027aa3f3951f0667dbca699e808c4574d" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;fromProc&lt;/code&gt;, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.</source>
          <target state="translated">Especificar &lt;code&gt;fromProc&lt;/code&gt; , que es una cadena que especifica el nombre del proceso al que pertenece este futuro, es un buen h&amp;aacute;bito ya que ayuda con la depuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b1caea9869ffec0e67a014cd78af1ef02ba40db6" translate="yes" xml:space="preserve">
          <source>Specifying the location of the query</source>
          <target state="translated">Especificar la ubicación de la consulta</target>
        </trans-unit>
        <trans-unit id="d3924b51dd7eaa83d08808569b1b0ce045cdc5be" translate="yes" xml:space="preserve">
          <source>Split a number into mantissa and exponent. &lt;em&gt;frexp&lt;/em&gt; calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that &lt;em&gt;x&lt;/em&gt; (the original float value) equals m * 2**n. frexp stores n in &lt;em&gt;exponent&lt;/em&gt; and returns m.</source>
          <target state="translated">Divide un n&amp;uacute;mero en mantisa y exponente. &lt;em&gt;frexp&lt;/em&gt; calcula la mantisa m (un valor flotante mayor o igual a 0.5 y menor que 1) y el valor entero n tal que &lt;em&gt;x&lt;/em&gt; (el valor flotante original) es igual a m * 2 ** n. frexp almacena n en &lt;em&gt;exponente&lt;/em&gt; y devuelve m.</target>
        </trans-unit>
        <trans-unit id="0745140758afddfc4ee7cc02a1b14f4076dc0642" translate="yes" xml:space="preserve">
          <source>Split the string at the first or last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">Divida la cadena en la primera o &amp;uacute;ltima aparici&amp;oacute;n de &lt;em&gt;sep&lt;/em&gt; en una tupla de 3</target>
        </trans-unit>
        <trans-unit id="696d32e8d8bbfbcb085e88d7ad30d5090043c8af" translate="yes" xml:space="preserve">
          <source>Split the string at the last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">Divida la cadena en la &amp;uacute;ltima aparici&amp;oacute;n de &lt;em&gt;sep&lt;/em&gt; en una tupla de 3</target>
        </trans-unit>
        <trans-unit id="9b30837131faaf707d014d0ca36f825f274439f5" translate="yes" xml:space="preserve">
          <source>Splits a &lt;span id=&quot;command-line_1&quot;&gt;command line&lt;/span&gt; into several components; This proc is only occasionally useful, better use the &lt;em&gt;parseopt&lt;/em&gt; module.</source>
          <target state="translated">Divide una &lt;span id=&quot;command-line_1&quot;&gt;l&amp;iacute;nea de comando&lt;/span&gt; en varios componentes; Este proceso solo es &amp;uacute;til ocasionalmente, mejor use el m&amp;oacute;dulo &lt;em&gt;parseopt&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f6fefaa7fc5767e6bf862c955b2209fdb94636" translate="yes" xml:space="preserve">
          <source>Splits a directory into (head, tail), so that &lt;code&gt;head / tail == path&lt;/code&gt; (except for edge cases like &quot;/usr&quot;).</source>
          <target state="translated">Divide un directorio en (head, tail), de modo que &lt;code&gt;head / tail == path&lt;/code&gt; (excepto en casos extremos como &quot;/ usr&quot;).</target>
        </trans-unit>
        <trans-unit id="d3a95cdd0557cc6b3279f5bbb847dfba5f79895c" translate="yes" xml:space="preserve">
          <source>Splits a filename into (dir, filename, extension). &lt;em&gt;dir&lt;/em&gt; does not end in &lt;em&gt;DirSep&lt;/em&gt;. &lt;em&gt;extension&lt;/em&gt; includes the leading dot.</source>
          <target state="translated">Divide un nombre de archivo en (dir, nombre de archivo, extensi&amp;oacute;n). &lt;em&gt;dir&lt;/em&gt; no termina en &lt;em&gt;DirSep&lt;/em&gt; . &lt;em&gt;la extensi&amp;oacute;n&lt;/em&gt; incluye el punto inicial.</target>
        </trans-unit>
        <trans-unit id="38adfc0e948e54bb128886ea5c9d463e755da1e5" translate="yes" xml:space="preserve">
          <source>Splits and distributes a sequence &lt;em&gt;s&lt;/em&gt; into &lt;em&gt;num&lt;/em&gt; sub sequences.</source>
          <target state="translated">Splits y distribuye una secuencia &lt;em&gt;s&lt;/em&gt; en &lt;em&gt;num&lt;/em&gt; secuencias SUB.</target>
        </trans-unit>
        <trans-unit id="a0c6e0e448f34874bff64437b7d2ab91fdf935d9" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; at whitespace stripping leading and trailing whitespace if necessary. If &lt;code&gt;maxsplit&lt;/code&gt; is specified and is positive, no more than &lt;code&gt;maxsplit&lt;/code&gt; splits is made.</source>
          <target state="translated">Divide la cadena &lt;code&gt;s&lt;/code&gt; en los espacios en blanco eliminando los espacios en blanco iniciales y finales si es necesario. Si se especifica &lt;code&gt;maxsplit&lt;/code&gt; y es positivo, no se &lt;code&gt;maxsplit&lt;/code&gt; divisiones que maxsplit .</target>
        </trans-unit>
        <trans-unit id="a79255370060c2e50f8a5845d572dc8618abf3bc" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into a seq of substrings.</source>
          <target state="translated">Divide la cadena &lt;code&gt;s&lt;/code&gt; en una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="cb7b44f53469c886c88f238f833dcf716ae5cf1d" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into substrings.</source>
          <target state="translated">Divide la cadena &lt;code&gt;s&lt;/code&gt; en subcadenas.</target>
        </trans-unit>
        <trans-unit id="7bee92474f34808ecc0e41e36df829980b2f1e85" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into its containing lines.</source>
          <target state="translated">Divide la cadena &lt;em&gt;s&lt;/em&gt; en sus l&amp;iacute;neas contenedoras.</target>
        </trans-unit>
        <trans-unit id="5b2ee834c17d5b26b6e4fac9083478adf72ace42" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">Divide la cadena &lt;em&gt;s&lt;/em&gt; en subcadenas desde la derecha usando un separador de cadena. Funciona exactamente igual que el &lt;a href=&quot;#split.i,string,char,int&quot;&gt;iterador dividido,&lt;/a&gt; excepto en orden inverso.</target>
        </trans-unit>
        <trans-unit id="087310e18b69609a2aa211f0f42cebd7c1cd07af" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">Divide la cadena &lt;em&gt;s&lt;/em&gt; en subcadenas desde la derecha usando un separador de cadena. Funciona exactamente igual que el &lt;a href=&quot;#split.i,string,string,int&quot;&gt;iterador dividido,&lt;/a&gt; excepto en orden inverso.</target>
        </trans-unit>
        <trans-unit id="cd60b97467de78d203515610e7c117f7aca90a40" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a group of separators.</source>
          <target state="translated">Divide la cadena &lt;em&gt;s&lt;/em&gt; en subcadenas usando un grupo de separadores.</target>
        </trans-unit>
        <trans-unit id="006e1144089a0526e01f597553d1e7c5c932d6fd" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a single separator.</source>
          <target state="translated">Divide la cadena &lt;em&gt;s&lt;/em&gt; en subcadenas usando un solo separador.</target>
        </trans-unit>
        <trans-unit id="f52fdc09a9930420c66d61ce94065811386774f2" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a string separator.</source>
          <target state="translated">Divide la cadena &lt;em&gt;s&lt;/em&gt; en subcadenas usando un separador de cadena.</target>
        </trans-unit>
        <trans-unit id="bdcf8c0eeb58a21cdf0ea123c375dc7b74b4c1c3" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">Divide la cadena &lt;em&gt;s&lt;/em&gt; en subcadenas.</target>
        </trans-unit>
        <trans-unit id="7ba91be4e0a331af370fe3ce81d200f372c209c4" translate="yes" xml:space="preserve">
          <source>Square root for a complex number &lt;em&gt;z&lt;/em&gt;.</source>
          <target state="translated">Ra&amp;iacute;z cuadrada de un n&amp;uacute;mero complejo &lt;em&gt;z&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c7d890a6474c971c057ab4ea575d83552a62c69b" translate="yes" xml:space="preserve">
          <source>StackTrace</source>
          <target state="translated">StackTrace</target>
        </trans-unit>
        <trans-unit id="5834da0d9d1f734eeb82b865257b78b65132ac61" translate="yes" xml:space="preserve">
          <source>StackTrace option</source>
          <target state="translated">Opción StackTrace</target>
        </trans-unit>
        <trans-unit id="97a27501491262c65d421114e5586483e201f5db" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeFloat&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">Implementaci&amp;oacute;n de formato est&amp;aacute;ndar para &lt;code&gt;SomeFloat&lt;/code&gt; . Tiene poco sentido llamar a esto directamente, pero la macro &lt;code&gt;&amp;amp;&lt;/code&gt; requiere que exista .</target>
        </trans-unit>
        <trans-unit id="6c9988eb477879aef4e84166efb847dbda62ecb3" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeInteger&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">Implementaci&amp;oacute;n de formato est&amp;aacute;ndar para &lt;code&gt;SomeInteger&lt;/code&gt; . Tiene poco sentido llamar a esto directamente, pero la macro &lt;code&gt;&amp;amp;&lt;/code&gt; requiere que exista .</target>
        </trans-unit>
        <trans-unit id="82b4f534d5b70cca26d540da82df24c1661c25fa" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;string&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">Implementaci&amp;oacute;n de formato est&amp;aacute;ndar para &lt;code&gt;string&lt;/code&gt; . Tiene poco sentido llamar a esto directamente, pero la macro &lt;code&gt;&amp;amp;&lt;/code&gt; requiere que exista .</target>
        </trans-unit>
        <trans-unit id="286926a53b71c9700c85a0fe22c8494800f423ec" translate="yes" xml:space="preserve">
          <source>Standard format specifier for strings, integers and floats</source>
          <target state="translated">Especificador de formato estándar para cuerdas,enteros y flotadores</target>
        </trans-unit>
        <trans-unit id="e4536991ce4cfc6d6a8e33066d777f94420dea8c" translate="yes" xml:space="preserve">
          <source>Start types with a capital &lt;code&gt;T&lt;/code&gt;, unless they are pointers/references which start with &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">Comience tipos con un capital &lt;code&gt;T&lt;/code&gt; , a menos que sean punteros / referencias que comienzan con &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59898b19b077c1855bd9ba49e69a1b8694d1ea8a" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for read availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">Comience a observar el descriptor de archivo para ver la disponibilidad de lectura y luego llame al &lt;code&gt;cb&lt;/code&gt; de devoluci&amp;oacute;n de llamada .</target>
        </trans-unit>
        <trans-unit id="c48d22286fde2df857b4c72495d932198256b33b" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for write availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">Comience a observar el descriptor de archivo para ver la disponibilidad de escritura y luego llame al callback &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e536d288d0851f6d9e8276875d7977f4844842b" translate="yes" xml:space="preserve">
          <source>Starting with c2nim version 0.9.8 it is also possible to directly embed Nim code in the C file. This is handy when you don't want to modify the generated Nim code at all. Nim code can be embedded directly via &lt;code&gt;#@ Nim code here @#&lt;/code&gt;:</source>
          <target state="translated">A partir de la versi&amp;oacute;n 0.9.8 de c2nim, tambi&amp;eacute;n es posible incrustar directamente c&amp;oacute;digo Nim en el archivo C. Esto es &amp;uacute;til cuando no desea modificar el c&amp;oacute;digo Nim generado en absoluto. El c&amp;oacute;digo Nim se puede incrustar directamente a trav&amp;eacute;s del &lt;code&gt;#@ Nim code here @#&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bde902e0e1c0a059e5fe83c9f5f9792a0e51c8a5" translate="yes" xml:space="preserve">
          <source>Starting with the simplest case, a &lt;code&gt;type&lt;/code&gt; section appears much like &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">Comenzando con el caso m&amp;aacute;s simple, una secci&amp;oacute;n de &lt;code&gt;type&lt;/code&gt; se parece mucho a &lt;code&gt;var&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5750880c4922c991ffb618071f7738d4d0253363" translate="yes" xml:space="preserve">
          <source>Starting with version 0.13.0 of the language Nim supports multiline comments. They look like:</source>
          <target state="translated">A partir de la versión 0.13.0 del lenguaje Nim soporta comentarios multilínea.Se ven como:</target>
        </trans-unit>
        <trans-unit id="0bc24feae6a6568706e81e7f2d7d483485e4dca3" translate="yes" xml:space="preserve">
          <source>Starting with version 0.14 of the language, Nim supports &lt;code&gt;field&lt;/code&gt; as a shortcut for &lt;code&gt;self.field&lt;/code&gt; comparable to the &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; keyword in Java or C++. This feature has to be explicitly enabled via a &lt;code&gt;{.this: self.}&lt;/code&gt; statement pragma. This pragma is active for the rest of the module:</source>
          <target state="translated">A partir de la versi&amp;oacute;n 0.14 del lenguaje, Nim admite &lt;code&gt;field&lt;/code&gt; como atajo para &lt;code&gt;self.field&lt;/code&gt; comparable a la palabra clave &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; en Java o C ++. Esta caracter&amp;iacute;stica debe habilitarse expl&amp;iacute;citamente mediante un pragma de declaraci&amp;oacute;n &lt;code&gt;{.this: self.}&lt;/code&gt; . Este pragma est&amp;aacute; activo durante el resto del m&amp;oacute;dulo:</target>
        </trans-unit>
        <trans-unit id="fb2ad21d99439d76c4ae769b916f899ad8dad268" translate="yes" xml:space="preserve">
          <source>Starts a process. &lt;em&gt;Command&lt;/em&gt; is the executable file, &lt;em&gt;workingDir&lt;/em&gt; is the process's working directory. If &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; the current directory is used. &lt;em&gt;args&lt;/em&gt; are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. &lt;em&gt;args&lt;/em&gt; should not contain this argument! &lt;em&gt;env&lt;/em&gt; is the environment that will be passed to the process. If &lt;code&gt;env == nil&lt;/code&gt; the environment is inherited of the parent process. &lt;em&gt;options&lt;/em&gt; are additional flags that may be passed to &lt;em&gt;startProcess&lt;/em&gt;. See the documentation of &lt;code&gt;ProcessOption&lt;/code&gt; for the meaning of these flags. You need to &lt;em&gt;close&lt;/em&gt; the process when done.</source>
          <target state="translated">Inicia un proceso. &lt;em&gt;Command&lt;/em&gt; es el archivo ejecutable, &lt;em&gt;workingDir&lt;/em&gt; es el directorio de trabajo del proceso. Si &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; se utiliza el directorio actual. &lt;em&gt;args&lt;/em&gt; son los argumentos de la l&amp;iacute;nea de comandos que se pasan al proceso. En muchos sistemas operativos, el primer argumento de la l&amp;iacute;nea de comandos es el nombre del ejecutable. &lt;em&gt;&amp;iexcl;args&lt;/em&gt; no debe contener este argumento! &lt;em&gt;env&lt;/em&gt; es el entorno que se pasar&amp;aacute; al proceso. Si &lt;code&gt;env == nil&lt;/code&gt; el entorno se hereda del proceso padre. &lt;em&gt;Las opciones&lt;/em&gt; son indicadores adicionales que se pueden pasar a &lt;em&gt;startProcess&lt;/em&gt; . Ver la documentaci&amp;oacute;n de &lt;code&gt;ProcessOption&lt;/code&gt; por el significado de estas banderas. Necesita &lt;em&gt;cerrar&lt;/em&gt; el proceso cuando haya terminado.</target>
        </trans-unit>
        <trans-unit id="e1e47e87b9fe76e44fbbfad1b5c2f3cec6f694d4" translate="yes" xml:space="preserve">
          <source>Starts main coroutine scheduler loop which exits when all coroutines exit. Calling this proc starts execution of first coroutine.</source>
          <target state="translated">Inicia el bucle principal del programador de corutina que sale cuando todas las corutinas salen.Al llamar a este proceso se inicia la ejecución de la primera corutina.</target>
        </trans-unit>
        <trans-unit id="e4b62e8fbf218158e05c575bcb526db8434456d7" translate="yes" xml:space="preserve">
          <source>Starts the process of listening for incoming HTTP connections on the specified address and port.</source>
          <target state="translated">Inicia el proceso de escucha de las conexiones HTTP entrantes en la dirección y puerto especificados.</target>
        </trans-unit>
        <trans-unit id="95e9a635c9383520925e14042d4b923fd6c3ac7c" translate="yes" xml:space="preserve">
          <source>Startswith vs full match</source>
          <target state="translated">Empieza con un partido completo</target>
        </trans-unit>
        <trans-unit id="2f3fd7595abb518c6624f116892060fa788f065b" translate="yes" xml:space="preserve">
          <source>State of the random number generator. The procs that use the default state are &lt;strong&gt;not&lt;/strong&gt; thread-safe!</source>
          <target state="translated">Estado del generador de n&amp;uacute;meros aleatorios. &amp;iexcl;Los procesos que usan el estado predeterminado &lt;strong&gt;no&lt;/strong&gt; son seguros para subprocesos!</target>
        </trans-unit>
        <trans-unit id="585af40bd2ea53a8fcbac51a9fdd078062535c3e" translate="yes" xml:space="preserve">
          <source>Statement Macros</source>
          <target state="translated">Macros de declaración</target>
        </trans-unit>
        <trans-unit id="c1d090a6c68c4210ac3bd5dfc03a161d8ee95112" translate="yes" xml:space="preserve">
          <source>Statement list</source>
          <target state="translated">Lista de declaraciones</target>
        </trans-unit>
        <trans-unit id="e9d413cd91133512c4e3171d0a7ea1f91f1b99be" translate="yes" xml:space="preserve">
          <source>Statement list expression</source>
          <target state="translated">Expresión de la lista de declaraciones</target>
        </trans-unit>
        <trans-unit id="561838a377363a51093422d3a816d894fc64a7aa" translate="yes" xml:space="preserve">
          <source>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</source>
          <target state="translated">Las macros de declaración se definen como macros de expresión.Sin embargo,son invocadas por una expresión que sigue a los dos puntos.</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="5328a225bf88e0ed36c05ac4a8717682f2fb065b" translate="yes" xml:space="preserve">
          <source>Statements and expressions</source>
          <target state="translated">Declaraciones y expresiones</target>
        </trans-unit>
        <trans-unit id="28b50d2ede0bbc0df4e2532f866848d6bf82cffb" translate="yes" xml:space="preserve">
          <source>Statements and indentation</source>
          <target state="translated">Declaraciones y sangría</target>
        </trans-unit>
        <trans-unit id="2f0b50bd8139f25d6003b6a910f512893ff24a3e" translate="yes" xml:space="preserve">
          <source>Statements are separated into &lt;span id=&quot;simple-statements_1&quot;&gt;simple statements&lt;/span&gt; and &lt;span id=&quot;complex-statements_1&quot;&gt;complex statements&lt;/span&gt;. Simple statements are statements that cannot contain other statements like assignments, calls or the &lt;code&gt;return&lt;/code&gt; statement; complex statements can contain other statements. To avoid the &lt;span id=&quot;dangling-else-problem_1&quot;&gt;dangling else problem&lt;/span&gt;, complex statements always have to be indented. The details can be found in the grammar.</source>
          <target state="translated">Las declaraciones se dividen en &lt;span id=&quot;simple-statements_1&quot;&gt;declaraciones simples&lt;/span&gt; y &lt;span id=&quot;complex-statements_1&quot;&gt;declaraciones complejas&lt;/span&gt; . Las declaraciones simples son declaraciones que no pueden contener otras declaraciones como asignaciones, llamadas o la declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; ; Las declaraciones complejas pueden contener otras declaraciones. Para evitar el &lt;span id=&quot;dangling-else-problem_1&quot;&gt;problema del else pendiente&lt;/span&gt; , las declaraciones complejas siempre deben tener sangr&amp;iacute;a. Los detalles se pueden encontrar en la gram&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="73e132de8d234237b097eae09c8f41a5d3aeb437" translate="yes" xml:space="preserve">
          <source>Statements can also occur in an expression context that looks like &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt;. This is called an statement list expression or &lt;code&gt;(;)&lt;/code&gt;. The type of &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; is the type of &lt;code&gt;ex&lt;/code&gt;. All the other statements must be of type &lt;code&gt;void&lt;/code&gt;. (One can use &lt;code&gt;discard&lt;/code&gt; to produce a &lt;code&gt;void&lt;/code&gt; type.) &lt;code&gt;(;)&lt;/code&gt; does not introduce a new scope.</source>
          <target state="translated">Las declaraciones tambi&amp;eacute;n pueden ocurrir en un contexto de expresi&amp;oacute;n similar a &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; . Esto se denomina expresi&amp;oacute;n de lista de instrucciones o &lt;code&gt;(;)&lt;/code&gt; . El tipo de &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; es el tipo de &lt;code&gt;ex&lt;/code&gt; . Todas las dem&amp;aacute;s declaraciones deben ser de tipo &lt;code&gt;void&lt;/code&gt; . (Se puede usar &lt;code&gt;discard&lt;/code&gt; para producir un tipo &lt;code&gt;void&lt;/code&gt; .) &lt;code&gt;(;)&lt;/code&gt; No introduce un nuevo alcance.</target>
        </trans-unit>
        <trans-unit id="09ba2d803c92fca5d318023b8b22a1bf044aeec2" translate="yes" xml:space="preserve">
          <source>States that &lt;em&gt;every&lt;/em&gt; other parameter must not alias with the marked parameter.</source>
          <target state="translated">Establece que &lt;em&gt;todos los&lt;/em&gt; dem&amp;aacute;s par&amp;aacute;metros no deben tener un alias con el par&amp;aacute;metro marcado.</target>
        </trans-unit>
        <trans-unit id="b21c7be07ec4d071647590676d7c707716706eb2" translate="yes" xml:space="preserve">
          <source>States that the marked parameter needs to alias with &lt;em&gt;some&lt;/em&gt; other parameter.</source>
          <target state="translated">Indica que el par&amp;aacute;metro marcado necesita un alias con &lt;em&gt;alg&amp;uacute;n&lt;/em&gt; otro par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="bda29e5bb4f9a6e91109576feba5b699a9ffa7c4" translate="yes" xml:space="preserve">
          <source>Static params can also appear in the signatures of generic types:</source>
          <target state="translated">Los parámeros estáticos también pueden aparecer en las firmas de los tipos genéricos:</target>
        </trans-unit>
        <trans-unit id="fd4eea69c0fcf4c239e8f32cdb22fe3e56921d96" translate="yes" xml:space="preserve">
          <source>Static statement/expression</source>
          <target state="translated">Declaración/expresión estática</target>
        </trans-unit>
        <trans-unit id="1efa0116abdd20c68f5da9f1569291c9d6bcab18" translate="yes" xml:space="preserve">
          <source>Static types, like &lt;code&gt;static[int]&lt;/code&gt;, use &lt;code&gt;nnkIdent&lt;/code&gt; wrapped in &lt;code&gt;nnkStaticTy&lt;/code&gt;.</source>
          <target state="translated">Los tipos est&amp;aacute;ticos, como &lt;code&gt;static[int]&lt;/code&gt; , usan &lt;code&gt;nnkIdent&lt;/code&gt; envuelto en &lt;code&gt;nnkStaticTy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df6826b4250b90fb4e378254d9554431e3e76513" translate="yes" xml:space="preserve">
          <source>Statically typed wrapper around a JavaScript object.</source>
          <target state="translated">Un envoltorio escrito estáticamente alrededor de un objeto de JavaScript.</target>
        </trans-unit>
        <trans-unit id="f99da6af391d7d0b1782b934b78439cc36d3ec64" translate="yes" xml:space="preserve">
          <source>Statistical analysis framework for performing basic statistical analysis of data. The data is analysed in a single pass, when a data value is pushed to the &lt;code&gt;RunningStat&lt;/code&gt; or &lt;code&gt;RunningRegress&lt;/code&gt; objects</source>
          <target state="translated">Marco de an&amp;aacute;lisis estad&amp;iacute;stico para realizar an&amp;aacute;lisis estad&amp;iacute;stico b&amp;aacute;sico de datos. Los datos se analizan en una sola pasada, cuando un valor de datos se &lt;code&gt;RunningRegress&lt;/code&gt; objetos &lt;code&gt;RunningStat&lt;/code&gt; o RunningRegress</target>
        </trans-unit>
        <trans-unit id="95c5b7897012d8f6b29894d9aacb62893a21c7dd" translate="yes" xml:space="preserve">
          <source>StdTmpl filter</source>
          <target state="translated">Filtro StdTmpl</target>
        </trans-unit>
        <trans-unit id="2d517ff3e91f20612466e4d677722b435331123f" translate="yes" xml:space="preserve">
          <source>Stop the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="translated">Detener el proceso &lt;em&gt;p&lt;/em&gt; . En los sistemas operativos Posix, el procedimiento env&amp;iacute;a &lt;code&gt;SIGTERM&lt;/code&gt; al proceso. En Windows, se llama a la funci&amp;oacute;n &lt;code&gt;TerminateProcess()&lt;/code&gt; la API de Win32 para detener el proceso.</target>
        </trans-unit>
        <trans-unit id="193670292bbf8be6929e6f76418e0773142d3e9f" translate="yes" xml:space="preserve">
          <source>Stops coroutine execution and resumes no sooner than after &lt;code&gt;sleeptime&lt;/code&gt; seconds. Until then other coroutines are executed.</source>
          <target state="translated">Detiene la ejecuci&amp;oacute;n de una rutina y se reanuda no antes de &lt;code&gt;sleeptime&lt;/code&gt; segundos del tiempo de inactividad . Hasta entonces se ejecutan otras corrutinas.</target>
        </trans-unit>
        <trans-unit id="c692f32f2608c4a295dcfea18799b8cd9fd2f756" translate="yes" xml:space="preserve">
          <source>Stops the program immediately with an exit code.</source>
          <target state="translated">Detiene el programa inmediatamente con un código de salida.</target>
        </trans-unit>
        <trans-unit id="6c7da5ae9d8453249af10e3df51f169922c5fe26" translate="yes" xml:space="preserve">
          <source>Store implementation-defined representation of the exception flags indicated by &lt;em&gt;excepts&lt;/em&gt; in the object pointed to by &lt;em&gt;flagp&lt;/em&gt;.</source>
          <target state="translated">Almacene la representaci&amp;oacute;n definida por la implementaci&amp;oacute;n de los indicadores de excepci&amp;oacute;n indicados por &lt;em&gt;excepciones&lt;/em&gt; en el objeto al que apunta &lt;em&gt;flagp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd07ac3fcadc296f8eadaaee32c2d2045b485375" translate="yes" xml:space="preserve">
          <source>Store the current floating-point environment in the object pointed to by &lt;em&gt;envp&lt;/em&gt;.</source>
          <target state="translated">Almacene el entorno de punto flotante actual en el objeto al que apunta &lt;em&gt;envp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ed122e970e1da75eae7113f501ba6a2683599b66" translate="yes" xml:space="preserve">
          <source>Stores arbitrary data inside SSLContext. The unique &lt;em&gt;index&lt;/em&gt; should be retrieved using getSslContextExtraDataIndex.</source>
          <target state="translated">Almacena datos arbitrarios dentro de SSLContext. El &lt;em&gt;&amp;iacute;ndice&lt;/em&gt; &amp;uacute;nico debe recuperarse mediante getSslContextExtraDataIndex.</target>
        </trans-unit>
        <trans-unit id="3561a6520c3d5d295122d365e075a71d866713db" translate="yes" xml:space="preserve">
          <source>Stores the empty string or the last headline/overline found in the rst document, so it can be used as a prettier name for term index generation.</source>
          <target state="translated">Almacena la cadena vacía o el último titular/superlínea que se encuentra en el primer documento,por lo que puede ser utilizado como un nombre más bonito para la generación del índice de términos.</target>
        </trans-unit>
        <trans-unit id="48c0d4450fba91caf6c704085748bb15b5343e9a" translate="yes" xml:space="preserve">
          <source>Stream interface that supports writing or reading. Note that these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="translated">Interfaz de streaming que soporta la escritura o la lectura.Tenga en cuenta que estos campos de aquí no deben ser utilizados directamente.Son accesibles para que una implementación de streaming pueda anularlos.</target>
        </trans-unit>
        <trans-unit id="51a31e0d2f2e0f77e70f94326ee6904303908d73" translate="yes" xml:space="preserve">
          <source>String &lt;span id=&quot;interpolation_1&quot;&gt;interpolation&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;format&lt;/span&gt; inspired by Python's &lt;code&gt;f&lt;/code&gt;-strings.</source>
          <target state="translated">&lt;span id=&quot;interpolation_1&quot;&gt;Interpolaci&amp;oacute;n&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;formato de&lt;/span&gt; cadenas inspirado en las cadenas &lt;code&gt;f&lt;/code&gt; de Python.</target>
        </trans-unit>
        <trans-unit id="dff366ef5455c79b8728295225889786b796cf17" translate="yes" xml:space="preserve">
          <source>String and character literals</source>
          <target state="translated">Literales de cuerdas y caracteres</target>
        </trans-unit>
        <trans-unit id="8592962cea78137eedb95afe4474ceef0bee804c" translate="yes" xml:space="preserve">
          <source>String assignments are sometimes expensive in Nim: They are required to copy the whole string. However, the compiler is often smart enough to not copy strings. Due to the argument passing semantics, strings are never copied when passed to subroutines. The compiler does not copy strings that are a result from a procedure call, because the callee returns a new string anyway. Thus it is efficient to do:</source>
          <target state="translated">Las asignaciones de cuerdas son a veces costosas en Nim:Se requiere que copien toda la cuerda.Sin embargo,el compilador es a menudo lo suficientemente inteligente como para no copiar las cadenas.Debido al argumento de pasar la semántica,las cadenas nunca se copian cuando se pasan a las subrutinas.El compilador no copia cadenas que son resultado de una llamada a un procedimiento,porque el callee devuelve una nueva cadena de todos modos.Por lo tanto,es eficiente de hacer:</target>
        </trans-unit>
        <trans-unit id="f72b5d43e5245ea7b69b536ff3f8c988cbabcd7f" translate="yes" xml:space="preserve">
          <source>String handling</source>
          <target state="translated">El manejo de las cuerdas</target>
        </trans-unit>
        <trans-unit id="5993cb336c6391ee8eea94b873bb797a1c4d4619" translate="yes" xml:space="preserve">
          <source>String literals</source>
          <target state="translated">Literales de cuerda</target>
        </trans-unit>
        <trans-unit id="af12c2e063676108d00610ed5b2b199ea508a589" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes. The &lt;code&gt;var&lt;/code&gt; statement declares a new variable named &lt;code&gt;name&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; with the value that is returned by the &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; procedure. Since the compiler knows that &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; returns a string, you can leave out the type in the declaration (this is called &lt;span id=&quot;local-type-inference_1&quot;&gt;local type inference&lt;/span&gt;). So this will work too:</source>
          <target state="translated">Los literales de cadena se encierran entre comillas dobles. La instrucci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; declara una nueva variable denominada &lt;code&gt;name&lt;/code&gt; de tipo &lt;code&gt;string&lt;/code&gt; con el valor que devuelve el procedimiento &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; . Dado que el compilador sabe que &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; devuelve una cadena, puede omitir el tipo en la declaraci&amp;oacute;n (esto se denomina &lt;span id=&quot;local-type-inference_1&quot;&gt;inferencia de tipo local&lt;/span&gt; ). Entonces esto tambi&amp;eacute;n funcionar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="cbd76253c7810952b365eda2c20cec5a247a7e14" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes; character literals in single quotes. Special characters are escaped with &lt;code&gt;\&lt;/code&gt;: &lt;code&gt;\n&lt;/code&gt; means newline, &lt;code&gt;\t&lt;/code&gt; means tabulator, etc. There are also &lt;em&gt;raw&lt;/em&gt; string literals:</source>
          <target state="translated">Los literales de cadena se incluyen entre comillas dobles; literales de caracteres entre comillas simples. Los caracteres especiales se escaparon con &lt;code&gt;\&lt;/code&gt; : &lt;code&gt;\n&lt;/code&gt; medio de nueva l&amp;iacute;nea, &lt;code&gt;\t&lt;/code&gt; medios tabulador, etc. Tambi&amp;eacute;n hay &lt;em&gt;primas&lt;/em&gt; literales de cadena:</target>
        </trans-unit>
        <trans-unit id="91beede65eb4bf81fa0a0b03f71ed1840d87fbad" translate="yes" xml:space="preserve">
          <source>String literals can also be delimited by three double quotes &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;. Literals in this form may run for several lines, may contain &lt;code&gt;&quot;&lt;/code&gt; and do not interpret any escape sequences. For convenience, when the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is followed by a newline (there may be whitespace between the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt;, so this:</source>
          <target state="translated">Los literales de cadena tambi&amp;eacute;n se pueden delimitar con tres comillas dobles &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; . Los literales de este formulario pueden tener varias l&amp;iacute;neas, pueden contener &lt;code&gt;&quot;&lt;/code&gt; y no interpretar ninguna secuencia de escape. Por conveniencia, cuando la apertura &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; va seguida de una nueva l&amp;iacute;nea (puede haber espacios en blanco entre la apertura &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; y la nueva l&amp;iacute;nea) , la nueva l&amp;iacute;nea (y el espacio en blanco anterior) no se incluye en la cadena. El final del literal de cadena se define mediante el patr&amp;oacute;n &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt; , por lo que esto:</target>
        </trans-unit>
        <trans-unit id="a98bf22b08be1e87b2f87e1e68dc04c240c4f84a" translate="yes" xml:space="preserve">
          <source>String literals can be delimited by matching double quotes, and can contain the following &lt;span id=&quot;escape-sequences_1&quot;&gt;escape sequences&lt;/span&gt;:</source>
          <target state="translated">Los literales de cadena se pueden delimitar haciendo coincidir comillas dobles y pueden contener las siguientes &lt;span id=&quot;escape-sequences_1&quot;&gt;secuencias de escape&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="add4920af30df00399258f443c32b23c074019f6" translate="yes" xml:space="preserve">
          <source>String match ignoring case for back reference.</source>
          <target state="translated">La coincidencia de las cuerdas ignora el caso para la referencia trasera.</target>
        </trans-unit>
        <trans-unit id="2a6aa06ff131f3961de8e3d1902b39032ccdc0a1" translate="yes" xml:space="preserve">
          <source>String match ignoring case.</source>
          <target state="translated">El partido de cuerdas ignora el caso.</target>
        </trans-unit>
        <trans-unit id="147076ac16a166598cdc8c313b99f065ab615a6a" translate="yes" xml:space="preserve">
          <source>String match ignoring style for back reference.</source>
          <target state="translated">El juego de cuerdas ignorando el estilo para la referencia trasera.</target>
        </trans-unit>
        <trans-unit id="bb24a4c20f47d52b01a258419055f6b3dfdee121" translate="yes" xml:space="preserve">
          <source>String match ignoring style.</source>
          <target state="translated">El partido de cuerdas ignorando el estilo.</target>
        </trans-unit>
        <trans-unit id="02ac6c5d15d3833eb25c8fee2851790ab39dbbb4" translate="yes" xml:space="preserve">
          <source>String type</source>
          <target state="translated">Tipo de cuerda</target>
        </trans-unit>
        <trans-unit id="986c54b2d8959694bd3a8d1059f1a28ae674bd61" translate="yes" xml:space="preserve">
          <source>String variables are &lt;strong&gt;mutable&lt;/strong&gt;, so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string's length can be retrieved with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a &lt;code&gt;cstring&lt;/code&gt; without doing a copy.</source>
          <target state="translated">Las variables de cadena son &lt;strong&gt;mutables&lt;/strong&gt; , por lo que agregar una cadena es posible y bastante eficiente. Las cadenas en Nim terminan en cero y tienen un campo de longitud. La longitud de un string puede ser recuperada con la orden interna &lt;code&gt;len&lt;/code&gt; procedimiento; la longitud nunca cuenta el cero final. Acceder al cero de terminaci&amp;oacute;n es un error, solo existe para que una cadena Nim se pueda convertir en una &lt;code&gt;cstring&lt;/code&gt; sin hacer una copia.</target>
        </trans-unit>
        <trans-unit id="9582510d33852bda61d01257c5b36aff25c4246c" translate="yes" xml:space="preserve">
          <source>String: If the text ahead is the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Cadena: si el texto anterior es la cadena &lt;em&gt;s&lt;/em&gt; , cons&amp;uacute;malo e indica &amp;eacute;xito. De lo contrario, indique falla.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="3fef5979e2a970ce485675c739e2e35d04689a53" translate="yes" xml:space="preserve">
          <source>Strings and C strings</source>
          <target state="translated">Cuerdas y cuerdas de Do</target>
        </trans-unit>
        <trans-unit id="1b710e9083a424ca250da057248ace9578ab56d8" translate="yes" xml:space="preserve">
          <source>Strings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0). Unlike arrays, they can be used in case statements:</source>
          <target state="translated">Las cuerdas se comparan por su orden lexicográfico.Todos los operadores de comparación están disponibles.Las cadenas pueden ser indexadas como matrices (el límite inferior es 0).A diferencia de las matrices,pueden ser usadas en declaraciones de casos:</target>
        </trans-unit>
        <trans-unit id="09c9bb4c72fe3ad8b1a94e6b29d07b028ab504ba" translate="yes" xml:space="preserve">
          <source>Strings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;.</source>
          <target state="translated">Las cadenas se comparan utilizando su orden lexicogr&amp;aacute;fico. Todos los operadores de comparaci&amp;oacute;n son compatibles. Por convenci&amp;oacute;n, todas las cadenas est&amp;aacute;n codificadas en UTF-8, pero esto no se aplica. Por ejemplo, al leer cadenas de archivos binarios, son simplemente una secuencia de bytes. La operaci&amp;oacute;n de &amp;iacute;ndice &lt;code&gt;s[i]&lt;/code&gt; significa el i-&amp;eacute;simo &lt;em&gt;car&amp;aacute;cter&lt;/em&gt; de &lt;code&gt;s&lt;/code&gt; , no el i-&amp;eacute;simo &lt;em&gt;unichar&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="68f5a8dcb38cb2dcf8c5a38294f5911b71dc18ba" translate="yes" xml:space="preserve">
          <source>Strings in Nim may contain any 8-bit value, even embedded zeros. However some operations may interpret the first binary zero as a terminator.</source>
          <target state="translated">Las cuerdas en Nim pueden contener cualquier valor de 8 bits,incluso ceros incrustados.Sin embargo,algunas operaciones pueden interpretar el primer cero binario como un terminador.</target>
        </trans-unit>
        <trans-unit id="5b34aa10a7504c11b1c238076600885e8cb63777" translate="yes" xml:space="preserve">
          <source>Strip filter</source>
          <target state="translated">Filtro de tira</target>
        </trans-unit>
        <trans-unit id="98e0d86ad6cb0129df0228988af89dce21ec584d" translate="yes" xml:space="preserve">
          <source>Strips leading or trailing &lt;em&gt;chars&lt;/em&gt; from &lt;em&gt;s&lt;/em&gt; and returns the resulting string.</source>
          <target state="translated">Elimina los &lt;em&gt;caracteres&lt;/em&gt; iniciales o finales de &lt;em&gt;sy&lt;/em&gt; devuelve la cadena resultante.</target>
        </trans-unit>
        <trans-unit id="c8ff4b4dfac3e5ecfb01fa66e040f2be24062608" translate="yes" xml:space="preserve">
          <source>Structured types</source>
          <target state="translated">Tipos estructurados</target>
        </trans-unit>
        <trans-unit id="6617ba0382b36cb88686c64241a0d1066459e84e" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison.</source>
          <target state="translated">Comparación insensible al estilo.</target>
        </trans-unit>
        <trans-unit id="47c3fbfee5ccaddc82435585c637b37f1eed421b" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">Comparaci&amp;oacute;n insensible al estilo. &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; pueden ser un identificador o un s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="327f538ea37da49ccf2c271b65129745ac5559a5" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">Comparaci&amp;oacute;n insensible al estilo. &lt;code&gt;a&lt;/code&gt; puede ser un identificador o un s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="a24820daa51bd1dce30c8565c1d952ac958b1e4f" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">Comparaci&amp;oacute;n insensible al estilo. &lt;code&gt;b&lt;/code&gt; puede ser un identificador o un s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="af3750102e983bbf33f619b8dae0de2a0f4b3c0c" translate="yes" xml:space="preserve">
          <source>Subrange of &lt;code&gt;TimeUnit&lt;/code&gt; that only includes units of fixed duration. These are the units that can be represented by a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Subrango de &lt;code&gt;TimeUnit&lt;/code&gt; que solo incluye unidades de duraci&amp;oacute;n fija. Estas son las unidades que se pueden representar mediante una &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3435d7cc8ec39979e476fdb02a131d9a1f16a5a" translate="yes" xml:space="preserve">
          <source>Subrange or subtype match: &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;range[T]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; matches &lt;code&gt;f&lt;/code&gt; exactly. Or: &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Coincidencia de subrango o subtipo: &lt;code&gt;a&lt;/code&gt; es un &lt;code&gt;range[T]&lt;/code&gt; y &lt;code&gt;T&lt;/code&gt; coincide con &lt;code&gt;f&lt;/code&gt; exactamente. O: &lt;code&gt;a&lt;/code&gt; es un subtipo de &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee14d0889156d81963bda220fbb8514a525f717" translate="yes" xml:space="preserve">
          <source>Subrange types</source>
          <target state="translated">Tipos de subrangos</target>
        </trans-unit>
        <trans-unit id="041d20cfb351df25518b1fc63a1180aa4794aa06" translate="yes" xml:space="preserve">
          <source>Subranges</source>
          <target state="translated">Subranges</target>
        </trans-unit>
        <trans-unit id="b5f3755a0b5ea501c2ceef9602ab2b833039d687" translate="yes" xml:space="preserve">
          <source>Substitution Expressions (subex)</source>
          <target state="translated">Expresiones de sustitución (subex)</target>
        </trans-unit>
        <trans-unit id="10ae1fbab8828c5f045753afbdada38d4797d019" translate="yes" xml:space="preserve">
          <source>Substitution variables can also be words (that is &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt;) in which case the arguments in &lt;em&gt;a&lt;/em&gt; with even indices are keys and with odd indices are the corresponding values. An example:</source>
          <target state="translated">Las variables de sustituci&amp;oacute;n tambi&amp;eacute;n pueden ser palabras (es decir, &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt; ) en cuyo caso los argumentos en &lt;em&gt;a&lt;/em&gt; con &amp;iacute;ndices pares son claves y con &amp;iacute;ndices impares son los valores correspondientes. Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="834dbbb6edc63f93dd355df612f58e6f6c9305b3" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;.</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas por una subcadena que solo contiene &lt;em&gt;seps&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2ec85e175386f10e5a8dc9ec3874b1df9dc2ae" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;. Examples:</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas por una subcadena que solo contiene &lt;em&gt;seps&lt;/em&gt; . Ejemplos:</target>
        </trans-unit>
        <trans-unit id="9b3a380e1c6cb3aaa0328c36e53f0fcd3dd31ec2" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the PEG &lt;em&gt;sep&lt;/em&gt;. Examples:</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas por el PEG &lt;em&gt;sep&lt;/em&gt; . Ejemplos:</target>
        </trans-unit>
        <trans-unit id="e91de9d53e26c3248ed96f64d99b705efaf9da39" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the character &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas por el car&amp;aacute;cter &lt;em&gt;sep&lt;/em&gt; . El c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="5bff515ff93456666b03df7f012092cf65f567c4" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the regular expression &lt;code&gt;sep&lt;/code&gt; (and the portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned).</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas por la expresi&amp;oacute;n regular &lt;code&gt;sep&lt;/code&gt; (y la parte que coincide con &lt;code&gt;sep&lt;/code&gt; no se devuelve).</target>
        </trans-unit>
        <trans-unit id="e8588d2a952b8b1b868045a8e60e1b1612fbdf6e" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas por la cadena &lt;em&gt;sep&lt;/em&gt; . El c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="969d144035ae8c1097f28295048d2e10839468b5" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. This is a wrapper around the &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt;.</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas por la cadena &lt;em&gt;sep&lt;/em&gt; . Esta es una envoltura alrededor del &lt;a href=&quot;#split.i,string,string,int&quot;&gt;iterador dividido&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="518967ba497c08dc430a7afa2799aa4c61e41859" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the char &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas de la derecha por el char &lt;em&gt;sep&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2cd528c9f9109219b97fe511dbbed0b9acbd1118" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the set of chars &lt;em&gt;seps&lt;/em&gt;</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas de la derecha por el conjunto de caracteres &lt;em&gt;seps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e2f8adf7c1cab6995d76bf2a7d0ca46134fd40b" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the string &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">Las subcadenas est&amp;aacute;n separadas de la derecha por la cadena &lt;em&gt;sep&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f96fd7e06b2e3440bae01cbcfe7490ed94381668" translate="yes" xml:space="preserve">
          <source>Subtract &lt;code&gt;interval&lt;/code&gt; from &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are subtracted in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">Reste el &lt;code&gt;interval&lt;/code&gt; o de &lt;code&gt;dt&lt;/code&gt; . Los componentes del &lt;code&gt;interval&lt;/code&gt; o se restan en el orden de su tama&amp;ntilde;o, es decir, primero el componente de &lt;code&gt;years&lt;/code&gt; , luego el componente de &lt;code&gt;months&lt;/code&gt; y as&amp;iacute; sucesivamente. El &lt;code&gt;DateTime&lt;/code&gt; devuelto tendr&amp;aacute; la misma zona horaria que la entrada.</target>
        </trans-unit>
        <trans-unit id="76bc475fe96d51312be250027df1a17a17035b2c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Reste &lt;em&gt;y&lt;/em&gt; de &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b1dcda865799d69866263f2964a5c388fd816f8c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Reste &lt;em&gt;y&lt;/em&gt; del n&amp;uacute;mero complejo &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4f3fc03c45197f8110a3f544c2fd44b496e0b4" translate="yes" xml:space="preserve">
          <source>Subtract a duration from another.</source>
          <target state="translated">Restar una duración de otra.</target>
        </trans-unit>
        <trans-unit id="0a0ad440585f43f54b766a259c1467e330bf63c8" translate="yes" xml:space="preserve">
          <source>Subtract int &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Reste int &lt;em&gt;y&lt;/em&gt; de &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="5428a30fe88840d786a7f61b7d233914d258e100" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from int &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Reste &lt;em&gt;y&lt;/em&gt; racional de int &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="41acafc64eeedf3eca00c862873071d48f536cc2" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Reste &lt;em&gt;y&lt;/em&gt; racional de &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="7bef7ee0413bb39584843be44a786acae479c9b7" translate="yes" xml:space="preserve">
          <source>Subtract two complex numbers.</source>
          <target state="translated">Reste dos números complejos.</target>
        </trans-unit>
        <trans-unit id="7189d91ec5033b9efd0a25062c31f9a16c88f644" translate="yes" xml:space="preserve">
          <source>Subtract two rational numbers.</source>
          <target state="translated">Reste dos números racionales.</target>
        </trans-unit>
        <trans-unit id="000947a7b3b6b45852df6f5a592408f7e55c3bb3" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;em&gt;interval&lt;/em&gt; from Time &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">Resta el &lt;em&gt;intervalo&lt;/em&gt; del &lt;em&gt;tiempo&lt;/em&gt; . Si el &lt;em&gt;intervalo&lt;/em&gt; contiene a&amp;ntilde;os, meses, semanas o d&amp;iacute;as, la operaci&amp;oacute;n se realiza en la zona horaria local.</target>
        </trans-unit>
        <trans-unit id="333dcd5ddf8f4d8066eab6ce4acb5ae7c09ae03c" translate="yes" xml:space="preserve">
          <source>Subtracts TimeInterval &lt;code&gt;ti1&lt;/code&gt; from &lt;code&gt;ti2&lt;/code&gt;.</source>
          <target state="translated">Resta TimeInterval &lt;code&gt;ti1&lt;/code&gt; de &lt;code&gt;ti2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6179323b99f6b40288e7176393e0e598ec9f2ba" translate="yes" xml:space="preserve">
          <source>Subtracts a duration of time from a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Resta una duraci&amp;oacute;n de tiempo de un &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dcbc2b9a13a2d866e0df3c601f071ff376561ec" translate="yes" xml:space="preserve">
          <source>Subtracts complex &lt;em&gt;y&lt;/em&gt; from float &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Resta el complejo &lt;em&gt;y&lt;/em&gt; del flotante &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4c88d3850624fa5509b42b7c6454e560083b18e5" translate="yes" xml:space="preserve">
          <source>Subtracts float &lt;em&gt;y&lt;/em&gt; from complex &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Resta float &lt;em&gt;y&lt;/em&gt; del complejo &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f70590b4a99f5ea41cbbb277fc8ae20c97c2f508" translate="yes" xml:space="preserve">
          <source>Subtype relation</source>
          <target state="translated">Relación de subtipo</target>
        </trans-unit>
        <trans-unit id="0dfbf551cd1febe9be3271e47b0ace6915b7e99f" translate="yes" xml:space="preserve">
          <source>Success, SuccessX</source>
          <target state="translated">Success,SuccessX</target>
        </trans-unit>
        <trans-unit id="d9aa2dd47e2183e4004b0890583ddab7b0dd3b84" translate="yes" xml:space="preserve">
          <source>Successful compilation of a library or a binary.</source>
          <target state="translated">La compilación exitosa de una biblioteca o un binario.</target>
        </trans-unit>
        <trans-unit id="885db975a310a3bb649f91e5771f94988987874d" translate="yes" xml:space="preserve">
          <source>Suffix</source>
          <target state="translated">Suffix</target>
        </trans-unit>
        <trans-unit id="8e3e076ed673ec7f1a40d1724dfcc98398c4fee1" translate="yes" xml:space="preserve">
          <source>Sugar for contains</source>
          <target state="translated">El azúcar para contiene</target>
        </trans-unit>
        <trans-unit id="2b0f1741006e1749638aebbba0c62519275602e6" translate="yes" xml:space="preserve">
          <source>Sugar for not containing</source>
          <target state="translated">Azúcar para no contener</target>
        </trans-unit>
        <trans-unit id="861edba00547bc9ce7a08df78d4378766418179f" translate="yes" xml:space="preserve">
          <source>Suggestions</source>
          <target state="translated">Suggestions</target>
        </trans-unit>
        <trans-unit id="941d7d9ac0746aafb3a7018083b0465f921dce61" translate="yes" xml:space="preserve">
          <source>Supported OS primitives: &lt;code&gt;epoll&lt;/code&gt;, &lt;code&gt;kqueue&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt; and Windows &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">Primitivas de SO compatibles: &lt;code&gt;epoll&lt;/code&gt; , &lt;code&gt;kqueue&lt;/code&gt; , &lt;code&gt;poll&lt;/code&gt; y Windows &lt;code&gt;select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5f3ef8bd9a226a902e3da626f593d8f6bdd720e" translate="yes" xml:space="preserve">
          <source>Supported PEG grammar</source>
          <target state="translated">Gramática PEG soportada</target>
        </trans-unit>
        <trans-unit id="9d80112951ed980c75468e1be3b86df0f222e090" translate="yes" xml:space="preserve">
          <source>Supported features: files, sockets, pipes, timers, processes, signals and user events.</source>
          <target state="translated">Características soportadas:archivos,enchufes,tuberías,temporizadores,procesos,señales y eventos de usuario.</target>
        </trans-unit>
        <trans-unit id="922e354db556982aaec9d3960cdeb221956777ff" translate="yes" xml:space="preserve">
          <source>Supported syntax with default empty &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt;:</source>
          <target state="translated">Sintaxis admitida con &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; vac&amp;iacute;o predeterminado :</target>
        </trans-unit>
        <trans-unit id="52fecfba1182fabfdebf61ef0bd285c76b11a6aa" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the current async procedure for the next &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">Suspende la ejecuci&amp;oacute;n del procedimiento as&amp;iacute;ncrono de corriente para los pr&amp;oacute;ximos &lt;code&gt;ms&lt;/code&gt; milisegundos.</target>
        </trans-unit>
        <trans-unit id="d5c77fcc8428eb1c29fb0edea391c5fde177f006" translate="yes" xml:space="preserve">
          <source>Suspends the process &lt;em&gt;p&lt;/em&gt;.</source>
          <target state="translated">Suspende el proceso &lt;em&gt;p&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ff172170c09b0a3f643ea6f3860725b0e3adcde6" translate="yes" xml:space="preserve">
          <source>Swaps the case of unicode characters in &lt;em&gt;s&lt;/em&gt;</source>
          <target state="translated">Intercambia el caso de caracteres Unicode en &lt;em&gt;s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55b596882450b0f897f71f7b842053dfc1583f85" translate="yes" xml:space="preserve">
          <source>Swaps the positions of elements in a sequence randomly.</source>
          <target state="translated">Intercambia las posiciones de los elementos en una secuencia aleatoria.</target>
        </trans-unit>
        <trans-unit id="0ccabcb7feef7d8bfe041ead9426ae3125086c8c" translate="yes" xml:space="preserve">
          <source>Symbol binding in templates</source>
          <target state="translated">La vinculación de los símbolos en las plantillas</target>
        </trans-unit>
        <trans-unit id="e15d9719893fff31a651b51709f3f17053857c18" translate="yes" xml:space="preserve">
          <source>Symbol lookup in generics</source>
          <target state="translated">Búsqueda de símbolos en los genéricos</target>
        </trans-unit>
        <trans-unit id="93722351d20a0af3b4b9e37b38817089ab39c090" translate="yes" xml:space="preserve">
          <source>Symbol lookup of the identifiers &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; is performed after the rewriting step, so that all overloads of &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; are taken into account.</source>
          <target state="translated">La b&amp;uacute;squeda de s&amp;iacute;mbolos de los &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; identificadores se realiza despu&amp;eacute;s del paso de reescritura, de modo que se tienen en cuenta todas las sobrecargas de &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84e33e2c80c65f15d6048f2ca6f92d94cfd3e6de" translate="yes" xml:space="preserve">
          <source>Symbol usages</source>
          <target state="translated">Usos de los símbolos</target>
        </trans-unit>
        <trans-unit id="15d2715339927ab1cacbd3a795da09326886df84" translate="yes" xml:space="preserve">
          <source>Symbolic link.</source>
          <target state="translated">Enlace simbólico.</target>
        </trans-unit>
        <trans-unit id="11ad0ab4dc32899beb01665dac0504b053480af8" translate="yes" xml:space="preserve">
          <source>Symbols declared in an &lt;em&gt;enter&lt;/em&gt; handler can be made visible in the corresponding &lt;em&gt;leave&lt;/em&gt; handler by annotating them with an &lt;em&gt;inject&lt;/em&gt; pragma.</source>
          <target state="translated">Los s&amp;iacute;mbolos declarados en un controlador de &lt;em&gt;entrada&lt;/em&gt; se pueden hacer visibles en el controlador de &lt;em&gt;licencia&lt;/em&gt; correspondiente anot&amp;aacute;ndolos con un pragma de &lt;em&gt;inyecci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a4b7119bc873b1a47de2955098054673778589df" translate="yes" xml:space="preserve">
          <source>Synonym for existsDir</source>
          <target state="translated">Sinónimo de existeDir</target>
        </trans-unit>
        <trans-unit id="ba60d4cc263ff180c27a4a09e6b636cd98ac4e3b" translate="yes" xml:space="preserve">
          <source>Synonym for existsFile</source>
          <target state="translated">Sinónimo de existeArchivo</target>
        </trans-unit>
        <trans-unit id="e8aa2bdcd24d6964731df6f38e8110132abbce66" translate="yes" xml:space="preserve">
          <source>Syntactically a &lt;em&gt;type conversion&lt;/em&gt; is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).</source>
          <target state="translated">Sint&amp;aacute;cticamente, una &lt;em&gt;conversi&amp;oacute;n de tipo&lt;/em&gt; es como una llamada a procedimiento, pero un nombre de tipo reemplaza el nombre de procedimiento. Una conversi&amp;oacute;n de tipo siempre es segura en el sentido de que si no se convierte un tipo en otro, se genera una excepci&amp;oacute;n (si no se puede determinar est&amp;aacute;ticamente).</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="9c59412440fcb6dd3270f66f446a4acc85d89be4" translate="yes" xml:space="preserve">
          <source>Syntax sugar for anonymous procedures.</source>
          <target state="translated">Azúcar de sintaxis para procedimientos anónimos.</target>
        </trans-unit>
        <trans-unit id="a492d9c66fdcf105c885da59425dccb0b62e918e" translate="yes" xml:space="preserve">
          <source>Syntax sugar for procedure types.</source>
          <target state="translated">Azúcar de sintaxis para los tipos de procedimiento.</target>
        </trans-unit>
        <trans-unit id="2e2159d4e1bf250922bd0a832c5179a9837c51e5" translate="yes" xml:space="preserve">
          <source>T = enum</source>
          <target state="translated">T=enum</target>
        </trans-unit>
        <trans-unit id="4434fd593bde3375839bc932883b120b979c7044" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">ESTE SOFTWARE ES PROPORCIONADO POR LOS TITULARES DE LOS DERECHOS DE AUTOR Y LOS COLABORADORES &quot;TAL CUAL&quot; Y SE RENUNCIA A CUALQUIER GARANTÍA EXPRESA O IMPLÍCITA,INCLUIDAS,ENTRE OTRAS,LAS GARANTÍAS IMPLÍCITAS DE COMERCIABILIDAD E IDONEIDAD PARA UN FIN DETERMINADO.EN NINGÚN CASO EL PROPIETARIO DE LOS DERECHOS DE AUTOR O LOS COLABORADORES SERÁN RESPONSABLES DE NINGÚN DAÑO DIRECTO,INDIRECTO,INCIDENTAL,ESPECIAL,EJEMPLAR O CONSECUENTE (INCLUYENDO,PERO SIN LIMITARSE A,LA ADQUISICIÓN DE BIENES O SERVICIOS SUSTITUTOS;LA PÉRDIDA DE USO,DATOS O BENEFICIOS;O LA INTERRUPCIÓN DE LA ACTIVIDAD COMERCIAL),INDEPENDIENTEMENTE DE LA CAUSA Y DE CUALQUIER TEORÍA DE RESPONSABILIDAD,YA SEA CONTRACTUAL,RESPONSABILIDAD ESTRICTA O EXTRACONTRACTUAL (INCLUYENDO LA NEGLIGENCIA O DE OTRO TIPO)QUE SURJA DE CUALQUIER MANERA DEL USO DE ESTE SOFTWARE,INCLUSO SI SE HA ADVERTIDO DE LA POSIBILIDAD DE TALES DAÑOS.</target>
        </trans-unit>
        <trans-unit id="7cbcc89bc56ee06c7485bd88edf78b958d325e03" translate="yes" xml:space="preserve">
          <source>TODO: &lt;code&gt;/dev/poll&lt;/code&gt;, &lt;code&gt;event ports&lt;/code&gt; and filesystem events.</source>
          <target state="translated">TODO: &lt;code&gt;/dev/poll&lt;/code&gt; , &lt;code&gt;event ports&lt;/code&gt; y eventos del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated">Constructor de mesas</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated">Seguimiento de la etiqueta</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">El modo de contaminación...</target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated">Tenga especial cuidado al declarar tipos como &lt;code&gt;proc&lt;/code&gt; . El comportamiento es similar a la &lt;code&gt;Procedure declaration&lt;/code&gt; , a continuaci&amp;oacute;n, pero no trata &lt;code&gt;nnkGenericParams&lt;/code&gt; . Los par&amp;aacute;metros gen&amp;eacute;ricos se tratan en el tipo, no en el &lt;code&gt;proc&lt;/code&gt; eso en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">Toma un &lt;code&gt;typedesc&lt;/code&gt; como su primer argumento y una serie de expresiones de tipo &lt;code&gt;key: value&lt;/code&gt; , y devuelve un valor del tipo especificado con cada &lt;code&gt;key&lt;/code&gt; campo establecida en &lt;code&gt;value&lt;/code&gt; , como se especifica en los argumentos de &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">Toma un flotador que contiene el número de segundos desde la época de los unix y devuelve un objeto de tiempo.</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">Toma un int que contiene el número de segundos desde la época de los unix y devuelve un objeto de tiempo.</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">Toma un número entero y produce tantos &quot;¡hola mundo!&quot; como sea posible.</target>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">Toma los elementos de varias secuencias y los devuelve dentro de una nueva secuencia.</target>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">Toma el nombre de un procedimiento y lo envuelve en una lambda sin el primer argumento, la cual pasa el JavaScript incorporado &lt;code&gt;this&lt;/code&gt; como el primer argumento del procedimiento. Devuelve la lambda resultante.</target>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated">Declaración de la plantilla</target>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">Plantilla para doblar una secuencia de izquierda a derecha,devolviendo la acumulación.</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">Plantilla para doblar una secuencia de derecha a izquierda,devolviendo la acumulación.</target>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">Plantilla que se expande a stdout o stderr dependiendo del &lt;em&gt;conmutador&lt;/em&gt; de tiempo de compilaci&amp;oacute;n &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">Las plantillas (as&amp;iacute; como las macros, como veremos) tienen un AST ligeramente expandido en comparaci&amp;oacute;n con los procesos y los iteradores. La raz&amp;oacute;n de esto es [macros de reescritura de t&amp;eacute;rminos] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt; . &amp;iquest;Observa &lt;code&gt;nnkEmpty()&lt;/code&gt; como el segundo argumento para &lt;code&gt;nnkProcDef&lt;/code&gt; y &lt;code&gt;nnkIteratorDef&lt;/code&gt; arriba? Ah&amp;iacute; es donde van las macros de reescritura de t&amp;eacute;rminos.</target>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated">Las plantillas son un simple mecanismo de sustitución que opera en los árboles de sintaxis abstracta de Nim.Las plantillas son procesadas en el pase semántico del compilador.Se integran bien con el resto del lenguaje y no comparten ninguna de las fallas de las macros del preprocesador de C.</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">Las plantillas son especialmente útiles para fines de evaluación perezosa.Considere un procedimiento sencillo para el registro:</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">Almacenamiento temporal para &lt;code&gt;readLine&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">Macros de reescritura de términos</target>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">Las macros de reescritura de t&amp;eacute;rminos son macros o plantillas que no solo tienen un &lt;em&gt;nombre&lt;/em&gt; sino tambi&amp;eacute;n un &lt;em&gt;patr&amp;oacute;n&lt;/em&gt; que se busca despu&amp;eacute;s de la fase de verificaci&amp;oacute;n sem&amp;aacute;ntica del compilador: esto significa que proporcionan una manera f&amp;aacute;cil de mejorar la canalizaci&amp;oacute;n de compilaci&amp;oacute;n con optimizaciones definidas por el usuario:</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated">Símbolo de la terminal</target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">S&amp;iacute;mbolo terminal en la gram&amp;aacute;tica: &lt;code&gt;RSTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">S&amp;iacute;mbolo terminal en la gram&amp;aacute;tica: &lt;code&gt;STR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">S&amp;iacute;mbolo terminal en la gram&amp;aacute;tica: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">S&amp;iacute;mbolos terminales en la gram&amp;aacute;tica: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; , &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated">Termina la instancia del servidor http async.</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">Termina la conexión con el servidor.</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">Formato de archivo del caso de prueba</target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">Prueba para un archivo especial de bloque.</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">Prueba para un archivo especial de caracteres.</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated">Prueba para un directorio.</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">Prueba para una cola de mensajes.</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">Prueba para una tubería o un archivo especial FIFO.</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">Prueba para un archivo regular.</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated">Prueba para un semáforo.</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">Prueba para un objeto de memoria compartida.</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated">Prueba para un enchufe.</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">Prueba de un vínculo simbólico.</target>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">Pruebe si el &lt;em&gt;cuerpo&lt;/em&gt; genera una excepci&amp;oacute;n encontrada en las &lt;em&gt;excepciones&lt;/em&gt; pasadas . La prueba pasa si la excepci&amp;oacute;n planteada es parte de las excepciones aceptables. De lo contrario, falla. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">Macro de prueba para un objeto de memoria tecleado.</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">Conjunto de pruebas...</target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">Probado en estos sistemas operativos:Linux,Windows,OSX</target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">Las pruebas pueden ser anidadas,sin embargo el fracaso de una prueba anidada no marcará la prueba madre como fallida.La instalación y el desmontaje son hereditarios.La configuración se puede anular localmente.</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">Se ejecutan las pruebas que coinciden con &lt;strong&gt;cualquiera&lt;/strong&gt; de los argumentos.</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">Comprueba si la implementación del DOM implementa una característica específica y esa característica es soportada por este nodo.</target>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Las pruebas con GCC en Amd64 mostraron que es realmente beneficioso si el puntero &quot;ambiente&quot; se pasa como el último argumento,no como el primer argumento.</target>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">Gracias a su construcci&amp;oacute;n condicional &lt;code&gt;$[0|1|2|else]&lt;/code&gt; soporta bastante bien la &lt;span id=&quot;internationalization_1&quot;&gt;internacionalizaci&amp;oacute;n&lt;/span&gt; de los literales de cadenas de formato.</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">Eso significa que sólo las primeras letras se comparan de manera sensible a las mayúsculas y minúsculas.Las demás letras se comparan sin distinguir entre mayúsculas y minúsculas dentro del rango ASCII y se ignoran los subrayados.</target>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">Eso significa convertirlo en minúsculas y eliminar cualquier '_'.Esto NO debe ser usado para normalizar los nombres de los identificadores Nim.</target>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">La anotación &quot;``` también puede usarse para llamar a un operador como cualquier otro procedimiento:</target>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">El programa &quot;hello world&quot; contiene varios identificadores que ya son conocidos por el compilador: &lt;code&gt;echo&lt;/code&gt; , &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; , etc. Estos incorporados se declaran en el m&amp;oacute;dulo del &lt;a href=&quot;system&quot;&gt;sistema&lt;/a&gt; que es impl&amp;iacute;citamente importado por cualquier otro m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">Los &quot;tipos&quot; de plantillas pueden ser los s&amp;iacute;mbolos &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; o &lt;code&gt;type&lt;/code&gt; . Estos son &quot;metatipos&quot;, solo se pueden usar en ciertos contextos. Tambi&amp;eacute;n se pueden utilizar tipos regulares; esto implica que se esperan expresiones &lt;code&gt;typed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">La &quot;precisión&quot; es un número decimal que indica cuántos dígitos deben mostrarse después del punto decimal en una conversión de punto flotante.En el caso de los tipos no numéricos,el campo indica el tamaño máximo del campo,es decir,cuántos caracteres se utilizarán del contenido del campo.La precisión se ignora en las conversiones de números enteros.</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">La declaración de &quot;retorno&quot; debería usarse idealmente cuando se requieran sus propiedades de flujo de control.Utilice la variable implícita &quot;resultado&quot; de un procedimiento siempre que sea posible.Esto mejora la legibilidad.</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">La opción &quot;signo&quot; sólo es válida para los tipos numéricos,y puede ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">El valor (entero)del radix utilizado para representar cualquier tipo de punto flotante en la arquitectura utilizada para construir el programa.</target>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">La &lt;a href=&quot;#nimble&quot;&gt;parte inferior&lt;/a&gt; de esta p&amp;aacute;gina incluye una lista de paquetes de terceros creados por la comunidad de Nim. Estos paquetes son una adici&amp;oacute;n &amp;uacute;til a los m&amp;oacute;dulos de la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">La &lt;a href=&quot;nimc&quot;&gt;Gu&amp;iacute;a del usuario del compilador de Nim&lt;/a&gt; documenta la invocaci&amp;oacute;n t&amp;iacute;pica del compilador, utilizando el comando &lt;code&gt;compile&lt;/code&gt; o &lt;code&gt;c&lt;/code&gt; para transformar un archivo &lt;code&gt;.nim&lt;/code&gt; en uno o m&amp;aacute;s archivos &lt;code&gt;.c&lt;/code&gt; que luego se compilan con el compilador C de la plataforma en un binario est&amp;aacute;tico. Sin embargo, existen otros comandos para compilar en C ++, Objective-C o JavaScript. Este documento intenta concentrar en un solo lugar todas las opciones de backend y de interfaz.</target>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">El &lt;a href=&quot;nimc#dynliboverride&quot;&gt;conmutador de&lt;/a&gt; l&amp;iacute;nea de comando dynlibOverride permite evitar el enlace din&amp;aacute;mico si necesita enlazar est&amp;aacute;ticamente algo. Los contenedores de Nim dise&amp;ntilde;ados para vincular est&amp;aacute;ticamente archivos fuente pueden usar el &lt;a href=&quot;nimc#compile-pragma&quot;&gt;pragma de compilaci&amp;oacute;n&lt;/a&gt; si hay pocas fuentes o proporcionarlas junto con el c&amp;oacute;digo Nim es m&amp;aacute;s f&amp;aacute;cil que usar una biblioteca del sistema. Las bibliotecas instaladas en el sistema host se pueden vincular con el &lt;a href=&quot;nimc#passl-pragma&quot;&gt;pragma PassL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">Las operaciones &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt; , &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt; , &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; y &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; pueden fallar al generar una excepci&amp;oacute;n &lt;em&gt;EOutOfRange&lt;/em&gt; o &lt;em&gt;EOverflow&lt;/em&gt; . (Si el c&amp;oacute;digo se ha compilado con las comprobaciones de tiempo de ejecuci&amp;oacute;n adecuadas activadas).</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">El &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; operadores est&amp;aacute;n en las plantillas de datos:</target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated">El &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; operadores est&amp;aacute;n en las plantillas Realidad: Esto tiene la ventaja de que si se sobrecarga el &lt;code&gt;==&lt;/code&gt; operador, el &lt;code&gt;!=&lt;/code&gt; Operador est&amp;aacute; disponible de forma autom&amp;aacute;tica y hace lo correcto. (A excepci&amp;oacute;n de los n&amp;uacute;meros de punto flotante IEEE, NaN rompe la l&amp;oacute;gica booleana b&amp;aacute;sica).</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">Las &lt;code&gt;#header&lt;/code&gt; y &lt;code&gt;#dynlib&lt;/code&gt; son mutuamente excluyentes. &amp;iexcl;Un enlace que usa &lt;code&gt;dynlib&lt;/code&gt; es mucho m&amp;aacute;s preferible que uno que usa &lt;code&gt;header&lt;/code&gt; ! El compilador de Nim podr&amp;iacute;a dejar de admitir el pragma de &lt;code&gt;header&lt;/code&gt; en el futuro, ya que no puede funcionar para backends que no generan c&amp;oacute;digo C.</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">La directiva &lt;code&gt;#header&lt;/code&gt; le dice a c2nim que debe anotar cada proceso que resulte de un prototipo de funci&amp;oacute;n C y cada variable y tipo exportados con el pragma de &lt;code&gt;header&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">La directiva &lt;code&gt;#skipcomments&lt;/code&gt; se puede poner en el c&amp;oacute;digo C para hacer que c2nim ignore los comentarios y no los copie en el archivo Nim generado.</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">La directiva &lt;code&gt;#typeprefixes&lt;/code&gt; se puede poner en el c&amp;oacute;digo C para hacer que c2nim genere el prefijo &lt;code&gt;T&lt;/code&gt; o &lt;code&gt;P&lt;/code&gt; para cada tipo definido.</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">El operador &lt;code&gt;$&lt;/code&gt; puede convertir cualquier valor de enumeraci&amp;oacute;n a su nombre y &lt;code&gt;ord&lt;/code&gt; proc puede convertirlo a su valor entero subyacente.</target>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated">El &lt;code&gt;**&lt;/code&gt; es muy parecido al operador &lt;code&gt;*&lt;/code&gt; , excepto que re&amp;uacute;ne no solo todos los argumentos, sino tambi&amp;eacute;n los operadores coincidentes en notaci&amp;oacute;n de pulido inverso:</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">El &lt;code&gt;**&lt;/code&gt; operador</target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">El &lt;code&gt;*&lt;/code&gt; operador</target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">El operador &lt;code&gt;*&lt;/code&gt; puede &lt;em&gt;aplanar&lt;/em&gt; una expresi&amp;oacute;n binaria anidada como &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; a &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">El &lt;code&gt;--context&lt;/code&gt; idetools es muy similar al modificador de sugerencias, pero en lugar de usarse despu&amp;eacute;s de que el usuario ha escrito un car&amp;aacute;cter de punto, este est&amp;aacute; dise&amp;ntilde;ado para usarse despu&amp;eacute;s de que el usuario haya escrito una llave de apertura para comenzar a escribir par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">El &lt;code&gt;--def&lt;/code&gt; idetools realiza una consulta sobre la definici&amp;oacute;n de un s&amp;iacute;mbolo espec&amp;iacute;fico. Si est&amp;aacute; disponible, idetools responder&amp;aacute; con el tipo, archivo de origen, informaci&amp;oacute;n de l&amp;iacute;nea / columna y otros datos accesorios si est&amp;aacute;n disponibles como una cadena de documentos. Con esta informaci&amp;oacute;n, un IDE puede proporcionar la &lt;em&gt;definici&amp;oacute;n&lt;/em&gt; t&amp;iacute;pica de &lt;em&gt;Saltar a&lt;/em&gt; donde un usuario coloca el cursor sobre un s&amp;iacute;mbolo o usa el mouse para seleccionarlo y es redirigido al lugar donde se encuentra el s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">El &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;compilador &lt;/a&gt;--nimcache se puede utilizar para cambiar el directorio de &lt;code&gt;nimcache&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">El &lt;code&gt;--suggest&lt;/code&gt; idetools realiza una consulta sobre posibles s&amp;iacute;mbolos de finalizaci&amp;oacute;n en alg&amp;uacute;n punto del archivo. Los IDE pueden proporcionar f&amp;aacute;cilmente una funci&amp;oacute;n de autocompletado donde el IDE escanea el archivo actual (y los relacionados, si conoce el idioma que se est&amp;aacute; editando y sigue incluye / importa) y cuando el usuario comienza a escribir algo, aparece un cuadro de finalizaci&amp;oacute;n con diferentes opciones.</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">El interruptor &lt;code&gt;--usages&lt;/code&gt; idetools enumera todos los usos del s&amp;iacute;mbolo en una posici&amp;oacute;n. Los IDE pueden usar esto para encontrar todos los lugares en el archivo donde se usa el s&amp;iacute;mbolo y ofrecer al usuario cambiar el nombre en todos los lugares al mismo tiempo. Nuevamente, una b&amp;uacute;squeda y reemplazo puramente basados ​​en cadenas puede capturar s&amp;iacute;mbolos fuera del alcance de una funci&amp;oacute;n / bucle.</target>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">El &lt;code&gt;.&lt;/code&gt; Los operadores (acceder a un operador de campo de tupla / objeto) y &lt;code&gt;[]&lt;/code&gt; ( operador de matriz / cadena / &amp;iacute;ndice de secuencia) realizan operaciones de desreferenciaci&amp;oacute;n impl&amp;iacute;citas para tipos de referencia:</target>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">&amp;iexcl;El s&amp;iacute;mbolo &lt;code&gt;C2NIM&lt;/code&gt; solo se reconoce en las construcciones &lt;code&gt;#ifdef&lt;/code&gt; y &lt;code&gt;#ifndef&lt;/code&gt; ! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; lo hace &lt;strong&gt;no&lt;/strong&gt; trabajo.</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">El tipo &lt;code&gt;DateTime&lt;/code&gt; se puede analizar y formatear utilizando los diferentes procedimientos de &lt;code&gt;parse&lt;/code&gt; y &lt;code&gt;format&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">La excepci&amp;oacute;n &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; se genera si &lt;code&gt;x&lt;/code&gt; no es un &lt;code&gt;Student&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">Los &lt;code&gt;RstParseOptions&lt;/code&gt; , &lt;code&gt;FindFileHandler&lt;/code&gt; y &lt;code&gt;MsgHandler&lt;/code&gt; se definen en el &lt;a href=&quot;rst&quot;&gt;m&amp;oacute;dulo packages / docutils / rst&lt;/a&gt; . &lt;code&gt;options&lt;/code&gt; selecciona el comportamiento del primer analizador.</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">La &lt;code&gt;T&lt;/code&gt; se denomina &lt;span id=&quot;generic-type-parameter_1&quot;&gt;par&amp;aacute;metro de tipo gen&amp;eacute;rico&lt;/span&gt; o &lt;span id=&quot;type-variable_1&quot;&gt;variable de tipo&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;[: ]&lt;/code&gt; ha sido dise&amp;ntilde;ada para mitigar este problema: &lt;code&gt;x.p[:T]&lt;/code&gt; es reescrito por el analizador &lt;code&gt;p[T](x)&lt;/code&gt; , &lt;code&gt;x.p[:T](y)&lt;/code&gt; se reescribe &lt;code&gt;p[T](x, y)&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;[: ]&lt;/code&gt; no tiene representaci&amp;oacute;n AST, la reescritura se realiza directamente en el paso de an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">El operador de acceso a la matriz &lt;code&gt;[]&lt;/code&gt; se puede sobrecargar para proporcionar &lt;span id=&quot;array-properties_1&quot;&gt;propiedades de la matriz&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">El operador &lt;code&gt;[]&lt;/code&gt; generar&amp;aacute; una excepci&amp;oacute;n cuando el campo especificado no existe. Si desea evitar este comportamiento, puede usar el operador &lt;code&gt;{}&lt;/code&gt; en su lugar, simplemente devolver&amp;aacute; &lt;code&gt;nil&lt;/code&gt; cuando no se encuentre el campo. La familia de procedimientos &lt;code&gt;get&lt;/code&gt; devolver&amp;aacute; un valor predeterminado cuando se llame a &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">El operador de sub&amp;iacute;ndice &lt;code&gt;[]&lt;/code&gt; para matrices / openarrays / secuencias puede estar sobrecargado.</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">Las afirmaciones &lt;code&gt;\A&lt;/code&gt; , &lt;code&gt;\Z&lt;/code&gt; y &lt;code&gt;\z&lt;/code&gt; difieren del circunflejo y del d&amp;oacute;lar tradicionales en que solo coinciden al principio y al final de la cadena de asunto, independientemente de las opciones establecidas. La diferencia entre &lt;code&gt;\Z&lt;/code&gt; y &lt;code&gt;\z&lt;/code&gt; es que &lt;code&gt;\Z&lt;/code&gt; coincide antes de una nueva l&amp;iacute;nea que es el &amp;uacute;ltimo car&amp;aacute;cter de la cadena, as&amp;iacute; como al final de la cadena, mientras que &lt;code&gt;\z&lt;/code&gt; coincide solo al final.</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">El sufijo &lt;code&gt;_r&lt;/code&gt; se usa para versiones de versiones, &lt;code&gt;_d&lt;/code&gt; es para versiones de depuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">La llamada de &lt;code&gt;accept&lt;/code&gt; puede resultar en un error si el enchufe de conexi&amp;oacute;n se desconecta durante la duraci&amp;oacute;n de la &lt;code&gt;accept&lt;/code&gt; . Si se especifica el indicador &lt;code&gt;SafeDisconn&lt;/code&gt; , este error no se generar&amp;aacute; y, en su lugar, se llamar&amp;aacute; de nuevo a accept.</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">El pragma &lt;code&gt;acyclic&lt;/code&gt; se puede utilizar para los tipos de objetos para marcarlos como ac&amp;iacute;clicos aunque parezcan c&amp;iacute;clicos. Esta es una &lt;strong&gt;optimizaci&amp;oacute;n&lt;/strong&gt; para que el recolector de basura no considere objetos de este tipo como parte de un ciclo:</target>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">El operador &lt;code&gt;addr&lt;/code&gt; devuelve la direcci&amp;oacute;n de un valor l. Si el tipo de la ubicaci&amp;oacute;n es &lt;code&gt;T&lt;/code&gt; , el &lt;em&gt;addr&lt;/em&gt; resultado operador es del tipo &lt;code&gt;ptr T&lt;/code&gt; . Una direcci&amp;oacute;n es siempre una referencia sin rastrear. Tomar la direcci&amp;oacute;n de un objeto que reside en la pila &lt;strong&gt;no&lt;/strong&gt; es &lt;strong&gt;seguro&lt;/strong&gt; , ya que el puntero puede vivir m&amp;aacute;s que el objeto en la pila y, por lo tanto, puede hacer referencia a un objeto no existente. Se puede obtener la direcci&amp;oacute;n de las variables, pero no se puede usar en variables declaradas a trav&amp;eacute;s de declaraciones &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">Los procedimientos &lt;code&gt;async&lt;/code&gt; tambi&amp;eacute;n ofrecen soporte limitado para la declaraci&amp;oacute;n de prueba.</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">El tipo &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico solo se puede utilizar para tipos de retorno y par&amp;aacute;metros. Para los tipos de retorno, hace que el compilador infiera el tipo del cuerpo de la rutina:</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">La llamada en &lt;code&gt;await&lt;/code&gt; se puede utilizar en muchos contextos. Se puede usar en el lado derecho de una declaraci&amp;oacute;n de variable: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; , en cuyo caso la variable se establecer&amp;aacute; autom&amp;aacute;ticamente en el valor del futuro. Puede usarse para esperar un objeto &lt;code&gt;Future&lt;/code&gt; , y puede usarse para esperar un procedimiento que devuelva un &lt;code&gt;Future[void]&lt;/code&gt; : &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;bind&lt;/code&gt; es la contraparte de la declaraci&amp;oacute;n de &lt;code&gt;mixin&lt;/code&gt; . Se puede usar para declarar expl&amp;iacute;citamente identificadores que deben vincularse antes (es decir, los identificadores deben buscarse en el alcance de la plantilla / definici&amp;oacute;n gen&amp;eacute;rica):</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">El pragma de &lt;code&gt;bitsize&lt;/code&gt; es para miembros de campo de objeto. Declara el campo como un campo de bits en C / C ++.</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">El pragma de &lt;code&gt;borrow&lt;/code&gt; hace que el compilador use la misma implementaci&amp;oacute;n que el proceso que trata con el tipo base del tipo diferenciado, por lo que no se genera c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">La sentencia &lt;code&gt;break&lt;/code&gt; se usa para dejar un bloque inmediatamente. Si se da el &lt;code&gt;symbol&lt;/code&gt; , es el nombre del bloque circundante que se va a dejar. Si est&amp;aacute; ausente, se deja el bloque m&amp;aacute;s interno.</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">El pragma &lt;code&gt;bycopy&lt;/code&gt; se puede aplicar a un objeto o tipo de tupla e indica al compilador que pase el tipo por valor a procs:</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">El pragma &lt;code&gt;byref&lt;/code&gt; se puede aplicar a un objeto o tipo de tupla e indica al compilador que pase el tipo por referencia (puntero oculto) a procs.</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">La restricci&amp;oacute;n de &lt;code&gt;call&lt;/code&gt; es particularmente &amp;uacute;til para implementar una optimizaci&amp;oacute;n de movimiento para tipos que tienen sem&amp;aacute;ntica de copia:</target>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;case&lt;/code&gt; es similar a la declaraci&amp;oacute;n if, pero representa una selecci&amp;oacute;n de varias ramas. La expresi&amp;oacute;n despu&amp;eacute;s del &lt;code&gt;case&lt;/code&gt; la palabra clave se eval&amp;uacute;a y si su valor est&amp;aacute; en una lista de &lt;em&gt;sectores, se ejecutan&lt;/em&gt; las declaraciones correspondientes (despu&amp;eacute;s de la palabra clave &lt;code&gt;of&lt;/code&gt; ). Si el valor no est&amp;aacute; en ninguna lista de &lt;em&gt;sectores&lt;/em&gt; determinada, se &lt;em&gt;ejecuta&lt;/em&gt; la parte &lt;code&gt;else&lt;/code&gt; . Si no hay &lt;code&gt;else&lt;/code&gt; parte y no todos los valores posibles que &lt;code&gt;expr&lt;/code&gt; puede contener ocurren en una lista de &lt;code&gt;slicelist&lt;/code&gt; , se produce un error est&amp;aacute;tico. Esto es v&amp;aacute;lido solo para expresiones de tipos ordinales. &quot;Todos los valores posibles&quot; de &lt;code&gt;expr&lt;/code&gt; est&amp;aacute;n determinados por &lt;code&gt;expr&lt;/code&gt; tipo de. Para suprimir el error est&amp;aacute;tico , se debe utilizar una parte &lt;code&gt;else&lt;/code&gt; con una declaraci&amp;oacute;n de &lt;code&gt;discard&lt;/code&gt; vac&amp;iacute;a .</target>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">El pragma &lt;code&gt;codegenDecl&lt;/code&gt; se puede utilizar para influir directamente en el generador de c&amp;oacute;digo de Nim. Recibe una cadena de formato que determina c&amp;oacute;mo se declara la variable o proc en el c&amp;oacute;digo generado.</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">El pragma de &lt;code&gt;compile&lt;/code&gt; se puede utilizar para compilar y vincular un archivo fuente C / C ++ con el proyecto:</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">El pragma &lt;code&gt;compileTime&lt;/code&gt; se usa para marcar un proceso o variable para ser usado solo en tiempo de compilaci&amp;oacute;n. No se generar&amp;aacute; ning&amp;uacute;n c&amp;oacute;digo para ello. Los procesos de tiempo de compilaci&amp;oacute;n son &amp;uacute;tiles como ayudantes para macros. Desde la versi&amp;oacute;n 0.12.0 del lenguaje, un proc que usa &lt;code&gt;system.NimNode&lt;/code&gt; dentro de sus tipos de par&amp;aacute;metros se declara impl&amp;iacute;citamente &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">El pragma &lt;code&gt;computedGoto&lt;/code&gt; se puede utilizar para decirle al compilador c&amp;oacute;mo compilar un &lt;span id=&quot;case_2&quot;&gt;caso&lt;/span&gt; Nim en una declaraci&amp;oacute;n &lt;code&gt;while true&lt;/code&gt; . Sint&amp;aacute;cticamente, debe usarse como una declaraci&amp;oacute;n dentro del ciclo:</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">El comando &lt;code&gt;con&lt;/code&gt; Nimsuggest es muy similar al comando de sugerencias, pero en lugar de usarse despu&amp;eacute;s de que el usuario haya escrito un car&amp;aacute;cter de punto, este debe usarse despu&amp;eacute;s de que el usuario haya escrito una llave de apertura para comenzar a escribir par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">El tipo &lt;code&gt;cstring&lt;/code&gt; que significa &lt;em&gt;cadena compatible&lt;/em&gt; es la representaci&amp;oacute;n nativa de una cadena para el backend de compilaci&amp;oacute;n. Para el backend C, el tipo &lt;code&gt;cstring&lt;/code&gt; representa un puntero a una matriz de caracteres terminada en cero compatible con el tipo &lt;code&gt;char*&lt;/code&gt; en Ansi C. Su prop&amp;oacute;sito principal radica en una f&amp;aacute;cil interfaz con C. La operaci&amp;oacute;n de &amp;iacute;ndice &lt;code&gt;s[i]&lt;/code&gt; significa el i-&amp;eacute;simo &lt;em&gt;car&amp;aacute;cter&lt;/em&gt; de &lt;code&gt;s&lt;/code&gt; ; sin embargo, no se realiza ninguna comprobaci&amp;oacute;n de l&amp;iacute;mites para &lt;code&gt;cstring&lt;/code&gt; , lo que hace que la operaci&amp;oacute;n de &amp;iacute;ndice sea insegura.</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">Los &lt;code&gt;data&lt;/code&gt; son datos definidos por la aplicaci&amp;oacute;n, que se pasar&amp;aacute;n cuando ocurra &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">Los &lt;code&gt;data&lt;/code&gt; son datos definidos por la aplicaci&amp;oacute;n, que se pasar&amp;aacute;n cuando el proceso con &lt;code&gt;pid&lt;/code&gt; haya finalizado.</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">Los &lt;code&gt;data&lt;/code&gt; son datos definidos por la aplicaci&amp;oacute;n, que se pasar&amp;aacute;n cuando aumente la se&amp;ntilde;al.</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">Los &lt;code&gt;data&lt;/code&gt; son datos definidos por la aplicaci&amp;oacute;n, que se pasar&amp;aacute;n cuando se active el temporizador.</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">El comando &lt;code&gt;def&lt;/code&gt; Nimsuggest realiza una consulta sobre la definici&amp;oacute;n de un s&amp;iacute;mbolo espec&amp;iacute;fico. Si est&amp;aacute; disponible, Nimsuggest responder&amp;aacute; con el tipo, archivo de origen, informaci&amp;oacute;n de l&amp;iacute;nea / columna y otros datos accesorios si est&amp;aacute;n disponibles como una cadena de documentos. Con esta informaci&amp;oacute;n, un IDE puede proporcionar la &lt;em&gt;definici&amp;oacute;n&lt;/em&gt; t&amp;iacute;pica de &lt;em&gt;Saltar a&lt;/em&gt; donde un usuario coloca el cursor sobre un s&amp;iacute;mbolo o usa el mouse para seleccionarlo y es redirigido al lugar donde se encuentra el s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;discard&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para crear comentarios en bloque como se describe en la secci&amp;oacute;n &lt;a href=&quot;#comments&quot;&gt;Comentarios&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;discard&lt;/code&gt; eval&amp;uacute;a su expresi&amp;oacute;n en busca de efectos secundarios y descarta el valor resultante de la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">El comando &lt;code&gt;doc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">El mecanismo de importaci&amp;oacute;n de &lt;code&gt;dynlib&lt;/code&gt; admite un esquema de control de versiones:</target>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">El pragma &lt;code&gt;dynlib&lt;/code&gt; admite no solo cadenas constantes como argumento, sino tambi&amp;eacute;n expresiones de cadena en general:</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">El pragma de &lt;code&gt;effects&lt;/code&gt; ha sido dise&amp;ntilde;ado para ayudar al programador con el an&amp;aacute;lisis de efectos. Es una declaraci&amp;oacute;n que hace que el compilador genere todos los efectos inferidos hasta la posici&amp;oacute;n de los &lt;code&gt;effects&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">El pragma de &lt;code&gt;emit&lt;/code&gt; se puede utilizar para afectar directamente la salida del generador de c&amp;oacute;digo del compilador. Por lo tanto, hace que su c&amp;oacute;digo no sea port&amp;aacute;til para otros generadores de c&amp;oacute;digo / backends. &amp;iexcl;Su uso est&amp;aacute; altamente desaconsejado! Sin embargo, puede ser extremadamente &amp;uacute;til para interactuar con c&amp;oacute;digo &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt; o &lt;span id=&quot;objective-c_1&quot;&gt;Objective C.&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">El procedimiento de &lt;code&gt;encode&lt;/code&gt; toma una &lt;code&gt;openarray&lt;/code&gt; para que tanto las matrices como las secuencias se puedan pasar como par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">El pragma de &lt;code&gt;error&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para anotar un s&amp;iacute;mbolo (como un iterador o un proceso). El &lt;em&gt;uso&lt;/em&gt; del s&amp;iacute;mbolo desencadena un error en tiempo de compilaci&amp;oacute;n. Esto es especialmente &amp;uacute;til para descartar que alguna operaci&amp;oacute;n sea v&amp;aacute;lida por sobrecarga y conversiones de tipo:</target>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">El pragma de &lt;code&gt;error&lt;/code&gt; se utiliza para hacer que el compilador genere un mensaje de error con el contenido dado. Sin embargo, la compilaci&amp;oacute;n no se cancela necesariamente despu&amp;eacute;s de un error.</target>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">El pragma &lt;code&gt;experimental&lt;/code&gt; habilita caracter&amp;iacute;sticas del lenguaje experimental. Dependiendo de la caracter&amp;iacute;stica concreta, esto significa que la caracter&amp;iacute;stica se considera demasiado inestable para una versi&amp;oacute;n que de otro modo ser&amp;iacute;a estable o que el futuro de la caracter&amp;iacute;stica es incierto (puede eliminarse en cualquier momento).</target>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">El &lt;code&gt;exportc&lt;/code&gt; pragma proporciona un medio para exportar un tipo, una variable, o un procedimiento para C. enumeraciones y constantes no pueden ser exportados. El argumento opcional es una cadena que contiene el identificador C. Si falta el argumento, el nombre C es el identificador de Nim &lt;em&gt;exactamente como se escribe&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;expr&lt;/code&gt; en &lt;code&gt;let x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">El &lt;code&gt;expr&lt;/code&gt; en &lt;code&gt;result = expr&lt;/code&gt; donde &lt;code&gt;result&lt;/code&gt; ado es el s&amp;iacute;mbolo especial introducido por el compilador.</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;expr&lt;/code&gt; a &lt;code&gt;return expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;expr&lt;/code&gt; en &lt;code&gt;var x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">El pragma &lt;code&gt;fatal&lt;/code&gt; se usa para hacer que el compilador genere un mensaje de error con el contenido dado. En contraste con el pragma de &lt;code&gt;error&lt;/code&gt; , se garantiza que la compilaci&amp;oacute;n ser&amp;aacute; abortada por este pragma. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;file&lt;/code&gt; es suficiente para el an&amp;aacute;lisis est&amp;aacute;tico, pero los IDE tienden a tener &lt;em&gt;b&amp;uacute;feres no guardados&lt;/em&gt; en los que el usuario a&amp;uacute;n puede estar escribiendo una l&amp;iacute;nea. En tales situaciones, el IDE puede guardar el contenido actual en un archivo temporal y luego usar la opci&amp;oacute;n &lt;code&gt;dirtyfile.nim&lt;/code&gt; para decirle a Nimsuggest que &lt;code&gt;foobar.nim&lt;/code&gt; debe tomarse de &lt;code&gt;temporary/foobar.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">El pragma &lt;code&gt;final&lt;/code&gt; se puede usar para un tipo de objeto para especificar que no se puede heredar. Tenga en cuenta que la herencia solo est&amp;aacute; disponible para los objetos que heredan de un objeto existente (a trav&amp;eacute;s del &lt;code&gt;object of SuperType&lt;/code&gt; sintaxis de SuperType ) o que se han marcado como &lt;code&gt;inheritable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">La &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; es m&amp;aacute;s agradable desde el punto de vista est&amp;eacute;tico, pero esconde un peque&amp;ntilde;o problema. La cadena es un &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;literal de cadena sin formato generalizado&lt;/a&gt; . Esto tiene algunos efectos sorprendentes:</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">El bucle &lt;code&gt;for&lt;/code&gt; declara variables de iteraci&amp;oacute;n: su alcance llega hasta el final del cuerpo del bucle. Los tipos de las variables de iteraci&amp;oacute;n se infieren mediante el tipo de retorno del iterador.</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;for&lt;/code&gt; se puede usar con una o dos variables cuando se usa con una secuencia. Cuando usa la forma de una variable, la variable tendr&amp;aacute; el valor proporcionado por la secuencia. La instrucci&amp;oacute;n &lt;code&gt;for&lt;/code&gt; recorre los resultados del iterador &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items ()&lt;/a&gt; del m&amp;oacute;dulo del &lt;a href=&quot;system&quot;&gt;sistema&lt;/a&gt; . Pero si usa la forma de dos variables, la primera variable mantendr&amp;aacute; la posici&amp;oacute;n del &amp;iacute;ndice y la segunda variable mantendr&amp;aacute; el valor. Aqu&amp;iacute;, la instrucci&amp;oacute;n &lt;code&gt;for&lt;/code&gt; recorre los resultados del iterador &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pair ()&lt;/a&gt; del m&amp;oacute;dulo del &lt;a href=&quot;system&quot;&gt;sistema&lt;/a&gt; . Ejemplos:</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;for&lt;/code&gt; es una construcci&amp;oacute;n para recorrer cualquier elemento que proporcione un &lt;em&gt;iterador&lt;/em&gt; . El ejemplo usa el iterador de &lt;a href=&quot;system#countup&quot;&gt;conteo integrado&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;from&lt;/code&gt; tambi&amp;eacute;n puede forzar la calificaci&amp;oacute;n del espacio de nombres en los s&amp;iacute;mbolos, lo que hace que los s&amp;iacute;mbolos est&amp;eacute;n disponibles, pero deben estar calificados para su uso.</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">La palabra clave &lt;code&gt;func&lt;/code&gt; introduce un atajo para un proceso &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">La operaci&amp;oacute;n de &lt;code&gt;get&lt;/code&gt; demostrada arriba devuelve el valor subyacente o genera &lt;code&gt;UnpackError&lt;/code&gt; si no hay ning&amp;uacute;n valor. Hay otra opci&amp;oacute;n para obtener el valor: &lt;code&gt;unsafeGet&lt;/code&gt; , pero solo debe usarlo cuando est&amp;eacute; absolutamente seguro de que el valor est&amp;aacute; presente (por ejemplo, despu&amp;eacute;s de verificar &lt;code&gt;isSome&lt;/code&gt; ). Si no se preocupan por la peque&amp;ntilde;a sobrecarga que &lt;code&gt;get&lt;/code&gt; causas, se debe simplemente nunca utilizar &lt;code&gt;unsafeGet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">El pragma &lt;code&gt;global&lt;/code&gt; se puede aplicar a una variable dentro de un proceso para indicar al compilador que la almacene en una ubicaci&amp;oacute;n global y la inicialice una vez al inicio del programa.</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">La anotaci&amp;oacute;n de &lt;code&gt;guard&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para proteger campos dentro de un objeto. Entonces, la guardia debe ser otro campo dentro del mismo objeto o una variable global.</target>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">El pragma del &lt;code&gt;header&lt;/code&gt; siempre espera una constante de cadena. El contenido de la cadena contiene el archivo de encabezado: Como es habitual en C, un archivo de encabezado del sistema se incluye entre corchetes angulares: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Si no se proporcionan corchetes angulares, Nim incluye el archivo de encabezado en &lt;code&gt;&quot;&quot;&lt;/code&gt; en el c&amp;oacute;digo C generado.</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">El pragma del &lt;code&gt;header&lt;/code&gt; es muy similar al pragma &lt;code&gt;noDecl&lt;/code&gt; : se puede aplicar a casi cualquier s&amp;iacute;mbolo y especifica que no debe declararse y, en cambio, el c&amp;oacute;digo generado debe contener un &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">El pragma de &lt;code&gt;hint&lt;/code&gt; se utiliza para hacer que el compilador genere un mensaje de sugerencia con el contenido dado. La compilaci&amp;oacute;n contin&amp;uacute;a despu&amp;eacute;s de la pista.</target>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">La sentencia &lt;code&gt;if&lt;/code&gt; es una forma sencilla de hacer una rama en el flujo de control: se eval&amp;uacute;a la expresi&amp;oacute;n despu&amp;eacute;s de la palabra clave &lt;code&gt;if&lt;/code&gt; , si es verdadera se ejecutan las sentencias correspondientes despu&amp;eacute;s de &lt;code&gt;:&lt;/code&gt; . De lo contrario, se eval&amp;uacute;a la expresi&amp;oacute;n despu&amp;eacute;s de &lt;code&gt;elif&lt;/code&gt; (si hay una rama &lt;code&gt;elif&lt;/code&gt; ), si es verdadera, se ejecutan las declaraciones correspondientes despu&amp;eacute;s de &lt;code&gt;:&lt;/code&gt; . Esto contin&amp;uacute;a hasta el &amp;uacute;ltimo &lt;code&gt;elif&lt;/code&gt; . Si todas las condiciones fallan, se ejecuta la parte &lt;code&gt;else&lt;/code&gt; . Si no hay &lt;code&gt;else&lt;/code&gt; parte, la ejecuci&amp;oacute;n contin&amp;uacute;a con la siguiente instrucci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">El pragma &lt;code&gt;importc&lt;/code&gt; proporciona un medio para importar un proceso o una variable de C. El argumento opcional es una cadena que contiene el identificador C. Si falta el argumento, el nombre C es el identificador de Nim &lt;em&gt;exactamente como se escribe&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;include&lt;/code&gt; hace algo fundamentalmente diferente a importar un m&amp;oacute;dulo: simplemente incluye el contenido de un archivo. La declaraci&amp;oacute;n de &lt;code&gt;include&lt;/code&gt; es &amp;uacute;til para dividir un m&amp;oacute;dulo grande en varios archivos:</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">El pragma &lt;code&gt;incompleteStruct&lt;/code&gt; le dice al compilador que no use la &lt;code&gt;struct&lt;/code&gt; C subyacente en una expresi&amp;oacute;n &lt;code&gt;sizeof&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">Los &lt;code&gt;gensym&lt;/code&gt; &lt;code&gt;inject&lt;/code&gt; y gensym son anotaciones de segunda clase; no tienen sem&amp;aacute;ntica fuera de una definici&amp;oacute;n de plantilla y no se pueden abstraer sobre:</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">El pragma &lt;code&gt;injectStmt&lt;/code&gt; se puede usar para inyectar una declaraci&amp;oacute;n antes de cualquier otra declaraci&amp;oacute;n en el m&amp;oacute;dulo actual. Solo se supone que debe usarse para depurar:</target>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;intsets&lt;/code&gt; implementa un conjunto int eficiente implementado como un &lt;span id=&quot;sparse-bit-set_1&quot;&gt;conjunto de bits dispersos&lt;/span&gt; . &lt;strong&gt;Nota&lt;/strong&gt; : Dado que Nim actualmente no permite que el operador de asignaci&amp;oacute;n se sobrecargue, &lt;code&gt;=&lt;/code&gt; for int sets realiza una copia superficial bastante sin sentido; use &lt;code&gt;assign&lt;/code&gt; para obtener una copia en profundidad.</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">El patr&amp;oacute;n del par&amp;aacute;metro &lt;code&gt;int{lit}&lt;/code&gt; coincide con una expresi&amp;oacute;n de tipo &lt;code&gt;int&lt;/code&gt; , pero solo si es un literal.</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">El operador &lt;code&gt;is&lt;/code&gt; comprueba la equivalencia de tipos en tiempo de compilaci&amp;oacute;n. Por lo tanto, es muy &amp;uacute;til para la especializaci&amp;oacute;n de tipos dentro de c&amp;oacute;digo gen&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">El tipo de &lt;code&gt;iterator&lt;/code&gt; es siempre del &lt;code&gt;closure&lt;/code&gt; convenci&amp;oacute;n de llamada impl&amp;iacute;citamente; El siguiente ejemplo muestra c&amp;oacute;mo utilizar iteradores para implementar un sistema de &lt;span id=&quot;collaborative-tasking_1&quot;&gt;tareas colaborativas&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">El comando &lt;code&gt;jsondoc0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">El comando &lt;code&gt;jsondoc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">El programa &lt;code&gt;koch&lt;/code&gt; es el script de mantenimiento de Nim. Es un reemplazo de las secuencias de comandos de creaci&amp;oacute;n y shell con la ventaja de que es mucho m&amp;aacute;s port&amp;aacute;til. Puede encontrar m&amp;aacute;s informaci&amp;oacute;n sobre sus opciones en la documentaci&amp;oacute;n de &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; funciona como la instrucci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; , pero los s&amp;iacute;mbolos declarados son variables de &lt;em&gt;asignaci&amp;oacute;n &amp;uacute;nica&lt;/em&gt; : despu&amp;eacute;s de la inicializaci&amp;oacute;n, su valor no puede cambiar:</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">El pragma de &lt;code&gt;line&lt;/code&gt; se puede usar para afectar la informaci&amp;oacute;n de la l&amp;iacute;nea de la declaraci&amp;oacute;n anotada como se ve en las trazas de pila:</target>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;lineDir&lt;/code&gt; se puede activar o desactivar. Si est&amp;aacute; activado, el c&amp;oacute;digo C generado contiene directivas &lt;code&gt;#line&lt;/code&gt; . Esto puede resultar &amp;uacute;til para depurar con GDB.</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;lineInfoFrom&lt;/code&gt; se usa para informaci&amp;oacute;n de l&amp;iacute;nea cuando el c&amp;oacute;digo producido falla. Debe asegurarse de que est&amp;eacute; configurado en un nodo que est&amp;aacute; transformando.</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;lineTrace&lt;/code&gt; implica la opci&amp;oacute;n &lt;code&gt;stackTrace&lt;/code&gt; . Si est&amp;aacute; activado, el C generado contiene c&amp;oacute;digo para garantizar que se proporcionen los seguimientos de pila adecuados con la informaci&amp;oacute;n del n&amp;uacute;mero de l&amp;iacute;nea si el programa falla o se genera una excepci&amp;oacute;n no detectada.</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">El pragma &lt;code&gt;linearScanEnd&lt;/code&gt; se puede usar para decirle al compilador c&amp;oacute;mo compilar una declaraci&amp;oacute;n de &lt;span id=&quot;case_1&quot;&gt;caso de&lt;/span&gt; Nim . Sint&amp;aacute;cticamente tiene que usarse como una declaraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">El pragma &lt;code&gt;linearScanEnd&lt;/code&gt; debe colocarse en la &amp;uacute;ltima rama con la que se debe probar a trav&amp;eacute;s del escaneo lineal. Si se coloca en la &amp;uacute;ltima rama de la declaraci&amp;oacute;n de &lt;code&gt;case&lt;/code&gt; completa , la declaraci&amp;oacute;n de &lt;code&gt;case&lt;/code&gt; completa utiliza un escaneo lineal.</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">El pragma de &lt;code&gt;link&lt;/code&gt; se puede utilizar para vincular un archivo adicional con el proyecto:</target>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">El pragma de &lt;code&gt;locks&lt;/code&gt; tambi&amp;eacute;n puede tomar el valor especial &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; . Esto es &amp;uacute;til en el contexto del env&amp;iacute;o de m&amp;eacute;todos din&amp;aacute;micos. En el siguiente ejemplo, el compilador puede inferir un nivel de bloqueo de 0 para el caso &lt;code&gt;base&lt;/code&gt; . Sin embargo, uno de los m&amp;eacute;todos sobrecargados llama a un procvar que potencialmente se est&amp;aacute; bloqueando. Por lo tanto, el nivel de bloqueo de la llamada a &lt;code&gt;g.testMethod&lt;/code&gt; no se puede inferir de forma est&amp;aacute;tica, lo que genera advertencias del compilador. Al usar &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; , El m&amp;eacute;todo base tambi&amp;eacute;n se puede marcar expl&amp;iacute;citamente con un nivel de bloqueo desconocido:</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">El pragma de &lt;code&gt;locks&lt;/code&gt; toma una lista de bloqueos de expresiones de &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; para admitir declaraciones de &lt;em&gt;bloqueo m&amp;uacute;ltiple&lt;/em&gt; . Por qu&amp;eacute; estos son esenciales se explica en la secci&amp;oacute;n de &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;niveles de bloqueo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">La secci&amp;oacute;n de &lt;code&gt;locks&lt;/code&gt; deliberadamente se ve fea porque no tiene sem&amp;aacute;ntica de tiempo de ejecuci&amp;oacute;n y no debe usarse directamente. Solo debe usarse en plantillas que tambi&amp;eacute;n implementen alguna forma de bloqueo en tiempo de ejecuci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;mapper&lt;/code&gt; puede modificar los valores &lt;code&gt;val&lt;/code&gt; y &lt;code&gt;pairExists&lt;/code&gt; para cambiar el mapeo de la clave o eliminarlo de la tabla. Al agregar un valor, aseg&amp;uacute;rese de establecer &lt;code&gt;pairExists&lt;/code&gt; en &lt;code&gt;true&lt;/code&gt; junto con la modificaci&amp;oacute;n de &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">El &lt;code&gt;mapper&lt;/code&gt; toma 3 argumentos:</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;maxLength&lt;/code&gt; determina la cantidad m&amp;aacute;xima de caracteres que se pueden leer. &lt;code&gt;resString&lt;/code&gt; se truncar&amp;aacute; despu&amp;eacute;s de eso.</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;maxLength&lt;/code&gt; determina la cantidad m&amp;aacute;xima de caracteres que se pueden leer. El resultado se trunca despu&amp;eacute;s de eso.</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">El &lt;code&gt;msgHandler&lt;/code&gt; es un proc utilizado para el informe de errores de usuario. Se llamar&amp;aacute; con el nombre de archivo, la l&amp;iacute;nea, la columna y el tipo de cualquier error encontrado durante el an&amp;aacute;lisis. Si pasa &lt;code&gt;nil&lt;/code&gt; , se utilizar&amp;aacute; un controlador de mensajes predeterminado que escribe los mensajes en la salida est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">El ejecutable de &lt;code&gt;nim&lt;/code&gt; procesa los archivos de configuraci&amp;oacute;n en los siguientes directorios (en este orden; los archivos posteriores sobrescriben la configuraci&amp;oacute;n anterior):</target>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">Es &lt;code&gt;nnkElifBranch&lt;/code&gt; &lt;code&gt;nnkElse&lt;/code&gt; partes nnkElifBranch y nnkElse .</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">El pragma &lt;code&gt;noDecl&lt;/code&gt; se puede aplicar a casi cualquier s&amp;iacute;mbolo (variable, proc, tipo, etc.) y en ocasiones es &amp;uacute;til para la interoperabilidad con C: le dice a Nim que no debe generar una declaraci&amp;oacute;n para el s&amp;iacute;mbolo en el c&amp;oacute;digo C. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">El pragma &lt;code&gt;noSideEffect&lt;/code&gt; se utiliza para marcar un proceso / iterador para que no tenga efectos secundarios. Esto significa que el proc / iterator solo cambia las ubicaciones que son accesibles desde sus par&amp;aacute;metros y el valor de retorno solo depende de los argumentos. Si ninguno de sus par&amp;aacute;metros tiene el tipo &lt;code&gt;var T&lt;/code&gt; o &lt;code&gt;ref T&lt;/code&gt; o &lt;code&gt;ptr T&lt;/code&gt; , esto significa que no se modifica ninguna ubicaci&amp;oacute;n. Es un error est&amp;aacute;tico marcar un proc / iterator para que no tenga efectos secundarios si el compilador no puede verificarlo.</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">El pragma &lt;code&gt;noreturn&lt;/code&gt; se usa para marcar un proceso que nunca regresa.</target>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">La &lt;code&gt;operation&lt;/code&gt; par&amp;aacute;metro debe ser una expresi&amp;oacute;n que utiliza las variables &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; para cada paso del pliegue. Dado que este es un pliegue a la izquierda, para operaciones binarias no asociativas como la resta, piense que la secuencia de n&amp;uacute;meros 1, 2 y 3 estar&amp;aacute; entre par&amp;eacute;ntesis como (((1) - 2) - 3).</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">La &lt;code&gt;operation&lt;/code&gt; par&amp;aacute;metro debe ser una expresi&amp;oacute;n que utiliza las variables &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; para cada paso del pliegue. Dado que este es un pliegue a la derecha, para operaciones binarias no asociativas como la resta, piense que la secuencia de n&amp;uacute;meros 1, 2 y 3 estar&amp;aacute; entre par&amp;eacute;ntesis como (1 - (2 - (3))).</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">La &lt;code&gt;operation&lt;/code&gt; par&amp;aacute;metro debe ser una expresi&amp;oacute;n que utiliza las variables &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; para cada paso del pliegue. El &lt;code&gt;first&lt;/code&gt; par&amp;aacute;metro es el valor inicial (la primera &lt;code&gt;a&lt;/code&gt; ) y por lo tanto define el tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">La plantilla &lt;code&gt;optPeg&lt;/code&gt; optimiza el caso de un constructor de clavijas con un literal de cadena, de modo que el patr&amp;oacute;n solo se analizar&amp;aacute; una vez al inicio del programa y se almacenar&amp;aacute; en un &lt;code&gt;gl&lt;/code&gt; global que luego se reutilizar&amp;aacute;. Esta optimizaci&amp;oacute;n se denomina elevaci&amp;oacute;n porque es comparable a la elevaci&amp;oacute;n de bucle cl&amp;aacute;sica.</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">El pragma &lt;code&gt;packed&lt;/code&gt; se puede aplicar a cualquier tipo de &lt;code&gt;object&lt;/code&gt; . Garantiza que los campos de un objeto se empaqueten uno tras otro en la memoria. Es &amp;uacute;til para almacenar paquetes o mensajes desde / hacia la red o los controladores de hardware, y para la interoperabilidad con C. La combinaci&amp;oacute;n de pragma empaquetado con herencia no est&amp;aacute; definida y no debe usarse con memoria GC'ed (ref's).</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">La matriz de &lt;code&gt;params&lt;/code&gt; debe comenzar con el tipo de retorno del proceso, seguido de una lista de IdentDefs que especifique los params.</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">El procedimiento &lt;code&gt;parseJson&lt;/code&gt; toma una cadena que contiene JSON y devuelve un objeto &lt;code&gt;JsonNode&lt;/code&gt; . Esta es una variante de objeto y es &lt;code&gt;JObject&lt;/code&gt; , &lt;code&gt;JArray&lt;/code&gt; , &lt;code&gt;JString&lt;/code&gt; , &lt;code&gt;JInt&lt;/code&gt; , &lt;code&gt;JFloat&lt;/code&gt; , &lt;code&gt;JBool&lt;/code&gt; o &lt;code&gt;JNull&lt;/code&gt; . Compruebe el tipo de esta variante de objeto utilizando el &lt;code&gt;kind&lt;/code&gt; acceso de tipo .</target>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;parsecfg&lt;/code&gt; implementa un analizador de archivos de configuraci&amp;oacute;n de alto rendimiento. La sintaxis del archivo de configuraci&amp;oacute;n es similar al formato &lt;code&gt;.ini&lt;/code&gt; de Windows , pero mucho m&amp;aacute;s potente, ya que no es un analizador basado en l&amp;iacute;neas. Los literales de cadena, los literales de cadena sin formato y los literales de cadena entre comillas triples se admiten como en el lenguaje de programaci&amp;oacute;n Nim. Este es un ejemplo de c&amp;oacute;mo puede verse un archivo de configuraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;parsesql&lt;/code&gt; implementa un analizador de archivos SQL de alto rendimiento. Analiza la sintaxis de PostgreSQL y el est&amp;aacute;ndar SQL ANSI.</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">El pragma &lt;code&gt;passC&lt;/code&gt; se puede usar para pasar par&amp;aacute;metros adicionales al compilador de C como lo har&amp;iacute;a usando el interruptor de l&amp;iacute;nea de comandos &lt;code&gt;--passC&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">El pragma &lt;code&gt;passL&lt;/code&gt; se puede usar para pasar par&amp;aacute;metros adicionales al enlazador como lo har&amp;iacute;a usando el interruptor de l&amp;iacute;nea de comandos &lt;code&gt;--passL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;poll&lt;/code&gt; no devolver&amp;aacute;, por s&amp;iacute; sola, ning&amp;uacute;n evento. En su lugar , se completar&amp;aacute; un objeto &lt;code&gt;Future&lt;/code&gt; apropiado . Un &lt;code&gt;Future&lt;/code&gt; es un tipo que tiene un valor que a&amp;uacute;n no est&amp;aacute; disponible, pero que &lt;em&gt;puede&lt;/em&gt; estar disponible en el futuro. Puede comprobar si un futuro est&amp;aacute; terminado utilizando la funci&amp;oacute;n &lt;code&gt;finished&lt;/code&gt; . Cuando se termina un futuro, significa que el valor que tiene ahora est&amp;aacute; disponible o tiene un error. Esta &amp;uacute;ltima situaci&amp;oacute;n ocurre cuando la operaci&amp;oacute;n para completar un futuro falla con una excepci&amp;oacute;n. Puede distinguir entre las dos situaciones con la funci&amp;oacute;n &lt;code&gt;failed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">El &lt;code&gt;pragma&lt;/code&gt; pragma se puede utilizar para declarar pragmas definidos por el usuario. Esto es &amp;uacute;til porque las plantillas y macros de Nim no afectan a los pragmas. Los pragmas definidos por el usuario est&amp;aacute;n en un &amp;aacute;mbito de m&amp;oacute;dulo diferente al de todos los dem&amp;aacute;s s&amp;iacute;mbolos. No se pueden importar desde un m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">El proceso &lt;code&gt;readCfgAtRuntime&lt;/code&gt; abrir&amp;aacute; el nombre de archivo dado y devolver&amp;aacute; una &lt;code&gt;Table&lt;/code&gt; desde el &lt;a href=&quot;tables&quot;&gt;m&amp;oacute;dulo de tablas&lt;/a&gt; . El an&amp;aacute;lisis del archivo se realiza (sin mucho cuidado por manejar datos inv&amp;aacute;lidos o casos de esquina) usando el &lt;a href=&quot;strutils#splitLines&quot;&gt;proceso splitLines del m&amp;oacute;dulo strutils&lt;/a&gt; . Hay muchas cosas que pueden fallar; Tenga en cuenta que el prop&amp;oacute;sito es explicar c&amp;oacute;mo hacer que esto se ejecute en tiempo de compilaci&amp;oacute;n, no c&amp;oacute;mo implementar correctamente un esquema DRM.</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">El pragma de &lt;code&gt;register&lt;/code&gt; es solo para variables. Declara la variable como &lt;code&gt;register&lt;/code&gt; , dando al compilador una pista de que la variable debe colocarse en un registro de hardware para un acceso m&amp;aacute;s r&amp;aacute;pido. Sin embargo, los compiladores de C generalmente ignoran esto y por buenas razones: a menudo hacen un mejor trabajo sin &amp;eacute;l de todos modos.</target>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">La variable de &lt;code&gt;result&lt;/code&gt; ado ya est&amp;aacute; declarada impl&amp;iacute;citamente al comienzo de la funci&amp;oacute;n, por lo que declararla de nuevo con 'var result', por ejemplo, la sombrear&amp;iacute;a con una variable normal del mismo nombre. La variable de resultado tambi&amp;eacute;n ya est&amp;aacute; inicializada con el valor predeterminado del tipo. Tenga en cuenta que los tipos de datos referenciales ser&amp;aacute;n &lt;code&gt;nil&lt;/code&gt; al comienzo del procedimiento y, por lo tanto, pueden requerir una inicializaci&amp;oacute;n manual.</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; finaliza la ejecuci&amp;oacute;n del procedimiento actual. Solo est&amp;aacute; permitido en tr&amp;aacute;mites. Si hay un &lt;code&gt;expr&lt;/code&gt; , este es az&amp;uacute;car sint&amp;aacute;ctico para:</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">El comando &lt;code&gt;rst2tex&lt;/code&gt; se invoca de forma id&amp;eacute;ntica a &lt;code&gt;rst2html&lt;/code&gt; , pero genera un archivo .tex en lugar de .html.</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">El &lt;code&gt;scanp&lt;/code&gt; asigna el c&amp;oacute;digo gramatical al c&amp;oacute;digo Nim que realiza el an&amp;aacute;lisis. El an&amp;aacute;lisis se realiza con la ayuda de 3 plantillas auxiliares que se pueden implementar para un tipo personalizado.</target>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;code&gt;sets&lt;/code&gt; implementa un &lt;span id=&quot;hash-set_1&quot;&gt;conjunto de hash&lt;/span&gt; eficiente y un conjunto de hash ordenado.</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">El pragma &lt;code&gt;shallow&lt;/code&gt; afecta la sem&amp;aacute;ntica de un tipo: el compilador puede hacer una copia superficial. &amp;iexcl;Esto puede causar problemas sem&amp;aacute;nticos graves y romper la seguridad de la memoria! Sin embargo, puede acelerar las asignaciones considerablemente, porque la sem&amp;aacute;ntica de Nim requiere una copia profunda de secuencias y cadenas. Esto puede resultar caro, especialmente si se utilizan secuencias para construir una estructura de &amp;aacute;rbol:</target>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;strtabs&lt;/code&gt; implementa una tabla hash eficiente que es un mapeo de cadenas a cadenas. Admite un modo que distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas, y no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas y estilo Tambi&amp;eacute;n se proporciona un operador de sustituci&amp;oacute;n de cadenas eficiente &lt;code&gt;%&lt;/code&gt; para la tabla de cadenas.</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">El comando &lt;code&gt;sug&lt;/code&gt; Nimsuggest realiza una consulta sobre posibles s&amp;iacute;mbolos de finalizaci&amp;oacute;n en alg&amp;uacute;n punto del archivo.</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">El m&amp;oacute;dulo del &lt;code&gt;system&lt;/code&gt; contiene la parte del RTL que necesita soporte mediante la magia del compilador (y el material que necesita estar en &amp;eacute;l porque la especificaci&amp;oacute;n lo dice). El generador de c&amp;oacute;digo C genera el c&amp;oacute;digo C para &amp;eacute;l como cualquier otro m&amp;oacute;dulo. Sin embargo, el CCG inserta las llamadas a algunos procedimientos como &lt;code&gt;addInt&lt;/code&gt; . Por lo tanto, el m&amp;oacute;dulo &lt;code&gt;magicsys&lt;/code&gt; contiene una tabla ( &lt;code&gt;compilerprocs&lt;/code&gt; ) con todos los s&amp;iacute;mbolos que est&amp;aacute;n marcados como &lt;code&gt;compilerproc&lt;/code&gt; . &lt;code&gt;compilerprocs&lt;/code&gt; son necesarios para el generador de c&amp;oacute;digo. Un proceso &lt;code&gt;magic&lt;/code&gt; no es lo mismo que un proceso de &lt;code&gt;compilerproc&lt;/code&gt; : Un proceso &lt;code&gt;magic&lt;/code&gt; es un proceso que necesita magia de compilador para su comprobaci&amp;oacute;n sem&amp;aacute;ntica, un proceso de &lt;code&gt;compilerproc&lt;/code&gt; es un proceso que utiliza el generador de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">El m&amp;oacute;dulo del &lt;code&gt;system&lt;/code&gt; define el tipo &lt;a href=&quot;system#Natural&quot;&gt;natural&lt;/a&gt; importante como &lt;code&gt;range[0..high(int)]&lt;/code&gt; ( &lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; devuelve el valor m&amp;aacute;ximo). Otros lenguajes de programaci&amp;oacute;n pueden sugerir el uso de enteros sin signo para n&amp;uacute;meros naturales. Esto suele ser &lt;strong&gt;imprudente&lt;/strong&gt; : no desea aritm&amp;eacute;tica sin signo (que se envuelve) solo porque los n&amp;uacute;meros no pueden ser negativos. El tipo &lt;code&gt;Natural&lt;/code&gt; de Nim ayuda a evitar este error de programaci&amp;oacute;n com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;code&gt;tables&lt;/code&gt; implementa variantes de una &lt;span id=&quot;hash-table_1&quot;&gt;tabla hash&lt;/span&gt; eficiente (tambi&amp;eacute;n llamada &lt;span id=&quot;dictionary_1&quot;&gt;diccionario&lt;/span&gt; en otros lenguajes de programaci&amp;oacute;n) que es una asignaci&amp;oacute;n de claves a valores. &lt;code&gt;Table&lt;/code&gt; es la tabla hash habitual, &lt;code&gt;OrderedTable&lt;/code&gt; es como &lt;code&gt;Table&lt;/code&gt; pero recuerda el orden de inserci&amp;oacute;n y &lt;code&gt;CountTable&lt;/code&gt; es una asignaci&amp;oacute;n de una clave a su n&amp;uacute;mero de apariciones. Por coherencia con cualquier otro tipo de datos en Nim, estos tienen sem&amp;aacute;ntica de &lt;strong&gt;valor&lt;/strong&gt; , esto significa que &lt;code&gt;=&lt;/code&gt; realiza una copia de la tabla hash. Para la sem&amp;aacute;ntica de &lt;strong&gt;referencia,&lt;/strong&gt; use la variante &lt;code&gt;Ref&lt;/code&gt; : &lt;code&gt;TableRef&lt;/code&gt; , &lt;code&gt;OrderedTableRef&lt;/code&gt; , &lt;code&gt;CountTableRef&lt;/code&gt; . Para dar un ejemplo, cuando &lt;em&gt;a&lt;/em&gt; es una tabla, entonces &lt;em&gt;var b = a&lt;/em&gt; da &lt;em&gt;b&lt;/em&gt; como una nueva tabla independiente. b se inicializa con el contenido de &lt;em&gt;a&lt;/em&gt; . Cambiando &lt;em&gt;b&lt;/em&gt; no afecta a &lt;em&gt;una&lt;/em&gt; y viceversa:</target>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">El argumento de &lt;code&gt;timeout&lt;/code&gt; especifica el n&amp;uacute;mero m&amp;aacute;ximo de milisegundos que se bloquear&amp;aacute; la funci&amp;oacute;n si no hay eventos listos. Especificar un tiempo de espera de &lt;code&gt;-1&lt;/code&gt; hace que la funci&amp;oacute;n se bloquee indefinidamente.</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">El argumento de &lt;code&gt;timeout&lt;/code&gt; especifica el n&amp;uacute;mero m&amp;aacute;ximo de milisegundos que se bloquear&amp;aacute; la funci&amp;oacute;n si no hay eventos listos. Especificar un tiempo de espera de &lt;code&gt;-1&lt;/code&gt; hace que la funci&amp;oacute;n se bloquee indefinidamente. Todos los eventos disponibles se almacenar&amp;aacute;n en la matriz de &lt;code&gt;results&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;timeout&lt;/code&gt; especifica el tiempo en milisegundos para permitir que se realice la conexi&amp;oacute;n al servidor.</target>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">La declaraci&amp;oacute;n &lt;code&gt;try&lt;/code&gt; maneja excepciones:</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">El pragma &lt;code&gt;unchecked&lt;/code&gt; marcar se puede usar para marcar una matriz con nombre como &lt;code&gt;unchecked&lt;/code&gt; marcar, lo que significa que sus l&amp;iacute;mites no est&amp;aacute;n marcados. Esto suele ser &amp;uacute;til para implementar matrices personalizadas de tama&amp;ntilde;o flexible. Adem&amp;aacute;s, una matriz no marcada se traduce en una matriz C de tama&amp;ntilde;o indeterminado:</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">El pragma de &lt;code&gt;union&lt;/code&gt; se puede aplicar a cualquier tipo de &lt;code&gt;object&lt;/code&gt; . Significa que todos los campos del objeto se superponen en la memoria. Esto produce una &lt;code&gt;union&lt;/code&gt; lugar de una &lt;code&gt;struct&lt;/code&gt; en el c&amp;oacute;digo C / C ++ generado. Entonces, la declaraci&amp;oacute;n de objeto no debe usar herencia ni ninguna memoria GC, pero esto no est&amp;aacute; actualmente verificado.</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">El &lt;code&gt;unroll&lt;/code&gt; pragma se puede utilizar para indicar al compilador que debe desenrollar un &lt;span id=&quot;for_2&quot;&gt;para&lt;/span&gt; o &lt;span id=&quot;while_1&quot;&gt;mientras&lt;/span&gt; bucle para la eficiencia en tiempo de ejecuci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">El comando &lt;code&gt;use&lt;/code&gt; Nimsuggest enumera todos los usos del s&amp;iacute;mbolo en una posici&amp;oacute;n. Los IDE pueden usar esto para encontrar todos los lugares en el archivo donde se usa el s&amp;iacute;mbolo y ofrecer al usuario cambiar el nombre en todos los lugares al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">La secci&amp;oacute;n &lt;code&gt;using&lt;/code&gt; usa la misma sintaxis de agrupaci&amp;oacute;n basada en sangr&amp;iacute;a que una secci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; o &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated">El pragma &lt;code&gt;varargs&lt;/code&gt; se puede aplicar solo a procedimientos (y tipos de procedimientos). Le dice a Nim que el proceso puede tomar un n&amp;uacute;mero variable de par&amp;aacute;metros despu&amp;eacute;s del &amp;uacute;ltimo par&amp;aacute;metro especificado. Los valores de cadena Nim se convertir&amp;aacute;n a cadenas C autom&amp;aacute;ticamente:</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">El tipo &lt;code&gt;void&lt;/code&gt; denota la ausencia de cualquier tipo. Los par&amp;aacute;metros de tipo &lt;code&gt;void&lt;/code&gt; se tratan como inexistentes, &lt;code&gt;void&lt;/code&gt; como tipo de retorno significa que el procedimiento no devuelve un valor:</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;void&lt;/code&gt; solo es v&amp;aacute;lido para par&amp;aacute;metros y tipos de retorno; otros s&amp;iacute;mbolos no pueden tener el tipo &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated">El tipo &lt;code&gt;void&lt;/code&gt; es particularmente &amp;uacute;til para c&amp;oacute;digo gen&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">El pragma &lt;code&gt;volatile&lt;/code&gt; es solo para variables. Declara la variable como &lt;code&gt;volatile&lt;/code&gt; , sea lo que sea que eso signifique en C / C ++ (su sem&amp;aacute;ntica no est&amp;aacute; bien definida en C / C ++).</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated">El pragma de &lt;code&gt;warning&lt;/code&gt; se usa para que el compilador genere un mensaje de advertencia con el contenido dado. La compilaci&amp;oacute;n contin&amp;uacute;a despu&amp;eacute;s de la advertencia.</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;when&lt;/code&gt; habilita t&amp;eacute;cnicas de compilaci&amp;oacute;n condicional. Como extensi&amp;oacute;n sint&amp;aacute;ctica especial, la construcci&amp;oacute;n &lt;code&gt;when&lt;/code&gt; tambi&amp;eacute;n est&amp;aacute; disponible dentro de las definiciones de &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">La declaraci&amp;oacute;n &lt;code&gt;when&lt;/code&gt; es casi id&amp;eacute;ntica a la declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; con algunas excepciones:</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;when&lt;/code&gt; es casi id&amp;eacute;ntica a la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; , pero con estas diferencias:</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;when&lt;/code&gt; es &amp;uacute;til para escribir c&amp;oacute;digo espec&amp;iacute;fico de la plataforma, similar a la construcci&amp;oacute;n &lt;code&gt;#ifdef&lt;/code&gt; en el lenguaje de programaci&amp;oacute;n C.</target>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;while&lt;/code&gt; se ejecuta hasta que &lt;code&gt;expr&lt;/code&gt; se eval&amp;uacute;a como falso. Los bucles sin fin no son un error. &lt;code&gt;while&lt;/code&gt; sentencias while abren un &lt;em&gt;bloque impl&amp;iacute;cito&lt;/em&gt; , de modo que se pueden dejar con una sentencia &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; se utiliza en lugar de la declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; en iteradores. Solo es v&amp;aacute;lido en iteradores. La ejecuci&amp;oacute;n se devuelve al cuerpo del bucle for que llam&amp;oacute; al iterador. El rendimiento no finaliza el proceso de iteraci&amp;oacute;n, pero la ejecuci&amp;oacute;n se devuelve al iterador si comienza la siguiente iteraci&amp;oacute;n. Consulte la secci&amp;oacute;n sobre iteradores ( &lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;iteradores y la declaraci&amp;oacute;n&lt;/a&gt; for) para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">El operador &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">El &lt;code&gt;|&lt;/code&gt; operador</target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">El &lt;code&gt;|&lt;/code&gt; operador si se usa como operador infijo crea una elecci&amp;oacute;n ordenada:</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">El &lt;code&gt;|&lt;/code&gt; , los s&amp;iacute;mbolos &lt;code&gt;/&lt;/code&gt; se utilizan para marcar alternativas y tienen la precedencia m&amp;aacute;s baja. &lt;code&gt;/&lt;/code&gt; es la opci&amp;oacute;n ordenada que requiere que el analizador pruebe las alternativas en el orden dado. &lt;code&gt;/&lt;/code&gt; se usa a menudo para asegurar que la gram&amp;aacute;tica no sea ambigua.</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">El &lt;code&gt;~&lt;/code&gt; operador</target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">El operador &lt;code&gt;~&lt;/code&gt; es el operador &lt;strong&gt;no&lt;/strong&gt; en los patrones:</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">El operador &lt;em&gt;$&lt;/em&gt; para tablas de conteo.</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">El operador &lt;em&gt;$&lt;/em&gt; para tablas hash.</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">El operador &lt;em&gt;$&lt;/em&gt; para conjuntos int.</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">El operador &lt;em&gt;$&lt;/em&gt; para tablas hash ordenadas.</target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">El operador &lt;em&gt;$&lt;/em&gt; para tablas de cadenas.</target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">El operador &lt;em&gt;%&lt;/em&gt; para tablas de cadenas.</target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">El operador &lt;em&gt;==&lt;/em&gt; para tablas de conteo. Devuelve &lt;code&gt;true&lt;/code&gt; si ambas tablas contienen las mismas claves con el mismo recuento. Insertar orden no importa.</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">El operador &lt;em&gt;==&lt;/em&gt; para tablas de conteo. Devuelve &lt;code&gt;true&lt;/code&gt; si ambas tablas son &lt;code&gt;nil&lt;/code&gt; o ninguna es &lt;code&gt;nil&lt;/code&gt; y ambas contienen las mismas claves con el mismo recuento. Insertar orden no importa.</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">El operador &lt;em&gt;==&lt;/em&gt; para tablas hash. Devuelve &lt;code&gt;true&lt;/code&gt; si ambas tablas son &lt;code&gt;nil&lt;/code&gt; o ninguna es &lt;code&gt;nil&lt;/code&gt; y el contenido de ambas tablas contiene los mismos pares clave-valor. Insertar orden no importa.</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">El operador &lt;em&gt;==&lt;/em&gt; para tablas hash. Devuelve &lt;code&gt;true&lt;/code&gt; si el contenido de ambas tablas contiene los mismos pares clave-valor. Insertar orden no importa.</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">El operador &lt;em&gt;==&lt;/em&gt; para tablas hash ordenadas. Devuelve verdadero si tanto el contenido como el orden son iguales.</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">El operador &lt;em&gt;==&lt;/em&gt; para tablas hash ordenadas. Devuelve verdadero si ambas tablas son &lt;code&gt;nil&lt;/code&gt; o ninguna es &lt;code&gt;nil&lt;/code&gt; y el contenido y el orden de ambas son iguales.</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">El &lt;em&gt;compilador de Nim&lt;/em&gt; tambi&amp;eacute;n tiene soporte para archivos RST (reStructuredText) con los comandos &lt;code&gt;rst2html&lt;/code&gt; y &lt;code&gt;rst2tex&lt;/code&gt; . Documentos como este se escriben inicialmente en un dialecto de RST que agrega soporte para el resaltado de c&amp;oacute;digo fuente nim con el &lt;code&gt;.. code-block:: nim&lt;/code&gt; . &lt;code&gt;code-block&lt;/code&gt; tambi&amp;eacute;n admite el resaltado de C ++ y algunos otros lenguajes similares a c.</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">La &lt;em&gt;expresi&amp;oacute;n de caso&lt;/em&gt; es nuevamente muy similar a la declaraci&amp;oacute;n de caso:</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">El &lt;em&gt;tipo de car&amp;aacute;cter&lt;/em&gt; se llama &lt;code&gt;char&lt;/code&gt; . Su tama&amp;ntilde;o es siempre de un byte, por lo que no puede representar la mayor&amp;iacute;a de los caracteres UTF-8; pero &lt;em&gt;puede&lt;/em&gt; representar uno de los bytes que componen un car&amp;aacute;cter UTF-8 de varios bytes. La raz&amp;oacute;n de esto es la eficiencia: para la gran mayor&amp;iacute;a de los casos de uso, los programas resultantes seguir&amp;aacute;n manejando UTF-8 correctamente, ya que UTF-8 fue dise&amp;ntilde;ado especialmente para esto. Los literales de caracteres se incluyen entre comillas simples.</target>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;em&gt;nombre de archivo&lt;/em&gt; se utilizar&amp;aacute; para informar de errores y crear hiperv&amp;iacute;nculos de &amp;iacute;ndice al archivo, pero puede pasar una cadena vac&amp;iacute;a aqu&amp;iacute; si est&amp;aacute; analizando una secuencia en la memoria. Si el &lt;em&gt;nombre de archivo&lt;/em&gt; termina con la extensi&amp;oacute;n &lt;code&gt;.nim&lt;/code&gt; , el t&amp;iacute;tulo del documento se establecer&amp;aacute; de forma predeterminada en &lt;code&gt;Module filename&lt;/code&gt; . Este t&amp;iacute;tulo predeterminado puede ser anulado por el primero incorporado, pero ayuda a embellecer el &amp;iacute;ndice generado si no se encuentra ning&amp;uacute;n t&amp;iacute;tulo.</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">El par&amp;aacute;metro &lt;em&gt;handlers&lt;/em&gt; consta de bloques de c&amp;oacute;digo para &lt;em&gt;PegKinds&lt;/em&gt; , que definen los elementos gramaticales de inter&amp;eacute;s. Cada bloque puede contener c&amp;oacute;digo de controlador que se ejecutar&amp;aacute; cuando el analizador ingrese y deje texto que coincida con el elemento gramatical. Un controlador de &lt;em&gt;entrada&lt;/em&gt; puede acceder al nodo AST de PEG espec&amp;iacute;fico que se empareja como &lt;em&gt;p&lt;/em&gt; , toda la cadena analizada como &lt;em&gt;s&lt;/em&gt; y la posici&amp;oacute;n del segmento de texto coincidente en &lt;em&gt;s&lt;/em&gt; como &lt;em&gt;inicio&lt;/em&gt; . Un administrador de &lt;em&gt;permisos&lt;/em&gt; puede acceder a &lt;em&gt;p&lt;/em&gt; , &lt;em&gt;s&lt;/em&gt; , &lt;em&gt;inicio&lt;/em&gt; y tambi&amp;eacute;n a la longitud del segmento de texto coincidente como &lt;em&gt;longitud&lt;/em&gt; . Para un partido fallido, el&lt;em&gt;&lt;/em&gt;Se ejecutar&amp;aacute;n los controladores de &lt;em&gt;entrada&lt;/em&gt; y &lt;em&gt;salida&lt;/em&gt; , con la &lt;em&gt;longitud&lt;/em&gt; establecida en -1.</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">La &lt;em&gt;identificaci&amp;oacute;n&lt;/em&gt; se agregar&amp;aacute; con un car&amp;aacute;cter hash solo si su longitud no es cero; de lo contrario, no se generar&amp;aacute; un ancla espec&amp;iacute;fica. En general, solo debe pasar un valor de &lt;em&gt;identificaci&amp;oacute;n&lt;/em&gt; vac&amp;iacute;o para el t&amp;iacute;tulo de los primeros documentos independientes (son especiales para el proceso &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes ()&lt;/a&gt; , consulte &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Formato de archivo de &amp;iacute;ndice (idx)&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n). A diferencia de otros t&amp;eacute;rminos de &amp;iacute;ndice, las entradas de t&amp;iacute;tulo se insertan al principio del b&amp;uacute;fer acumulado para mantener un orden l&amp;oacute;gico de entradas.</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">El par&amp;aacute;metro &lt;em&gt;initialSize&lt;/em&gt; debe ser una potencia de dos. Puede usar &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()&lt;/a&gt; o &lt;em&gt;rightSize&lt;/em&gt; para garantizar eso en tiempo de ejecuci&amp;oacute;n. Todas las variables establecidas deben inicializarse antes de usarse con otros procesos de este m&amp;oacute;dulo con la excepci&amp;oacute;n de &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; y &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">El par&amp;aacute;metro &lt;em&gt;initialSize&lt;/em&gt; debe ser una potencia de dos. Puede usar &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()&lt;/a&gt; o &lt;em&gt;rightSize&lt;/em&gt; para garantizar eso en tiempo de ejecuci&amp;oacute;n. Todas las variables establecidas deben inicializarse antes de usarse con otros procesos de este m&amp;oacute;dulo con la excepci&amp;oacute;n de &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; y &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">El &lt;em&gt;alcance&lt;/em&gt; de una variable declarada en la parte de declaraci&amp;oacute;n de un bloque es v&amp;aacute;lido desde el punto de declaraci&amp;oacute;n hasta el final del bloque. Si un bloque contiene un segundo bloque, en el que se vuelve a declarar el identificador, dentro de este bloque, la segunda declaraci&amp;oacute;n ser&amp;aacute; v&amp;aacute;lida. Al salir del bloque interior, la primera declaraci&amp;oacute;n vuelve a ser v&amp;aacute;lida. Un identificador no se puede redefinir en el mismo bloque, excepto si es v&amp;aacute;lido para prop&amp;oacute;sitos de sobrecarga de iterador o procedimiento.</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">El ejemplo de &lt;em&gt;interfaz descuidada&lt;/em&gt; usa &lt;code&gt;.emit&lt;/code&gt; para producir &lt;code&gt;using namespace&lt;/code&gt; declaraciones de espacio de nombres . Por lo general, es mucho mejor referirse al nombre importado a trav&amp;eacute;s de la notaci&amp;oacute;n del &lt;code&gt;namespace::identifier&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">El car&amp;aacute;cter de &lt;span id=&quot;backslash_1&quot;&gt;barra invertida&lt;/span&gt; tiene varios usos. En primer lugar, si va seguido de un car&amp;aacute;cter no alfanum&amp;eacute;rico, elimina cualquier significado especial que pueda tener ese car&amp;aacute;cter. Este uso de barra invertida como car&amp;aacute;cter de escape se aplica tanto a clases de caracteres internos como externos.</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated">El comando de arranque &lt;span id=&quot;boot_1&quot;&gt;arranca&lt;/span&gt; el compilador y acepta diferentes opciones:</target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">El comando &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; crea las fuentes C para la instalaci&amp;oacute;n. Acepta las mismas opciones que pasar&amp;iacute;a al &lt;a href=&quot;#boot-command&quot;&gt;comando de arranque&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; es un mecanismo abstracto para iterar sobre los elementos de un contenedor. Depende de un &lt;span id=&quot;iterator_1&quot;&gt;iterador&lt;/span&gt; para hacerlo. Al igual &lt;code&gt;while&lt;/code&gt; declaraciones while , las declaraciones &lt;code&gt;for&lt;/code&gt; abren un &lt;span id=&quot;implicit-block_1&quot;&gt;bloque impl&amp;iacute;cito&lt;/span&gt; , de modo que se pueden dejar con una declaraci&amp;oacute;n &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">La anotaci&amp;oacute;n &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; se puede usar para marcar un proceso como gcsafe; de ​​lo contrario, el compilador infiere esta propiedad. Tenga en cuenta que &lt;code&gt;noSideEffect&lt;/code&gt; implica &lt;code&gt;gcsafe&lt;/code&gt; . La &amp;uacute;nica forma de crear un hilo es a trav&amp;eacute;s de &lt;code&gt;spawn&lt;/code&gt; o &lt;code&gt;createThread&lt;/code&gt; . &lt;code&gt;spawn&lt;/code&gt; suele ser el m&amp;eacute;todo preferible. De cualquier manera, el proceso invocado no debe usar par&amp;aacute;metros &lt;code&gt;var&lt;/code&gt; ni ninguno de sus par&amp;aacute;metros debe contener un tipo &lt;code&gt;ref&lt;/code&gt; o de &lt;code&gt;closure&lt;/code&gt; . Esto aplica la &lt;em&gt;restricci&amp;oacute;n de no compartir el mont&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">La opci&amp;oacute;n &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; habilita el modo de compilaci&amp;oacute;n especial donde los cambios en el c&amp;oacute;digo se pueden aplicar autom&amp;aacute;ticamente a un programa en ejecuci&amp;oacute;n. La recarga de c&amp;oacute;digo ocurre en la granularidad de un m&amp;oacute;dulo individual. Cuando se recarga un m&amp;oacute;dulo, Nim conservar&amp;aacute; el estado de todas las variables globales que se inicializan con una declaraci&amp;oacute;n de variable est&amp;aacute;ndar en el c&amp;oacute;digo. Todos los dem&amp;aacute;s c&amp;oacute;digos de nivel superior se ejecutar&amp;aacute;n repetidamente en cada recarga. Si desea evitar este comportamiento, puede proteger un bloque de c&amp;oacute;digo con la construcci&amp;oacute;n &lt;code&gt;once&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">El programa &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; es el script de mantenimiento de Nim. Es un reemplazo de las secuencias de comandos de creaci&amp;oacute;n y shell con la ventaja de que es mucho m&amp;aacute;s port&amp;aacute;til. La palabra &lt;em&gt;koch&lt;/em&gt; significa &lt;em&gt;cocinero&lt;/em&gt; en alem&amp;aacute;n. &lt;code&gt;koch&lt;/code&gt; se usa principalmente para construir el compilador de Nim, pero tambi&amp;eacute;n se puede usar para otras tareas. Este documento describe los comandos admitidos y sus opciones.</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">El directorio &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; se genera durante la compilaci&amp;oacute;n y contendr&amp;aacute; archivos temporales o finales dependiendo de su objetivo de backend. El nombre predeterminado para el directorio depende del backend utilizado y de su sistema operativo, pero puede usar el &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;compilador &lt;/a&gt;--nimcache para cambiarlo.</target>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">La expresi&amp;oacute;n de &lt;span id=&quot;parameter-constraint_1&quot;&gt;restricci&amp;oacute;n de par&amp;aacute;metro&lt;/span&gt; puede utilizar los operadores &lt;code&gt;|&lt;/code&gt; (o), &lt;code&gt;&amp;amp;&lt;/code&gt; (y) y &lt;code&gt;~&lt;/code&gt; (no) y los siguientes predicados:</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">Los pragmas &lt;span id=&quot;pushslashpop_1&quot;&gt;push / pop&lt;/span&gt; son muy similares a la directiva de opciones, pero se utilizan para anular la configuraci&amp;oacute;n temporalmente. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">La &lt;span id=&quot;slice_1&quot;&gt;rebanada&lt;/span&gt; del operador .. tiene prioridad sobre otras muestras que contienen un punto: {..} son los tres fichas {, ..,} y no los dos s&amp;iacute;mbolos {,..}.</target>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">El operador de &lt;span id=&quot;substitution_1&quot;&gt;sustituci&amp;oacute;n&lt;/span&gt; realiza sustituciones de cadenas en &lt;em&gt;formattr&lt;/em&gt; y devuelve un &lt;em&gt;formattr&lt;/em&gt; modificado . Esto a menudo se denomina &lt;span id=&quot;string-interpolation_1&quot;&gt;interpolaci&amp;oacute;n de cadenas&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">El operador de &lt;span id=&quot;substitution_2&quot;&gt;sustituci&amp;oacute;n&lt;/span&gt; realiza sustituciones de cadenas en &lt;em&gt;formattr&lt;/em&gt; y devuelve un &lt;em&gt;formattr&lt;/em&gt; modificado . Esto a menudo se denomina &lt;span id=&quot;string-interpolation_2&quot;&gt;interpolaci&amp;oacute;n de cadenas&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">El comando de &lt;span id=&quot;test_1&quot;&gt;prueba&lt;/span&gt; tambi&amp;eacute;n se puede invocar con las &lt;code&gt;tests&lt;/code&gt; alias . Este comando compilar&amp;aacute; y ejecutar&amp;aacute; &lt;code&gt;tests/testament/tester.nim&lt;/code&gt; , que es el controlador principal del conjunto de pruebas de Nim. Puede pasar opciones al comando de &lt;code&gt;test&lt;/code&gt; , se enviar&amp;aacute;n al probador. Consulte su c&amp;oacute;digo fuente para conocer las opciones disponibles.</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">El comando &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; convierte la documentaci&amp;oacute;n en el directorio &lt;code&gt;doc&lt;/code&gt; de primero a HTML. Tambi&amp;eacute;n repite la misma operaci&amp;oacute;n pero coloca el resultado en la &lt;code&gt;web/upload&lt;/code&gt; que se puede usar para actualizar el sitio web en &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">El par&amp;aacute;metro &lt;strong&gt;FILE&lt;/strong&gt; es suficiente para el an&amp;aacute;lisis est&amp;aacute;tico, pero los IDE tienden a tener &lt;em&gt;b&amp;uacute;feres no guardados&lt;/em&gt; en los que el usuario a&amp;uacute;n puede estar escribiendo una l&amp;iacute;nea. En tales situaciones, el IDE puede guardar el contenido actual en un archivo temporal y luego usar el interruptor &lt;code&gt;--trackDirty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">La API est&amp;aacute; dise&amp;ntilde;ada para ser &lt;strong&gt;f&amp;aacute;cil de usar&lt;/strong&gt; y coherente. La facilidad de uso se mide por el n&amp;uacute;mero de llamadas para lograr una acci&amp;oacute;n concreta de alto nivel.</target>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">La API debe adoptar la noci&amp;oacute;n de diferencia de AST: consulte el &lt;code&gt;macrocache&lt;/code&gt; del m&amp;oacute;dulo para obtener los detalles finales.</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated">La AST en Nim</target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">Los backends tipo C colocar&amp;aacute;n sus &lt;code&gt;.c&lt;/code&gt; temporales .c , &lt;code&gt;.cpp&lt;/code&gt; o &lt;code&gt;.m&lt;/code&gt; en el directorio &lt;code&gt;nimcache&lt;/code&gt; . El nombre de estos archivos sigue el patr&amp;oacute;n &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">Los objetivos en forma de C</target>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">La estructura de datos de CellSet</target>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">La configuraci&amp;oacute;n de DevkitPro debe ser la misma que la predeterminada con su nuevo instalador &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;aqu&amp;iacute; para Mac / Linux&lt;/a&gt; o &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;aqu&amp;iacute; para Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">El GC depende de una estructura de datos extremadamente eficiente para almacenar un conjunto de punteros; esto se denomina &lt;code&gt;TCellSet&lt;/code&gt; en el c&amp;oacute;digo fuente. La inserci&amp;oacute;n, eliminaci&amp;oacute;n y b&amp;uacute;squeda se realizan en un tiempo constante. Sin embargo, modificar un &lt;code&gt;TCellSet&lt;/code&gt; durante el recorrido conduce a un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">La GC sólo se activa en una operación de asignación de memoria.No se dispara con un temporizador y no se ejecuta en un hilo de fondo.</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">La forma de medir el tiempo del GC usa (ver &lt;code&gt;lib/system/timers.nim&lt;/code&gt; para la implementaci&amp;oacute;n):</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated">El recolector de basura</target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">Las excepciones de IEEE se ignoran en tiempo de ejecuci&amp;oacute;n o se asignan a las excepciones de Nim: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt; , &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt; , &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt; , &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt; y &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt; . Estas excepciones heredan de la clase base &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">La norma IEEE define cinco tipos de excepciones de punto flotante:</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">El objetivo es en realidad JS &lt;code&gt;node.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">El objetivo de JavaScript</target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">El destino de JavaScript no tiene m&amp;aacute;s consideraciones de interfaz, ya que tambi&amp;eacute;n tiene recolecci&amp;oacute;n de basura, pero los destinos de C requieren que inicialices los componentes internos de Nim, lo que se hace llamando a una funci&amp;oacute;n de &lt;code&gt;NimMain&lt;/code&gt; . Adem&amp;aacute;s, el c&amp;oacute;digo C requiere que especifique una declaraci&amp;oacute;n de avance para las funciones o el compilador asumir&amp;aacute; ciertos tipos para el valor de retorno y los par&amp;aacute;metros que probablemente har&amp;aacute;n que su programa se bloquee en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">El compilador de Nim y la mayor&amp;iacute;a de las partes de la biblioteca est&amp;aacute;ndar admiten un modo de contaminaci&amp;oacute;n. Las cadenas de entrada se declaran con el tipo de cadena &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; declarado en el m&amp;oacute;dulo del &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">El compilador de Nim puede generar un encabezado de interfaz C a trav&amp;eacute;s del &lt;code&gt;--header&lt;/code&gt; l&amp;iacute;nea de comando --header . El encabezado generado contendr&amp;aacute; todos los s&amp;iacute;mbolos exportados y el proceso de &lt;code&gt;NimMain&lt;/code&gt; al que debe llamar antes que cualquier otro c&amp;oacute;digo de Nim.</target>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">El compilador de Nim emite diferentes tipos de mensajes: &lt;span id=&quot;hint_1&quot;&gt;sugerencias&lt;/span&gt; , &lt;span id=&quot;warning_1&quot;&gt;advertencias&lt;/span&gt; y mensajes de &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; . Se emite un mensaje de &lt;em&gt;error&lt;/em&gt; si el compilador encuentra alg&amp;uacute;n error est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">El compilador Nim incluye un sencillo solucionador de ecuaciones lineales,que le permite inferir parámetros estáticos en algunas situaciones en las que la aritmética de los números enteros está involucrada.</target>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">El compilador de Nim admite principalmente dos familias de backend: los destinos C, C ++ y Objective-C y el destino JavaScript. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;Los objetivos similares a C&lt;/a&gt; crean archivos fuente que se pueden compilar en una biblioteca o en un ejecutable final. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;El destino de JavaScript&lt;/a&gt; puede generar un archivo &lt;code&gt;.js&lt;/code&gt; al que hace referencia desde un archivo HTML o crear un &lt;a href=&quot;http://nodejs.org&quot;&gt;programa nodejs independiente&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">El compilador Nim soporta filtros de código fuente como un simple pero poderoso sistema de plantillas incorporado.</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">El compilador Nim se encargar&amp;aacute; de la vinculaci&amp;oacute;n de los archivos de origen generados en el &lt;code&gt;nimcache&lt;/code&gt; directorio en el &lt;code&gt;libfib.nim.a&lt;/code&gt; biblioteca est&amp;aacute;tica, que luego se puede vincular en su programa C. Tenga en cuenta que estos comandos son gen&amp;eacute;ricos y variar&amp;aacute;n para cada sistema. Por ejemplo, en sistemas Linux probablemente necesitar&amp;aacute; usar &lt;code&gt;-ldl&lt;/code&gt; tambi&amp;eacute;n para vincular la funcionalidad dlopen requerida.</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">La biblioteca Nim hace un uso intensivo de la sobrecarga; una de las razones es que cada operador como &lt;code&gt;+&lt;/code&gt; es solo un proceso sobrecargado. El analizador le permite usar operadores en &lt;em&gt;notaci&amp;oacute;n infija&lt;/em&gt; ( &lt;code&gt;a + b&lt;/code&gt; ) o &lt;em&gt;notaci&amp;oacute;n prefijo&lt;/em&gt; ( &lt;code&gt;+ a&lt;/code&gt; ). Un operador infijo siempre recibe dos argumentos, un operador prefijo siempre uno. (Los operadores de sufijo no son posibles, porque esto ser&amp;iacute;a ambiguo: &amp;iquest; &lt;code&gt;a @ @ b&lt;/code&gt; significa &lt;code&gt;(a) @ (@b)&lt;/code&gt; o &lt;code&gt;(a@) @ (b)&lt;/code&gt; ? Siempre significa &lt;code&gt;(a) @ (@b)&lt;/code&gt; , porque no hay operadores de sufijo en Nim.)</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">El manual de Nim es un borrador que evolucionará en una especificación adecuada.</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">El lenguaje de programaci&amp;oacute;n Nim no tiene ning&amp;uacute;n concepto de los mecanismos de manejo de se&amp;ntilde;ales de Posix. Sin embargo, la biblioteca est&amp;aacute;ndar ofrece un soporte rudimentario para el manejo de se&amp;ntilde;ales, en particular, las fallas de segmentaci&amp;oacute;n se convierten en errores fatales que producen un seguimiento de pila. Esto se puede desactivar con el &lt;code&gt;-d:noSignalHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">La estructura del directorio del proyecto Nim es:</target>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar de Nim usa esta funci&amp;oacute;n en los elementos de las colecciones cuando produce una representaci&amp;oacute;n de cadena de una colecci&amp;oacute;n. Se recomienda utilizar esta funci&amp;oacute;n tambi&amp;eacute;n para las colecciones del lado del usuario. Los usuarios pueden sobrecargar &lt;em&gt;addQuoted&lt;/em&gt; para &lt;em&gt;tipos&lt;/em&gt; personalizados (similares a cadenas) si desean implementar una representaci&amp;oacute;n de elementos personalizada.</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">La primera parte del tutorial de Nim trata de lo básico.</target>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">La segunda parte del tutorial de Nim trata de las construcciones avanzadas del lenguaje.</target>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">El analizador PEG implementa esta gramática (escrita en la sintaxis PEG):</target>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated">La macro de &lt;code&gt;debug&lt;/code&gt; anterior se basa en el hecho de que &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; y &lt;code&gt;stdout&lt;/code&gt; se declaran en el m&amp;oacute;dulo del sistema y, por lo tanto, son visibles en el contexto de instanciaci&amp;oacute;n. Hay una forma de utilizar identificadores enlazados (tambi&amp;eacute;n conocidos como &lt;span id=&quot;symbols_1&quot;&gt;s&amp;iacute;mbolos&lt;/span&gt; ) en lugar de utilizar identificadores independientes. El &lt;code&gt;bindSym&lt;/code&gt; se puede utilizar para eso:</target>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">El c&amp;oacute;digo anterior produce un error con el mensaje de error misterioso que &lt;code&gt;i&lt;/code&gt; ya ha sido declarado. La raz&amp;oacute;n de esto es que los cuerpos &lt;code&gt;var i = ...&lt;/code&gt; necesitan ser verificados antes de pasarlos al par&amp;aacute;metro &lt;code&gt;body&lt;/code&gt; y la verificaci&amp;oacute;n de tipos en Nim implica b&amp;uacute;squedas de s&amp;iacute;mbolos. Para las operaciones de b&amp;uacute;squeda de s&amp;iacute;mbolos para tener &amp;eacute;xito &lt;code&gt;i&lt;/code&gt; necesita ser agregado a la (es decir, exterior) &amp;aacute;mbito actual. Despu&amp;eacute;s de comprobar el tipo, estas adiciones a la tabla de s&amp;iacute;mbolos no se deshacen (para bien o para mal). El mismo c&amp;oacute;digo funciona con &lt;code&gt;untyped&lt;/code&gt; ya que no es necesario verificar el tipo del cuerpo pasado:</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">El código anterior sale:</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">El ejemplo anterior fallar&amp;aacute;, para garantizar que c2nim &lt;em&gt;procese&lt;/em&gt; estas definiciones y las expanda, use la directiva #def de &lt;code&gt;#def&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">El m&amp;oacute;dulo anterior exporta &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;*&lt;/code&gt; , pero no &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">La salida anterior podría ser el resultado de un fragmento de código como:</target>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated">El acceso al campo &lt;code&gt;x.v&lt;/code&gt; est&amp;aacute; permitido ya que su guarda &lt;code&gt;x.L&lt;/code&gt; est&amp;aacute; activo. Despu&amp;eacute;s de la expansi&amp;oacute;n de la plantilla, esto equivale a:</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated">El operador de la dirección</target>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">El algoritmo para compilar los módulos es:</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">El algoritmo se basa en la teoría de las fracciones continuas.</target>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de cadenas siempre copia la cadena. El operador &lt;code&gt;&amp;amp;&lt;/code&gt; concatena cadenas.</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de cadenas copia la cadena. Puede usar el operador &lt;code&gt;&amp;amp;&lt;/code&gt; para concatenar cadenas y &lt;code&gt;add&lt;/code&gt; para agregar a una cadena.</target>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de tuplas copia cada componente. El operador de asignaci&amp;oacute;n predeterminado para objetos copia cada componente. La sobrecarga del operador de asignaci&amp;oacute;n se describe en &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;operador de operaciones vinculadas al tipo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de tuplas copia cada componente. La notaci&amp;oacute;n &lt;code&gt;t.field&lt;/code&gt; se usa para acceder al campo de una tupla. Otra notaci&amp;oacute;n es &lt;code&gt;t[i]&lt;/code&gt; para acceder al campo &lt;code&gt;i&lt;/code&gt; . Aqu&amp;iacute; &lt;code&gt;i&lt;/code&gt; debe ser un entero constante.</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">El operador de asignaci&amp;oacute;n debe estar asociado a un objeto o tipo &lt;code&gt;T&lt;/code&gt; diferenciado . Su firma tiene que ser &lt;code&gt;(var T, T)&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated">La declaración de asignación</target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">La declaración de asignación asigna un nuevo valor a una variable o,más generalmente,a un almacén:</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">El despachador de asíncrono implementa el patrón del proactor y también tiene una implementación del IOCP.Implementa el patrón proactor para otros sistemas operativos a través del módulo de selectores.Los futuros también se implementan aquí,y de hecho todos los procedimientos devuelven un futuro.</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">Los tipos de presentación de punto flotante disponibles son:</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">Los tipos de presentación de números enteros disponibles son:</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">El backend debe tener cierta l&amp;oacute;gica para que si el m&amp;oacute;dulo procesado actualmente es de la cach&amp;eacute; de compilaci&amp;oacute;n, no se acceda al campo &lt;code&gt;ast&lt;/code&gt; . En cambio, el C (++) generado para el cuerpo del s&amp;iacute;mbolo tambi&amp;eacute;n debe almacenarse en cach&amp;eacute; y volver a insertarse en el archivo C producido. Este enfoque parece abordar todos los problemas descritos anteriormente.</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">El tipo de base de la matriz no marcada puede no contener ninguna memoria GC'ed,pero actualmente no está marcada.</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">El algoritmo b&amp;aacute;sico es el &lt;em&gt;recuento de referencia diferido&lt;/em&gt; con detecci&amp;oacute;n de ciclos. Las referencias en la pila no se cuentan para un mejor rendimiento (y una generaci&amp;oacute;n de c&amp;oacute;digo C m&amp;aacute;s f&amp;aacute;cil). La detecci&amp;oacute;n del ciclo se realiza actualmente mediante un GC simple de marcado y barrido que tiene que escanear el mont&amp;oacute;n (mont&amp;oacute;n local de subprocesos) completo. &lt;code&gt;--gc:v2&lt;/code&gt; reemplaza esto con una marca y un barrido incrementales. Sin embargo, a&amp;uacute;n no est&amp;aacute; listo para la producci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">El algoritmo b&amp;aacute;sico es el &lt;em&gt;recuento de referencias diferidas&lt;/em&gt; con detecci&amp;oacute;n de ciclos. Las referencias en la pila no se cuentan para un mejor rendimiento y una generaci&amp;oacute;n de c&amp;oacute;digo C m&amp;aacute;s f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated">El operador binario &lt;code&gt;^*&lt;/code&gt; se utiliza como abreviatura de 0 o m&amp;aacute;s ocurrencias separadas por su segundo argumento; igualmente &lt;code&gt;^+&lt;/code&gt; significa 1 o m&amp;aacute;s ocurrencias: &lt;code&gt;a ^+ b&lt;/code&gt; es la abreviatura de &lt;code&gt;a (b a)*&lt;/code&gt; y &lt;code&gt;a ^* b&lt;/code&gt; es la abreviatura de &lt;code&gt;(a (b a)*)?&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">La declaraci&amp;oacute;n de bloque es un medio para agrupar declaraciones en un &lt;code&gt;block&lt;/code&gt; (con nombre) . Dentro del bloque, la declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; puede abandonar el bloque inmediatamente. Una declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; puede contener un nombre de un bloque circundante para especificar qu&amp;eacute; bloque debe salir.</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated">La &lt;em&gt;etiqueta&lt;/em&gt; del bloque ( &lt;code&gt;myblock&lt;/code&gt; en el ejemplo) es opcional.</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">El tipo booleano se denomina &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; en Nim y puede ser uno de los dos valores predefinidos &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; . Condiciones en &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elif&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; -enunciados deben ser de tipo &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated">El pragmatismo de los préstamos también puede utilizarse para anotar el tipo distinto para permitir que se levanten ciertas operaciones incorporadas:</target>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated">El proceso &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; incorporado devuelve la longitud de la matriz. &lt;a href=&quot;system#low&quot;&gt;low (a)&lt;/a&gt; devuelve el &amp;iacute;ndice v&amp;aacute;lido m&amp;aacute;s bajo para la matriz &lt;em&gt;a&lt;/em&gt; y &lt;a href=&quot;system#high&quot;&gt;high (a)&lt;/a&gt; el &amp;iacute;ndice v&amp;aacute;lido m&amp;aacute;s alto.</target>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;deepCopy&lt;/code&gt; incorporado puede incluso clonar cierres y sus entornos. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated">El orden interna &lt;code&gt;system.finished&lt;/code&gt; se puede utilizar para determinar si un iterador ha terminado su operaci&amp;oacute;n; no se genera ninguna excepci&amp;oacute;n en un intento de invocar un iterador que ya ha terminado su trabajo.</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">El generador de documentos incorporado &lt;code&gt;nim doc&lt;/code&gt; genera documentaci&amp;oacute;n HTML a partir de archivos fuente &lt;code&gt;.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">La devoluci&amp;oacute;n de llamada tambi&amp;eacute;n se llama cuando se completa el futuro. Por lo tanto, debe usar &lt;code&gt;finished&lt;/code&gt; para verificar si hay datos disponibles.</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">La devolución de la llamada debería devolver una de:</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">El carácter de caret (^)no se reconoce como un carácter de escape o delimitador.El carácter se maneja completamente por el analizador de línea de comandos en el sistema operativo antes de ser pasado a la matriz argv en el programa.</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">La declaración del caso puede tratar de números enteros,otros tipos ordinales y cuerdas.(Lo que es un tipo ordinal se explicará pronto.)Para números enteros u otros tipos ordinales también son posibles los rangos de valores:</target>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">La convenci&amp;oacute;n cdecl significa que un procedimiento utilizar&amp;aacute; la misma convenci&amp;oacute;n que el compilador de C. En Windows, el procedimiento C generado se declara con la palabra clave &lt;code&gt;__cdecl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">El carácter utilizado convencionalmente por el sistema operativo para separar los componentes del parche de búsqueda (como en PATH),como ':' para POSIX o ';' para Windows.</target>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">El tipo de car&amp;aacute;cter se denomina &lt;code&gt;char&lt;/code&gt; en Nim. Su tama&amp;ntilde;o es de un byte. Por lo tanto, no puede representar un car&amp;aacute;cter UTF-8, sino una parte de &amp;eacute;l. La raz&amp;oacute;n de esto es la eficiencia: para la gran mayor&amp;iacute;a de los casos de uso, los programas resultantes seguir&amp;aacute;n manejando UTF-8 correctamente, ya que UTF-8 fue dise&amp;ntilde;ado especialmente para esto. Otra raz&amp;oacute;n es que Nim puede admitir &lt;code&gt;array[char, int]&lt;/code&gt; o &lt;code&gt;set[char]&lt;/code&gt; eficiente ya que muchos algoritmos se basan en esta caracter&amp;iacute;stica. El tipo &lt;em&gt;Rune&lt;/em&gt; se utiliza para caracteres Unicode, puede representar cualquier car&amp;aacute;cter Unicode. &lt;code&gt;Rune&lt;/code&gt; se declara en el &lt;a href=&quot;unicode&quot;&gt;m&amp;oacute;dulo Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">El carácter utilizado por el sistema operativo para separar los componentes de la ruta,por ejemplo,'/' para POSIX o ':' para el clásico Macintosh.</target>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">El car&amp;aacute;cter que separa el nombre de archivo base de la extensi&amp;oacute;n; por ejemplo, el '.' en &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">La elección del estilo depende de ti.</target>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated">El &lt;code&gt;@#&lt;/code&gt; de cierre debe estar en una l&amp;iacute;nea propia, solo precedido por un espacio en blanco opcional. De esta forma, &lt;code&gt;@#&lt;/code&gt; puede ocurrir de otra manera en el c&amp;oacute;digo Nim como muestra el ejemplo.</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">El c&amp;oacute;digo contiene una declaraci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; confusa .</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">El código contiene una secuencia octal no soportada.</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">La función de reordenación del código puede reordenar implícitamente las definiciones de procedimientos,plantillas y macros,junto con las declaraciones e inicializaciones variables en el ámbito del nivel superior,de modo que,en gran medida,un programador no tenga que preocuparse de ordenar correctamente las definiciones o se vea obligado a utilizar declaraciones anticipadas para dar un prefacio a las definiciones dentro de un módulo.</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">El código utiliza un símbolo obsoleto.</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;type(x)&lt;/code&gt; coerci&amp;oacute;n (x) se puede utilizar para obtener el tipo de la expresi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; dada .</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">El recopilador comprueba si todav&amp;iacute;a queda tiempo para su trabajo despu&amp;eacute;s de cada iteraci&amp;oacute;n de &lt;code&gt;workPackage&lt;/code&gt; . Actualmente est&amp;aacute; establecido en 100, lo que significa que se atraviesan y liberan hasta 100 objetos antes de que vuelva a comprobarse. Por &lt;code&gt;workPackage&lt;/code&gt; tanto, workPackage afecta la granularidad del tiempo y es posible que deba ajustarse en entornos altamente especializados o para hardware m&amp;aacute;s antiguo.</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">La sintaxis de invocaci&amp;oacute;n de comandos tampoco puede tener expresiones complejas como argumentos. Por ejemplo: ( &lt;a href=&quot;#anonymous-procs&quot;&gt;procesos an&amp;oacute;nimos&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; o &lt;code&gt;try&lt;/code&gt; . La ( &lt;a href=&quot;#do-notation&quot;&gt;notaci&amp;oacute;n do&lt;/a&gt; ) es limitada, pero se puede usar para un solo proceso (ver el ejemplo en la secci&amp;oacute;n correspondiente). Las llamadas a funciones sin argumentos todav&amp;iacute;a necesitan () para distinguir entre una llamada y la funci&amp;oacute;n en s&amp;iacute; como un valor de primera clase.</target>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">Los comandos para compilar en C,C++o en Objetivo-C son:</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated">El delimitador de argumento com&amp;uacute;n &lt;code&gt;--&lt;/code&gt; sin opci&amp;oacute;n aparece como una clave de opci&amp;oacute;n larga de cadena vac&amp;iacute;a. &lt;code&gt;OptParser.cmd&lt;/code&gt; , &lt;code&gt;OptParser.pos&lt;/code&gt; y &lt;code&gt;os.parseCmdLine&lt;/code&gt; se pueden utilizar para completar el an&amp;aacute;lisis en ese caso.</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">Los operadores comunes &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; Est&amp;aacute;n definidos para flotantes y siguen el est&amp;aacute;ndar IEEE-754.</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">Los operadores comunes &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; Se definen para enteros. Los operadores &lt;code&gt;and or xor not&lt;/code&gt; tambi&amp;eacute;n se definen para n&amp;uacute;meros enteros y proporcionan operaciones &lt;em&gt;bit a bit&lt;/em&gt; . El cambio de bit a la izquierda se realiza con el &lt;code&gt;shl&lt;/code&gt; , el cambio a la derecha con el operador &lt;code&gt;shr&lt;/code&gt; . Los operadores de cambio de bits siempre tratan sus argumentos como &lt;em&gt;sin firmar&lt;/em&gt; . Para &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;cambios de bits aritm&amp;eacute;ticos,&lt;/span&gt; se puede utilizar la multiplicaci&amp;oacute;n o divisi&amp;oacute;n ordinaria.</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">El compilador comprueba que cada parámetro reciba exactamente un argumento.</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">El compilador verifica la sem&amp;aacute;ntica y produce c&amp;oacute;digo &lt;em&gt;solo&lt;/em&gt; para las declaraciones que pertenecen a la primera condici&amp;oacute;n que se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">Los comandos del compilador seleccionan el backend de destino, pero si es necesario, puede &lt;a href=&quot;nimc#cross-compilation&quot;&gt;especificar conmutadores adicionales para la compilaci&amp;oacute;n cruzada&lt;/a&gt; para seleccionar la CPU de destino, el sistema operativo o los comandos del compilador / enlazador.</target>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">El compilador depende del m&amp;oacute;dulo del sistema para funcionar correctamente y el m&amp;oacute;dulo del sistema depende del compilador. La mayor&amp;iacute;a de las rutinas enumeradas aqu&amp;iacute; usan magia de compilador especial. Cada m&amp;oacute;dulo importa impl&amp;iacute;citamente el m&amp;oacute;dulo del sistema; no debe incluirse expl&amp;iacute;citamente. Debido a esto, no puede haber un m&amp;oacute;dulo definido por el usuario llamado &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">El compilador se asegura de que cada ruta de código inicialice las variables que contienen punteros no nulos.Los detalles de este análisis aún deben ser especificados aquí.</target>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">El compilador genera código como si el programador hubiera escrito esto:</target>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">Es posible que el compilador no genere ning&amp;uacute;n c&amp;oacute;digo para la &lt;code&gt;assert&lt;/code&gt; si se recomienda hacerlo a trav&amp;eacute;s de los &lt;a href=&quot;nimc#command-line-switches&quot;&gt;modificadores de l&amp;iacute;nea de comandos &lt;/a&gt; &lt;code&gt;-d:release&lt;/code&gt; o &lt;code&gt;--assertions:off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">Es necesario indicar al compilador que genere C ++ (comando &lt;code&gt;cpp&lt;/code&gt; ) para que esto funcione. El s&amp;iacute;mbolo condicional &lt;code&gt;cpp&lt;/code&gt; se define cuando el compilador emite c&amp;oacute;digo C ++.</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">Es necesario indicar al compilador que genere Objective C (comando &lt;code&gt;objc&lt;/code&gt; ) para que esto funcione. El s&amp;iacute;mbolo condicional &lt;code&gt;objc&lt;/code&gt; se define cuando el compilador emite c&amp;oacute;digo Objective C.</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">El compilador ahora reescribe &lt;code&gt;x * 2&lt;/code&gt; como &lt;code&gt;x + x&lt;/code&gt; . El c&amp;oacute;digo dentro de los curlies es el patr&amp;oacute;n con el que comparar. Los operadores &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; tienen un significado especial en los patrones si est&amp;aacute;n escritos en notaci&amp;oacute;n infija, por lo que para hacer coincidir palabra por palabra con &lt;code&gt;*&lt;/code&gt; es necesario utilizar la sintaxis de llamada de funci&amp;oacute;n ordinaria.</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">El compilador optimiza las declaraciones de los casos de cadenas:Se utiliza un esquema hash para ellas si se utilizan varias constantes de cadena diferentes.Así que un código como este es razonablemente eficiente:</target>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated">El compilador genera un mensaje de sugerencia de que se puede &lt;code&gt;IOError&lt;/code&gt; . &lt;code&gt;OSError&lt;/code&gt; no aparece en la lista porque no se puede generar en la rama en la &lt;code&gt;effects&lt;/code&gt; aparece el pragma de efectos .</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">El compilador admite el operador &lt;code&gt;$&lt;/code&gt; para enumeraciones. El resultado de stringify se puede controlar dando expl&amp;iacute;citamente los valores de cadena para usar:</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">Luego, el compilador se asegura de que cada acceso a &lt;code&gt;gdata&lt;/code&gt; est&amp;eacute; dentro de una secci&amp;oacute;n de &lt;code&gt;locks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated">La arquitectura del compilador</target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">La función de error complementaria</target>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">El complier informará de cualquier fallo en la evaluación de la expresión o de un posible error de tipo.</target>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">El concepto es una coincidencia si:</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">Los tipos de concepto pueden ser paramétricos como los tipos genéricos normales:</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">La condici&amp;oacute;n en una declaraci&amp;oacute;n &lt;code&gt;do while(condition)&lt;/code&gt; debe ser &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">La cadena constante utilizada por el sistema operativo para referirse al directorio actual.</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">La cadena constante utilizada por el sistema operativo para referirse al directorio principal.</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">La restricción puede ser un tipo concreto o una clase de tipo.</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; construcci&amp;oacute;n &quot;&quot; &quot;literal de cadena&quot; &quot;&quot; tambi&amp;eacute;n existe. Es un atajo para el &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated">El &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; construcci&amp;oacute;n &quot;literal de cadena&quot; (sin espacios en blanco entre el identificador y las comillas de apertura) es un literal de cadena sin formato generalizado. Es un atajo para el &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt; construcci&amp;oacute;n (r &quot;literal de cadena&quot;) , por lo que denota una llamada a procedimiento con un literal de cadena sin formato como &amp;uacute;nico argumento. Los literales de cadena sin procesar generalizados son especialmente convenientes para incrustar mini lenguajes directamente en Nim (por ejemplo, expresiones regulares).</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">Los par&amp;aacute;metros contravariantes introducidos con el modificador &lt;code&gt;in&lt;/code&gt; son actualmente &amp;uacute;tiles solo cuando se interact&amp;uacute;a con tipos importados que tienen dicha sem&amp;aacute;ntica.</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">La relaci&amp;oacute;n convertible se puede relajar mediante un &lt;span id=&quot;converter_1&quot;&gt;convertidor de&lt;/span&gt; tipo definido por el usuario .</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">El &amp;aacute;rbol de bits cr&amp;iacute;ticos se puede utilizar como un mapeo de cadenas a alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; o como un conjunto de cadenas si &lt;code&gt;T&lt;/code&gt; es nulo.</target>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">La implementaci&amp;oacute;n actual plantea algunas restricciones para la evaluaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n: el c&amp;oacute;digo que contiene &lt;code&gt;cast&lt;/code&gt; o hace uso de la interfaz de funci&amp;oacute;n ajena no se puede evaluar en tiempo de compilaci&amp;oacute;n. Las versiones posteriores de Nim admitir&amp;aacute;n FFI en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">El colector de ciclos se puede activar / desactivar independientemente de las otras partes del GC con &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; y &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">La compilaci&amp;oacute;n predeterminada de un proyecto es una &lt;span id=&quot;debug-build_1&quot;&gt;compilaci&amp;oacute;n de depuraci&amp;oacute;n&lt;/span&gt; . Para compilar una &lt;span id=&quot;release-build_1&quot;&gt;versi&amp;oacute;n de lanzamiento,&lt;/span&gt; defina el s&amp;iacute;mbolo de &lt;code&gt;release&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">La convenci&amp;oacute;n de llamada predeterminada es &lt;code&gt;nimcall&lt;/code&gt; , a menos que sea un proceso interno (un proceso dentro de un proceso). Para un proceso interno se realiza un an&amp;aacute;lisis de si accede a su entorno. Si lo hace, tiene el &lt;code&gt;closure&lt;/code&gt; convenci&amp;oacute;n de llamada ; de lo contrario, tiene la convenci&amp;oacute;n de llamada &lt;code&gt;nimcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">El compilador predeterminado se define en la parte superior de &lt;code&gt;config\nim.cfg&lt;/code&gt; . El cambio de esta configuraci&amp;oacute;n afecta al compilador utilizado por &lt;code&gt;koch&lt;/code&gt; para (re) construir Nim.</target>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">La configuraci&amp;oacute;n predeterminada ( &lt;em&gt;recorte = verdadero&lt;/em&gt; y &lt;em&gt;precisi&amp;oacute;n = 10&lt;/em&gt; ) muestra la forma &lt;strong&gt;m&amp;aacute;s corta&lt;/strong&gt; que muestra el valor con precisi&amp;oacute;n (hasta un m&amp;aacute;ximo de 10 lugares decimales). Por ejemplo, 4.100000 se mostrar&amp;aacute; como 4.1 (que es matem&amp;aacute;ticamente id&amp;eacute;ntico) mientras que 4.1000003 se mostrar&amp;aacute; como 4.1000003.</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">El tipo flotante predeterminado es &lt;code&gt;float&lt;/code&gt; . En la implementaci&amp;oacute;n actual, &lt;code&gt;float&lt;/code&gt; es siempre de 64 bits.</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">El valor predeterminado para los s&amp;iacute;mbolos de &lt;code&gt;type&lt;/code&gt; de entidad , &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; es &lt;code&gt;gensym&lt;/code&gt; y para &lt;code&gt;proc&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;converter&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; es &lt;code&gt;inject&lt;/code&gt; . Sin embargo, si el nombre de la entidad se pasa como un par&amp;aacute;metro de plantilla, es un s&amp;iacute;mbolo inyectado:</target>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">El tipo de entero predeterminado es &lt;code&gt;int&lt;/code&gt; . Los literales enteros pueden tener un &lt;em&gt;sufijo de tipo&lt;/em&gt; para especificar un tipo de entero no predeterminado:</target>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="translated">La pragmática desaprobada se utiliza para marcar un símbolo como desaprobado:</target>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">La diferencia entre 1,0 y el número más pequeño mayor que 1,0 que puede ser representado en un tipo de punto flotante de 32 bits.</target>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">La diferencia entre 1,0 y el número más pequeño mayor que 1,0 que puede ser representado en un tipo de punto flotante de 64 bits.</target>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="translated">La diferencia entre &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; es: &lt;code&gt;let&lt;/code&gt; introduce una variable que no se puede reasignar, &lt;code&gt;const&lt;/code&gt; significa &quot;imponer la evaluaci&amp;oacute;n del tiempo de compilaci&amp;oacute;n y ponerla en una secci&amp;oacute;n de datos&quot;:</target>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="translated">La diferencia de dos conjuntos se representa matem&amp;aacute;ticamente como &lt;em&gt;AB&lt;/em&gt; y es el conjunto de todos los objetos que son miembros de &lt;em&gt;s1&lt;/em&gt; y no miembros de &lt;em&gt;s2&lt;/em&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">La diferencia con respecto al proceso &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; es que este proceso devuelve &lt;em&gt;verdadero&lt;/em&gt; si la &lt;em&gt;clave&lt;/em&gt; no estaba presente en &lt;em&gt;s&lt;/em&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">La diferencia con respecto al proceso &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; es que este proceso devuelve &lt;em&gt;verdadero&lt;/em&gt; si la &lt;em&gt;clave&lt;/em&gt; no estaba presente en &lt;em&gt;s&lt;/em&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">La diferencia con respecto al proceso &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; es que este proceso devuelve &lt;em&gt;verdadero&lt;/em&gt; si la &lt;em&gt;clave&lt;/em&gt; ya estaba presente en &lt;em&gt;s&lt;/em&gt; . El proceso devolver&amp;aacute; falso si la &lt;em&gt;clave&lt;/em&gt; se agreg&amp;oacute; como un nuevo valor a &lt;em&gt;s&lt;/em&gt; durante esta llamada. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">La diferencia con respecto al proceso &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; es que este proceso devuelve &lt;em&gt;verdadero&lt;/em&gt; si la &lt;em&gt;clave&lt;/em&gt; ya estaba presente en &lt;em&gt;s&lt;/em&gt; . El proceso devolver&amp;aacute; falso si la &lt;em&gt;clave&lt;/em&gt; se agreg&amp;oacute; como un nuevo valor a &lt;em&gt;s&lt;/em&gt; durante esta llamada. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="translated">A continuación se documentan las diferentes pautas de formato que se admiten.</target>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="translated">La incrustaci&amp;oacute;n directa de c&amp;oacute;digo ensamblador en c&amp;oacute;digo Nim es compatible con la instrucci&amp;oacute;n &lt;code&gt;asm&lt;/code&gt; insegura . Los identificadores en el c&amp;oacute;digo de ensamblador que se refieren a identificadores de Nim deben incluirse en un car&amp;aacute;cter especial que se puede especificar en los pragmas de la declaraci&amp;oacute;n. El car&amp;aacute;cter especial predeterminado es &lt;code&gt;'`'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="translated">El directorio puede contener varios subdirectorios que a&amp;uacute;n no existen. Se crea la ruta completa. Si esto falla, se &lt;em&gt;genera OSError&lt;/em&gt; . No &lt;strong&gt;, no&lt;/strong&gt; falla si el directorio ya existe porque para la mayor&amp;iacute;a de usos, esto no indica un error.</target>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="translated">El despachador act&amp;uacute;a como una especie de bucle de eventos. Debe llamar a la &lt;code&gt;poll&lt;/code&gt; (o una funci&amp;oacute;n que lo haga por usted, como &lt;code&gt;waitFor&lt;/code&gt; o &lt;code&gt;runForever&lt;/code&gt; ) para sondear cualquier evento pendiente. La implementaci&amp;oacute;n subyacente se basa en epoll en Linux, IO Completion Ports en Windows y select en otros sistemas operativos.</target>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="translated">La documentación consiste en varios documentos:</target>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">El generador de documentaci&amp;oacute;n conoce estos ejemplos y los considera parte del comentario &lt;code&gt;##&lt;/code&gt; doc. Como &amp;uacute;ltimo paso de la generaci&amp;oacute;n de documentaci&amp;oacute;n, los ejemplos se colocan en un archivo &lt;code&gt;$file_example.nim&lt;/code&gt; , se compilan y se prueban. Los ejemplos recopilados se colocan en su propio m&amp;oacute;dulo para garantizar que los ejemplos no se refieran a s&amp;iacute;mbolos no exportados.</target>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="translated">El sistema de efectos ( &lt;code&gt;raises: []&lt;/code&gt; ) no funciona con procedimientos as&amp;iacute;ncronos.</target>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">La &lt;a href=&quot;#procedures-discard-statement&quot;&gt;declaraci&amp;oacute;n de descarte&lt;/a&gt; vac&amp;iacute;a es una declaraci&amp;oacute;n de &lt;em&gt;no hacer nada&lt;/em&gt; . El compilador sabe que una declaraci&amp;oacute;n de caso con una parte else no puede fallar y, por lo tanto, el error desaparece. Tenga en cuenta que es imposible cubrir todos los valores de cadena posibles: es por eso que los casos de cadena siempre necesitan una rama &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">La notaci&amp;oacute;n de sub&amp;iacute;ndice vac&amp;iacute;a &lt;code&gt;[]&lt;/code&gt; se puede utilizar para &lt;em&gt;eliminar&lt;/em&gt; una referencia, es decir, recuperar el elemento al que apunta la referencia. El &lt;code&gt;.&lt;/code&gt; Los operadores (acceder a un operador de campo de tupla / objeto) y &lt;code&gt;[]&lt;/code&gt; ( operador de matriz / cadena / &amp;iacute;ndice de secuencia) realizan operaciones de desreferenciaci&amp;oacute;n impl&amp;iacute;citas para tipos de referencia:</target>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">La parte vac&amp;iacute;a &lt;code&gt;except&lt;/code&gt; o se ejecuta si hay una excepci&amp;oacute;n que no se enumera expl&amp;iacute;citamente. Es similar a una parte &lt;code&gt;else&lt;/code&gt; en declaraciones &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">La cl&amp;aacute;usula vac&amp;iacute;a &lt;span id=&quot;except_1&quot;&gt;excepto&lt;/span&gt; se ejecuta si hay una excepci&amp;oacute;n que no figura en otra lista. Es similar a una cl&amp;aacute;usula &lt;code&gt;else&lt;/code&gt; en declaraciones &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="translated">La tabla vac&amp;iacute;a se puede escribir &lt;code&gt;{:}&lt;/code&gt; (en contraste con el conjunto vac&amp;iacute;o que es &lt;code&gt;{}&lt;/code&gt; ) que es, por tanto, otra forma de escribir como el constructor de matriz vac&amp;iacute;a &lt;code&gt;[]&lt;/code&gt; . Esta forma un poco inusual de apoyar las mesas tiene muchas ventajas:</target>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="translated">La función de error</target>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="translated">El ejemplo también muestra que el cuerpo de un proc puede consistir en una sola expresión cuyo valor se devuelve entonces implícitamente.</target>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="translated">El ejemplo es tonto, ya que un vector se modela mejor con una tupla que ya proporciona acceso &lt;code&gt;v[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="translated">El ejemplo muestra un &amp;aacute;rbol binario gen&amp;eacute;rico. Dependiendo del contexto, los corchetes se utilizan para introducir par&amp;aacute;metros de tipo o para instanciar un proceso, iterador o tipo gen&amp;eacute;rico. Como muestra el ejemplo, los gen&amp;eacute;ricos funcionan con sobrecarga: se usa la mejor coincidencia de &lt;code&gt;add&lt;/code&gt; . El procedimiento de &lt;code&gt;add&lt;/code&gt; para secuencias no est&amp;aacute; oculto y se usa en el iterador de &lt;code&gt;preorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="translated">El ejemplo utiliza un bucle while para seguir preguntando a los usuarios por su nombre,siempre y cuando el usuario no teclee nada (sólo pulse RETURN).</target>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">La excepci&amp;oacute;n se &lt;em&gt;consume&lt;/em&gt; en una parte &lt;code&gt;except&lt;/code&gt; o . Si no se maneja una excepci&amp;oacute;n, se propaga a trav&amp;eacute;s de la pila de llamadas. Esto significa que a menudo el resto del procedimiento - que no est&amp;aacute; dentro de un &lt;code&gt;finally&lt;/code&gt; no se ejecuta (si se produce una excepci&amp;oacute;n) - cl&amp;aacute;usula.</target>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">La excepci&amp;oacute;n se &lt;em&gt;consume&lt;/em&gt; en un controlador de excepciones. Sin embargo, un controlador de excepciones puede generar otra excepci&amp;oacute;n. Si no se maneja la excepci&amp;oacute;n, se propaga a trav&amp;eacute;s de la pila de llamadas. Esto significa que a menudo el resto del procedimiento - que no est&amp;aacute; dentro de un &lt;code&gt;finally&lt;/code&gt; no se ejecuta (si se produce una excepci&amp;oacute;n) - cl&amp;aacute;usula.</target>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="translated">El seguimiento de excepciones es parte del &lt;span id=&quot;effect-system_1&quot;&gt;sistema de efectos&lt;/span&gt; de Nim . Hacer una excepci&amp;oacute;n es un &lt;em&gt;efecto&lt;/em&gt; . Tambi&amp;eacute;n se pueden definir otros efectos. Un efecto definido por el usuario es un medio para &lt;em&gt;etiquetar&lt;/em&gt; una rutina y realizar comprobaciones contra esta etiqueta:</target>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="translated">El &amp;aacute;rbol de excepciones se define en el m&amp;oacute;dulo del &lt;a href=&quot;system&quot;&gt;sistema&lt;/a&gt; . Cada excepci&amp;oacute;n hereda de &lt;code&gt;system.Exception&lt;/code&gt; . Las excepciones que indican errores de programaci&amp;oacute;n se heredan de &lt;code&gt;system.Defect&lt;/code&gt; (que es un subtipo de &lt;code&gt;Exception&lt;/code&gt; ) y, estrictamente hablando, no se pueden detectar, ya que tambi&amp;eacute;n se pueden asignar a una operaci&amp;oacute;n que finaliza todo el proceso. Las excepciones que indican cualquier otro error de tiempo de ejecuci&amp;oacute;n que pueda &lt;code&gt;system.CatchableError&lt;/code&gt; se heredan de system.CatchableError (que es un subtipo de &lt;code&gt;Exception&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="translated">La expresi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;x.f&lt;/code&gt; debe verificarse sem&amp;aacute;nticamente (lo que significa b&amp;uacute;squeda de s&amp;iacute;mbolos y verificaci&amp;oacute;n de tipo) antes de que se pueda decidir que debe reescribirse en &lt;code&gt;f(x)&lt;/code&gt; . Por lo tanto, la sintaxis de puntos tiene algunas limitaciones cuando se usa para invocar plantillas / macros:</target>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="translated">La extensi&amp;oacute;n significa que los comentarios que comienzan con &lt;em&gt;#&lt;/em&gt; y espacios en blanco se ignoran.</target>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="translated">Los identificadores de campo dentro de una tupla o definición de objeto son válidos en los siguientes lugares:</target>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="translated">El archivo &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demuestra c&amp;oacute;mo utilizar el analizador XML para realizar otra tarea sencilla: determinar todos los enlaces que contiene un documento HTML.</target>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="translated">El archivo &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demuestra c&amp;oacute;mo utilizar el analizador XML para realizar una tarea sencilla: determinar el t&amp;iacute;tulo de un documento HTML.</target>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="translated">La extensión de un archivo de guión.Por ejemplo:&quot;&quot; para POSIX,&quot;bat&quot; en Windows.</target>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="translated">La extensión del archivo de los ejecutables nativos.Por ejemplo:&quot;&quot; para POSIX,&quot;exe&quot; en Windows.</target>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="translated">El modo de archivo cuando se abre un archivo.</target>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="translated">El archivo en el que desea realizar la consulta. Por lo general, pasar&amp;aacute; el mismo valor que &lt;strong&gt;proj.nim&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="translated">El filtro transforma esto en:</target>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="translated">La última capa es la asíncrona espera la transformación.Esto le permite escribir código asíncrono en un estilo síncrono y funciona de manera similar a la espera de C#.La transformación funciona convirtiendo cualquier procedimiento de async en un iterador.</target>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">El primer comando ejecuta el compilador de Nim con tres opciones especiales para evitar generar una funci&amp;oacute;n &lt;code&gt;main()&lt;/code&gt; en los archivos generados, evitar vincular los archivos objeto en un binario final y generar expl&amp;iacute;citamente un archivo de encabezado para la integraci&amp;oacute;n de C. Todos los archivos generados se colocan en el directorio &lt;code&gt;nimcache&lt;/code&gt; . Es por eso que el siguiente comando compila la fuente &lt;code&gt;maths.c&lt;/code&gt; m&amp;aacute;s todos los archivos &lt;code&gt;.c&lt;/code&gt; de &lt;code&gt;nimcache&lt;/code&gt; . Adem&amp;aacute;s de esta ruta, tambi&amp;eacute;n debe indicarle al compilador de C d&amp;oacute;nde encontrar el archivo de encabezado &lt;code&gt;nimbase.h&lt;/code&gt; de Nim .</target>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="translated">La primera línea indica el archivo principal del proyecto.</target>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="translated">El primer programa</target>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="translated">Lo primero que hay que tener en cuenta es que todos los tipos llamables tienen al menos una coma,aunque no tengan ningún parámetro.Si hay parámetros,están representados por sus tipos y estarán separados por una coma.Al símbolo simple se le puede añadir un sufijo dependiendo del tipo de llamable:</target>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="translated">Lo primero que siempre necesitar&amp;aacute; hacer para comenzar a usar sockets es crear una nueva instancia del tipo &lt;code&gt;Socket&lt;/code&gt; usando el procedimiento &lt;code&gt;newSocket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="translated">La primera versi&amp;oacute;n usa &lt;em&gt;cmp&lt;/em&gt; para comparar los elementos. Los valores de retorno esperados son los mismos que los de system.cmp. La segunda versi&amp;oacute;n utiliza la funci&amp;oacute;n de comparaci&amp;oacute;n predeterminada &lt;em&gt;cmp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="translated">El siguiente código Nim:</target>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="translated">El siguiente algoritmo (en pseudoc&amp;oacute;digo) determina si dos tipos son iguales sin tener en cuenta los tipos &lt;code&gt;distinct&lt;/code&gt; . Por brevedad, se omite la verificaci&amp;oacute;n del ciclo con un conjunto auxiliar &lt;code&gt;s&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">Los siguientes procedimientos integrados no pueden ser sobrecargados por razones de simplicidad de implementación (requieren una verificación semántica especializada):</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">El siguiente código:</target>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="translated">Se dispone de los siguientes operadores de puntos:</target>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="translated">El siguiente ejemplo demuestra un simple servidor de chat.</target>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="translated">El siguiente ejemplo demuestra la carga de una función llamada &quot;greet&quot; de una biblioteca que se determina en tiempo de ejecución en base a una elección de idioma.Si la biblioteca no se carga o no se encuentra la función &quot;greet&quot;,se cierra con un código de error de fallo.</target>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="translated">El siguiente ejemplo demuestra el registro a tres manipuladores diferentes simultáneamente:</target>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="translated">El siguiente ejemplo implementa un poderoso comando de &lt;code&gt;debug&lt;/code&gt; que acepta un n&amp;uacute;mero variable de argumentos:</target>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="translated">El siguiente ejemplo esboza una macro que genera un analizador léxico a partir de expresiones regulares:</target>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="translated">El siguiente ejemplo muestra que se puede modelar un árbol binario genérico:</target>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="translated">El siguiente ejemplo muestra cómo puede aplicarse alguna forma de elevación:</target>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="translated">El siguiente ejemplo muestra cómo se puede llevar a cabo una evaluación parcial simple con la reescritura de los términos:</target>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="translated">Los siguientes ejemplos generar&amp;aacute;n documentaci&amp;oacute;n para el m&amp;oacute;dulo &lt;em&gt;Nim&lt;/em&gt; artificial a continuaci&amp;oacute;n , llamado acertadamente 'sample.nim'</target>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="translated">Los siguientes tipos de punto flotante están predefinidos:</target>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="translated">Las siguientes palabras clave están reservadas y no pueden utilizarse como identificadores:</target>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="translated">El siguiente código nim:</target>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="translated">Los siguientes párrafos son en su mayoría un recordatorio para mí mismo.Cosas para tener en cuenta:</target>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="translated">En la siguiente sección se definen varias relaciones sobre los tipos que se necesitan para describir la comprobación de tipos realizada por el compilador.</target>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="translated">En las siguientes secciones se define la salida esperada para cada tipo de símbolo para el que idetools devuelve una salida válida.</target>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="translated">En las siguientes secciones se describe el uso de cada uno de los metacaracteres.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">Las siguientes cuerdas denotan otras fichas:</target>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="translated">La cadena de formato para convertir un nombre de archivo en un archivo &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; (tambi&amp;eacute;n llamado &lt;span id=&quot;shared-object_1&quot;&gt;objeto compartido&lt;/span&gt; en algunos sistemas operativos).</target>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="translated">La cuarta columna será la cadena vacía si se está definiendo el iterador,ya que en ese punto del archivo el analizador no ha procesado aún la línea completa.La firma se devolverá completa en instancias posteriores del iterador.</target>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="translated">La cuarta columna será la cadena vacía si se está definiendo la macro,ya que en ese punto del archivo el analizador no ha procesado aún la línea completa.La firma será devuelta completa en instancias posteriores de la macro.</target>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="translated">La cuarta columna será la cadena vacía si se está definiendo el método,ya que en ese momento del archivo el analizador no ha procesado aún la línea completa.La firma se devolverá completa en instancias posteriores del método.</target>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="translated">La cuarta columna será la cadena vacía si se está definiendo el proc,ya que en ese punto del archivo el analizador no ha procesado aún la línea completa.La firma se devolverá completa en instancias posteriores del proc.</target>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="translated">La cuarta columna será la cadena vacía si se está definiendo la plantilla,ya que en ese momento del archivo el analizador no ha procesado aún la línea completa.La firma será devuelta completa en instancias posteriores de la plantilla.</target>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="translated">El cuarto uso de la barra invertida es para ciertas &lt;span id=&quot;simple-assertions_1&quot;&gt;afirmaciones simples&lt;/span&gt; . Una aserci&amp;oacute;n especifica una condici&amp;oacute;n que debe cumplirse en un punto particular de una coincidencia, sin consumir ning&amp;uacute;n car&amp;aacute;cter de la cadena de asunto. El uso de subpatrones para afirmaciones m&amp;aacute;s complicadas se describe a continuaci&amp;oacute;n. Las afirmaciones con barra invertida son:</target>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="translated">La parte fraccionaria de la duración,como una duración.</target>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="translated">El resultado completo se puede ver aqu&amp;iacute;: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt; . Se ejecuta despu&amp;eacute;s de la verificaci&amp;oacute;n sem&amp;aacute;ntica e incluye pragmas adjuntos impl&amp;iacute;citamente por el compilador.</target>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="translated">La funcionalidad implementada por &lt;code&gt;HttpClient&lt;/code&gt; y &lt;code&gt;AsyncHttpClient&lt;/code&gt; es la misma, por lo que puede usar la que m&amp;aacute;s le convenga en los ejemplos que se muestran aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="translated">La corriente futura se ha completado (esto significa que no se escribirán más datos).</target>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="translated">La función gamma</target>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="translated">La funci&amp;oacute;n gamma En &lt;strong&gt;desuso desde la versi&amp;oacute;n 0.19.0&lt;/strong&gt; : use &lt;code&gt;gamma&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="translated">La forma general de un especificador de formato estándar es:</target>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="translated">El c&amp;oacute;digo C generado no tendr&amp;aacute; ninguna convenci&amp;oacute;n de llamada expl&amp;iacute;cita y, por lo tanto, utilizar&amp;aacute; la convenci&amp;oacute;n de llamada predeterminada del compilador de C. Esto es necesario porque la convenci&amp;oacute;n de llamada predeterminada de Nim para procedimientos es &lt;code&gt;fastcall&lt;/code&gt; para mejorar la velocidad.</target>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="translated">El HTML generado para algunos de estos envoltorios es tan grande que no está contenido en la distribución.Entonces puedes encontrarlos en el sitio web.</target>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="translated">Los archivos generados que produce Nim van todos a un subdirectorio llamado &lt;code&gt;nimcache&lt;/code&gt; . Su camino completo es</target>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="translated">El &amp;iacute;ndice generado. &lt;strong&gt;&amp;Iacute;ndice + (Ctrl + F) == Alegr&amp;iacute;a&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="translated">La llamada al sistema getrlimit()tiene límites de recursos.</target>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="translated">&amp;iexcl;La buena noticia es que no ha cambiado mucho! Primero, necesitamos cambiar el manejo del par&amp;aacute;metro de entrada (l&amp;iacute;nea 3). En la versi&amp;oacute;n din&amp;aacute;mica, &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc recibe un par&amp;aacute;metro de cadena. Sin embargo, en la versi&amp;oacute;n de macro tambi&amp;eacute;n se declara como cadena, pero esta es la interfaz &lt;em&gt;externa&lt;/em&gt; de la macro. Cuando se ejecuta la macro, en realidad obtiene un objeto &lt;code&gt;PNimNode&lt;/code&gt; en lugar de una cadena, y tenemos que llamar a &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (l&amp;iacute;nea 5) desde el &lt;a href=&quot;macros&quot;&gt;m&amp;oacute;dulo de macros&lt;/a&gt; para obtener la cadena que se pasa a la macro.</target>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">El s&amp;iacute;mbolo de inicio de la gram&amp;aacute;tica es &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="translated">El programa de saludos consiste en 3 declaraciones que se ejecutan secuencialmente.Sólo los programas más primitivos pueden salirse con la suya:también se necesitan las ramificaciones y los bucles.</target>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="translated">El guardia no necesita ser de ningún tipo en particular.Es lo suficientemente flexible como para modelar mecanismos de bajo nivel sin cerraduras:</target>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">El manejo de una barra invertida seguida de un dígito distinto de 0 es complicado.Fuera de una clase de caracteres,PCRE lo lee y cualquier dígito siguiente como un número decimal.Si el número es inferior a 10,o si ha habido al menos tantos paréntesis izquierdos capturados anteriormente en la expresión,la secuencia completa se toma como referencia inversa.Una descripción de cómo funciona esto se da más adelante,después de la discusión de los subpatrones entre paréntesis.</target>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">La funci&amp;oacute;n de volcado de pila a&amp;uacute;n est&amp;aacute; en pa&amp;ntilde;ales, pero ya nos ha resultado &amp;uacute;til, por lo que podr&amp;iacute;a serle &amp;uacute;til. Para obtener un volcado de pila, compile con &lt;code&gt;-d:nimTypeNames&lt;/code&gt; y llame a &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; en un lugar estrat&amp;eacute;gico de su programa. Esto produce una lista de tipos usados ​​en su programa y para cada tipo la cantidad total de instancias de objetos para este tipo, as&amp;iacute; como la cantidad total de bytes que ocupan estas instancias. &amp;iexcl;Esta lista no est&amp;aacute; clasificada actualmente! Necesita usar pirater&amp;iacute;a de script de shell externo para ordenarlo.</target>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="translated">El nombre del cliente que hizo la solicitud.</target>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="translated">Las horas en un dígito si es posible,que van de 0 a 23.</target>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="translated">Las horas en un dígito si es posible.Va de la 1 a la 12.</target>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="translated">Las horas en dos dígitos siempre.El 0 está adelantado si la hora es de un dígito.</target>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="translated">Las horas en dos dígitos siempre.Si la hora es de un dígito,se prepara el 0.</target>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">Los identificadores que siguen a la palabra clave &lt;code&gt;concept&lt;/code&gt; representan instancias del tipo coincidente actualmente. Puede aplicar cualquiera de los modificadores de tipo est&amp;aacute;ndar, como &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; y &lt;code&gt;static&lt;/code&gt; para indicar un tipo de instancia m&amp;aacute;s espec&amp;iacute;fico. Tambi&amp;eacute;n puede aplicar el modificador de &lt;em&gt;tipo&lt;/em&gt; para crear una instancia con nombre del tipo en s&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="translated">El comando idetools puede ejecutarse como un servicio de compilación (CAAS),donde primero se lanza el compilador y se mantendrá en línea como un servidor,aceptando consultas de forma telnet.La ventaja de permanecer en línea es que para muchas consultas el compilador puede almacenar en caché los resultados de la compilación,y las consultas subsiguientes deben ser rápidas en el rango de milisegundos,siendo así lo suficientemente receptivo para los IDEs.</target>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="translated">La declaración &quot;si&quot; es una forma de ramificar el flujo de control:</target>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="translated">La unidad imaginaria. &amp;radic;-1.</target>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">El pragma inmediato est&amp;aacute; obsoleto. Consulte &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Par&amp;aacute;metros con tipo y sin tipo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">La implementación alinea los campos para un mejor rendimiento de acceso.La alineación es compatible con la forma en que lo hace el compilador C.</target>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="translated">En la actualidad,la aplicación ofrece las siguientes opciones posibles (pueden añadirse otras más adelante).</target>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="translated">La implementación del caché de compilación es difícil:Hay muchos problemas que resolver para el front y el backend.</target>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">La inicializaci&amp;oacute;n impl&amp;iacute;cita tambi&amp;eacute;n se puede prevenir mediante la &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; pragma tipo. El compilador requiere una inicializaci&amp;oacute;n expl&amp;iacute;cita para el objeto y todos sus campos. Sin embargo, realiza un &lt;span id=&quot;control-flow-analysis_1&quot;&gt;an&amp;aacute;lisis de flujo de control&lt;/span&gt; para demostrar que la variable se ha inicializado y no se basa en propiedades sint&amp;aacute;cticas:</target>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="translated">La inicializaci&amp;oacute;n impl&amp;iacute;cita se puede evitar por motivos de optimizaci&amp;oacute;n con el pragma &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="translated">El manejo de la indentación se realiza de la siguiente manera:El lexer anota la siguiente ficha con el número precedente de espacios;la indentación no es una ficha separada.Este truco permite el análisis de Nim con sólo 1 token de lookahead.</target>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="translated">Las herramientas de generaci&amp;oacute;n de &amp;iacute;ndices intentan diferenciar entre la documentaci&amp;oacute;n generada a partir de archivos &lt;code&gt;.nim&lt;/code&gt; y la documentaci&amp;oacute;n generada a partir de archivos &lt;code&gt;.txt&lt;/code&gt; o &lt;code&gt;.rst&lt;/code&gt; . Los primeros siempre est&amp;aacute;n estrechamente relacionados con el c&amp;oacute;digo fuente y consisten principalmente en entradas de API. Estos &amp;uacute;ltimos son documentos gen&amp;eacute;ricos destinados a la lectura humana.</target>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">El &amp;iacute;ndice no se escribir&amp;aacute; en el disco a menos que llame a &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile ()&lt;/a&gt; . El prop&amp;oacute;sito del &amp;iacute;ndice est&amp;aacute; documentado en la &lt;a href=&quot;docgen#index-switch&quot;&gt;gu&amp;iacute;a de herramientas de docgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">La inferencia para el seguimiento de lectura/escritura es análoga a la inferencia para el seguimiento de excepciones.</target>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">La inferencia para el rastreo de etiquetas es análoga a la inferencia para el rastreo de excepciones.</target>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">La convenci&amp;oacute;n en l&amp;iacute;nea significa que la persona que llama no debe llamar al procedimiento, sino en l&amp;iacute;nea su c&amp;oacute;digo directamente. Tenga en cuenta que Nim no est&amp;aacute; en l&amp;iacute;nea, pero deja esto al compilador de C; genera &lt;code&gt;__inline&lt;/code&gt; en l&amp;iacute;nea. Esto es solo una sugerencia para el compilador: puede ignorarlo por completo y puede incluir procedimientos en l&amp;iacute;nea que no est&amp;eacute;n marcados como en &lt;code&gt;inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="translated">La interacci&amp;oacute;n entre subprocesos y excepciones es simple: una excepci&amp;oacute;n &lt;em&gt;manejada&lt;/em&gt; en un subproceso no puede afectar a ning&amp;uacute;n otro subproceso. Sin embargo, una excepci&amp;oacute;n &lt;em&gt;no controlada&lt;/em&gt; en un hilo termina todo el &lt;em&gt;proceso&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="translated">Lo interesante es que nuestra macro no devuelve un objeto &lt;a href=&quot;tables#Table&quot;&gt;Table en&lt;/a&gt; tiempo de ejecuci&amp;oacute;n . En cambio, construye el c&amp;oacute;digo fuente de Nim en la variable &lt;code&gt;source&lt;/code&gt; . Para cada l&amp;iacute;nea del archivo de configuraci&amp;oacute;n se generar&amp;aacute; una variable &lt;code&gt;const&lt;/code&gt; ante (l&amp;iacute;nea 15). Para evitar conflictos, prefijamos estas variables con &lt;code&gt;cfg&lt;/code&gt; . En esencia, lo que est&amp;aacute; haciendo el compilador es reemplazar la l&amp;iacute;nea que llama a la macro con el siguiente fragmento de c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="translated">La documentación interna describe cómo se implementa el compilador.Lee esto si quieres hackear el compilador.</target>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="translated">La intersecci&amp;oacute;n de dos conjuntos se representa matem&amp;aacute;ticamente como &lt;em&gt;A &amp;cap; B&lt;/em&gt; y es el conjunto de todos los objetos que son miembros de &lt;em&gt;s1&lt;/em&gt; y &lt;em&gt;s2&lt;/em&gt; al mismo tiempo. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="translated">Las construcciones del lenguaje se explican utilizando un BNF extendido, en el que &lt;code&gt;(a)*&lt;/code&gt; significa 0 o m&amp;aacute;s &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a+&lt;/code&gt; significa 1 o m&amp;aacute;s &lt;code&gt;a&lt;/code&gt; , y &lt;code&gt;(a)?&lt;/code&gt; significa un opcional &lt;em&gt;a&lt;/em&gt; . Se pueden usar par&amp;eacute;ntesis para agrupar elementos.</target>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">El mayor número positivo que puede representarse en un tipo de punto flotante de 32 bits.</target>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">El mayor número positivo que puede representarse en un tipo de punto flotante de 64 bits.</target>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="translated">Los dos últimos dígitos del año.Al analizar,se asume el siglo actual.</target>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="translated">Los dos &amp;uacute;ltimos par&amp;aacute;metros especifican la ruta del archivo de certificado y la ruta del archivo de claves; lo m&amp;aacute;s probable es que un socket de servidor no funcione sin estos. Los certificados se pueden generar usando el siguiente comando: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="translated">La declaración de la licencia...</target>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="translated">La letra &quot;l&quot; no debe usarse como identificador.</target>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="translated">La biblioteca utiliza un esquema de denominación simple que utiliza abreviaturas comunes para que los nombres sean cortos pero significativos.</target>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">La biblioteca utiliza un esquema de nomenclatura simple que hace uso de abreviaturas comunes para mantener los nombres cortos pero significativos. Desde la versi&amp;oacute;n 0.8.2, muchos s&amp;iacute;mbolos han cambiado de nombre para adaptarse a este esquema. El objetivo final es que el programador pueda &lt;em&gt;adivinar&lt;/em&gt; un nombre.</target>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="translated">Los pragmas enumerados aquí pueden utilizarse para anular las opciones de generación de código para un proc/método/convertidor.</target>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="translated">El l&amp;iacute;mite inferior de una matriz o secuencia puede ser recibido por el proceso integrado &lt;code&gt;low()&lt;/code&gt; , el l&amp;iacute;mite superior por &lt;code&gt;high()&lt;/code&gt; . La longitud puede ser recibida por &lt;code&gt;len()&lt;/code&gt; . &lt;code&gt;low()&lt;/code&gt; para una secuencia o una matriz abierta siempre devuelve 0, ya que este es el primer &amp;iacute;ndice v&amp;aacute;lido. Se pueden agregar elementos a una secuencia con el proceso &lt;code&gt;add()&lt;/code&gt; o el operador &lt;code&gt;&amp;amp;&lt;/code&gt; , y eliminar (y obtener) el &amp;uacute;ltimo elemento de una secuencia con el proc &lt;code&gt;pop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="translated">La llamada macro se expande a:</target>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">El manual menciona que las &lt;a href=&quot;manual#cstring-type&quot;&gt;cadenas de Nim son impl&amp;iacute;citamente convertibles a cstrings, lo&lt;/a&gt; que hace que la interacci&amp;oacute;n generalmente sea indolora. La mayor&amp;iacute;a de las funciones de C que aceptan una cadena Nim convertida en una &lt;code&gt;cstring&lt;/code&gt; probablemente no necesitar&amp;aacute;n mantener esta cadena y, para cuando la devuelvan, la cadena ya no ser&amp;aacute; necesaria. Sin embargo, para los casos excepcionales en los que una cadena Nim debe conservarse y ponerse a disposici&amp;oacute;n del backend C como una &lt;code&gt;cstring&lt;/code&gt; , deber&amp;aacute; evitar manualmente que los datos de la cadena se liberen con &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; y &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="translated">Los operadores de puntos emparejados pueden ser símbolos de cualquier tipo llamable (procs,plantillas y macros),dependiendo del efecto deseado:</target>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="translated">La coincidencia de la AST debe ser una expresión de llamada/aplicación.</target>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="translated">La coincidencia de la AST debe ser un valor.</target>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="translated">La coincidencia de la AST debe tener un efecto secundario.</target>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="translated">La coincidencia de la AST no debe tener ningún efecto secundario.</target>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="translated">El AST coincidente debe tener el tipo especificado. (Ejemplo: &lt;code&gt;nkIfStmt&lt;/code&gt; denota una instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="translated">El emparejamiento se realiza después de que el compilador haya realizado algunas optimizaciones como el plegado constante,por lo que lo siguiente no funciona:</target>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="translated">El nodo coincidente no tiene hijos.</target>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="translated">El nodo coincidente es un literal como &quot;abc&quot;,12.</target>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="translated">El nodo coincidente debe ser un símbolo (un identificador de la unión).</target>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="translated">El nodo coincidente debe ser un identificador (un identificador no vinculado).</target>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="translated">La longitud máxima de contenido que se leerá para el cuerpo.</target>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">El valor m&amp;aacute;ximo de &lt;em&gt;x&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; necesita tener un operador &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="translated">El valor máximo de dos enteros.</target>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="translated">La sintaxis de la llamada al m&amp;eacute;todo entra en conflicto con las instancias gen&amp;eacute;ricas expl&amp;iacute;citas: &lt;code&gt;p[T](x)&lt;/code&gt; no se puede escribir como &lt;code&gt;x.p[T]&lt;/code&gt; porque &lt;code&gt;x.p[T]&lt;/code&gt; siempre se analiza como &lt;code&gt;(x.p)[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">El valor m&amp;iacute;nimo de &lt;em&gt;x&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; necesita tener un operador &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="translated">El valor mínimo de dos enteros.</target>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="translated">Los minutos en un dígito si es posible.</target>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="translated">El m&amp;oacute;dulo recurrir&amp;aacute; a procesos nim puros en caso de que el backend no sea compatible. Tambi&amp;eacute;n puede usar el indicador &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; para deshabilitar los intr&amp;iacute;nsecos del compilador.</target>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="translated">El mes en un dígito si es posible.</target>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="translated">El mes en dos dígitos siempre.El 0 está precedido.</target>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="translated">La razón más importante para la RTTI.La generación de procedimientos transversales produce un código mayor y es probable que sea más lento en el hardware moderno,ya que la vinculación de procedimientos dinámicos es difícil de predecir.</target>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="translated">La forma m&amp;aacute;s confiable de manejar las excepciones es usar &lt;code&gt;yield&lt;/code&gt; en un futuro y luego verificar la propiedad &lt;code&gt;failed&lt;/code&gt; del futuro . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="translated">La diferencia m&amp;aacute;s significativa entre estos comandos es que si busca en el directorio &lt;code&gt;nimcache&lt;/code&gt; encontrar&amp;aacute; &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; o &lt;code&gt;.m&lt;/code&gt; , aparte de que todos ellos producir&amp;aacute;n un binario nativo para su proyecto. Esto le permite tomar el c&amp;oacute;digo generado y colocarlo directamente en un proyecto utilizando cualquiera de estos lenguajes. A continuaci&amp;oacute;n, se muestran algunas invocaciones t&amp;iacute;picas de la l&amp;iacute;nea de comandos:</target>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="translated">El nombre de la zona horaria.</target>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n normal traer&amp;aacute; todos los s&amp;iacute;mbolos exportados. Estos pueden limitarse nombrando s&amp;iacute;mbolos que deben excluirse con el calificador &lt;code&gt;except&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="translated">El modo de operaci&amp;oacute;n normal se llama &lt;code&gt;ProcRun&lt;/code&gt; e implica iniciar un proceso para cada comando o consulta, similar a ejecutar manualmente el compilador de Nim desde la l&amp;iacute;nea de comandos. El modo &lt;code&gt;CaasRun&lt;/code&gt; inicia un proceso de servidor para responder a todas las consultas. Los desarrolladores de compiladores utilizan el modo &lt;code&gt;SymbolProcRun&lt;/code&gt; . Esto significa que ejecutar todas las pruebas implica procesar todos los archivos &lt;code&gt;*.txt&lt;/code&gt; tres veces, lo que puede llevar bastante tiempo.</target>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;x[i]&lt;/code&gt; se puede utilizar para acceder al i-&amp;eacute;simo elemento de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;x[i]&lt;/code&gt; se usa para acceder al i-&amp;eacute;simo elemento de &lt;code&gt;x&lt;/code&gt; . El acceso a la matriz siempre se comprueba por l&amp;iacute;mites (en tiempo de compilaci&amp;oacute;n o en tiempo de ejecuci&amp;oacute;n). Estas comprobaciones pueden desactivarse mediante pragmas o invocando el compilador con el &lt;code&gt;--bound_checks:off&lt;/code&gt; l&amp;iacute;nea de comandos --bound_checks: off .</target>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="translated">La notación utilizada para un PEG es similar a la del EBNF:</target>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="translated">El número de bytes que pertenecen a &quot;s[i]&quot; incluyendo los siguientes caracteres de combinación.</target>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">Los n&amp;uacute;meros cuentan el n&amp;uacute;mero de objetos en todos los montones de GC, se refieren a todos los subprocesos en ejecuci&amp;oacute;n, no solo al subproceso actual. (El hilo actual ser&amp;iacute;a el hilo que llama a &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; ). Esto podr&amp;iacute;a cambiar en versiones posteriores.</target>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="translated">El identificador numérico es sólo un número al azar.El número se asigna según la sección y la posición del símbolo en el archivo que se está procesando y no se debe confiar en que sea constante:si se añade o se quita un símbolo,los números pueden mezclarse.</target>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="translated">El uso ocasional de idetools es aceptable para cosas como las definiciones,donde el usuario pone el cursor en un símbolo o hace doble clic en él y después de uno o dos segundos el IDE muestra dónde está definido ese símbolo.Tales latencias serían terribles para características como la sugerencia de símbolos,además,¿por qué esperar si podemos evitarlo?</target>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="translated">El &amp;uacute;nico caso en el que las cosas no son tan f&amp;aacute;ciles es cuando el recolector de basura necesita algunos ajustes del ensamblador para funcionar. La versi&amp;oacute;n est&amp;aacute;ndar del GC usa la funci&amp;oacute;n &lt;code&gt;setjmp&lt;/code&gt; de C para almacenar todos los registros en la pila de hardware. Puede ser necesario que la nueva plataforma deba reemplazar este c&amp;oacute;digo gen&amp;eacute;rico por alg&amp;uacute;n c&amp;oacute;digo ensamblador.</target>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="translated">La &amp;uacute;nica diferencia entre el contenido de ese archivo y los valores proporcionados por este proceso es la variable &lt;code&gt;doc.file&lt;/code&gt; . La variable &lt;code&gt;doc.file&lt;/code&gt; del archivo de configuraci&amp;oacute;n contiene HTML para crear p&amp;aacute;ginas independientes, mientras que este proceso devuelve solo el contenido de &lt;code&gt;rstToHtml&lt;/code&gt; como rstToHtml para generar el HTML m&amp;iacute;nimo.</target>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="translated">Las &amp;uacute;nicas operaciones que se ven afectadas por el pragma &lt;code&gt;floatChecks&lt;/code&gt; son los operadores &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; para los tipos de coma flotante.</target>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="translated">El tipo de openarray no puede anidarse:los openarrays multidimensionales no se soportan porque rara vez se necesitan y no se pueden hacer de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="translated">La operaci&amp;oacute;n se realiza de forma at&amp;oacute;mica y otras operaciones en la tabla se bloquear&amp;aacute;n mientras se invoca el &lt;code&gt;mapper&lt;/code&gt; , por lo que debe ser breve y simple.</target>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="translated">La operaci&amp;oacute;n produjo un resultado que no se puede representar con precisi&amp;oacute;n infinita, por ejemplo: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="translated">La operación produjo un resultado que excede el rango del exponente.</target>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="translated">La operación produjo un resultado demasiado pequeño para ser representado como un número normal.</target>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="translated">La precedencia del operador está determinada por su primer carácter.Los detalles se pueden encontrar en el manual.</target>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="translated">Los operadores &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; tienen un significado especial en los patrones si est&amp;aacute;n escritos en notaci&amp;oacute;n infija.</target>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="translated">Los operadores &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; est&amp;aacute;n definidos para el tipo bool. El &lt;code&gt;and&lt;/code&gt; y &lt;code&gt;or&lt;/code&gt; los operadores de realizar la evaluaci&amp;oacute;n de cortocircuito. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="translated">Los operadores &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; est&amp;aacute;n definidos para el tipo bool. El &lt;code&gt;and&lt;/code&gt; y &lt;code&gt;or&lt;/code&gt; Los operadores realizan la evaluaci&amp;oacute;n de acceso directo. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="translated">El carácter opcional de &quot;relleno&quot; define el carácter que se utilizará para rellenar el campo hasta el ancho mínimo.El carácter de relleno,si está presente,debe ir seguido de una bandera de alineación.</target>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="translated">La bandera de alineación opcional puede ser una de las siguientes:</target>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="translated">El orden de los pares (clave, valor) se conserva, por lo que es f&amp;aacute;cil admitir dictados ordenados con, por ejemplo, &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="translated">El orden de los reemplazos sí importa.Los reemplazos anteriores son preferibles a los posteriores en la lista de argumentos.</target>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="translated">Entonces no se puede acceder al nombre del m&amp;oacute;dulo original. Las notaciones &lt;code&gt;path/to/module&lt;/code&gt; o &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; se pueden utilizar para hacer referencia a un m&amp;oacute;dulo en subdirectorios:</target>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="translated">La cadena original se devuelve si el &lt;em&gt;ancho&lt;/em&gt; es menor o igual que &lt;em&gt;s.len&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="translated">La otra razón es que el archivo sucio puede aparecer en cualquier lugar del disco (por ejemplo,en tmpfs),pero debe tratarse como si tuviera una ruta que coincida con el módulo original cuando se trata del uso de rutas relativas,etc.Las consultas,sin embargo,se referirán al nombre del módulo sucio en sus respuestas en lugar del nombre del archivo normal.</target>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="translated">La salida para HTML y LaTeX proviene de los archivos de configuraci&amp;oacute;n &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; y &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; . Puede agregar y modificar estos archivos a su proyecto para cambiar el aspecto de la salida de docgen.</target>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="translated">La salida es el doble de la entrada. No se genera ning&amp;uacute;n prefijo como &lt;code&gt;0x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="translated">La verbosidad de salida de las pruebas.</target>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">La declaraci&amp;oacute;n paralela es el mecanismo preferido para introducir paralelismo en un programa Nim. Un subconjunto del lenguaje Nim es v&amp;aacute;lido dentro de una secci&amp;oacute;n &lt;code&gt;parallel&lt;/code&gt; . Se verifica que este subconjunto est&amp;eacute; libre de carreras de datos en el momento de la compilaci&amp;oacute;n. &amp;iexcl;Un &lt;span id=&quot;disjoint-checker_1&quot;&gt;verificador disjunto&lt;/span&gt; sofisticado asegura que no sean posibles carreras de datos a pesar de que la memoria compartida es ampliamente compatible!</target>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="translated">Tipos de los par&amp;aacute;metros pueden ser tipos ordinarios o los tipos meta &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; o &lt;code&gt;type&lt;/code&gt; . &lt;code&gt;type&lt;/code&gt; sugiere que solo se puede proporcionar un s&amp;iacute;mbolo de tipo como argumento, y sin &lt;code&gt;untyped&lt;/code&gt; significa que las b&amp;uacute;squedas de s&amp;iacute;mbolos y la resoluci&amp;oacute;n de tipos no se realizan antes de que la expresi&amp;oacute;n se pase a la plantilla.</target>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">El analizador utiliza una pila de niveles de sangr&amp;iacute;a: la pila consta de n&amp;uacute;meros enteros que cuentan los espacios. La informaci&amp;oacute;n de sangr&amp;iacute;a se consulta en lugares estrat&amp;eacute;gicos del analizador, pero se ignora de lo contrario: el pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denota una sangr&amp;iacute;a que consta de m&amp;aacute;s espacios que la entrada en la parte superior de la pila; &lt;code&gt;IND{=}&lt;/code&gt; una sangr&amp;iacute;a que tiene el mismo n&amp;uacute;mero de espacios. &lt;code&gt;DED&lt;/code&gt; es otro pseudo terminal que describe la &lt;em&gt;acci&amp;oacute;n&lt;/em&gt; de sacar un valor de la pila, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; luego implica empujar a la pila.</target>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="translated">&lt;strong&gt;Actualmente&lt;/strong&gt; , el an&amp;aacute;lisis de la ruta no es &lt;strong&gt;s&amp;oacute;lido&lt;/strong&gt; , pero eso no lo hace in&amp;uacute;til. Dos rutas se consideran equivalentes si son sint&amp;aacute;cticamente iguales.</target>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="translated">El nombre simple de un símbolo es una versión simplificada de su firma totalmente exportada.Las variables o constantes tienen el mismo símbolo de nombre simple que su nombre complejo.El nombre simple de los procedimientos,plantillas y otros tipos llamables será su valor no cotizado después de eliminar los parámetros,tipos de retorno y pragmas.El nombre sencillo permite un enlace corto y agradable de los símbolos que funciona a menos que tengas un módulo con colisiones debido a la sobrecarga.</target>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="translated">La porci&amp;oacute;n igualada por &lt;code&gt;sep&lt;/code&gt; no se devuelve.</target>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="translated">Los pragmas listados aquí pueden ser usados para aceptar opcionalmente valores de la opción -d/--definir en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="translated">El problema aqu&amp;iacute; es que el compilador ya decidi&amp;oacute; que &lt;code&gt;something()&lt;/code&gt; como iterador no se puede llamar en este contexto antes de que &lt;code&gt;toSeq&lt;/code&gt; tenga la oportunidad de convertirlo en una secuencia.</target>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="translated">El proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; se llama impl&amp;iacute;citamente cuando su programa nim finaliza sin incidentes para plataformas donde este es el comportamiento esperado. Una excepci&amp;oacute;n no controlada &lt;code&gt;quit(QuitFailure)&lt;/code&gt; es equivalente a llamar a quit (QuitFailure) .</target>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="translated">El objetivo del proceso es analizar el encabezado de las cookies de un cliente,no el encabezado &quot;Set-Cookie&quot; de los servidores.</target>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="translated">El procedimiento ha sido dise&amp;ntilde;ado para que su salida se pueda utilizar para muchas sintaxis comunes diferentes. &lt;strong&gt;Nota&lt;/strong&gt; : &amp;iexcl;Esto no es correcto para producir c&amp;oacute;digo Ansi C!</target>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="translated">El progreso de la carga de un archivo o de la descarga de un archivo se puede verificar especificando un procedimiento &lt;code&gt;onProgressChanged&lt;/code&gt; en los procedimientos de &lt;code&gt;store&lt;/code&gt; o &lt;code&gt;retrFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="translated">El proyecto utiliza un archivo de configuración obsoleto.</target>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="translated">La raz&amp;oacute;n es que el compilador ya transform&amp;oacute; el 1 en &quot;1&quot; para la declaraci&amp;oacute;n de &lt;code&gt;echo&lt;/code&gt; . Sin embargo, una macro de reescritura de t&amp;eacute;rminos no deber&amp;iacute;a cambiar la sem&amp;aacute;ntica de todos modos. De hecho, pueden desactivarse con la &lt;code&gt;--patterns:off&lt;/code&gt; l&amp;iacute;nea de comandos o temporalmente con el pragma de &lt;code&gt;patterns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="translated">La reimplementaci&amp;oacute;n de este c&amp;oacute;digo como un proceso de tiempo de compilaci&amp;oacute;n nos permitir&amp;aacute; deshacernos del archivo &lt;code&gt;data.cfg&lt;/code&gt; que necesitar&amp;iacute;amos distribuir a lo largo del binario, adem&amp;aacute;s si la informaci&amp;oacute;n es realmente constante, no lo hace desde un punto de vista l&amp;oacute;gico. para tenerlo &lt;em&gt;mutable&lt;/em&gt; en una variable global, ser&amp;iacute;a mejor si fuera una constante. Finalmente, y probablemente la caracter&amp;iacute;stica m&amp;aacute;s valiosa, podemos implementar alguna verificaci&amp;oacute;n en el momento de la compilaci&amp;oacute;n. Podr&amp;iacute;a pensar en esto como una &lt;em&gt;mejor prueba unitaria&lt;/em&gt; , ya que es imposible obtener un binario a menos que todo est&amp;eacute; correcto, lo que le impide enviar a los usuarios un programa roto que no se inicia porque falta un peque&amp;ntilde;o archivo cr&amp;iacute;tico o su contenido ha cambiado por error a algo inv&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="translated">La relaci&amp;oacute;n entre el tipo y el sufijo se realiza mediante proc &lt;code&gt;complexName&lt;/code&gt; en el archivo &lt;code&gt;compiler/docgen.nim&lt;/code&gt; . A continuaci&amp;oacute;n se muestran algunos ejemplos de nombres complejos para s&amp;iacute;mbolos en el &lt;a href=&quot;system&quot;&gt;m&amp;oacute;dulo del sistema&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="translated">La eliminación de los archivos existentes.</target>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="translated">El filtro de reemplazo reemplaza las subcadenas en cada línea.</target>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="translated">La representaci&amp;oacute;n de la expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; es sutil, pero f&amp;aacute;cil de recorrer.</target>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="translated">La representaci&amp;oacute;n de la declaraci&amp;oacute;n if es sutil, pero f&amp;aacute;cil de recorrer. Si no hay &lt;code&gt;else&lt;/code&gt; rama, no existe ning&amp;uacute;n hijo &lt;code&gt;nnkElse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="translated">El flujo corporal de la respuesta se lee de forma sincronizada.</target>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="translated">El resto de la l&amp;iacute;nea se trata como una &lt;a href=&quot;re&quot;&gt;expresi&amp;oacute;n regular&lt;/a&gt; , as&amp;iacute; que tenga cuidado al escapar de los metacaracteres como los par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="translated">El enchufe del cliente resultante se registra automáticamente en el despachador.</target>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="translated">El cliente resultante heredará cualquier propiedad del socket del servidor.Por ejemplo:si el socket está almacenado en un buffer o no.</target>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">La cadena resultante siempre tiene &lt;em&gt;len&lt;/em&gt; caracteres. No se genera ning&amp;uacute;n prefijo &lt;code&gt;0b&lt;/code&gt; inicial .</target>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">La cadena resultante siempre tiene &lt;em&gt;len&lt;/em&gt; caracteres. No se genera ning&amp;uacute;n prefijo &lt;code&gt;0o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="translated">La cadena resultante tiene el &lt;em&gt;prefijo&lt;/em&gt; y el sufijo como &lt;em&gt;sufijo&lt;/em&gt; . Ambos pueden ser cadenas vac&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="translated">La cadena resultante puede no tener un cero inicial.Su longitud es siempre exactamente 3.</target>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="translated">La cadena resultante tendr&amp;aacute; exactamente &lt;em&gt;len&lt;/em&gt; caracteres. No se genera ning&amp;uacute;n prefijo como &lt;code&gt;0x&lt;/code&gt; . &lt;em&gt;x&lt;/em&gt; se trata como un valor sin signo.</target>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">La cadena resultante tendr&amp;aacute; una &lt;em&gt;longitud&lt;/em&gt; m&amp;iacute;nima de caracteres &lt;em&gt;minchars&lt;/em&gt; . Esto se logra agregando ceros a la izquierda.</target>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="translated">El valor de retorno se puede ignorar impl&amp;iacute;citamente si el proc / iterator llamado se ha declarado con el pragma &lt;code&gt;discardable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="translated">El valor de retorno se puede ignorar impl&amp;iacute;citamente si el proc / iterator llamado se ha declarado con el pragma &lt;span id=&quot;discardable_1&quot;&gt;descartable&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="translated">El &lt;code&gt;StringTableRef&lt;/code&gt; devuelto contiene los par&amp;aacute;metros utilizados por el motor HTML para generar el resultado final. Para obtener informaci&amp;oacute;n sobre cu&amp;aacute;les son estos par&amp;aacute;metros y su prop&amp;oacute;sito, busque el archivo &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; incluido con el compilador.</target>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="translated">El Futuro devuelto se completará una vez que todos los datos hayan sido escritos en el archivo especificado.</target>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="translated">Las reglas para la computación en tiempo de compilación son:</target>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="translated">La misma acci&amp;oacute;n tambi&amp;eacute;n se puede realizar de forma asincr&amp;oacute;nica, simplemente use &lt;code&gt;AsyncHttpClient&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">Lo mismo que &lt;code&gt;add(s, formatstr % a)&lt;/code&gt; , pero m&amp;aacute;s eficiente.</target>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="translated">Lo mismo que &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">Lo mismo que &lt;code&gt;parentDir(head) / tail&lt;/code&gt; menos que no haya un directorio principal. Entonces se realiza &lt;code&gt;head / tail&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="translated">Lo mismo que &lt;em&gt;joinPath (head, tail)&lt;/em&gt; , pero funciona con cualquier n&amp;uacute;mero de partes del directorio. Debe pasar al menos un elemento o el proceso se afirmar&amp;aacute; en las compilaciones de depuraci&amp;oacute;n y se bloquear&amp;aacute; en las compilaciones de lanzamiento.</target>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">Lo mismo que el &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;iterador rsplit&lt;/a&gt; , pero es un proceso que devuelve una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">Lo mismo que el &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;iterador rsplit&lt;/a&gt; , pero es un proceso que devuelve una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">Lo mismo que el &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;iterador rsplit&lt;/a&gt; , pero es un proceso que devuelve una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">Lo mismo que el &lt;a href=&quot;#split.i,string,char,int&quot;&gt;iterador dividido&lt;/a&gt; , pero es un proceso que devuelve una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">Lo mismo que el &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;iterador dividido&lt;/a&gt; , pero es un proceso que devuelve una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">Lo mismo que el iterador &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; , pero es un proceso que devuelve una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">Lo mismo que el iterador &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; , pero es un proceso que devuelve una secuencia de subcadenas.</target>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">La misma sintaxis se aplica al &lt;code&gt;iterator&lt;/code&gt; (con &lt;code&gt;nnkIteratorTy&lt;/code&gt; ), pero &lt;em&gt;no se&lt;/em&gt; aplica al &lt;code&gt;converter&lt;/code&gt; o la &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="translated">La macro de escaneo</target>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">El segundo operador de &lt;em&gt;*&lt;/em&gt; debe ser un par&amp;aacute;metro; se utiliza para reunir todos los argumentos. La expresi&amp;oacute;n &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; se pasa a &lt;code&gt;optConc&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; como una lista especial (del tipo &lt;code&gt;nkArgList&lt;/code&gt; ) que se aplana en una expresi&amp;oacute;n de llamada; por tanto, la invocaci&amp;oacute;n de &lt;code&gt;optConc&lt;/code&gt; produce:</target>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="translated">Se requiere que la secuencia tenga al menos un solo elemento. Las versiones de depuraci&amp;oacute;n de su programa se afirmar&amp;aacute;n en esta situaci&amp;oacute;n, pero las versiones de lanzamiento continuar&amp;aacute;n felizmente. Si la secuencia tiene un solo elemento, se devolver&amp;aacute; sin aplicar la &lt;code&gt;operation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="translated">El tipo de conjunto modela la noción matemática de un conjunto.El tipo de conjunto sólo puede ser un tipo ordinal de un cierto tamaño,a saber:</target>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="translated">La llamada del sistema setrlimit()establece los límites de los recursos.</target>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="translated">La firma tiene que ser:</target>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="translated">El tamaño del tipo de bool es de un byte.</target>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">El número positivo más pequeño (no cero)que se puede representar en un tipo de punto flotante de 32 bits.</target>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">El número positivo más pequeño (no cero)que puede representarse en un tipo de punto flotante de 64 bits.</target>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="translated">La soluci&amp;oacute;n es &lt;strong&gt;reproducir&lt;/strong&gt; las declaraciones de nivel superior del m&amp;oacute;dulo. Esto resuelve el problema sin tener que poner en especial la l&amp;oacute;gica que llena las secuencias internas que se ven afectadas por los pragmas.</target>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="translated">La línea de origen que disparó un mensaje de diagnóstico.</target>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">La variable de &lt;code&gt;result&lt;/code&gt; ado especial .</target>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="translated">Los corchetes &lt;code&gt;[]&lt;/code&gt; indican un elemento opcional.</target>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="translated">La distribución estándar se envía con las siguientes herramientas:</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">El flujo de error estándar.</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">El flujo de entrada estándar.</target>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar se puede evitar hasta un punto en el que sea factible la generaci&amp;oacute;n de c&amp;oacute;digo C para microcontroladores de 16 bits. Utilice el destino &lt;span id=&quot;standalone_1&quot;&gt;independiente&lt;/span&gt; ( &lt;code&gt;--os:standalone&lt;/code&gt; ) para una biblioteca est&amp;aacute;ndar b&amp;aacute;sica que carece de funciones del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar admite un n&amp;uacute;mero creciente de &lt;code&gt;useX&lt;/code&gt; condicionales de useX que afectan la forma en que se implementan algunas funciones. Esta secci&amp;oacute;n intenta dar una lista completa.</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">El flujo de salida estándar.</target>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="translated">Las declaraciones posteriores al &lt;code&gt;try&lt;/code&gt; se ejecutan en orden secuencial a menos que se genere una excepci&amp;oacute;n &lt;code&gt;e&lt;/code&gt; . Si el tipo de excepci&amp;oacute;n de &lt;code&gt;e&lt;/code&gt; coincide con alguno de los enumerados en una cl&amp;aacute;usula &lt;code&gt;except&lt;/code&gt; , se ejecutan las instrucciones correspondientes. Las declaraciones que siguen a las cl&amp;aacute;usulas &lt;code&gt;except&lt;/code&gt; se denominan &lt;span id=&quot;exception-handlers_1&quot;&gt;controladores de excepciones&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="translated">Las declaraciones posteriores al &lt;code&gt;try&lt;/code&gt; se ejecutan a menos que se genere una excepci&amp;oacute;n. Entonces se ejecuta la parte &lt;code&gt;except&lt;/code&gt; o apropiada .</target>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="translated">Las declaraciones no abren un nuevo ámbito.</target>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="translated">Las declaraciones que pertenecen a la expresión que se evalúa como verdadera son traducidas por el compilador,las otras declaraciones no son revisadas por la semántica! Sin embargo,cada condición se comprueba para la semántica.</target>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="translated">Las declaraciones dentro de una rama no abren un nuevo ámbito.</target>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="translated">El estado de una prueba cuando se hace.</target>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">La API stdlib est&amp;aacute; dise&amp;ntilde;ada para ser &lt;strong&gt;f&amp;aacute;cil de usar&lt;/strong&gt; y coherente. La facilidad de uso se mide por el n&amp;uacute;mero de llamadas para lograr una acci&amp;oacute;n concreta de alto nivel. El objetivo final es que el programador pueda &lt;em&gt;adivinar&lt;/em&gt; un nombre.</target>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="translated">El filtro stdtmpl proporciona un motor de plantillas simple para Nim. El filtro utiliza un analizador sint&amp;aacute;ctico basado en l&amp;iacute;neas: las l&amp;iacute;neas precedidas por un &lt;em&gt;metacar&amp;aacute;cter&lt;/em&gt; (predeterminado: &lt;code&gt;#&lt;/code&gt; ) contienen c&amp;oacute;digo Nim, otras l&amp;iacute;neas son textualmente. Debido a que el an&amp;aacute;lisis basado en sangr&amp;iacute;a no es adecuado para un motor de plantillas, las declaraciones de flujo de control necesitan delimitadores &lt;code&gt;end X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="translated">El literal de cadena pasado a &lt;code&gt;exportc&lt;/code&gt; puede ser una cadena de formato:</target>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="translated">El literal de cadena pasado a &lt;code&gt;importc&lt;/code&gt; puede ser una cadena de formato:</target>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">El operador stringify para un argumento CString. Devuelve &lt;em&gt;x&lt;/em&gt; convertido en una cadena.</target>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">El operador stringify para un argumento booleano. Devuelve &lt;em&gt;x&lt;/em&gt; convertido a la cadena &quot;falso&quot; o &quot;verdadero&quot;.</target>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">El operador stringify para un argumento de car&amp;aacute;cter. Devuelve &lt;em&gt;x&lt;/em&gt; convertido en una cadena.</target>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">El operador stringify para un argumento flotante. Devuelve &lt;em&gt;x&lt;/em&gt; convertido a una cadena decimal.</target>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">El operador stringify para un argumento de cadena. Devuelve &lt;em&gt;x&lt;/em&gt; tal como est&amp;aacute;. Este operador es &amp;uacute;til para c&amp;oacute;digo gen&amp;eacute;rico, por lo que &lt;code&gt;$expr&lt;/code&gt; tambi&amp;eacute;n funciona si &lt;code&gt;expr&lt;/code&gt; ya es una cadena.</target>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">El operador stringify para un argumento de enumeraci&amp;oacute;n. Esto funciona para cualquier tipo de enumeraci&amp;oacute;n gracias a la magia del compilador. Si se proporciona un operador &lt;code&gt;$&lt;/code&gt; para una enumeraci&amp;oacute;n concreta, se utiliza en su lugar. (En otras palabras: es posible &lt;em&gt;sobrescribir&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">El operador stringify para un argumento de n&amp;uacute;mero entero. Devuelve &lt;em&gt;x&lt;/em&gt; convertido a una cadena decimal.</target>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">El operador stringify para un argumento de n&amp;uacute;mero entero. Devuelve &lt;em&gt;x&lt;/em&gt; convertido a una cadena decimal. &lt;code&gt;$&lt;/code&gt; es la forma general en que Nim &lt;span id=&quot;tostring_1&quot;&gt;escribe toString&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="translated">El filtro de tira simplemente elimina los espacios en blanco delanteros y traseros de cada línea.</target>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">La subexpresi&amp;oacute;n despu&amp;eacute;s de los dos puntos ( &lt;code&gt;arg&lt;/code&gt; en &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; ) es un argumento opcional que se pasa al &lt;code&gt;format&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="translated">El subconjunto es,de hecho,el lenguaje completo con las siguientes restricciones/cambios:</target>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="translated">El car&amp;aacute;cter de sustituci&amp;oacute;n introduce una expresi&amp;oacute;n de Nim &lt;em&gt;e&lt;/em&gt; dentro del literal de cadena. &lt;em&gt;e&lt;/em&gt; se convierte en una cadena con la operaci&amp;oacute;n &lt;em&gt;toString&lt;/em&gt; que por defecto es &lt;code&gt;$&lt;/code&gt; . Para una verificaci&amp;oacute;n de tipo s&amp;oacute;lida, establezca &lt;code&gt;toString&lt;/code&gt; en la cadena vac&amp;iacute;a. &lt;em&gt;e&lt;/em&gt; debe coincidir con este patr&amp;oacute;n de PEG:</target>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="translated">Las variables de sustituci&amp;oacute;n (la cosa despu&amp;eacute;s del &lt;code&gt;$&lt;/code&gt; ) se enumeran de 1 a &lt;code&gt;a.len&lt;/code&gt; . Para producir un &lt;code&gt;$&lt;/code&gt; textual , use &lt;code&gt;$$&lt;/code&gt; . La notaci&amp;oacute;n &lt;code&gt;$#&lt;/code&gt; se puede utilizar para hacer referencia a la siguiente variable de sustituci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="translated">La suite ejecutará los casos de prueba individuales en el orden en que fueron listados.Con la configuración global predeterminada,el código anterior se imprime:</target>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="translated">El estado de no bloqueo del &lt;code&gt;fd&lt;/code&gt; proporcionado se habilitar&amp;aacute; impl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="translated">Las reglas de vinculación de los símbolos en los genéricos son ligeramente sutiles:Hay símbolos &quot;abiertos&quot; y &quot;cerrados&quot;.Un símbolo &quot;cerrado&quot; no puede rebotar en el contexto de la instanciación,un símbolo &quot;abierto&quot; puede.Por defecto,los símbolos sobrecargados son abiertos y todos los demás símbolos son cerrados.</target>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="translated">El campo &lt;code&gt;ast&lt;/code&gt; del s&amp;iacute;mbolo se carga de forma perezosa, a pedido. Aqu&amp;iacute; es de donde provienen la mayor&amp;iacute;a de los ahorros, solo el AST externo poco profundo se reconstruye inmediatamente.</target>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="translated">La diferencia sim&amp;eacute;trica de dos conjuntos se representa matem&amp;aacute;ticamente como &lt;em&gt;A △ B&lt;/em&gt; o &lt;em&gt;A ⊖ B&lt;/em&gt; y es el conjunto de todos los objetos que son miembros de &lt;em&gt;s1&lt;/em&gt; o &lt;em&gt;s2&lt;/em&gt; pero no ambos al mismo tiempo. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="translated">La sintaxis &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; se puede utilizar para importar varios m&amp;oacute;dulos desde el mismo directorio.</target>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="translated">La sintaxis de los iteradores es similar a procs, pero con &lt;code&gt;nnkIteratorDef&lt;/code&gt; reemplazando a &lt;code&gt;nnkProcDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="translated">La sintaxis de los arreglos anidados (multidimensionales)en otros idiomas es cuestión de añadir más corchetes porque normalmente cada dimensión se restringe al mismo tipo de índice que las demás.En Nim se pueden tener diferentes dimensiones con diferentes tipos de índice,por lo que la sintaxis de anidación es ligeramente diferente.Basándonos en el ejemplo anterior,en el que un nivel se define como un conjunto de enums indexados por otro enum,podemos añadir las siguientes líneas para añadir un tipo de torre de luz subdividido en niveles de altura a los que se accede a través de su índice entero:</target>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="translated">La sintaxis para las conversiones de tipos es &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (como una llamada normal):</target>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="translated">La sintaxis de &lt;code&gt;case&lt;/code&gt; en una declaraci&amp;oacute;n de objeto sigue de cerca la sintaxis de la declaraci&amp;oacute;n &lt;code&gt;case&lt;/code&gt; : las ramas en una secci&amp;oacute;n &lt;code&gt;case&lt;/code&gt; tambi&amp;eacute;n pueden tener sangr&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="translated">La sintaxis para &lt;em&gt;invocar&lt;/em&gt; una plantilla es la misma que para llamar a un procedimiento.</target>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="translated">El árbol de sintaxis</target>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="translated">El &amp;aacute;rbol de sintaxis consta de nodos que pueden tener un n&amp;uacute;mero arbitrario de hijos. Los tipos y s&amp;iacute;mbolos est&amp;aacute;n representados por otros nodos, porque pueden contener ciclos. El AST cambia de forma despu&amp;eacute;s de la verificaci&amp;oacute;n sem&amp;aacute;ntica. Esto es necesario para facilitar la vida de los generadores de c&amp;oacute;digos. Consulte el m&amp;oacute;dulo &quot;ast&quot; para conocer las definiciones de tipos. El m&amp;oacute;dulo de &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; contiene muchos ejemplos de c&amp;oacute;mo AST representa cada estructura sint&amp;aacute;ctica.</target>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="translated">La convenci&amp;oacute;n syscall es la misma que &lt;code&gt;__syscall&lt;/code&gt; en C. Se usa para interrupciones.</target>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">El comando temp crea el compilador de Nim pero con un nombre final diferente ( &lt;code&gt;nim_temp&lt;/code&gt; ), por lo que no sobrescribe su compilador normal. Puede usar este comando para probar diferentes opciones, las mismas que emitir&amp;iacute;a para el &lt;a href=&quot;#boot-command&quot;&gt;comando de arranque&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="translated">El motor de la plantilla es bastante flexible.Es fácil producir un procedimiento que escribe el código de la plantilla directamente en un archivo:</target>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="translated">La plantilla inyecta la variable &lt;code&gt;it&lt;/code&gt; que puede usar directamente en una expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="translated">La plantilla inyecta la variable &lt;code&gt;it&lt;/code&gt; que puede usar directamente en una expresi&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="translated">La plantilla inyecta la variable &lt;code&gt;it&lt;/code&gt; que puede usar directamente en una expresi&amp;oacute;n. La expresi&amp;oacute;n debe devolver el mismo tipo que la secuencia que est&amp;aacute; mutando.</target>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="translated">La plantilla inyecta la variable &lt;code&gt;it&lt;/code&gt; que puede usar directamente en una expresi&amp;oacute;n. Tambi&amp;eacute;n debe pasar como &lt;em&gt;tip&lt;/em&gt; el tipo de expresi&amp;oacute;n, ya que la nueva secuencia devuelta puede tener un tipo diferente al original.</target>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="translated">No se puede acceder al cero final a menos que la cadena se convierta primero al tipo &lt;code&gt;cstring&lt;/code&gt; . El cero de terminaci&amp;oacute;n asegura que esta conversi&amp;oacute;n se puede realizar en O (1) y sin ninguna asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="translated">El estado y el nombre de la prueba se imprime después de cualquier salida o rastreo.</target>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="translated">La tercera y &amp;uacute;ltima forma de escribir literales de cadena son &lt;em&gt;literales de cadena larga&lt;/em&gt; . Est&amp;aacute;n escritos con tres comillas: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; ; pueden abarcar varias l&amp;iacute;neas y &lt;code&gt;\&lt;/code&gt; tampoco es un car&amp;aacute;cter de escape. Son muy &amp;uacute;tiles para incrustar plantillas de c&amp;oacute;digo HTML, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="translated">El tercer uso de la barra invertida es para especificar &lt;span id=&quot;generic-character-types_1&quot;&gt;tipos de caracteres gen&amp;eacute;ricos&lt;/span&gt; . Siempre se reconocen los siguientes:</target>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">Los caracteres de la nueva línea que se arrastran se eliminan de las líneas iteradas.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">El tipo coerci&amp;oacute;n &lt;code&gt;static(x)&lt;/code&gt; se puede usar para forzar la evaluaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n de la expresi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; dada .</target>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="translated">La conversi&amp;oacute;n de tipo &lt;code&gt;T(a)&lt;/code&gt; es un valor L si &lt;code&gt;a&lt;/code&gt; es un valor L y se &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">El tipo de par&amp;aacute;metro puede tener como prefijo la palabra clave &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="translated">El tipo que representa un mango de archivo.</target>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="translated">Los sufijos del tipo son:</target>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">Los tipos &lt;code&gt;var T&lt;/code&gt; y &lt;code&gt;typedesc[T]&lt;/code&gt; no se pueden inferir en una instanciaci&amp;oacute;n gen&amp;eacute;rica. No se permite lo siguiente:</target>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">El uso t&amp;iacute;pico del compilador implica el uso del comando &lt;code&gt;compile&lt;/code&gt; o &lt;code&gt;c&lt;/code&gt; para transformar un archivo &lt;code&gt;.nim&lt;/code&gt; en uno o m&amp;aacute;s archivos &lt;code&gt;.c&lt;/code&gt; que luego se compilan con el compilador C de la plataforma en un binario est&amp;aacute;tico. Sin embargo, existen otros comandos para compilar en C ++, Objective-C o Javascript. Se pueden leer m&amp;aacute;s detalles en el &lt;a href=&quot;backends&quot;&gt;documento Integraci&amp;oacute;n de backend de Nim&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">El escenario de uso t&amp;iacute;pico para esta opci&amp;oacute;n es llamarla despu&amp;eacute;s de que el usuario haya escrito el car&amp;aacute;cter de punto para &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;la sintaxis de llamada orientada a objetos&lt;/a&gt; . Idetools intentar&amp;aacute; devolver las sugerencias ordenadas primero por alcance (desde el m&amp;aacute;s interno al m&amp;aacute;s externo) y luego por el nombre del elemento.</target>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">El escenario de uso t&amp;iacute;pico para esta opci&amp;oacute;n es llamarla despu&amp;eacute;s de que el usuario haya escrito el car&amp;aacute;cter de punto para &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;la sintaxis de llamada orientada a objetos&lt;/a&gt; . Nimsuggest intentar&amp;aacute; devolver las sugerencias ordenadas primero por alcance (desde el m&amp;aacute;s interno al m&amp;aacute;s externo) y luego por el nombre del elemento.</target>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="translated">La uni&amp;oacute;n de dos conjuntos se representa matem&amp;aacute;ticamente como &lt;em&gt;A &amp;cup; B&lt;/em&gt; y es el conjunto de todos los objetos que son miembros de &lt;em&gt;s1&lt;/em&gt; , &lt;em&gt;s2&lt;/em&gt; o ambos. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="translated">La unidad de los par&amp;aacute;metros &lt;code&gt;maxPauseInUs&lt;/code&gt; y &lt;code&gt;us&lt;/code&gt; es microsegundos.</target>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="translated">El operador inseguro</target>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="translated">La subida de nuevos archivos.</target>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="translated">El uso de &lt;code&gt;concept&lt;/code&gt; o (experimental) es similar a los objetos.</target>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="translated">La guía del usuario enumera los argumentos de la línea de comandos,las características especiales del compilador,etc.</target>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="translated">La declaración de uso proporciona una conveniencia sintáctica en los módulos en los que se utilizan una y otra vez los mismos nombres y tipos de parámetros.En lugar de:</target>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="translated">Los valores del listado devuelto deben ser bastante auto-explicativos:</target>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="translated">La declaración de Var</target>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="translated">La declaración var declara una nueva variable local o global:</target>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="translated">La variable &lt;code&gt;i&lt;/code&gt; es declarada impl&amp;iacute;citamente por el bucle &lt;code&gt;for&lt;/code&gt; y tiene el tipo &lt;code&gt;int&lt;/code&gt; , porque eso es lo que devuelve &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; . &lt;code&gt;i&lt;/code&gt; corre a trav&amp;eacute;s de los valores 1, 2, .., 10. Cada valor es &lt;code&gt;echo&lt;/code&gt; -ed. Este c&amp;oacute;digo hace lo mismo:</target>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="translated">Las variables se comparan con &lt;em&gt;cmpIgnoreStyle&lt;/em&gt; . &lt;em&gt;ValueError&lt;/em&gt; se &lt;em&gt;genera&lt;/em&gt; si se ha pasado una cadena de formato mal formada al operador &lt;em&gt;%&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="translated">La frase &quot;while&quot; es una simple construcción en bucle:</target>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="translated">El año sin relleno.Siempre es positivo,incluso cuando el año es antes de Cristo.</target>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="translated">El año sin relleno.Será negativo cuando el año sea BC.</target>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">El año,acolchado hasta al menos cuatro dígitos.Siempre es positivo,incluso cuando el año es antes de Cristo.Cuando el año tiene más de cuatro dígitos,el &quot;+&quot; está precedido.</target>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">El año,acolchado hasta al menos cuatro dígitos.Será negativo cuando el año sea BC.Cuando el año tiene más de cuatro dígitos,el &quot;+&quot; se anticipa a menos que el año sea antes de Cristo.</target>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">Luego llama a &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; y luego cierra el archivo. Devuelve la cadena. Genera una excepci&amp;oacute;n de E / S en caso de error. Si necesita llamar a esto dentro de una macro de tiempo de compilaci&amp;oacute;n, puede usar &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="translated">Luego, el m&amp;oacute;dulo &lt;code&gt;A&lt;/code&gt; (que depende de &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;G&lt;/code&gt; ) se compila y &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;G&lt;/code&gt; se dejan sin cambios. &lt;code&gt;A&lt;/code&gt; requiere &lt;code&gt;G.P2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="translated">Luego se compila el m&amp;oacute;dulo &lt;code&gt;B&lt;/code&gt; que requiere &lt;code&gt;G.P1&lt;/code&gt; . Ok, no hay problema, &lt;code&gt;G.P1&lt;/code&gt; se carga desde el archivo de s&amp;iacute;mbolos y &lt;code&gt;G.c&lt;/code&gt; ahora contiene &lt;code&gt;G.P1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="translated">Luego mueva el c&amp;oacute;digo C y el script de compilaci&amp;oacute;n &lt;code&gt;compile_myproject.sh&lt;/code&gt; a su m&amp;aacute;quina Linux i386 y ejecute el script.</target>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="translated">Hay 2 tipos de iteradores en Nim: iteradores en &lt;em&gt;l&amp;iacute;nea&lt;/em&gt; y de &lt;em&gt;cierre&lt;/em&gt; . Un &lt;span id=&quot;inline-iterator_1&quot;&gt;iterador en l&amp;iacute;nea&lt;/span&gt; es un iterador que siempre est&amp;aacute; alineado por el compilador, lo que genera una sobrecarga cero para la abstracci&amp;oacute;n, pero puede resultar en un gran aumento en el tama&amp;ntilde;o del c&amp;oacute;digo. Los iteradores en l&amp;iacute;nea son ciudadanos de segunda clase; Se pueden pasar como par&amp;aacute;metros solo a otras funciones de c&amp;oacute;digo en l&amp;iacute;nea, como plantillas, macros y otros iteradores en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="translated">Hay 3 operaciones que están ligadas a un tipo:</target>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="translated">Hay algunas cosas que no funcionan porque las bibliotecas de DevkitPro no las soportan.Lo son:</target>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="translated">Tambi&amp;eacute;n hay literales de cadena sin formato que est&amp;aacute;n precedidos por la letra &lt;code&gt;r&lt;/code&gt; (o &lt;code&gt;R&lt;/code&gt; ) y est&amp;aacute;n delimitados por comillas dobles coincidentes (como los literales de cadena ordinarios) y no interpretan las secuencias de escape. Esto es especialmente conveniente para expresiones regulares o rutas de Windows:</target>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="translated">Actualmente solo hay dos opciones para el modo de verificaci&amp;oacute;n; uno es &lt;code&gt;CVerifyNone&lt;/code&gt; y con &amp;eacute;l no se verificar&amp;aacute;n los certificados, el otro es &lt;code&gt;CVerifyPeer&lt;/code&gt; y se verificar&amp;aacute;n los certificados, &lt;code&gt;CVerifyPeer&lt;/code&gt; es la opci&amp;oacute;n m&amp;aacute;s segura.</target>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">Hay varias formas de evitar esto, incluido el uso del operador &lt;code&gt;&amp;amp;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="translated">No hay restricciones para el &lt;code&gt;constructor&lt;/code&gt; AST, funciona para tuplas anidadas de matrices de conjuntos, etc.</target>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="translated">Hay varios tipos de nodos que se utilizan para la comprobación semántica o la generación de códigos.Estos son accesibles desde este módulo,pero no deben ser utilizados.Otros tipos de nodos están especialmente diseñados para facilitar las manipulaciones de AST.Estos se explican aquí.</target>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">Hay dos conjuntos diferentes de metacaracteres:los que se reconocen en cualquier parte del patrón,excepto entre corchetes,y los que se reconocen entre corchetes.Fuera de los corchetes,los metacaracteres son los siguientes:</target>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="translated">Hay dos pseudo directorios:</target>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="translated">Hay dos maneras de construir un PEG en código Nim:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
