<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="956810679fde5bcd94729ea5a195b781ebc9936f" translate="yes" xml:space="preserve">
          <source>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; features should be used instead. Both parallel and spawn need the &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; module to work.</source>
          <target state="translated">Nim tiene un grupo de subprocesos incorporado que se puede usar para tareas intensivas de CPU. Para las tareas intensivas IO los &lt;code&gt;async&lt;/code&gt; y &lt;code&gt;await&lt;/code&gt; caracter&amp;iacute;sticas se deben utilizar en su lugar. Tanto el paralelo como el spawn necesitan que el m&amp;oacute;dulo &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; funcione.</target>
        </trans-unit>
        <trans-unit id="8271465a18dfd05fb2b43750bb600424d58f8d93" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Nim no necesita &lt;em&gt;propiedades&lt;/em&gt; get: los procedimientos get ordinarios que se llaman con la &lt;em&gt;sintaxis de llamada&lt;/em&gt; al &lt;em&gt;m&amp;eacute;todo&lt;/em&gt; logran lo mismo. Pero establecer un valor es diferente; para esto se necesita una sintaxis especial de setter:</target>
        </trans-unit>
        <trans-unit id="2d68c150b59e057428b45d05875c0768dda6fd33" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this, a special setter syntax is needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a3428d8f1eb98b6a56266f5afa22c38fb951ee" translate="yes" xml:space="preserve">
          <source>Nim has no separate optimizer, but the C code that is produced is very efficient. Most C compilers have excellent optimizers, so usually it is not needed to optimize one's code. Nim has been designed to encourage efficient code: The most readable code in Nim is often the most efficient too.</source>
          <target state="translated">Nim no tiene un optimizador separado,pero el código C que se produce es muy eficiente.La mayoría de los compiladores C tienen excelentes optimizadores,así que usualmente no es necesario optimizar el código de uno.Nim ha sido diseñado para fomentar un código eficiente:El código más legible en Nim es a menudo el más eficiente también.</target>
        </trans-unit>
        <trans-unit id="d4433d8ee67c60caa5f14cbc4d36fb3fc5be0287" translate="yes" xml:space="preserve">
          <source>Nim has the concept of a global search path (PATH) that is queried to determine where to find imported modules or include files. If multiple files are found an ambiguity error is produced.</source>
          <target state="translated">Nim tiene el concepto de una ruta de búsqueda global (PATH)que se consulta para determinar dónde encontrar los módulos importados o incluir los archivos.Si se encuentran múltiples archivos se produce un error de ambigüedad.</target>
        </trans-unit>
        <trans-unit id="01727ad8d0bbaeeea62faa6f12c71312bf1ae451" translate="yes" xml:space="preserve">
          <source>Nim has these floating point types built-in: &lt;code&gt;float float32 float64&lt;/code&gt;.</source>
          <target state="translated">Nim tiene estos tipos de coma flotante incorporados: &lt;code&gt;float float32 float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3deb8348e9e32056d74290a50d876e63851d29" translate="yes" xml:space="preserve">
          <source>Nim has these integer types built-in: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt;.</source>
          <target state="translated">Nim tiene estos tipos de enteros integrados: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4f95676cbff4f6b732c078d876ae2ad27f446" translate="yes" xml:space="preserve">
          <source>Nim has two flavors of parallelism:</source>
          <target state="translated">Nim tiene dos sabores de paralelismo:</target>
        </trans-unit>
        <trans-unit id="dc5bf296e3c41484c147bfc3cd569c0d2a605bfb" translate="yes" xml:space="preserve">
          <source>Nim idetools integration</source>
          <target state="translated">La integración de las herramientas de Nim idetools</target>
        </trans-unit>
        <trans-unit id="fde430a55fc171aea53e7cacfbb81ff6931bd1b5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from C</source>
          <target state="translated">Ejemplo de invocación de Nim de C</target>
        </trans-unit>
        <trans-unit id="a9b0c283f30ebbd8bbc505d567707e20b58f9be5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from JavaScript</source>
          <target state="translated">Ejemplo de invocación de Nim desde JavaScript</target>
        </trans-unit>
        <trans-unit id="bdd28046b42c51d6419a24b949f2e431ad33feda" translate="yes" xml:space="preserve">
          <source>Nim is free software; it is licensed under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt;.</source>
          <target state="translated">Nim es un software gratuito; tiene licencia de &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7393409ca98f35a585605ecd27b0ce04bc6dc" translate="yes" xml:space="preserve">
          <source>Nim lock, re-entrant</source>
          <target state="translated">Nim lock,reentrada</target>
        </trans-unit>
        <trans-unit id="af2f77b6798efd1fe7af2c6d48238ea2e59af4d3" translate="yes" xml:space="preserve">
          <source>Nim lock; whether this is re-entrant or not is unspecified!</source>
          <target state="translated">Nim lock;si esto es reingresar o no,no está especificado!</target>
        </trans-unit>
        <trans-unit id="396c55174c1748ab5bec4b1cb866abf79d300e48" translate="yes" xml:space="preserve">
          <source>Nim maintenance script</source>
          <target state="translated">Guión de mantenimiento de Nim</target>
        </trans-unit>
        <trans-unit id="200b4437aaf50df9807fc02a8b32574618effddb" translate="yes" xml:space="preserve">
          <source>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</source>
          <target state="translated">Nim ofrece una familia especial de operadores de puntos que pueden utilizarse para interceptar y reescribir intentos de llamada de proc y de acceso al campo,refiriéndose a nombres de símbolos no declarados anteriormente.Pueden utilizarse para proporcionar una interfaz fluida a los objetos que se encuentran fuera de los límites estáticos del sistema de tipos,como los valores de los lenguajes de escritura dinámicos o los formatos de archivos dinámicos como JSON o XML.</target>
        </trans-unit>
        <trans-unit id="67e6a58d0659f4167e32702de63a078a70b84e7d" translate="yes" xml:space="preserve">
          <source>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</source>
          <target state="translated">Nim ofrece una interfaz bidireccional con el backend del objetivo.Esto significa que puedes llamar al código del backend desde Nim y el código Nim puede ser llamado por el código del backend.Usualmente la direccion de las llamadas depende de la arquitectura de tu software (es Nim tu programa principal o Nim provee un componente?).</target>
        </trans-unit>
        <trans-unit id="893f066137f8187ed8a07f2272b19d0871bbc768" translate="yes" xml:space="preserve">
          <source>Nim produces a warning for symbols that are not exported and not used either. The &lt;code&gt;used&lt;/code&gt; pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</source>
          <target state="translated">Nim genera una advertencia para los s&amp;iacute;mbolos que no se exportan y tampoco se utilizan. El pragma &lt;code&gt;used&lt;/code&gt; se puede adjuntar a un s&amp;iacute;mbolo para suprimir esta advertencia. Esto es particularmente &amp;uacute;til cuando el s&amp;iacute;mbolo fue generado por una macro:</target>
        </trans-unit>
        <trans-unit id="6150bb7b7dad74d65ce46c3a55145c510735a725" translate="yes" xml:space="preserve">
          <source>Nim provides language integration with external IDEs through the idetools command. See the documentation of &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; for further information.</source>
          <target state="translated">Nim proporciona integraci&amp;oacute;n de lenguaje con IDE externos a trav&amp;eacute;s del comando idetools. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6864a9277154b157b94a761e493fbd79ef8b809c" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; and &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; commands to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;docgen&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim proporciona los comandos &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; y &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; para generar documentaci&amp;oacute;n HTML a partir de archivos fuente &lt;code&gt;.nim&lt;/code&gt; . Solo los s&amp;iacute;mbolos exportados aparecer&amp;aacute;n en la salida. Para obtener m&amp;aacute;s detalles, &lt;a href=&quot;docgen&quot;&gt;consulte la documentaci&amp;oacute;n de docgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7008b8e9d9cc2fbb71ad07b4590df2b146b1ff" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; command to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0f9e0827a8dbea31dc2fbe4ce37db63cfa840c" translate="yes" xml:space="preserve">
          <source>Nim provides the ability to overload procedures similar to C++:</source>
          <target state="translated">Nim provee la habilidad de sobrecargar procedimientos similares a C++:</target>
        </trans-unit>
        <trans-unit id="082cc471f7e487d0e261d56375fe2f285b9ead9d" translate="yes" xml:space="preserve">
          <source>Nim provides the pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; and &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; to control whether the IEEE exceptions are ignored or trap a Nim exception:</source>
          <target state="translated">Nim proporciona los pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; e &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; para controlar si las excepciones IEEE se ignoran o atrapan una excepci&amp;oacute;n de Nim:</target>
        </trans-unit>
        <trans-unit id="508417c4e97e2bf7456d14ecac591b4f6356c08f" translate="yes" xml:space="preserve">
          <source>Nim runs on a wide variety of platforms. Support on amd64 and i386 is tested regularly, while less popular platforms are tested by the community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a99b555e8d5a547fbd7a8b6c3c5be83dc59b13" translate="yes" xml:space="preserve">
          <source>Nim search and replace utility.</source>
          <target state="translated">Nim busca y reemplaza la utilidad.</target>
        </trans-unit>
        <trans-unit id="cea72c6813825983207ed89ef6d7563250a6be64" translate="yes" xml:space="preserve">
          <source>Nim significantly improves on the safety of these features via additional pragmas:</source>
          <target state="translated">Nim mejora significativamente la seguridad de estas características a través de pragmas adicionales:</target>
        </trans-unit>
        <trans-unit id="13adb76d4a44fc6d0ed9557643b94613f8b29151" translate="yes" xml:space="preserve">
          <source>Nim support for &lt;span id=&quot;substitution-expressions_1&quot;&gt;substitution expressions&lt;/span&gt; (&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;).</source>
          <target state="translated">Soporte de Nim para &lt;span id=&quot;substitution-expressions_1&quot;&gt;expresiones de sustituci&amp;oacute;n&lt;/span&gt; ( &lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="f308ae3443ec85df73ede4f78102be2e349b672c" translate="yes" xml:space="preserve">
          <source>Nim supports exception tracking. The &lt;span id=&quot;raises_1&quot;&gt;raises&lt;/span&gt; pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</source>
          <target state="translated">Nim admite el seguimiento de excepciones. El pragma de &lt;span id=&quot;raises_1&quot;&gt;aumentos&lt;/span&gt; se puede usar para definir expl&amp;iacute;citamente qu&amp;eacute; excepciones puede generar un proc / iterator / method / converter. El compilador verifica esto:</target>
        </trans-unit>
        <trans-unit id="3f7af30571e6dd9a4e1318813044e95e94a257fb" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own &lt;span id=&quot;namespace_1&quot;&gt;namespace&lt;/span&gt;. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to symbols of another module by the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Recursive module dependencies&lt;/span&gt; are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is &lt;code&gt;identifier.nim&lt;/code&gt;).</source>
          <target state="translated">Nim admite la divisi&amp;oacute;n de un programa en partes mediante un concepto de m&amp;oacute;dulo. Cada m&amp;oacute;dulo debe estar en su propio archivo y tener su propio &lt;span id=&quot;namespace_1&quot;&gt;espacio de nombres&lt;/span&gt; . Los m&amp;oacute;dulos permiten &lt;span id=&quot;information-hiding_1&quot;&gt;ocultar informaci&amp;oacute;n&lt;/span&gt; y &lt;span id=&quot;separate-compilation_1&quot;&gt;compilarlos por separado&lt;/span&gt; . Un m&amp;oacute;dulo puede obtener acceso a los s&amp;iacute;mbolos de otro m&amp;oacute;dulo mediante la declaraci&amp;oacute;n de &lt;span id=&quot;import_1&quot;&gt;importaci&amp;oacute;n&lt;/span&gt; . Se permiten &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;dependencias de m&amp;oacute;dulo recursivas&lt;/span&gt; , pero un poco sutiles. Solo se exportan los s&amp;iacute;mbolos de nivel superior que est&amp;aacute;n marcados con un asterisco ( &lt;code&gt;*&lt;/code&gt; ). Un nombre de m&amp;oacute;dulo v&amp;aacute;lido solo puede ser un identificador de Nim v&amp;aacute;lido (y por lo tanto su nombre de archivo es &lt;code&gt;identifier.nim&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e44eef4a789fd3c119666d4ed23cb9494cb3bbf7" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to the symbols of another module by using the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported:</source>
          <target state="translated">Nim admite la divisi&amp;oacute;n de un programa en partes con un concepto de m&amp;oacute;dulo. Cada m&amp;oacute;dulo est&amp;aacute; en su propio archivo. Los m&amp;oacute;dulos permiten &lt;span id=&quot;information-hiding_1&quot;&gt;ocultar informaci&amp;oacute;n&lt;/span&gt; y &lt;span id=&quot;separate-compilation_1&quot;&gt;compilarlos por separado&lt;/span&gt; . Un m&amp;oacute;dulo puede obtener acceso a los s&amp;iacute;mbolos de otro m&amp;oacute;dulo utilizando la declaraci&amp;oacute;n de &lt;span id=&quot;import_1&quot;&gt;importaci&amp;oacute;n&lt;/span&gt; . Solo se exportan los s&amp;iacute;mbolos de nivel superior que est&amp;aacute;n marcados con un asterisco ( &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="46fdd12ce5e87d8ce22525d0fc7e670179c0d9e1" translate="yes" xml:space="preserve">
          <source>Nim supports the generation of DLLs. However, there must be only one instance of the GC per process/address space. This instance is contained in &lt;code&gt;nimrtl.dll&lt;/code&gt;. This means that every generated Nim DLL depends on &lt;code&gt;nimrtl.dll&lt;/code&gt;. To generate the &quot;nimrtl.dll&quot; file, use the command:</source>
          <target state="translated">Nim admite la generaci&amp;oacute;n de archivos DLL. Sin embargo, debe haber solo una instancia del GC por proceso / espacio de direcciones. Esta instancia est&amp;aacute; contenida en &lt;code&gt;nimrtl.dll&lt;/code&gt; . Esto significa que cada DLL de Nim generada depende de &lt;code&gt;nimrtl.dll&lt;/code&gt; . Para generar el archivo &quot;nimrtl.dll&quot;, use el comando:</target>
        </trans-unit>
        <trans-unit id="9716569bd8c70a883cc816b4d661c7ea0ac3b2d4" translate="yes" xml:space="preserve">
          <source>Nim supports these &lt;span id=&quot;calling-conventions_1&quot;&gt;calling conventions&lt;/span&gt;:</source>
          <target state="translated">Nim admite estas &lt;span id=&quot;calling-conventions_1&quot;&gt;convenciones de llamadas&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="abcf9d9cfc4c5456a80f226fb54d7c37497efa51" translate="yes" xml:space="preserve">
          <source>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Nim apunta a JavaScript 1.5, que es compatible con cualquier navegador ampliamente utilizado. Dado que JavaScript no tiene un medio port&amp;aacute;til para incluir otro m&amp;oacute;dulo, Nim solo genera un archivo &lt;code&gt;.js&lt;/code&gt; largo .</target>
        </trans-unit>
        <trans-unit id="d6334ba658939fb66c6d2eb5152d5c5e1ed6cc5c" translate="yes" xml:space="preserve">
          <source>Nim type</source>
          <target state="translated">Tipo de Nim</target>
        </trans-unit>
        <trans-unit id="12a335b577d343cb196e9cbe8abf689f02aa0bd4" translate="yes" xml:space="preserve">
          <source>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, &lt;em&gt;in pseudo-code&lt;/em&gt;, determines type equality:</source>
          <target state="translated">Nim utiliza la equivalencia de tipo estructural para la mayor&amp;iacute;a de los tipos. Solo para objetos, enumeraciones y tipos diferenciados se utiliza la equivalencia de nombres. El siguiente algoritmo, &lt;em&gt;en pseudoc&amp;oacute;digo&lt;/em&gt; , determina la igualdad de tipos:</target>
        </trans-unit>
        <trans-unit id="1870e8d051fa7bd2733b9612e24fa28e4e1bd585" translate="yes" xml:space="preserve">
          <source>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</source>
          <target state="translated">Nim usa la clásica arquitectura de compilación:Un lexer/escáner alimenta fichas para un analizador.El analizador construye un árbol de sintaxis que es usado por el generador de código.Este árbol de sintaxis es la interfaz entre el analizador y el generador de código.Es esencial entender la mayor parte del código del compilador.</target>
        </trans-unit>
        <trans-unit id="322b8b83d95b2969c2c0f758d4cccd2596086dda" translate="yes" xml:space="preserve">
          <source>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</source>
          <target state="translated">Nim utiliza el paradigma común de declaración/expresión:Las declaraciones no producen un valor en contraste con las expresiones.Sin embargo,algunas expresiones son declaraciones.</target>
        </trans-unit>
        <trans-unit id="89ee9afb771e64a1e7ce2a930130a658c6ca2c85" translate="yes" xml:space="preserve">
          <source>Nim versions before 0.20 used the wrong spelling (&quot;demon&quot;). Now &lt;code&gt;ProcessOption&lt;/code&gt; uses the correct spelling (&quot;daemon&quot;), and this is needed just for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bf12211c3e06c6eb9e50a3ff54ca759ba185c1" translate="yes" xml:space="preserve">
          <source>Nim&amp;#x27;s Garbage Collector</source>
          <target state="translated">Recolector de basura de Nim</target>
        </trans-unit>
        <trans-unit id="9e747b8df254ba8adeea93bf65d5d26fc1f7c029" translate="yes" xml:space="preserve">
          <source>Nim's &lt;code&gt;import&lt;/code&gt; statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n de Nim en realidad tiene diferentes variaciones seg&amp;uacute;n las palabras clave presentes. Comencemos con la forma m&amp;aacute;s simple.</target>
        </trans-unit>
        <trans-unit id="576ef403ca389194e42a3457f0afbf3573e97c72" translate="yes" xml:space="preserve">
          <source>Nim's &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</source>
          <target state="translated">La &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (interfaz de funci&amp;oacute;n externa) de Nim es extensa y solo las partes que escalan a otros backends futuros (como los backends LLVM / JavaScript) est&amp;aacute;n documentadas aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="0001d3798571e3724667eff0ac34ad8cc342d30f" translate="yes" xml:space="preserve">
          <source>Nim's FFI (foreign function interface) is not available in NimScript. This means that any stdlib module which relies on &lt;code&gt;importc&lt;/code&gt; can not be used in the VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a2a3b0146362c9c774e923c0df1b46db23ed52" translate="yes" xml:space="preserve">
          <source>Nim's Garbage Collector</source>
          <target state="translated">El recolector de basura de Nim</target>
        </trans-unit>
        <trans-unit id="9c63ed798cb14ea75cd44449159244ef1e6fa151" translate="yes" xml:space="preserve">
          <source>Nim's Memory Management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41682260d59280a2b3b6483204da1644fe3e4a8" translate="yes" xml:space="preserve">
          <source>Nim's boolean type is called &lt;code&gt;bool&lt;/code&gt; and consists of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in while, if, elif, and when statements must be of type bool.</source>
          <target state="translated">El tipo booleano de Nim se llama &lt;code&gt;bool&lt;/code&gt; y consta de dos valores predefinidos &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; . Las condiciones en las declaraciones while, if, elif y when deben ser de tipo bool.</target>
        </trans-unit>
        <trans-unit id="7f9bb646d70cb0b289c9556100113fa715dd573b" translate="yes" xml:space="preserve">
          <source>Nim's library is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt;, and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ee675d367062e6a639dae94168d9a9c1a41f44" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different from other common programming languages (C, Pascal): Each thread has its own (garbage collected) heap and sharing of memory is restricted. This helps to prevent race conditions and improves efficiency. See &lt;a href=&quot;manual#threads&quot;&gt;the manual for details of this memory model&lt;/a&gt;.</source>
          <target state="translated">El modelo de memoria de Nim para subprocesos es bastante diferente de otros lenguajes de programaci&amp;oacute;n comunes (C, Pascal): cada subproceso tiene su propio mont&amp;oacute;n (recolecci&amp;oacute;n de basura) y el uso compartido de memoria est&amp;aacute; restringido. Esto ayuda a prevenir las condiciones de carrera y mejora la eficiencia. Consulte &lt;a href=&quot;manual#threads&quot;&gt;el manual para obtener detalles de este modelo de memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e98391c7155144865c0c684166fb6f91c4167fcb" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</source>
          <target state="translated">El modelo de memoria de Nim para los hilos es bastante diferente al de otros lenguajes de programación comunes (C,Pascal,Java):Cada hilo tiene su propio montón (de basura)y compartir la memoria está restringido a variables globales.Esto ayuda a prevenir condiciones de raza.La eficiencia del GC se mejora bastante,porque el GC nunca tiene que detener a otros hilos y ver a qué se refieren.La asignación de memoria no requiere ningún bloqueo.Este diseño se escala fácilmente a procesadores multinúcleo masivos que se están convirtiendo en la norma.</target>
        </trans-unit>
        <trans-unit id="e16beba5be23dbf120604d9eac2a0b9733124873" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap, and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd526290438cb61dffae2d2e60576f140904aaf" translate="yes" xml:space="preserve">
          <source>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</source>
          <target state="translated">La sintaxis de objetos de Nim es rica.Echemos un vistazo a un ejemplo implicado en su totalidad para ver algunas de las complejidades.</target>
        </trans-unit>
        <trans-unit id="0d1938981c78468bfa1d2da1e306dcbcb6376cdd" translate="yes" xml:space="preserve">
          <source>Nim's parser</source>
          <target state="translated">El analizador de Nim</target>
        </trans-unit>
        <trans-unit id="acf2817c0d9f0b146da2d625488e15fe41115e79" translate="yes" xml:space="preserve">
          <source>Nim's standard grammar describes an &lt;span id=&quot;indentation-sensitive_1&quot;&gt;indentation sensitive&lt;/span&gt; language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</source>
          <target state="translated">La gram&amp;aacute;tica est&amp;aacute;ndar de Nim describe un lenguaje &lt;span id=&quot;indentation-sensitive_1&quot;&gt;sensible a la sangr&amp;iacute;a&lt;/span&gt; . Esto significa que todas las estructuras de control se reconocen por sangr&amp;iacute;a. La sangr&amp;iacute;a consta solo de espacios; no se permiten tabuladores.</target>
        </trans-unit>
        <trans-unit id="fb3af97ac3591e9d4487efae331e1cc3fe9eed9d" translate="yes" xml:space="preserve">
          <source>Nim's standard library only covers the basics, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; for a list of 3rd party packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77393f218a5f26531de32e76d9d12df341c291fa" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1452a3d3fd11615a428ccdddc1e755ffef521766" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator. Based on the &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor/rotate/shift/rotate) library.</source>
          <target state="translated">Generador de n&amp;uacute;meros aleatorios est&amp;aacute;ndar de Nim. Basado en la &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor / rotate / shift / rotate).</target>
        </trans-unit>
        <trans-unit id="e87220288cb1bb4d3284ac229d8e724411f9156a" translate="yes" xml:space="preserve">
          <source>NimCompilerApiVersion:</source>
          <target state="translated">NimCompilerApiVersion:</target>
        </trans-unit>
        <trans-unit id="035abfdda9b03c8237ac0a7feb0ced2c808a87c6" translate="yes" xml:space="preserve">
          <source>NimExt:</source>
          <target state="translated">NimExt:</target>
        </trans-unit>
        <trans-unit id="25a35361f773f4c4dde724d3ece4cf111ba2929b" translate="yes" xml:space="preserve">
          <source>NimProg:</source>
          <target state="translated">NimProg:</target>
        </trans-unit>
        <trans-unit id="8ab4b86e0c9b72c06707898687dc558effda2630" translate="yes" xml:space="preserve">
          <source>NimScript</source>
          <target state="translated">NimScript</target>
        </trans-unit>
        <trans-unit id="1060f5fe59141088954b97650581009ff437f63d" translate="yes" xml:space="preserve">
          <source>NimScript as a build tool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe85fa4503fd856c0b2c5b8e006bfb56700547e" translate="yes" xml:space="preserve">
          <source>NimScript as a configuration file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fb69363bbec3d3e7f963ac64cc9108bb1eb062" translate="yes" xml:space="preserve">
          <source>NimScript can also be used directly as a portable replacement for Bash and Batch files. Use &lt;code&gt;nim myscript.nims&lt;/code&gt; to run &lt;code&gt;myscript.nims&lt;/code&gt;. For example, installation of Nimble could be accomplished with this simple script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8119aecbfac41940b08449972bffe26657feb9" translate="yes" xml:space="preserve">
          <source>NimScript can detect on which platform, operating system, architecture, and even which Linux distribution is running on, allowing the same script to support a lot of systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f85d9adec2a4efa1b9102c81dbf387a3fb5e9d" translate="yes" xml:space="preserve">
          <source>NimScript can use Nim's templates, macros, types, concepts, effect tracking system, and more, you can create modules that work on compiled Nim and also on interpreted NimScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0d9ddce680baee1ba932a503b5444c9efc6dfe" translate="yes" xml:space="preserve">
          <source>NimScript evolves together with Nim, &lt;a href=&quot;https://github.com/nim-lang/Nim/pulls?utf8=%E2%9C%93&amp;amp;q=nimscript&quot;&gt;occasionally new features might become available on NimScript&lt;/a&gt; , adapted from compiled Nim or added as new features on both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402bcf2eebcea027b3675344e83beef6d49421ab" translate="yes" xml:space="preserve">
          <source>NimScript is subject to some limitations caused by the implementation of the VM (virtual machine):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa0a28931e2602b2a448ffe81a4e242e7826335" translate="yes" xml:space="preserve">
          <source>NimScripts also support &lt;code&gt;--&lt;/code&gt; templates for convenience, which look like command-line switches written as-is in the NimScript file. So the above example can be rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6b14412133ed2489b730e9fc4f06291eb4e8ce" translate="yes" xml:space="preserve">
          <source>Nimble</source>
          <target state="translated">Nimble</target>
        </trans-unit>
        <trans-unit id="26c03ddba53d901b234feb6fb87a68295b59cd08" translate="yes" xml:space="preserve">
          <source>Nimble integration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3bca65182fa05bd8858bec9a6e6900f87e2adf" translate="yes" xml:space="preserve">
          <source>Nimble is a package manager for the Nim programming language. For instructions on how to install Nimble packages see &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;its README&lt;/a&gt;.</source>
          <target state="translated">Nimble es un administrador de paquetes para el lenguaje de programaci&amp;oacute;n Nim. Para obtener instrucciones sobre c&amp;oacute;mo instalar paquetes de Nimble, consulte &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;su archivo README&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5013a2b58d23844e1296b43b0dea97d39a7cb11" translate="yes" xml:space="preserve">
          <source>Nimble metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2ec20dbc771a65435e830fecd7f56d930e7e15" translate="yes" xml:space="preserve">
          <source>Nimble support: Call this to set the list of requirements of your Nimble package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b2694a8c57bd7aa2c631729dbba47d2a27cc62" translate="yes" xml:space="preserve">
          <source>Nimble support: Set this to the package name. It is usually not required to do that, nims' filename is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed05e42072d36de3ae6f98f3a205cb1e71d91ba" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d931b828c900211ecdbb0924f07616c6d6f1c2" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d6064cefa030bc1c619c0d11551a8571e5d1cc" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's binary directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d30b4bc6cc39b452f5dc2c3f197ab1449217fe" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513e69b6157a08403fb5d2ef1ef15bb2da0988fc" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72740a9f91b96fbde6c9a0fcaa67f6da285a52a" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's source directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3cd36df69ddf669e773a85de7a62c85b77a507" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af01d1d4ff2ceea4a8135b93a3b16c4bb879507" translate="yes" xml:space="preserve">
          <source>Nimcache and C like targets</source>
          <target state="translated">Nimcache y C como objetivos</target>
        </trans-unit>
        <trans-unit id="d63113aa6032c199ac973f9c41b92f6b86bc69c5" translate="yes" xml:space="preserve">
          <source>Nimcache and the Javascript target</source>
          <target state="translated">Nimcache y el objetivo de Javascript</target>
        </trans-unit>
        <trans-unit id="7a7b1200d84cdfcc90e4068e405d16fe626da360" translate="yes" xml:space="preserve">
          <source>Nimcache naming logic</source>
          <target state="translated">La lógica de la denominación de Nimcache</target>
        </trans-unit>
        <trans-unit id="71db390f7498c8607ecf76f70925348383f07f46" translate="yes" xml:space="preserve">
          <source>Nimgrep has particularly good support for Nim's eccentric &lt;em&gt;style insensitivity&lt;/em&gt;. Apart from that it is a generic text manipulation tool.</source>
          <target state="translated">Nimgrep tiene un apoyo particularmente bueno para la &lt;em&gt;insensibilidad del estilo&lt;/em&gt; exc&amp;eacute;ntrico de Nim . Aparte de eso, es una herramienta gen&amp;eacute;rica de manipulaci&amp;oacute;n de texto.</target>
        </trans-unit>
        <trans-unit id="23ef2cadfc8ec56820149ad08675af48b8c2a012" translate="yes" xml:space="preserve">
          <source>Nimgrep is a command line tool for search&amp;amp;replace tasks. It can search for regex or peg patterns and can search whole directories at once. User confirmation for every single replace operation can be requested.</source>
          <target state="translated">Nimgrep es una herramienta de l&amp;iacute;nea de comandos para buscar y reemplazar tareas. Puede buscar patrones de regex o peg y puede buscar directorios completos a la vez. Se puede solicitar la confirmaci&amp;oacute;n del usuario para cada operaci&amp;oacute;n de reemplazo.</target>
        </trans-unit>
        <trans-unit id="b1cf2ee07bf536474f8a79eec9ae5297ea46f5b0" translate="yes" xml:space="preserve">
          <source>Nimsuggest for IDE support</source>
          <target state="translated">Nimsuggest para soporte IDE</target>
        </trans-unit>
        <trans-unit id="74dadd5fc671c88eec7c8cc084b2f4492ce2f149" translate="yes" xml:space="preserve">
          <source>Nimsuggest invocation</source>
          <target state="translated">Invocación de Nimsuggest</target>
        </trans-unit>
        <trans-unit id="5621d2e904ec7f4a1fa59a63968518771b43d445" translate="yes" xml:space="preserve">
          <source>Nimsuggest is part of Nim's core. Build it via:</source>
          <target state="translated">Nimsuggest es parte del núcleo de Nim.Constrúyelo a través de:</target>
        </trans-unit>
        <trans-unit id="b9338b400871e7a753e81682f58f03a8156017e7" translate="yes" xml:space="preserve">
          <source>Nimsuggest output is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">La salida de Nimsuggest siempre se devuelve en l&amp;iacute;neas individuales separadas por caracteres de tabulaci&amp;oacute;n ( &lt;code&gt;\t&lt;/code&gt; ). Los valores de cada columna son:</target>
        </trans-unit>
        <trans-unit id="5372c202a30284da7742441a108b564cdbdf5739" translate="yes" xml:space="preserve">
          <source>Nimsuggest than waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">Nimsuggest que espera a que se procesen las consultas. Una consulta consiste en un &quot;comando&quot; cr&amp;iacute;ptico de 3 letras &lt;code&gt;def&lt;/code&gt; o &lt;code&gt;con&lt;/code&gt; o &lt;code&gt;sug&lt;/code&gt; o &lt;code&gt;use&lt;/code&gt; seguido de una ubicaci&amp;oacute;n. Una ubicaci&amp;oacute;n de consulta consta de:</target>
        </trans-unit>
        <trans-unit id="8bffa4d8fa15634e3c256a4cb41638cf0bbf6c32" translate="yes" xml:space="preserve">
          <source>Nimsuggest then waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95165223d15af7cefab907c1e06b8b4044d588d9" translate="yes" xml:space="preserve">
          <source>Nimsuggest will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Nimsuggest siempre responderá con una sola definición o ninguna si no encuentra ningún símbolo válido que coincida con la posición de la consulta.</target>
        </trans-unit>
        <trans-unit id="cd6ee0acaba1530dda97aa7b3382ff72ed9f8236" translate="yes" xml:space="preserve">
          <source>Nimterlingua</source>
          <target state="translated">Nimterlingua</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5edb935fde1ba56536daaa6b349f01597bc5f8c0" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;&amp;lt;$xml ...$&amp;gt;&lt;/code&gt; declaration is produced, so that the produced XML fragments are composable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb05c02eb40dd8659b5825634b0887e886c359fc" translate="yes" xml:space="preserve">
          <source>No longer actually used</source>
          <target state="translated">Ya no se usa realmente</target>
        </trans-unit>
        <trans-unit id="62642b3249a520b5e9ec7c96e547e3faa1827969" translate="yes" xml:space="preserve">
          <source>No traffic is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b9c1b54338d8b9332efccba32605f983f91029" translate="yes" xml:space="preserve">
          <source>NoDecl pragma</source>
          <target state="translated">NoDeclarar pragmatismo</target>
        </trans-unit>
        <trans-unit id="4170d71a9c1c5f8428ffdc4348b9e7f9ec2ac4c6" translate="yes" xml:space="preserve">
          <source>Noalias annotation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889f402d84c133d41a3ffb2515b25c4ff5b1ea38" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;code&gt;delim&lt;/code&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c63e0618d33e20ddbbc5fcacaa83b0217e5a9a" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;em&gt;delim&lt;/em&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">Se pueden pasar delimitadores no predeterminados para permitir la iteraci&amp;oacute;n sobre otros tipos de registros de longitud variable &quot;similares a l&amp;iacute;neas&quot;. Pase eat = '\ 0' para estar &lt;em&gt;delimitado&lt;/em&gt; estrictamente . (No se admite el uso de un prefijo opcional igual a '\ 0').</target>
        </trans-unit>
        <trans-unit id="51982015db8c39d38da4e016c910ad96f798d0ca" translate="yes" xml:space="preserve">
          <source>Non-printing characters</source>
          <target state="translated">Caracteres que no se imprimen</target>
        </trans-unit>
        <trans-unit id="418bd9eb8597b90fb89b70c50e626f53d89d17ca" translate="yes" xml:space="preserve">
          <source>Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.</source>
          <target state="translated">Los valores numéricos no puros deben utilizar CamelCase,mientras que los valores numéricos puros deben utilizar PascalCase.</target>
        </trans-unit>
        <trans-unit id="f8d7bfd0d37a23478caf5e01ccd5869426102765" translate="yes" xml:space="preserve">
          <source>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with &lt;code&gt;'&lt;/code&gt;. An example:</source>
          <target state="translated">Los no terminales comienzan con una letra min&amp;uacute;scula, los s&amp;iacute;mbolos de terminales abstractos est&amp;aacute;n en MAY&amp;Uacute;SCULAS. Los s&amp;iacute;mbolos finales textuales (incluidas las palabras clave) se citan con &lt;code&gt;'&lt;/code&gt; . Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="2da5842ba2d454a52f2d4148a700d65ec1d538fd" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;code&gt;boundChecks&lt;/code&gt; option, those procs will raise an &lt;code&gt;IndexDefect&lt;/code&gt; on such access. This should not be relied upon, as &lt;code&gt;-d:danger&lt;/code&gt; or &lt;code&gt;--checks:off&lt;/code&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461551ab6e0521d38c563c8b4f15319bef024ec5" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;em&gt;boundChecks&lt;/em&gt; option, those procs will raise an &lt;em&gt;IndexError&lt;/em&gt; on such access. This should not be relied upon, as &lt;em&gt;-d:release&lt;/em&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">Ninguno de los procesos que obtienen un valor individual de la deque se puede usar en una deque vac&amp;iacute;a. Si se compila con la opci&amp;oacute;n &lt;em&gt;boundChecks&lt;/em&gt; , esos procesos generar&amp;aacute;n un &lt;em&gt;IndexError&lt;/em&gt; en dicho acceso. No se debe confiar en esto, ya que &lt;em&gt;-d: release&lt;/em&gt; desactivar&amp;aacute; esas comprobaciones y puede devolver basura o bloquear el programa.</target>
        </trans-unit>
        <trans-unit id="c1f993e0a0dd08ee915cc3e9cf167ebefdec7aa0" translate="yes" xml:space="preserve">
          <source>None:</source>
          <target state="translated">None:</target>
        </trans-unit>
        <trans-unit id="e62990a968e72898ad2b534a5d5ef0b2768deeb2" translate="yes" xml:space="preserve">
          <source>NoneLike:</source>
          <target state="translated">NoneLike:</target>
        </trans-unit>
        <trans-unit id="eb4fc459eedc650eb7092ee10047a19689f0d4cd" translate="yes" xml:space="preserve">
          <source>Nonoverloadable builtins</source>
          <target state="translated">Los componentes no sobrecargables</target>
        </trans-unit>
        <trans-unit id="a209e6fa751d79c5e7c6b6c0069fb20b224a488a" translate="yes" xml:space="preserve">
          <source>Normal Android apps are written in Java, to use Nim inside an Android app you need a small Java stub that calls out to a native library written in Nim using the &lt;a href=&quot;https://developer.android.com/ndk&quot;&gt;NDK&lt;/a&gt;. You can also use &lt;a href=&quot;https://developer.android.com/ndk/samples/sample_na&quot;&gt;native-activity&lt;/a&gt; to have the Java stub be auto-generated for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb66dc661861f381636ef80a030d6e4f15642186" translate="yes" xml:space="preserve">
          <source>Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hiearchy for document TOCs in the final index, and TOC entries found in &lt;code&gt;.nim&lt;/code&gt; files are discarded.</source>
          <target state="translated">Los s&amp;iacute;mbolos normales se agregan al &amp;iacute;ndice con los espacios en blanco circundantes eliminados. Una excepci&amp;oacute;n a esto son las entradas de la tabla de contenido (TOC). Las entradas de TOC se agregan al archivo de &amp;iacute;ndice y su tercera columna tiene tantos espacios de prefijo como su nivel en el TOC (al menos 1 car&amp;aacute;cter). El espacio en blanco del prefijo ayuda a filtrar las entradas de TOC de API o s&amp;iacute;mbolos de texto. Esto es importante porque la cantidad de espacios se usa para replicar la jerarqu&amp;iacute;a de las TOC de los documentos en el &amp;iacute;ndice final, y las entradas de TOC que se encuentran en los archivos &lt;code&gt;.nim&lt;/code&gt; se descartan.</target>
        </trans-unit>
        <trans-unit id="b2311ed7d695294572b2e47ef09cbf7395d919cc" translate="yes" xml:space="preserve">
          <source>Normalize a path.</source>
          <target state="translated">Normalizar un camino.</target>
        </trans-unit>
        <trans-unit id="88b967ed3ef7a6725101f93ac01771eb39040fe8" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;code&gt;s&lt;/code&gt; as a Nim identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23b19ce6bd569b872dfb26317c2ba486b398fed" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc401dc387c902dea14776d7f9bdd3484fd7eecd" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Normaliza la cadena &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="189e5cbc3b2e9402b7839197455dd96543d0d4ac" translate="yes" xml:space="preserve">
          <source>Not available for JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4111577c9d69153a097caeb5d59cb7772b3248" translate="yes" xml:space="preserve">
          <source>Not equals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b87a9d966e87007d02f8daaa4c946c260411a9b" translate="yes" xml:space="preserve">
          <source>Not nil annotation</source>
          <target state="translated">No es una anotación nula</target>
        </trans-unit>
        <trans-unit id="8e5e6194b87f5a890650f1c4bfbf0e220197df8e" translate="yes" xml:space="preserve">
          <source>Not nil annotations are not supported.</source>
          <target state="translated">No se admiten anotaciones nulas.</target>
        </trans-unit>
        <trans-unit id="7a8674a1a5764153c229b94ca832a584559616dd" translate="yes" xml:space="preserve">
          <source>Not predicate</source>
          <target state="translated">No es un predicado</target>
        </trans-unit>
        <trans-unit id="3d01d18bf9a6daa3fb19ea60a23f7dd70f8af43a" translate="yes" xml:space="preserve">
          <source>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</source>
          <target state="translated">No es un predicado:Indicar el fracaso si la expresión E coincide con el texto que sigue;de lo contrario,indicar el éxito.No consuma ningún texto.</target>
        </trans-unit>
        <trans-unit id="372ee3c9236cc0455481f60f3b86be209faab779" translate="yes" xml:space="preserve">
          <source>Not supported for JS backend, use &lt;a href=&quot;strutils#cmpIgnoreCase%2Cstring%2Cstring&quot;&gt;strutils.cmpIgnoreCase&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c6219b3ee58abf2bacef53dd21d8b78344d8d7" translate="yes" xml:space="preserve">
          <source>Not supported for JS backend, use &lt;a href=&quot;strutils#cmpIgnoreStyle%2Cstring%2Cstring&quot;&gt;strutils.cmpIgnoreStyle&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb537afc8ef61289c5a65dac8f48c5cd88026a7d" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,Natural,int&quot;&gt;find proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542c73c0783f6a29758964ce1947b79cd5d16744" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find() proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">No es muy &amp;uacute;til por s&amp;iacute; solo, puede usarlo para crear conjuntos &lt;em&gt;invertidos&lt;/em&gt; para hacer que el proceso &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find ()&lt;/a&gt; encuentre caracteres &lt;strong&gt;no v&amp;aacute;lidos&lt;/strong&gt; en cadenas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="04228ae1050018eb31f9f0fcb6a78ef941137a15" translate="yes" xml:space="preserve">
          <source>Note how the built-in &lt;code&gt;len&lt;/code&gt; proc returns only the array's first dimension length. Another way of defining the &lt;code&gt;LightTower&lt;/code&gt; to better illustrate its nested nature would be to omit the previous definition of the &lt;code&gt;LevelSetting&lt;/code&gt; type and instead write it embedded directly as the type of the first dimension:</source>
          <target state="translated">Observe c&amp;oacute;mo el proceso &lt;code&gt;len&lt;/code&gt; incorporado devuelve solo la longitud de la primera dimensi&amp;oacute;n de la matriz. Otra forma de definir &lt;code&gt;LightTower&lt;/code&gt; para ilustrar mejor su naturaleza anidada ser&amp;iacute;a omitir la definici&amp;oacute;n anterior del tipo &lt;code&gt;LevelSetting&lt;/code&gt; y, en su lugar, escribirla incorporada directamente como el tipo de la primera dimensi&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cd3704db1df15da0eb18abb96f396dc8315f28b4" translate="yes" xml:space="preserve">
          <source>Note how the example contains extra C code to declare the &lt;code&gt;iupdll&lt;/code&gt; symbol in the generated Nim code.</source>
          <target state="translated">Observe c&amp;oacute;mo el ejemplo contiene c&amp;oacute;digo C adicional para declarar el s&amp;iacute;mbolo &lt;code&gt;iupdll&lt;/code&gt; en el c&amp;oacute;digo Nim generado.</target>
        </trans-unit>
        <trans-unit id="33e40503f2c45525bd696a9b1577019e4a6a54a7" translate="yes" xml:space="preserve">
          <source>Note how the set turns enum values into powers of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9897f075d01f2091487e98593989f12def2c9e19" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$app&lt;/code&gt;, &lt;code&gt;$appname&lt;/code&gt;, and &lt;code&gt;$appdir&lt;/code&gt; are not supported when using the JavaScript backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a791309560be143e9e6f64f7aa9877ff5cada7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TimeInterval&lt;/code&gt; doesn't represent a fixed duration of time, since the duration of some units depend on the context (e.g a year can be either 365 or 366 days long). The non-fixed time units are years, months, days and week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94766cead949b3e8ea24b0db0a77a97e426ab4e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TimeInterval&lt;/code&gt;'s returned from the &lt;code&gt;times&lt;/code&gt; module are never normalized. If you want to normalize a time unit, &lt;a href=&quot;#Duration&quot;&gt;Duration&lt;/a&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf4a48e6d5642c56029b0227b694330e642ab42" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ashr&lt;/code&gt; is not an operator so use the normal function call syntax for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6b9b4ceabc50bdb117bfb8df4ea521f2a5d675" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getCurrentException&lt;/code&gt; always returns a &lt;code&gt;ref Exception&lt;/code&gt; type. If a variable of the proper type is needed (in the example above, &lt;code&gt;IOError&lt;/code&gt;), one must convert it explicitly:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;getCurrentException&lt;/code&gt; siempre devuelve un tipo de &lt;code&gt;ref Exception&lt;/code&gt; . Si se necesita una variable del tipo adecuado (en el ejemplo anterior, &lt;code&gt;IOError&lt;/code&gt; ), se debe convertir expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="15f8bf07037666cd628faf3d8b1289a1ebbe6888" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import math as m&lt;/code&gt; does not use a different node; rather, we use &lt;code&gt;nnkImportStmt&lt;/code&gt; with &lt;code&gt;as&lt;/code&gt; as an infix operator.</source>
          <target state="translated">Tenga en cuenta que la &lt;code&gt;import math as m&lt;/code&gt; no usa un nodo diferente; m&amp;aacute;s bien, usamos &lt;code&gt;nnkImportStmt&lt;/code&gt; con &lt;code&gt;as&lt;/code&gt; que un operador infijo.</target>
        </trans-unit>
        <trans-unit id="3850a394097e20f4e139b6c553e491a35ada914b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5663a783c31085b10a438aaa39d48ac8ef1674" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;system.finished&lt;/code&gt; is error prone to use because it only returns &lt;code&gt;true&lt;/code&gt; one iteration after the iterator has finished:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;system.finished&lt;/code&gt; es propenso a errores porque solo devuelve &lt;code&gt;true&lt;/code&gt; una iteraci&amp;oacute;n despu&amp;eacute;s de que el iterador haya finalizado:</target>
        </trans-unit>
        <trans-unit id="bc55a86bc2176f00ed0cc4a2ced7592a3287c04a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since the untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65e48edf1a92ed7ba69b341dc76ceb955ed905a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el &lt;code&gt;using&lt;/code&gt; no se aplica a la &lt;code&gt;template&lt;/code&gt; ya que los par&amp;aacute;metros de la plantilla sin tipo son los predeterminados del tipo &lt;code&gt;system.untyped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eaa79a5d51a878bd30d77cb48d9cf5f64b35ea7" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que los literales de cadena sin formato extendidos de Nim admiten la sintaxis &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; como forma abreviada de &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541571b7bbe9cf9e61fcadf529c49d38c395b8d1" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;. Also note that since this compiles the regular expression, which is expensive, you should avoid putting it directly in the arguments of the functions like the examples show below if you plan to use it a lot of times, as this will hurt performance immensely. (e.g. outside a loop, ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66958a893582569a32abe154668c902b04b269b9" translate="yes" xml:space="preserve">
          <source>Note that a duration can be negative, so even if &lt;code&gt;a &amp;lt; b&lt;/code&gt; is true &lt;code&gt;a&lt;/code&gt; might represent a larger absolute duration. Use &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; to compare the absolute duration.</source>
          <target state="translated">Tenga en cuenta que una duraci&amp;oacute;n puede ser negativa, por lo que incluso si &lt;code&gt;a &amp;lt; b&lt;/code&gt; es verdadera, &lt;code&gt;a&lt;/code&gt; podr&amp;iacute;a representar una duraci&amp;oacute;n absoluta mayor. Utilice &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; para comparar la duraci&amp;oacute;n absoluta.</target>
        </trans-unit>
        <trans-unit id="11d04164bd578d4758910d31096e77690bec376a" translate="yes" xml:space="preserve">
          <source>Note that a message's level is still checked against each handler's &lt;code&gt;levelThreshold&lt;/code&gt; and the global log filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a61e95866e9147c08e9c2d0fd1b10e87385ea4" translate="yes" xml:space="preserve">
          <source>Note that an explicit array constructor passed to a &lt;code&gt;varargs&lt;/code&gt; parameter is not wrapped in another implicit array construction:</source>
          <target state="translated">Tenga en cuenta que un constructor de matriz expl&amp;iacute;cito pasado a un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; no est&amp;aacute; envuelto en otra construcci&amp;oacute;n de matriz impl&amp;iacute;cita:</target>
        </trans-unit>
        <trans-unit id="580208a43972b50356da5b1da0797b119e251075" translate="yes" xml:space="preserve">
          <source>Note that at the moment the word &lt;code&gt;proc&lt;/code&gt; is returned for the signature of the found method instead of the expected &lt;code&gt;method&lt;/code&gt;. This may change in the future.</source>
          <target state="translated">Tenga en cuenta que en este momento se devuelve la palabra &lt;code&gt;proc&lt;/code&gt; para la firma del m&amp;eacute;todo encontrado en lugar del &lt;code&gt;method&lt;/code&gt; esperado . Esto puede cambiar en el futuro.</target>
        </trans-unit>
        <trans-unit id="24c487cedc7c752e18df39ebc5ba3ec45556047e" translate="yes" xml:space="preserve">
          <source>Note that container &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt; and it is required for your input and output types to be the same, since &lt;code&gt;s&lt;/code&gt; is modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a1d492f470ea3d6702b7d65ba7a1f02a7ad547" translate="yes" xml:space="preserve">
          <source>Note that container &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt; and it is required for your input and output types to be the same, since &lt;code&gt;s&lt;/code&gt; is modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe89c735f73e47df7589d2ce0f730288a5b272a5" translate="yes" xml:space="preserve">
          <source>Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will &lt;em&gt;unroll&lt;/em&gt; the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! For safety use side-effect free procedures if making multiple assignments.</source>
          <target state="translated">Tenga en cuenta que declarar m&amp;uacute;ltiples variables con una sola asignaci&amp;oacute;n que llama a un procedimiento puede tener resultados inesperados: el compilador &lt;em&gt;desenrollar&amp;aacute;&lt;/em&gt; las asignaciones y terminar&amp;aacute; llamando al procedimiento varias veces. Si el resultado del procedimiento depende de los efectos secundarios, &amp;iexcl;sus variables pueden terminar teniendo valores diferentes! Por seguridad, utilice procedimientos sin efectos secundarios si realiza varias asignaciones.</target>
        </trans-unit>
        <trans-unit id="c80f0b7fe87a1023b9ef2a3f07090c0f9848e853" translate="yes" xml:space="preserve">
          <source>Note that due to Nim's parameter passing semantics this means that &lt;code&gt;T&lt;/code&gt; doesn't need to be copied so &lt;code&gt;awaitAndThen&lt;/code&gt; can sometimes be more efficient than &lt;a href=&quot;#%5E,FlowVar%5BT%5D&quot;&gt;^ proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fc07cec95ec5e1fead7b4c0cc4bdbd5f963690" translate="yes" xml:space="preserve">
          <source>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</source>
          <target state="translated">Obsérvese que deben existir el segundo o el tercer parámetro (o ambos)arriba mencionados,ya que el compilador necesita conocer el tipo de alguna manera (que puede deducir de la asignación dada).</target>
        </trans-unit>
        <trans-unit id="315d31332dc9316e7f3826cb4f065e4db97ff67a" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe! Also, Nim's runtime type information will evolve and may eventually be deprecated. As an alternative approach to programmatically understanding and manipulating types, consider using the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; package to work with the types' AST representation at compile time. See, for example, the &lt;a href=&quot;macros#getTypeImpl,NimNode&quot;&gt;getTypeImpl proc&lt;/a&gt;. As an alternative approach to storing arbitrary types at runtime, consider using generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa4224474e4b6c80954422260464c3b4a8019a5" translate="yes" xml:space="preserve">
          <source>Note that for floats, the result cannot always be interpreted as &quot;greatest decimal &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;z*N == x and z*M == y&lt;/code&gt; where N and M are positive integers.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3974a69d8025c1886c72445a8fb4b0c0716b4564" translate="yes" xml:space="preserve">
          <source>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</source>
          <target state="translated">Obsérvese que para los sistemas con una pila continua (que es lo que tienen la mayoría de los sistemas)la comprobación de si el árbitro está en la pila es muy barata (sólo dos comparaciones).</target>
        </trans-unit>
        <trans-unit id="9d1f8d76ba4bd5c129c2a18a24e1dab11a14ed65" translate="yes" xml:space="preserve">
          <source>Note that in most circumstances one should only disable the mark and sweep phase with &lt;a href=&quot;#GC_disableMarkAndSweep&quot;&gt;GC_disableMarkAndSweep&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e095193050971ff047ad4d5c8afbbc2efec37383" translate="yes" xml:space="preserve">
          <source>Note that in the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because it makes more sense for them to use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">Tenga en cuenta que en el ejemplo los constructores &lt;code&gt;newLit&lt;/code&gt; y &lt;code&gt;newPlus&lt;/code&gt; son procs porque tiene m&amp;aacute;s sentido que usen enlaces est&amp;aacute;ticos, pero &lt;code&gt;eval&lt;/code&gt; es un m&amp;eacute;todo porque requiere enlaces din&amp;aacute;micos.</target>
        </trans-unit>
        <trans-unit id="ba700b00e3387a40d1683b4c05ca6858e147eb43" translate="yes" xml:space="preserve">
          <source>Note that it is space sensitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ad541deafb8f63a37e09491c7556544b9d95b3" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11be0dfde35904fa7f02afe90c20970ebac48dfb" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">Tenga en cuenta que no todos los &lt;code&gt;nnkTypeDef&lt;/code&gt; utilizan &lt;code&gt;nnkIdent&lt;/code&gt; como su par&amp;aacute;metro. Uno de los usos m&amp;aacute;s comunes de las declaraciones de tipos es trabajar con objetos.</target>
        </trans-unit>
        <trans-unit id="0224a1f68a8585cd4a55cb358bf685741b3afb31" translate="yes" xml:space="preserve">
          <source>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</source>
          <target state="translated">Tenga en cuenta que los valores octales de 100 o más no deben ser introducidos por un cero inicial,porque nunca se leen más de tres dígitos octales.</target>
        </trans-unit>
        <trans-unit id="359593d58b85b30432eb40cd29b67c1829ffd3da" translate="yes" xml:space="preserve">
          <source>Note that one can use &lt;code&gt;gorge&lt;/code&gt; from the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt; to embed parameters from an external command that will be executed during semantic analysis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0c14568cc44b3aa6b93616a9638e1e67aa608b" translate="yes" xml:space="preserve">
          <source>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</source>
          <target state="translated">Tenga en cuenta que,como se trata de un iterador,no debe modificar la cadena sobre la que está iterando:podrían ocurrir cosas malas.</target>
        </trans-unit>
        <trans-unit id="0c6ff8ba25ceb642b409cfabb3508e2a2e6d8e4b" translate="yes" xml:space="preserve">
          <source>Note that some floating point numbers (e.g. infinity or even 1e19) cannot be accurately converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e26b1561a3f022726ef326aaca35071eca0d805" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Time&lt;/code&gt; argument does not represent a point in time, it represent a local time! E.g if &lt;code&gt;adjTime&lt;/code&gt; is &lt;code&gt;fromUnix(0)&lt;/code&gt;, it should be interpreted as 1970-01-01T00:00:00 in the &lt;code&gt;zone&lt;/code&gt; timezone, not in UTC.</source>
          <target state="translated">Tenga en cuenta que el argumento &lt;code&gt;Time&lt;/code&gt; no representa un punto en el tiempo, &amp;iexcl;representa una hora local! Por ejemplo, si &lt;code&gt;adjTime&lt;/code&gt; es &lt;code&gt;fromUnix(0)&lt;/code&gt; , debe interpretarse como 1970-01-01T00: 00: 00 en la &lt;code&gt;zone&lt;/code&gt; horaria, no en UTC.</target>
        </trans-unit>
        <trans-unit id="ff3153be7f62193c7a012288373ef96e64821a33" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;importcpp&lt;/code&gt; variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</source>
          <target state="translated">Tenga en cuenta que la variante &lt;code&gt;importcpp&lt;/code&gt; para procs usa un lenguaje de patrones algo cr&amp;iacute;ptico para una m&amp;aacute;xima flexibilidad:</target>
        </trans-unit>
        <trans-unit id="f79f9b3f84579ddfcfc49f356b7732e51770554f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;jsondoc&lt;/code&gt; command outputs it's JSON without pretty-printing it, while &lt;code&gt;jsondoc0&lt;/code&gt; outputs pretty-printed JSON.</source>
          <target state="translated">Tenga en cuenta que el comando &lt;code&gt;jsondoc&lt;/code&gt; genera su JSON sin tener una impresi&amp;oacute;n bonita, mientras que &lt;code&gt;jsondoc0&lt;/code&gt; genera JSON con una impresi&amp;oacute;n bonita.</target>
        </trans-unit>
        <trans-unit id="e1b7da4962a08c6b2249b0042ce79badfd4c9b0e" translate="yes" xml:space="preserve">
          <source>Note that the compiler maps that to the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; construct of &lt;span id=&quot;openmp_1&quot;&gt;OpenMP&lt;/span&gt; and as such isn't aware of the parallelism in your code! Be careful! Later versions of &lt;code&gt;||&lt;/code&gt; will get proper support by Nim's code generator and GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a40c5d3a6d57a617cae578c4709a1aa7f56b0c" translate="yes" xml:space="preserve">
          <source>Note that the compiler maps that to the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; construct of &lt;span id=&quot;openmp_2&quot;&gt;OpenMP&lt;/span&gt; and as such isn't aware of the parallelism in your code! Be careful! Later versions of &lt;code&gt;||&lt;/code&gt; will get proper support by Nim's code generator and GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ac3d817acc6699555135aadc50a22472888948" translate="yes" xml:space="preserve">
          <source>Note that the default generator always starts in the same state. The &lt;a href=&quot;#randomize&quot;&gt;randomize proc&lt;/a&gt; can be called to initialize the default generator with a seed based on the current time, and it only needs to be called once before the first usage of procs from this module. If &lt;code&gt;randomize&lt;/code&gt; is not called, then the default generator will always produce the same results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0657a4b90e474cfb90775d71e0fec2c9d65f4786" translate="yes" xml:space="preserve">
          <source>Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">Tenga en cuenta que la codificación no puede ser cambiada una vez que se ha establecido.Según la documentación de SQLite3,cualquier intento de cambiar la codificación después de que se cree la base de datos será ignorado silenciosamente.</target>
        </trans-unit>
        <trans-unit id="9cb042b8b29c59f41b3cd0e948e779e25db65a35" translate="yes" xml:space="preserve">
          <source>Note that the module name is still &lt;code&gt;strutils&lt;/code&gt; and not &lt;code&gt;lib/pure/strutils&lt;/code&gt; and so one &lt;strong&gt;cannot&lt;/strong&gt; do:</source>
          <target state="translated">Tenga en cuenta que el nombre del m&amp;oacute;dulo sigue siendo &lt;code&gt;strutils&lt;/code&gt; y no &lt;code&gt;lib/pure/strutils&lt;/code&gt; , por lo que &lt;strong&gt;no se puede&lt;/strong&gt; hacer:</target>
        </trans-unit>
        <trans-unit id="343c37cc8e2a037df9dff1a349a478f071828d8b" translate="yes" xml:space="preserve">
          <source>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</source>
          <target state="translated">Observe que el lenguaje de patrones naturalmente también cubre las capacidades de sobrecarga del operador de C++:</target>
        </trans-unit>
        <trans-unit id="8cde912a6f95d6bc0c0ad134a4919451e220d036" translate="yes" xml:space="preserve">
          <source>Note that the regular expression does not behave as intended either: in the example &lt;code&gt;*&lt;/code&gt; should not be greedy, so &lt;code&gt;\[.*?\]&lt;/code&gt; should be used instead.</source>
          <target state="translated">Tenga en cuenta que la expresi&amp;oacute;n regular tampoco se comporta como se esperaba: en el ejemplo &lt;code&gt;*&lt;/code&gt; no deber&amp;iacute;a ser codicioso, por lo que se deber&amp;iacute;a utilizar &lt;code&gt;\[.*?\]&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="f120496e6d813c76cb6c4055f029e22950f8809c" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be &lt;code&gt;nil&lt;/code&gt;. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">Tenga en cuenta que la secuencia se rellenar&amp;aacute; con entradas cero, lo que puede ser un problema para las secuencias que contienen cadenas, ya que su valor ser&amp;aacute; &lt;code&gt;nil&lt;/code&gt; . Despu&amp;eacute;s de la creaci&amp;oacute;n de la secuencia, debe asignar entradas a la secuencia en lugar de agregarlas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="de5af658288d60206e55385523786da7d39f926a" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2997a3fd7a7a4785860a47b62d4eebe1a899d888" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f32cf721122a35c0f4af8b0ef39f1b57a1cde09" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;a href=&quot;#degToRad,T&quot;&gt;degToRad&lt;/a&gt; and &lt;a href=&quot;#radToDeg,T&quot;&gt;radToDeg&lt;/a&gt; provide conversion between radians and degrees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afc5e4454ca57a472753d975721911248348abc" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;em&gt;degToRad&lt;/em&gt; and &lt;em&gt;radToDeg&lt;/em&gt; provide conversion between radians and degrees.</source>
          <target state="translated">Tenga en cuenta que las funciones trigonom&amp;eacute;tricas operan naturalmente en radianes. Las funciones auxiliares &lt;em&gt;degToRad&lt;/em&gt; y &lt;em&gt;radToDeg&lt;/em&gt; proporcionan conversi&amp;oacute;n entre radianes y grados.</target>
        </trans-unit>
        <trans-unit id="b39e62dfdcac76acc3788b0504467d241681c022" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="translated">Tenga en cuenta que puede haber excepciones a estas reglas. Nim, siendo tan flexible como es, habr&amp;aacute; partes de esta gu&amp;iacute;a de estilo que no tienen sentido en ciertos contextos. Adem&amp;aacute;s, as&amp;iacute; como &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;la gu&amp;iacute;a de estilo de Python&lt;/a&gt; cambia con el tiempo, esta gu&amp;iacute;a de estilo tambi&amp;eacute;n lo har&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="f45c1e74fbf037d56e89d6aed23541b59684fe6f" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;https://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fed77603f9454dbdef2e75534af23ed17061d9e" translate="yes" xml:space="preserve">
          <source>Note that this is a &lt;em&gt;runtime&lt;/em&gt; call and using &lt;code&gt;quit&lt;/code&gt; inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; or &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; pragmas.</source>
          <target state="translated">Tenga en cuenta que esta es una llamada en &lt;em&gt;tiempo de ejecuci&amp;oacute;n&lt;/em&gt; y el uso de &lt;code&gt;quit&lt;/code&gt; dentro de una macro no tendr&amp;aacute; ning&amp;uacute;n efecto en el tiempo de compilaci&amp;oacute;n. Si necesita detener el compilador dentro de una macro, use los pragmas de &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; o &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04eea85d84506e2be9f7ff640da1764e6c3b0050" translate="yes" xml:space="preserve">
          <source>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</source>
          <target state="translated">Nótese que esta es básicamente la única forma de inferencia de tipo que existe en Nim:es un buen compromiso entre la brevedad y la legibilidad.</target>
        </trans-unit>
        <trans-unit id="58d880698f829e5e05f8d05a0d0ab0bc71e4e33a" translate="yes" xml:space="preserve">
          <source>Note that this pragma has been abused in the past to also work in the js backend for js objects and functions. : Other backends do provide the same feature under the same name. Also, when the target language is not set to C, other pragmas are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca57587cd09e4fd62d9d47bd97a7a8675351ea8c" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</source>
          <target state="translated">Tengan en cuenta que este pragmatismo es un nombre poco apropiado:Otros backends proporcionan la misma característica bajo el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="6aa0aaed3cc81e0439834c7c529aa1845e5383d7" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name. Also, if one is interfacing with C++ the &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; and interfacing with Objective-C the &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC pragma&lt;/a&gt; can be used.</source>
          <target state="translated">Tenga en cuenta que este pragma es un nombre poco apropiado: otros backends proporcionan la misma funci&amp;oacute;n con el mismo nombre. Adem&amp;aacute;s, si uno est&amp;aacute; interactuando con C ++, se puede &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;utilizar el pragma ImportCpp&lt;/a&gt; y con Objective-C, se puede utilizar el &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;pragma ImportObjC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5d063d7e7c89bcb1be31e9838c1418c3a823324" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">Tenga en cuenta que esto requiere que los tipos de entrada y salida sean los mismos, ya que se modifican en el lugar. La funci&amp;oacute;n de par&amp;aacute;metro toma un par&amp;aacute;metro de tipo &lt;code&gt;var T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd22634c739d8b9963ba6240e6f789a4901df14" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">Tenga en cuenta que esto requiere que los tipos de entrada y salida sean los mismos, ya que se modifican en el lugar. La funci&amp;oacute;n de par&amp;aacute;metro toma y devuelve una variable de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0ca87ec29ac7228de79e4d262997ceff6fd5ce6" translate="yes" xml:space="preserve">
          <source>Note that this rule also applies to keywords, meaning that &lt;code&gt;notin&lt;/code&gt; is the same as &lt;code&gt;notIn&lt;/code&gt; and &lt;code&gt;not_in&lt;/code&gt; (all-lowercase version (&lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt;) is the preferred way of writing keywords).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e73723c67698a4db4dbcdaa04c4f3387732c63" translate="yes" xml:space="preserve">
          <source>Note that this version of &lt;code&gt;map&lt;/code&gt; requires your input and output types to be the same, since they are modified in-place.</source>
          <target state="translated">Tenga en cuenta que esta versi&amp;oacute;n del &lt;code&gt;map&lt;/code&gt; a requiere que los tipos de entrada y salida sean los mismos, ya que se modifican en el lugar.</target>
        </trans-unit>
        <trans-unit id="35a43adebbe7d9517e28187d2c67478e70dbaf9e" translate="yes" xml:space="preserve">
          <source>Note that type inference works for parameters with default values; there is no need to write &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt;, for example.</source>
          <target state="translated">Tenga en cuenta que la inferencia de tipos funciona para par&amp;aacute;metros con valores predeterminados; no es necesario escribir &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">Obsérvese que,a menos que se defina un ancho de campo mínimo,el ancho de campo será siempre del mismo tamaño que los datos para rellenarlo,por lo que la opción de alineación no tiene sentido en este caso.</target>
        </trans-unit>
        <trans-unit id="a4f6df5cd8b79acdb0c70f5d30510d6e8cdfa162" translate="yes" xml:space="preserve">
          <source>Note that unordered or ordered choice operators (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) are not implemented.</source>
          <target state="translated">Tenga en cuenta que los operadores de elecci&amp;oacute;n ordenados o desordenados ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ) no est&amp;aacute;n implementados.</target>
        </trans-unit>
        <trans-unit id="21df650805f0f9da23f06c6e6caddf7af086fddf" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;code&gt;31 October&lt;/code&gt; will result in &lt;code&gt;31 November&lt;/code&gt;, which will overflow and result in &lt;code&gt;1 December&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f37b4c7971dff9f25702efc2db169764ea60985" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;em&gt;31 October&lt;/em&gt; will result in &lt;em&gt;31 November&lt;/em&gt;, which will overflow and result in &lt;em&gt;1 December&lt;/em&gt;.</source>
          <target state="translated">Tenga en cuenta que al agregar meses, se permite el desbordamiento del d&amp;iacute;a del mes. Esto significa que si el mes resultante no tiene suficientes d&amp;iacute;as, el mes se incrementar&amp;aacute; y el d&amp;iacute;a del mes se establecer&amp;aacute; en el n&amp;uacute;mero de d&amp;iacute;as desbordados. Entonces, agregar un mes al &lt;em&gt;31 de octubre&lt;/em&gt; dar&amp;aacute; como resultado el &lt;em&gt;31 de noviembre&lt;/em&gt; , que se desbordar&amp;aacute; y dar&amp;aacute; como resultado el &lt;em&gt;1 de diciembre&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="768312a6255dc501e7c26889c546bd253fd2aec8" translate="yes" xml:space="preserve">
          <source>Note that when passing objects to procedures on another thread by pointer (for example through a thread's argument), objects created using the default allocator will use thread-local, GC-managed memory. Thus it is generally safer to store channel objects in global variables (as in the above example), in which case they will use a process-wide (thread-safe) shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4120fed8da8d3978e684516d5bde06baadb627e" translate="yes" xml:space="preserve">
          <source>Note that while the value returned is of type &lt;code&gt;var B&lt;/code&gt;, it is easy to accidentally create an copy of the value at &lt;code&gt;t[key]&lt;/code&gt;. Remember that seqs and strings are value types, and therefore cannot be copied into a separate variable for modification. See the example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f7073771e81c9dae2114aa3af0598ed46cf0ad" translate="yes" xml:space="preserve">
          <source>Note that with multiple infix operators, the command is parsed by operator precedence.</source>
          <target state="translated">Tenga en cuenta que con múltiples operadores de infijo,el comando es analizado por la precedencia del operador.</target>
        </trans-unit>
        <trans-unit id="c76fa1132c9049877899fb2dd217fb4f9fb94f6c" translate="yes" xml:space="preserve">
          <source>Note that without the &lt;em&gt;*&lt;/em&gt; following the name of the type, the documentation for this type would not be generated. Documentation will only be generated for &lt;em&gt;exported&lt;/em&gt; types/procedures/etc.</source>
          <target state="translated">Tenga en cuenta que sin el &lt;em&gt;* que&lt;/em&gt; sigue al nombre del tipo, no se generar&amp;iacute;a la documentaci&amp;oacute;n para este tipo. La documentaci&amp;oacute;n solo se generar&amp;aacute; para tipos / procedimientos / etc. &lt;em&gt;exportados&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="83dc7e0556afc26215f0f05cbb05794c79af8e39" translate="yes" xml:space="preserve">
          <source>Note that you can use &lt;code&gt;gorge&lt;/code&gt; from the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt; to embed parameters from an external command at compile time:</source>
          <target state="translated">Tenga en cuenta que puede usar &lt;code&gt;gorge&lt;/code&gt; desde el &lt;a href=&quot;system&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; del sistema para insertar par&amp;aacute;metros de un comando externo en el momento de la compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="03602da7fc5f3527dab2cb6a5e9fa3d6f417f9f6" translate="yes" xml:space="preserve">
          <source>Note that you can use this proc inside a pragma like &lt;a href=&quot;manual#implementation-specific-pragmas-passc-pragma&quot;&gt;passc&lt;/a&gt; or &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;passl&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75dacd50fe5a788cdf642a67310a4f0cc7d7c77" translate="yes" xml:space="preserve">
          <source>Note that you can't pass any &lt;code&gt;args&lt;/code&gt; if you use the option &lt;code&gt;poEvalCommand&lt;/code&gt;, which invokes the system shell to run the specified &lt;code&gt;command&lt;/code&gt;. In this situation you have to concatenate manually the contents of &lt;code&gt;args&lt;/code&gt; to &lt;code&gt;command&lt;/code&gt; carefully escaping/quoting any special characters, since it will be passed &lt;em&gt;as is&lt;/em&gt; to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8772d3554a687071842e284d2ee1e51238d62e" translate="yes" xml:space="preserve">
          <source>Note that you can't pass any &lt;em&gt;args&lt;/em&gt; if you use the option &lt;code&gt;poEvalCommand&lt;/code&gt;, which invokes the system shell to run the specified &lt;em&gt;command&lt;/em&gt;. In this situation you have to concatenate manually the contents of &lt;em&gt;args&lt;/em&gt; to &lt;em&gt;command&lt;/em&gt; carefully escaping/quoting any special characters, since it will be passed &lt;em&gt;as is&lt;/em&gt; to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.</source>
          <target state="translated">Tenga en cuenta que no puede pasar ning&amp;uacute;n &lt;em&gt;argumento&lt;/em&gt; si usa la opci&amp;oacute;n &lt;code&gt;poEvalCommand&lt;/code&gt; , que invoca el shell del sistema para ejecutar el &lt;em&gt;comando&lt;/em&gt; especificado . En esta situaci&amp;oacute;n, debe concatenar manualmente el contenido de los &lt;em&gt;argumentos&lt;/em&gt; para &lt;em&gt;ordenar con&lt;/em&gt; cuidado escapando / citando cualquier car&amp;aacute;cter especial, ya que se pasar&amp;aacute; &lt;em&gt;tal cual&lt;/em&gt; al shell del sistema. Cada sistema / shell puede presentar diferentes reglas de escape, as&amp;iacute; que trate de evitar este tipo de invocaci&amp;oacute;n de shell si es posible, ya que conduce a software no port&amp;aacute;til.</target>
        </trans-unit>
        <trans-unit id="d40b1f043c53ab114d44579b20fed14c54f78029" translate="yes" xml:space="preserve">
          <source>Note that you cannot compare a floating point value to this value and expect a reasonable result - use the &lt;code&gt;classify&lt;/code&gt; procedure in the &lt;a href=&quot;math&quot;&gt;math module&lt;/a&gt; for checking for NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5592912b54a15cb049ee1308dc422e794cf8b0" translate="yes" xml:space="preserve">
          <source>Note that, unlike tuples, objects require the field names along with their values. For a &lt;code&gt;ref object&lt;/code&gt; type &lt;code&gt;system.new&lt;/code&gt; is invoked implicitly.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de las tuplas, los objetos requieren los nombres de campo junto con sus valores. Para un tipo de &lt;code&gt;ref object&lt;/code&gt; &lt;code&gt;system.new&lt;/code&gt; se invoca impl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="4fe2a6b6231ef8afd037c1399752e71468fb5fa7" translate="yes" xml:space="preserve">
          <source>Note, single letter options that take an argument require a colon. E.g. -p:PATH.</source>
          <target state="translated">Nota,las opciones de una sola letra que toman un argumento requieren dos puntos.Por ejemplo,-p:PATH.</target>
        </trans-unit>
        <trans-unit id="1a7f5bb7cac3eb28fa52efeaad9afaa0e45fe5ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;a&lt;/code&gt; can only be part of &lt;code&gt;b&lt;/code&gt;, if &lt;code&gt;a&lt;/code&gt;'s type can be part of &lt;code&gt;b&lt;/code&gt;'s type. Since however type analysis is more expensive, we perform it only if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b4d4771d7ff34d7e5d420650862df593a32f84" translate="yes" xml:space="preserve">
          <source>Note: Ensure the original #define is not seen by c2nim (notice the #ifndef C2NIM).</source>
          <target state="translated">Nota:Asegúrate de que el #define original no sea visto por c2nim (nota el #ifndef C2NIM).</target>
        </trans-unit>
        <trans-unit id="589daca808645da8bffbebba1f4a3d7ffd0724bc" translate="yes" xml:space="preserve">
          <source>Note: For inter thread communication use a &lt;a href=&quot;channels&quot;&gt;Channel&lt;/a&gt; instead.</source>
          <target state="translated">Nota: Para la comunicaci&amp;oacute;n entre hilos, utilice un &lt;a href=&quot;channels&quot;&gt;canal en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="3c98c05550ca8db8ba1bb08e3e1cdb582a3c0958" translate="yes" xml:space="preserve">
          <source>Note: Import &lt;code&gt;std/sha1&lt;/code&gt; to use this module</source>
          <target state="translated">Nota: Importe &lt;code&gt;std/sha1&lt;/code&gt; para usar este m&amp;oacute;dulo</target>
        </trans-unit>
        <trans-unit id="a3380d8cd20bf5139372befec400003e462558ff" translate="yes" xml:space="preserve">
          <source>Note: In general, auto-converting from int to float loses information, which is why these operators live in a separate module. Use with care.</source>
          <target state="translated">Nota:En general,la autoconversión de int a flotante pierde información,por lo que estos operadores viven en un módulo separado.Usar con cuidado.</target>
        </trans-unit>
        <trans-unit id="bb6ec3757cbbdd1dd0301b680ca419e74971fb18" translate="yes" xml:space="preserve">
          <source>Note: Not available for JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4cd3c3e2d987ccf3e1ad62f1c44f6201bc3f26" translate="yes" xml:space="preserve">
          <source>Note: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b65c5d5f2ba33aefbd25c3c5eb32dd838fe065" translate="yes" xml:space="preserve">
          <source>Note: The pattern refers to the original C identifiers, not to the resulting identifiers after mangling!</source>
          <target state="translated">Nota:El patrón se refiere a los identificadores C originales,no a los identificadores resultantes después de la manipulación!</target>
        </trans-unit>
        <trans-unit id="5207456ac36fc3f9063842f9bda281784379b2c6" translate="yes" xml:space="preserve">
          <source>Note: This template may not work in some cases, use &lt;a href=&quot;sugar#capture.m,openArray%5Btyped%5D,untyped&quot;&gt;capture&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b257114cf6fc959d8954b5a66399cfa481aa015" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;a href=&quot;options#Option&quot;&gt;Option&lt;/a&gt; for keys sometimes missing in json responses, and backticks around keys with a reserved keyword as name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85936911cd46420f06b600d6cad5d51acfe276f" translate="yes" xml:space="preserve">
          <source>Note: While the rules outlined below are the &lt;em&gt;current&lt;/em&gt; naming conventions, these conventions have not always been in place. Previously, the naming conventions for identifiers followed the Pascal tradition of prefixes which indicated the base type of the identifier - PFoo for pointer and reference types, TFoo for value types, EFoo for exceptions, etc. Though this has since changed, there are many places in the standard library which still use this convention. Such style remains in place purely for legacy reasons, and will be changed in the future.</source>
          <target state="translated">Nota: Si bien las reglas que se describen a continuaci&amp;oacute;n son las convenciones de nomenclatura &lt;em&gt;actuales&lt;/em&gt; , estas convenciones no siempre han estado vigentes. Anteriormente, las convenciones de nomenclatura para los identificadores segu&amp;iacute;an la tradici&amp;oacute;n de prefijos de Pascal que indicaba el tipo base del identificador: PFoo para tipos de puntero y referencia, TFoo para tipos de valor, EFoo para excepciones, etc. Aunque esto ha cambiado desde entonces, hay muchos lugares en la biblioteca est&amp;aacute;ndar que todav&amp;iacute;a usa esta convenci&amp;oacute;n. Dicho estilo permanece en su lugar puramente por razones heredadas y se cambiar&amp;aacute; en el futuro.</target>
        </trans-unit>
        <trans-unit id="9778d746b0391d7bd7fd0ece0b5cbc7f2a1e15d9" translate="yes" xml:space="preserve">
          <source>Note: XCode's &quot;make clean&quot; gets confused about the generated nim.c files, so you need to clean those files manually to do a clean build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fecedf4653bc748c9340a21b565062d449db86" translate="yes" xml:space="preserve">
          <source>Note: alternate ways of writing this are &lt;code&gt;b[^8..^2] = &quot;useful&quot;&lt;/code&gt; or as &lt;code&gt;b[11..b.len-2] = &quot;useful&quot;&lt;/code&gt; or as &lt;code&gt;b[11..&amp;lt;b.len-1] = &quot;useful&quot;&lt;/code&gt;.</source>
          <target state="translated">Nota: formas alternativas de escribir esto son &lt;code&gt;b[^8..^2] = &quot;useful&quot;&lt;/code&gt; o como &lt;code&gt;b[11..b.len-2] = &quot;useful&quot;&lt;/code&gt; o como &lt;code&gt;b[11..&amp;lt;b.len-1] = &quot;useful&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d2a8fe03f1e52e70d949a49deffb7beaa9697e" translate="yes" xml:space="preserve">
          <source>Note: there is a speed improvement if the matches do not need to be captured.</source>
          <target state="translated">Nota:hay una mejora de la velocidad si los fósforos no necesitan ser capturados.</target>
        </trans-unit>
        <trans-unit id="b66ebf38768e7530c8d492ade747b6e73d402946" translate="yes" xml:space="preserve">
          <source>Note: this could block if &lt;code&gt;input.len&lt;/code&gt; is greater than your OS's maximum pipe buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46cb88cb285ad050ff48c315bfe537707654bcc" translate="yes" xml:space="preserve">
          <source>Note: this is mostly outdated, see instead &lt;a href=&quot;nimsuggest&quot;&gt;nimsuggest&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e84c20ada2d36c53605b5b42bec5ecb1edbb93" translate="yes" xml:space="preserve">
          <source>Note: to serialize &lt;em&gt;x&lt;/em&gt; to JSON use $(%x) from the &lt;code&gt;json&lt;/code&gt; module</source>
          <target state="translated">Nota: para serializar &lt;em&gt;x&lt;/em&gt; a JSON, use $ (% x) del m&amp;oacute;dulo &lt;code&gt;json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="fedfa1aa98f87579b26f162395ec81ac6f49897e" translate="yes" xml:space="preserve">
          <source>Notes when using multiple threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d40b7a681541c6f19f485d3cc6b34540337a107" translate="yes" xml:space="preserve">
          <source>NotesVerbosity:</source>
          <target state="translated">NotesVerbosity:</target>
        </trans-unit>
        <trans-unit id="a4a2ebf22ba0a60faeb2fdc809dafca8b36c3083" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; must be of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5815dccaa90c765a4f2404d7d1dd5b55be738f8c" translate="yes" xml:space="preserve">
          <source>Notice that when exporting, one needs to specify only the module name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb925a84b12636058c161c78db99469a750858b" translate="yes" xml:space="preserve">
          <source>Notices are semantically very similar to info messages, but they are meant to be messages that the user should be actively notified about, depending on the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c599056dda568258fe7a8884f67e29669997a74a" translate="yes" xml:space="preserve">
          <source>Now that we covered the basic control flow statements, let's return to Nim indentation rules.</source>
          <target state="translated">Ahora que cubrimos las declaraciones básicas del flujo de control,volvamos a las reglas de indentación de Nim.</target>
        </trans-unit>
        <trans-unit id="359cc1b4d4e1198e58400a2f6178f9956362e79d" translate="yes" xml:space="preserve">
          <source>Now that we use named arguments to call &lt;code&gt;createWindow&lt;/code&gt; the argument order does not matter anymore. Mixing named arguments with ordered arguments is also possible, but not very readable:</source>
          <target state="translated">Ahora que usamos argumentos con nombre para llamar a &lt;code&gt;createWindow&lt;/code&gt; , el orden de los argumentos ya no importa. Tambi&amp;eacute;n es posible mezclar argumentos con nombre con argumentos ordenados, pero no es muy legible:</target>
        </trans-unit>
        <trans-unit id="de073aaec09d9a82c0b5660d7283e643aafc1ad4" translate="yes" xml:space="preserve">
          <source>Now the call to &lt;code&gt;createWindow&lt;/code&gt; only needs to set the values that differ from the defaults.</source>
          <target state="translated">Ahora, la llamada a &lt;code&gt;createWindow&lt;/code&gt; solo necesita establecer los valores que difieren de los predeterminados.</target>
        </trans-unit>
        <trans-unit id="37e192255f51d8e35fa4d8c800cc0c72921cf379" translate="yes" xml:space="preserve">
          <source>Now the following holds:</source>
          <target state="translated">Ahora lo siguiente se mantiene:</target>
        </trans-unit>
        <trans-unit id="87081d18a9fcb6da770d34e0fe4d26d7acf23a4c" translate="yes" xml:space="preserve">
          <source>Now we have compile-time checking against SQL injection attacks. Since &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; is transformed to &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; no new syntax is needed for nice looking &lt;code&gt;SQL&lt;/code&gt; string literals. The hypothetical &lt;code&gt;SQL&lt;/code&gt; type actually exists in the library as the &lt;a href=&quot;db_common#SqlQuery&quot;&gt;SqlQuery type&lt;/a&gt; of modules like &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1e7ee1876e3e297d1a65cb42dae5bbd812f819" translate="yes" xml:space="preserve">
          <source>Now we have compile-time checking against SQL injection attacks. Since &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; is transformed to &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; no new syntax is needed for nice looking &lt;code&gt;SQL&lt;/code&gt; string literals. The hypothetical &lt;code&gt;SQL&lt;/code&gt; type actually exists in the library as the &lt;a href=&quot;db_sqlite#TSqlQuery&quot;&gt;TSqlQuery type&lt;/a&gt; of modules like &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt;.</source>
          <target state="translated">Ahora tenemos una verificaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n contra ataques de inyecci&amp;oacute;n SQL. Dado que &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; se transforma a &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; no se necesita una nueva sintaxis para los literales de cadena &lt;code&gt;SQL&lt;/code&gt; de buen aspecto . El tipo de &lt;code&gt;SQL&lt;/code&gt; hipot&amp;eacute;tico en realidad existe en la biblioteca como el &lt;a href=&quot;db_sqlite#TSqlQuery&quot;&gt;tipo&lt;/a&gt; de m&amp;oacute;dulos &lt;a href=&quot;db_sqlite&quot;&gt;TSqlQuery&lt;/a&gt; como db_sqlite .</target>
        </trans-unit>
        <trans-unit id="ef2111c104cca92314b6843b4983145b5795a78c" translate="yes" xml:space="preserve">
          <source>Now when &lt;code&gt;bar.nim&lt;/code&gt; is compiled directly, the &lt;code&gt;getProjectPath&lt;/code&gt; will now return the &lt;code&gt;dir2/&lt;/code&gt; path, and the &lt;code&gt;currentSourcePath&lt;/code&gt; will still return the same path, the path to the &lt;code&gt;bar.nim&lt;/code&gt; source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f6d46c0b2b46a621f9252b5aed254ec60a3b55" translate="yes" xml:space="preserve">
          <source>Now when &lt;code&gt;foo.nim&lt;/code&gt; is compiled, the &lt;code&gt;getProjectPath&lt;/code&gt; from &lt;code&gt;bar.nim&lt;/code&gt; will return the &lt;code&gt;dir1/&lt;/code&gt; path, while the &lt;code&gt;currentSourcePath&lt;/code&gt; will return the path to the &lt;code&gt;bar.nim&lt;/code&gt; source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756f1995808a7a657065d45ecdba62e1e4422db8" translate="yes" xml:space="preserve">
          <source>Now you can run the following Unix like commands to first generate C sources form the Nim code, then link them into a static binary along your main C program:</source>
          <target state="translated">Ahora puedes ejecutar los siguientes comandos tipo Unix para generar primero las fuentes C desde el código Nim,y luego enlazarlas en un binario estático a lo largo de tu programa C principal:</target>
        </trans-unit>
        <trans-unit id="b395673dbacaa4ff7221cdcfe84290edc07b8bb9" translate="yes" xml:space="preserve">
          <source>Now you can run the following Unix like commands to first generate C sources from the Nim code, then link them into a static binary along your main C program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cf1586c107e2ad157be6c3699e618619c6124a" translate="yes" xml:space="preserve">
          <source>Number of decimal digits that can be represented in a 32-bit floating-point type without losing precision.</source>
          <target state="translated">Número de dígitos decimales que pueden ser representados en un tipo de punto flotante de 32 bits sin perder precisión.</target>
        </trans-unit>
        <trans-unit id="f2a4cda872ca90910ea60e675f66d013e1c1c5d2" translate="yes" xml:space="preserve">
          <source>Number of decimal digits that can be represented in a 64-bit floating-point type without losing precision.</source>
          <target state="translated">Número de dígitos decimales que pueden ser representados en un tipo de punto flotante de 64 bits sin perder precisión.</target>
        </trans-unit>
        <trans-unit id="1e93ac306e3ccaf06ddd125b223d48515fd601ae" translate="yes" xml:space="preserve">
          <source>Number of digits (in base &lt;code&gt;floatingPointRadix&lt;/code&gt;) in the mantissa of 32-bit floating-point numbers.</source>
          <target state="translated">N&amp;uacute;mero de d&amp;iacute;gitos (en base &lt;code&gt;floatingPointRadix&lt;/code&gt; ) en la mantisa de n&amp;uacute;meros de coma flotante de 32 bits.</target>
        </trans-unit>
        <trans-unit id="8d111fafd83c57aff8321d904d1159c139884ca1" translate="yes" xml:space="preserve">
          <source>Number of digits (in base &lt;code&gt;floatingPointRadix&lt;/code&gt;) in the mantissa of 64-bit floating-point numbers.</source>
          <target state="translated">N&amp;uacute;mero de d&amp;iacute;gitos (en base &lt;code&gt;floatingPointRadix&lt;/code&gt; ) en la mantisa de n&amp;uacute;meros de coma flotante de 64 bits.</target>
        </trans-unit>
        <trans-unit id="6d57434884838acf9fbf6aa87bb099375ffa68a7" translate="yes" xml:space="preserve">
          <source>Number of whole days represented by the duration.</source>
          <target state="translated">Número de días enteros representados por la duración.</target>
        </trans-unit>
        <trans-unit id="bbbf1dbfdd00220f8dc094d6ec5b5e3a5b7eec35" translate="yes" xml:space="preserve">
          <source>Number of whole hours represented by the duration.</source>
          <target state="translated">Número de horas completas representadas por la duración.</target>
        </trans-unit>
        <trans-unit id="b3416e7091156db48c9ee6ff7ce55182de3f7f47" translate="yes" xml:space="preserve">
          <source>Number of whole microseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">N&amp;uacute;mero de microsegundos enteros representados por la parte &lt;strong&gt;fraccionaria&lt;/strong&gt; de la duraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e7efa45f297295912fd59ed47a00f3af6bfa2ef2" translate="yes" xml:space="preserve">
          <source>Number of whole milliseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">N&amp;uacute;mero de milisegundos enteros representados por la parte &lt;strong&gt;fraccionaria&lt;/strong&gt; de la duraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="76ab1f8aba37163bdf200dab23553396a7d3e689" translate="yes" xml:space="preserve">
          <source>Number of whole minutes represented by the duration.</source>
          <target state="translated">Número de minutos enteros representados por la duración.</target>
        </trans-unit>
        <trans-unit id="18290aaf8138cc68a7cb85c476b2a4618ec23b5c" translate="yes" xml:space="preserve">
          <source>Number of whole nanoseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">N&amp;uacute;mero de nanosegundos enteros representados por la parte &lt;strong&gt;fraccionaria&lt;/strong&gt; de la duraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a01af1e768fd4e093861831d977f5d94b80aa9f9" translate="yes" xml:space="preserve">
          <source>Number of whole seconds represented by the duration.</source>
          <target state="translated">Número de segundos enteros representados por la duración.</target>
        </trans-unit>
        <trans-unit id="5019b0366e2a30d163a49d5eb75e70470ba3899e" translate="yes" xml:space="preserve">
          <source>Number of whole weeks represented by the duration.</source>
          <target state="translated">Número de semanas enteras representadas por la duración.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="6d872a21aa9a7b7fea7d5fe31a5c2025c54405e4" translate="yes" xml:space="preserve">
          <source>Numbers in of the range -1000.0&amp;lt;f&amp;lt;1000.0 will be formatted without an exponent. Numbers outside of this range will be formatted as a significand in the range -1000.0&amp;lt;f&amp;lt;1000.0 and an exponent that will always be an integer multiple of 3, corresponding with the SI prefix scale k, M, G, T etc for numbers with an absolute value greater than 1 and m, &amp;mu;, n, p etc for numbers with an absolute value less than 1.</source>
          <target state="translated">Los n&amp;uacute;meros en el rango -1000.0 &amp;lt;f &amp;lt;1000.0 se formatear&amp;aacute;n sin un exponente. Los n&amp;uacute;meros fuera de este rango se formatear&amp;aacute;n como un significado en el rango -1000.0 &amp;lt;f &amp;lt;1000.0 y un exponente que siempre ser&amp;aacute; un m&amp;uacute;ltiplo entero de 3, correspondiente a la escala de prefijo SI k, M, G, T, etc. para n&amp;uacute;meros con un valor absoluto mayor que 1 y m, &amp;mu;, n, p, etc. para n&amp;uacute;meros con un valor absoluto menor que 1.</target>
        </trans-unit>
        <trans-unit id="76046e581003f2b0494ba6b4f5311bb28033bd96" translate="yes" xml:space="preserve">
          <source>Numeric value representing the day of the month, it will be either one or two digits long.</source>
          <target state="translated">Valor numérico que representa el día del mes,tendrá uno o dos dígitos de longitud.</target>
        </trans-unit>
        <trans-unit id="de117b3e0329ec2102122ec4b014ce37f5a796cb" translate="yes" xml:space="preserve">
          <source>Numerical constants</source>
          <target state="translated">Constantes numéricas</target>
        </trans-unit>
        <trans-unit id="1e9d4ed2757d3ae1dd279289b3d36043bcba7966" translate="yes" xml:space="preserve">
          <source>Numerical constants are of a single type and have the form:</source>
          <target state="translated">Las constantes numéricas son de un solo tipo y tienen la forma:</target>
        </trans-unit>
        <trans-unit id="14f53cb15d3a159e9414701d05c0d3d0e93ec666" translate="yes" xml:space="preserve">
          <source>Numerical literals are written as in most other languages. As a special twist, underscores are allowed for better readability: &lt;code&gt;1_000_000&lt;/code&gt; (one million). A number that contains a dot (or 'e' or 'E') is a floating point literal: &lt;code&gt;1.0e9&lt;/code&gt; (one billion). Hexadecimal literals are prefixed with &lt;code&gt;0x&lt;/code&gt;, binary literals with &lt;code&gt;0b&lt;/code&gt; and octal literals with &lt;code&gt;0o&lt;/code&gt;. A leading zero alone does not produce an octal.</source>
          <target state="translated">Los literales num&amp;eacute;ricos se escriben como en la mayor&amp;iacute;a de los otros idiomas. Como un giro especial, se permiten guiones bajos para una mejor legibilidad: &lt;code&gt;1_000_000&lt;/code&gt; (un mill&amp;oacute;n). Un n&amp;uacute;mero que contiene un punto (o 'e' o 'E') es un literal de coma flotante: &lt;code&gt;1.0e9&lt;/code&gt; (mil millones). Los literales hexadecimales tienen el prefijo &lt;code&gt;0x&lt;/code&gt; , los literales binarios &lt;code&gt;0b&lt;/code&gt; y los literales octales &lt;code&gt;0o&lt;/code&gt; . Un cero inicial solo no produce un octal.</target>
        </trans-unit>
        <trans-unit id="2c5c7f8404256e0a35e506cca1a7981e7daef170" translate="yes" xml:space="preserve">
          <source>NumericalBase.base10</source>
          <target state="translated">NumericalBase.base10</target>
        </trans-unit>
        <trans-unit id="ccf3ca1a1bb490e927ea05b6581028198ac69592" translate="yes" xml:space="preserve">
          <source>NumericalBase.base16</source>
          <target state="translated">NumericalBase.base16</target>
        </trans-unit>
        <trans-unit id="ee9048563b2785fc2b606907b0087c584930c9f9" translate="yes" xml:space="preserve">
          <source>NumericalBase.base2</source>
          <target state="translated">NumericalBase.base2</target>
        </trans-unit>
        <trans-unit id="ae0213167f6a92377ed9aad1ca56953301053e5c" translate="yes" xml:space="preserve">
          <source>NumericalBase.base8</source>
          <target state="translated">NumericalBase.base8</target>
        </trans-unit>
        <trans-unit id="3d2ccad0a41ad474c931c455f0da38d9969feacd" translate="yes" xml:space="preserve">
          <source>NumericalBase:</source>
          <target state="translated">NumericalBase:</target>
        </trans-unit>
        <trans-unit id="f49726ee7d810f57a9139d6d7df541fd9f684eaf" translate="yes" xml:space="preserve">
          <source>O(n) complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04cb3eb98c641516855449fcdbb36cf3f897d21" translate="yes" xml:space="preserve">
          <source>OP0</source>
          <target state="translated">OP0</target>
        </trans-unit>
        <trans-unit id="e04bcfb1ab304010d11e5f6c998c2482bd0d4128" translate="yes" xml:space="preserve">
          <source>OP1</source>
          <target state="translated">OP1</target>
        </trans-unit>
        <trans-unit id="a0f424f70ed0dceb9a4df1bcbbb44ba5f55142ae" translate="yes" xml:space="preserve">
          <source>OP10</source>
          <target state="translated">OP10</target>
        </trans-unit>
        <trans-unit id="c7235db666ae5752cda05330ea4cb5178dc33cc7" translate="yes" xml:space="preserve">
          <source>OP2</source>
          <target state="translated">OP2</target>
        </trans-unit>
        <trans-unit id="0269d7bdbba9ed5972892d3d356a1a3fac87612d" translate="yes" xml:space="preserve">
          <source>OP3</source>
          <target state="translated">OP3</target>
        </trans-unit>
        <trans-unit id="edc0331fa7efd5f99c8d4978274902462f4a77f2" translate="yes" xml:space="preserve">
          <source>OP4</source>
          <target state="translated">OP4</target>
        </trans-unit>
        <trans-unit id="1076f805e66d9538ab3ed3922addefb1313d6fee" translate="yes" xml:space="preserve">
          <source>OP5</source>
          <target state="translated">OP5</target>
        </trans-unit>
        <trans-unit id="ff32e5028e5ac9dd0850a491b15bab66a3070884" translate="yes" xml:space="preserve">
          <source>OP6</source>
          <target state="translated">OP6</target>
        </trans-unit>
        <trans-unit id="c5255cf0231d866ba6a47dd27b61007d7803323f" translate="yes" xml:space="preserve">
          <source>OP7</source>
          <target state="translated">OP7</target>
        </trans-unit>
        <trans-unit id="94fa4343a5ec0348b7ea746f38cbd00d2482ae4f" translate="yes" xml:space="preserve">
          <source>OP8</source>
          <target state="translated">OP8</target>
        </trans-unit>
        <trans-unit id="f373944b57d55ca9eddf4252a4349141943f321e" translate="yes" xml:space="preserve">
          <source>OP9</source>
          <target state="translated">OP9</target>
        </trans-unit>
        <trans-unit id="bea1b7a7bcd9663ab56444c7d74124c17a8fbbfc" translate="yes" xml:space="preserve">
          <source>ORC</source>
          <target state="translated">ORC</target>
        </trans-unit>
        <trans-unit id="99bb1a1563f4d5f5cc3004055e8ee1b82817117f" translate="yes" xml:space="preserve">
          <source>OS-Path normalization. Used by &lt;code&gt;os.nim&lt;/code&gt; but also generally useful for dealing with paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380a5dcbfa19547ee9ef2a45f62b8b54d658bbde" translate="yes" xml:space="preserve">
          <source>OS-specific operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b289714645dc080e6d028dce9288aaf44c582e6" translate="yes" xml:space="preserve">
          <source>OS:</source>
          <target state="translated">OS:</target>
        </trans-unit>
        <trans-unit id="e2e3a80c4bd8a468bcd99583c85e67abc6426be7" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming</source>
          <target state="translated">Programación orientada a objetos</target>
        </trans-unit>
        <trans-unit id="228b119ddf88904b9df1033a323f6ac211450b69" translate="yes" xml:space="preserve">
          <source>Object access operator &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">Operador de acceso a objetos &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589a18f6b8265d03c5f8516a6f333a007673bfce" translate="yes" xml:space="preserve">
          <source>Object and array construction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5558dc9f8bd66c6e283c97f8881f22188449327a" translate="yes" xml:space="preserve">
          <source>Object and array construction is treated as a function call where the function has &lt;code&gt;sink&lt;/code&gt; parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ca8083a285ad1c3815b36f3d7992ca6b703603" translate="yes" xml:space="preserve">
          <source>Object construction</source>
          <target state="translated">La construcción de objetos</target>
        </trans-unit>
        <trans-unit id="28b132088e585ec3607bc5ee13d1d17885737336" translate="yes" xml:space="preserve">
          <source>Object field access &lt;code&gt;e.field&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233bb7b76158a54f9e255a510cc28ac7b239b2dc" translate="yes" xml:space="preserve">
          <source>Object fields and global variables can be annotated via a &lt;code&gt;guard&lt;/code&gt; pragma:</source>
          <target state="translated">Los campos de objeto y las variables globales se pueden anotar mediante un pragma de &lt;code&gt;guard&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97f4ffdb6041c29c1c6a9a1c4566f9fc24ba1904" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;. New object types can only be defined within a type section.</source>
          <target state="translated">Los campos de objeto que deber&amp;iacute;an ser visibles desde fuera del m&amp;oacute;dulo de definici&amp;oacute;n deben estar marcados con &lt;code&gt;*&lt;/code&gt; . A diferencia de las tuplas, los diferentes tipos de objetos nunca son &lt;em&gt;equivalentes&lt;/em&gt; . Los nuevos tipos de objetos solo se pueden definir dentro de una secci&amp;oacute;n de tipos.</target>
        </trans-unit>
        <trans-unit id="d5aae1485cba1ac004bf1c390547daf6751e0fcb" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module, have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;, they are nominal types whereas tuples are structural. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt; and thus have no hidden type information. One can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d5262dff32615f0940c3ad8ba0ac64dcad73ed" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module, have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt; and thus have no hidden type field. One can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;.</source>
          <target state="translated">Los campos de objeto que deber&amp;iacute;an ser visibles desde fuera del m&amp;oacute;dulo de definici&amp;oacute;n deben estar marcados con &lt;code&gt;*&lt;/code&gt; . A diferencia de las tuplas, los diferentes tipos de objetos nunca son &lt;em&gt;equivalentes&lt;/em&gt; . Los objetos que no tienen antepasado son impl&amp;iacute;citamente &lt;code&gt;final&lt;/code&gt; es y, por lo tanto, no tienen un campo de tipo oculto. Se puede usar el pragma &lt;code&gt;inheritable&lt;/code&gt; para introducir nuevas ra&amp;iacute;ces de objetos adem&amp;aacute;s de &lt;code&gt;system.RootObj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0978d14ec54e6881dd2800cbf0b00efa45a72d10" translate="yes" xml:space="preserve">
          <source>Object variants</source>
          <target state="translated">Variantes de objetos</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="d2c0e1be93b0738e53ee9b0896c747691dcee381" translate="yes" xml:space="preserve">
          <source>Objects can also be created with an &lt;span id=&quot;object-construction-expression_1&quot;&gt;object construction expression&lt;/span&gt; that has the syntax &lt;code&gt;T(fieldA: valueA, fieldB: valueB, ...)&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;object&lt;/code&gt; type or a &lt;code&gt;ref object&lt;/code&gt; type:</source>
          <target state="translated">Los objetos tambi&amp;eacute;n se pueden crear con una &lt;span id=&quot;object-construction-expression_1&quot;&gt;expresi&amp;oacute;n de construcci&amp;oacute;n de objetos&lt;/span&gt; que tenga la sintaxis &lt;code&gt;T(fieldA: valueA, fieldB: valueB, ...)&lt;/code&gt; donde &lt;code&gt;T&lt;/code&gt; es un tipo de &lt;code&gt;object&lt;/code&gt; o un tipo de &lt;code&gt;ref object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ec43891abad4c5f51b9f1f5052e07c492132c2c3" translate="yes" xml:space="preserve">
          <source>Objects have access to their type at runtime. There is an &lt;code&gt;of&lt;/code&gt; operator that can be used to check the object's type:</source>
          <target state="translated">Los objetos tienen acceso a su tipo en tiempo de ejecuci&amp;oacute;n. Hay un operador &lt;code&gt;of&lt;/code&gt; que se puede usar para verificar el tipo de objeto:</target>
        </trans-unit>
        <trans-unit id="4834206117cd45bf703010b173f8d2ab8b0e8785" translate="yes" xml:space="preserve">
          <source>Objects provide many features that tuples do not. Object provide inheritance and information hiding. Objects have access to their type at runtime, so that the &lt;code&gt;of&lt;/code&gt; operator can be used to determine the object's type. The &lt;code&gt;of&lt;/code&gt; operator is similar to the &lt;code&gt;instanceof&lt;/code&gt; operator in Java.</source>
          <target state="translated">Los objetos proporcionan muchas caracter&amp;iacute;sticas que las tuplas no. Objeto proporciona herencia y ocultaci&amp;oacute;n de informaci&amp;oacute;n. Los objetos tienen acceso a su tipo en tiempo de ejecuci&amp;oacute;n, de modo que el operador &lt;code&gt;of&lt;/code&gt; se puede utilizar para determinar el tipo del objeto. El operador &lt;code&gt;of&lt;/code&gt; es similar al operador &lt;code&gt;instanceof&lt;/code&gt; en Java.</target>
        </trans-unit>
        <trans-unit id="50fbd3a1625c6e8ac6633b1b59a260ad1ef17f1e" translate="yes" xml:space="preserve">
          <source>Objects provide many features that tuples do not. Object provide inheritance and the ability to hide fields from other modules. Objects with inheritance enabled have information about their type at runtime so that the &lt;code&gt;of&lt;/code&gt; operator can be used to determine the object's type. The &lt;code&gt;of&lt;/code&gt; operator is similar to the &lt;code&gt;instanceof&lt;/code&gt; operator in Java.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b16e087c768e899a86532c722c83d0cf81e74b" translate="yes" xml:space="preserve">
          <source>Objects should inherit from &lt;code&gt;RootObj&lt;/code&gt; or one of its descendants. However, objects that have no ancestor are also allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0553672f5b32a90c8aef874a5102dc22e01f71a7" translate="yes" xml:space="preserve">
          <source>Objects that contain pointers that point to the same object are not supported by Nim's model. Otherwise swapped objects would end up in an inconsistent state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c57f97f14e60597fdfd797182b06e968256db96" translate="yes" xml:space="preserve">
          <source>Objects, tuples and references can model quite complex data structures which depend on each other; they are &lt;em&gt;mutually recursive&lt;/em&gt;. In Nim these types can only be declared within a single type section. (Anything else would require arbitrary symbol lookahead which slows down compilation.)</source>
          <target state="translated">Los objetos, tuplas y referencias pueden modelar estructuras de datos bastante complejas que dependen unas de otras; son &lt;em&gt;recursivas mutuamente&lt;/em&gt; . En Nim, estos tipos solo se pueden declarar dentro de una &amp;uacute;nica secci&amp;oacute;n de tipos. (Cualquier otra cosa requerir&amp;iacute;a una b&amp;uacute;squeda anticipada de s&amp;iacute;mbolos arbitraria que ralentiza la compilaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="71f640b46a5645b45934608435a884aa861a4b91" translate="yes" xml:space="preserve">
          <source>Obtains a sequence containing the Runes in &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">Obtiene una secuencia que contiene las Runas en &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76d03f5fe1c384210c6971da7941ee56452fb961" translate="yes" xml:space="preserve">
          <source>Obtains a sequence containing the Runes in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ad7ba4d959a6de6e644561408cd88962c2b6f5" translate="yes" xml:space="preserve">
          <source>Obtains the AST nodes returned from a macro or template invocation. Example:</source>
          <target state="translated">Obtiene los nodos AST devueltos de una invocación de macro o plantilla.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="e48a55708577c922dfe1c8727c5015fe59dcd19c" translate="yes" xml:space="preserve">
          <source>Octal format. Outputs the number in base 8.</source>
          <target state="translated">Formato octal.Emite el número en base 8.</target>
        </trans-unit>
        <trans-unit id="1168d0c029a48fe3aea275c0858b8d7c66a53429" translate="yes" xml:space="preserve">
          <source>OctalEscape</source>
          <target state="translated">OctalEscape</target>
        </trans-unit>
        <trans-unit id="848ceaf7c8a295c627cb93a73ac754f0130154b6" translate="yes" xml:space="preserve">
          <source>Often C and C++ code contains something like the following, where the return value is frequently ignored and so the Nim wrapper should contain a &lt;code&gt;.discardable&lt;/code&gt; pragma:</source>
          <target state="translated">A menudo, el c&amp;oacute;digo C y C ++ contiene algo como lo siguiente, donde el valor de retorno se ignora con frecuencia y, por lo tanto, el contenedor de Nim debe contener un pragma &lt;code&gt;.discardable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c85c11c4b42c93c3e7a04193ab3c113033320a61" translate="yes" xml:space="preserve">
          <source>Often C code contains special macros that affect the declaration of a function prototype but confuse c2nim's parser:</source>
          <target state="translated">A menudo el código C contiene macros especiales que afectan a la declaración de un prototipo de función pero que confunden al analizador de c2nim:</target>
        </trans-unit>
        <trans-unit id="a8f42ebc1976b2a5351c29b1673e9099dfdbaca1" translate="yes" xml:space="preserve">
          <source>Often a procedure has many parameters and it is not clear in which order the parameters appear. This is especially true for procedures that construct a complex data type. Therefore the arguments to a procedure can be named, so that it is clear which argument belongs to which parameter:</source>
          <target state="translated">A menudo un procedimiento tiene muchos parámetros y no está claro en qué orden aparecen los parámetros.Esto es especialmente cierto en el caso de los procedimientos que construyen un tipo de datos complejos.Por lo tanto,se pueden nombrar los argumentos de un procedimiento,de modo que quede claro qué argumento pertenece a qué parámetro:</target>
        </trans-unit>
        <trans-unit id="3a5f3199753bf25f09a786142eab4d142c315045" translate="yes" xml:space="preserve">
          <source>Often an object hierarchy is an overkill in certain situations where simple variant types are needed. Object variants are tagged unions discriminated via an enumerated type used for runtime type flexibility, mirroring the concepts of &lt;em&gt;sum types&lt;/em&gt; and &lt;em&gt;algebraic data types (ADTs)&lt;/em&gt; as found in other languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6395b4ee4a71999d586e3acbee700ed5ca4da87" translate="yes" xml:space="preserve">
          <source>Often an object hierarchy is overkill in certain situations where simple variant types are needed.</source>
          <target state="translated">A menudo una jerarquía de objetos es exagerada en ciertas situaciones en las que se necesitan tipos de variantes simples.</target>
        </trans-unit>
        <trans-unit id="06ebd19cc8bc8c7150cf93f1a6c3d3c1726b3741" translate="yes" xml:space="preserve">
          <source>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; type allows this. Openarrays are always indexed with an &lt;code&gt;int&lt;/code&gt; starting at position 0. The &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt;, &lt;a href=&quot;system#low&quot;&gt;low&lt;/a&gt; and &lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter.</source>
          <target state="translated">A menudo, las matrices de tama&amp;ntilde;o fijo resultan demasiado inflexibles; los procedimientos deben poder trabajar con matrices de diferentes tama&amp;ntilde;os. El tipo &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; permite esto. Las matrices abiertas siempre se indexan con un &lt;code&gt;int&lt;/code&gt; que comienza en la posici&amp;oacute;n 0. Las operaciones &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; , &lt;a href=&quot;system#low&quot;&gt;low&lt;/a&gt; y &lt;a href=&quot;system#high&quot;&gt;high tambi&amp;eacute;n&lt;/a&gt; est&amp;aacute;n disponibles para matrices abiertas. Cualquier matriz con un tipo base compatible se puede pasar a un par&amp;aacute;metro openarray, el tipo de &amp;iacute;ndice no importa.</target>
        </trans-unit>
        <trans-unit id="b72b9d6119b4da4f2df6e174e7eebce8ade809c0" translate="yes" xml:space="preserve">
          <source>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; type allows this; it can only be used for parameters. Openarrays are always indexed with an &lt;code&gt;int&lt;/code&gt; starting at position 0. The &lt;code&gt;len&lt;/code&gt;, &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter. In addition to arrays sequences can also be passed to an open array parameter.</source>
          <target state="translated">A menudo, las matrices de tama&amp;ntilde;o fijo resultan demasiado inflexibles; Los procedimientos deben poder trabajar con matrices de diferentes tama&amp;ntilde;os. El tipo &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; permite esto; solo se puede utilizar para par&amp;aacute;metros. Las matrices abiertas siempre se indexan con un &lt;code&gt;int&lt;/code&gt; que comienza en la posici&amp;oacute;n 0. Las operaciones &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;low&lt;/code&gt; y &lt;code&gt;high&lt;/code&gt; tambi&amp;eacute;n est&amp;aacute;n disponibles para matrices abiertas. Cualquier matriz con un tipo base compatible se puede pasar a un par&amp;aacute;metro openarray, el tipo de &amp;iacute;ndice no importa. Adem&amp;aacute;s de las matrices, las secuencias tambi&amp;eacute;n se pueden pasar a un par&amp;aacute;metro de matriz abierta.</target>
        </trans-unit>
        <trans-unit id="653db7bf1a8cfcc325e38da27b77e167f0e8e1e1" translate="yes" xml:space="preserve">
          <source>Often it is unclear where the method should belong to: is &lt;code&gt;join&lt;/code&gt; a string method or an array method?</source>
          <target state="translated">A menudo no est&amp;aacute; claro a d&amp;oacute;nde debe pertenecer el m&amp;eacute;todo: &amp;iquest;la &lt;code&gt;join&lt;/code&gt; es un m&amp;eacute;todo de cadena o un m&amp;eacute;todo de matriz?</target>
        </trans-unit>
        <trans-unit id="c448be5e6f2f721a095ce66e4d5d6809129d6a5f" translate="yes" xml:space="preserve">
          <source>Often, you might work with callback-based API-s. You can wrap them with asynchronous procedures using promises and &lt;code&gt;newPromise&lt;/code&gt;:</source>
          <target state="translated">A menudo, puede trabajar con API basadas en devoluciones de llamada. Puede envolverlos con procedimientos asincr&amp;oacute;nicos usando promesas y &lt;code&gt;newPromise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="13c64dac54bbedb5367bd67136157fa1cbeaf400" translate="yes" xml:space="preserve">
          <source>Old HTML contains tags that have no end tag: &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; for example.</source>
          <target state="translated">El HTML antiguo contiene etiquetas que no tienen etiqueta final: &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; por ejemplo.</target>
        </trans-unit>
        <trans-unit id="6d9b2255ea4766e38b37a3d1d6acbcd79adbbee9" translate="yes" xml:space="preserve">
          <source>Oldest clients supported by this list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce7e4551854af6b06b12d4a9f13070d5030d272" translate="yes" xml:space="preserve">
          <source>On OpenSSL &amp;gt;= 1.1.0 this is on by default and cannot be disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ab671e39fd99eba628d677c2b659305d9cd016" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d06d53900d18c0c4d19f86691434ca346457cf3" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b962bd1576f47b7fbea68a4ac589aea607292c" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5aa2ca373f45676714b04347619568162e21bdb" translate="yes" xml:space="preserve">
          <source>On Posix OSes the procedure sends &lt;code&gt;SIGKILL&lt;/code&gt; to the process. On Windows &lt;code&gt;kill&lt;/code&gt; is simply an alias for &lt;a href=&quot;#terminate,Process&quot;&gt;terminate()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636bb30d2edfe13bddf1cfddf99dc97b65eee8d3" translate="yes" xml:space="preserve">
          <source>On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33123903f02b8bf587a5568b29d3def5ad6cd5c" translate="yes" xml:space="preserve">
          <source>On Posix systems, it uses the following parsing rules: Components are separated by whitespace unless the whitespace occurs within &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; quotes.</source>
          <target state="translated">En los sistemas Posix, utiliza las siguientes reglas de an&amp;aacute;lisis: Los componentes est&amp;aacute;n separados por espacios en blanco a menos que el espacio en blanco aparezca entre &lt;code&gt;&quot;&lt;/code&gt; o &lt;code&gt;'&lt;/code&gt; comillas.</target>
        </trans-unit>
        <trans-unit id="834cc319d31095e6fc7d78e7d1c9b23d8c20037d" translate="yes" xml:space="preserve">
          <source>On Unix, you can also use the shebang &lt;code&gt;#!/usr/bin/env nim&lt;/code&gt;, as long as your filename ends with &lt;code&gt;.nims&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca375d55e90a2ca9b205b82e74384bf3a49097b" translate="yes" xml:space="preserve">
          <source>On Windows adds &quot;.dll&quot; to &lt;code&gt;filename&lt;/code&gt;, on Posix produces &quot;lib$filename.so&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbafa0f673264a750ef0cf50fe66c11c098cd82" translate="yes" xml:space="preserve">
          <source>On Windows adds &quot;.exe&quot; to &lt;code&gt;filename&lt;/code&gt;, else returns &lt;code&gt;filename&lt;/code&gt; unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131615a38d5f682e627f291b00695b764612c48b" translate="yes" xml:space="preserve">
          <source>On Windows this is a noop, &lt;code&gt;symlinkPath&lt;/code&gt; is simply returned.</source>
          <target state="translated">En Windows esto es un error, &lt;code&gt;symlinkPath&lt;/code&gt; simplemente se devuelve.</target>
        </trans-unit>
        <trans-unit id="05672aecf27340137fd58647ae2456a227fa831f" translate="yes" xml:space="preserve">
          <source>On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir,string,string&quot;&gt;copyDir proc&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fa250d69a315e525601b1f7e96a5b8019564e1" translate="yes" xml:space="preserve">
          <source>On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile proc&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ce96c0b5b17afe1bacf0b1747928e53aaa71eb" translate="yes" xml:space="preserve">
          <source>On Windows, a file is hidden if the file's 'hidden' attribute is set. On Unix-like systems, a file is hidden if it starts with a '.' (period) and is not &lt;em&gt;just&lt;/em&gt; '.' or '..' ' .&quot;</source>
          <target state="translated">En Windows, un archivo est&amp;aacute; oculto si se establece el atributo 'oculto' del archivo. En sistemas similares a Unix, un archivo est&amp;aacute; oculto si comienza con un '.' (punto) y no es &lt;em&gt;solo&lt;/em&gt; '.' o '..' '. &quot;</target>
        </trans-unit>
        <trans-unit id="be2b5ddfadb7e844935b3f58931b5fdf015b4ffa" translate="yes" xml:space="preserve">
          <source>On Windows, ignores the read-only attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d219ef8a6a1662c16fa1ad9a9fb14a71aa03b00f" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;following parsing rules&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e780c227d663a3ece4d9e2f1a1ef9ba70a8f3fe" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;following parsing rules&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49455f655e6af02510b37b400ad079bda32fcf9" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the following parsing rules (see &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt; ):</source>
          <target state="translated">En Windows, utiliza las siguientes reglas de an&amp;aacute;lisis (consulte &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="2d9112d9c390a489d1abe81e704b96328351c744" translate="yes" xml:space="preserve">
          <source>On Windows, network paths are considered absolute too.</source>
          <target state="translated">En Windows,las rutas de red también se consideran absolutas.</target>
        </trans-unit>
        <trans-unit id="ac5b0f8c13e69a83282367b11b7a62a054b16852" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;-d:useWinAnsi&lt;/code&gt; compilation flag can be used to make this procedure use the non-unicode Win API calls to retrieve the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4001f01f1a00f62db5ba5d2ddb394bcb0fbc5ede" translate="yes" xml:space="preserve">
          <source>On Windows: returns true if it exists and its &quot;hidden&quot; attribute is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd69f94a373ae6ea79b01a75e59c435ad639d26" translate="yes" xml:space="preserve">
          <source>On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively. Returns:</source>
          <target state="translated">En un sistema de archivos que distingue entre mayúsculas y minúsculas,esto se hace de manera que se distingue entre mayúsculas y minúsculas,de lo contrario no se distingue entre mayúsculas y minúsculas.Devuelve:</target>
        </trans-unit>
        <trans-unit id="c8469f270e6308a5204d808346468ba7e32ce5ba" translate="yes" xml:space="preserve">
          <source>On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.</source>
          <target state="translated">En un sistema UNIX esto no hace nada.Si no,convierte el &quot;/&quot;,&quot;/&quot;,&quot;/&quot; en las cosas apropiadas.</target>
        </trans-unit>
        <trans-unit id="ce6e6ab795a177a2429d9448acf045ddddf42374" translate="yes" xml:space="preserve">
          <source>On an UNIX system this does nothing. Else it converts &lt;code&gt;'/'&lt;/code&gt;, &lt;code&gt;'.'&lt;/code&gt;, &lt;code&gt;'..'&lt;/code&gt; to the appropriate things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410676d7292fbbcf827b204fd9a0c07b3ffe5980" translate="yes" xml:space="preserve">
          <source>On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.</source>
          <target state="translated">En los backends sin predicción de rama (JS y el nimscript VM),esta plantilla no afectará a la ejecución del código.</target>
        </trans-unit>
        <trans-unit id="71349d230261d02d2bc3058f2f163656370a285c" translate="yes" xml:space="preserve">
          <source>On non Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;em&gt;ignorePermissionErrors&lt;/em&gt; is true, errors while reading/setting file attributes will be ignored, otherwise will raise &lt;em&gt;OSError&lt;/em&gt;.</source>
          <target state="translated">En los sistemas que no son de Windows, los permisos se copian despu&amp;eacute;s de que se haya copiado el archivo, lo que no suceder&amp;aacute; de forma at&amp;oacute;mica y podr&amp;iacute;a provocar una condici&amp;oacute;n de carrera. Si &lt;em&gt;ignorePermissionErrors&lt;/em&gt; es verdadero, los errores al leer / configurar los atributos del archivo se ignorar&amp;aacute;n; de lo contrario, se generar&amp;aacute; &lt;em&gt;OSError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b26734ed023d711198160409aa5df1de55e088f2" translate="yes" xml:space="preserve">
          <source>On non Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;em&gt;ignorePermissionErrors&lt;/em&gt; is true, errors while reading/setting file attributes will be ignored, otherwise will raise &lt;em&gt;OSError&lt;/em&gt;.</source>
          <target state="translated">En sistemas que no son de Windows, los permisos se copian despu&amp;eacute;s de que se haya copiado el archivo o directorio, lo que no suceder&amp;aacute; de forma at&amp;oacute;mica y podr&amp;iacute;a provocar una condici&amp;oacute;n de carrera. Si &lt;em&gt;ignorePermissionErrors&lt;/em&gt; es verdadero, los errores al leer / configurar los atributos del archivo se ignorar&amp;aacute;n; de lo contrario, se generar&amp;aacute; &lt;em&gt;OSError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9214590a8005bcbc988e94c2ff34b8e0671fd615" translate="yes" xml:space="preserve">
          <source>On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable if it is set, otherwise it returns the default configuration directory (&quot;~/.config/&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5345a8b53344aaa0863f04f717114c18227851" translate="yes" xml:space="preserve">
          <source>On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the XDG_CONFIG_HOME environment variable if it is set, and returns the default configuration directory, &quot;~/.config/&quot;, otherwise.</source>
          <target state="translated">En los sistemas operativos que no son Windows,este procedimiento se ajusta a las especificaciones del Directorio Base XDG.Por lo tanto,este proc devuelve el valor de la variable de entorno XDG_CONFIG_HOME si está establecida,y devuelve el directorio de configuración por defecto,&quot;~/.config/&quot;,en caso contrario.</target>
        </trans-unit>
        <trans-unit id="1ef1878800148722a52d11621bb2995a19e795fa" translate="yes" xml:space="preserve">
          <source>On non-Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;code&gt;ignorePermissionErrors&lt;/code&gt; is true (default), errors while reading/setting file attributes will be ignored, otherwise will raise &lt;code&gt;OSError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7826bbb956520ceecb8ab7c01c0eac14d107b3b2" translate="yes" xml:space="preserve">
          <source>On non-Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;code&gt;ignorePermissionErrors&lt;/code&gt; is true (default), errors while reading/setting file attributes will be ignored, otherwise will raise &lt;code&gt;OSError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d198733f6e75c57f15a08ce67d688e4a62009004" translate="yes" xml:space="preserve">
          <source>On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. Use &lt;a href=&quot;#copyDirWithPermissions,string,string&quot;&gt;copyDirWithPermissions proc&lt;/a&gt; to preserve attributes recursively on these platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb66bc173e5cea45d224b1d00e5c254cf51c117" translate="yes" xml:space="preserve">
          <source>On other platforms you need to use &lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; procs to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions,string,string&quot;&gt;copyFileWithPermissions proc&lt;/a&gt;), otherwise &lt;code&gt;dest&lt;/code&gt; will inherit the default permissions of a newly created file for the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898bf4553278bc34226081a98acca7cca2299308" translate="yes" xml:space="preserve">
          <source>On posix this will search through the &lt;code&gt;/etc/services&lt;/code&gt; file.</source>
          <target state="translated">En posix, esto buscar&amp;aacute; en el &lt;code&gt;/etc/services&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c51ed0629b09b2b1d09d42b4681c845de22a12d3" translate="yes" xml:space="preserve">
          <source>On posix, if the process has exited because of a signal, 128 + signal number will be returned.</source>
          <target state="translated">En el posix,si el proceso ha salido por una señal,se devolverá el número de señal 128 +.</target>
        </trans-unit>
        <trans-unit id="db8215b423ef9bc86e0c61cb1eee5873cfe33f7d" translate="yes" xml:space="preserve">
          <source>On posix: returns true if &lt;code&gt;lastPathPart(path)&lt;/code&gt; starts with &lt;code&gt;.&lt;/code&gt; and is not &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3c38d17d46151c5d354197efeee10f8d783f2b" translate="yes" xml:space="preserve">
          <source>On relative paths, double dot (..) sequences are collapsed if possible. On absolute paths they are always collapsed.</source>
          <target state="translated">En los caminos relativos,las secuencias de doble punto (..)se colapsan si es posible.En las rutas absolutas siempre se colapsan.</target>
        </trans-unit>
        <trans-unit id="3b3d50c97cdc169f61ed97cda00a458b0a518724" translate="yes" xml:space="preserve">
          <source>On relative paths, double dot (&lt;code&gt;..&lt;/code&gt;) sequences are collapsed if possible. On absolute paths they are always collapsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd0de97e21f18a70dc40d4ea02d3e032d1e6822" translate="yes" xml:space="preserve">
          <source>On systems with a concept of &quot;drives&quot;, &lt;code&gt;drive&lt;/code&gt; is used to determine which drive label to use during absolute path conversion. &lt;code&gt;drive&lt;/code&gt; defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20fce5143547ae9c280f86e85a7f988d0055a8f" translate="yes" xml:space="preserve">
          <source>On systems with a concept of &quot;drives&quot;, &lt;em&gt;drive&lt;/em&gt; is used to determine which drive label to use during absolute path conversion. &lt;em&gt;drive&lt;/em&gt; defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</source>
          <target state="translated">En sistemas con un concepto de &quot;unidades&quot;, la &lt;em&gt;unidad&lt;/em&gt; se utiliza para determinar qu&amp;eacute; etiqueta de unidad utilizar durante la conversi&amp;oacute;n de ruta absoluta. &lt;em&gt;unidad tiene como valor&lt;/em&gt; predeterminado la unidad del directorio de trabajo actual y se ignora en sistemas que no tienen un concepto de &quot;unidades&quot;.</target>
        </trans-unit>
        <trans-unit id="919f238a50bd9c8a0b4c8aebc53de677589c1bbb" translate="yes" xml:space="preserve">
          <source>On the Windows platform this proc will copy the attributes from &lt;code&gt;source&lt;/code&gt; into &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632c6c96343e057ab2f11cb26fae25368444d555" translate="yes" xml:space="preserve">
          <source>On the Windows platform this proc will copy the source file's attributes into dest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e27ced0560e6c76c802fe94e33423bf08b2b55" translate="yes" xml:space="preserve">
          <source>On the other hand, if &lt;code&gt;spread&lt;/code&gt; is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3066034f3e12801386284630d4449cf120d021" translate="yes" xml:space="preserve">
          <source>On the other hand, if &lt;em&gt;spread&lt;/em&gt; is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.</source>
          <target state="translated">Por otro lado, si la &lt;em&gt;propagaci&amp;oacute;n&lt;/em&gt; es verdadera, el proceso distribuir&amp;aacute; uniformemente el resto de la divisi&amp;oacute;n en todas las secuencias, lo que hace que el resultado sea m&amp;aacute;s adecuado para subprocesos m&amp;uacute;ltiples donde se pasan unidades de trabajo de igual tama&amp;ntilde;o a un grupo de subprocesos y se desea maximizar el uso del n&amp;uacute;cleo. .</target>
        </trans-unit>
        <trans-unit id="317e86312cac8e36e1b7e5107ff34ed5cc4b1895" translate="yes" xml:space="preserve">
          <source>On the other hand, in Nim's future I would like to replace the VM by native code. A diff algorithm wouldn't work for that. Instead the native code would work with an API like &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">Por otro lado, en el futuro de Nim, me gustar&amp;iacute;a reemplazar la m&amp;aacute;quina virtual por c&amp;oacute;digo nativo. Un algoritmo de diferencias no funcionar&amp;iacute;a para eso. En cambio, el c&amp;oacute;digo nativo funcionar&amp;iacute;a con una API como &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="15cc13f1907198262a48b2f1247b799d1650a03d" translate="yes" xml:space="preserve">
          <source>On the other hand, in the &lt;code&gt;RingBuffer&lt;/code&gt; example above, the designated generic param is used to instantiate the non-pointer &lt;code&gt;seq&lt;/code&gt; type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; types):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25df01f5e813eafaaa5663850dd783a4040697d" translate="yes" xml:space="preserve">
          <source>On the other hand, in the &lt;em&gt;RingBuffer&lt;/em&gt; example above, the designated generic param is used to instantiate the non-pointer &lt;code&gt;seq&lt;/code&gt; type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; types):</source>
          <target state="translated">Por otro lado, en el ejemplo de &lt;em&gt;RingBuffer&lt;/em&gt; anterior, el &lt;em&gt;par&amp;aacute;metro&lt;/em&gt; gen&amp;eacute;rico designado se usa para instanciar el tipo &lt;code&gt;seq&lt;/code&gt; sin puntero , lo que significa que el tipo gen&amp;eacute;rico resultante tendr&amp;aacute; una covarianza que imita una matriz o secuencia (es decir, ser&amp;aacute; covariante solo cuando instanciado con los tipos &lt;code&gt;ptr&lt;/code&gt; y &lt;code&gt;ref&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="9c4aef9144f0f23eb3dbf979b7ad1a6367db8432" translate="yes" xml:space="preserve">
          <source>On the other hand, using &lt;code&gt;bind once&lt;/code&gt; types allows you to test for equivalent types used in multiple signatures, without actually requiring any concrete types, thus allowing you to encode implementation-defined types:</source>
          <target state="translated">Por otro lado, el uso de tipos de &lt;code&gt;bind once&lt;/code&gt; permite probar tipos equivalentes utilizados en m&amp;uacute;ltiples firmas, sin requerir ning&amp;uacute;n tipo concreto, lo que le permite codificar tipos definidos por implementaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="dba138949d4841696388d7021ef9a2601c30eef7" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;TableRef&lt;/code&gt; instead, then changes to &lt;code&gt;b&lt;/code&gt; also affect &lt;code&gt;a&lt;/code&gt;. Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;&lt;strong&gt;ref&lt;/strong&gt; the same data structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13d679112fedc32342b16f2848339011424e35e" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;em&gt;a&lt;/em&gt; is a TableRef instead, then changes to &lt;em&gt;b&lt;/em&gt; also affect &lt;em&gt;a&lt;/em&gt;. Both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; reference the same data structure:</source>
          <target state="translated">Por otro lado, cuando &lt;em&gt;una&lt;/em&gt; es una TableRef lugar, luego cambia a &lt;em&gt;b&lt;/em&gt; tambi&amp;eacute;n afectan a &lt;em&gt;una&lt;/em&gt; . Tanto &lt;em&gt;a&lt;/em&gt; como &lt;em&gt;b hacen&lt;/em&gt; referencia a la misma estructura de datos:</target>
        </trans-unit>
        <trans-unit id="37d18afb7f631d26e467ad1c5e79cc58b688edd5" translate="yes" xml:space="preserve">
          <source>On top of generating libraries or standalone applications, Nim offers bidirectional interfacing with the backend targets through generic and specific pragmas.</source>
          <target state="translated">Además de generar librerías o aplicaciones autónomas,Nim ofrece una interfaz bidireccional con los objetivos del backend a través de pragmas genéricos y específicos.</target>
        </trans-unit>
        <trans-unit id="c81da6451dca2da62ae25f6caf1eff5bac5311d0" translate="yes" xml:space="preserve">
          <source>On top of that, there is also the &lt;code&gt;typ&lt;/code&gt; field for the type. It the kind of the &lt;code&gt;typ&lt;/code&gt; field can be one of the following ones, and it should be matching the literal kind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c2d48642cb046e2bbc4639d90dcf6445b4e94f" translate="yes" xml:space="preserve">
          <source>On windows, if a root of &lt;code&gt;path&lt;/code&gt; and a root of &lt;code&gt;base&lt;/code&gt; are different, returns &lt;code&gt;path&lt;/code&gt; as is because it is impossible to make a relative path. That means an absolute path can be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab18c0b5501aadd3a3af3f1ceb793c3f49cf6f2" translate="yes" xml:space="preserve">
          <source>OnHeap:</source>
          <target state="translated">OnHeap:</target>
        </trans-unit>
        <trans-unit id="568f54818fab1d16943bd423920f09da70e89138" translate="yes" xml:space="preserve">
          <source>OnStack:</source>
          <target state="translated">OnStack:</target>
        </trans-unit>
        <trans-unit id="db6805e8c7cfbc2552a2ae4ead1110380c4f8151" translate="yes" xml:space="preserve">
          <source>OnStatic:</source>
          <target state="translated">OnStatic:</target>
        </trans-unit>
        <trans-unit id="15222cc1cfca09f665b5c4bd79a604c8a5fda245" translate="yes" xml:space="preserve">
          <source>OnUnknown:</source>
          <target state="translated">OnUnknown:</target>
        </trans-unit>
        <trans-unit id="b55aab0a049cabc5b434393773f26e77af86b5f9" translate="yes" xml:space="preserve">
          <source>Once a logger has been created, call its &lt;a href=&quot;#log.e,ConsoleLogger,Level,varargs%5Bstring,%5D&quot;&gt;log proc&lt;/a&gt; to log a message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8edce91442634d7387fe386cb073a4a709ecff8" translate="yes" xml:space="preserve">
          <source>Once bound, type params can appear in the rest of the proc signature:</source>
          <target state="translated">Una vez encuadernado,los parámetros del tipo pueden aparecer en el resto de la firma del proceso:</target>
        </trans-unit>
        <trans-unit id="609040b49e0851c8e7801cc6b5b773d38bc4bba4" translate="yes" xml:space="preserve">
          <source>Once declared, a constant's symbol can be used as a constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b47a60e99f1394d99a1c045b8c28b67a9fc8f6a" translate="yes" xml:space="preserve">
          <source>Once everything is registered in a dispatcher, you need to call the &lt;code&gt;poll&lt;/code&gt; function in a while loop.</source>
          <target state="translated">Una vez que todo est&amp;aacute; registrado en un despachador, debe llamar a la funci&amp;oacute;n de &lt;code&gt;poll&lt;/code&gt; en un ciclo while.</target>
        </trans-unit>
        <trans-unit id="d5654d82c2a3884c2cbc3f1c679468b9597dacae" translate="yes" xml:space="preserve">
          <source>Once index files have been generated for one or more modules, the Nim compiler command &lt;code&gt;buildIndex directory&lt;/code&gt; can be run to go over all the index files in the specified directory to generate a &lt;a href=&quot;https://nim-lang.org/docs/theindex.html&quot;&gt;theindex.html&lt;/a&gt; file.</source>
          <target state="translated">Una vez que se han generado los archivos de &amp;iacute;ndice para uno o m&amp;aacute;s m&amp;oacute;dulos, se puede ejecutar el &lt;code&gt;buildIndex directory&lt;/code&gt; comando del compilador de Nim para revisar todos los archivos de &amp;iacute;ndice en el directorio especificado para generar un archivo &lt;a href=&quot;https://nim-lang.org/docs/theindex.html&quot;&gt;theindex.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9093fbfa7147de35adc3e237969b8a5f741293d8" translate="yes" xml:space="preserve">
          <source>Once the current log file being written to contains &lt;code&gt;maxLines&lt;/code&gt; lines, a new log file will be created, and the old log file will be renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60efbade01d07951321fcb62a711c7c0a4d46ba" translate="yes" xml:space="preserve">
          <source>Once you have a &lt;code&gt;JsonNode&lt;/code&gt;, retrieving the values can then be achieved by using one of the helper procedures, which include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba237fb6a97d475a345fe56549779371d65c0b14" translate="yes" xml:space="preserve">
          <source>Once you have code like this in place, if the list of raised exception changes the compiler will stop with an error specifying the line of the proc which stopped validating the pragma and the raised exception not being caught, along with the file and line where the uncaught exception is being raised, which may help you locate the offending code which has changed.</source>
          <target state="translated">Una vez que se tiene un código como este en su lugar,si la lista de excepciones planteadas cambia,el compilador se detendrá con un error que especifica la línea del proc que dejó de validar la pragma y la excepción planteada que no está siendo capturada,junto con el archivo y la línea donde se está planteando la excepción no capturada,lo que puede ayudar a localizar el código ofensivo que ha cambiado.</target>
        </trans-unit>
        <trans-unit id="e837030f84dd416a1763c3313ad3b60179285a22" translate="yes" xml:space="preserve">
          <source>Once your code is compiled for hot reloading, you can use a framework such as &lt;em&gt;LiveReload &amp;lt;http://livereload.com/&amp;gt;&lt;/em&gt; or &lt;em&gt;BrowserSync &amp;lt;https://browsersync.io/&amp;gt;&lt;/em&gt; to implement the actual reloading behavior in your project.</source>
          <target state="translated">Una vez que su c&amp;oacute;digo est&amp;aacute; compilado para la recarga en caliente, puede usar un marco como &lt;em&gt;LiveReload &amp;lt;http://livereload.com/&amp;gt;&lt;/em&gt; o &lt;em&gt;BrowserSync &amp;lt;https://browsersync.io/&amp;gt;&lt;/em&gt; para implementar el comportamiento de recarga real en su proyecto.</target>
        </trans-unit>
        <trans-unit id="b2d92002386ccab2c66af44a60e6f00bc53d2d7b" translate="yes" xml:space="preserve">
          <source>Once your macro is finished, there are two ways to invoke it:</source>
          <target state="translated">Una vez que su macro está terminada,hay dos maneras de invocarla:</target>
        </trans-unit>
        <trans-unit id="c95e6032530fcbf63e3fb9d935e3a4900b15a008" translate="yes" xml:space="preserve">
          <source>One can force an expression to be evaluated at compile time as a constant expression by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83e207267fa148c2a0ca5ddf816169f22ace210" translate="yes" xml:space="preserve">
          <source>One can obtain the type of a given expression by constructing a &lt;code&gt;typeof&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe69f9cd71b11c831e91b58e239cae9c34d55dc8" translate="yes" xml:space="preserve">
          <source>One can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2e14b82a6a078671a4c4d9c4519514eb953104" translate="yes" xml:space="preserve">
          <source>One can tell the compiler about the convention that a parameter of name &lt;code&gt;c&lt;/code&gt; should default to type &lt;code&gt;Context&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; should default to &lt;code&gt;Node&lt;/code&gt; etc.:</source>
          <target state="translated">Uno puede decirle al compilador acerca de la convenci&amp;oacute;n de que un par&amp;aacute;metro de nombre &lt;code&gt;c&lt;/code&gt; deber&amp;iacute;a por defecto escribir &lt;code&gt;Context&lt;/code&gt; o , &lt;code&gt;n&lt;/code&gt; deber&amp;iacute;a por defecto a &lt;code&gt;Node&lt;/code&gt; etc .:</target>
        </trans-unit>
        <trans-unit id="b441a31745d56840471825f544c92905083aa43a" translate="yes" xml:space="preserve">
          <source>One can use &lt;span id=&quot;tuple-unpacking_1&quot;&gt;tuple unpacking&lt;/span&gt; to access the tuple's fields:</source>
          <target state="translated">Se puede utilizar el &lt;span id=&quot;tuple-unpacking_1&quot;&gt;desempaquetado de tuplas&lt;/span&gt; para acceder a los campos de la tupla:</target>
        </trans-unit>
        <trans-unit id="0aae6e8e4a31c5c278e8ef5e9e83aa14fc870267" translate="yes" xml:space="preserve">
          <source>One can use a temporary helper variable, for example instead of &lt;code&gt;x = p(8)&lt;/code&gt; use &lt;code&gt;let tmp = p(8); x = tmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6393931ab1901888c2c40493d5e9e26b0c1998b" translate="yes" xml:space="preserve">
          <source>One of Nim's cool features is pragmas, which allow fine-tuning of various aspects of the language. They come in all types, such as adorning procs and objects, but the standalone &lt;code&gt;emit&lt;/code&gt; pragma shows the basics with the AST.</source>
          <target state="translated">Una de las caracter&amp;iacute;sticas interesantes de Nim son los pragmas, que permiten ajustar varios aspectos del idioma. Vienen en todos los tipos, como adornos de procesos y objetos, pero el pragma de &lt;code&gt;emit&lt;/code&gt; independiente muestra lo b&amp;aacute;sico con el AST.</target>
        </trans-unit>
        <trans-unit id="da1a3f527bb79b13e631a70eceb3b03667fef012" translate="yes" xml:space="preserve">
          <source>One or more</source>
          <target state="translated">Uno o más</target>
        </trans-unit>
        <trans-unit id="2e948a81e04389675a5a97047baf132370163826" translate="yes" xml:space="preserve">
          <source>One or more: Apply expression &lt;code&gt;E&lt;/code&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2207e76c212f3f40ba5c67c82dea4cf30adfcd7c" translate="yes" xml:space="preserve">
          <source>One or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise indicate failure.</source>
          <target state="translated">Uno o m&amp;aacute;s: aplique la expresi&amp;oacute;n &lt;em&gt;E&lt;/em&gt; repetidamente para que coincida con el texto anterior, siempre que tenga &amp;eacute;xito. Consuma el texto coincidente (si lo hay) e indique el &amp;eacute;xito si hubo al menos una coincidencia. De lo contrario, indique falla.</target>
        </trans-unit>
        <trans-unit id="7580ae8512abee0f0777a780954b22b310c552f2" translate="yes" xml:space="preserve">
          <source>One problem with rules 3 and 4 is that they affect specific global or thread local variables, but Nim's effect tracking only tracks &quot;uses no global variable&quot; via &lt;code&gt;.noSideEffect&lt;/code&gt;. The rules 3 and 4 can also be approximated by a different rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4680ad8f0f14c282d731ada768ace3aaf946a2" translate="yes" xml:space="preserve">
          <source>One should overload this proc if one wants to overload the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcabe66eb85b400f8ef4fa596004eac08e1527ca" translate="yes" xml:space="preserve">
          <source>One should overload this proc if one wants to overload the &lt;code&gt;in&lt;/code&gt; operator. The parameters are in reverse order! &lt;code&gt;a in b&lt;/code&gt; is a template for &lt;code&gt;contains(b, a)&lt;/code&gt;. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the &lt;code&gt;in&lt;/code&gt; operator that would be the wrong direction for this piece of code:</source>
          <target state="translated">Uno debe sobrecargar este proc si uno quiere sobrecargar el &lt;code&gt;in&lt;/code&gt; operador. &amp;iexcl;Los par&amp;aacute;metros est&amp;aacute;n en orden inverso! &lt;code&gt;a in b&lt;/code&gt; es una plantilla para &lt;code&gt;contains(b, a)&lt;/code&gt; . Esto se debe a que el algoritmo de unificaci&amp;oacute;n que utiliza Nim para la resoluci&amp;oacute;n de sobrecargas funciona de izquierda a derecha. Pero para el operador &lt;code&gt;in&lt;/code&gt; , esa ser&amp;iacute;a la direcci&amp;oacute;n incorrecta para este fragmento de c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="b3ed0c36ef143962232eea5026e9f624f11115c4" translate="yes" xml:space="preserve">
          <source>One very nice advantage over regular expressions is that &lt;code&gt;scanf&lt;/code&gt; is extensible with ordinary Nim procs. The proc is either enclosed in &lt;code&gt;${}&lt;/code&gt; or in &lt;code&gt;$[]&lt;/code&gt;. &lt;code&gt;${}&lt;/code&gt; matches and binds the result to a variable (that was passed to the &lt;code&gt;scanf&lt;/code&gt; macro) while &lt;code&gt;$[]&lt;/code&gt; merely matches optional tokens without any result binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e4679df7a5cffe918b1e69c86872ec6282c2aa" translate="yes" xml:space="preserve">
          <source>One very nice advantage over regular expressions is that &lt;code&gt;scanf&lt;/code&gt; is extensible with ordinary Nim procs. The proc is either enclosed in &lt;code&gt;${}&lt;/code&gt; or in &lt;code&gt;$[]&lt;/code&gt;. &lt;code&gt;${}&lt;/code&gt; matches and binds the result to a variable (that was passed to the &lt;code&gt;scanf&lt;/code&gt; macro) while &lt;code&gt;$[]&lt;/code&gt; merely optional tokens.</source>
          <target state="translated">Una muy buena ventaja sobre las expresiones regulares es que &lt;code&gt;scanf&lt;/code&gt; es extensible con los procesos normales de Nim. El proceso se incluye entre &lt;code&gt;${}&lt;/code&gt; o &lt;code&gt;$[]&lt;/code&gt; . &lt;code&gt;${}&lt;/code&gt; coincide y vincula el resultado a una variable (que se pas&amp;oacute; a la macro &lt;code&gt;scanf&lt;/code&gt; ) mientras que &lt;code&gt;$[]&lt;/code&gt; simplemente tokens opcionales.</target>
        </trans-unit>
        <trans-unit id="488e4498e568d4ebdd0ca2157ae6748d000ab688" translate="yes" xml:space="preserve">
          <source>One:</source>
          <target state="translated">One:</target>
        </trans-unit>
        <trans-unit id="7aa20e42e9fac36bab86ec5c3c5c9673fd5be3ee" translate="yes" xml:space="preserve">
          <source>Only available for numbers types. Note that the sequence will be uninitialized. After the creation of the sequence you should assign entries to the sequence instead of adding them.</source>
          <target state="translated">Sólo disponible para los tipos de números.Tenga en cuenta que la secuencia no será inicializada.Después de la creación de la secuencia debería asignar entradas a la secuencia en lugar de añadirlas.</target>
        </trans-unit>
        <trans-unit id="7532cddc260a1527eb39bd5975f976f61cc3dd83" translate="yes" xml:space="preserve">
          <source>Only error and fatal messages will cause the output buffer to be flushed immediately. Use the &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; to flush the buffer manually if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc370c46bbbf0bf1dd85847affcf8aaa6e750bc" translate="yes" xml:space="preserve">
          <source>Only used in PSK ciphersuites.</source>
          <target state="translated">Sólo se usa en las suites de cifrado PSK.</target>
        </trans-unit>
        <trans-unit id="ceea6a715ca43640a59d2dcdf7b7681ea3882443" translate="yes" xml:space="preserve">
          <source>Only useful if set server-side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bd3d75d2161188ac0381f01f684cf113e3579e" translate="yes" xml:space="preserve">
          <source>OpChars:</source>
          <target state="translated">OpChars:</target>
        </trans-unit>
        <trans-unit id="061313292428912182098de432d58a7d8e9cc1bb" translate="yes" xml:space="preserve">
          <source>Open a parser, using the given arguments to set up its internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eef2b7e3d6c43c01d59bb1d06ba5236003b6a81" translate="yes" xml:space="preserve">
          <source>Open and Closed symbols</source>
          <target state="translated">Símbolos de abierto y cerrado</target>
        </trans-unit>
        <trans-unit id="cc4d804a9a52970f4e0eefea5bf1b6f54e9967fb" translate="yes" xml:space="preserve">
          <source>Open arrays</source>
          <target state="translated">Matrices abiertas</target>
        </trans-unit>
        <trans-unit id="3e4447a76d334227b53f87594f9577969a26e881" translate="yes" xml:space="preserve">
          <source>Open database connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0714f9844e88b33e62cf52d5b0d001860502d901" translate="yes" xml:space="preserve">
          <source>Open input stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab2517dbed2bed693f918f911730ef79e6d5360" translate="yes" xml:space="preserve">
          <source>Open symbols are looked up in two different contexts: Both the context at definition and the context at instantiation are considered:</source>
          <target state="translated">Los símbolos abiertos se buscan en dos contextos diferentes:Se considera tanto el contexto en la definición como el contexto en la instanciación:</target>
        </trans-unit>
        <trans-unit id="6dc1a7bf5dd1013cab3f801ec28857dece149460" translate="yes" xml:space="preserve">
          <source>OpenMP parallel loop iterator with stepping. Same as &lt;code&gt;countup&lt;/code&gt; but the loop may run in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67376ee07cbce917e8219510219ec5b620099129" translate="yes" xml:space="preserve">
          <source>OpenMP parallel loop iterator. Same as &lt;code&gt;..&lt;/code&gt; but the loop may run in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b366a2a3d0445fcc6195c7e8bf9aa2ec87d29a" translate="yes" xml:space="preserve">
          <source>OpenSSL 0.9.8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1948a8835e811d7bb8fe3dc8f03cdae689640cb" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.0.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c6ce40f6dd891b1898209548f158bde2dc23bc" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d77bab6bef6033d1033ca864d642fde957a56f8" translate="yes" xml:space="preserve">
          <source>OpenSSL can also be statically linked using &lt;code&gt;--dynlibOverride:ssl&lt;/code&gt; for OpenSSL &amp;gt;= 1.1.0. If you want to statically link against OpenSSL 1.0.x, you now have to define the &lt;code&gt;openssl10&lt;/code&gt; symbol via &lt;code&gt;-d:openssl10&lt;/code&gt;.</source>
          <target state="translated">OpenSSL tambi&amp;eacute;n se puede vincular est&amp;aacute;ticamente usando &lt;code&gt;--dynlibOverride:ssl&lt;/code&gt; para OpenSSL&amp;gt; = 1.1.0. Si desea vincular est&amp;aacute;ticamente con OpenSSL 1.0.x, ahora debe definir el s&amp;iacute;mbolo &lt;code&gt;openssl10&lt;/code&gt; mediante &lt;code&gt;-d:openssl10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0576b64464ad64eb4c53eaa5c4ef2696b5bb4d5" translate="yes" xml:space="preserve">
          <source>OpenSSL support</source>
          <target state="translated">El soporte de OpenSSL</target>
        </trans-unit>
        <trans-unit id="41785aa4105d96f7aa2063837bbf62b9d0c42838" translate="yes" xml:space="preserve">
          <source>Opening a connection to a database</source>
          <target state="translated">Abrir una conexión a una base de datos</target>
        </trans-unit>
        <trans-unit id="075f451d6a093e7fdd7b9ad18b76dcfe972397a7" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;url&lt;/code&gt; with the user's default browser. This does not block. The URL must not be empty string, to open on a blank page see &lt;code&gt;openDefaultBrowser()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d145821f017af9ef3f638af874e9b10829b0995" translate="yes" xml:space="preserve">
          <source>Opens a channel &lt;code&gt;c&lt;/code&gt; for inter thread communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b5a32312a9dd72c3dba0d99cdc13009520ada4" translate="yes" xml:space="preserve">
          <source>Opens a database connection.</source>
          <target state="translated">Abre una conexión de base de datos.</target>
        </trans-unit>
        <trans-unit id="6341a3385125d358f254687a1cf9ec666ef3ba23" translate="yes" xml:space="preserve">
          <source>Opens a database connection. Raises a &lt;code&gt;DbError&lt;/code&gt; exception if the connection could not be established.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc6b3e2b4c985f7646af8662c40813a043d8273" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; for reading, calls &lt;a href=&quot;#readAll,File&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;system#staticRead,string&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5bedf756c39d16773af1a78426390def78e208" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; for writing. Then writes the &lt;code&gt;content&lt;/code&gt; completely to the file and closes the file afterwards. Raises an IO exception in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38b309e7cb64778d65091ba8fb43d41a2afd811" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; with given &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d89b0ce8e9218e6fea12851e9b880be1e4997d4" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; for reading.</source>
          <target state="translated">Abre un archivo llamado &lt;em&gt;nombre&lt;/em&gt; de &lt;em&gt;archivo&lt;/em&gt; para su lectura.</target>
        </trans-unit>
        <trans-unit id="a04bc38a4be5b20cb1f277438e98d1933fa9e233" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; for writing. Then writes the &lt;em&gt;content&lt;/em&gt; completely to the file and closes the file afterwards. Raises an IO exception in case of an error.</source>
          <target state="translated">Abre un archivo llamado &lt;em&gt;nombre&lt;/em&gt; de &lt;em&gt;archivo&lt;/em&gt; para escritura. Luego escribe el &lt;em&gt;contenido&lt;/em&gt; completamente en el archivo y luego cierra el archivo. Genera una excepci&amp;oacute;n de E / S en caso de error.</target>
        </trans-unit>
        <trans-unit id="eaf81cf94eccf62abfb731ae2352ef1f7afad678" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; with given &lt;em&gt;mode&lt;/em&gt;.</source>
          <target state="translated">Abre un archivo llamado &lt;em&gt;nombre de archivo&lt;/em&gt; con el &lt;em&gt;modo&lt;/em&gt; dado .</target>
        </trans-unit>
        <trans-unit id="14f607a4816b562ae72f4697df3c9b5d1e94db71" translate="yes" xml:space="preserve">
          <source>Opens a file specified by the path in &lt;code&gt;filename&lt;/code&gt; using the specified FileMode &lt;code&gt;mode&lt;/code&gt; asynchronously.</source>
          <target state="translated">Abre un archivo especificado por la ruta en el &lt;code&gt;filename&lt;/code&gt; de archivo usando el &lt;code&gt;mode&lt;/code&gt; FileMode especificado de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="d0bbee2462ecfc98727ddc0ff7d24ba7bbb75c45" translate="yes" xml:space="preserve">
          <source>Opens the user's default browser without any &lt;code&gt;url&lt;/code&gt; (blank page). This does not block. Implements IETF RFC-6694 Section 3, &quot;about:blank&quot; must be reserved for a blank page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1668ac138ae92ffacd3116296d3548db776f14" translate="yes" xml:space="preserve">
          <source>Opera 20</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b0fc59d7aad8bc81ae95e641aa3418061b2802" translate="yes" xml:space="preserve">
          <source>Opera 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad0a017eb9f00073f41816df228a99ee3a83534" translate="yes" xml:space="preserve">
          <source>Opera 57</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="27fea8d4a592d2ef15188641818c4f50cf213496" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;mitems&lt;/code&gt; or &lt;code&gt;mpairs&lt;/code&gt; (or the now deprecated &lt;code&gt;mget&lt;/code&gt;) that allow a &lt;em&gt;mutating view&lt;/em&gt; into some data structure should start with an &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Las operaciones como &lt;code&gt;mitems&lt;/code&gt; o &lt;code&gt;mpairs&lt;/code&gt; (o el &lt;code&gt;mget&lt;/code&gt; ahora obsoleto ) que permiten una &lt;em&gt;vista mutante&lt;/em&gt; en alguna estructura de datos deben comenzar con una &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="2eb04c37cf98ac30d71ff1b2f86ff1286db3a060" translate="yes" xml:space="preserve">
          <source>Operators ending in either &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;~&amp;gt;&lt;/code&gt; or &lt;code&gt;=&amp;gt;&lt;/code&gt; are called &lt;span id=&quot;arrow-like_1&quot;&gt;arrow like&lt;/span&gt;, and have the lowest precedence of all operators.</source>
          <target state="translated">Los operadores que terminan en &lt;code&gt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;~&amp;gt;&lt;/code&gt; o &lt;code&gt;=&amp;gt;&lt;/code&gt; se denominan &lt;span id=&quot;arrow-like_1&quot;&gt;como flechas&lt;/span&gt; y tienen la precedencia m&amp;aacute;s baja de todos los operadores.</target>
        </trans-unit>
        <trans-unit id="b9fb7505b70ebf5d6a9bf27d2cc12bbd40ee6af9" translate="yes" xml:space="preserve">
          <source>Operators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.</source>
          <target state="translated">Los operadores con un parámetro son operadores prefijos,los operadores con dos parámetros son operadores infijos.(Sin embargo,el analizador los distingue de la posición del operador dentro de una expresión).No hay forma de declarar operadores postfix:todos los operadores postfix están incorporados y son manejados por la gramática explícitamente.</target>
        </trans-unit>
        <trans-unit id="6ff265181afd92a333026e2c5d5e199dc5da7ef8" translate="yes" xml:space="preserve">
          <source>Operators:</source>
          <target state="translated">Operators:</target>
        </trans-unit>
        <trans-unit id="4cad12b6f389d483084d0d553643ba732946936d" translate="yes" xml:space="preserve">
          <source>Optimize the code for speed or size, or disable optimization.</source>
          <target state="translated">Optimizar el código para la velocidad o el tamaño,o desactivar la optimización.</target>
        </trans-unit>
        <trans-unit id="5bc67490a69e2f143ae9471a30d11d13f1cf0a23" translate="yes" xml:space="preserve">
          <source>Optimized version of &lt;a href=&quot;#replace,string,string&quot;&gt;replace&lt;/a&gt; for characters.</source>
          <target state="translated">Versi&amp;oacute;n optimizada de &lt;a href=&quot;#replace,string,string&quot;&gt;reemplazar&lt;/a&gt; para personajes.</target>
        </trans-unit>
        <trans-unit id="5a8298c3a957647aef96f07b3da793f45200cac3" translate="yes" xml:space="preserve">
          <source>Optimized version of &lt;a href=&quot;#replace,string,string,string&quot;&gt;replace&lt;/a&gt; for characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13225c7d848cc0d6dfe6ef6391b22b19c1fefb1b" translate="yes" xml:space="preserve">
          <source>Optimizer:</source>
          <target state="translated">Optimizer:</target>
        </trans-unit>
        <trans-unit id="eeaab884d147b712e7cd622a4a60b4a88154310b" translate="yes" xml:space="preserve">
          <source>Optimizing for Nim</source>
          <target state="translated">Optimizando para Nim</target>
        </trans-unit>
        <trans-unit id="b48db209b043766c1b5804d5e27bcd73790ad927" translate="yes" xml:space="preserve">
          <source>Optimizing string handling</source>
          <target state="translated">Optimizar el manejo de las cuerdas</target>
        </trans-unit>
        <trans-unit id="74b1e148d5f6b3cc16368babcbaee255c62422d6" translate="yes" xml:space="preserve">
          <source>Optional human readable string to display as hyper link. If the value is not present or is the empty string, the hyper link will be rendered using the term. Prefix whitespace indicates that this entry is not for an API symbol but for a TOC entry.</source>
          <target state="translated">Cadena opcional legible por el hombre para mostrar como hipervínculo.Si el valor no está presente o es la cadena vacía,el hiperenlace se mostrará usando el término.El prefijo de espacio en blanco indica que esta entrada no es para un símbolo API sino para una entrada TOC.</target>
        </trans-unit>
        <trans-unit id="d39225d11f759a6f965920f1aaea6c3af2e9f0dd" translate="yes" xml:space="preserve">
          <source>Optional title or description of the hyper link. Browsers usually display this as a tooltip after hovering a moment over the hyper link.</source>
          <target state="translated">Título opcional o descripción del hipervínculo.Los navegadores suelen mostrar esto como una herramienta de ayuda después de pasar un momento por encima del hipervínculo.</target>
        </trans-unit>
        <trans-unit id="c193b422d4cdb46518f62b1308dcbb7e534adc1e" translate="yes" xml:space="preserve">
          <source>Optionally, the initial capacity can be reserved via &lt;code&gt;initialSize&lt;/code&gt; as a performance optimization. The length of a newly created deque will still be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1957a08c23244cb7c73a47bb45230876010740d3" translate="yes" xml:space="preserve">
          <source>Optionally: manpages, documentation, shell completion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a81599fb16f88a774e6e6dde5e5c88bf3a24004" translate="yes" xml:space="preserve">
          <source>Options that can be passed to &lt;a href=&quot;#startProcess,string,string,openArray%5Bstring%5D,StringTableRef,set%5BProcessOption%5D&quot;&gt;startProcess proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="81de498479269f7efcd2ce9f7789819338e86fcf" translate="yes" xml:space="preserve">
          <source>Or if we directly use a ref object:</source>
          <target state="translated">O si usamos directamente un objeto de referencia:</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="21ab442b56e6693d449e1b3316a7c72b27f04270" translate="yes" xml:space="preserve">
          <source>Order of evaluation</source>
          <target state="translated">Orden de evaluación</target>
        </trans-unit>
        <trans-unit id="6fddf2edd42bb52326d95d7ad197008a3ad3c62b" translate="yes" xml:space="preserve">
          <source>Order of evaluation is strictly left-to-right, inside-out as it is typical for most others imperative programming languages:</source>
          <target state="translated">El orden de evaluación es estrictamente de izquierda a derecha,de adentro hacia afuera como es típico en la mayoría de los otros lenguajes de programación imperativos:</target>
        </trans-unit>
        <trans-unit id="45f68e3d201980b2ce2fa3c6e8912431c529664b" translate="yes" xml:space="preserve">
          <source>Ordered choice: Apply expressions &lt;code&gt;A&lt;/code&gt;, ..., &lt;code&gt;Z&lt;/code&gt;, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise do not consume any text and indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab66e435888dccd3c76f559e634b263fcd8938b5" translate="yes" xml:space="preserve">
          <source>Ordered choice: Apply expressions &lt;em&gt;A&lt;/em&gt;, ..., &lt;em&gt;Z&lt;/em&gt;, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise do not consume any text and indicate failure.</source>
          <target state="translated">Elecci&amp;oacute;n ordenada: aplique las expresiones &lt;em&gt;A&lt;/em&gt; , ..., &lt;em&gt;Z&lt;/em&gt; , en este orden, al texto siguiente, hasta que una de ellas tenga &amp;eacute;xito y posiblemente consuma algo de texto. Indique &amp;eacute;xito si una de las expresiones tuvo &amp;eacute;xito. De lo contrario, no consuma ning&amp;uacute;n texto e indique falla.</target>
        </trans-unit>
        <trans-unit id="52eba0e6519807164baca0d6b1158a8ecd7de4c9" translate="yes" xml:space="preserve">
          <source>OrderedTable</source>
          <target state="translated">OrderedTable</target>
        </trans-unit>
        <trans-unit id="bca57d661a7ac85cef723a55cd585566c9d3f621" translate="yes" xml:space="preserve">
          <source>Ordinal types</source>
          <target state="translated">Tipos ordinarios</target>
        </trans-unit>
        <trans-unit id="3119a2318ed75057b08b3960866241e029fabd75" translate="yes" xml:space="preserve">
          <source>Ordinal types are countable and ordered. This property allows the operation of functions as &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt; on ordinal types to be defined.</source>
          <target state="translated">Los tipos ordinales son contables y ordenados. Esta propiedad permite definir el funcionamiento de funciones como &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;ord&lt;/code&gt; , &lt;code&gt;dec&lt;/code&gt; en tipos ordinales.</target>
        </trans-unit>
        <trans-unit id="872a8c3d6d59041261f393e2e15158de859ea0da" translate="yes" xml:space="preserve">
          <source>Ordinal types have the following characteristics:</source>
          <target state="translated">Los tipos ordinarios tienen las siguientes características:</target>
        </trans-unit>
        <trans-unit id="e629aac27b5777617cee72722956d8b340e2199c" translate="yes" xml:space="preserve">
          <source>Ordinal values have a largest possible value. Trying to count further than the largest value gives a checked runtime or static error.</source>
          <target state="translated">Los valores ordinarios tienen el mayor valor posible.Tratar de contar más allá del valor más grande da un tiempo de ejecución comprobado o un error estático.</target>
        </trans-unit>
        <trans-unit id="36acb83b7e99f490d0435fdeb44f36127e91db65" translate="yes" xml:space="preserve">
          <source>Ordinal values have a smallest possible value. Trying to count further down than the smallest value gives a checked runtime or static error.</source>
          <target state="translated">Los valores ordinales tienen un valor mínimo posible.Tratar de contar más allá del valor más pequeño da un tiempo de ejecución comprobado o un error estático.</target>
        </trans-unit>
        <trans-unit id="a3273ae720a4e64dcca9795fe755e4b9213bc669" translate="yes" xml:space="preserve">
          <source>Ordinal values have the largest possible value. Trying to count further than the largest value produces a panic or a static error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563bb5bf58644ad6723e724e397712047e75b6e7" translate="yes" xml:space="preserve">
          <source>Ordinal values have the smallest possible value. Trying to count further down than the smallest value produces a panic or a static error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa953406f4d182ae08a38375892d6aff714ff91" translate="yes" xml:space="preserve">
          <source>OrdinalType.FloatLike</source>
          <target state="translated">OrdinalType.FloatLike</target>
        </trans-unit>
        <trans-unit id="88dcff2ae87c9e99ad5c60ac3538a976e2816c25" translate="yes" xml:space="preserve">
          <source>OrdinalType.IntLike</source>
          <target state="translated">OrdinalType.IntLike</target>
        </trans-unit>
        <trans-unit id="f88d1629d2c6e62128639c388362a7be4a950f39" translate="yes" xml:space="preserve">
          <source>OrdinalType.NoneLike</source>
          <target state="translated">OrdinalType.NoneLike</target>
        </trans-unit>
        <trans-unit id="a47cfd3d99cec2694c9dbb5322d0b724efa09a94" translate="yes" xml:space="preserve">
          <source>OrdinalType:</source>
          <target state="translated">OrdinalType:</target>
        </trans-unit>
        <trans-unit id="3ed1f6c1083d3683b1c12d25ec50e612d1123f42" translate="yes" xml:space="preserve">
          <source>Ordinals</source>
          <target state="translated">Ordinals</target>
        </trans-unit>
        <trans-unit id="aa2feef9929fb50eb0970ed959dead68aeaa3fc1" translate="yes" xml:space="preserve">
          <source>Ordinary code should not use this, but the &lt;a href=&quot;typeinfo&quot;&gt;typeinfo module&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d640a1890d09eeb8ca875d238db12f1e6d3c3e8" translate="yes" xml:space="preserve">
          <source>Ordinary procs are often preferred over type conversions in Nim: For instance, &lt;code&gt;$&lt;/code&gt; is the &lt;code&gt;toString&lt;/code&gt; operator by convention and &lt;code&gt;toFloat&lt;/code&gt; and &lt;code&gt;toInt&lt;/code&gt; can be used to convert from floating point to integer or vice versa.</source>
          <target state="translated">Los procesos ordinarios a menudo se prefieren a las conversiones de tipos en Nim: por ejemplo, &lt;code&gt;$&lt;/code&gt; es el operador &lt;code&gt;toString&lt;/code&gt; por convenci&amp;oacute;n y &lt;code&gt;toFloat&lt;/code&gt; y &lt;code&gt;toInt&lt;/code&gt; se pueden usar para convertir de punto flotante a entero o viceversa.</target>
        </trans-unit>
        <trans-unit id="0ec5421d5a04b330a5d5f07445ff5c33b2ee43c5" translate="yes" xml:space="preserve">
          <source>Ordinary procs are often preferred over type conversions in Nim: For instance, &lt;code&gt;$&lt;/code&gt; is the &lt;code&gt;toString&lt;/code&gt; operator by convention and &lt;code&gt;toFloat&lt;/code&gt; and &lt;code&gt;toInt&lt;/code&gt; can be used to convert from floating-point to integer or vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="2ff9f42e32037de9fa807030da493664b568f9f2" translate="yes" xml:space="preserve">
          <source>Other Input Formats</source>
          <target state="translated">Otros formatos de entrada</target>
        </trans-unit>
        <trans-unit id="43a5e3b913b70aa6bbf66b3f9a94594af1d85d6e" translate="yes" xml:space="preserve">
          <source>Other features that are &lt;em&gt;implicitly&lt;/em&gt; triggered cause problems for modularity too. Type converters fall into this category:</source>
          <target state="translated">Otras caracter&amp;iacute;sticas que se activan &lt;em&gt;impl&amp;iacute;citamente tambi&amp;eacute;n&lt;/em&gt; causan problemas de modularidad. Los convertidores de tipo se incluyen en esta categor&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="13f7dea1ee4b7cb7f096198dcfd885624c0eca95" translate="yes" xml:space="preserve">
          <source>Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8702ae2aa93e41c74ae80da30c44c3106f145472" translate="yes" xml:space="preserve">
          <source>Other literal types, such as &lt;code&gt;uint literal(123)&lt;/code&gt; that would automatically convert to other integer types, but prefers to become a &lt;code&gt;uint&lt;/code&gt; are not part of the Nim language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb62f4ab5d15274940b6aca44c5aaa8ba4f5ebac" translate="yes" xml:space="preserve">
          <source>Other modules may provide other implementations for this standard stream interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaade51f8bd7dc897edf07f1c61fcd7a86afa793" translate="yes" xml:space="preserve">
          <source>Other parts of Nim - like scoping rules or runtime semantics are only described in the, more easily comprehensible, informal manner for now.</source>
          <target state="translated">Otras partes de Nim-como las reglas de alcance o la semántica del tiempo de ejecución sólo se describen de manera informal,más fácilmente comprensible,por ahora.</target>
        </trans-unit>
        <trans-unit id="cd81b04823d8d098b759de332e3f37424b167edb" translate="yes" xml:space="preserve">
          <source>Other parts of Nim, like scoping rules or runtime semantics, are described informally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13760399786dc4b7c7d0f4b3dbf3b00e5ee44753" translate="yes" xml:space="preserve">
          <source>Other strings can be inserted by putting them in &lt;code&gt;''&lt;/code&gt;. For example &lt;code&gt;hh'-&amp;gt;'mm&lt;/code&gt; will give &lt;code&gt;01-&amp;gt;56&lt;/code&gt;. The following characters can be inserted without quoting them: &lt;code&gt;:&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;. A literal &lt;code&gt;'&lt;/code&gt; can be specified with &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">Se pueden insertar otras cadenas coloc&amp;aacute;ndolas en &lt;code&gt;''&lt;/code&gt; . Por ejemplo, &lt;code&gt;hh'-&amp;gt;'mm&lt;/code&gt; dar&amp;aacute; &lt;code&gt;01-&amp;gt;56&lt;/code&gt; . Los siguientes caracteres pueden ser insertados sin citar ellos: &lt;code&gt;:&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; . Un literal &lt;code&gt;'&lt;/code&gt; se puede especificar con &lt;code&gt;''&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db18f7107204fed8fe24c5d3014de56d0af6c5d" translate="yes" xml:space="preserve">
          <source>Other tokens</source>
          <target state="translated">Otras fichas</target>
        </trans-unit>
        <trans-unit id="d65b86f3209b622242b01d2656aba539a4c22285" translate="yes" xml:space="preserve">
          <source>Other useful iterators for collections (like arrays and sequences) are</source>
          <target state="translated">Otros iteradores útiles para las colecciones (como arreglos y secuencias)son</target>
        </trans-unit>
        <trans-unit id="e1ab7515d2fc3d1784934bda518727e08f8359e6" translate="yes" xml:space="preserve">
          <source>Other value-based compound types like &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;array&lt;/code&gt; are handled correspondingly. For &lt;code&gt;object&lt;/code&gt; however, the compiler-generated hooks can be overridden. This can also be important to use an alternative traversal of the involved data structure that is more efficient or in order to avoid deep recursions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2d7e0a58dc8427e382ddd731db370ec009572b" translate="yes" xml:space="preserve">
          <source>Otherwise precedence is determined by the first character.</source>
          <target state="translated">De lo contrario,la precedencia está determinada por el primer personaje.</target>
        </trans-unit>
        <trans-unit id="21bc9e76f2a8c2a0eaf537c08d3d36f6d8085e56" translate="yes" xml:space="preserve">
          <source>Otherwise returns an empty string.</source>
          <target state="translated">De lo contrario,devuelve una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="1c72b5f977bcddbc511f75e162bc5876c1a3aead" translate="yes" xml:space="preserve">
          <source>Otherwise, precedence is determined by the first character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdd4c9ffbb5fd3025e9485c4feb564db99a1d5f" translate="yes" xml:space="preserve">
          <source>Our first attempt will start by modifying the program to generate a compile time string with the &lt;em&gt;generated source code&lt;/em&gt;, which we then pass to the &lt;code&gt;parseStmt&lt;/code&gt; proc from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;. Here is the modified source code implementing the macro:</source>
          <target state="translated">Nuestro primer intento comenzar&amp;aacute; modificando el programa para generar una cadena de tiempo de compilaci&amp;oacute;n con el &lt;em&gt;c&amp;oacute;digo fuente generado&lt;/em&gt; , que luego pasamos al proceso &lt;code&gt;parseStmt&lt;/code&gt; desde el &lt;a href=&quot;macros&quot;&gt;m&amp;oacute;dulo de macros&lt;/a&gt; . Aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo fuente modificado que implementa la macro:</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="1458e0711b267bc74f8fee698a4064944483ced7" translate="yes" xml:space="preserve">
          <source>Overflow: operation produces a result that exceeds the range of the exponent, for example MAXDOUBLE+0.0000000000001e308.</source>
          <target state="translated">Desbordamiento:la operación produce un resultado que excede el rango del exponente,por ejemplo MAXDOUBLE+0.0000000000001e308.</target>
        </trans-unit>
        <trans-unit id="7e1b7bd0afdc5a65df37f4970df5c8e08d3dd78f" translate="yes" xml:space="preserve">
          <source>Overload resolution can be further influenced by constraining the set of types that will match the type param. This works in practice by attaching attributes to types via templates. The constraint can be a concrete type or a type class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754c102f9b75ce776185c568a14f1c8a51acdc8a" translate="yes" xml:space="preserve">
          <source>Overload resolution can be further influenced by constraining the set of types that will match the type param:</source>
          <target state="translated">La resolución de la sobrecarga puede verse aún más influenciada por la restricción del conjunto de tipos que coincidirán con el tipo param:</target>
        </trans-unit>
        <trans-unit id="7fa7936a516e9b4405cfaaa07e91ba994298a243" translate="yes" xml:space="preserve">
          <source>Overload that validates &lt;code&gt;f&lt;/code&gt; at compile time.</source>
          <target state="translated">Sobrecarga que valida &lt;code&gt;f&lt;/code&gt; en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9c00e2ea8b8b406447c26bdcb6148e11ef275602" translate="yes" xml:space="preserve">
          <source>Overload that validates &lt;code&gt;format&lt;/code&gt; at compile time.</source>
          <target state="translated">Sobrecarga que valida el &lt;code&gt;format&lt;/code&gt; o en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4640027ad29996563c1a87a8afddf3069ba5a1e7" translate="yes" xml:space="preserve">
          <source>OverloadableSyms:</source>
          <target state="translated">OverloadableSyms:</target>
        </trans-unit>
        <trans-unit id="084d89d78f9253e5971aa14b7a1c146ed66021d5" translate="yes" xml:space="preserve">
          <source>Overloaded procedures</source>
          <target state="translated">Procedimientos sobrecargados</target>
        </trans-unit>
        <trans-unit id="52682dea26ce453286dbc5b5476302bf2f155d52" translate="yes" xml:space="preserve">
          <source>Overloading based on &amp;#x27;var T&amp;#x27;</source>
          <target state="translated">Sobrecarga basada en 'var T'</target>
        </trans-unit>
        <trans-unit id="fdfc3d44da0fc76ce20708147d4fa0f06487870d" translate="yes" xml:space="preserve">
          <source>Overloading based on 'var T'</source>
          <target state="translated">Sobrecarga basada en la &quot;var T</target>
        </trans-unit>
        <trans-unit id="3fa8556506ad2f2650ad5f0ace5f70fac3fe501b" translate="yes" xml:space="preserve">
          <source>Overloading based on 'var T' / 'out T'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376919dad96314f113fa2e51189fad0ab6b8a289" translate="yes" xml:space="preserve">
          <source>Overloading of the subscript operator</source>
          <target state="translated">La sobrecarga del operador del subíndice</target>
        </trans-unit>
        <trans-unit id="856f6c8643871a65621d9a78bd00b337b84e3743" translate="yes" xml:space="preserve">
          <source>Overloading resolution</source>
          <target state="translated">Resolución de sobrecarga</target>
        </trans-unit>
        <trans-unit id="59d786986f63a664027eb772a26d80c3f7a0abe9" translate="yes" xml:space="preserve">
          <source>Override this method in custom loggers. Default implementation does nothing.</source>
          <target state="translated">Anular este método en los registradores personalizados.La implementación por defecto no hace nada.</target>
        </trans-unit>
        <trans-unit id="6e1ae1a7c1ebfbcd4f7e403da7e822ba08800911" translate="yes" xml:space="preserve">
          <source>Override this method in custom loggers. The default implementation does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a660e603ccfc886dc9821594693be1bc0353fd" translate="yes" xml:space="preserve">
          <source>Overrides the location of a given file belonging to the passed package. If the &lt;code&gt;replacement&lt;/code&gt; is not an absolute path, the path is interpreted to be local to the Nimscript file that contains the call to &lt;code&gt;patchFile&lt;/code&gt;, Nim's &lt;code&gt;--path&lt;/code&gt; is not used at all to resolve the filename!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="b6d3fab9b4983c0a7fac72ed7d8df78bdcbf862d" translate="yes" xml:space="preserve">
          <source>Overwrites the contents of the memory at &lt;code&gt;p&lt;/code&gt; with the value 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7bf096f89a1c09f22a68174532321948a126b7a" translate="yes" xml:space="preserve">
          <source>PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.</source>
          <target state="translated">El PCRE es una biblioteca de funciones para apoyar las expresiones regulares cuya sintaxis y semántica son lo más parecidas posibles a las del lenguaje Perl 5.</target>
        </trans-unit>
        <trans-unit id="dbd40bd5aaef4dbeb16b94e187805c444acafbdf" translate="yes" xml:space="preserve">
          <source>PContext:</source>
          <target state="translated">PContext:</target>
        </trans-unit>
        <trans-unit id="7cacbbd17d87f4550a6720e9ec18284a7061410d" translate="yes" xml:space="preserve">
          <source>PCtx:</source>
          <target state="translated">PCtx:</target>
        </trans-unit>
        <trans-unit id="cc9a0f474ef35d5f0eb8a004093952e55059eb5c" translate="yes" xml:space="preserve">
          <source>PDoc:</source>
          <target state="translated">PDoc:</target>
        </trans-unit>
        <trans-unit id="595a895491f3a0cc703f76860a5a4b9d42a6ea7f" translate="yes" xml:space="preserve">
          <source>PEG construction</source>
          <target state="translated">Construcción de PEG</target>
        </trans-unit>
        <trans-unit id="118ee2de963e33508b97b815b8c557728d365a9c" translate="yes" xml:space="preserve">
          <source>PEG syntax and semantics</source>
          <target state="translated">Sintaxis y semántica del PEG</target>
        </trans-unit>
        <trans-unit id="9bde7e84a708b95057b420b93ae5d95c394c2f01" translate="yes" xml:space="preserve">
          <source>PEG vs regular expression</source>
          <target state="translated">PEG contra la expresión regular</target>
        </trans-unit>
        <trans-unit id="9a88b7a4b3c1cc84a7c0e7df861d95ea546a29f6" translate="yes" xml:space="preserve">
          <source>PEvalContext:</source>
          <target state="translated">PEvalContext:</target>
        </trans-unit>
        <trans-unit id="d9feff605b042a276d71f7511edd02d350b336f6" translate="yes" xml:space="preserve">
          <source>PIdObj:</source>
          <target state="translated">PIdObj:</target>
        </trans-unit>
        <trans-unit id="ffab2525091289dbd9d41123e41aff716b05e503" translate="yes" xml:space="preserve">
          <source>PIdent:</source>
          <target state="translated">PIdent:</target>
        </trans-unit>
        <trans-unit id="fd7dba84795498ad0e65cc4af895fd7d829b3c54" translate="yes" xml:space="preserve">
          <source>PInstantiation:</source>
          <target state="translated">PInstantiation:</target>
        </trans-unit>
        <trans-unit id="accfd6dd76c6b8689524f104b98bddaef54a702a" translate="yes" xml:space="preserve">
          <source>PLLStream:</source>
          <target state="translated">PLLStream:</target>
        </trans-unit>
        <trans-unit id="cbeaa1d5e4e194941a961e776953a09573177112" translate="yes" xml:space="preserve">
          <source>PLib:</source>
          <target state="translated">PLib:</target>
        </trans-unit>
        <trans-unit id="fc242215607474d0c7b7da3f12b4b91f6f303f9d" translate="yes" xml:space="preserve">
          <source>PNode:</source>
          <target state="translated">PNode:</target>
        </trans-unit>
        <trans-unit id="567edf4105fe83ec09be7bbd5ad833d065991b7e" translate="yes" xml:space="preserve">
          <source>POSIX character class (only if followed by POSIX syntax)</source>
          <target state="translated">Clase de carácter POSIX (sólo si va seguido de la sintaxis POSIX)</target>
        </trans-unit>
        <trans-unit id="e3896dc47c849389aad6b68320cef38af4776a63" translate="yes" xml:space="preserve">
          <source>POSIX-compliant systems on conventional hardware are usually pretty easy to port: Add the platform to &lt;code&gt;platform&lt;/code&gt; (if it is not already listed there), check that the OS, System modules work and recompile Nim.</source>
          <target state="translated">Los sistemas compatibles con POSIX en hardware convencional suelen ser bastante f&amp;aacute;ciles de migrar: agregue la plataforma a la &lt;code&gt;platform&lt;/code&gt; (si a&amp;uacute;n no est&amp;aacute; en la lista), verifique que el sistema operativo, los m&amp;oacute;dulos del sistema funcionen y recompile Nim.</target>
        </trans-unit>
        <trans-unit id="12142e28cc69313a619ae99c351fba5fe84b0a4b" translate="yes" xml:space="preserve">
          <source>POSTs &lt;code&gt;body&lt;/code&gt; to &lt;code&gt;url&lt;/code&gt; and returns the response's body as a string</source>
          <target state="translated">POST env&amp;iacute;a el &lt;code&gt;body&lt;/code&gt; a la &lt;code&gt;url&lt;/code&gt; y devuelve el cuerpo de la respuesta como una cadena</target>
        </trans-unit>
        <trans-unit id="2dbc1dded6bee0ca902ff7658892851595e373f2" translate="yes" xml:space="preserve">
          <source>POSTs &lt;code&gt;body&lt;/code&gt; to the &lt;code&gt;url&lt;/code&gt; and returns a &lt;code&gt;Response&lt;/code&gt; object.</source>
          <target state="translated">POST env&amp;iacute;a el &lt;code&gt;body&lt;/code&gt; a la &lt;code&gt;url&lt;/code&gt; y devuelve un objeto de &lt;code&gt;Response&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6aee922e510d7ec57148a12114d5593e2b06f9" translate="yes" xml:space="preserve">
          <source>POptionEntry:</source>
          <target state="translated">POptionEntry:</target>
        </trans-unit>
        <trans-unit id="671f7474c264cec8bd98b6bc369716f871230c32" translate="yes" xml:space="preserve">
          <source>PPassContext:</source>
          <target state="translated">PPassContext:</target>
        </trans-unit>
        <trans-unit id="fae5eded41aca0b332d2db1f43cc65305199884d" translate="yes" xml:space="preserve">
          <source>PProc:</source>
          <target state="translated">PProc:</target>
        </trans-unit>
        <trans-unit id="11901d272bf1a502817be89a6f84525164cfa2da" translate="yes" xml:space="preserve">
          <source>PProcCon:</source>
          <target state="translated">PProcCon:</target>
        </trans-unit>
        <trans-unit id="b4e6954da93815488c9a364b8a508b656e9a52c2" translate="yes" xml:space="preserve">
          <source>PScope:</source>
          <target state="translated">PScope:</target>
        </trans-unit>
        <trans-unit id="db62fc930ef7c90144194475b3b082dfe8559291" translate="yes" xml:space="preserve">
          <source>PStackFrame:</source>
          <target state="translated">PStackFrame:</target>
        </trans-unit>
        <trans-unit id="4500d5cdba9ccdd561ec42d814fc3287a68d4171" translate="yes" xml:space="preserve">
          <source>PSym:</source>
          <target state="translated">PSym:</target>
        </trans-unit>
        <trans-unit id="f952a66c2e11ba6f3956bcda3c808ff7a43df019" translate="yes" xml:space="preserve">
          <source>PType:</source>
          <target state="translated">PType:</target>
        </trans-unit>
        <trans-unit id="332b04a11e1cc3787447391399cd62fd1868e0c6" translate="yes" xml:space="preserve">
          <source>Package level objects</source>
          <target state="translated">Los objetos del nivel de paquete</target>
        </trans-unit>
        <trans-unit id="77adf05ce915bafb1957104035a50844753d37c0" translate="yes" xml:space="preserve">
          <source>Packaging Nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b83e85b6cee3a941fc9661251d4bdffffa5249" translate="yes" xml:space="preserve">
          <source>Packaging for Linux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55fd3d981957b0d91d11e46f1e01dfd840b2014b" translate="yes" xml:space="preserve">
          <source>Packed pragma</source>
          <target state="translated">Pragmatismo empaquetado</target>
        </trans-unit>
        <trans-unit id="eea669f22aa5d4a29c38a6b10887b380fe6f283b" translate="yes" xml:space="preserve">
          <source>Pairwise (cascade) summation of &lt;code&gt;x[i0:i0+n-1]&lt;/code&gt;, with O(log n) error growth (vs O(n) for a simple loop) with negligible performance cost if the base case is large enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5510a92cb951dc073e6190edad274f134f704fb8" translate="yes" xml:space="preserve">
          <source>Parallel &amp;amp; Spawn</source>
          <target state="translated">Paralelo y aparici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="3b1299c53c7f5cf485c6482e9c854f429e16cdd6" translate="yes" xml:space="preserve">
          <source>Parallel statement</source>
          <target state="translated">Declaración paralela</target>
        </trans-unit>
        <trans-unit id="eec7d291b5a6446b7643c94e8e46ada61a750299" translate="yes" xml:space="preserve">
          <source>Parameter constraints</source>
          <target state="translated">Restricciones de los parámetros</target>
        </trans-unit>
        <trans-unit id="6edec2e5d0a7a5dbb4aae5b4adaf9693a07b89ea" translate="yes" xml:space="preserve">
          <source>Parameter constraints can also be used for ordinary routine parameters; these constraints affect ordinary overloading resolution then:</source>
          <target state="translated">Las restricciones de los parámetros también pueden utilizarse para los parámetros ordinarios de rutina;estas restricciones afectan entonces a la resolución ordinaria de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="f1a6890392c7940ddb0108d029ad337fb538b0dc" translate="yes" xml:space="preserve">
          <source>Parameter substitution</source>
          <target state="translated">Sustitución de parámetros</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="248b028facc0fd21c2e902405b8d5a47c01d6c40" translate="yes" xml:space="preserve">
          <source>Parameters and their defaults:</source>
          <target state="translated">Parámetros y sus valores por defecto:</target>
        </trans-unit>
        <trans-unit id="0f206e21ffd2fb787832ab9df479679c8199f0e6" translate="yes" xml:space="preserve">
          <source>Parameters are immutable in the procedure body. By default, their value cannot be changed because this allows the compiler to implement parameter passing in the most efficient way. If a mutable variable is needed inside the procedure, it has to be declared with &lt;code&gt;var&lt;/code&gt; in the procedure body. Shadowing the parameter name is possible, and actually an idiom:</source>
          <target state="translated">Los par&amp;aacute;metros son inmutables en el cuerpo del procedimiento. De forma predeterminada, su valor no se puede cambiar porque esto permite que el compilador implemente el paso de par&amp;aacute;metros de la manera m&amp;aacute;s eficiente. Si se necesita una variable mutable dentro del procedimiento, debe declararse con &lt;code&gt;var&lt;/code&gt; en el cuerpo del procedimiento. Es posible sombrear el nombre del par&amp;aacute;metro, y en realidad un modismo:</target>
        </trans-unit>
        <trans-unit id="8e2f8631ccf741645c248093e0a2a666f3997d29" translate="yes" xml:space="preserve">
          <source>Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa46df5cd24d9e242819c5e1aa5a6733dc8ec59" translate="yes" xml:space="preserve">
          <source>Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier &lt;em&gt;var&lt;/em&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros pueden declararse mutables y permitir que el proceso modifique esos argumentos, utilizando el modificador de tipo &lt;em&gt;var&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bb1a33ba432c2fafb1613ca7e699e06e64431463" translate="yes" xml:space="preserve">
          <source>Parameters in a pattern are type checked in the matching process. If a parameter is of the type &lt;code&gt;varargs&lt;/code&gt; it is treated specially and it can match 0 or more arguments in the AST to be matched against:</source>
          <target state="translated">Los par&amp;aacute;metros de un patr&amp;oacute;n se comprueban en el proceso de comparaci&amp;oacute;n. Si un par&amp;aacute;metro es del tipo &lt;code&gt;varargs&lt;/code&gt; , se trata de forma especial y puede coincidir con 0 o m&amp;aacute;s argumentos en el AST con los que comparar:</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="f9627107a88876f4aaf6d7e0b0c19984c3a631ae" translate="yes" xml:space="preserve">
          <source>Parentheses</source>
          <target state="translated">Parentheses</target>
        </trans-unit>
        <trans-unit id="127effbb71ba19570ab235baa525f232fbd22004" translate="yes" xml:space="preserve">
          <source>Parentheses for affecting operator precedence or tuple construction are built with the &lt;code&gt;nnkPar&lt;/code&gt; node.</source>
          <target state="translated">Los par&amp;eacute;ntesis para afectar la precedencia del operador o la construcci&amp;oacute;n de tuplas se crean con el nodo &lt;code&gt;nnkPar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d9b125022b9ee7ebf69c8a04fd096637510b142" translate="yes" xml:space="preserve">
          <source>Parse from string to &lt;code&gt;Document&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed227c288a07222d3d51a4595d3b79f52c8d03e" translate="yes" xml:space="preserve">
          <source>Parser:</source>
          <target state="translated">Parser:</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="fdc5c8bf9de8fe50660fbecb95450298ca04c420" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;file&lt;/code&gt; into a &lt;code&gt;JsonNode&lt;/code&gt;. If &lt;code&gt;file&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c8de0d487854ee3be6455d253f7500550cee2d" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt; using the format specified by &lt;code&gt;f&lt;/code&gt;. If no UTC offset was parsed, then &lt;code&gt;input&lt;/code&gt; is assumed to be specified in the &lt;code&gt;zone&lt;/code&gt; timezone. If a UTC offset was parsed, the result will be converted to the &lt;code&gt;zone&lt;/code&gt; timezone.</source>
          <target state="translated">Analiza &lt;code&gt;input&lt;/code&gt; como un &lt;code&gt;DateTime&lt;/code&gt; utilizando el formato especificado por &lt;code&gt;f&lt;/code&gt; . Si no se analiz&amp;oacute; ning&amp;uacute;n desplazamiento de UTC, se supone que la &lt;code&gt;input&lt;/code&gt; se especifica en la &lt;code&gt;zone&lt;/code&gt; horaria. Si se analiz&amp;oacute; un desplazamiento de UTC, el resultado se convertir&amp;aacute; a la &lt;code&gt;zone&lt;/code&gt; horaria.</target>
        </trans-unit>
        <trans-unit id="7918d77f526af521fc86e403546e7b0e219d1d4c" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;name&lt;/code&gt; to a color value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca7a029bb84bff8ec1168a8bf88514632d40ff1" translate="yes" xml:space="preserve">
          <source>Parses &lt;em&gt;file&lt;/em&gt; into a &lt;em&gt;JsonNode&lt;/em&gt;. If &lt;em&gt;file&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">Analiza el &lt;em&gt;archivo&lt;/em&gt; en un &lt;em&gt;JsonNode&lt;/em&gt; . Si el &lt;em&gt;archivo&lt;/em&gt; contiene datos adicionales, generar&amp;aacute; &lt;em&gt;JsonParsingError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fafedced417174aa4da9f6c5355a4f97842e0273" translate="yes" xml:space="preserve">
          <source>Parses JSON from &lt;code&gt;buffer&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31988daf224c3e5481844d9affd370b85ab0c4b" translate="yes" xml:space="preserve">
          <source>Parses JSON from &lt;em&gt;buffer&lt;/em&gt;. If &lt;em&gt;buffer&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">Analiza JSON desde el &lt;em&gt;b&amp;uacute;fer&lt;/em&gt; . Si el &lt;em&gt;b&amp;uacute;fer&lt;/em&gt; contiene datos adicionales, generar&amp;aacute; &lt;em&gt;JsonParsingError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c83d8c3603707a9ecc2dd84a9a6037c204951a36" translate="yes" xml:space="preserve">
          <source>Parses Sexp from &lt;em&gt;buffer&lt;/em&gt;.</source>
          <target state="translated">Analiza Sexp desde el &lt;em&gt;b&amp;uacute;fer&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7b270c2a1c4209369629ad62e2046102416eaf" translate="yes" xml:space="preserve">
          <source>Parses a URI and returns it.</source>
          <target state="translated">Analiza una URI y la devuelve.</target>
        </trans-unit>
        <trans-unit id="ad45644f553663f9d257789c054572a54266f47c" translate="yes" xml:space="preserve">
          <source>Parses a URI. The &lt;code&gt;result&lt;/code&gt; variable will be cleared before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec7d8bb1b5440dcea9f8d95176ab435560994e3" translate="yes" xml:space="preserve">
          <source>Parses a URI. The &lt;em&gt;result&lt;/em&gt; variable will be cleared before.</source>
          <target state="translated">Analiza un URI. La variable de &lt;em&gt;resultado&lt;/em&gt; se borrar&amp;aacute; antes.</target>
        </trans-unit>
        <trans-unit id="47c6be8783069edfdf34c74b669c16a0475feedb" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18146fc030fe2a6ab8885a719a469a90008e5f4" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Analiza un valor entero binario contenido en &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb2463cc2ccaef503186bd51ebe5185565cfeb8" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1930245a174e6900c3d7fb820106a1eb91eb1732" translate="yes" xml:space="preserve">
          <source>Parses a binary number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092905e90e391bd9b854c24a81b158dbbe52809b" translate="yes" xml:space="preserve">
          <source>Parses a decimal floating point value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835e144c44ca9aa9a0c3bc52fffba2a23a756070" translate="yes" xml:space="preserve">
          <source>Parses a decimal floating point value contained in &lt;em&gt;s&lt;/em&gt;. If &lt;em&gt;s&lt;/em&gt; is not a valid floating point number, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;code&gt;NAN&lt;/code&gt;, &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;-INF&lt;/code&gt; are also supported (case insensitive comparison).</source>
          <target state="translated">Analiza un valor de coma flotante decimal contenido en &lt;em&gt;s&lt;/em&gt; . Si &lt;em&gt;s&lt;/em&gt; no es un n&amp;uacute;mero de punto flotante v&amp;aacute;lido, se &lt;em&gt;genera ValueError&lt;/em&gt; . Tambi&amp;eacute;n se admiten &lt;code&gt;NAN&lt;/code&gt; , &lt;code&gt;INF&lt;/code&gt; , &lt;code&gt;-INF&lt;/code&gt; (comparaci&amp;oacute;n que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas).</target>
        </trans-unit>
        <trans-unit id="426b331688624b96220a72237b41278b8789b32f" translate="yes" xml:space="preserve">
          <source>Parses a decimal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95acbbe3645191c11345e3af876888af39d5fe0a" translate="yes" xml:space="preserve">
          <source>Parses a decimal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Analiza un valor entero decimal contenido en &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50fee93e276e7a265a8ffb848b200df570c8c778" translate="yes" xml:space="preserve">
          <source>Parses a decimal unsigned integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0e8f3670947e2eebff34e6614bd7b5cc662d7c" translate="yes" xml:space="preserve">
          <source>Parses a decimal unsigned integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Analiza un valor entero decimal sin signo contenido en &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd85b664c039d20903a1b3a0d045b4bbde454585" translate="yes" xml:space="preserve">
          <source>Parses a float starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if a parsing error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685445d7be6759190f48fa0f51a191e497d2eba9" translate="yes" xml:space="preserve">
          <source>Parses a float starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if there occurred a parsing error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db44b06c6474e1abe579f57d2b9fb8d598fb0d1" translate="yes" xml:space="preserve">
          <source>Parses a hex integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27840da795a5763a32afb1c0666c8f210e80f391" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2552cef1d7b2fd79db3dae66bea932dea01f7f48" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Analiza un valor entero hexadecimal contenido en &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2488ed821276fa08bab01cec3a67e70fc3f6f8" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Analiza un n&amp;uacute;mero hexadecimal y almacena su valor en &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb54921c8152e46b53bfa74a90daf66afa228f80" translate="yes" xml:space="preserve">
          <source>Parses a natural number into &lt;code&gt;b&lt;/code&gt;. This cannot raise an overflow error. &lt;code&gt;high(int)&lt;/code&gt; is returned for an overflow. The number of processed character is returned. This is usually what you really want to use instead of &lt;span id=&quot;parseint_1&quot;&gt;parseInt&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52772096a4233cc51e1600d105de8977b1778a95" translate="yes" xml:space="preserve">
          <source>Parses a single raw header HTTP line into key value pairs.</source>
          <target state="translated">Analiza una sola línea HTTP de cabecera en bruto en pares de valores clave.</target>
        </trans-unit>
        <trans-unit id="95b650c6035e72c967c98b41c7ebcc9dd65e6d54" translate="yes" xml:space="preserve">
          <source>Parses a string into an AST, returning the top node. &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;, although optional, provide info so that the compiler can generate correct error messages referring to the original source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c701c28b798a044aaf1117a96e54a0c2d5f2da3" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that comes before the &lt;code&gt;until&lt;/code&gt; token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36b9f501444b04abc01044f2ebfde091271a4b2" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the &lt;code&gt;until&lt;/code&gt; character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d3eec3b6b0406b84be0d5701498cd7d574a854" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in &lt;code&gt;validChars&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97d02f27717f5551aacbc5a29f3102a29c8b007" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin &lt;code&gt;until&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6a8d0899321496ee5b4707a4985a56d004222b" translate="yes" xml:space="preserve">
          <source>Parses a value into a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c29907580552c41f83b6dee8503b24b04303ca" translate="yes" xml:space="preserve">
          <source>Parses a value into a &lt;em&gt;bool&lt;/em&gt;.</source>
          <target state="translated">Analiza un valor en un &lt;em&gt;bool&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="410e8b23cd46010b49b0dd0e3914dc4ecc9e1ca5" translate="yes" xml:space="preserve">
          <source>Parses an IP address Raises EInvalidValue on error</source>
          <target state="translated">Analiza una dirección IP y aumenta el valor de invalidez en caso de error.</target>
        </trans-unit>
        <trans-unit id="3868d092804175ec95080b3c3f82ec8e767af1ea" translate="yes" xml:space="preserve">
          <source>Parses an IP address Raises ValueError on error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6850ab1bcfc38172914099c85e87137a9e1a8e" translate="yes" xml:space="preserve">
          <source>Parses an binary number and stores its value in &lt;code&gt;number&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="translated">Analiza un n&amp;uacute;mero binario y almacena su valor en &lt;code&gt;number&lt;/code&gt; . Devuelve el n&amp;uacute;mero de caracteres analizados o 0 en caso de error.</target>
        </trans-unit>
        <trans-unit id="52ecab5e0e696e851dd2d8e05a4efb7aef630d77" translate="yes" xml:space="preserve">
          <source>Parses an enum &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Analiza una enumeraci&amp;oacute;n &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed985855211a09c313ddd3d2ad1eecc68c677350" translate="yes" xml:space="preserve">
          <source>Parses an enum &lt;code&gt;T&lt;/code&gt;. This errors at compile time, if the given enum type contains multiple fields with the same string value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b43b85907d5ddc55c4b3714b6a9769b28c6493" translate="yes" xml:space="preserve">
          <source>Parses an identifier and returns it or an empty string in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ec9442ce0c86283d4a625d404705eba967848b" translate="yes" xml:space="preserve">
          <source>Parses an identifier and stores it in &lt;code&gt;ident&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e77e0c344edc805c7867507e4487f62806f9022" translate="yes" xml:space="preserve">
          <source>Parses an integer starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if there is no integer. &lt;code&gt;ValueError&lt;/code&gt; is raised if the parsed integer is out of the valid range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db59fe378bf2dcbcb71f7d850662780bf0b1cbaf" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1300628673257382b63897d5a63358653f3d654e" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Analiza un valor entero octal contenido en &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8728b9534afce3f642e4b3aebeb7678eb66fd67f" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7401e15eeba63dc0b50156bc802bc4478ad2f731" translate="yes" xml:space="preserve">
          <source>Parses an octal number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b4c05a71f0a355fc50b443e92107cc745a1c8a" translate="yes" xml:space="preserve">
          <source>Parses an octal number and stores its value in &lt;code&gt;number&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="translated">Analiza un n&amp;uacute;mero octal y almacena su valor en &lt;code&gt;number&lt;/code&gt; . Devuelve el n&amp;uacute;mero de caracteres analizados o 0 en caso de error.</target>
        </trans-unit>
        <trans-unit id="13fd10e0aeee81890876e811b26e03b135d51ed9" translate="yes" xml:space="preserve">
          <source>Parses an unsigned integer starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. &lt;code&gt;ValueError&lt;/code&gt; is raised if the parsed integer is out of the valid range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541ca66d4dbc79404bc942d6bfb6c2be8439048d" translate="yes" xml:space="preserve">
          <source>Parses from a buffer &lt;em&gt;s&lt;/em&gt; into a &lt;em&gt;SexpNode&lt;/em&gt;.</source>
          <target state="translated">Analiza desde un b&amp;uacute;fer &lt;em&gt;s&lt;/em&gt; en un &lt;em&gt;SexpNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce15ddb51f7707db52e2ae68e86add81e03689ed" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;JsonNodes&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; is only needed for nice error messages. The JSON fragments are separated by whitespace. This can be substantially faster than the comparable loop &lt;code&gt;for x in splitWhitespace(s): yield parseJson(x)&lt;/code&gt;. This closes the stream &lt;code&gt;s&lt;/code&gt; after it's done. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a309dc0181d3f0cb9ac7df4853c24a9cc3a1bc" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;code&gt;s&lt;/code&gt; into a &lt;code&gt;JsonNode&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; is only needed for nice error messages. If &lt;code&gt;s&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;. This closes the stream &lt;code&gt;s&lt;/code&gt; after it's done. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f09fb29abff457c84ba95e0bc8011331d06c2a" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;em&gt;s&lt;/em&gt; into a &lt;em&gt;JsonNode&lt;/em&gt;. &lt;em&gt;filename&lt;/em&gt; is only needed for nice error messages. If &lt;em&gt;s&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">Analiza desde una secuencia &lt;em&gt;s&lt;/em&gt; en un &lt;em&gt;JsonNode&lt;/em&gt; . &lt;em&gt;filename&lt;/em&gt; solo es necesario para mensajes de error agradables. Si &lt;em&gt;s&lt;/em&gt; contiene datos adicionales, generar&amp;aacute; &lt;em&gt;JsonParsingError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c205fbee41ffe389bcaa089240a73bbb6a3cbbdc" translate="yes" xml:space="preserve">
          <source>Parses the HTML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7392bd1dfd3616a852a08b90df502af326331916" translate="yes" xml:space="preserve">
          <source>Parses the HTML from stream &lt;em&gt;s&lt;/em&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">Analiza el HTML de la secuencia &lt;em&gt;sy&lt;/em&gt; devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Todos los errores de an&amp;aacute;lisis se ignoran.</target>
        </trans-unit>
        <trans-unit id="9d6b6e4325404bd4282ae6db6786d3c6cdde20d0" translate="yes" xml:space="preserve">
          <source>Parses the HTML from string &lt;code&gt;html&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">Analiza el HTML de la cadena &lt;code&gt;html&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Todos los errores de an&amp;aacute;lisis se ignoran.</target>
        </trans-unit>
        <trans-unit id="1b291cc50ee23e8b1901cb7970d7d44a0a902e25" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">Analiza el XML de la secuencia &lt;code&gt;s&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Todos los errores de an&amp;aacute;lisis se convierten en una excepci&amp;oacute;n &lt;code&gt;XmlError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="377e589d2efc7bd7f0d783557a0305ff1980a8dc" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;code&gt;errors&lt;/code&gt; sequence.</source>
          <target state="translated">Analiza el XML de la secuencia &lt;code&gt;s&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Cada error de an&amp;aacute;lisis producido se agrega a la secuencia de &lt;code&gt;errors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="693b35a301ba4a3e77a1617dfcdfe0c2eea41014" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;em&gt;s&lt;/em&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;em&gt;errors&lt;/em&gt; sequence.</source>
          <target state="translated">Analiza el XML de la secuencia &lt;em&gt;sy&lt;/em&gt; devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Cada error de an&amp;aacute;lisis producido se agrega a la secuencia de &lt;em&gt;errores&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="000730be1a0f93678cf7000c57f6c22e66d7b0b4" translate="yes" xml:space="preserve">
          <source>Parses the XML from string &lt;code&gt;str&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">Analiza el XML de la cadena &lt;code&gt;str&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Todos los errores de an&amp;aacute;lisis se convierten en una excepci&amp;oacute;n &lt;code&gt;XmlError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e94cd8428f25354a33870cff6f77b016ec0d7c9" translate="yes" xml:space="preserve">
          <source>Parses the next token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15086c718d34668e53394d9f878ee54b1f9d49b1" translate="yes" xml:space="preserve">
          <source>Parses the rest of the input stream held by the parser into a PNode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="e5e5e69e286e3687e8e65c82c15218f29cdccbe5" translate="yes" xml:space="preserve">
          <source>Parsing JSON</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f8861222174c27dc6101721594edce57bf1ada" translate="yes" xml:space="preserve">
          <source>Parsing a string into an AST which consists of &lt;code&gt;Peg&lt;/code&gt; nodes with the &lt;code&gt;peg&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d46a080325775ed12fd3ffd5aa0a8d40db7175c" translate="yes" xml:space="preserve">
          <source>Parsing a string into an AST which consists of &lt;em&gt;Peg&lt;/em&gt; nodes with the &lt;em&gt;peg&lt;/em&gt; proc.</source>
          <target state="translated">Analizar una cadena en un AST que consta de &lt;em&gt;Peg&lt;/em&gt; nodos con el &lt;em&gt;PEG&lt;/em&gt; proc.</target>
        </trans-unit>
        <trans-unit id="6d1213aa0c980986abc9cfe893f564f800d35d51" translate="yes" xml:space="preserve">
          <source>Parsing and Formatting Dates</source>
          <target state="translated">Analizar y dar formato a las fechas</target>
        </trans-unit>
        <trans-unit id="e8de9b67e60bfc9e5a53216bb30c98671e868ddb" translate="yes" xml:space="preserve">
          <source>Parsing idetools output</source>
          <target state="translated">Análisis de la salida de las herramientas de análisis</target>
        </trans-unit>
        <trans-unit id="1800737251d65799e8ed6a97afb24d8a2b9918ef" translate="yes" xml:space="preserve">
          <source>Parsing nimsuggest output</source>
          <target state="translated">Analizando la salida de nimsuggest</target>
        </trans-unit>
        <trans-unit id="5a01db6f2d606f2a701b77fbab0924cc899be0e3" translate="yes" xml:space="preserve">
          <source>Part 2</source>
          <target state="translated">Parte 2</target>
        </trans-unit>
        <trans-unit id="859cfaaaeaf6a8ced2a1b65b58557fb95d875c48" translate="yes" xml:space="preserve">
          <source>Part of a pattern that is in square brackets is called a &quot;character class&quot;. In a character class the only metacharacters are:</source>
          <target state="translated">Parte de un patrón que está entre corchetes se llama &quot;clase de personaje&quot;.En una clase de personaje los únicos metacaracteres son:</target>
        </trans-unit>
        <trans-unit id="9269695463c8a5faa720fae720afebc9f6ef9e73" translate="yes" xml:space="preserve">
          <source>Partial Output:</source>
          <target state="translated">Salida parcial:</target>
        </trans-unit>
        <trans-unit id="d9152c0a90009a287d69e549232b96c390e66d7e" translate="yes" xml:space="preserve">
          <source>Partial:</source>
          <target state="translated">Partial:</target>
        </trans-unit>
        <trans-unit id="d2ed3ad5db69194cd3d8766327afd474a9733e0f" translate="yes" xml:space="preserve">
          <source>Partially supported OS: Windows (only sockets and user events), Solaris (files, sockets, handles and user events). Android (files, sockets, handles and user events).</source>
          <target state="translated">Sistema operativo parcialmente soportado:Windows (sólo sockets y eventos de usuario),Solaris (archivos,sockets,handles y eventos de usuario).Android (archivos,sockets,handles y eventos de usuario).</target>
        </trans-unit>
        <trans-unit id="f8b3b0ce73b2c887fc04e170a70ba3e345ca3ea2" translate="yes" xml:space="preserve">
          <source>Partition variables into different graphs. Used for Nim's write tracking, borrow checking and also for the cursor inference. The algorithm is a reinvention / variation of Steensgaard's algorithm. The used data structure is &quot;union find&quot; with path compression.We perform two passes over the AST:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447a6d9d5a5bea5594901fb1228ca57d5eb5c3aa" translate="yes" xml:space="preserve">
          <source>Partitions:</source>
          <target state="translated">Partitions:</target>
        </trans-unit>
        <trans-unit id="8a171b6aa4025579258fcd2c8b48f01cfb4c51c1" translate="yes" xml:space="preserve">
          <source>Parts of the string that are enclosed in the curly braces are interpreted as Nim code, to escape an &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt; double it.</source>
          <target state="translated">Las partes de la cadena que est&amp;aacute;n encerradas entre llaves se interpretan como c&amp;oacute;digo Nim, para escapar de un &lt;code&gt;{&lt;/code&gt; o &lt;code&gt;}&lt;/code&gt; doble.</target>
        </trans-unit>
        <trans-unit id="ae5e4613a5a66f977a85dd0954ce24e4cb776f3b" translate="yes" xml:space="preserve">
          <source>Pass one (&lt;code&gt;computeLiveRanges&lt;/code&gt;): collect livetimes of local variables and whether they are potentially re-assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aca8fe67e97585de445057c4943ea7782cef87e" translate="yes" xml:space="preserve">
          <source>Pass the filename and an array of times to set the access and modification times respectively. If you pass nil as the array both attributes will be set to the current time.</source>
          <target state="translated">Pasa el nombre del archivo y una serie de veces para establecer los tiempos de acceso y modificación respectivamente.Si pasas nil como el array ambos atributos se ajustarán a la hora actual.</target>
        </trans-unit>
        <trans-unit id="ce3232a33ee700938d89f8cd85b81c950620aef7" translate="yes" xml:space="preserve">
          <source>Pass two (&lt;code&gt;traverse&lt;/code&gt;): combine local variables to abstract &quot;graphs&quot;. Strict func checking: Ensure that graphs that are connected to const parameters are not mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c5b9444c85f22cfca7c6842fd1c77d3d446d19" translate="yes" xml:space="preserve">
          <source>PassC pragma</source>
          <target state="translated">Pragmatismo PassC</target>
        </trans-unit>
        <trans-unit id="27478f48296583129eac069e5087f2d2b0da482f" translate="yes" xml:space="preserve">
          <source>PassL pragma</source>
          <target state="translated">Pragmatismo PassL</target>
        </trans-unit>
        <trans-unit id="63887463770a134a992bce27e42d7f2d2c85fd99" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;typedesc&lt;/code&gt; almost identical, just with the differences that the macro is not instantiated generically. The type expression is simply passed as a &lt;code&gt;NimNode&lt;/code&gt; to the macro, like everything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f9f364778543f2d3d56cfb6fbfab613d11d558c" translate="yes" xml:space="preserve">
          <source>Passing Channels Safely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f8c2a994a126eaf7103a7c43409efdd75a983d" translate="yes" xml:space="preserve">
          <source>Passing a code block to a template</source>
          <target state="translated">Pasar un bloque de código a una plantilla</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c05a7dde4e8ae01915e872a2ecdbb5cd167032f4" translate="yes" xml:space="preserve">
          <source>Path expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27560fcddb5cfbfe7af93f89dd7a53c8deb37a54" translate="yes" xml:space="preserve">
          <source>Path handling utilities for Nim. Strictly typed code in order to avoid the never ending time sink in getting path handling right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2643c3434dcb6df9c1e72e6681f1bedc8ada4a0" translate="yes" xml:space="preserve">
          <source>Path names are syntactically either Nim identifiers or string literals. If the path name is not a valid Nim identifier it needs to be a string literal:</source>
          <target state="translated">Los nombres de las rutas son sintácticamente identificadores Nim o literales de la cadena.Si el nombre de la ruta no es un identificador Nim válido,debe ser una cadena literal:</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="7b6c2f9c3abcefd6eb4c4d0a0b5007e45b97a311" translate="yes" xml:space="preserve">
          <source>Pattern operators</source>
          <target state="translated">Operadores de patrón</target>
        </trans-unit>
        <trans-unit id="b72a4aa7fcffcb55499f6f65d9d2148428770a18" translate="yes" xml:space="preserve">
          <source>Peeks a bool from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6a9eba2a7a8dfeec4fef0b5ee800ec7bce466c" translate="yes" xml:space="preserve">
          <source>Peeks a char from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred. Returns '\0' as an EOF marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30991c6b5bff2936cbd0d88e8d9f4f17f645b52" translate="yes" xml:space="preserve">
          <source>Peeks a float32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ae27eff9b512d1dc5c6f48c66a3d7a3a0a266d" translate="yes" xml:space="preserve">
          <source>Peeks a float64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204f73ee7651322bcdfc2623d6c7a9dcb68585ef" translate="yes" xml:space="preserve">
          <source>Peeks a line from a stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82e5a058ac8dd2705ce01808437b2ad8b5084fa" translate="yes" xml:space="preserve">
          <source>Peeks a line from a stream &lt;em&gt;s&lt;/em&gt;. Note: This is not very efficient. Raises &lt;em&gt;EIO&lt;/em&gt; if an error occurred.</source>
          <target state="translated">Asoma una l&amp;iacute;nea de un arroyo &lt;em&gt;s&lt;/em&gt; . Nota: esto no es muy eficaz. Genera &lt;em&gt;EIO&lt;/em&gt; si ocurre un error.</target>
        </trans-unit>
        <trans-unit id="c0f56bf840615055642d6528d6f868484cf2948c" translate="yes" xml:space="preserve">
          <source>Peeks a line of text from the stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt; must not be &lt;code&gt;nil&lt;/code&gt;! May throw an IO exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afacc1115ea965417732e73e255661db6f4983da" translate="yes" xml:space="preserve">
          <source>Peeks a string of length &lt;code&gt;length&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9414855f96734b147ad15c7dde82de48212d4b" translate="yes" xml:space="preserve">
          <source>Peeks an int16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296a55eb24e1b0188438c22d6c2625aee424270b" translate="yes" xml:space="preserve">
          <source>Peeks an int32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84da338eff9110ffe76ec04860083e3ad8d4fda0" translate="yes" xml:space="preserve">
          <source>Peeks an int64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a726c626471c71e2bea52828da149e79477e34db" translate="yes" xml:space="preserve">
          <source>Peeks an int8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37554e75d27de5e874212c2847da8d22976d57a3" translate="yes" xml:space="preserve">
          <source>Peeks an uint16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a11a5412c9e16f4d463046d5b50765daaf1c35b" translate="yes" xml:space="preserve">
          <source>Peeks an uint32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9288ec1fcb9b1804858ac1c31deefe90a164960" translate="yes" xml:space="preserve">
          <source>Peeks an uint64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3cd9c754a426dc765433ad7315ebfc501dfc7f" translate="yes" xml:space="preserve">
          <source>Peeks an uint8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d4c57147bf5dd3bbcaf7bdfd58b0b2226cf25d" translate="yes" xml:space="preserve">
          <source>Per convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;. The iterator &lt;code&gt;runes&lt;/code&gt; from the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt; can be used for iteration over all Unicode characters.</source>
          <target state="translated">Por convenci&amp;oacute;n, todas las cadenas son cadenas UTF-8, pero esto no se aplica. Por ejemplo, al leer cadenas de archivos binarios, son simplemente una secuencia de bytes. La operaci&amp;oacute;n de &amp;iacute;ndice &lt;code&gt;s[i]&lt;/code&gt; significa el i-&amp;eacute;simo &lt;em&gt;car&amp;aacute;cter&lt;/em&gt; de &lt;code&gt;s&lt;/code&gt; , no el i-&amp;eacute;simo &lt;em&gt;unichar&lt;/em&gt; . Las &lt;code&gt;runes&lt;/code&gt; del iterador del &lt;a href=&quot;unicode&quot;&gt;m&amp;oacute;dulo Unicode&lt;/a&gt; se pueden utilizar para iterar sobre todos los caracteres Unicode.</target>
        </trans-unit>
        <trans-unit id="ff72f9179ae9e4a2376a59a5c8d0eeb265a32c2e" translate="yes" xml:space="preserve">
          <source>Per default templates are &lt;span id=&quot;hygienic_2&quot;&gt;hygienic&lt;/span&gt;: Local identifiers declared in a template cannot be accessed in the instantiation context:</source>
          <target state="translated">Las plantillas predeterminadas son &lt;span id=&quot;hygienic_2&quot;&gt;higi&amp;eacute;nicas&lt;/span&gt; : no se puede acceder a los identificadores locales declarados en una plantilla en el contexto de creaci&amp;oacute;n de instancias:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="231131ea1a3863240874952ad37cf345067f33f6" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;new(x)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89cf973516a4a21e210bf15d9d57a4a7110ea58" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;newSeq(x, len)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7013d1f7d9f5962bdcdf6809fa5ec60bd9876b80" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;setLen(x, x.len+1)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3450f41878523c76e1512334d0b887875e232269" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155215fde1aa26f3ee38c0933534e538b88f9ae9" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;code&gt;y&lt;/code&gt; and copies it into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cd9242728b5c1a926850fd325c67f2fc62426b" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">Realiza una copia profunda de &lt;em&gt;un&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfc2453a55ae0dddd53cdf78d2032544f6ddc57" translate="yes" xml:space="preserve">
          <source>Performs a left rotation on a range of elements. If you want to rotate right, use a negative &lt;code&gt;dist&lt;/code&gt;. Specifically, &lt;code&gt;rotateLeft&lt;/code&gt; rotates the elements at &lt;code&gt;slice&lt;/code&gt; by &lt;code&gt;dist&lt;/code&gt; positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fc1469f461af1ae348df9943fa1632f7f69e69" translate="yes" xml:space="preserve">
          <source>Performs a left rotation on a range of elements. If you want to rotate right, use a negative &lt;code&gt;dist&lt;/code&gt;. Specifically, &lt;code&gt;rotateLeft&lt;/code&gt; rotates the elements at &lt;code&gt;slice&lt;/code&gt; by &lt;code&gt;dist&lt;/code&gt; positions. The element at index &lt;code&gt;slice.a + dist&lt;/code&gt; will be at index &lt;code&gt;slice.a&lt;/code&gt;. The element at index &lt;code&gt;slice.b&lt;/code&gt; will be at &lt;code&gt;slice.a + dist -1&lt;/code&gt;. The element at index &lt;code&gt;slice.a&lt;/code&gt; will be at &lt;code&gt;slice.b + 1 - dist&lt;/code&gt;. The element at index &lt;code&gt;slice.a + dist - 1&lt;/code&gt; will be at &lt;code&gt;slice.b&lt;/code&gt;.</source>
          <target state="translated">Realiza una rotaci&amp;oacute;n a la izquierda en una variedad de elementos. Si desea rotar a la derecha, use un &lt;code&gt;dist&lt;/code&gt; negativo . Espec&amp;iacute;ficamente, &lt;code&gt;rotateLeft&lt;/code&gt; rota los elementos en las posiciones de &lt;code&gt;slice&lt;/code&gt; por &lt;code&gt;dist&lt;/code&gt; ancia . El elemento en el &lt;code&gt;slice.a + dist&lt;/code&gt; &amp;iacute;ndice. A + dist estar&amp;aacute; en el &lt;code&gt;slice.a&lt;/code&gt; &amp;iacute;ndice . A. El elemento en el &amp;iacute;ndice &lt;code&gt;slice.b&lt;/code&gt; estar&amp;aacute; en &lt;code&gt;slice.a + dist -1&lt;/code&gt; . El elemento en el &amp;iacute;ndice &lt;code&gt;slice.a&lt;/code&gt; estar&amp;aacute; en &lt;code&gt;slice.b + 1 - dist&lt;/code&gt; . El elemento en el &amp;iacute;ndice &lt;code&gt;slice.a + dist - 1&lt;/code&gt; estar&amp;aacute; en &lt;code&gt;slice.b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="547e7eb2c01a8b7516cb21056d0deeb73c558d11" translate="yes" xml:space="preserve">
          <source>PersistentNodeFlags:</source>
          <target state="translated">PersistentNodeFlags:</target>
        </trans-unit>
        <trans-unit id="fccc2964329a971b590ec4a8a9af70e6f9bbd4ae" translate="yes" xml:space="preserve">
          <source>Pins a thread to a &lt;span id=&quot;cpu_1&quot;&gt;CPU&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d668e43bf0a5743410bd7ab9e0edf6b66e6ccd9e" translate="yes" xml:space="preserve">
          <source>Pipe operator</source>
          <target state="translated">Operador de tuberías</target>
        </trans-unit>
        <trans-unit id="1712134a62aaf8aeb730f1ebe5c06b3ad4796c1b" translate="yes" xml:space="preserve">
          <source>Platform specific file extension for executables. On Windows &lt;code&gt;[&quot;exe&quot;, &quot;cmd&quot;, &quot;bat&quot;]&lt;/code&gt;, on Posix &lt;code&gt;[&quot;&quot;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9801141d70e8a14926ba6354cb8932aea11f6959" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;static T&lt;/code&gt; is just a syntactic convenience for the underlying generic type &lt;code&gt;static[T]&lt;/code&gt;. The type param can be omitted to obtain the type class of all constant expressions. A more specific type class can be created by instantiating &lt;code&gt;static&lt;/code&gt; with another type class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91502d9216b226c484d80d6fd0eebe1eb9ccca35" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;static T&lt;/code&gt; is just a syntactic convenience for the underlying generic type &lt;code&gt;static[T]&lt;/code&gt;. The type param can be omitted to obtain the type class of all values known at compile-time. A more specific type class can be created by instantiating &lt;code&gt;static&lt;/code&gt; with another type class.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;static T&lt;/code&gt; es solo una conveniencia sint&amp;aacute;ctica para el tipo gen&amp;eacute;rico subyacente &lt;code&gt;static[T]&lt;/code&gt; . El tipo param se puede omitir para obtener la clase de tipo de todos los valores conocidos en tiempo de compilaci&amp;oacute;n. Se puede crear una clase de tipo m&amp;aacute;s espec&amp;iacute;fica instanciando &lt;code&gt;static&lt;/code&gt; con otra clase de tipo.</target>
        </trans-unit>
        <trans-unit id="376e940c0f4ede252519f2b91f3c32d65164170e" translate="yes" xml:space="preserve">
          <source>Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as &lt;code&gt;seq[AnnotatedPtr[T]]&lt;/code&gt; or &lt;code&gt;RingBuffer[AnnotatedPtr[T]]&lt;/code&gt; will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a448e8765ceed97b70d742a1fbff8cbe9813f8" translate="yes" xml:space="preserve">
          <source>Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as &lt;em&gt;seq[AnnotatedPtr[T]]&lt;/em&gt; or &lt;em&gt;RingBuffer[AnnotatedPtr[T]]&lt;/em&gt; will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.</source>
          <target state="translated">Tenga en cuenta que Nim tratar&amp;aacute; los tipos de puntero definidos por el usuario como alternativas adecuadas a los tipos de puntero integrados. Es decir, tipos como &lt;em&gt;seq [AnnotatedPtr [T]]&lt;/em&gt; o &lt;em&gt;RingBuffer [AnnotatedPtr [T]]&lt;/em&gt; tambi&amp;eacute;n se considerar&amp;aacute;n covariantes y puede crear nuevos tipos de puntero creando instancias de otros tipos de puntero definidos por el usuario.</target>
        </trans-unit>
        <trans-unit id="31de791033a98daa5433ce403ccf2d1db3a3ae55" translate="yes" xml:space="preserve">
          <source>Please note that generic concepts such as &lt;code&gt;Enumerable[T]&lt;/code&gt; can be matched against concrete types such as &lt;code&gt;string&lt;/code&gt;. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as &lt;code&gt;genericHead&lt;/code&gt; or &lt;code&gt;stripGenericParams&lt;/code&gt; within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic &lt;code&gt;Functor&lt;/code&gt; concept from Haskell and then demonstrate that Nim's &lt;code&gt;Option[T]&lt;/code&gt; type is an instance of it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6121f8f77a7e5843548ab29d76b72f1fdf494af" translate="yes" xml:space="preserve">
          <source>Please note that generic concepts such as &lt;em&gt;Enumerable[T]&lt;/em&gt; can be matched against concrete types such as &lt;em&gt;string&lt;/em&gt;. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as &lt;em&gt;genericHead&lt;/em&gt; or &lt;em&gt;stripGenericParams&lt;/em&gt; within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic &lt;em&gt;Functor&lt;/em&gt; concept from Haskell and then demonstrate that Nim's &lt;em&gt;Option[T]&lt;/em&gt; type is an instance of it:</source>
          <target state="translated">Tenga en cuenta que los conceptos gen&amp;eacute;ricos como &lt;em&gt;Enumerable [T]&lt;/em&gt; se pueden comparar con tipos concretos como &lt;em&gt;cadena&lt;/em&gt; . Nim no requiere que el tipo de concepto tenga el mismo n&amp;uacute;mero de par&amp;aacute;metros que el tipo que se est&amp;aacute; comparando. Si desea expresar un requisito hacia los par&amp;aacute;metros gen&amp;eacute;ricos del tipo coincidente, puede utilizar un operador de mapeo de tipos como &lt;em&gt;genericHead&lt;/em&gt; o &lt;em&gt;stripGenericParams&lt;/em&gt; dentro del cuerpo del concepto para obtener la versi&amp;oacute;n no autenticada del tipo, que luego puede intentar instanciar de cualquier forma requerida. Por ejemplo, as&amp;iacute; es como se podr&amp;iacute;a definir el concepto cl&amp;aacute;sico de &lt;em&gt;Functor&lt;/em&gt; de Haskell y luego demostrar que el tipo &lt;em&gt;Option [T] de&lt;/em&gt; Nim es una instancia de &amp;eacute;l:</target>
        </trans-unit>
        <trans-unit id="f5ca38697a6a448107efa272f859558c7b3efed4" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;is&lt;/code&gt; operator allows one to easily verify the precise type signatures of the required operations, but since type inference and default parameters are still applied in the concept body, it's also possible to describe usage protocols that do not reveal implementation details.</source>
          <target state="translated">Tenga en cuenta que el operador &lt;code&gt;is&lt;/code&gt; le permite a uno verificar f&amp;aacute;cilmente las firmas de tipo precisas de las operaciones requeridas, pero dado que la inferencia de tipo y los par&amp;aacute;metros predeterminados a&amp;uacute;n se aplican en el cuerpo del concepto, tambi&amp;eacute;n es posible describir protocolos de uso que no revelan detalles de implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="84b24489b92fa55264426ed8af25adfd53357fe7" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;the manual&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57833aa974b0e7c9c5481b4733aa65f3e38c1c57" translate="yes" xml:space="preserve">
          <source>Plugin support for the Nim compiler. Right now plugins need to be built with the compiler only: plugins using DLLs or the FFI will not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc451d63fbb704536042da563053eb7ff831435" translate="yes" xml:space="preserve">
          <source>Plugin to transform an inline iterator into a data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aae53af150b3796d306eb4ef6355e27209ba89b" translate="yes" xml:space="preserve">
          <source>Plugin:</source>
          <target state="translated">Plugin:</target>
        </trans-unit>
        <trans-unit id="57941ad380b619af368380c59a568808bb67d5c6" translate="yes" xml:space="preserve">
          <source>Pointer dereference &lt;code&gt;e[]&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e396fac5e10a7261ea311d079d21e12d48a8e32" translate="yes" xml:space="preserve">
          <source>Pop and return the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement:</source>
          <target state="translated">Revienta y devuelva el valor más pequeño actual,y añada el nuevo artículo.Esto es más eficiente que pop()seguido de push(),y puede ser más apropiado cuando se usa un montón de tamaño fijo.Ten en cuenta que el valor devuelto puede ser mayor que el del artículo! Esto limita los usos razonables de esta rutina a menos que se escriba como parte de un reemplazo condicional:</target>
        </trans-unit>
        <trans-unit id="7a35ff20b244cefddc1604b170c46f6cbce2de97" translate="yes" xml:space="preserve">
          <source>Pop the smallest item off the heap, maintaining the heap invariant.</source>
          <target state="translated">Sacar el objeto más pequeño del montón,manteniendo el montón invariable.</target>
        </trans-unit>
        <trans-unit id="34e45af26b9cdfe158c5ff6d766e12ef85dbe2c8" translate="yes" xml:space="preserve">
          <source>Pops and returns the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb79c259d58f1d3802c82933611bcfb17f33f4a" translate="yes" xml:space="preserve">
          <source>Pops and returns the smallest item from &lt;code&gt;heap&lt;/code&gt;, maintaining the heap invariant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="62eb2d652c640374db70b913a59f5d9da34f44b1" translate="yes" xml:space="preserve">
          <source>Porting Nim to a new architecture is pretty easy, since C is the most portable programming language (within certain limits) and Nim generates C code, porting the code generator is not necessary.</source>
          <target state="translated">Portar Nim a una nueva arquitectura es bastante fácil,ya que C es el lenguaje de programación más portable (dentro de ciertos límites)y Nim genera código C,portar el generador de código no es necesario.</target>
        </trans-unit>
        <trans-unit id="442a29f3c82b03d1fb72c4411cbd3b9a535b5dbf" translate="yes" xml:space="preserve">
          <source>Porting to new platforms</source>
          <target state="translated">Portando a nuevas plataformas</target>
        </trans-unit>
        <trans-unit id="96938ac778902dc9c8a77d5d10c75b74615cc812" translate="yes" xml:space="preserve">
          <source>Position relative to which seek should happen</source>
          <target state="translated">Posición relativa a la que debe ocurrir la búsqueda</target>
        </trans-unit>
        <trans-unit id="72250df1b33b90f691fb1b3acc0b0e2ea24463ab" translate="yes" xml:space="preserve">
          <source>Position relative to which seek should happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c44413026c7a51d5c1001acf9afe19a2fa6a8a3" translate="yes" xml:space="preserve">
          <source>Possible modes of &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e892ba2967a8f941ba09b419a3743f5e7d66af16" translate="yes" xml:space="preserve">
          <source>Possible values: &lt;code&gt;&quot;i386&quot;&lt;/code&gt;, &lt;code&gt;&quot;alpha&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc64&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc64el&quot;&lt;/code&gt;, &lt;code&gt;&quot;sparc&quot;&lt;/code&gt;, &lt;code&gt;&quot;amd64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips&quot;&lt;/code&gt;, &lt;code&gt;&quot;mipsel&quot;&lt;/code&gt;, &lt;code&gt;&quot;arm&quot;&lt;/code&gt;, &lt;code&gt;&quot;arm64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips64el&quot;&lt;/code&gt;, &lt;code&gt;&quot;riscv64&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa912531ccb34c0bee4edeab46a67bbbcf925be" translate="yes" xml:space="preserve">
          <source>Possible values: &lt;code&gt;&quot;windows&quot;&lt;/code&gt;, &lt;code&gt;&quot;macosx&quot;&lt;/code&gt;, &lt;code&gt;&quot;linux&quot;&lt;/code&gt;, &lt;code&gt;&quot;netbsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;freebsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;openbsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;solaris&quot;&lt;/code&gt;, &lt;code&gt;&quot;aix&quot;&lt;/code&gt;, &lt;code&gt;&quot;haiku&quot;&lt;/code&gt;, &lt;code&gt;&quot;standalone&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f507f61c5144c40eeb0019cc1f801d64ef47b9b" translate="yes" xml:space="preserve">
          <source>Possibly volatile-qualified integer type of an object that can be accessed as an atomic entity, even in the presence of asynchronous interrupts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7350d4c47ea4aa0bc5e9515e97fb1d18e41403e7" translate="yes" xml:space="preserve">
          <source>Postfix operator call</source>
          <target state="translated">Llamada de la operadora del Postfix</target>
        </trans-unit>
        <trans-unit id="4f334f0326bbdb4bbc89a575b872446c3dde5a89" translate="yes" xml:space="preserve">
          <source>Powerful Metaprogramming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d857c4a3cba6bb11f909b140e46311890f7f21c4" translate="yes" xml:space="preserve">
          <source>Pragmas</source>
          <target state="translated">Pragmas</target>
        </trans-unit>
        <trans-unit id="5d8e7de7f25aa645cd3d52db842b4045251d9dd7" translate="yes" xml:space="preserve">
          <source>Pragmas are Nim's method to give the compiler additional information / commands without introducing a massive number of new keywords. Pragmas are processed on the fly during semantic checking. Pragmas are enclosed in the special &lt;code&gt;{.&lt;/code&gt; and &lt;code&gt;.}&lt;/code&gt; curly brackets. Pragmas are also often used as a first implementation to play with a language feature before a nicer syntax to access the feature becomes available.</source>
          <target state="translated">Los pragmas son el m&amp;eacute;todo de Nim para dar al compilador informaci&amp;oacute;n / comandos adicionales sin introducir una gran cantidad de palabras clave nuevas. Los pragmas se procesan sobre la marcha durante la verificaci&amp;oacute;n sem&amp;aacute;ntica. Los pragmas se incluyen en el &lt;code&gt;{.&lt;/code&gt; especial . y &lt;code&gt;.}&lt;/code&gt; llaves. Los pragmas tambi&amp;eacute;n se utilizan a menudo como primera implementaci&amp;oacute;n para jugar con una funci&amp;oacute;n de lenguaje antes de que est&amp;eacute; disponible una sintaxis m&amp;aacute;s agradable para acceder a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fe9ce5f74d6f359dacb6b5ff6609ec745d285ed1" translate="yes" xml:space="preserve">
          <source>Pragmas are Nim's method to give the compiler additional information/ commands without introducing a massive number of new keywords. Pragmas are enclosed in the special &lt;code&gt;{.&lt;/code&gt; and &lt;code&gt;.}&lt;/code&gt; curly dot brackets. This tutorial does not cover pragmas. See the &lt;a href=&quot;manual#pragmas&quot;&gt;manual&lt;/a&gt; or &lt;a href=&quot;nimc#additional-features&quot;&gt;user guide&lt;/a&gt; for a description of the available pragmas.</source>
          <target state="translated">Los pragmas son el m&amp;eacute;todo de Nim para dar al compilador informaci&amp;oacute;n / comandos adicionales sin introducir una gran cantidad de palabras clave nuevas. Los pragmas se incluyen en el &lt;code&gt;{.&lt;/code&gt; especial . y &lt;code&gt;.}&lt;/code&gt; corchetes de puntos. Este tutorial no cubre los pragmas. Consulte el &lt;a href=&quot;manual#pragmas&quot;&gt;manual&lt;/a&gt; o &lt;a href=&quot;nimc#additional-features&quot;&gt;la gu&amp;iacute;a del usuario&lt;/a&gt; para obtener una descripci&amp;oacute;n de los pragmas disponibles.</target>
        </trans-unit>
        <trans-unit id="98fd755e5931021a9b89b9579124e072dc87d99f" translate="yes" xml:space="preserve">
          <source>Pre-defined floating point types</source>
          <target state="translated">Tipos de punto flotante predefinidos</target>
        </trans-unit>
        <trans-unit id="fb09faa048a039f6976971e21ef11f9d51c37b06" translate="yes" xml:space="preserve">
          <source>Pre-defined floating-point types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddce2e3fda9f6f78c28f745b41b5c1d94ce0affb" translate="yes" xml:space="preserve">
          <source>Pre-defined integer types</source>
          <target state="translated">Tipos enteros predefinidos</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="e11b40e5dc046d6eacf2b9c0341a3b59b3ba5410" translate="yes" xml:space="preserve">
          <source>Precedence level</source>
          <target state="translated">Nivel de precedencia</target>
        </trans-unit>
        <trans-unit id="39a03e2279ceac8cb327814928332264628e7b59" translate="yes" xml:space="preserve">
          <source>Predecessor of the value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="a0632aa9c12bfe3dcd3037995eb766aec389aa10" translate="yes" xml:space="preserve">
          <source>Predicates that share their name with a keyword have to be escaped with backticks. The &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b360b99e5530a900c44998c81311dbde2b2172fa" translate="yes" xml:space="preserve">
          <source>Predicates that share their name with a keyword have to be escaped with backticks: `` &lt;em&gt;const&lt;/em&gt;&lt;code&gt;. The ``alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:</source>
          <target state="translated">Los predicados que comparten su nombre con una palabra clave deben escaparse con comillas invertidas: `` &lt;em&gt;const &lt;/em&gt; &lt;code&gt;. The ``alias&lt;/code&gt; predicados `` alias y &lt;code&gt;noalias&lt;/code&gt; se refieren no solo al AST coincidente, sino tambi&amp;eacute;n a todos los dem&amp;aacute;s par&amp;aacute;metros enlazados; sint&amp;aacute;cticamente deben ocurrir despu&amp;eacute;s de los predicados AST ordinarios:</target>
        </trans-unit>
        <trans-unit id="2b151af2a194f19ff375b24827bd3223300579c0" translate="yes" xml:space="preserve">
          <source>Prefix operator call</source>
          <target state="translated">Llamada de la operadora del prefijo</target>
        </trans-unit>
        <trans-unit id="fbd2682b135bba426260d1de577b0322c630062a" translate="yes" xml:space="preserve">
          <source>PrefixMatch:</source>
          <target state="translated">PrefixMatch:</target>
        </trans-unit>
        <trans-unit id="66495d0734591a26213f3a366af624feb0c83b41" translate="yes" xml:space="preserve">
          <source>Prepares a string for insertion into a XML document by escaping the XML special characters.</source>
          <target state="translated">Prepara una cadena para su inserción en un documento XML escapando de los caracteres especiales del XML.</target>
        </trans-unit>
        <trans-unit id="a3014e7add76fcb315acde9f61b5b3077efef0f3" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a node &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad5802802da4c948ba8d3d94e9f72f06ed26198" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a node to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a5d3dfd1ec66e32e8f9e711f12608b4c8e461" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a value to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9650901619effd3019d005a7f0cabcb33160dd0" translate="yes" xml:space="preserve">
          <source>Prepends the element x to the beginning of the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db44386f03d5b854ad6dafaca1b1eeb202b32004" translate="yes" xml:space="preserve">
          <source>Prepends the element x to the beginning of the sequence. Requires copying of the sequence</source>
          <target state="translated">Prefiere el elemento x al principio de la secuencia.Requiere la copia de la secuencia</target>
        </trans-unit>
        <trans-unit id="e93c24da69c1700494f35fc0d6e60ad65139bd35" translate="yes" xml:space="preserve">
          <source>Preprocess table &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;sub&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ecd31a75929e40768bb20c6e9a666bcfc1c0cf" translate="yes" xml:space="preserve">
          <source>Preprocess table &lt;em&gt;a&lt;/em&gt; for &lt;em&gt;sub&lt;/em&gt;.</source>
          <target state="translated">Tabla de preprocesamiento &lt;em&gt;a&lt;/em&gt; para &lt;em&gt;sub&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0ebd928fc5c21d8b23de923afa72f9b439e03d18" translate="yes" xml:space="preserve">
          <source>Preprocessor support</source>
          <target state="translated">Apoyo al preprocesador</target>
        </trans-unit>
        <trans-unit id="78f94e0402b0663fec796a2cb153834ccd0300a2" translate="yes" xml:space="preserve">
          <source>Presumably this snippet of code could be used in a commercial software, reading a configuration file to display information about the person who bought the software. This external file would be generated by an online web shopping cart to be included along the program containing the license information:</source>
          <target state="translated">Presumiblemente,este fragmento de código podría utilizarse en un software comercial,leyendo un archivo de configuración para mostrar información sobre la persona que compró el software.Este archivo externo sería generado por un carrito de compras en línea para ser incluido en el programa que contiene la información de la licencia:</target>
        </trans-unit>
        <trans-unit id="bbaacc193c8d2a284014a58127bf356addea8297" translate="yes" xml:space="preserve">
          <source>Print out the checkpoints encountered so far and quit if &lt;code&gt;abortOnError&lt;/code&gt; is true. Otherwise, erase the checkpoints and indicate the test has failed (change exit code and test status). This template is useful for debugging, but is otherwise mostly used internally. Example:</source>
          <target state="translated">Imprima los puntos de control encontrados hasta ahora y salga si &lt;code&gt;abortOnError&lt;/code&gt; es verdadero. De lo contrario, borre los puntos de control e indique que la prueba ha fallado (cambie el c&amp;oacute;digo de salida y el estado de la prueba). Esta plantilla es &amp;uacute;til para depurar, pero por lo dem&amp;aacute;s se usa principalmente internamente. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="f51d4e0dcedaa3fc409bdb1e06a21dc4a5fd577e" translate="yes" xml:space="preserve">
          <source>Proc</source>
          <target state="translated">Proc</target>
        </trans-unit>
        <trans-unit id="eb113d7d8beac65e410d096bf62f5df0c3b28a3c" translate="yes" xml:space="preserve">
          <source>Procedural type</source>
          <target state="translated">Tipo de procedimiento</target>
        </trans-unit>
        <trans-unit id="9e7331be4f43593dd7df9b640d47a72f7445dbe7" translate="yes" xml:space="preserve">
          <source>Procedure calls of the form &lt;code&gt;p(X)&lt;/code&gt; are compile-time computable if &lt;code&gt;p&lt;/code&gt; is a proc without side-effects (see the &lt;a href=&quot;#pragmas-nosideeffect-pragma&quot;&gt;noSideEffect pragma&lt;/a&gt; for details) and if &lt;code&gt;X&lt;/code&gt; is a (possibly empty) list of compile-time computable arguments.</source>
          <target state="translated">Las llamadas a procedimientos de la forma &lt;code&gt;p(X)&lt;/code&gt; son computables en tiempo de compilaci&amp;oacute;n si &lt;code&gt;p&lt;/code&gt; es un proceso sin efectos secundarios (ver el &lt;a href=&quot;#pragmas-nosideeffect-pragma&quot;&gt;pragma noSideEffect&lt;/a&gt; para m&amp;aacute;s detalles) y si &lt;code&gt;X&lt;/code&gt; es una lista (posiblemente vac&amp;iacute;a) de argumentos computables en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b8db867373f6b118d2afb0458feddadd86fe8e12" translate="yes" xml:space="preserve">
          <source>Procedure declaration</source>
          <target state="translated">Declaración de procedimiento</target>
        </trans-unit>
        <trans-unit id="d682fc9dab69c1d2daf94fe72d9c9c2027249415" translate="yes" xml:space="preserve">
          <source>Procedures</source>
          <target state="translated">Procedures</target>
        </trans-unit>
        <trans-unit id="c7e7f6611bf2da78f49f8e451d842d8bd7ab42ec" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. For dynamic dispatch replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;method&lt;/code&gt;:</source>
          <target state="translated">Los procedimientos siempre utilizan el env&amp;iacute;o est&amp;aacute;tico. Para el env&amp;iacute;o din&amp;aacute;mico, reemplace la palabra clave &lt;code&gt;proc&lt;/code&gt; por &lt;code&gt;method&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f4c0de7b4c7726fec29f652686da73a3922e3fa" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. Methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad221890d30672f04664877c946ff70a32ff7b5" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. Multi-methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type as well.</source>
          <target state="translated">Los procedimientos siempre utilizan el envío estático.Los multimétodos utilizan el envío dinámico.Para que el despacho dinámico funcione en un objeto,debe ser también un tipo de referencia.</target>
        </trans-unit>
        <trans-unit id="06fbd2dad7effcb2234aac62fd8428a3ba476436" translate="yes" xml:space="preserve">
          <source>Procedures can appear at the top level in a module as well as inside other scopes, in which case they are called nested procs. A nested proc can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.</source>
          <target state="translated">Los procedimientos pueden aparecer en el nivel superior de un módulo,así como en el interior de otros alcances,en cuyo caso se denominan procedimientos anidados.Un proc anidado puede acceder a las variables locales desde su ámbito de cobertura y si lo hace se convierte en un cierre.Las variables capturadas se almacenan en un argumento adicional oculto al cierre (su entorno)y se accede a ellas por referencia tanto al cierre como a su ámbito de aplicación (es decir,cualquier modificación que se haga en ellas es visible en ambos lugares).El entorno del cierre puede asignarse al montón o a la pila si el compilador determina que esto sería seguro.</target>
        </trans-unit>
        <trans-unit id="e7841a99f25705b147bd34c0a1f7bb11c058cf2b" translate="yes" xml:space="preserve">
          <source>Procedures utilizing type classes in such a manner are considered to be &lt;span id=&quot;implicitly-generic_1&quot;&gt;implicitly generic&lt;/span&gt;. They will be instantiated once for each unique combination of param types used within the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d366db67df6a0b1e1efe0e08594bca71f8eee2" translate="yes" xml:space="preserve">
          <source>Procedures utilizing type classes in such manner are considered to be &lt;span id=&quot;implicitly-generic_1&quot;&gt;implicitly generic&lt;/span&gt;. They will be instantiated once for each unique combination of param types used within the program.</source>
          <target state="translated">Los procedimientos que utilizan clases de tipos de esta manera se consideran &lt;span id=&quot;implicitly-generic_1&quot;&gt;impl&amp;iacute;citamente gen&amp;eacute;ricos&lt;/span&gt; . Se crear&amp;aacute;n instancias una vez para cada combinaci&amp;oacute;n &amp;uacute;nica de tipos de par&amp;aacute;metros utilizados dentro del programa.</target>
        </trans-unit>
        <trans-unit id="77d887d3c4269645cbb00a3f203259c5546c162d" translate="yes" xml:space="preserve">
          <source>Process the closure of all inner procs in one pass and accumulate the environments. This is however not always possible.</source>
          <target state="translated">Procesa el cierre de todos los procesos internos en una sola pasada y acumula los ambientes.Sin embargo,esto no siempre es posible.</target>
        </trans-unit>
        <trans-unit id="e63451d3cf90040c075dc1fe95aa1f7d7528c37f" translate="yes" xml:space="preserve">
          <source>Processing</source>
          <target state="translated">Processing</target>
        </trans-unit>
        <trans-unit id="9afbe384e2a83f2b02c509b5363d71ee79a38e3a" translate="yes" xml:space="preserve">
          <source>Procs</source>
          <target state="translated">Procs</target>
        </trans-unit>
        <trans-unit id="4311d5a41c23a4400f7edfce5e0b039536a0abc1" translate="yes" xml:space="preserve">
          <source>Procs as expressions can appear both as nested procs and inside top level executable code.</source>
          <target state="translated">Los procedimientos como expresiones pueden aparecer como procedimientos anidados y dentro del código ejecutable de nivel superior.</target>
        </trans-unit>
        <trans-unit id="3e4f503b0908900893c7de08f0c51457cc0dc892" translate="yes" xml:space="preserve">
          <source>Procs as expressions can appear both as nested procs and inside top-level executable code. The &lt;a href=&quot;sugar&quot;&gt;sugar&lt;/a&gt; module contains the &lt;code&gt;=&amp;gt;&lt;/code&gt; macro which enables a more succinct syntax for anonymous procedures resembling lambdas as they are in languages like JavaScript, C#, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1616e4bc1aa2bed912867d0902aca437b90990" translate="yes" xml:space="preserve">
          <source>Procs can also be treated as expressions, in which case it's allowed to omit the proc's name.</source>
          <target state="translated">Los procedimientos también pueden ser tratados como expresiones,en cuyo caso se permite omitir el nombre del procedimiento.</target>
        </trans-unit>
        <trans-unit id="57362afa37cf6acde07ad138b615e180f8f62a5b" translate="yes" xml:space="preserve">
          <source>Procs featuring &lt;code&gt;type&lt;/code&gt; params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:</source>
          <target state="translated">Los procesos que presentan par&amp;aacute;metros de &lt;code&gt;type&lt;/code&gt; se consideran impl&amp;iacute;citamente gen&amp;eacute;ricos. Se crear&amp;aacute;n instancias para cada combinaci&amp;oacute;n &amp;uacute;nica de tipos proporcionados y, dentro del cuerpo del proceso, el nombre de cada par&amp;aacute;metro se referir&amp;aacute; al tipo de concreto enlazado:</target>
        </trans-unit>
        <trans-unit id="d11e4ea5c4fc8b9c8ae45fea3562c69c5ec08ed3" translate="yes" xml:space="preserve">
          <source>Procs featuring &lt;code&gt;typedesc&lt;/code&gt; params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6342d3bbf4c02568a11954f011158915db9e2356" translate="yes" xml:space="preserve">
          <source>Procs have been provided to calculate statistics on arrays and sequences.</source>
          <target state="translated">Se han suministrado procedimientos para calcular estadísticas sobre conjuntos y secuencias.</target>
        </trans-unit>
        <trans-unit id="797173c091947a15389bb8674683086569e23428" translate="yes" xml:space="preserve">
          <source>Procs that take an &lt;code&gt;onProgressChanged&lt;/code&gt; callback will call this every &lt;code&gt;progressInterval&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdad80c260c1b79fcf7078364eee12ddb03d0dbf" translate="yes" xml:space="preserve">
          <source>Procs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:</source>
          <target state="translated">Los procedimientos escritos con el estilo implícitamente genérico a menudo necesitarán referirse a los parámetros del tipo genérico emparejado.Se puede acceder a ellos fácilmente usando la sintaxis de puntos:</target>
        </trans-unit>
        <trans-unit id="cd7ff859e3411fbc571ec4264667afa27e529104" translate="yes" xml:space="preserve">
          <source>Produce and emit the parser message &lt;code&gt;arg&lt;/code&gt; to output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417499a3e724b26a485073043202bc4249cbf19c" translate="yes" xml:space="preserve">
          <source>Produces a new boolean literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff054aee7691236a9993dec46a2130a988a71073" translate="yes" xml:space="preserve">
          <source>Produces a new call node. &lt;code&gt;theProc&lt;/code&gt; is the proc that is called with the arguments &lt;code&gt;args[0..]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622a3a47b2c474ef796d04d2baf1a3173889bd80" translate="yes" xml:space="preserve">
          <source>Produces a new character literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ae80c128f37c9e400ccceee66df439075090a4" translate="yes" xml:space="preserve">
          <source>Produces a new float literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddd5e7e89e83e960e4a8323a02eadefcf15728a" translate="yes" xml:space="preserve">
          <source>Produces a new integer literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a27d8b9701ccfc7b4ff722f94e7f83a25b94830" translate="yes" xml:space="preserve">
          <source>Produces a new node with children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b793100dbd4a4b12a262055c30b601dac0bcd2" translate="yes" xml:space="preserve">
          <source>Produces a new string literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973901b80807f5ff207e2042993c04bbe7029db8" translate="yes" xml:space="preserve">
          <source>Produces a new unsigned integer literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5dd73eabe0ceec3510ddd56cff50a79d0fd6a6" translate="yes" xml:space="preserve">
          <source>Produces an XML tree for:</source>
          <target state="translated">Produce un árbol XML para:</target>
        </trans-unit>
        <trans-unit id="2fac879cf602e3396c116983a52de85ad6e251ad" translate="yes" xml:space="preserve">
          <source>Produces roughly this C code:</source>
          <target state="translated">Produce aproximadamente este código C:</target>
        </trans-unit>
        <trans-unit id="2659970d3474662f3ed922e19e08a245aa2fdc58" translate="yes" xml:space="preserve">
          <source>Produces the Cartesian product of the array. Warning: complexity may explode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960e8fddc698625d55770887235e931f448d8d54" translate="yes" xml:space="preserve">
          <source>Produces:</source>
          <target state="translated">Produces:</target>
        </trans-unit>
        <trans-unit id="2c32898c6bc516c95e3a09efcc75829d8ca400b4" translate="yes" xml:space="preserve">
          <source>ProfileData:</source>
          <target state="translated">ProfileData:</target>
        </trans-unit>
        <trans-unit id="f4cf552e1f1e8c0469d4436b64b404977bcf69c9" translate="yes" xml:space="preserve">
          <source>ProfileInfo:</source>
          <target state="translated">ProfileInfo:</target>
        </trans-unit>
        <trans-unit id="5869080be0ffd6203a367dfac147459656260124" translate="yes" xml:space="preserve">
          <source>Profiler:</source>
          <target state="translated">Profiler:</target>
        </trans-unit>
        <trans-unit id="a6d68bd4be10c0820c76fc8d06aecf226d4b6440" translate="yes" xml:space="preserve">
          <source>Program is executed.</source>
          <target state="translated">El programa se ejecuta.</target>
        </trans-unit>
        <trans-unit id="4f17a83cbcff788a0cad5a770a0848dad49ec175" translate="yes" xml:space="preserve">
          <source>Progress reporting</source>
          <target state="translated">Informes de progreso</target>
        </trans-unit>
        <trans-unit id="1f2140e31dbd92836ebf9c2bfdffac3015b3027f" translate="yes" xml:space="preserve">
          <source>Project switch</source>
          <target state="translated">Cambio de proyecto</target>
        </trans-unit>
        <trans-unit id="760874ddf5afe0d82343947ffb16ccd1781c1d3b" translate="yes" xml:space="preserve">
          <source>Proper thunk generation is harder because the proc that is to wrap could stem from a complex expression:</source>
          <target state="translated">La generación de pensamientos adecuados es más difícil porque el proceso de envolver podría surgir de una expresión compleja:</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="5e49b9bd99ab4bc355bcfd55bdeb30deaad41741" translate="yes" xml:space="preserve">
          <source>Protecting general locations</source>
          <target state="translated">Protección de las ubicaciones generales</target>
        </trans-unit>
        <trans-unit id="d8eec506723634351a9cba0d6d82397b9f72baf0" translate="yes" xml:space="preserve">
          <source>Protecting global variables</source>
          <target state="translated">Proteger las variables globales</target>
        </trans-unit>
        <trans-unit id="157122474fc28e9dcab665a3696cb13a6fe9933e" translate="yes" xml:space="preserve">
          <source>Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are available with the addition of &lt;code&gt;protSSLv23&lt;/code&gt; which allows for compatibility with all of them.</source>
          <target state="translated">La versi&amp;oacute;n del protocolo especifica el protocolo a utilizar. SSLv2, SSLv3, TLSv1 est&amp;aacute;n disponibles con la adici&amp;oacute;n de &lt;code&gt;protSSLv23&lt;/code&gt; que permite la compatibilidad con todos ellos.</target>
        </trans-unit>
        <trans-unit id="e38d7d5b91755bfbdf05c15f5eb398d4e6becf82" translate="yes" xml:space="preserve">
          <source>Provide a restrictive API that can load/save the compiletime state to a file.</source>
          <target state="translated">Proporcionar una API restrictiva que pueda cargar/guardar el estado de compilación a un archivo.</target>
        </trans-unit>
        <trans-unit id="7b940e771b06f772546586fc239edc7c0e4b029b" translate="yes" xml:space="preserve">
          <source>Provide spaces around binary operators if that enhances readability.</source>
          <target state="translated">Proporcionar espacios alrededor de los operadores binarios si eso mejora la legibilidad.</target>
        </trans-unit>
        <trans-unit id="021a736a22fb8ccb515c4ebdd3bd6f75f2aa9698" translate="yes" xml:space="preserve">
          <source>Provides access to the compiler's instantiation stack line information of a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41454706f7a445dc20f892c59f0f20e55e32de2" translate="yes" xml:space="preserve">
          <source>Provides system information in a &lt;code&gt;Uname&lt;/code&gt; struct with sysname, nodename, release, version and machine attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cea344353e26ba6f1565ed661d94f610ce9e4f" translate="yes" xml:space="preserve">
          <source>Proxy</source>
          <target state="translated">Proxy</target>
        </trans-unit>
        <trans-unit id="8ec4b541fad1239b548ff32ef94487dec816b95b" translate="yes" xml:space="preserve">
          <source>Pseudo import/include paths</source>
          <target state="translated">Seudoimportes/trayectos inclusivos</target>
        </trans-unit>
        <trans-unit id="e8905062c7f92650e2b49b14825d94b7e789608b" translate="yes" xml:space="preserve">
          <source>PtrLikeKinds:</source>
          <target state="translated">PtrLikeKinds:</target>
        </trans-unit>
        <trans-unit id="b3a030279e3be16bc447509ee9cb018fef87870e" translate="yes" xml:space="preserve">
          <source>Pull an identifier from prefix/postfix expressions</source>
          <target state="translated">Sacar un identificador de las expresiones de prefijo/postfijo</target>
        </trans-unit>
        <trans-unit id="ff5298d9926e7f25a3c4cd2c8956e4fd8ad809b8" translate="yes" xml:space="preserve">
          <source>Pull an identifier from prefix/postfix expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5ec8ce5c1cd610e2351c5a15b6b9c81346e199" translate="yes" xml:space="preserve">
          <source>Pure libraries</source>
          <target state="translated">Bibliotecas puras</target>
        </trans-unit>
        <trans-unit id="c6a218c1fffd61e7a4c8cd984b85f49ea6bce0e1" translate="yes" xml:space="preserve">
          <source>Pure libraries do not depend on any external &lt;code&gt;*.dll&lt;/code&gt; or &lt;code&gt;lib*.so&lt;/code&gt; binary while impure libraries do. A wrapper is an impure library that is a very low-level interface to a C library.</source>
          <target state="translated">Las bibliotecas puras no dependen de ning&amp;uacute;n &lt;code&gt;*.dll&lt;/code&gt; o &lt;code&gt;lib*.so&lt;/code&gt; binario externo, mientras que las bibliotecas impuras s&amp;iacute; lo hacen. Un contenedor es una biblioteca impura que es una interfaz de muy bajo nivel para una biblioteca C.</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ab194e6c51955e3ece7467854fe421e48b6e4cf4" translate="yes" xml:space="preserve">
          <source>Push item onto heap, maintaining the heap invariant.</source>
          <target state="translated">Empujar el objeto a la pila,manteniendo la pila invariable.</target>
        </trans-unit>
        <trans-unit id="de1a698df31e45a8f5f4c836ee77bd27a6716e91" translate="yes" xml:space="preserve">
          <source>Pushes &lt;code&gt;item&lt;/code&gt; onto heap, maintaining the heap invariant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03af26b6f966874b74a290186d326f05c96fece2" translate="yes" xml:space="preserve">
          <source>Put the SMTP connection in TLS (Transport Layer Security) mode. May fail with ReplyError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51a6bd4b9d6286ac6ae728ccaf7c792a9d75dc7" translate="yes" xml:space="preserve">
          <source>Puts a (key, value)-pair into &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfadf925b0a8b79995ad4896979cb346499bb036" translate="yes" xml:space="preserve">
          <source>Puts a new &lt;code&gt;(key, value)&lt;/code&gt; pair into &lt;code&gt;t&lt;/code&gt; even if &lt;code&gt;t[key]&lt;/code&gt; already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21951821226cf6b4fe9f15bee71bff72d85baae9" translate="yes" xml:space="preserve">
          <source>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39c27c6f3bf8974c957653b58c3fa5dc8ccf58c" translate="yes" xml:space="preserve">
          <source>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression. The original meaning of the interpolation operator may be obtained by escaping it (by prefixing it with itself): e.g. &lt;em&gt;@&lt;/em&gt; is escaped as &lt;em&gt;@@&lt;/em&gt;, &lt;em&gt;@@&lt;/em&gt; is escaped as &lt;em&gt;@@@&lt;/em&gt; and so on.</source>
          <target state="translated">Operador de cuasicotizaciones. Acepta una expresi&amp;oacute;n o un bloque y devuelve el AST que lo representa. Dentro del AST citado, puede interpolar expresiones de NimNode del &amp;aacute;mbito circundante. Si no se proporciona un operador, la cita se realiza con comillas invertidas. De lo contrario, el operador dado debe usarse como operador de prefijo para cualquier expresi&amp;oacute;n interpolada. El significado original del operador de interpolaci&amp;oacute;n se puede obtener escap&amp;aacute;ndolo (prefij&amp;aacute;ndolo con &amp;eacute;l mismo): por ejemplo, &lt;em&gt;@&lt;/em&gt; se escapa como &lt;em&gt;@@&lt;/em&gt; , &lt;em&gt;@@&lt;/em&gt; se escapa como &lt;em&gt;@@@&lt;/em&gt; y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="a8d92791ed83ac521184aed4c28bfc51de528ba5" translate="yes" xml:space="preserve">
          <source>Quickly find the log base 2 of an integer. If &lt;code&gt;x&lt;/code&gt; is zero, when &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; is set, result is -1, otherwise result is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84df47161db68162cf2c1cf2df6862e32ae9b781" translate="yes" xml:space="preserve">
          <source>Quickly find the log base 2 of an integer. If &lt;em&gt;x&lt;/em&gt; is zero, when &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; is set, result is -1, otherwise result is undefined.</source>
          <target state="translated">Encuentre r&amp;aacute;pidamente la base logar&amp;iacute;tmica 2 de un n&amp;uacute;mero entero. Si &lt;em&gt;x&lt;/em&gt; es cero, cuando se establece &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; , el resultado es -1; de lo contrario, el resultado no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="e155eddd124128a190616e7a186ae4d25f6a6ebc" translate="yes" xml:space="preserve">
          <source>QuitCalled</source>
          <target state="translated">QuitCalled</target>
        </trans-unit>
        <trans-unit id="707d835cf000590a6cbcdd3de8f6c5db75a32002" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to POSIX shell. Based on Python's &lt;code&gt;pipes.quote&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a34ec7721112f13b97cfbb0d6e0a2ad3e3442" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to POSIX shell. Based on Python's pipes.quote</source>
          <target state="translated">Citar &lt;code&gt;s&lt;/code&gt; , por lo que se puede pasar de forma segura al shell POSIX. Basado en las tuber&amp;iacute;as de Python.</target>
        </trans-unit>
        <trans-unit id="ef5384530fb53a4b50a924b05202ea7f5c268758" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to Windows API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d08dfbd0710ec2fc6ea17808fda70dbf079d436" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to shell.</source>
          <target state="translated">Cita &lt;code&gt;s&lt;/code&gt; , para que se pueda pasar de forma segura a shell.</target>
        </trans-unit>
        <trans-unit id="b5d45f4b8112546563b986e1d340a3de1ceef7ec" translate="yes" xml:space="preserve">
          <source>Quote s, so it can be safely passed to Windows API. Based on Python's subprocess.list2cmdline See &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt;</source>
          <target state="translated">Cita s, para que se pueda pasar de forma segura a la API de Windows. Basado en subprocess.list2cmdline de Python Consulte &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3a56dd5f4e333e6e2e0eafd9130d0884fa87aa3" translate="yes" xml:space="preserve">
          <source>RST Quick Reference</source>
          <target state="translated">Referencia rápida de RST</target>
        </trans-unit>
        <trans-unit id="bcb0bbc7586f8b1cf1562ef98d5628eb03fc6223" translate="yes" xml:space="preserve">
          <source>Raise statement</source>
          <target state="translated">Levante la declaración</target>
        </trans-unit>
        <trans-unit id="d96d8a1fbad05e28f48bbb7b60f4cc5f83489601" translate="yes" xml:space="preserve">
          <source>Raise the supported exceptions represented by &lt;code&gt;excepts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728c44d434025a939b40fb468f6b464eb21b6d42" translate="yes" xml:space="preserve">
          <source>Raise the supported exceptions represented by &lt;em&gt;excepts&lt;/em&gt;.</source>
          <target state="translated">Plantee las excepciones admitidas representadas por &lt;em&gt;excepciones&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ec3240294db6590d6eb674eceefe2d3080c82d81" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;0.0/0.0&lt;/code&gt;, for example.</source>
          <target state="translated">Aumento de &lt;code&gt;0.0/0.0&lt;/code&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="1ad44127cead1a93b77e67eaafbb798c1b8d6a72" translate="yes" xml:space="preserve">
          <source>Raised by division by zero.</source>
          <target state="translated">Aumentado por la división por cero.</target>
        </trans-unit>
        <trans-unit id="66d476b23e649e63bb348172beb74bbf37053e03" translate="yes" xml:space="preserve">
          <source>Raised by invalid operations according to IEEE.</source>
          <target state="translated">Criado por operaciones inválidas según el IEEE.</target>
        </trans-unit>
        <trans-unit id="0626d08315c63b21ae589949312963836c529522" translate="yes" xml:space="preserve">
          <source>Raised for inexact results.</source>
          <target state="translated">Criado para resultados inexactos.</target>
        </trans-unit>
        <trans-unit id="99e5be4241e93c72cfe80efe56d3696ed1d11b32" translate="yes" xml:space="preserve">
          <source>Raised for invalid memory access errors</source>
          <target state="translated">Levantado por errores de acceso a la memoria no válidos</target>
        </trans-unit>
        <trans-unit id="38c30cf567b7b9ee1eddd8acb70da472c0ad9270" translate="yes" xml:space="preserve">
          <source>Raised for overflows.</source>
          <target state="translated">Levantado para los desbordamientos.</target>
        </trans-unit>
        <trans-unit id="dd2cdbc5b0a42dacf72096db49f963030ac2eaf1" translate="yes" xml:space="preserve">
          <source>Raised for runtime integer divide-by-zero errors.</source>
          <target state="translated">Aumentado para errores de división entera por cero en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="2c9304ac03b02da4616572280aa9bb8ab12791a0" translate="yes" xml:space="preserve">
          <source>Raised for runtime integer overflows.</source>
          <target state="translated">Aumentado para desbordamientos de enteros en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="32c28ea5c78055e8ea68515c83c3ba22b6953b99" translate="yes" xml:space="preserve">
          <source>Raised for string and object conversion errors.</source>
          <target state="translated">Levantado por errores de conversión de cuerdas y objetos.</target>
        </trans-unit>
        <trans-unit id="08c46d3ef782190797d8a4bd64e301f0fa063ecc" translate="yes" xml:space="preserve">
          <source>Raised for underflows.</source>
          <target state="translated">Levantado para las corrientes submarinas.</target>
        </trans-unit>
        <trans-unit id="be95aced11bd594c29b8a4cd5b58705ab2fd7a7d" translate="yes" xml:space="preserve">
          <source>Raised for unsuccessful attempts to allocate memory.</source>
          <target state="translated">Criado por los intentos fallidos de asignar la memoria.</target>
        </trans-unit>
        <trans-unit id="ec59fe758ecda80d7bef1c0104bc8498d5c4a618" translate="yes" xml:space="preserve">
          <source>Raised if a dynamic library could not be loaded.</source>
          <target state="translated">Se levantaría si una biblioteca dinámica no pudiera ser cargada.</target>
        </trans-unit>
        <trans-unit id="fe56f3d52954d21251fffdab96d048a6101b0e04" translate="yes" xml:space="preserve">
          <source>Raised if a key cannot be found in a table.</source>
          <target state="translated">Se levanta si no se puede encontrar una llave en una mesa.</target>
        </trans-unit>
        <trans-unit id="bbba70332d0c775286b48ce439b172d9ba242f8e" translate="yes" xml:space="preserve">
          <source>Raised if a range check error occurred.</source>
          <target state="translated">Aumentado si se produce un error en la comprobación del rango.</target>
        </trans-unit>
        <trans-unit id="650353b9e13b1678f3e0f946a77bce78b804cb35" translate="yes" xml:space="preserve">
          <source>Raised if a record field is not accessible because its dicriminant's value does not fit.</source>
          <target state="translated">Aumentado si un campo de registro no es accesible porque el valor de su dicriminante no encaja.</target>
        </trans-unit>
        <trans-unit id="2fffcd1cf8b129cd2ba5e5e1a92281ab5c51b0fc" translate="yes" xml:space="preserve">
          <source>Raised if a record field is not accessible because its discriminant's value does not fit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad88cbc3b7ff45823f8340b1fcd5be1d429c6ad" translate="yes" xml:space="preserve">
          <source>Raised if a resource request could not be fulfilled.</source>
          <target state="translated">Se plantea si no se puede cumplir con una solicitud de recursos.</target>
        </trans-unit>
        <trans-unit id="cd11d72b167232b61b07884734877076a77cdc66" translate="yes" xml:space="preserve">
          <source>Raised if an IO &quot;end of file&quot; error occurred.</source>
          <target state="translated">Aumentado si se produce un error de &quot;fin de archivo&quot; IO.</target>
        </trans-unit>
        <trans-unit id="68c91c46567b49ce511b6a68e91cd37c644d9b1b" translate="yes" xml:space="preserve">
          <source>Raised if an IO error occurred.</source>
          <target state="translated">Aumentado si se produce un error de IO.</target>
        </trans-unit>
        <trans-unit id="f68ad7db1fb95353786755c35e1d60aecfb00a29" translate="yes" xml:space="preserve">
          <source>Raised if an array index is out of bounds.</source>
          <target state="translated">Sube si el índice de la matriz está fuera de los límites.</target>
        </trans-unit>
        <trans-unit id="d3ef858ef306b68c4f896a6d7c87ab203440961c" translate="yes" xml:space="preserve">
          <source>Raised if an object gets assigned to its parent's object.</source>
          <target state="translated">Criado si un objeto se asigna al objeto de su padre.</target>
        </trans-unit>
        <trans-unit id="fdb573346d5de72dc1dc0894684d9b86b57d2d06" translate="yes" xml:space="preserve">
          <source>Raised if an object is converted to an incompatible object type. You can use &lt;code&gt;of&lt;/code&gt; operator to check if conversion will succeed.</source>
          <target state="translated">Se genera si un objeto se convierte en un tipo de objeto incompatible. Se puede utilizar &lt;code&gt;of&lt;/code&gt; operador para comprobar si la conversi&amp;oacute;n se realizar&amp;aacute; correctamente.</target>
        </trans-unit>
        <trans-unit id="da2633c286ea06df76a0438d7891623c292b571a" translate="yes" xml:space="preserve">
          <source>Raised if an operating system service failed.</source>
          <target state="translated">Se eleva si un servicio del sistema operativo falla.</target>
        </trans-unit>
        <trans-unit id="028c1298a842b618b5e92022ea3c9cb7f8150b55" translate="yes" xml:space="preserve">
          <source>Raised if any kind of arithmetic error occurred.</source>
          <target state="translated">Se eleva si se produce algún tipo de error aritmético.</target>
        </trans-unit>
        <trans-unit id="b57acbd1eafc73247bdc8b7db4a7e36731116243" translate="yes" xml:space="preserve">
          <source>Raised if it is attempted to send a message to a dead thread.</source>
          <target state="translated">Levantado si se intenta enviar un mensaje a un hilo muerto.</target>
        </trans-unit>
        <trans-unit id="586536f2532bdba51684aaa2faaccf9a0ee3ad93" translate="yes" xml:space="preserve">
          <source>Raised if the hardware stack used for subroutine calls overflowed.</source>
          <target state="translated">Se elevó si la pila de hardware utilizada para las llamadas de subrutinas se desbordó.</target>
        </trans-unit>
        <trans-unit id="17261fb73363d2c277ed1529e2e101dd346435d0" translate="yes" xml:space="preserve">
          <source>Raised if there is no exception to reraise.</source>
          <target state="translated">Criado si no hay ninguna excepción a la crianza.</target>
        </trans-unit>
        <trans-unit id="351c8bf075d81572768b1ca963b6bf3b6f76ed34" translate="yes" xml:space="preserve">
          <source>Raised on attempts to re-sink an already consumed &lt;code&gt;sink&lt;/code&gt; parameter.</source>
          <target state="translated">Se genera en los intentos de volver a hundir un par&amp;aacute;metro de &lt;code&gt;sink&lt;/code&gt; ya consumido .</target>
        </trans-unit>
        <trans-unit id="c3c39e104d96138eb3a3997e68ced83f3dee4e47" translate="yes" xml:space="preserve">
          <source>Raised on dereferences of &lt;code&gt;nil&lt;/code&gt; pointers.</source>
          <target state="translated">Criado en desreferencias de punteros &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32a2e38706f27d38537d5bf0c1530200f9030954" translate="yes" xml:space="preserve">
          <source>Raised when a tag is not properly closed</source>
          <target state="translated">Se levanta cuando una etiqueta no está bien cerrada</target>
        </trans-unit>
        <trans-unit id="42ca68196e5e694cdc0156d223a1ff6b17dcec98" translate="yes" xml:space="preserve">
          <source>Raised when an unexpected XML Parser event occurs</source>
          <target state="translated">Se plantea cuando se produce un evento inesperado de XML Parser</target>
        </trans-unit>
        <trans-unit id="4d15913f72d2ca164e122d25060193477a26ffc0" translate="yes" xml:space="preserve">
          <source>Raised when assertion is proved wrong.</source>
          <target state="translated">Se plantea cuando se comprueba que la afirmación es errónea.</target>
        </trans-unit>
        <trans-unit id="fdbcd933410345697cf76acdf9926620d94d3b8e" translate="yes" xml:space="preserve">
          <source>Raised when parsing a &lt;code&gt;TimeFormat&lt;/code&gt; string fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0c54a9ceebd56228f9e7a47a36cc438b296a4a" translate="yes" xml:space="preserve">
          <source>Raised when parsing input using a &lt;code&gt;TimeFormat&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94babf1279c76282aa7e3b74b85ba454ebe03766" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionDefect&lt;/code&gt; if specified &lt;code&gt;code&lt;/code&gt; does not raise the specified exception. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdd67ba0a2ee1b9a768b23962088796764a4478" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionDefect&lt;/code&gt; with &lt;code&gt;msg&lt;/code&gt; if &lt;code&gt;cond&lt;/code&gt; is false. Note that &lt;code&gt;AssertionDefect&lt;/code&gt; is hidden from the effect system, so it doesn't produce &lt;code&gt;{.raises: [AssertionDefect].}&lt;/code&gt;. This exception is only supposed to be caught by unit testing frameworks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91029130d53f12dffcfc80d43ea48134c5d69fcf" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionError&lt;/code&gt; if specified &lt;code&gt;code&lt;/code&gt; does not raise the specified exception. Example:</source>
          <target state="translated">Genera &lt;code&gt;AssertionError&lt;/code&gt; si el &lt;code&gt;code&lt;/code&gt; especificado no genera la excepci&amp;oacute;n especificada. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="567f8f001d78a8e744cdf6369fc805b49aa2b893" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionError&lt;/code&gt; with &lt;em&gt;msg&lt;/em&gt; if &lt;em&gt;cond&lt;/em&gt; is false. Note that &lt;code&gt;AssertionError&lt;/code&gt; is hidden from the effect system, so it doesn't produce &lt;code&gt;{.raises: [AssertionError].}&lt;/code&gt;. This exception is only supposed to be caught by unit testing frameworks.</source>
          <target state="translated">Genera &lt;code&gt;AssertionError&lt;/code&gt; con &lt;em&gt;msg&lt;/em&gt; si &lt;em&gt;cond&lt;/em&gt; es falso. Tenga en cuenta que &lt;code&gt;AssertionError&lt;/code&gt; est&amp;aacute; oculto al sistema de efectos, por lo que no produce &lt;code&gt;{.raises: [AssertionError].}&lt;/code&gt; . Se supone que esta excepci&amp;oacute;n solo debe detectarse mediante marcos de prueba unitarios.</target>
        </trans-unit>
        <trans-unit id="83faa64f0dc51236f90a868139ec38fb95462791" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;EDb&lt;/code&gt; if the connection could not be established.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66f8302c80cace007ec26b7dd8b0079cd5a50b0" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred. Returns '\0' as an EOF marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6894f48a57ffed3e94bbf7818467bd56356354ec" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OSError&lt;/code&gt; if any of the files does not exist or information about it can not be obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d275297cc16ea24212ee08bfe9169118ebac459" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OSError&lt;/code&gt; in case of an error. Follows symlinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cc1c9996322f8cc38f559f2584b50f088e6996" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid hex values. The comparison is case-insensitive.</source>
          <target state="translated">Plantea &lt;code&gt;ValueError&lt;/code&gt; durante valores hexadecimales v&amp;aacute;lidos. La comparaci&amp;oacute;n no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="3b3e8ef72efa78e2c5caac2a7c250a94e659a2c7" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid value in &lt;code&gt;s&lt;/code&gt;. The comparison is done in a style insensitive way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22f12804c795d88ca74f939ddf08aea8931971a" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">Plantea &lt;code&gt;ValueError&lt;/code&gt; por un valor no v&amp;aacute;lido en el &lt;em&gt;s&lt;/em&gt; . La comparaci&amp;oacute;n se realiza de una manera insensible al estilo.</target>
        </trans-unit>
        <trans-unit id="2d4578456b5ba2f01543ab1822189b16a39fba87" translate="yes" xml:space="preserve">
          <source>Raises &lt;em&gt;EDb&lt;/em&gt; if the connection could not be established.</source>
          <target state="translated">Eleva &lt;em&gt;EDb&lt;/em&gt; si no se pudo establecer la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="09f056dbb100b1c839a4625115b8a60c96d1a0e6" translate="yes" xml:space="preserve">
          <source>Raises EInvalidValue in case of an error.</source>
          <target state="translated">Aumenta el Valor Inválido en caso de error.</target>
        </trans-unit>
        <trans-unit id="e0bebaa2403bca683eb4d2b3f51753adb492d176" translate="yes" xml:space="preserve">
          <source>Raises EOS on error.</source>
          <target state="translated">Sube el EOS por error.</target>
        </trans-unit>
        <trans-unit id="3094065727173e7ff0610b2ec2f7fa1c58ae43f7" translate="yes" xml:space="preserve">
          <source>Raises KeyError if the set &lt;code&gt;s&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80f698527275363029eae2721df321a059387f0" translate="yes" xml:space="preserve">
          <source>Raises KeyError if the set &lt;em&gt;s&lt;/em&gt; is empty.</source>
          <target state="translated">Genera KeyError si el conjunto &lt;em&gt;s&lt;/em&gt; est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="dc121ba0d8a6bbb1d7c05a5c564231baa3ad236b" translate="yes" xml:space="preserve">
          <source>Raises OSError on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1994fdf951fcefef8875ee783032c923a838b8c1" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;DbError&lt;/code&gt; exception when failed to insert row. For Postgre this adds &lt;code&gt;RETURNING id&lt;/code&gt; to the query, so it only works if your primary key is named &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a13ee0841c3615288bf2501646fe81c56c819e" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;DbError&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bcb2956d86cad57b8ce1d8879b7ac38c45bebf8" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; exception if &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;contentType&lt;/code&gt; contain newline characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8600b37550ccb497a4af5ce01a4410e73d0d2b" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; if the parsing fails or the value is not a correctly formatted time.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; un ValueError si el an&amp;aacute;lisis falla o el valor no es una hora con el formato correcto.</target>
        </trans-unit>
        <trans-unit id="276b555f70ce184a6b1f8f69f1b6bd8354a1579b" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; if the response's &lt;code&gt;status&lt;/code&gt; does not have a corresponding &lt;code&gt;HttpCode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; un ValueError si el &lt;code&gt;status&lt;/code&gt; la respuesta no tiene un &lt;code&gt;HttpCode&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="307a090405fae28bbe37ae495085d4fc3467fca3" translate="yes" xml:space="preserve">
          <source>Raises a new SSL error.</source>
          <target state="translated">Provoca un nuevo error en el SSL.</target>
        </trans-unit>
        <trans-unit id="4058e50bf03acedae079d451577c7b21d4279856" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;system#OSError&quot;&gt;OSError exception&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be1df9024700353ee279a033c20b43e611103d1" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;[DbError]&lt;/code&gt; exception with ODBC error information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b8735df78acafac0305b07c45583c0f5e06188" translate="yes" xml:space="preserve">
          <source>Raises an &lt;em&gt;[DbError]&lt;/em&gt; exception with ODBC error information</source>
          <target state="translated">Plantea una &lt;em&gt;[DBERROR]&lt;/em&gt; excepci&amp;oacute;n, con informaci&amp;oacute;n de error de ODBC</target>
        </trans-unit>
        <trans-unit id="172a8dadd8dd7c12c87a018821e520f360bdd00c" translate="yes" xml:space="preserve">
          <source>Raises an EOS error upon failure.</source>
          <target state="translated">Provoca un error de EOS al fallar.</target>
        </trans-unit>
        <trans-unit id="524595e54374e963ef480df057abcc139126f7c3" translate="yes" xml:space="preserve">
          <source>Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.</source>
          <target state="translated">Hace una excepción de IO en caso de error.Es un error si la posición actual del archivo no está al principio del mismo.</target>
        </trans-unit>
        <trans-unit id="6ab99fafbb1c01fadc221231a21a65c013cfa660" translate="yes" xml:space="preserve">
          <source>Raises an OSError based on the error code returned by &lt;code&gt;SSLGetError&lt;/code&gt; (for SSL sockets) and &lt;code&gt;osLastError&lt;/code&gt; otherwise.</source>
          <target state="translated">Genera un OSError basado en el c&amp;oacute;digo de error devuelto por &lt;code&gt;SSLGetError&lt;/code&gt; (para sockets SSL) y &lt;code&gt;osLastError&lt;/code&gt; en caso contrario.</target>
        </trans-unit>
        <trans-unit id="06bc197d01299cedae87da2f96f00c76ba39cb84" translate="yes" xml:space="preserve">
          <source>Raises an OSError based on the error code returned by &lt;code&gt;SSL_get_error&lt;/code&gt; (for SSL sockets) and &lt;code&gt;osLastError&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981040978083ddb6aedc722b391b33e2f5b4fa72" translate="yes" xml:space="preserve">
          <source>Raises an OSError error upon failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ebae0e4f71b7a4be2a66964668697eb30ea1dc" translate="yes" xml:space="preserve">
          <source>Raises exceptions for the status codes &lt;code&gt;4xx&lt;/code&gt; and &lt;code&gt;5xx&lt;/code&gt;</source>
          <target state="translated">Genera excepciones para los c&amp;oacute;digos de estado &lt;code&gt;4xx&lt;/code&gt; y &lt;code&gt;5xx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bbcfba3180974b175ec29f25aedc4af60fbde06f" translate="yes" xml:space="preserve">
          <source>Raises proper errors based on return values of &lt;code&gt;recv&lt;/code&gt; functions.</source>
          <target state="translated">Genera errores adecuados basados ​​en valores de retorno de funciones &lt;code&gt;recv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2208414278b65730f3d9e753c0bd6120a6090206" translate="yes" xml:space="preserve">
          <source>Raising an exception is done with the &lt;code&gt;raise&lt;/code&gt; statement:</source>
          <target state="translated">La creaci&amp;oacute;n de una excepci&amp;oacute;n se realiza con la declaraci&amp;oacute;n de &lt;code&gt;raise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="39db0baa12271196bc8f4503eccfe33d8bedd2cf" translate="yes" xml:space="preserve">
          <source>Ranges occur in set constructors, case statement branches, or array slices. Internally, the node kind &lt;code&gt;nnkRange&lt;/code&gt; is used, but when constructing the AST, construction with &lt;code&gt;..&lt;/code&gt; as an infix operator should be used instead.</source>
          <target state="translated">Los rangos se producen en constructores de conjuntos, ramas de sentencias de casos o sectores de matriz. Internamente, se usa el tipo de nodo &lt;code&gt;nnkRange&lt;/code&gt; , pero al construir el AST, se debe usar la construcci&amp;oacute;n con &lt;code&gt;..&lt;/code&gt; como operador infijo en su lugar.</target>
        </trans-unit>
        <trans-unit id="0a6d74fbec021ac49e6d5b9824dc9112431d3fb1" translate="yes" xml:space="preserve">
          <source>Rationale: Consistency with overloaded assignment or assignment-like operations, &lt;code&gt;a = b&lt;/code&gt; can be read as &lt;code&gt;performSomeCopy(a, b)&lt;/code&gt;.</source>
          <target state="translated">Justificaci&amp;oacute;n: coherencia con la asignaci&amp;oacute;n sobrecargada o las operaciones similares a &lt;code&gt;a = b&lt;/code&gt; asignaci&amp;oacute;n, a = b se puede leer como &lt;code&gt;performSomeCopy(a, b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab08d8a4461364c6af80c6c7c98c0b2b7dab27a7" translate="yes" xml:space="preserve">
          <source>Rationale: This is far easier to implement than hypothetical alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9a4a772a88d49b6a63f78245488ac96b3f98ab" translate="yes" xml:space="preserve">
          <source>Raw string literals</source>
          <target state="translated">Literales de cuerda cruda</target>
        </trans-unit>
        <trans-unit id="386ba29889d0288988970831100059ae32e75da0" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;size&lt;/code&gt; bytes from the specified file asynchronously starting at the current position of the file pointer.</source>
          <target state="translated">Leer &lt;code&gt;size&lt;/code&gt; bytes del archivo especificado de forma asincr&amp;oacute;nica comenzando en la posici&amp;oacute;n actual del puntero del archivo.</target>
        </trans-unit>
        <trans-unit id="7ae2849845c6540687653cb08ca1d61f314e6677" translate="yes" xml:space="preserve">
          <source>Read CGI data from a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9e33ecea7657999c83b3f119c92f8cdd6252a4" translate="yes" xml:space="preserve">
          <source>Read CGI data. If the client does not use a method listed in the &lt;code&gt;allowedMethods&lt;/code&gt; set, an &lt;code&gt;ECgi&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6837b052d9e0068e0b32c146cb0a7341a45c3d40" translate="yes" xml:space="preserve">
          <source>Read CGI data. If the client does not use a method listed in the &lt;em&gt;allowedMethods&lt;/em&gt; set, an &lt;em&gt;ECgi&lt;/em&gt; exception is raised.</source>
          <target state="translated">Leer datos CGI. Si el cliente no usa un m&amp;eacute;todo listado en el conjunto &lt;em&gt;allowedMethods&lt;/em&gt; , se &lt;em&gt;genera&lt;/em&gt; una excepci&amp;oacute;n &lt;em&gt;ECgi&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cec1fd33cb854b699cea99a9f755995756d5ee2f" translate="yes" xml:space="preserve">
          <source>Read a single character from the terminal, blocking until it is entered. The character is not printed to the terminal.</source>
          <target state="translated">Lee un solo carácter de la terminal,bloqueándolo hasta que se introduzca.El carácter no se imprime en el terminal.</target>
        </trans-unit>
        <trans-unit id="58a1329fd636aaedc19278e8f118476d716ed20a" translate="yes" xml:space="preserve">
          <source>Read file stream example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ae5075e8a76e1e3bf797c3ca0f0105038061c6" translate="yes" xml:space="preserve">
          <source>Read or write stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88bf8c215b46559275a409fea6da7ac855220c7" translate="yes" xml:space="preserve">
          <source>Read the description of the &lt;a href=&quot;#newOSError,OSErrorCode,string&quot;&gt;newOSError proc&lt;/a&gt; to learn how the exception object is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1f949ee6094b79d43e6d504438e7f6f64c9ab8" translate="yes" xml:space="preserve">
          <source>Read this &lt;a href=&quot;apis&quot;&gt;document&lt;/a&gt; for a quick overview of the API design.</source>
          <target state="translated">Lea este &lt;a href=&quot;apis&quot;&gt;documento&lt;/a&gt; para obtener una descripci&amp;oacute;n general r&amp;aacute;pida del dise&amp;ntilde;o de la API.</target>
        </trans-unit>
        <trans-unit id="e12115c2336394c1a363bbc5f4d2a10707e72fdd" translate="yes" xml:space="preserve">
          <source>Read/Write tracking</source>
          <target state="translated">Seguimiento de lectura y escritura</target>
        </trans-unit>
        <trans-unit id="7bad437b94c79808d48551fc7876a886aeec220d" translate="yes" xml:space="preserve">
          <source>Reading a configuration file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24620e210d243aab2166090142b8a7d92b8f8897" translate="yes" xml:space="preserve">
          <source>Reading a configuration file.</source>
          <target state="translated">Leyendo un archivo de configuración.</target>
        </trans-unit>
        <trans-unit id="7421207f915a61053be48ee1f81c1396400af83a" translate="yes" xml:space="preserve">
          <source>Reading values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5a5f0d0a31292a7e615d242d5373135350e488" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;, which must at least be of that size. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Lee &lt;strong&gt;hasta&lt;/strong&gt; bytes de &lt;code&gt;size&lt;/code&gt; del &lt;code&gt;socket&lt;/code&gt; al &lt;code&gt;buf&lt;/code&gt; , que debe ser al menos de ese tama&amp;ntilde;o. El futuro devuelto se completar&amp;aacute; una vez que se hayan le&amp;iacute;do todos los datos solicitados, se haya le&amp;iacute;do una parte de los datos o se haya desconectado el socket, en cuyo caso el futuro se completar&amp;aacute; con un valor de &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e7c0e94dad43b7d156eb9468f3ce53d820c8c1b" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Lee &lt;strong&gt;hasta&lt;/strong&gt; bytes de &lt;code&gt;size&lt;/code&gt; del &lt;code&gt;socket&lt;/code&gt; al &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33491ee917470d5dff9cb97340d439812d5536b8" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">Lee &lt;strong&gt;hasta&lt;/strong&gt; bytes de &lt;code&gt;size&lt;/code&gt; desde el &lt;code&gt;socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77c0df6a022c05feac3496fef62e568dec0833b2" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt;. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Lee &lt;strong&gt;hasta&lt;/strong&gt; bytes de &lt;code&gt;size&lt;/code&gt; desde el &lt;code&gt;socket&lt;/code&gt; . El futuro devuelto se completar&amp;aacute; una vez que se hayan le&amp;iacute;do todos los datos solicitados, se haya le&amp;iacute;do una parte de los datos o se haya desconectado el socket, en cuyo caso el futuro se completar&amp;aacute; con un valor de &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="978c556c2dd2a7521290801e2dc3c34fa4b57db4" translate="yes" xml:space="preserve">
          <source>Reads a &lt;em&gt;password&lt;/em&gt; from stdin without printing it. &lt;em&gt;password&lt;/em&gt; must not be &lt;code&gt;nil&lt;/code&gt;! Returns &lt;code&gt;false&lt;/code&gt; if the end of the file has been reached, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">Lee una &lt;em&gt;contrase&amp;ntilde;a&lt;/em&gt; de stdin sin imprimirla. &lt;em&gt;La contrase&amp;ntilde;a&lt;/em&gt; no debe ser &lt;code&gt;nil&lt;/code&gt; . Devuelve &lt;code&gt;false&lt;/code&gt; si se ha llegado al final del archivo, &lt;code&gt;true&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="ce48b1b4358052432406e956566fc0d7c5a91157" translate="yes" xml:space="preserve">
          <source>Reads a bool from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db9e9c7c5aa541797e5f1778ae04def378cc0ce" translate="yes" xml:space="preserve">
          <source>Reads a char from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444646cd8abc01e30ae794dcda8cbbdb2222593d" translate="yes" xml:space="preserve">
          <source>Reads a float32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d61cabb21cb1835fe80bb50992fd3d84a2ca59" translate="yes" xml:space="preserve">
          <source>Reads a float64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2d32cde52d11c29e47f77d0e5566b28e25896c" translate="yes" xml:space="preserve">
          <source>Reads a line from a stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c7c69f0a4086f87414fa84f0850e98e826f6a2" translate="yes" xml:space="preserve">
          <source>Reads a line from a stream &lt;em&gt;s&lt;/em&gt;. Note: This is not very efficient. Raises &lt;em&gt;EIO&lt;/em&gt; if an error occurred.</source>
          <target state="translated">Lee una l&amp;iacute;nea de un flujo &lt;em&gt;s&lt;/em&gt; . Nota: esto no es muy eficaz. Genera &lt;em&gt;EIO&lt;/em&gt; si ocurre un error.</target>
        </trans-unit>
        <trans-unit id="603f08eff7888543b9965532d75111a52efffb42" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;resString&lt;/code&gt;.</source>
          <target state="translated">Lee una l&amp;iacute;nea de datos del &lt;code&gt;socket&lt;/code&gt; a &lt;code&gt;resString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f939728ad91b0c6736db56d252e3d56ef5aac62" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">Lee una l&amp;iacute;nea de datos de &lt;code&gt;socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9683a6732a76c35b64fa9e3a0d7661b3a22d384" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt;. Returned future will complete once a full line is read or an error occurs.</source>
          <target state="translated">Lee una l&amp;iacute;nea de datos de &lt;code&gt;socket&lt;/code&gt; . El futuro devuelto se completar&amp;aacute; una vez que se lea una l&amp;iacute;nea completa o se produzca un error.</target>
        </trans-unit>
        <trans-unit id="3847b584349df73d4d611006c26414caaf93bd15" translate="yes" xml:space="preserve">
          <source>Reads a line of data from stdin - blocks until n or EOF which happens when stdin is closed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aecd3b8f1dea16d09efe88e1e8d84722091e2e7" translate="yes" xml:space="preserve">
          <source>Reads a line of text from the stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt; must not be &lt;code&gt;nil&lt;/code&gt;! May throw an IO exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512f7f707ed82b2a4fb989d157a70b5d69b30b07" translate="yes" xml:space="preserve">
          <source>Reads a password from stdin without printing it.</source>
          <target state="translated">Lee una contraseña de stdin sin imprimirla.</target>
        </trans-unit>
        <trans-unit id="3a565e53f76c99ac01c6e7755400b49c72fd17b5" translate="yes" xml:space="preserve">
          <source>Reads a single character from the stream &lt;code&gt;f&lt;/code&gt;. Should not be used in performance sensitive code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f82d6c2b3adf0dd37525a198d9bcda0bb8916c" translate="yes" xml:space="preserve">
          <source>Reads a single character from the stream &lt;em&gt;f&lt;/em&gt;. Should not be used in performance sensitive code.</source>
          <target state="translated">Lee un solo car&amp;aacute;cter de la secuencia &lt;em&gt;f&lt;/em&gt; . No debe usarse en c&amp;oacute;digo sensible al rendimiento.</target>
        </trans-unit>
        <trans-unit id="4ad562c998d7d33d16f2d35016ec8f1190aaf424" translate="yes" xml:space="preserve">
          <source>Reads a single line from the specified file asynchronously.</source>
          <target state="translated">Lee una sola línea del archivo especificado asincrónicamente.</target>
        </trans-unit>
        <trans-unit id="e6392a2ce7ba8c43bede495139762911cf43dab7" translate="yes" xml:space="preserve">
          <source>Reads a string of length &lt;code&gt;length&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45c699410e48af3598ad0ffd48f49477789d869" translate="yes" xml:space="preserve">
          <source>Reads all available data.</source>
          <target state="translated">Lee todos los datos disponibles.</target>
        </trans-unit>
        <trans-unit id="2fd12af609f6c0c44ecea736f73e6dced25a94f4" translate="yes" xml:space="preserve">
          <source>Reads all data from stdin - blocks until EOF which happens when stdin is closed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8cdad2cd8286acdfd0d66e63f133bab5192a3c" translate="yes" xml:space="preserve">
          <source>Reads all data from the specified file.</source>
          <target state="translated">Lee todos los datos del archivo especificado.</target>
        </trans-unit>
        <trans-unit id="607456770984494827062ec12a94f5f8805c30aa" translate="yes" xml:space="preserve">
          <source>Reads all data from the stream &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c0c9eac2fafeeecf77fef0fbd118a7d5fe097d" translate="yes" xml:space="preserve">
          <source>Reads all data from the stream &lt;em&gt;file&lt;/em&gt;.</source>
          <target state="translated">Lee todos los datos del &lt;em&gt;archivo&lt;/em&gt; continuo .</target>
        </trans-unit>
        <trans-unit id="a7a03269d18b195e925ad9c77002d605c67ad1ac" translate="yes" xml:space="preserve">
          <source>Reads an int16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da7f67b91586db02c5b853ed490a5b2b0ce65ac" translate="yes" xml:space="preserve">
          <source>Reads an int32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6198aa8906f011e979ffbd40950dff7b0b296ef" translate="yes" xml:space="preserve">
          <source>Reads an int64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71175b4a24a11e531a6e13b456559b45b07beffd" translate="yes" xml:space="preserve">
          <source>Reads an int8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4636e7a0ee095ed96e677e732b5563936ba23cd0" translate="yes" xml:space="preserve">
          <source>Reads an uint16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab8c1e7be4b6116cc56b4597be1df909a24bbb2" translate="yes" xml:space="preserve">
          <source>Reads an uint32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1ee6f7d57815e3a9aeeb3c2780f23d6024cab6" translate="yes" xml:space="preserve">
          <source>Reads an uint64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b50c7fc4493290e27785f0bddc497b8082c478" translate="yes" xml:space="preserve">
          <source>Reads an uint8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16aa2b06a9fd45fdc5177ba0791c46e2186fefff" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of.</source>
          <target state="translated">Lee y decodifica los datos CGI y produce los pares (nombre,valor)de los que se componen los datos.</target>
        </trans-unit>
        <trans-unit id="d02b91ef117c2e1852e6fa0ea5eaaaa055755450" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the &lt;code&gt;allowedMethods&lt;/code&gt; set, an &lt;code&gt;ECgi&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f08e1736fd8ee6f6e4264f9ba880fc2692403ee" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the &lt;em&gt;allowedMethods&lt;/em&gt; set, an &lt;em&gt;ECgi&lt;/em&gt; exception is raised.</source>
          <target state="translated">Lee y decodifica datos CGI y produce los pares (nombre, valor) de los que constan los datos. Si el cliente no usa un m&amp;eacute;todo listado en el conjunto &lt;em&gt;allowedMethods&lt;/em&gt; , se &lt;em&gt;genera&lt;/em&gt; una excepci&amp;oacute;n &lt;em&gt;ECgi&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b51006412d40deb76f46a9f4cf49b32d91c5577f" translate="yes" xml:space="preserve">
          <source>Reads data and transforms it to a type &lt;code&gt;T&lt;/code&gt; (deserialization, unmarshalling).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd580d77db8229465ebeb4157251802035fe7ba1" translate="yes" xml:space="preserve">
          <source>Reads data from the specified future stream until it is completed. The data which is read is written to the file immediately and freed from memory.</source>
          <target state="translated">Lee los datos de la corriente futura especificada hasta que se complete.Los datos que se leen se escriben en el archivo inmediatamente y se liberan de la memoria.</target>
        </trans-unit>
        <trans-unit id="6453f710c400a1bd3088d85ace46f2b0c556b4f3" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as a bool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595d56d3e18b21c18bca00840423ca2ea7fc2a5e" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as a string</source>
          <target state="translated">Se lee en una definición de tiempo de construcción como una cadena</target>
        </trans-unit>
        <trans-unit id="e8adc86af0b87b9e44aebe3a30de9bd18fc60874" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as an integer</source>
          <target state="translated">Se lee en un tiempo de construcción definido como un entero</target>
        </trans-unit>
        <trans-unit id="4598472634a594f3ffeff8206db9ccc9d9d0f85d" translate="yes" xml:space="preserve">
          <source>Reads the first row and creates a look-up table for column numbers See also &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt;.</source>
          <target state="translated">Lee la primera fila y crea una tabla de b&amp;uacute;squeda para los n&amp;uacute;meros de columna. Consulte tambi&amp;eacute;n &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc93c75abc8e47d3649940dfe86c4205db62db9" translate="yes" xml:space="preserve">
          <source>Reads the first row and creates a look-up table for column numbers See also:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c75a689c79c66c1db3b8b33ba096a09aab5fb43" translate="yes" xml:space="preserve">
          <source>Reads the next row; if &lt;code&gt;columns&lt;/code&gt; &amp;gt; 0, it expects the row to have exactly this many columns. Returns false if the end of the file has been encountered else true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494c153aaf278be23e83188e46e8ae53c00137ae" translate="yes" xml:space="preserve">
          <source>Reads the response's body and caches it. The read is performed only once.</source>
          <target state="translated">Lee el cuerpo de la respuesta y lo almacena.La lectura se realiza sólo una vez.</target>
        </trans-unit>
        <trans-unit id="c09ea5f583e17a92aa05d2a79d90d53798b88bd5" translate="yes" xml:space="preserve">
          <source>Realtime support</source>
          <target state="translated">Soporte en tiempo real</target>
        </trans-unit>
        <trans-unit id="0a4f8939ec5010f9c8a6d335f9942ba0998f0630" translate="yes" xml:space="preserve">
          <source>Reborrows</source>
          <target state="translated">Reborrows</target>
        </trans-unit>
        <trans-unit id="4818f606d1ff08f9655a082b5139170b1f1676b8" translate="yes" xml:space="preserve">
          <source>Rebuilding the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a26b1287f5ff59f6b29334f315518ff72b9960f" translate="yes" xml:space="preserve">
          <source>Receive a line of data from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">Reciba una l&amp;iacute;nea de datos de &lt;code&gt;socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45ba1787b19136d286049145b2a0b743a6c33a76" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;, address of datagram's sender will be stored into &lt;code&gt;saddr&lt;/code&gt; and &lt;code&gt;saddrLen&lt;/code&gt;. Returned future will complete once one datagram has been received, and will return size of packet received.</source>
          <target state="translated">Recibe los datos de un datagrama del &lt;code&gt;socket&lt;/code&gt; en &lt;code&gt;buf&lt;/code&gt; , que debe tener al menos el tama&amp;ntilde;o del &lt;code&gt;size&lt;/code&gt; , la direcci&amp;oacute;n del remitente del datagrama se almacenar&amp;aacute; en &lt;code&gt;saddr&lt;/code&gt; y &lt;code&gt;saddrLen&lt;/code&gt; . El futuro devuelto se completar&amp;aacute; una vez que se haya recibido un datagrama y devolver&amp;aacute; el tama&amp;ntilde;o del paquete recibido.</target>
        </trans-unit>
        <trans-unit id="08a1c7a9c8b11f0330e062d3a219827691a2ced9" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;data&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;. The address and port of datagram's sender will be stored into &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, respectively. Returned future will complete once one datagram has been received, and will return size of packet received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035642ed262c167867946bf47a15f8d3cd74423d" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;. Returned future will complete once one datagram has been received and will return tuple with: data of packet received; and address and port of datagram's sender.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cd4737c50ee8048cd8ba70ef02d69e328a1eaf" translate="yes" xml:space="preserve">
          <source>Receives a line of data from the socket connected to the SMTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e06d171d56b86b84dc6f8e208bc7ee0606c281" translate="yes" xml:space="preserve">
          <source>Receives a message from the channel &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc62c15428d535855ae8065d053fb9f3dae416a2" translate="yes" xml:space="preserve">
          <source>Receives data from &lt;code&gt;socket&lt;/code&gt;. This function should normally be used with connection-less sockets (UDP sockets).</source>
          <target state="translated">Recibe datos del &lt;code&gt;socket&lt;/code&gt; . Esta funci&amp;oacute;n deber&amp;iacute;a utilizarse normalmente con sockets sin conexi&amp;oacute;n (sockets UDP).</target>
        </trans-unit>
        <trans-unit id="fde44220b1eb77eb349f04d90b283dec9ec8fc18" translate="yes" xml:space="preserve">
          <source>Receives data from a socket.</source>
          <target state="translated">Recibe datos de un enchufe.</target>
        </trans-unit>
        <trans-unit id="38611008bdc8b293ba57958ff7e53cb4f0c593ef" translate="yes" xml:space="preserve">
          <source>Recursively clears all children of an XmlNode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cfde3be5404be7accf4a0a658b02ee7896180d" translate="yes" xml:space="preserve">
          <source>Recursively walks over the directory &lt;code&gt;dir&lt;/code&gt; and yields for each file or directory in &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a29f5764a54e8058c540d4730c0a945d240f1f8" translate="yes" xml:space="preserve">
          <source>Recursively walks over the directory &lt;em&gt;dir&lt;/em&gt; and yields for each file or directory in &lt;em&gt;dir&lt;/em&gt;. The full path for each file or directory is returned. &lt;strong&gt;Warning&lt;/strong&gt;: Modifying the directory structure while the iterator is traversing may result in undefined behavior!</source>
          <target state="translated">Camina de forma recursiva sobre el directorio &lt;em&gt;dir&lt;/em&gt; y rinde para cada archivo o directorio en &lt;em&gt;dir&lt;/em&gt; . Se devuelve la ruta completa de cada archivo o directorio. &lt;strong&gt;Advertencia&lt;/strong&gt; : &amp;iexcl;Modificar la estructura del directorio mientras el iterador est&amp;aacute; atravesando puede resultar en un comportamiento indefinido!</target>
        </trans-unit>
        <trans-unit id="fcf937319f333e7df4ec12406025be63bde6549b" translate="yes" xml:space="preserve">
          <source>Redirects</source>
          <target state="translated">Redirects</target>
        </trans-unit>
        <trans-unit id="c20bb0f7c4d78b01fa838319a2981e9b417f1f05" translate="yes" xml:space="preserve">
          <source>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</source>
          <target state="translated">Se permite la redistribución y el uso en forma de fuente y binaria,con o sin modificaciones,siempre que se cumplan las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="57ec4bae787e02e75ae9439f5fbfc851c887f70f" translate="yes" xml:space="preserve">
          <source>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</source>
          <target state="translated">Las redistribuciones en forma binaria deben reproducir el anterior aviso de derechos de autor,esta lista de condiciones y el siguiente descargo de responsabilidad en la documentación y/u otros materiales proporcionados con la distribución.</target>
        </trans-unit>
        <trans-unit id="b7338b5245c44e48d0d288fd4ec6f22445873f8e" translate="yes" xml:space="preserve">
          <source>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</source>
          <target state="translated">Las redistribuciones de código fuente deben conservar el anterior aviso de copyright,esta lista de condiciones y el siguiente descargo de responsabilidad.</target>
        </trans-unit>
        <trans-unit id="ded5e6e7aa2ed376f64f1a24730ee173d5155d3a" translate="yes" xml:space="preserve">
          <source>Reduce rational &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a93873a7ac8bb5a91e249745de2599e8d65fd26" translate="yes" xml:space="preserve">
          <source>Reduce rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Reducir la &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="7693e4045bbbda8ba2d5c3ae273859b958bb1b40" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;a&lt;/code&gt; by &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259516f23573e881a917050af2115d65af6da166" translate="yes" xml:space="preserve">
          <source>Ref objects should be used whenever inheritance is used. It isn't strictly necessary, but with non-ref objects assignments such as &lt;code&gt;let person: Person = Student(id: 123)&lt;/code&gt; will truncate subclass fields.</source>
          <target state="translated">Los objetos de referencia deben usarse siempre que se use la herencia. No es estrictamente necesario, pero con asignaciones de objetos que no son de referencia como &lt;code&gt;let person: Person = Student(id: 123)&lt;/code&gt; truncar&amp;aacute;n los campos de subclase.</target>
        </trans-unit>
        <trans-unit id="6e957d91a2e6412d9c92ab3070be12e1aa4ce4ab" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#CountTable&quot;&gt;CountTable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1e817109e090abbcfa757ded0f90d1a5753425" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#OrderedTable&quot;&gt;OrderedTable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4ec7a15678a29e4afdf3478e19f787f13e2172" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#Table&quot;&gt;Table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87798bcee18d1436b909618b352c96cf831e7971" translate="yes" xml:space="preserve">
          <source>RefC</source>
          <target state="translated">RefC</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5af3748c63858d0b4874cf01bae4e3756fad9124" translate="yes" xml:space="preserve">
          <source>Reference Cycles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960faca00a2ea60fd367da06c6a9cf388e7dc545" translate="yes" xml:space="preserve">
          <source>Reference and pointer types</source>
          <target state="translated">Tipos de referencia y puntero</target>
        </trans-unit>
        <trans-unit id="5ac8f6bcbc2bb32b6f7eada152e718040b0ff894" translate="yes" xml:space="preserve">
          <source>Reference to &lt;code&gt;RootObj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170afdf8e2efc163d33d771c752badc8b632f258" translate="yes" xml:space="preserve">
          <source>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory (also called &lt;span id=&quot;aliasing_1&quot;&gt;aliasing&lt;/span&gt;).</source>
          <target state="translated">Las referencias (similares a los punteros en otros lenguajes de programaci&amp;oacute;n) son una forma de introducir relaciones de muchos a uno. Esto significa que diferentes referencias pueden se&amp;ntilde;alar y modificar la misma ubicaci&amp;oacute;n en la memoria (tambi&amp;eacute;n llamado &lt;span id=&quot;aliasing_1&quot;&gt;aliasing&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="02069e24e1a9efdb72de58330148c041dfc9b7b2" translate="yes" xml:space="preserve">
          <source>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory.</source>
          <target state="translated">Las referencias (similares a los punteros en otros lenguajes de programación)son una forma de introducir las relaciones de muchos a uno.Esto significa que diferentes referencias pueden señalar y modificar la misma ubicación en la memoria.</target>
        </trans-unit>
        <trans-unit id="21261db724edbd03f7602d59e2bb7a253492652e" translate="yes" xml:space="preserve">
          <source>Regarding binary comparison, this module only provides unequal operators. The equality operator &lt;code&gt;==&lt;/code&gt; is omitted, because depending on the use case either casting to float or rounding to int might be preferred, and users should make an explicit choice.</source>
          <target state="translated">En cuanto a la comparaci&amp;oacute;n binaria, este m&amp;oacute;dulo solo proporciona operadores desiguales. El operador de igualdad &lt;code&gt;==&lt;/code&gt; se omite porque, seg&amp;uacute;n el caso de uso, se puede preferir la conversi&amp;oacute;n a flotante o el redondeo a int, y los usuarios deben hacer una elecci&amp;oacute;n expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="e68ebd1d4ba803b29c2b4073e01cb0c6ecc77d97" translate="yes" xml:space="preserve">
          <source>Registers 'foreignPackageName' to the internal list of foreign deps. It is your job to ensure the package name</source>
          <target state="translated">Registra &quot;ForeignPackageName&quot; en la lista interna de deps.extranjeros.Es tu trabajo asegurarte de que el nombre del paquete</target>
        </trans-unit>
        <trans-unit id="dba53deed8138d1e437d395564bccc72d2fe91e1" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;fd&lt;/code&gt; with the dispatcher.</source>
          <target state="translated">Registra &lt;code&gt;fd&lt;/code&gt; con el despachador.</target>
        </trans-unit>
        <trans-unit id="bb5bd595db3b7cfbb12cdce72914e82c34cdf5db" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;ftp&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Registra &lt;code&gt;ftp&lt;/code&gt; con el despachador &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbabe5b470b654e5897fc52c60eed8e57b18f5cc" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;s&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Registros &lt;code&gt;s&lt;/code&gt; con despachador &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ac05ff3f5dcfa293b9d59ad4d7bb0664b1aef3f" translate="yes" xml:space="preserve">
          <source>Registers Unix signal notification with &lt;code&gt;signal&lt;/code&gt; to selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Registra la notificaci&amp;oacute;n de se&amp;ntilde;al Unix con &lt;code&gt;signal&lt;/code&gt; al selector &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="800f133d28b9b2c3e359d4dbbeb9ddbccf642485" translate="yes" xml:space="preserve">
          <source>Registers a &lt;em&gt;thread local&lt;/em&gt; handler that is called at the thread's destruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac28cb53181efd36c017064827507024c32b8745" translate="yes" xml:space="preserve">
          <source>Registers a &lt;em&gt;thread local&lt;/em&gt; handler that is called at the thread's destruction. A thread is destructed when the &lt;code&gt;.thread&lt;/code&gt; proc returns normally or when it raises an exception. Note that unhandled exceptions in a thread nevertheless cause the whole process to die.</source>
          <target state="translated">Registra un controlador &lt;em&gt;local de subprocesos al&lt;/em&gt; que se llama cuando se destruye el subproceso. Un hilo se destruye cuando &lt;code&gt;.thread&lt;/code&gt; proc regresa normalmente o cuando genera una excepci&amp;oacute;n. Tenga en cuenta que, sin embargo, las excepciones no controladas en un hilo hacen que todo el proceso falle.</target>
        </trans-unit>
        <trans-unit id="3deac7496ef34d80158290e83f7f14ef92d45c58" translate="yes" xml:space="preserve">
          <source>Registers a foreign command to the intern list of commands that can be queried later.</source>
          <target state="translated">Registra un comando extranjero a la lista interna de comandos que pueden ser consultados más tarde.</target>
        </trans-unit>
        <trans-unit id="f6b6982c4f6e50fc17a208315b2726e3bf92e0ac" translate="yes" xml:space="preserve">
          <source>Registers a process id (pid) notification (when process has exited) in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Registra una notificaci&amp;oacute;n de identificaci&amp;oacute;n de proceso (pid) (cuando el proceso ha salido) en el selector &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e6ab3c2650ac19e734751307d1c267db478032" translate="yes" xml:space="preserve">
          <source>Registers async socket &lt;code&gt;sock&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Registra el &lt;code&gt;sock&lt;/code&gt; socket as&amp;iacute;ncrono con el despachador &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d5e51b21a074f3910595269ee7ab90c19c97cbb" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when &lt;code&gt;ev&lt;/code&gt; will be signaled</source>
          <target state="translated">Registros de devoluci&amp;oacute;n de llamada &lt;code&gt;cb&lt;/code&gt; que se llamar&amp;aacute; cuando &lt;code&gt;ev&lt;/code&gt; se se&amp;ntilde;alizar&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="31450955f986e0842dc1c13efe0a244827237e9d" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when process with process ID &lt;code&gt;pid&lt;/code&gt; exited.</source>
          <target state="translated">Registra callback &lt;code&gt;cb&lt;/code&gt; para ser llamado cuando el proceso con ID de proceso &lt;code&gt;pid&lt;/code&gt; sale.</target>
        </trans-unit>
        <trans-unit id="e6471db9bd2a705c0ad2173f10920c7b023bff08" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when timer expired.</source>
          <target state="translated">Registra &lt;code&gt;cb&lt;/code&gt; de devoluci&amp;oacute;n de llamada que se llamar&amp;aacute; cuando expire el temporizador.</target>
        </trans-unit>
        <trans-unit id="337e6b2b0028085b3fcc713332555d1608d2e3ce" translate="yes" xml:space="preserve">
          <source>Registers delegate &lt;code&gt;deleg&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Registros delegan &lt;code&gt;deleg&lt;/code&gt; con despachador &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0836d5ff61abf1d138e16122f0ec0c79c61d80e8" translate="yes" xml:space="preserve">
          <source>Registers file/socket descriptor &lt;code&gt;fd&lt;/code&gt; to selector &lt;code&gt;s&lt;/code&gt; with events set in &lt;code&gt;events&lt;/code&gt;. The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when an event is triggered.</source>
          <target state="translated">Registra el descriptor de archivo / socket &lt;code&gt;fd&lt;/code&gt; en el selector &lt;code&gt;s&lt;/code&gt; con eventos establecidos en &lt;code&gt;events&lt;/code&gt; . Los &lt;code&gt;data&lt;/code&gt; son datos definidos por la aplicaci&amp;oacute;n, que se pasar&amp;aacute;n cuando se active un evento.</target>
        </trans-unit>
        <trans-unit id="43e16ff873d5de584458f76ad72d9537d10683d7" translate="yes" xml:space="preserve">
          <source>Registers selector BSD/MacOSX specific vnode events for file descriptor &lt;code&gt;fd&lt;/code&gt; and events &lt;code&gt;events&lt;/code&gt;. &lt;code&gt;data&lt;/code&gt; application-defined data, which to be passed, when vnode event happens.</source>
          <target state="translated">Registra eventos de vnode espec&amp;iacute;ficos de BSD / MacOSX del selector para el descriptor de archivo &lt;code&gt;fd&lt;/code&gt; y eventos de &lt;code&gt;events&lt;/code&gt; . &lt;code&gt;data&lt;/code&gt; datos definidos por la aplicaci&amp;oacute;n, que se pasar&amp;aacute;n, cuando ocurra el evento vnode.</target>
        </trans-unit>
        <trans-unit id="2199311ef193878f7d6db4d7b746d800cbc0159f" translate="yes" xml:space="preserve">
          <source>Registers selector event &lt;code&gt;ev&lt;/code&gt; in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Registra el evento &lt;code&gt;ev&lt;/code&gt; del selector en el selector &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b636a5c4fface43e127ecfee78ea1a0d490a11bb" translate="yes" xml:space="preserve">
          <source>Registers timer notification with &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) to selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Registra la notificaci&amp;oacute;n del temporizador con &lt;code&gt;timeout&lt;/code&gt; (en milisegundos) al selector &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="136039c2b54f04914b3cfa5a13100aef989f0ca7" translate="yes" xml:space="preserve">
          <source>Regular expression support for Nim.</source>
          <target state="translated">Apoyo a la expresión regular de Nim.</target>
        </trans-unit>
        <trans-unit id="dc6d5a0c3dd27227e0ade1d680a1afafeb5cd176" translate="yes" xml:space="preserve">
          <source>Regular expression syntax and semantics</source>
          <target state="translated">Sintaxis y semántica de la expresión regular</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">Expresiones regulares</target>
        </trans-unit>
        <trans-unit id="632284d6d44cd285a0879407d2b79c59fd92e9cc" translate="yes" xml:space="preserve">
          <source>Regular file.</source>
          <target state="translated">Un archivo normal.</target>
        </trans-unit>
        <trans-unit id="c73e7346189862b7e0f60858180cc71c17d6472c" translate="yes" xml:space="preserve">
          <source>Related Options</source>
          <target state="translated">Opciones relacionadas</target>
        </trans-unit>
        <trans-unit id="c87655c3652d2c8b712e2ae3b2ceb5122f8a4e27" translate="yes" xml:space="preserve">
          <source>Relative paths won't be expanded by this iterator. Instead, it will traverse only the directories appearing in the relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eeef2cf95f50c40792682050928f40e5526ea33" translate="yes" xml:space="preserve">
          <source>Relative paths won't be expanded by this proc. Instead, it will traverse only the directories appearing in the relative path.</source>
          <target state="translated">Los caminos relativos no se ampliarán con este procedimiento.En su lugar,sólo atravesará los directorios que aparecen en el camino relativo.</target>
        </trans-unit>
        <trans-unit id="682eef8fa79929553cfba1c728611c096b679fb2" translate="yes" xml:space="preserve">
          <source>RelativeDir:</source>
          <target state="translated">RelativeDir:</target>
        </trans-unit>
        <trans-unit id="b960d2de95c213b0c091babc3388bfd26b6a65b1" translate="yes" xml:space="preserve">
          <source>RelativeFile:</source>
          <target state="translated">RelativeFile:</target>
        </trans-unit>
        <trans-unit id="7bbbb9e16a836cdff3a094ab77249ddd20e70760" translate="yes" xml:space="preserve">
          <source>Releases the given lock.</source>
          <target state="translated">Libera el bloqueo dado.</target>
        </trans-unit>
        <trans-unit id="154465987117610232e8996850d08335b4100707" translate="yes" xml:space="preserve">
          <source>Remove &lt;em&gt;fromFirst&lt;/em&gt; elements from the front of the deque and &lt;em&gt;fromLast&lt;/em&gt; elements from the back. If the supplied number of elements exceeds the total number of elements in the deque, the deque will remain empty.</source>
          <target state="translated">Quite los &lt;em&gt;primeros&lt;/em&gt; elementos de la parte frontal de la &lt;em&gt;placa&lt;/em&gt; y los &lt;em&gt;&amp;uacute;ltimos&lt;/em&gt; elementos de la parte posterior. Si el n&amp;uacute;mero de elementos suministrado excede el n&amp;uacute;mero total de elementos en el deque, el deque permanecer&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
