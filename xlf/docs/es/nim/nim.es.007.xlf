<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="1e8e7ed4df7e1d79df73533103355f606bd486f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allowRemap&lt;/code&gt; only needs to be true if you want to call &lt;code&gt;mapMem&lt;/code&gt; on the resulting MemFile; else file handles are not kept open.</source>
          <target state="translated">&lt;code&gt;allowRemap&lt;/code&gt; solo debe ser verdadero si desea llamar a &lt;code&gt;mapMem&lt;/code&gt; en el MemFile resultante; de lo contrario, los identificadores de archivos no se mantienen abiertos.</target>
        </trans-unit>
        <trans-unit id="51fff43aca9a3f3d76b1af35103a5af6f22e4951" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asyncdispatch&lt;/code&gt; module (event loop)</source>
          <target state="translated">&lt;code&gt;asyncdispatch&lt;/code&gt; m&amp;oacute;dulo asyncdispatch (bucle de eventos)</target>
        </trans-unit>
        <trans-unit id="8fee4462a1fc6f7ca065434924f5269dc4e549ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asyncnet&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;asyncnet&lt;/code&gt; m&amp;oacute;dulo asyncnet</target>
        </trans-unit>
        <trans-unit id="498123f82aff644359d1fd4cd6bfb34e823defde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b[11..^2]&lt;/code&gt; is the portion &quot;useless&quot;, and &lt;code&gt;b[11..^2] = &quot;useful&quot;&lt;/code&gt; replaces the &quot;useless&quot; portion with &quot;useful&quot;, giving the result &quot;Slices are useful.&quot;</source>
          <target state="translated">&lt;code&gt;b[11..^2]&lt;/code&gt; es la parte &quot;in&amp;uacute;til&quot;, y &lt;code&gt;b[11..^2] = &quot;useful&quot;&lt;/code&gt; reemplaza la parte &quot;in&amp;uacute;til&quot; por &quot;&amp;uacute;til&quot;, dando el resultado &quot;Las rebanadas son &amp;uacute;tiles&quot;.</target>
        </trans-unit>
        <trans-unit id="d2ea31cf1c26dd26b1244e5ffea23471a18ded80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast[T](x)&lt;/code&gt; in JavaScript is translated to &lt;code&gt;(x)&lt;/code&gt;, except for casting between signed/unsigned ints, in which case it behaves as static cast in C language.</source>
          <target state="translated">&lt;code&gt;cast[T](x)&lt;/code&gt; en JavaScript se traduce a &lt;code&gt;(x)&lt;/code&gt; , excepto para la conversi&amp;oacute;n entre entradas firmadas / sin firmar, en cuyo caso se comporta como una conversi&amp;oacute;n est&amp;aacute;tica en lenguaje C.</target>
        </trans-unit>
        <trans-unit id="78e583a6ca5943602d2fea749731670fb16ec519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const NimVersion = &quot;0.0.0&quot;&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#NimVersion&quot;&gt;#NimVersion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;const NimVersion = &quot;0.0.0&quot;&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#NimVersion&quot;&gt;#NimVersion&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61889a3978487883ade1aa88a933aede33e10d71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cstring&lt;/code&gt; in JavaScript means JavaScript string. It is a good practice to use &lt;code&gt;cstring&lt;/code&gt; only when it is semantically appropriate. E.g. don't use &lt;code&gt;cstring&lt;/code&gt; as a binary data buffer.</source>
          <target state="translated">&lt;code&gt;cstring&lt;/code&gt; en JavaScript significa cadena de JavaScript. Es una buena pr&amp;aacute;ctica usar &lt;code&gt;cstring&lt;/code&gt; solo cuando sea sem&amp;aacute;nticamente apropiado. Por ejemplo, no utilice &lt;code&gt;cstring&lt;/code&gt; como b&amp;uacute;fer de datos binarios.</target>
        </trans-unit>
        <trans-unit id="ac407e594720119511a2dff99e2c8cb540795818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; is written after the parentheses enclosing the regular proc params. The proc expression represented by the do block is appended to them. In calls using the command syntax, the do block will bind to the immediately preceeding expression, transforming it in a call.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; est&amp;aacute; escrito despu&amp;eacute;s de los par&amp;eacute;ntesis que encierran los par&amp;aacute;metros de proc regulares. Se les a&amp;ntilde;ade la expresi&amp;oacute;n proc representada por el bloque do. En las llamadas que utilizan la sintaxis del comando, el bloque do se vincular&amp;aacute; a la expresi&amp;oacute;n inmediatamente anterior, transform&amp;aacute;ndola en una llamada.</target>
        </trans-unit>
        <trans-unit id="560a65c3942b87610678dbe71906d997387954ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; with parentheses is an anonymous &lt;code&gt;proc&lt;/code&gt;; however a &lt;code&gt;do&lt;/code&gt; without parentheses is just a block of code. The &lt;code&gt;do&lt;/code&gt; notation can be used to pass multiple blocks to a macro:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; con par&amp;eacute;ntesis es un an&amp;oacute;nimo &lt;code&gt;proc&lt;/code&gt; ; sin embargo, &lt;code&gt;do&lt;/code&gt; sin par&amp;eacute;ntesis es solo un bloque de c&amp;oacute;digo. La notaci&amp;oacute;n &lt;code&gt;do&lt;/code&gt; se puede utilizar para pasar varios bloques a una macro:</target>
        </trans-unit>
        <trans-unit id="f8bfd3653988749a0a70c5e576012e23dd595dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must be &lt;code&gt;gcsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; debe ser &lt;code&gt;gcsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d47873c2e8cae488fed6cb4e83f288d75cc0a265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must not have the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; no debe tener el &lt;code&gt;closure&lt;/code&gt; convenci&amp;oacute;n de llamadas .</target>
        </trans-unit>
        <trans-unit id="0fc4e09f9db81a165920ce36aaee0a3d848f2fbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;'s parameters may not be of type &lt;code&gt;var&lt;/code&gt;. This means one has to use raw &lt;code&gt;ptr&lt;/code&gt;'s for data passing reminding the programmer to be careful.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; Los par&amp;aacute;metros de f pueden no ser de tipo &lt;code&gt;var&lt;/code&gt; . Esto significa que uno tiene que usar &lt;code&gt;ptr&lt;/code&gt; sin procesar para el paso de datos, recordando al programador que tenga cuidado.</target>
        </trans-unit>
        <trans-unit id="a0a3e940e2d69b10dcd7b011d95e7e271faec390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findFile&lt;/code&gt; is a proc used by the rst &lt;code&gt;include&lt;/code&gt; directive among others. The purpose of this proc is to mangle or filter paths. It receives paths specified in the rst document and has to return a valid path to existing files or the empty string otherwise. If you pass &lt;code&gt;nil&lt;/code&gt;, a default proc will be used which given a path returns the input path only if the file exists. One use for this proc is to transform relative paths found in the document to absolute path, useful if the rst file and the resources it references are not in the same directory as the current working directory.</source>
          <target state="translated">&lt;code&gt;findFile&lt;/code&gt; es un proceso utilizado por la primera directiva &lt;code&gt;include&lt;/code&gt; , entre otras. El prop&amp;oacute;sito de este proceso es alterar o filtrar rutas. Recibe rutas especificadas en el primer documento y tiene que devolver una ruta v&amp;aacute;lida a archivos existentes o la cadena vac&amp;iacute;a en caso contrario. Si pasa &lt;code&gt;nil&lt;/code&gt; , se utilizar&amp;aacute; un proceso predeterminado que, dada una ruta, devuelve la ruta de entrada solo si el archivo existe. Un uso de este proceso es transformar las rutas relativas que se encuentran en el documento en una ruta absoluta, &amp;uacute;til si el primer archivo y los recursos a los que hace referencia no est&amp;aacute;n en el mismo directorio que el directorio de trabajo actual.</target>
        </trans-unit>
        <trans-unit id="8300161461027b1d236fc8fcb5051bea30977ff2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fmt&lt;/code&gt; vs. &lt;code&gt;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; vs. &lt;code&gt;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7037da41cd9a367dd5a1197389e84235b7fd299" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; is syntactic sugar for a proc with no side effects:</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; es az&amp;uacute;car sint&amp;aacute;ctico para un proc sin efectos secundarios:</target>
        </trans-unit>
        <trans-unit id="924aa797cc590677bd14ef7705744856d8172a99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getTime&lt;/code&gt; should generally be prefered over this proc.</source>
          <target state="translated">&lt;code&gt;getTime&lt;/code&gt; lo general, se debe preferir getTime a este proceso.</target>
        </trans-unit>
        <trans-unit id="d638e902f126f0c7aa4a0463f14fc91aa6e101cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gettimeofday&lt;/code&gt; on Posix systems.</source>
          <target state="translated">&lt;code&gt;gettimeofday&lt;/code&gt; en sistemas Posix.</target>
        </trans-unit>
        <trans-unit id="d5b46867399a3ebc590baf66c27020db2279084c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hash(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash(myBuf, 0, myBuf.high)&lt;/code&gt; es equivalente a &lt;code&gt;hash(myBuf)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45dddddd2bbfedd088d7b3c125dbef25e0d38ba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash(myStr, 0, myStr.high)&lt;/code&gt; is equivalent to &lt;code&gt;hash(myStr)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash(myStr, 0, myStr.high)&lt;/code&gt; es equivalente a &lt;code&gt;hash(myStr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d09d0789db01f5a9c05f92add326a6c6418fad63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashIgnoreCase(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hashIgnoreCase(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hashIgnoreCase(myBuf, 0, myBuf.high)&lt;/code&gt; es equivalente a &lt;code&gt;hashIgnoreCase(myBuf)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="539893790133747c72f0c3d326648e951cd62455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashIgnoreStyle(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hashIgnoreStyle(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hashIgnoreStyle(myBuf, 0, myBuf.high)&lt;/code&gt; es equivalente a &lt;code&gt;hashIgnoreStyle(myBuf)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6dad588628bbfdda78e877da81dc4063efbca4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpMethod&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;httpMethod&lt;/code&gt; par&amp;aacute;metro httpMethod .</target>
        </trans-unit>
        <trans-unit id="446c4e7001b764a870cc632382c962e1c7846115" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&lt;/code&gt; is used to create a value type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; se utiliza para crear un tipo de valor &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bac1f760d92cd7667c1edcfeeb152b5ca3e42fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int8&lt;/code&gt;-&lt;code&gt;int16&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int8&lt;/code&gt;-&lt;code&gt;int16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f4bbdf85817b62fc87718830d3fcc8142efb089" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;items&lt;/code&gt; and &lt;code&gt;mitems&lt;/code&gt;, which provides immutable and mutable elements respectively, and</source>
          <target state="translated">&lt;code&gt;items&lt;/code&gt; y &lt;code&gt;mitems&lt;/code&gt; , que proporciona elementos inmutables y mutables respectivamente, y</target>
        </trans-unit>
        <trans-unit id="d080c7c8dc2ed97f395585da2bba25e2810e6a4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {.inline.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;#pairs.i,seq[T]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {.inline.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;# pares.i, seq [T]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db0b9a7913713991512790ae51161be2f487b7b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; - the current key, if it exists, or the key passed to &lt;code&gt;withKey&lt;/code&gt; otherwise;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; : la clave actual, si existe, o la clave pasada a &lt;code&gt;withKey&lt;/code&gt; en caso contrario;</target>
        </trans-unit>
        <trans-unit id="137d632b8d1a56e511b10636ac245a0a4100b468" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;koch temp&lt;/code&gt; creates a debug build of the compiler, which is useful to create stacktraces for compiler debugging.</source>
          <target state="translated">&lt;code&gt;koch temp&lt;/code&gt; crea una compilaci&amp;oacute;n de depuraci&amp;oacute;n del compilador, que es &amp;uacute;til para crear trazas de pila para la depuraci&amp;oacute;n del compilador.</target>
        </trans-unit>
        <trans-unit id="b79b05bec9bfe83a19a391ff0202f6c5f735d0bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;koch temp&lt;/code&gt; returns 125 as the exit code in case the compiler compilation fails. This exit code tells &lt;code&gt;git bisect&lt;/code&gt; to skip the current commit.:</source>
          <target state="translated">&lt;code&gt;koch temp&lt;/code&gt; devuelve 125 como c&amp;oacute;digo de salida en caso de que falle la compilaci&amp;oacute;n del compilador. Este c&amp;oacute;digo de salida le dice a &lt;code&gt;git bisect&lt;/code&gt; que omita la confirmaci&amp;oacute;n actual:</target>
        </trans-unit>
        <trans-unit id="1e569b2cd12fd789d91b613969201b1b396b9248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mach_absolute_time&lt;/code&gt; on Mac OS X.</source>
          <target state="translated">&lt;code&gt;mach_absolute_time&lt;/code&gt; en Mac OS X.</target>
        </trans-unit>
        <trans-unit id="7edfc1fd9a182aafc615613438430cf9ea485a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mappedSize&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; can be used to map only a slice of the file.</source>
          <target state="translated">&lt;code&gt;mappedSize&lt;/code&gt; y &lt;code&gt;offset&lt;/code&gt; se pueden usar para mapear solo una porci&amp;oacute;n del archivo.</target>
        </trans-unit>
        <trans-unit id="aa96a3fe1f430f3bd1fcff24de7ff608b318637e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mappedSize&lt;/code&gt; of &lt;code&gt;-1&lt;/code&gt; maps to the whole file, and &lt;code&gt;offset&lt;/code&gt; must be multiples of the PAGE SIZE of your OS</source>
          <target state="translated">&lt;code&gt;mappedSize&lt;/code&gt; de &lt;code&gt;-1&lt;/code&gt; se asigna a todo el archivo, y el &lt;code&gt;offset&lt;/code&gt; debe ser m&amp;uacute;ltiplo del TAMA&amp;Ntilde;O DE P&amp;Aacute;GINA de su sistema operativo</target>
        </trans-unit>
        <trans-unit id="7df7743ccba4158e36f639a44a77c1c52f23d01c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match&lt;/code&gt; macros are subject to overload resolution. First the &lt;code&gt;case&lt;/code&gt;'s selector expression is used to determine which &lt;code&gt;match&lt;/code&gt; macro to call. To this macro is then passed the complete &lt;code&gt;case&lt;/code&gt; statement body and the macro is evaluated.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; macros de coincidencias est&amp;aacute;n sujetas a una resoluci&amp;oacute;n de sobrecarga. Primero, la expresi&amp;oacute;n del selector de &lt;code&gt;case&lt;/code&gt; se usa para determinar qu&amp;eacute; macro de &lt;code&gt;match&lt;/code&gt; llamar. A esta macro se le pasa el cuerpo completo de la declaraci&amp;oacute;n del &lt;code&gt;case&lt;/code&gt; y se eval&amp;uacute;a la macro.</target>
        </trans-unit>
        <trans-unit id="33681e35af54b0be5e86cbe9c5c3384c078bfb89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxRedirects&lt;/code&gt; specifies the maximum amount of redirects to follow, default is 5.</source>
          <target state="translated">&lt;code&gt;maxRedirects&lt;/code&gt; especifica la cantidad m&amp;aacute;xima de redirecciones a seguir, el valor predeterminado es 5.</target>
        </trans-unit>
        <trans-unit id="a63e991a055d70ba87b68410a67988fbb7f80b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is used to create a reference type &lt;code&gt;P&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; se utiliza para crear un tipo de referencia &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a602be3b30c82cb1f34df2de16159935bf9ca5cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newFileSize&lt;/code&gt; can only be set if the file does not exist and is opened with write access (e.g., with fmReadWrite).</source>
          <target state="translated">&lt;code&gt;newFileSize&lt;/code&gt; solo se puede establecer si el archivo no existe y se abre con acceso de escritura (por ejemplo, con fmReadWrite).</target>
        </trans-unit>
        <trans-unit id="c33624742e3075a81ef915e9323ccf924f4d420e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nim dump&lt;/code&gt; shows the contents of the PATH.</source>
          <target state="translated">&lt;code&gt;nim dump&lt;/code&gt; muestra el contenido de la RUTA.</target>
        </trans-unit>
        <trans-unit id="1d05d87869603b415dc3e7648e8e314e881eaa16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nimvm&lt;/code&gt; is a special symbol, that may be used as expression of &lt;code&gt;when nimvm&lt;/code&gt; statement to differentiate execution path between runtime and compile time.</source>
          <target state="translated">&lt;code&gt;nimvm&lt;/code&gt; es un s&amp;iacute;mbolo especial, que se puede usar como expresi&amp;oacute;n de la declaraci&amp;oacute;n &lt;code&gt;when nimvm&lt;/code&gt; para diferenciar la ruta de ejecuci&amp;oacute;n entre tiempo de ejecuci&amp;oacute;n y tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e6d0deed51af5627d170be866f9c9b832e859b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkBracketExpr(nnkIdent(&quot;array&quot;),...&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;nnkBracketExpr(nnkIdent(&quot;array&quot;),...&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="eaef4608c727f153577ce8477a94c4a41016aa3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkIdentDefs&lt;/code&gt; need to have at least three children, but they can have more: first comes a list of identifiers followed by a type and value nodes. This helper proc creates a three node subtree, the first subnode being a single identifier name. Both the &lt;code&gt;kind&lt;/code&gt; node and &lt;code&gt;default&lt;/code&gt; (value) nodes may be empty depending on where the &lt;code&gt;nnkIdentDefs&lt;/code&gt; appears: tuple or object definitions will have an empty &lt;code&gt;default&lt;/code&gt; node, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt; blocks may have an empty &lt;code&gt;kind&lt;/code&gt; node if the identifier is being assigned a value. Example:</source>
          <target state="translated">&lt;code&gt;nnkIdentDefs&lt;/code&gt; necesita tener al menos tres hijos, pero pueden tener m&amp;aacute;s: primero viene una lista de identificadores seguida de un tipo y nodos de valor. Este proceso auxiliar crea un sub&amp;aacute;rbol de tres nodos, siendo el primer subnodo un nombre de identificador &amp;uacute;nico. Tanto el nodo &lt;code&gt;kind&lt;/code&gt; como el nodo &lt;code&gt;default&lt;/code&gt; (valor) pueden estar vac&amp;iacute;os dependiendo de d&amp;oacute;nde aparezca &lt;code&gt;nnkIdentDefs&lt;/code&gt; : las definiciones de tupla o de objeto tendr&amp;aacute;n un nodo &lt;code&gt;default&lt;/code&gt; vac&amp;iacute;o , los bloques &lt;code&gt;let&lt;/code&gt; o &lt;code&gt;var&lt;/code&gt; pueden tener un nodo &lt;code&gt;kind&lt;/code&gt; vac&amp;iacute;o si se le asigna un valor al identificador. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="23cb81755297bb91f875d58a64e51a11f3bb1bba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkTypeClassTy&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;nnkTypeClassTy&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="d979bfd7809af3f787da470102b84296dc43dee7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notin&lt;/code&gt; and &lt;code&gt;isnot&lt;/code&gt; have the obvious meanings.</source>
          <target state="translated">&lt;code&gt;notin&lt;/code&gt; y is &lt;code&gt;isnot&lt;/code&gt; tienen los significados obvios.</target>
        </trans-unit>
        <trans-unit id="b733da2df93ef65b306bd9461fe3ea6457795e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; must be multiples of the PAGE SIZE of your OS (usually 4K or 8K but is unique to your OS)</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; debe ser m&amp;uacute;ltiplos del TAMA&amp;Ntilde;O DE P&amp;Aacute;GINA de su sistema operativo (generalmente 4K u 8K, pero es exclusivo de su sistema operativo)</target>
        </trans-unit>
        <trans-unit id="8fb1b7b67c3dc439712f44d89e4d717f52f04357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairExists&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; if the key exists, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pairExists&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; si la clave existe, &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="0e50d29d3877d70186a81b4d6f92422034d6a8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;mpairs&lt;/code&gt; which provides the element and an index number (immutable and mutable respectively)</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; y &lt;code&gt;mpairs&lt;/code&gt; que proporciona el elemento y un n&amp;uacute;mero de &amp;iacute;ndice (inmutable y mutable respectivamente)</target>
        </trans-unit>
        <trans-unit id="46fd512967085e03b5725fc1b1c542ab6c02be40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc getTotalMem(): int {.rtl, raises: [], tags: [].}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#getTotalMem,&quot;&gt;#getTotalMem,&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;proc getTotalMem(): int {.rtl, raises: [], tags: [].}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#getTotalMem,&quot;&gt;#getTotalMem,&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="196f6343dc5b835d948b2f0d904b1e516670f218" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc len[T](x: seq[T]): int {.magic: &quot;LengthSeq&quot;, noSideEffect.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#len,seq%5BT%5D&quot;&gt;#len,seq[T]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;proc len[T](x: seq[T]): int {.magic: &quot;LengthSeq&quot;, noSideEffect.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#len,seq%5BT%5D&quot;&gt;# len, seq [T]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5660e0b3db81a363a41e94bcdc8ef2c68d94a1ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc&lt;/code&gt; types are currently always invariant, but future versions of Nim may relax this rule.</source>
          <target state="translated">&lt;code&gt;proc&lt;/code&gt; tipos proc son actualmente siempre invariantes, pero las versiones futuras de Nim pueden relajar esta regla.</target>
        </trans-unit>
        <trans-unit id="028210015ead3722db469fae99b22a73fd0cebdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy&lt;/code&gt; specifies an HTTP proxy to use for this HTTP client's connections.</source>
          <target state="translated">&lt;code&gt;proxy&lt;/code&gt; especifica un proxy HTTP que se utilizar&amp;aacute; para las conexiones de este cliente HTTP.</target>
        </trans-unit>
        <trans-unit id="4959eb23bdd78e53cb8af81bc9bb9ebcd2e0f5fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&quot;&quot;&quot;&quot;&lt;/code&gt; is not possible with this notation, because the three leading quotes introduce a triple quoted string literal. &lt;code&gt;r&quot;&quot;&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; since triple quoted string literals do not interpret escape sequences either.</source>
          <target state="translated">&lt;code&gt;r&quot;&quot;&quot;&quot;&lt;/code&gt; no es posible con esta notaci&amp;oacute;n, porque las tres comillas iniciales introducen un literal de cadena entre comillas triples. &lt;code&gt;r&quot;&quot;&quot;&lt;/code&gt; es lo mismo que &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ya que los literales de cadena entre comillas triples tampoco interpretan secuencias de escape.</target>
        </trans-unit>
        <trans-unit id="2b075aac17257f2359ad806b6183d04e910a5afb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; parameters are deeply copied which is a subtle semantic change and can cause performance problems but ensures memory safety. This deep copy is performed via &lt;code&gt;system.deepCopy&lt;/code&gt; and so can be overridden.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; par&amp;aacute;metros de referencia se copian en profundidad, lo que constituye un cambio sem&amp;aacute;ntico sutil y puede causar problemas de rendimiento, pero garantiza la seguridad de la memoria. Esta copia profunda se realiza a trav&amp;eacute;s de &lt;code&gt;system.deepCopy&lt;/code&gt; y, por lo tanto, puede anularse .</target>
        </trans-unit>
        <trans-unit id="35d9f8b60195dac2076797c209d92497e8a52809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; is allowed in a closure iterator (but rarely useful) and ends iteration.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; est&amp;aacute; permitido en un iterador de cierre (pero rara vez es &amp;uacute;til) y finaliza la iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c6eb664148a5a03959b583e8dd19730950f68b68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; without an expression is a short notation for &lt;code&gt;return result&lt;/code&gt; if the proc has a return type. The &lt;span id=&quot;result_1&quot;&gt;result&lt;/span&gt; variable is always the return value of the procedure. It is automatically declared by the compiler. As all variables, &lt;code&gt;result&lt;/code&gt; is initialized to (binary) zero:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; sin una expresi&amp;oacute;n es una notaci&amp;oacute;n corta para el &lt;code&gt;return result&lt;/code&gt; si el proc tiene un tipo de retorno. La variable de &lt;span id=&quot;result_1&quot;&gt;resultado&lt;/span&gt; es siempre el valor de retorno del procedimiento. El compilador lo declara autom&amp;aacute;ticamente. Como todas las variables, el &lt;code&gt;result&lt;/code&gt; ado se inicializa a cero (binario):</target>
        </trans-unit>
        <trans-unit id="113c74a3fd2826389685dc9b0cc688a75bb22a6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanf&lt;/code&gt; returns true if the input string &lt;strong&gt;starts with&lt;/strong&gt; the specified pattern. If instead it should only return true if there is also nothing left in the input, append &lt;code&gt;$.&lt;/code&gt; to your pattern.</source>
          <target state="translated">&lt;code&gt;scanf&lt;/code&gt; devuelve verdadero si la cadena de entrada &lt;strong&gt;comienza con&lt;/strong&gt; el patr&amp;oacute;n especificado. Si, en cambio, solo debe devolver verdadero si tampoco queda nada en la entrada, agregue &lt;code&gt;$.&lt;/code&gt; a tu patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b10ad8ca26a39b5bc50703ca1825380095c2b3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;selectors&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;selectors&lt;/code&gt; m&amp;oacute;dulo de selectores</target>
        </trans-unit>
        <trans-unit id="414b4c694a3b05d8c88e89f76d20d0406356c388" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; must be of exactly the size that was requested via &lt;code&gt;mapMem&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; debe ser exactamente del tama&amp;ntilde;o solicitado a trav&amp;eacute;s de &lt;code&gt;mapMem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7428fa040024da68196dbad3f187333725a9111f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn&lt;/code&gt; executes the passed expression on the thread pool and returns a &lt;span id=&quot;data-flow-variable_1&quot;&gt;data flow variable&lt;/span&gt;&lt;code&gt;FlowVar[T]&lt;/code&gt; that can be read from. The reading with the &lt;code&gt;^&lt;/code&gt; operator is &lt;strong&gt;blocking&lt;/strong&gt;. However, one can use &lt;code&gt;blockUntilAny&lt;/code&gt; to wait on multiple flow variables at the same time:</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; ejecuta la expresi&amp;oacute;n pasada en el grupo de subprocesos y devuelve una &lt;span id=&quot;data-flow-variable_1&quot;&gt;variable de flujo de datos &lt;/span&gt; &lt;code&gt;FlowVar[T]&lt;/code&gt; que se puede leer. La lectura con el operador &lt;code&gt;^&lt;/code&gt; se &lt;strong&gt;bloquea&lt;/strong&gt; . Sin embargo, se puede usar &lt;code&gt;blockUntilAny&lt;/code&gt; para esperar en m&amp;uacute;ltiples variables de flujo al mismo tiempo:</target>
        </trans-unit>
        <trans-unit id="d6a078341ec3b81c9830d57f0b0899663805e59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn&lt;/code&gt; within a &lt;code&gt;parallel&lt;/code&gt; section has special semantics.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; dentro de una secci&amp;oacute;n &lt;code&gt;parallel&lt;/code&gt; tiene una sem&amp;aacute;ntica especial.</target>
        </trans-unit>
        <trans-unit id="0a237f056e6830032577998fb90190fdcae2b2f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sslContext&lt;/code&gt; specifies the SSL context to use for HTTPS requests.</source>
          <target state="translated">&lt;code&gt;sslContext&lt;/code&gt; especifica el contexto SSL que se utilizar&amp;aacute; para las solicitudes HTTPS.</target>
        </trans-unit>
        <trans-unit id="14ce006a57832b51af0da0a7cc6741ef70d10283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stackTrace&lt;/code&gt; is provided only if the failure occurred due to an exception. &lt;code&gt;checkpoints&lt;/code&gt; is never &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stackTrace&lt;/code&gt; se proporciona solo si el error se produjo debido a una excepci&amp;oacute;n. &lt;code&gt;checkpoints&lt;/code&gt; nunca son &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb4fe14b57e46dc6a68b8b91ce1197bfba9b9fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; may be overriden, i.e. if &lt;code&gt;sock&lt;/code&gt; is not connected it should be adjusted properly. By default it will be assumed that the socket is connected. Please note this is only applicable to TCP client sockets, if &lt;code&gt;sock&lt;/code&gt; is a different type of socket &lt;code&gt;state&lt;/code&gt; needs to be adjusted!!!</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; puede anularse, es decir, si el &lt;code&gt;sock&lt;/code&gt; no est&amp;aacute; conectado, debe ajustarse correctamente. Por defecto, se asumir&amp;aacute; que el enchufe est&amp;aacute; conectado. Tenga en cuenta que esto solo es aplicable a los sockets de cliente TCP, si el &lt;code&gt;sock&lt;/code&gt; es un tipo diferente de &lt;code&gt;state&lt;/code&gt; del socket , debe ajustarse.</target>
        </trans-unit>
        <trans-unit id="e674b50eb18e2a7db0371aad81cb1f5762665b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template newException[](exceptn: type; message: string): expr&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#newException.t,type,string&quot;&gt;#newException.t,type,string&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;template newException[](exceptn: type; message: string): expr&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#newException.t,type,string&quot;&gt;# newException.t, type, string&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bb140ccbc87a6b939e9e3439c2e3cc8632b83d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - timeout value in milliseconds.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; : valor de tiempo de espera en milisegundos.</target>
        </trans-unit>
        <trans-unit id="96b9adea7cc07edd40eb34f2988f6e65b0f32008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is specified in milliseconds and &lt;code&gt;-1&lt;/code&gt; can be specified for an unlimited time.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; se especifica en milisegundos y &lt;code&gt;-1&lt;/code&gt; se puede especificar por un tiempo ilimitado.</target>
        </trans-unit>
        <trans-unit id="bd67e5934c954c7a83cd4b013bf93f8697e48fe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is specified in milliseconds and &lt;code&gt;-1&lt;/code&gt; can be specified for an unlimited time. &lt;strong&gt;Warning:&lt;/strong&gt; This is deprecated since version 0.16.2. Use the &lt;code&gt;selectRead&lt;/code&gt; procedure instead.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; se especifica en milisegundos y &lt;code&gt;-1&lt;/code&gt; se puede especificar por un tiempo ilimitado. &lt;strong&gt;Advertencia:&lt;/strong&gt; est&amp;aacute; en desuso desde la versi&amp;oacute;n 0.16.2. En su lugar, utilice el procedimiento &lt;code&gt;selectRead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47d67af238e56b35260c7cf302090a09b5d4e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; specifies the number of milliseconds to allow before a &lt;code&gt;TimeoutError&lt;/code&gt; is raised.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; especifica el n&amp;uacute;mero de milisegundos a permitir antes de que se &lt;code&gt;TimeoutError&lt;/code&gt; un TimeoutError .</target>
        </trans-unit>
        <trans-unit id="0a3d983ab412f774a2d43a7773e59264a9986835" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type SignedInt = int | int8 | int16 | int32 | int64&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#SignedInt&quot;&gt;#SignedInt&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;type SignedInt = int | int8 | int16 | int32 | int64&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#SignedInt&quot;&gt;#SignedInt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36800177ee2b92e4b74725a1b76cc86e80ecbacc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; acts like a generic type. For instance, the type of the symbol &lt;code&gt;int&lt;/code&gt; is &lt;code&gt;type[int]&lt;/code&gt;. Just like with regular generic types, when the generic param is ommited, &lt;code&gt;type&lt;/code&gt; denotes the type class of all types. As a syntactic convenience, you can also use &lt;code&gt;type&lt;/code&gt; as a modifier. &lt;code&gt;type int&lt;/code&gt; is considered the same as &lt;code&gt;type[int]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; act&amp;uacute;a como un tipo gen&amp;eacute;rico. Por ejemplo, el tipo del s&amp;iacute;mbolo &lt;code&gt;int&lt;/code&gt; es &lt;code&gt;type[int]&lt;/code&gt; . Al igual que con los tipos gen&amp;eacute;ricos regulares, cuando se omite el par&amp;aacute;metro gen&amp;eacute;rico, &lt;code&gt;type&lt;/code&gt; denota la clase de tipo de todos los tipos. Como conveniencia sint&amp;aacute;ctica, tambi&amp;eacute;n puede usar el &lt;code&gt;type&lt;/code&gt; como modificador. &lt;code&gt;type int&lt;/code&gt; se considera igual que &lt;code&gt;type[int]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad64a4834d20179ee6e4e81e9e9cec9447164baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint8&lt;/code&gt;/&lt;code&gt;byte&lt;/code&gt;-&lt;code&gt;uint16&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uint8&lt;/code&gt;/&lt;code&gt;byte&lt;/code&gt;-&lt;code&gt;uint16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5524951be56e32fd2f7b7e27e9fb8dc263ca8215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;untyped&lt;/code&gt; and &lt;code&gt;varargs[untyped]&lt;/code&gt; are the only metatype that are lazy in this sense, the other metatypes &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; are not lazy.</source>
          <target state="translated">&lt;code&gt;untyped&lt;/code&gt; y &lt;code&gt;varargs[untyped]&lt;/code&gt; son la &amp;uacute;nica metatipo que son perezosos en este sentido, los otros metatipos &lt;code&gt;typed&lt;/code&gt; y &lt;code&gt;type&lt;/code&gt; no son perezosos.</target>
        </trans-unit>
        <trans-unit id="dd2e83eaaa4d30da3388fb06180b2d9cdc38b178" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userAgent&lt;/code&gt; specifies the user agent that will be used when making requests.</source>
          <target state="translated">&lt;code&gt;userAgent&lt;/code&gt; especifica el agente de usuario que se utilizar&amp;aacute; al realizar solicitudes.</target>
        </trans-unit>
        <trans-unit id="6e8057947b214078488d318b597d51c19c74bced" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; - the current value, if the key exists, or default value of the type otherwise;</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; : el valor actual, si la clave existe, o el valor predeterminado del tipo en caso contrario;</target>
        </trans-unit>
        <trans-unit id="70bd849b02a91f69a4faafb3130dd3312083ca7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var globalRaiseHook: proc (e: ref E_Base): bool {.nimcall.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#globalRaiseHook&quot;&gt;#globalRaiseHook&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;var globalRaiseHook: proc (e: ref E_Base): bool {.nimcall.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#globalRaiseHook&quot;&gt;#globalRaiseHook&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fa91fdb54c79794b9a602441c5470976dba8159" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;varargs[typed]&lt;/code&gt; is treated specially: It matches a variable list of arguments of arbitrary type but &lt;em&gt;always&lt;/em&gt; constructs an implicit array. This is required so that the builtin &lt;code&gt;echo&lt;/code&gt; proc does what is expected:</source>
          <target state="translated">&lt;code&gt;varargs[typed]&lt;/code&gt; se trata especialmente: coincide con una lista variable de argumentos de tipo arbitrario, pero &lt;em&gt;siempre&lt;/em&gt; construye una matriz impl&amp;iacute;cita. Esto es necesario para que el proceso de &lt;code&gt;echo&lt;/code&gt; incorporado haga lo que se espera:</target>
        </trans-unit>
        <trans-unit id="cfb3b8046a3ab81ffe6881ac3de26835854c0b13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when nimvm&lt;/code&gt; statement must meet the following requirements:</source>
          <target state="translated">&lt;code&gt;when nimvm&lt;/code&gt; declaraci&amp;oacute;n nimvm debe cumplir los siguientes requisitos:</target>
        </trans-unit>
        <trans-unit id="67ac27b54addce5df88f6ce1de6ac4b1806d80c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; in a closure iterator can not occur in a &lt;code&gt;try&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; en un iterador de cierre no puede ocurrir en una declaraci&amp;oacute;n &lt;code&gt;try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17d688332fc513102b8bb34b3b994661a671d9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zonedTimeFromTimeImpl&lt;/code&gt; and &lt;code&gt;zonedTimeFromAdjTimeImpl&lt;/code&gt; is used as the underlying implementations for &lt;code&gt;zonedTimeFromTime&lt;/code&gt; and &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;zonedTimeFromTimeImpl&lt;/code&gt; y &lt;code&gt;zonedTimeFromAdjTimeImpl&lt;/code&gt; se utilizan como implementaciones subyacentes para &lt;code&gt;zonedTimeFromTime&lt;/code&gt; y &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de7681dca8728ba640e9addf663d66eea92586e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%&lt;/em&gt; substitution operator for ropes. Does not support the &lt;code&gt;$identifier&lt;/code&gt; nor &lt;code&gt;${identifier}&lt;/code&gt; notations.</source>
          <target state="translated">&lt;em&gt;%&lt;/em&gt; operador de sustituci&amp;oacute;n de cuerdas. No admite las notaciones &lt;code&gt;$identifier&lt;/code&gt; ni &lt;code&gt;${identifier}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="703376a559c520d84ae5746f8f84e6453c7ecbf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated since version 0.18.1&lt;/em&gt;: No good usages of this feature are known.</source>
          <target state="translated">&lt;em&gt;En desuso desde la versi&amp;oacute;n 0.18.1&lt;/em&gt; : no se conocen buenos usos de esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a2e021efea2e75524a8b29d10b025f45cf8dcb6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Expressions&lt;/em&gt; are parts of a statement which usually result in a value. The condition in an if statement is an example for an expression. Expressions can contain indentation at certain places for better readability:</source>
          <target state="translated">&lt;em&gt;Las expresiones&lt;/em&gt; son partes de una declaraci&amp;oacute;n que generalmente dan como resultado un valor. La condici&amp;oacute;n en una instrucci&amp;oacute;n if es un ejemplo de expresi&amp;oacute;n. Las expresiones pueden contener sangr&amp;iacute;a en ciertos lugares para una mejor legibilidad:</target>
        </trans-unit>
        <trans-unit id="2e3cb0560107f66918fa3aedb67fc091d9d49443" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">&lt;em&gt;Ext se&lt;/em&gt; debe proporcionar sin el '.' Inicial, porque algunos sistemas de archivos pueden usar un car&amp;aacute;cter diferente. (Aunque no conozco ninguna bestia as&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="00e5801a705eb26208dbadfb059011bb00f52b91" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Runtime type information&lt;/em&gt; (RTTI) is needed for several aspects of the Nim programming language:</source>
          <target state="translated">&lt;em&gt;La informaci&amp;oacute;n de tipo de tiempo de ejecuci&amp;oacute;n&lt;/em&gt; (RTTI) es necesaria para varios aspectos del lenguaje de programaci&amp;oacute;n Nim:</target>
        </trans-unit>
        <trans-unit id="17f8a43b2c8fe38ae5080e22a567a4a144d535c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;arrow like operator&lt;/em&gt; (like &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;=&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;flecha como operador&lt;/em&gt; (como &lt;code&gt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;=&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cd27f1fe3eae5b9a898f8a1ee22d88a9fa597511" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;assignment operator&lt;/em&gt; (like &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;operador de asignaci&amp;oacute;n&lt;/em&gt; (como &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f7455f98c99e60e6bbeb9b3baae8878c758ba3c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmp&lt;/em&gt; is the comparator function to use, the expected return values are the same as that of system.cmp.</source>
          <target state="translated">&lt;em&gt;cmp&lt;/em&gt; es la funci&amp;oacute;n de comparaci&amp;oacute;n a utilizar, los valores de retorno esperados son los mismos que los de system.cmp.</target>
        </trans-unit>
        <trans-unit id="d07d1bc0c8a2aa1948c3ee05610a44eaacab87f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;decimalSep&lt;/em&gt; is used as the decimal separator.</source>
          <target state="translated">&lt;em&gt;decimalSep&lt;/em&gt; se utiliza como separador decimal.</target>
        </trans-unit>
        <trans-unit id="92cefe4d7882c47f6678d2ec5886a3672b587367" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;empty string&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cuerda vac&amp;iacute;a&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8f65828700fd66a8e7a7fd5be187238ed98013b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;escape&lt;/em&gt;: removes any special meaning from the following character; '0' disables escaping; if escaping is disabled and &lt;em&gt;quote&lt;/em&gt; is not '0', two &lt;em&gt;quote&lt;/em&gt; characters are parsed one literal &lt;em&gt;quote&lt;/em&gt; character.</source>
          <target state="translated">&lt;em&gt;escape&lt;/em&gt; : elimina cualquier significado especial del siguiente car&amp;aacute;cter; '0' desactiva el escape; si el escape est&amp;aacute; deshabilitado y la &lt;em&gt;cita&lt;/em&gt; no es '0', dos caracteres de &lt;em&gt;comillas&lt;/em&gt; se analizan como un car&amp;aacute;cter de &lt;em&gt;comillas&lt;/em&gt; literal .</target>
        </trans-unit>
        <trans-unit id="db614d277a70f95c2f6d4d36c543390ce136c5ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;false&lt;/em&gt; - generate timeout events periodically</source>
          <target state="translated">&lt;em&gt;falso&lt;/em&gt; : genera eventos de tiempo de espera peri&amp;oacute;dicamente</target>
        </trans-unit>
        <trans-unit id="8e307a213a9d0cd9087e4fab61d048d2e75d42ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;i&lt;/em&gt; should be in the range &lt;em&gt;1..paramCount()&lt;/em&gt;, the &lt;em&gt;IndexError&lt;/em&gt; exception will be raised for invalid values. Instead of iterating over &lt;a href=&quot;#paramCount&quot;&gt;paramCount()&lt;/a&gt; with this proc you can call the convenience &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; deber&amp;iacute;a estar en el intervalo &lt;em&gt;1..paramCount ()&lt;/em&gt; , el &lt;em&gt;IndexError&lt;/em&gt; excepci&amp;oacute;n ser&amp;aacute; levantado para valores no v&amp;aacute;lidos. En lugar de iterar sobre &lt;a href=&quot;#paramCount&quot;&gt;paramCount ()&lt;/a&gt; con este proceso, puede llamar al &lt;a href=&quot;#commandLineParams&quot;&gt;comando de&lt;/a&gt; conveniencia LineParams () .</target>
        </trans-unit>
        <trans-unit id="3f4bf9334d2490f523b663af6901783da21ac6a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;includeSpace&lt;/em&gt; can be set to true to include the (SI preferred) space between the number and the unit (e.g. 1 KiB).</source>
          <target state="translated">&lt;em&gt;includeSpace&lt;/em&gt; se puede establecer en verdadero para incluir el espacio (SI preferido) entre el n&amp;uacute;mero y la unidad (por ejemplo, 1 KiB).</target>
        </trans-unit>
        <trans-unit id="e71266691c1695dc862a4187873f4eb27e421c29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; method in this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; debe ser una potencia de dos. Si necesita aceptar valores de tiempo de ejecuci&amp;oacute;n para esto, puede usar el proceso &lt;code&gt;nextPowerOfTwo&lt;/code&gt; del m&amp;oacute;dulo &lt;a href=&quot;math&quot;&gt;matem&amp;aacute;tico&lt;/a&gt; o el m&amp;eacute;todo &lt;code&gt;rightSize&lt;/code&gt; en este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="00959dbd3dd10aad40ca8d5088bb831b41a7779c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; proc from this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; debe ser una potencia de dos. Si necesita aceptar valores de tiempo de ejecuci&amp;oacute;n para esto, puede usar el proceso &lt;code&gt;nextPowerOfTwo&lt;/code&gt; del m&amp;oacute;dulo &lt;a href=&quot;math&quot;&gt;matem&amp;aacute;tico&lt;/a&gt; o el proceso &lt;code&gt;rightSize&lt;/code&gt; de este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="ea4791fbf3e42731dc51d96cd68f2db285a8f167" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; proc in this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; debe ser una potencia de dos. Si necesita aceptar valores de tiempo de ejecuci&amp;oacute;n para esto, puede usar el proceso &lt;code&gt;nextPowerOfTwo&lt;/code&gt; del m&amp;oacute;dulo &lt;a href=&quot;math&quot;&gt;matem&amp;aacute;tico&lt;/a&gt; o el proceso &lt;code&gt;rightSize&lt;/code&gt; en este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="9a840e66e23dce5bbe529077fe70ae32ae27b78c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; debe ser una potencia de dos. Si necesita aceptar valores de tiempo de ejecuci&amp;oacute;n para esto, puede usar el proceso &lt;code&gt;nextPowerOfTwo&lt;/code&gt; del m&amp;oacute;dulo &lt;a href=&quot;math&quot;&gt;matem&amp;aacute;tico&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7472432b84a3a2eab38f2db62373daa9e022086e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;isNil&lt;/em&gt; for an any &lt;em&gt;x&lt;/em&gt; that represents a sequence, string, cstring, proc or some pointer type.</source>
          <target state="translated">&lt;em&gt;isNil&lt;/em&gt; para cualquier &lt;em&gt;x&lt;/em&gt; que representa una secuencia, cadena, cstring, proc o alg&amp;uacute;n tipo de puntero.</target>
        </trans-unit>
        <trans-unit id="f70ae80be2c58fd29de80509ed00d5e2c9f1f429" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;padding&lt;/em&gt; characters (by default spaces) are added after &lt;em&gt;s&lt;/em&gt; resulting in left alignment. If &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt;, no spaces are added and &lt;em&gt;s&lt;/em&gt; is returned unchanged. If you need to right align a string use the &lt;a href=&quot;#align&quot;&gt;align proc&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;em&gt;los&lt;/em&gt; caracteres de &lt;em&gt;relleno&lt;/em&gt; (espacios predeterminados) se agregan despu&amp;eacute;s de &lt;em&gt;s, lo que&lt;/em&gt; da como resultado una alineaci&amp;oacute;n a la izquierda. Si &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt; , no se agregan espacios y &lt;em&gt;s&lt;/em&gt; se devuelve sin cambios. Si necesita alinear a la derecha una cadena, use el proceso de &lt;a href=&quot;#align&quot;&gt;alineaci&amp;oacute;n&lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="8672d4b2f28ca97d242b9f9940ce8d1789ba04fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;padding&lt;/em&gt; characters (by default spaces) are added before &lt;em&gt;s&lt;/em&gt; resulting in right alignment. If &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt;, no spaces are added and &lt;em&gt;s&lt;/em&gt; is returned unchanged. If you need to left align a string use the &lt;a href=&quot;#alignLeft&quot;&gt;alignLeft proc&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;em&gt;Los&lt;/em&gt; caracteres de &lt;em&gt;relleno&lt;/em&gt; (espacios predeterminados) se agregan antes de &lt;em&gt;s, lo que&lt;/em&gt; da como resultado una alineaci&amp;oacute;n a la derecha. Si &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt; , no se agregan espacios y &lt;em&gt;s&lt;/em&gt; se devuelve sin cambios. Si necesita alinear a la izquierda una cadena, use el proceso &lt;a href=&quot;#alignLeft&quot;&gt;alignLeft&lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="8247e0fd6fcaa06e3944fbde836de9960b4b141c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;pattern&lt;/em&gt; is OS dependent, but at least the &quot;*.ext&quot; notation is supported.</source>
          <target state="translated">&lt;em&gt;El patr&amp;oacute;n&lt;/em&gt; depende del sistema operativo, pero se admite al menos la notaci&amp;oacute;n &quot;* .ext&quot;.</target>
        </trans-unit>
        <trans-unit id="75461844b2cd9f0f721ba3326b4f70c797e25d69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;precision&lt;/em&gt; can be used to set the number of digits to be shown after the decimal point or (if &lt;em&gt;trim&lt;/em&gt; is true) the maximum number of digits to be shown.</source>
          <target state="translated">&lt;em&gt;La precisi&amp;oacute;n&lt;/em&gt; se puede utilizar para establecer el n&amp;uacute;mero de d&amp;iacute;gitos que se mostrar&amp;aacute;n despu&amp;eacute;s del punto decimal o (si el &lt;em&gt;recorte&lt;/em&gt; es verdadero) el n&amp;uacute;mero m&amp;aacute;ximo de d&amp;iacute;gitos que se mostrar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="617209c0ac1f0365ddc9daa8adb400efad149a99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quote&lt;/em&gt;: Used to quote fields containing special characters like &lt;em&gt;separator&lt;/em&gt;, &lt;em&gt;quote&lt;/em&gt; or new-line characters. '0' disables the parsing of quotes.</source>
          <target state="translated">&lt;em&gt;quote&lt;/em&gt; : se utiliza para citar campos que contienen caracteres especiales como &lt;em&gt;separadores&lt;/em&gt; , &lt;em&gt;comillas&lt;/em&gt; o caracteres de nueva l&amp;iacute;nea. '0' desactiva el an&amp;aacute;lisis de comillas.</target>
        </trans-unit>
        <trans-unit id="f3dae05aba49b918194a9396a45aa3565615f037" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;replacements&lt;/em&gt; is any proc that takes a word and returns a new word to fill it's place.</source>
          <target state="translated">&lt;em&gt;reemplazos&lt;/em&gt; es cualquier proceso que toma una palabra y devuelve una nueva palabra para llenar su lugar.</target>
        </trans-unit>
        <trans-unit id="fbc817a3080e1b6882164dc8caf322799358d878" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;select&lt;/em&gt; with a sensible Nim interface. &lt;em&gt;timeout&lt;/em&gt; is in milliseconds. Specify -1 for no timeout. Returns the number of processes that are ready to read from. The processes that are ready to be read from are removed from &lt;em&gt;readfds&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;seleccione&lt;/em&gt; con una interfaz sensible de Nim. &lt;em&gt;el tiempo de espera&lt;/em&gt; est&amp;aacute; en milisegundos. Especifique -1 para que no haya tiempo de espera. Devuelve el n&amp;uacute;mero de procesos que est&amp;aacute;n listos para leer. Los procesos que est&amp;aacute;n listos para leer se eliminan de &lt;em&gt;readfds&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d7f259f2477167c821ca25fa51730ed7960a70b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;separator&lt;/em&gt;: character used to separate fields</source>
          <target state="translated">&lt;em&gt;separador&lt;/em&gt; : car&amp;aacute;cter utilizado para separar campos</target>
        </trans-unit>
        <trans-unit id="208edbd229c8eae9f5eb36df289548d5304b4d7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;skipInitialSpace&lt;/em&gt;: If true, whitespace immediately following the &lt;em&gt;separator&lt;/em&gt; is ignored.</source>
          <target state="translated">&lt;em&gt;skipInitialSpace&lt;/em&gt; : si es verdadero, se ignora el espacio en blanco que sigue inmediatamente al &lt;em&gt;separador&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="273a15cf374a6c4f49fed8d98b7d8b9586b0faaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;true&lt;/em&gt; - generate only one timeout event</source>
          <target state="translated">&lt;em&gt;verdadero&lt;/em&gt; : genera solo un evento de tiempo de espera</target>
        </trans-unit>
        <trans-unit id="14ee562aca33dc19b06533f7cf5920a2b50148e9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; y &lt;em&gt;y&lt;/em&gt; son convertidos a &lt;code&gt;float&lt;/code&gt; y la otra operaci&amp;oacute;n de empuje se llama.</target>
        </trans-unit>
        <trans-unit id="783ab28443368da5d8b24739fb4554949b0f9f72" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; is simply converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; simplemente se convierte en &lt;code&gt;float&lt;/code&gt; y se llama a la otra operaci&amp;oacute;n de inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fae64b6ebd8e2c7bcc575d125a2000abb729e3ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; raised to the power &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; elevado a la potencia &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="12323c312fd7de0e4ef8b6a4ab533d557d68adc8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;alert_1&quot;&gt;alert&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;alert_1&quot;&gt;alert&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="56d285c47b35312e64820df42bf3a87fd1b7b319" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;alert_2&quot;&gt;alert&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;alert_2&quot;&gt;alert&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="dc8e48b403bc73650b187c7f7e7ea88d6cb233c6" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;apostrophe_1&quot;&gt;apostrophe&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;apostrophe_1&quot;&gt;apostrophe&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="aa4c0ec53f4daba1b0ecbab22044a4b311fd35ea" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;apostrophe_2&quot;&gt;apostrophe&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;apostrophe_2&quot;&gt;apostrophe&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="489a12332aa212cc707a62ebb576449c73813d0c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Automatic type conversion&lt;/span&gt; is performed in expressions where different kinds of integer types are used: the smaller type is converted to the larger.</source>
          <target state="translated">&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;La conversi&amp;oacute;n autom&amp;aacute;tica de tipos&lt;/span&gt; se realiza en expresiones donde se utilizan diferentes tipos de tipos enteros: el tipo m&amp;aacute;s peque&amp;ntilde;o se convierte en el m&amp;aacute;s grande.</target>
        </trans-unit>
        <trans-unit id="ef114326cdf7ec64073b8d5c70949a59e4d16784" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="654a8f7f92faee492756a045bc4a4f5716bafc9a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backslash_2&quot;&gt;backslash&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backslash_2&quot;&gt;backslash&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b344cba5f1b85d441c18840ce9f4242eff677927" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backspace_1&quot;&gt;backspace&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backspace_1&quot;&gt;backspace&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="3ef60dc7d037ac085bdffe500a7612d735b0c712" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backspace_2&quot;&gt;backspace&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backspace_2&quot;&gt;backspace&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="fc49500076e57365e635056cd3b75868d666ab71" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;carriage-return_1&quot;&gt;carriage return&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;carriage-return_1&quot;&gt;retorno de carro&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8ab206963e8b4940d40701cfc51c0f7e1851ffeb" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;carriage-return_2&quot;&gt;carriage return&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;carriage-return_2&quot;&gt;retorno de carro&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1cf7c76a0ff63e90fbc9727aa4db16092702311a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;cdecl_1&quot;&gt;cdecl&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;cdecl_1&quot;&gt;cdecl&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0733a6e3e51ba48347bd816e4d97acf3dbb10225" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-decimal-value-d_1&quot;&gt;character with decimal value d&lt;/span&gt;; all decimal digits directly following are used for the character</source>
          <target state="translated">&lt;span id=&quot;character-with-decimal-value-d_1&quot;&gt;car&amp;aacute;cter con valor decimal d&lt;/span&gt; ; todos los d&amp;iacute;gitos decimales que siguen directamente se utilizan para el car&amp;aacute;cter</target>
        </trans-unit>
        <trans-unit id="d33b972e48200cc4a6a49329f9bd2b0b86e9d179" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-decimal-value-d_2&quot;&gt;character with decimal value d&lt;/span&gt;; all decimal digits directly following are used for the character</source>
          <target state="translated">&lt;span id=&quot;character-with-decimal-value-d_2&quot;&gt;car&amp;aacute;cter con valor decimal d&lt;/span&gt; ; todos los d&amp;iacute;gitos decimales que siguen directamente se utilizan para el car&amp;aacute;cter</target>
        </trans-unit>
        <trans-unit id="598b3bddfa5c5d0fa5a106b08f17b0cd0a6928c4" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-hex-value-hh_1&quot;&gt;character with hex value HH&lt;/span&gt;; exactly two hex digits are allowed</source>
          <target state="translated">&lt;span id=&quot;character-with-hex-value-hh_1&quot;&gt;car&amp;aacute;cter con valor hexadecimal HH&lt;/span&gt; ; se permiten exactamente dos d&amp;iacute;gitos hexadecimales</target>
        </trans-unit>
        <trans-unit id="899d46bdef3da49bf9a47052252021471e9deca1" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-hex-value-hh_2&quot;&gt;character with hex value HH&lt;/span&gt;; exactly two hex digits are allowed</source>
          <target state="translated">&lt;span id=&quot;character-with-hex-value-hh_2&quot;&gt;car&amp;aacute;cter con valor hexadecimal HH&lt;/span&gt; ; se permiten exactamente dos d&amp;iacute;gitos hexadecimales</target>
        </trans-unit>
        <trans-unit id="06eb32c5efe204f53b8a3e469a651a6422b0ecef" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;closure_1&quot;&gt;closure&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;closure_1&quot;&gt;closure&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="69035165c7fe56ca0f544baab5f7ca6b3bb23e5f" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;constants_1&quot;&gt;Constants&lt;/span&gt; are symbols which are bound to a value. The constant's value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time.</source>
          <target state="translated">&lt;span id=&quot;constants_1&quot;&gt;Las constantes&lt;/span&gt; son s&amp;iacute;mbolos vinculados a un valor. El valor de la constante no puede cambiar. El compilador debe poder evaluar la expresi&amp;oacute;n en una declaraci&amp;oacute;n constante en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bc7dc406312d3d989f8fded7366dc2a2ca439dfc" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;documentation-comments_1&quot;&gt;Documentation comments&lt;/span&gt; are comments that start with two &lt;code&gt;##&lt;/code&gt;. Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree!</source>
          <target state="translated">&lt;span id=&quot;documentation-comments_1&quot;&gt;Los comentarios de documentaci&amp;oacute;n&lt;/span&gt; son comentarios que comienzan con dos &lt;code&gt;##&lt;/code&gt; . Los comentarios de documentaci&amp;oacute;n son tokens; solo se permiten en ciertos lugares del archivo de entrada, ya que pertenecen al &amp;aacute;rbol de sintaxis.</target>
        </trans-unit>
        <trans-unit id="c983afd465ba80d2147e0b70ee70ed5b594ffd0c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;escape_1&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_1&quot;&gt;[ESC]&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;escape_1&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_1&quot;&gt;[ESC]&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="23e3ae456032cf7bfe12b54d4c30ef515b7e5769" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;escape_2&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_2&quot;&gt;[ESC]&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;escape_2&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_2&quot;&gt;[ESC]&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1f0669c885766923e22bc3a0cf1a25ecf09a7e71" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;fastcall_1&quot;&gt;fastcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;fastcall_1&quot;&gt;fastcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="61df4a1c082aef5508a11aa5f32360878c832316" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;form-feed_1&quot;&gt;form feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;form-feed_1&quot;&gt;formulario de alimentaci&amp;oacute;n&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c83e42d1968c9f81163b17f1f1a97a7f750bcc7b" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;form-feed_2&quot;&gt;form feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;form-feed_2&quot;&gt;formulario de alimentaci&amp;oacute;n&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="24ef9584feba6e596a828184a0614706f20342a7" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;inline_1&quot;&gt;inline&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;inline_1&quot;&gt;inline&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="97eb508c4f7e0532dda34314f3114ac62db38999" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;intdefine_1&quot;&gt;intdefine&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;intdefine_1&quot;&gt;intdefine&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="bf681f8157045b76a5b5cca6556c710b3d31af04" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;line-feed_1&quot;&gt;line feed&lt;/span&gt; (often called &lt;span id=&quot;newline_1&quot;&gt;newline&lt;/span&gt;)</source>
          <target state="translated">&lt;span id=&quot;line-feed_1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;newline_1&quot;&gt;salto de &lt;/span&gt;&lt;span id=&quot;line-feed_1&quot;&gt;l&amp;iacute;nea&lt;/span&gt; (a menudo llamado &lt;span id=&quot;newline_1&quot;&gt;nueva l&amp;iacute;nea&lt;/span&gt; )</target>
        </trans-unit>
        <trans-unit id="f069e5dc4bd5128fe57f984b98f0d1df33905e6c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;line-feed_2&quot;&gt;line feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;line-feed_2&quot;&gt;linea de alimentaci&amp;oacute;n&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="370fea44cd56e7d13668a1518c6ed3e2793cd844" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;nimcall_1&quot;&gt;nimcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;nimcall_1&quot;&gt;nimcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="386493dc5a93f6552eed5a0c301e509bae171c3a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;noconv_1&quot;&gt;noconv&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;noconv_1&quot;&gt;noconv&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0d18cc4b434985ecdfad600d62beb278d037bd02" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;operators_1&quot;&gt;Operators&lt;/span&gt; are procedures with a special operator symbol as identifier:</source>
          <target state="translated">&lt;span id=&quot;operators_1&quot;&gt;Los operadores&lt;/span&gt; son procedimientos con un s&amp;iacute;mbolo de operador especial como identificador:</target>
        </trans-unit>
        <trans-unit id="dd7a03ff3abf42e8baa1ecc1fffb484ad21a23af" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;quotation-mark_1&quot;&gt;quotation mark&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;quotation-mark_1&quot;&gt;comillas&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c6aabef76f9a817672169780852e677ea046add2" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;quotation-mark_2&quot;&gt;quotation mark&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;quotation-mark_2&quot;&gt;comillas&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c37b02a49dcefbd3153898422e9bb9a58594c0f5" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;safecall_1&quot;&gt;safecall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;safecall_1&quot;&gt;safecall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9075773ca58649470612eb72f9b476282ba11426" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;spawn_1&quot;&gt;spawn&lt;/span&gt; can be used to pass a task to the thread pool:</source>
          <target state="translated">&lt;span id=&quot;spawn_1&quot;&gt;spawn&lt;/span&gt; se puede usar para pasar una tarea al grupo de subprocesos:</target>
        </trans-unit>
        <trans-unit id="f768c26556a449ea02596d87572b18bde70355d0" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;stdcall_1&quot;&gt;stdcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;stdcall_1&quot;&gt;stdcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="459d1365b562550b27ebf6a8974dd5ae8b46a70a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;strdefine_1&quot;&gt;strdefine&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;strdefine_1&quot;&gt;strdefine&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="f2149f636a8a39166b70a1e1b85797ae880037d8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;structured_1&quot;&gt;Structured&lt;/span&gt; parallelism via the &lt;code&gt;parallel&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;structured_1&quot;&gt;&lt;/span&gt;Paralelismo &lt;span id=&quot;structured_1&quot;&gt;estructurado a&lt;/span&gt; trav&amp;eacute;s de la declaraci&amp;oacute;n &lt;code&gt;parallel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906052db691f512b87e944c4fa7ae79175ea0c21" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;syscall_1&quot;&gt;syscall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;syscall_1&quot;&gt;syscall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="2fce4fa4dbb6e8e47310c53145477e8e7e68ebe3" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;tabulator_1&quot;&gt;tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;tabulator_1&quot;&gt;tabulator&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b6b9690fa127b5c41c7a6608abe780996467b339" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;tabulator_2&quot;&gt;tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;tabulator_2&quot;&gt;tabulator&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a0e78449bd2f86ea69106414c3a2d0d1430a9b77" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;unmarshals_1&quot;&gt;Unmarshals&lt;/span&gt; the specified node into the object type specified.</source>
          <target state="translated">&lt;span id=&quot;unmarshals_1&quot;&gt;Desordena&lt;/span&gt; el nodo especificado en el tipo de objeto especificado.</target>
        </trans-unit>
        <trans-unit id="daac7f50d202881a5d6ee0367a0863d7aebf95c3" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;unstructured_1&quot;&gt;Unstructured&lt;/span&gt; parallelism via the standalone &lt;code&gt;spawn&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;unstructured_1&quot;&gt;&lt;/span&gt;Paralelismo &lt;span id=&quot;unstructured_1&quot;&gt;no estructurado a&lt;/span&gt; trav&amp;eacute;s de la declaraci&amp;oacute;n de &lt;code&gt;spawn&lt;/code&gt; independiente .</target>
        </trans-unit>
        <trans-unit id="d57fe270428bde77daa75ade4ed835d70900fc90" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;vertical-tabulator_1&quot;&gt;vertical tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;vertical-tabulator_1&quot;&gt;tabulador vertical&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9cc1eadaa9721d4034ad25e0a89c479254a832df" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;vertical-tabulator_2&quot;&gt;vertical tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;vertical-tabulator_2&quot;&gt;tabulador vertical&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="162d657293056b3b52f778e7e2ab66fe5d304524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;$MODULE&lt;/strong&gt;: like $TESTNIM but without extension, useful for expected output.</source>
          <target state="translated">&lt;strong&gt;$ MODULE&lt;/strong&gt; : como $ TESTNIM pero sin extensi&amp;oacute;n, &amp;uacute;til para la salida esperada.</target>
        </trans-unit>
        <trans-unit id="0f7f0e7e27fe39d47b743d1865954b56a2c07fd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;$TESTNIM&lt;/strong&gt;: filename specified in the first line of the script.</source>
          <target state="translated">&lt;strong&gt;$ TESTNIM&lt;/strong&gt; : nombre de archivo especificado en la primera l&amp;iacute;nea del script.</target>
        </trans-unit>
        <trans-unit id="a839ade11ae6dd196f2a9173f8f1d634964f9d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Availability&lt;/strong&gt;: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with &lt;a href=&quot;system#declared&quot;&gt;declared()&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;Disponibilidad&lt;/strong&gt; : en Posix no hay una forma port&amp;aacute;til de obtener la l&amp;iacute;nea de comandos de una DLL y, por lo tanto, el proceso no est&amp;aacute; definido en este entorno. Puede probar su disponibilidad con &lt;a href=&quot;system#declared&quot;&gt;Declaration ()&lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="654a21dac651772b23f95ecd2222feacad79471f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Availability&lt;/strong&gt;: When generating a dynamic library (see --app:lib) on Posix this proc is not defined. Test for availability using &lt;a href=&quot;system#declared&quot;&gt;declared()&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;Disponibilidad&lt;/strong&gt; : al generar una biblioteca din&amp;aacute;mica (ver --app: lib) en Posix, este proceso no est&amp;aacute; definido. Pruebe la disponibilidad utilizando &lt;a href=&quot;system#declared&quot;&gt;Published ()&lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="fcbe823732d2c9972cd2868d10967de104d96e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Blocks&lt;/strong&gt; the current thread until the specified future completes.</source>
          <target state="translated">&lt;strong&gt;Bloquea&lt;/strong&gt; el hilo actual hasta que se completa el futuro especificado.</target>
        </trans-unit>
        <trans-unit id="ade01956444b2bedb6ba0ce473524e122c45ab36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEPRECATED&lt;/strong&gt; as it was confused for shell quoting function. For this application use &lt;a href=&quot;osproc#quoteShell&quot;&gt;osproc.quoteShell&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;DEPRECADO&lt;/strong&gt; ya que se confundi&amp;oacute; con la funci&amp;oacute;n de cotizaci&amp;oacute;n de shell. Para esta aplicaci&amp;oacute;n, utilice &lt;a href=&quot;osproc#quoteShell&quot;&gt;osproc.quoteShell&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f9bcec4d297aa8b62e7707f49f12d5b91ee3e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since 0.9.6&lt;/strong&gt;: Use &lt;code&gt;Uri&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde 0.9.6&lt;/strong&gt; : use &lt;code&gt;Uri&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="0edc0ae576cbf1405d25d406473d00a29f1efad5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="64a9b956a337527118896d06cbe9ae7f050d636f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTimeInterval&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTimeInterval&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="d42b15a342ba8260b2d18fb84c9410a31da17af0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;createNativeSocket&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;createNativeSocket&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="07e0d4b10a5b7a0a71d906084234d0680ca5563e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;registerHandle&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;registerHandle&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="1129f505c350479aaa022b8a8003b02d2ff1812a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;trigger&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; utilice el &lt;code&gt;trigger&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="df4c00b11b4bf37dc2f6430219a81fef666c3077" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;updateHandle&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;updateHandle&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="8fd9c517dc50477a5fbd53eadca39aa342cacc15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;fromUnix&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;fromUnix&lt;/code&gt; en su lugar</target>
        </trans-unit>
        <trans-unit id="cb78393c2152a466222fd3a7fb4214ff908ccea1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;getDayOfWeek(monthday: MonthdayRange; month: Month; year: int)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;getDayOfWeek(monthday: MonthdayRange; month: Month; year: int)&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="a648b574225c4c5297a7b9e6a179de1fa70405ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;initTimeInterval&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;initTimeInterval&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="b650e97ba36dce981193da56e9d3e90303aa2415" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;local&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;local&lt;/code&gt; en su lugar</target>
        </trans-unit>
        <trans-unit id="be21164252193e55e3a53ee4fd307e3bd091719f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;now().utcOffset&lt;/code&gt; to get the current utc offset (including DST).</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;now().utcOffset&lt;/code&gt; para obtener el desplazamiento utc actual (incluido el horario de verano).</target>
        </trans-unit>
        <trans-unit id="7093a6b25b775ae7f81736fede1917ea4a624cb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;toUnix&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;toUnix&lt;/code&gt; en su lugar</target>
        </trans-unit>
        <trans-unit id="5bfa49165457523fa77a7619996190f331b5e0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;utc&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.0:&lt;/strong&gt; use &lt;code&gt;utc&lt;/code&gt; en su lugar</target>
        </trans-unit>
        <trans-unit id="a2f96fe2ad51bd3c2f12b80acad9b57384ced284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getBool&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.2:&lt;/strong&gt; use &lt;code&gt;getBool&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="df0e7fcddc8c3387b9579f61dc61f253f5817870" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getFloat&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.2:&lt;/strong&gt; use &lt;code&gt;getFloat&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="c1b0c3af938100bdf91557ac9b93edb506162843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getInt&lt;/code&gt; or &lt;code&gt;getBiggestInt&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.18.2:&lt;/strong&gt; use &lt;code&gt;getInt&lt;/code&gt; o &lt;code&gt;getBiggestInt&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="ff84ca124aa9ac594837f7d32a1435e66e43f038" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use &lt;code&gt;zonedTimeFromTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.19.0:&lt;/strong&gt; use &lt;code&gt;zonedTimeFromTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="595283a18cec59736002f87447f03a29696e5825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use the &lt;code&gt;time&lt;/code&gt; field instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.19.0:&lt;/strong&gt; use el campo de &lt;code&gt;time&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="5295b91fb2f0e30f39313327d56ecb8a32c45919" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use the &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.19.0:&lt;/strong&gt; use &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="abdd1f4767c098ae47e6067b7b37ea7d137a5e30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.8.10:&lt;/strong&gt; use &lt;code&gt;epochTime&lt;/code&gt; or &lt;code&gt;cpuTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde v0.8.10:&lt;/strong&gt; use &lt;code&gt;epochTime&lt;/code&gt; o &lt;code&gt;cpuTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="baa9f17ac8b7f5e394f4f3c35b922f174fd2bf83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.12.0:&lt;/strong&gt; Use the &lt;code&gt;apply&lt;/code&gt; proc instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.12.0:&lt;/strong&gt; use el &lt;strong&gt;procedimiento de &lt;/strong&gt; &lt;code&gt;apply&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="813f61ed56bd8727049251f3d658b7107660c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.12.0:&lt;/strong&gt; Use the &lt;code&gt;mapIt(seq1, op)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.12.0:&lt;/strong&gt; use &lt;code&gt;mapIt(seq1, op)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f28367f57c9f2614afb958138d03a3bf3142b6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: Use &lt;code&gt;asyncnet.recvLine()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.15.0&lt;/strong&gt; : use &lt;code&gt;asyncnet.recvLine()&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="e2d7de988f2acf5e38494443df673fdfae41dc37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.get&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.15.0&lt;/strong&gt; : use &lt;code&gt;HttpClient.get&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="299961d38c046d81a057b39c87e1ea3541f2bbbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.getContent&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.15.0&lt;/strong&gt; : use &lt;code&gt;HttpClient.getContent&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="50ec41efadd97988380f7499bf68d5ceb1b22a59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.post&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.15.0&lt;/strong&gt; : use &lt;code&gt;HttpClient.post&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="7c32a49f3f9d3f8d7e600b14dd15502686a235da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.postContent&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.15.0&lt;/strong&gt; : use &lt;code&gt;HttpClient.postContent&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="ed96372a5060ce286aef82b0d3c6ae674a124053" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.request&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.15.0&lt;/strong&gt; : use &lt;code&gt;HttpClient.request&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="813b7f383169e8184fc6c9b0e28773046ac68201" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.16.2&lt;/strong&gt;: use &lt;code&gt;HttpClient.downloadFile&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.16.2&lt;/strong&gt; : use &lt;code&gt;HttpClient.downloadFile&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="23834ea822e2c6d9726d7ec8d8695d7fb373d3c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.17.0&lt;/strong&gt;: This procedure isn't cross-platform and so should not be used in newly written code.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.17.0&lt;/strong&gt; : este procedimiento no es multiplataforma y, por lo tanto, no debe usarse en c&amp;oacute;digo reci&amp;eacute;n escrito.</target>
        </trans-unit>
        <trans-unit id="4df24020923200ebb62009aa073b6e02140c4500" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.0&lt;/strong&gt;. For the common excluding range write &lt;code&gt;0 ..&amp;lt; 10&lt;/code&gt; instead of &lt;code&gt;0 .. &amp;lt; 10&lt;/code&gt; (look at the spacing). For &lt;code&gt;&amp;lt;x&lt;/code&gt; write &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.18.0&lt;/strong&gt; . Para el rango de exclusi&amp;oacute;n com&amp;uacute;n, escriba &lt;code&gt;0 ..&amp;lt; 10&lt;/code&gt; lugar de &lt;code&gt;0 .. &amp;lt; 10&lt;/code&gt; (observe el espacio). Para &lt;code&gt;&amp;lt;x&lt;/code&gt; escriba &lt;code&gt;pred(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c7818b422a258b46806f0eafceaa44f6c79aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;. Use len() instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.18.1&lt;/strong&gt; . Utilice len () en su lugar.</target>
        </trans-unit>
        <trans-unit id="7ef1cf4f5f7fc799e0b35914ada5c795f1cd5725" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; All functionality is defined on &lt;code&gt;NimNode&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.18.1&lt;/strong&gt; ; Toda la funcionalidad est&amp;aacute; definida en &lt;code&gt;NimNode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e84173b0ac9d2fd4420a0991936918f4ee1a8ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Generate a new &lt;code&gt;NimNode&lt;/code&gt; with &lt;code&gt;genSym&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.18.1&lt;/strong&gt; ; &lt;code&gt;genSym&lt;/code&gt; lugar, genere un nuevo &lt;code&gt;NimNode&lt;/code&gt; con genSym .</target>
        </trans-unit>
        <trans-unit id="16653bf53256723a0cc8002763700158bb2a42ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Generate a new &lt;code&gt;NimNode&lt;/code&gt; with &lt;code&gt;ident(string)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.18.1&lt;/strong&gt; ; En su lugar, &lt;code&gt;NimNode&lt;/code&gt; un nuevo NimNode con &lt;code&gt;ident(string)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7fca1a76838f997b6b479a7049316d7b71e5d23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use &lt;code&gt;binarySearch&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.18.1&lt;/strong&gt; ; Utilice &lt;code&gt;binarySearch&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="07febc28bfa9d03d0fa4ee192105ba5a7d71b5d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use one of &lt;code&gt;nestList(NimNode, ...)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.18.1&lt;/strong&gt; ; Utilice uno de &lt;code&gt;nestList(NimNode, ...)&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="4b359efb52a169b0f8e2ad570667904d89cf4c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.8.12&lt;/strong&gt;: Use &lt;code&gt;parseWhile&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.8.12&lt;/strong&gt; : use &lt;code&gt;parseWhile&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="fd66fa6e9cfcab65583dfb8b55c8ca91df2a0525" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.0:&lt;/strong&gt; Please use &lt;code&gt;existsFile&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.9.0:&lt;/strong&gt; utilice &lt;code&gt;existsFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c46f664e9ddbfa0ff79f37fc44b94ec7d81f29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.0:&lt;/strong&gt; Please use the function above.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.9.0:&lt;/strong&gt; utilice la funci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="97dff7a47c48bdad8d984c2e2262de3696009ba8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function has been deprecated in favour of readLine.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.9.2&lt;/strong&gt; : esta funci&amp;oacute;n ha quedado obsoleta en favor de readLine.</target>
        </trans-unit>
        <trans-unit id="5f68edfa8278ec5885de09d908256c4b49e8634f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function has been deprecated in favour of readLineAsync.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.9.2&lt;/strong&gt; : esta funci&amp;oacute;n ha quedado obsoleta en favor de readLineAsync.</target>
        </trans-unit>
        <trans-unit id="c4af36b03e871c9cae4428903b9bca8534e6953e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function is not safe for use.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.9.2&lt;/strong&gt; : esta funci&amp;oacute;n no es segura para su uso.</target>
        </trans-unit>
        <trans-unit id="fface47b088c778a2f4e77c02bf19ee55d18a8e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;fromWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso:&lt;/strong&gt; use &lt;code&gt;fromWinTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="06ec99b3afe2ae2cbe0edda32125eccea758f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="3a884be761dae54201f8aa530278b417918acce3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;em&gt;hasKey&lt;/em&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso:&lt;/strong&gt; use &lt;em&gt;hasKey&lt;/em&gt; en &lt;em&gt;su&lt;/em&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="a22c0c29442195e4011e17d60edeee2f5d85fcea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</source>
          <target state="translated">&lt;strong&gt;Descargo de responsabilidad&lt;/strong&gt; : este c&amp;oacute;digo no est&amp;aacute; bien probado, puede ser muy inseguro y propenso a vulnerabilidades de seguridad.</target>
        </trans-unit>
        <trans-unit id="6ffe4dc5c4fc52ea3ea1e3a20dd64567380feece" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use this module for cryptographic purposes!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;No utilice este m&amp;oacute;dulo con fines criptogr&amp;aacute;ficos!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f928ed32bee5c29af52b00bc30f99ce156242335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Docstring&lt;/strong&gt; : siempre la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="d4209dbb40d9185067bcb8ce189cd1c6eed7f25e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: docstring if available.</source>
          <target state="translated">&lt;strong&gt;Docstring&lt;/strong&gt; : docstring si est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73e5c6a20cafb8203519ae745e546e8bb3f10e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : siempre la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="160ef9d36bed422272b88e68bd931cde20c08000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: enum type grouping other enum fields.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : tipo de enumeraci&amp;oacute;n que agrupa otros campos de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="be7ebe20c5b6aef98f77a13140c9b09bb67359f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the iterator including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma del iterador incluido el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="c6c20f7dbb204753d2338c8585a984c7c7fa8c25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the macro including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma de la macro, incluido el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="b6771fb30bab96fd8cf5d95cfd5b7411f13b3c15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the method including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma del m&amp;eacute;todo, incluido el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="8779f27a30500300592c1fbc44c5a869259d7284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the proc including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma del proceso, incluido el tipo de devoluci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5b4c52d33a04c0f32a87d9b5783e815726a1d81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the template including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma de la plantilla, incluido el tipo de devoluci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4dfd102fd6fbe96ece65dd9c1d384e0f16912006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the const value.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de valor constante.</target>
        </trans-unit>
        <trans-unit id="63fb555122e12cadcd219b4c04854752ec0ed9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the let variable.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de la variable let.</target>
        </trans-unit>
        <trans-unit id="20edb7c031a399a27ff6ff092cecc38f0cd151a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the parameter.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="d1c0d7dfb4af3e8e26314132e3d53473279ebfe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the result.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="c558e48e401e6265a17ebeab90f8b20f1f7e1e47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the var.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de var.</target>
        </trans-unit>
        <trans-unit id="9384cc6e440487319d842110001333299d831093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo.</target>
        </trans-unit>
        <trans-unit id="329b7e3326c98503c949ca9d39330b0e1c6794bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: type of the var.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : tipo de var.</target>
        </trans-unit>
        <trans-unit id="978f10cfc82df92effeee967159555f49c21c819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unchecked arrays and there should be an explicit annotation of how the GC is to determine the runtime size of the array.</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : la memoria GC'ed debe permitirse en matrices no verificadas y debe haber una anotaci&amp;oacute;n expl&amp;iacute;cita de c&amp;oacute;mo la GC debe determinar el tama&amp;ntilde;o de tiempo de ejecuci&amp;oacute;n de la matriz.</target>
        </trans-unit>
        <trans-unit id="150871409dc1ef45a59e74d4be5900fd8cf45ddc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unions and the GC should scan unions conservatively.</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : la memoria de GC deber&amp;iacute;a permitirse en los sindicatos y el GC deber&amp;iacute;a escanear los sindicatos de manera conservadora.</target>
        </trans-unit>
        <trans-unit id="5f1330a349c9dedfd2b8b17d35746d232592d00d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: The &lt;code&gt;acyclic&lt;/code&gt; pragma may become a property of a &lt;code&gt;ref&lt;/code&gt; type:</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : el pragma &lt;code&gt;acyclic&lt;/code&gt; puede convertirse en una propiedad de un tipo de &lt;code&gt;ref&lt;/code&gt; erencia :</target>
        </trans-unit>
        <trans-unit id="75d19ae59ec3e06e328ace922bad09261db8a6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: Using GC'ed memory in packed pragma will result in compile-time error. Usage with inheritance should be defined and documented.</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : el uso de memoria GC'ed en pragma empaquetado dar&amp;aacute; como resultado un error en tiempo de compilaci&amp;oacute;n. Se debe definir y documentar el uso con herencia.</target>
        </trans-unit>
        <trans-unit id="b59417140c3fc6f7e2c17f2c777a2f509360e62e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hint:&lt;/strong&gt; With &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (or higher) Nim lists the processed code after each filter application.</source>
          <target state="translated">&lt;strong&gt;Pista:&lt;/strong&gt; Con &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (o superior) Nim enumera el c&amp;oacute;digo procesado despu&amp;eacute;s de cada aplicaci&amp;oacute;n de filtro.</target>
        </trans-unit>
        <trans-unit id="f555042911466061dac7f6fee69c396fc92108dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Known limitations:&lt;/strong&gt; In the JavaScript target, global variables using the &lt;code&gt;codegenDecl&lt;/code&gt; pragma will be re-initialized on each reload. Please guard the initialization with a &lt;em&gt;once&lt;/em&gt; block to work-around this.</source>
          <target state="translated">&lt;strong&gt;Limitaciones conocidas:&lt;/strong&gt; en el destino de JavaScript, las variables globales que utilizan el pragma &lt;code&gt;codegenDecl&lt;/code&gt; se reinicializar&amp;aacute;n en cada recarga. Por favor, guardar la inicializaci&amp;oacute;n de una &lt;em&gt;vez&lt;/em&gt; el bloque de trabajo en torno a esto.</target>
        </trans-unit>
        <trans-unit id="5911ff88eb68bebee7d71b3a0d7b01ad6e208cea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Nim currently does not detect these!</source>
          <target state="translated">&lt;strong&gt;NOTA&lt;/strong&gt; : &amp;iexcl;Nim actualmente no los detecta!</target>
        </trans-unit>
        <trans-unit id="140047e96ac4c58f01e73270812c9a51624feb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; At the moment hot code reloading is supported only in JavaScript projects.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Por el momento, la recarga de c&amp;oacute;digo activo solo se admite en proyectos JavaScript.</target>
        </trans-unit>
        <trans-unit id="a5ae990ae2793f586640459d0853bfff28f07ff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Comment statement will be ignored.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Se ignorar&amp;aacute; la declaraci&amp;oacute;n de comentario.</target>
        </trans-unit>
        <trans-unit id="d4b69032440a3760c06332bd2946743c6dc04769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Each delegate has a task associated with it. This gets called after each select() call, if you set timeout to &lt;code&gt;-1&lt;/code&gt; the tasks will only be executed after one or more file descriptors becomes readable or writeable.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Cada delegado tiene una tarea asociada. Esto se llama despu&amp;eacute;s de cada llamada select (), si establece el tiempo de espera en &lt;code&gt;-1&lt;/code&gt; , las tareas solo se ejecutar&amp;aacute;n despu&amp;eacute;s de que uno o m&amp;aacute;s descriptores de archivo se vuelvan legibles o escribibles.</target>
        </trans-unit>
        <trans-unit id="7f378938581797df4e574611774903888f75a977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For leap years, start date is assumed to be 1 AD. counts the number of leap years up to January 1st of a given year. Keep in mind that if specified year is a leap year, the leap day has not happened before January 1st of that year.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Para los a&amp;ntilde;os bisiestos, se supone que la fecha de inicio es 1 d.C. cuenta el n&amp;uacute;mero de a&amp;ntilde;os bisiestos hasta el 1 de enero de un a&amp;ntilde;o determinado. Tenga en cuenta que si el a&amp;ntilde;o especificado es bisiesto, el d&amp;iacute;a bisiesto no ocurri&amp;oacute; antes del 1 de enero de ese a&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="8234ec32d945f2b0f03239d1b0eaae84f70df2af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to provide async ability to your module please do not use the &lt;code&gt;Delegate&lt;/code&gt; object, instead use &lt;code&gt;AsyncSocket&lt;/code&gt;. It is possible that in the future this type's fields will not be exported therefore breaking your code.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Si desea proporcionar capacidad as&amp;iacute;ncrona a su m&amp;oacute;dulo, no use el objeto &lt;code&gt;Delegate&lt;/code&gt; , en su lugar use &lt;code&gt;AsyncSocket&lt;/code&gt; . Es posible que en el futuro los campos de este tipo no se exporten y por lo tanto se rompa el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="6066c5e1dbc1c07031004fde7afa16f36e8afe0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Most modules have tasks which need to be ran regularly, this is why you should not call &lt;code&gt;poll&lt;/code&gt; with a infinite timeout, or even a very long one. In most cases the default timeout is fine.</source>
          <target state="translated">&lt;strong&gt;Nota: la&lt;/strong&gt; mayor&amp;iacute;a de los m&amp;oacute;dulos tienen tareas que deben ejecutarse con regularidad, por eso no debe llamar a &lt;code&gt;poll&lt;/code&gt; con un tiempo de espera infinito, o incluso uno muy largo. En la mayor&amp;iacute;a de los casos, el tiempo de espera predeterminado est&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="4f92aa536204e6eaef641a2e69451b390e74e1bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;em&gt;project file name&lt;/em&gt; is the name of the &lt;code&gt;.nim&lt;/code&gt; file that is passed as a command line argument to the compiler.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; El &lt;em&gt;nombre del archivo del proyecto&lt;/em&gt; es el nombre del archivo &lt;code&gt;.nim&lt;/code&gt; que se pasa como argumento de l&amp;iacute;nea de comando al compilador.</target>
        </trans-unit>
        <trans-unit id="2a72b0f5ef54ecdf16cb26a40bdbef5872800692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The API of FutureStream is still new and so has a higher likelihood of changing in the future.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; La API de FutureStream a&amp;uacute;n es nueva y, por lo tanto, tiene una mayor probabilidad de cambiar en el futuro.</target>
        </trans-unit>
        <trans-unit id="fe5b130db131453d8df37e590c01fe6f08bec9e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The behaviour of this procedure changed in version 0.14.0. To get a list of usages and to restore the old behaviour of this procedure, compile with the &lt;code&gt;-d:nimJsonGet&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; El comportamiento de este procedimiento cambi&amp;oacute; en la versi&amp;oacute;n 0.14.0. Para obtener una lista de usos y restaurar el antiguo comportamiento de este procedimiento, compile con el indicador &lt;code&gt;-d:nimJsonGet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c072da5e00ce440c3b93018b2a1ef17e9ee5503c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of message passing does not work with cyclic data structures. &lt;strong&gt;Note:&lt;/strong&gt; Channels cannot be passed between threads. Use globals or pass them by &lt;em&gt;ptr&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; La implementaci&amp;oacute;n actual del paso de mensajes no funciona con estructuras de datos c&amp;iacute;clicas. &lt;strong&gt;Nota: los&lt;/strong&gt; canales no se pueden pasar entre hilos. Utilice globales o &lt;em&gt;p&amp;aacute;selos&lt;/em&gt; por &lt;em&gt;ptr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b999dbe7ed39e219e124bd0949367e2e3d56fe13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The resulting &lt;code&gt;XmlNode&lt;/code&gt; already uses the &lt;code&gt;clientData&lt;/code&gt; field, so it cannot be used by clients of this library.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; El &lt;code&gt;XmlNode&lt;/code&gt; resultante ya usa el campo &lt;code&gt;clientData&lt;/code&gt; , por lo que los clientes de esta biblioteca no pueden usarlo.</target>
        </trans-unit>
        <trans-unit id="eb469a558a1fb80f9ffa7a37d87dd2f9adc314d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The server may return multiple lines of coded replies.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; el servidor puede devolver varias l&amp;iacute;neas de respuestas codificadas.</target>
        </trans-unit>
        <trans-unit id="0d1eacb2a91de8906a2993f50f4d1523095b2af2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; There are no postfix operators in Nim. However, the &lt;code&gt;nnkPostfix&lt;/code&gt; node is used for the &lt;em&gt;asterisk export marker&lt;/em&gt;&lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; No hay operadores de sufijo en Nim. Sin embargo, el nodo &lt;code&gt;nnkPostfix&lt;/code&gt; se utiliza para el &lt;em&gt;marcador de exportaci&amp;oacute;n de asterisco &lt;/em&gt; &lt;code&gt;*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f905a6d385133393b2c96347260edc54f46375a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This does not preserve the new line characters used in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esto no conserva los caracteres de nueva l&amp;iacute;nea utilizados en &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7811fa53cf7abdc675dfee2447ec973dd431ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is not supported on &lt;code&gt;Windows&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; esta funci&amp;oacute;n no es compatible con &lt;code&gt;Windows&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10e606a3da78b8e2b189b92aa03f1f5e54c1d549" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is supported only by BSD and MacOSX.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esta funci&amp;oacute;n solo es compatible con BSD y MacOSX.</target>
        </trans-unit>
        <trans-unit id="b24c06d6eed7edbd4cef00490b4db7c0ca199c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module currently only supports select(), this is limited by FD_SETSIZE, which is usually 1024. So you may only be able to use 1024 sockets at a time.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Este m&amp;oacute;dulo actualmente solo admite select (), esto est&amp;aacute; limitado por FD_SETSIZE, que generalmente es 1024. Por lo tanto, es posible que solo pueda usar 1024 sockets a la vez.</target>
        </trans-unit>
        <trans-unit id="be757c0b40131a488a140d8d6a5f654644bde753" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available for SSL sockets.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; este proceso no est&amp;aacute; disponible para sockets SSL.</target>
        </trans-unit>
        <trans-unit id="8996a73c32006599330b4aacfeffcd8eabd847e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Under POSIX OS's, the returned time may actually be the time at which the file's attribute's were last modified. See &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; En el sistema operativo POSIX, la hora devuelta puede ser la hora en que se modificaron por &amp;uacute;ltima vez los atributos del archivo. Consulte &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;aqu&amp;iacute;&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4326e562047392c7a998b1d78e1b1453866d2345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You may wish to use the high-level version of this function which is defined below.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; es posible que desee utilizar la versi&amp;oacute;n de alto nivel de esta funci&amp;oacute;n que se define a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="18f7852fedb7919a22f8ce639864908dfafb58b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You will need to run asynchronous examples in an async proc otherwise you will get an &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Deber&amp;aacute; ejecutar ejemplos asincr&amp;oacute;nicos en un proceso asincr&amp;oacute;nico; de lo contrario, obtendr&amp;aacute; un &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error &quot;aguardar&quot; .</target>
        </trans-unit>
        <trans-unit id="e153549d82bb0553e51565bc85af72f16648f194" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; can parse a large subset of C++ and knows about the &lt;code&gt;importcpp&lt;/code&gt; pragma pattern language. It is not necessary to know all the details described here.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; puede analizar un gran subconjunto de C ++ y conoce el lenguaje de patrones &lt;code&gt;importcpp&lt;/code&gt; pragma. No es necesario conocer todos los detalles aqu&amp;iacute; descritos.</target>
        </trans-unit>
        <trans-unit id="752ddb5d050c961f8013cbe90d4ad9d26a7ee13a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; must be initialised (with &lt;code&gt;new&lt;/code&gt;), this function makes no effort to initialise the &lt;code&gt;client&lt;/code&gt; variable.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : el &lt;code&gt;client&lt;/code&gt; e debe estar inicializado (con &lt;code&gt;new&lt;/code&gt; ), esta funci&amp;oacute;n no hace ning&amp;uacute;n esfuerzo por inicializar la variable del &lt;code&gt;client&lt;/code&gt; e .</target>
        </trans-unit>
        <trans-unit id="449eaada440261e910e8e598da9c4ed1cfb68e61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; needs to be initialised.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : el &lt;code&gt;client&lt;/code&gt; e debe inicializarse.</target>
        </trans-unit>
        <trans-unit id="ed6c907ecc726f3524b1431bfea1378d7d591f2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;data&lt;/code&gt; must be initialised.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : los &lt;code&gt;data&lt;/code&gt; deben inicializarse.</target>
        </trans-unit>
        <trans-unit id="79f23d79481e20b54cf233e31f8767bbf0d80411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;var&lt;/code&gt; parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : los par&amp;aacute;metros &lt;code&gt;var&lt;/code&gt; nunca son necesarios para un paso de par&amp;aacute;metros eficiente. Dado que los par&amp;aacute;metros no var no se pueden modificar, el compilador siempre tiene la libertad de pasar argumentos por referencia si considera que puede acelerar la ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="917b6bc95e7e2268d07e2f344f8fb05732bc1b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A &lt;code&gt;dynlib&lt;/code&gt; import can be overridden with the &lt;code&gt;--dynlibOverride:name&lt;/code&gt; command line option. The Compiler User Guide contains further information.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Una importaci&amp;oacute;n de &lt;code&gt;dynlib&lt;/code&gt; se puede anular con la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--dynlibOverride:name&lt;/code&gt; . La Gu&amp;iacute;a del usuario del compilador contiene m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a4c0c0109f9323e091c1b8f19f86e88886ea759e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: An &lt;span id=&quot;unresolved_1&quot;&gt;unresolved&lt;/span&gt; expression is an expression for which no symbol lookups and no type checking have been performed.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Una expresi&amp;oacute;n &lt;span id=&quot;unresolved_1&quot;&gt;sin resolver&lt;/span&gt; es una expresi&amp;oacute;n para la que no se han realizado b&amp;uacute;squedas de s&amp;iacute;mbolos ni verificaci&amp;oacute;n de tipos.</target>
        </trans-unit>
        <trans-unit id="19158a8ced28ef096d6d098faea99e938f8aea45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As a special syntactic extension if the whole PEG is only a single expression, identifiers are not interpreted as non-terminals, but are interpreted as verbatim string:</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Como extensi&amp;oacute;n sint&amp;aacute;ctica especial, si el PEG completo es solo una expresi&amp;oacute;n, los identificadores no se interpretan como no terminales, sino que se interpretan como una cadena literal:</target>
        </trans-unit>
        <trans-unit id="394b8821bf33b16092eceec91b4261c0182b2ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Code reordering is experimental and must be enabled via the &lt;code&gt;{.experimental.}&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : el reordenamiento del c&amp;oacute;digo es experimental y debe habilitarse mediante el &lt;code&gt;{.experimental.}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d3410cbe9aaa0f2ff2edaf757af2c7376b1329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compile time evaluation is not (yet) supported for methods.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : La evaluaci&amp;oacute;n del tiempo de compilaci&amp;oacute;n no es (todav&amp;iacute;a) compatible con los m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="1ec4927b4c9fc829236a51cac7723591db8396a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Composition (&lt;em&gt;has-a&lt;/em&gt; relation) is often preferable to inheritance (&lt;em&gt;is-a&lt;/em&gt; relation) for simple code reuse. Since objects are value types in Nim, composition is as efficient as inheritance.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : La composici&amp;oacute;n ( &lt;em&gt;tiene una&lt;/em&gt; relaci&amp;oacute;n) es a menudo preferible a la herencia ( &lt;em&gt;es una&lt;/em&gt; relaci&amp;oacute;n) para la reutilizaci&amp;oacute;n de c&amp;oacute;digo simple. Dado que los objetos son tipos de valor en Nim, la composici&amp;oacute;n es tan eficiente como la herencia.</target>
        </trans-unit>
        <trans-unit id="0f588e4000ab499174937baf99ba9de907f81477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Concepts are still in development.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los conceptos a&amp;uacute;n est&amp;aacute;n en desarrollo.</target>
        </trans-unit>
        <trans-unit id="af0cb2698b6f62001c812557400b5666b24c541b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently exceptions are not propagated between &lt;code&gt;spawn&lt;/code&gt;'ed tasks!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : En la actualidad excepciones no se propagan entre &lt;code&gt;spawn&lt;/code&gt; 'ed tareas!</target>
        </trans-unit>
        <trans-unit id="e593de705b48a873244d353e72e0630bbbf7e8ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the compiler recognizes but ignores this pragma.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Actualmente, el compilador reconoce pero ignora este pragma.</target>
        </trans-unit>
        <trans-unit id="1b2d5b76dbe4b87b85248e2c9cb6a142ec8c770f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the creation of &lt;code&gt;nimrtl.dll&lt;/code&gt; with thread support has never been tested and is unlikely to work!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Actualmente, la creaci&amp;oacute;n de &lt;code&gt;nimrtl.dll&lt;/code&gt; con soporte para subprocesos nunca se ha probado y es poco probable que funcione.</target>
        </trans-unit>
        <trans-unit id="fb2822c93615d44b3b3cc5966ff533ff418b8724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Destructors are still experimental and the spec might change significantly in order to incorporate an escape analysis.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los destructores a&amp;uacute;n son experimentales y la especificaci&amp;oacute;n puede cambiar significativamente para incorporar un an&amp;aacute;lisis de escape.</target>
        </trans-unit>
        <trans-unit id="ee1ed6db845c184364f8097a01163d56d39e9c4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Dot operators are still experimental and so need to be enabled via &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los operadores de &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt; todav&amp;iacute;a son experimentales y, por lo tanto, deben habilitarse mediante {.experimental: &quot;dotOperators&quot;.} .</target>
        </trans-unit>
        <trans-unit id="76687951273781b82f6f05a64604534fc897b54a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For SSL sockets, the &lt;code&gt;handshake&lt;/code&gt; procedure must be called whenever the socket successfully connects to a server.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Para los sockets SSL, se debe llamar al procedimiento de &lt;code&gt;handshake&lt;/code&gt; siempre que el socket se conecte con &amp;eacute;xito a un servidor.</target>
        </trans-unit>
        <trans-unit id="91e3db899bae0bbfb9a7d3d39b2d7c168b6e2d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;stmt&lt;/code&gt; is an alias for &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;expr&lt;/code&gt; an alias for &lt;code&gt;untyped&lt;/code&gt;, but new code should use the newer, clearer names.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Por razones hist&amp;oacute;ricas, &lt;code&gt;stmt&lt;/code&gt; es un alias para &lt;code&gt;typed&lt;/code&gt; y &lt;code&gt;expr&lt;/code&gt; un alias para &lt;code&gt;untyped&lt;/code&gt; , pero el c&amp;oacute;digo nuevo debe usar los nombres m&amp;aacute;s nuevos y claros.</target>
        </trans-unit>
        <trans-unit id="35fa8c02b68bd348136724f65366d5d42363838f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;varargs[expr]&lt;/code&gt; is not equivalent to &lt;code&gt;varargs[untyped]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Por razones hist&amp;oacute;ricas, &lt;code&gt;varargs[expr]&lt;/code&gt; no es equivalente a &lt;code&gt;varargs[untyped]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc5314fa7beb1755c498007976fd6bffd4a8741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim computes a SHA1 checksum and only recompiles the file if it has changed. You can use the &lt;code&gt;-f&lt;/code&gt; command line option to force recompilation of the file.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Nim calcula una suma de comprobaci&amp;oacute;n SHA1 y solo vuelve a compilar el archivo si ha cambiado. Puede usar la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;-f&lt;/code&gt; para forzar la recompilaci&amp;oacute;n del archivo.</target>
        </trans-unit>
        <trans-unit id="1271bb2722e7587eff37d0ec7806e796871dfb12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Openarrays can only be used for parameters.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Openarrays solo se puede utilizar para par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="69090e5eea8eeff4b4d6ed39bda4ed8ea1e00303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Passing variables to the &lt;code&gt;dynlib&lt;/code&gt; pragma will fail at runtime because of order of initialization problems.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : El paso de variables a &lt;code&gt;dynlib&lt;/code&gt; pragma fallar&amp;aacute; en tiempo de ejecuci&amp;oacute;n debido a problemas de orden de inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3d949419e5e8c75fc524d73127b46fd0d96b06e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Patterns like &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; are only supported in constant strings, because they are precompiled.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Patrones como &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; solo se admiten en cadenas constantes, porque est&amp;aacute;n precompilados.</target>
        </trans-unit>
        <trans-unit id="5c87c54173a7af7c54802abf0f3667ebc67c0bd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Read/write tracking is not yet implemented!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &amp;iexcl;El seguimiento de lectura / escritura a&amp;uacute;n no est&amp;aacute; implementado!</target>
        </trans-unit>
        <trans-unit id="935e75468fab30bc8f181842cd16bcdfa062c5e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;.this&lt;/code&gt; pragma is deprecated and should not be used anymore.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &lt;code&gt;.this&lt;/code&gt; pragma est&amp;aacute; obsoleto y no deber&amp;iacute;a utilizarse m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="e111e86a91d15663eda5e4e58e22260484c13d8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; operations are available at compile-time!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &amp;iexcl;Las operaciones &lt;code&gt;to&lt;/code&gt; y &lt;code&gt;$$&lt;/code&gt; est&amp;aacute;n disponibles en tiempo de compilaci&amp;oacute;n!</target>
        </trans-unit>
        <trans-unit id="1f9fdb234ef8ab9ea0cd0ee243a725c77f4c3646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The asynchronous implementation is only asynchronous for long file transfers, calls to functions which use the command socket will block.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : La implementaci&amp;oacute;n as&amp;iacute;ncrona solo es as&amp;iacute;ncrona para transferencias de archivos largas, las llamadas a funciones que usan el comando socket se bloquear&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="21b5006b1c5b3e0551182aafd1ac04017eed31d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los tipos de datos declarados aqu&amp;iacute; tienen &lt;em&gt;sem&amp;aacute;ntica de valor&lt;/em&gt; : esto significa que &lt;code&gt;=&lt;/code&gt; realiza una copia del conjunto.</target>
        </trans-unit>
        <trans-unit id="280898b023d47a8c9d92f2a9764ba5070e544d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example only works because the memory is initialized to zero (&lt;code&gt;alloc0&lt;/code&gt; instead of &lt;code&gt;alloc&lt;/code&gt; does this): &lt;code&gt;d.s&lt;/code&gt; is thus initialized to binary zero which the string assignment can handle. One needs to know low level details like this when mixing garbage collected data with unmanaged memory.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : El ejemplo solo funciona porque la memoria se inicializa a cero ( &lt;code&gt;alloc0&lt;/code&gt; en lugar de &lt;code&gt;alloc&lt;/code&gt; hace esto): as&amp;iacute;, &lt;code&gt;d.s&lt;/code&gt; se inicializa a cero binario que la asignaci&amp;oacute;n de cadena puede manejar. Es necesario conocer detalles de bajo nivel como este al mezclar datos recolectados de basura con memoria no administrada.</target>
        </trans-unit>
        <trans-unit id="47964f4e63f9364071ab4aeb6d699ff7f8c08bcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--assumedef&lt;/code&gt; and &lt;code&gt;--assumendef&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay opciones de l&amp;iacute;nea de comando &lt;code&gt;--assumedef&lt;/code&gt; y &lt;code&gt;--assumendef&lt;/code&gt; que pueden usarse para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="beec5a850cfc6f7745e1b0ecb5a58d4d3717ffad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--prefix&lt;/code&gt; and &lt;code&gt;--suffix&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay opciones de l&amp;iacute;nea de comando &lt;code&gt;--prefix&lt;/code&gt; y &lt;code&gt;--suffix&lt;/code&gt; que se pueden usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="69ba15cf193dfbb62171a2742d239684c78daa69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--stdcall&lt;/code&gt; and &lt;code&gt;--cdecl&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay opciones de l&amp;iacute;nea de comando &lt;code&gt;--stdcall&lt;/code&gt; y &lt;code&gt;--cdecl&lt;/code&gt; que se pueden usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="6eae5a3b83fbed6b6c57ab8bbef30bd246b16faa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are two approaches to parameter substitution support by this module.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Hay dos enfoques para el soporte de sustituci&amp;oacute;n de par&amp;aacute;metros en este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="a5a42997a6733b871213621a8b95f824a807c7b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--dynlib&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--dynlib&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="7af996a9b1410d0551b826fcf6f31d2982be4597" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--header&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--header&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="0f6e6a5551e301a9206be409821f73e8efe724ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipcomments&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--skipcomments&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="24001770e3fa5f62c6de4221e4016da922b0b6b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipinclude&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--skipinclude&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="2a3d0067cf0a534d5914217a3b18410a03771aa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--typeprefixes&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--typeprefixes&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="e18e21cf48841adbc9777187ae8968f7fba53e98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This document is a draft! Several of Nim's features may need more precise wording. This manual is constantly evolving into a proper specification.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &amp;iexcl;Este documento es un borrador! Varias de las caracter&amp;iacute;sticas de Nim pueden necesitar una redacci&amp;oacute;n m&amp;aacute;s precisa. Este manual evoluciona constantemente hacia una especificaci&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="054e7ea2fe4b0d2089c5eb61f38663920957149a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level function, you may be interested in the higher level versions of this function which are also named &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esta es una funci&amp;oacute;n de bajo nivel, puede que le interesen las versiones de nivel superior de esta funci&amp;oacute;n que tambi&amp;eacute;n se denominan &lt;code&gt;recv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5282ba94e7660dfc3a29bcd1eed3c48d245d27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level version of &lt;code&gt;send&lt;/code&gt;. You likely should use the version below.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta es una versi&amp;oacute;n de bajo nivel de &lt;code&gt;send&lt;/code&gt; . Probablemente deber&amp;iacute;a utilizar la versi&amp;oacute;n siguiente.</target>
        </trans-unit>
        <trans-unit id="a69e35e7b9f3081695456106f46697c03ffedd82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This module is deprecated since version 0.11.3. You should use the async version of this module &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este m&amp;oacute;dulo est&amp;aacute; obsoleto desde la versi&amp;oacute;n 0.11.3. Debe utilizar la versi&amp;oacute;n as&amp;iacute;ncrona de este m&amp;oacute;dulo &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2aa27f677d4a034cdeb59f9e8f5be392614db71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma should only be used by procs which consist solely of assembler statements.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este pragma solo debe ser utilizado por procesos que constan &amp;uacute;nicamente de declaraciones de ensamblador.</target>
        </trans-unit>
        <trans-unit id="c3942176661636505e686cd1e170c9c2c66c7838" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma will not exist for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : este pragma no existir&amp;aacute; para el backend LLVM.</target>
        </trans-unit>
        <trans-unit id="e370238e58db64e0d5e09298f252112f6df12b8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure is mostly used for testing. You likely want to use &lt;code&gt;asyncnet.recvLine&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : este procedimiento se utiliza principalmente para realizar pruebas. Es probable que desee utilizar &lt;code&gt;asyncnet.recvLine&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="322b2c09d6ee80b4e8d9ee5e387bb8ede9f8c9b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure will &lt;strong&gt;NOT&lt;/strong&gt; register &lt;code&gt;fd&lt;/code&gt; with the global async dispatcher. You need to do this manually. If you have used &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; to create &lt;code&gt;fd&lt;/code&gt; then it's already registered.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este procedimiento &lt;strong&gt;NO&lt;/strong&gt; registrar&amp;aacute; &lt;code&gt;fd&lt;/code&gt; con el despachador as&amp;iacute;ncrono global. Necesita hacer esto manualmente. Si ha utilizado &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; para crear &lt;code&gt;fd&lt;/code&gt; , entonces ya est&amp;aacute; registrado.</target>
        </trans-unit>
        <trans-unit id="d932869f99df24b8242ec488c4a11db3770fcfc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will not work for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esto no funcionar&amp;aacute; para el backend LLVM.</target>
        </trans-unit>
        <trans-unit id="36372381e9ac840b308a26506bae63970c747486" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will set &lt;code&gt;sock&lt;/code&gt; to be non-blocking.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esto configurar&amp;aacute; el &lt;code&gt;sock&lt;/code&gt; para que no bloquee.</target>
        </trans-unit>
        <trans-unit id="1223df2703569d7a264f78da6a04381483fe3ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: static[T] is still in development.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : est&amp;aacute;tica [T] todav&amp;iacute;a est&amp;aacute; en desarrollo.</target>
        </trans-unit>
        <trans-unit id="cfc7fae090374e3f5581cc6d980013b1b5608dd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this proc does not exist while using the JS backend.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : este proceso no existe mientras se usa el backend JS.</target>
        </trans-unit>
        <trans-unit id="3999835082895c400051c08efff687fac9d5116a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance note&lt;/strong&gt;: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</source>
          <target state="translated">&lt;strong&gt;Nota de rendimiento&lt;/strong&gt; : Nim no produce una tabla de m&amp;eacute;todo virtual, pero genera &amp;aacute;rboles de despacho. Esto evita la costosa rama indirecta para las llamadas a m&amp;eacute;todos y permite la inserci&amp;oacute;n. Sin embargo, otras optimizaciones como la evaluaci&amp;oacute;n del tiempo de compilaci&amp;oacute;n o la eliminaci&amp;oacute;n de c&amp;oacute;digo muerto no funcionan con m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="23e826b6b4ecba08efbc3138c61cefb888e1c674" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please do not use this&lt;/strong&gt;: On Android, it currently returns &lt;code&gt;getHomeDir()&lt;/code&gt;, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; to your compiler invokation.</source>
          <target state="translated">&lt;strong&gt;No utilice esto&lt;/strong&gt; : en Android, actualmente devuelve &lt;code&gt;getHomeDir()&lt;/code&gt; , y en otros sistemas basados ​​en Unix tambi&amp;eacute;n puede causar problemas de seguridad. Dicho esto, puede anular esta implementaci&amp;oacute;n agregando &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; a la invocaci&amp;oacute;n de su compilador.</target>
        </trans-unit>
        <trans-unit id="af53126db5be4c8aab90d27d5734b3708b192d3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restriction&lt;/strong&gt;: For objects their type is &lt;strong&gt;not&lt;/strong&gt; serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type:</source>
          <target state="translated">&lt;strong&gt;Restricci&amp;oacute;n&lt;/strong&gt; : para los objetos, su tipo &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; serializado. Esto significa esencialmente que no funciona si el objeto tiene alg&amp;uacute;n otro tipo de tiempo de ejecuci&amp;oacute;n que su tipo de tiempo de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="92e0079e41a5b0f8de60d18697948189f4c07fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Style note&lt;/strong&gt;: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</source>
          <target state="translated">&lt;strong&gt;Nota de estilo&lt;/strong&gt; : para la legibilidad del c&amp;oacute;digo, es la mejor idea usar la construcci&amp;oacute;n de programaci&amp;oacute;n menos poderosa que a&amp;uacute;n sea suficiente. Entonces, la &quot;lista de verificaci&amp;oacute;n&quot; es:</target>
        </trans-unit>
        <trans-unit id="fe1515dd837d06ebdfb95963f4b433b9a9c3985a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + const name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre constante.</target>
        </trans-unit>
        <trans-unit id="89fa1ce97e4b1a8bbc8a7bdf79f0c84b5531d6c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + enum type + enum field name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + tipo de enumeraci&amp;oacute;n + nombre de campo de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="44cc69c566e0009f6ccc0fbac4d3567a0268b727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + iterator name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del iterador.</target>
        </trans-unit>
        <trans-unit id="821988216adbe7cd1954ec0da5648027ef8dc44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + let name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de let.</target>
        </trans-unit>
        <trans-unit id="57a25e461776b40d157a649de93257f5fe549d65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + macro name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de macro.</target>
        </trans-unit>
        <trans-unit id="3166d2d68e6f9702d538e16e0e365a37f0f31329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + method name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="061167cd91100dd105e9d11351199c7b83c16430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre.</target>
        </trans-unit>
        <trans-unit id="acf85825d2dfb7a2233737f8ada9679976415f1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + param name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="546e3a8202699c79b7b925592249d4072a1845aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + proc name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del proceso.</target>
        </trans-unit>
        <trans-unit id="e1aaee074e6af2e4ed1a60de85b378cc36322c99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + result.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + resultado.</target>
        </trans-unit>
        <trans-unit id="ca9583e48baa25b1239a744bd75804685b9425dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + template name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de plantilla.</target>
        </trans-unit>
        <trans-unit id="e445dd6209bef0d057963888553bf05a22332bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + type name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del tipo.</target>
        </trans-unit>
        <trans-unit id="0e96cb006b66e97d61d546d8e4a627270ae7af33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + var name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de var.</target>
        </trans-unit>
        <trans-unit id="96622873fb587ed595611ae4d0e283ece6697a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is deprecated and should not be used&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Est&amp;aacute; en desuso y no debe utilizarse&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9df7eca11b12855add51f036ea9d3d1ea8ae1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage in JavaScript projects:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Uso en proyectos de JavaScript:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4316d6405c9f4c9d98f6e1f272b469fd25904ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Use it with caution. If &lt;code&gt;buf&lt;/code&gt; refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.</source>
          <target state="translated">&lt;strong&gt;ADVERTENCIA&lt;/strong&gt; : &amp;Uacute;selo con precauci&amp;oacute;n. Si &lt;code&gt;buf&lt;/code&gt; se refiere a un objeto GC'ed, debe usar llamadas GC_ref / GC_unref para evitar la liberaci&amp;oacute;n anticipada del b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="5f8f9514a22b55ff9c78136da9ef8a81f67b0108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; Si el proceso no ha terminado de ejecutarse, esto terminar&amp;aacute; forzosamente el proceso. Hacerlo puede resultar en procesos zombies y &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;fugas de pty&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7648a978c3c5b08aa7a942fe439314fcbbd9e17c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; It's not recommended to use &lt;code&gt;between&lt;/code&gt; for &lt;code&gt;DateTime's&lt;/code&gt; in different &lt;code&gt;TimeZone's&lt;/code&gt;. &lt;code&gt;a + between(a, b) == b&lt;/code&gt; is only guaranteed when &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in UTC.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; No se recomienda usar &lt;code&gt;between&lt;/code&gt; para &lt;code&gt;DateTime's&lt;/code&gt; en diferentes &lt;code&gt;TimeZone's&lt;/code&gt; . &lt;code&gt;a + between(a, b) == b&lt;/code&gt; solo se garantiza cuando &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; est&amp;aacute;n en UTC.</target>
        </trans-unit>
        <trans-unit id="d0a52c8fdc83d67244f36d1e45904b31b08be93b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since version 0.10.2 this module is deprecated. Use the &lt;a href=&quot;net&quot;&gt;net&lt;/a&gt; or the &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; Desde la versi&amp;oacute;n 0.10.2, este m&amp;oacute;dulo est&amp;aacute; obsoleto. En su lugar, utilice el m&amp;oacute;dulo &lt;a href=&quot;net&quot;&gt;net&lt;/a&gt; o &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9968b14e6044d19bea13d96a6048dbd5746bc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The &lt;code&gt;total&lt;/code&gt; reported by httpclient may be 0 in some cases.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; El &lt;code&gt;total&lt;/code&gt; informado por httpclient puede ser 0 en algunos casos.</target>
        </trans-unit>
        <trans-unit id="24b0c00e568f6b8e8da0f3bc2db0c76c857a200b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The API of this module is unstable, and therefore is subject to change.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; la API de este m&amp;oacute;dulo es inestable y, por lo tanto, est&amp;aacute; sujeta a cambios.</target>
        </trans-unit>
        <trans-unit id="9d0af0517916216290aedd9e00253fb0aa629d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The buffer &lt;em&gt;a&lt;/em&gt; must be pre-allocated. This can be done using, for example, &lt;code&gt;newString&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; El b&amp;uacute;fer &lt;em&gt;a&lt;/em&gt; debe estar preasignado. Esto se puede hacer usando, por ejemplo, &lt;code&gt;newString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0520baa64a72e7ee0281b0ddd067f506549b20a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The global list of handlers is a thread var, this means that the handlers must be re-added in each thread. &lt;strong&gt;Warning:&lt;/strong&gt; When logging on disk or console, only error and fatal messages are flushed out immediately. Use flushFile() where needed.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; La lista global de controladores es una var de subproceso, esto significa que los controladores deben volver a agregarse en cada subproceso. &lt;strong&gt;Advertencia:&lt;/strong&gt; al iniciar sesi&amp;oacute;n en el disco o la consola, solo los mensajes de error y fatales se eliminan de inmediato. Utilice flushFile () donde sea necesario.</target>
        </trans-unit>
        <trans-unit id="1de5e055501cd9543ed70f0688cbf30ac70cdc1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This function does not yet have a buffered implementation, so when &lt;code&gt;socket&lt;/code&gt; is buffered the non-buffered implementation will be used. Therefore if &lt;code&gt;socket&lt;/code&gt; contains something in its buffer this function will make no effort to return it.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; esta funci&amp;oacute;n a&amp;uacute;n no tiene una implementaci&amp;oacute;n en b&amp;uacute;fer, por lo que cuando el &lt;code&gt;socket&lt;/code&gt; est&amp;aacute; en b&amp;uacute;fer, se utilizar&amp;aacute; la implementaci&amp;oacute;n sin b&amp;uacute;fer. Por lo tanto, si &lt;code&gt;socket&lt;/code&gt; contiene algo en su b&amp;uacute;fer, esta funci&amp;oacute;n no har&amp;aacute; ning&amp;uacute;n esfuerzo por devolverlo.</target>
        </trans-unit>
        <trans-unit id="854f87e513637b6e9a5ac650c51cff41b8f768e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.10.2. Use the brand new &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; module together with the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo est&amp;aacute; obsoleto desde la versi&amp;oacute;n 0.10.2. Utilice el nuevo m&amp;oacute;dulo &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; junto con el m&amp;oacute;dulo &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0b3c2a66d1cb7f1d4a063b94c4ce6ca1f2543b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.14.0.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo est&amp;aacute; obsoleto desde la versi&amp;oacute;n 0.14.0.</target>
        </trans-unit>
        <trans-unit id="7eb0dfd155d4b6f3b53e214b0ecc3fdf13f08633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated, use the SSL procedures defined in the &lt;code&gt;net&lt;/code&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo est&amp;aacute; obsoleto, utilice los procedimientos SSL definidos en el m&amp;oacute;dulo de &lt;code&gt;net&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c5666a07ce3875934c4c4fc973b2a781936f5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module only supports the old asynchronous interface. You may wish to use the &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; instead for web applications.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo solo es compatible con la antigua interfaz as&amp;iacute;ncrona. Es posible que desee utilizar &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; en su lugar para aplicaciones web.</target>
        </trans-unit>
        <trans-unit id="53266ecbd11ce935a7868dc21f59beb46ccb3aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When using SSL with non-blocking sockets, it is best to use the acceptAddrSSL procedure as this procedure will most likely block.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; Cuando utilice SSL con sockets sin bloqueo, es mejor utilizar el procedimiento acceptAddrSSL ya que es muy probable que este procedimiento bloquee.</target>
        </trans-unit>
        <trans-unit id="808a8a1028dc1fed134e205c55ec27d7dd5b23fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLine&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &lt;code&gt;recvLine&lt;/code&gt; en sockets sin b&amp;uacute;fer asume que el protocolo usa &lt;code&gt;\r\L&lt;/code&gt; para delimitar una nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="ac11ca7b54f8ac76331d539b39687d412032a370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLineInto&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &lt;code&gt;recvLineInto&lt;/code&gt; en sockets sin b&amp;uacute;fer asume que el protocolo usa &lt;code&gt;\r\L&lt;/code&gt; para delimitar una nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="5d163b20a95cadf02bed8abe7ed680f87b2b48bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : Tenga cuidado al usar waitForSalir para procesos creados sin poParentStreams porque pueden llenar b&amp;uacute;feres de salida, causando un punto muerto.</target>
        </trans-unit>
        <trans-unit id="0163b79bd484845ef77cdbb23264a20232b50266" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: If &lt;code&gt;state&lt;/code&gt; is set incorrectly the resulting &lt;code&gt;AsyncSocket&lt;/code&gt; object may not work properly.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : si el &lt;code&gt;state&lt;/code&gt; se establece incorrectamente, es &lt;code&gt;AsyncSocket&lt;/code&gt; objeto AsyncSocket resultante no funcione correctamente.</target>
        </trans-unit>
        <trans-unit id="6f6766ee200b64744878c681dde8b968c6f670b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is currently supported.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : actualmente solo se admite el indicador &lt;code&gt;SafeDisconn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5179a287236e2707d51c8ae92986184ef63e00df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only use this if you know what you are doing.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : solo use esto si sabe lo que est&amp;aacute; haciendo.</target>
        </trans-unit>
        <trans-unit id="b8ef80f1f143a1f7de2004bb4e9cee1fed78e787" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : algunos sistemas operativos (como Microsoft Windows) restringen la creaci&amp;oacute;n de enlaces simb&amp;oacute;licos a los usuarios root (administradores).</target>
        </trans-unit>
        <trans-unit id="1f61c1a4fea430f13537ed29d0765d587962a8f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's restrict the creation of hard links to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : algunos sistemas operativos restringen la creaci&amp;oacute;n de enlaces f&amp;iacute;sicos a usuarios root (administradores).</target>
        </trans-unit>
        <trans-unit id="f9012f1b5937f6027293c08f92583d61921af08c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; flag is not yet implemented.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : la bandera &lt;code&gt;Peek&lt;/code&gt; a&amp;uacute;n no est&amp;aacute; implementada.</target>
        </trans-unit>
        <trans-unit id="e86c259d83ff7290e4d751971a6fa6a8870f2e71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; socket flag is not supported on Windows.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : el indicador de socket &lt;code&gt;Peek&lt;/code&gt; no es compatible con Windows.</target>
        </trans-unit>
        <trans-unit id="67b4583abc34f87fcf6eff4869eef2bfd28629d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;em&gt;tmpl&lt;/em&gt; argument is written to by &lt;em&gt;mkstemp&lt;/em&gt; and thus can't be a string literal. If in doubt copy the string before passing it.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &lt;em&gt;mkstemp escribe en el&lt;/em&gt; argumento &lt;em&gt;tmpl&lt;/em&gt; y, por lo tanto, no puede ser una cadena literal. En caso de duda, copie la cadena antes de pasarla.</target>
        </trans-unit>
        <trans-unit id="eae8834fd1ff75f9c078051184e01727261e31cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The resulting &lt;code&gt;ptr AddrInfo&lt;/code&gt; must be freed using &lt;code&gt;freeAddrInfo&lt;/code&gt;!</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &amp;iexcl;El &lt;code&gt;ptr AddrInfo&lt;/code&gt; resultante debe liberarse usando &lt;code&gt;freeAddrInfo&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="9e788c203930a853b492baa9fb790e0baaa6f689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;FileHandle&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : El &lt;em&gt;FileHandle&lt;/em&gt; devuelto no debe cerrarse manualmente ya que se cierra al cerrar el Proceso &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35816baa23c24b5f9e80530b286a99de07763458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;Stream&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : El &lt;em&gt;Stream&lt;/em&gt; devuelto no debe cerrarse manualmente ya que se cierra al cerrar el Proceso &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="070d8f77f83eff23785cd22229e7c7593a9f015a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This assumes that lines are delimited by &lt;code&gt;\r\L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : Esto supone que las l&amp;iacute;neas est&amp;aacute;n delimitados por &lt;code&gt;\r\L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9df6a23fa581b51ba2e0e996ce854f48568ec52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This function may give unexpected or completely wrong results on Windows.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : esta funci&amp;oacute;n puede dar resultados inesperados o completamente incorrectos en Windows.</target>
        </trans-unit>
        <trans-unit id="016fcff66b49f260c1c428fc4a770e9ba587d905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This module uses &lt;code&gt;immediate&lt;/code&gt; macros which are known to cause problems. Do yourself a favor and import the module as &lt;code&gt;from htmlgen import nil&lt;/code&gt; and then fully qualify the macros.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : este m&amp;oacute;dulo utiliza macros &lt;code&gt;immediate&lt;/code&gt; que se sabe que causan problemas. H&amp;aacute;gase un favor e importe el m&amp;oacute;dulo &lt;code&gt;from htmlgen import nil&lt;/code&gt; y luego califique completamente las macros.</target>
        </trans-unit>
        <trans-unit id="1ee8bac63489b4b65f1d77d36e0156115bbf2067" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see &quot;Locale support&quot; in the pcreapi page). For example, in the &quot;fr_FR&quot; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by &lt;code&gt;\w&lt;/code&gt;.</source>
          <target state="translated">Un car&amp;aacute;cter de &quot;palabra&quot; es un gui&amp;oacute;n bajo o cualquier car&amp;aacute;cter menor de 256 que sea una letra o un d&amp;iacute;gito. La definici&amp;oacute;n de letras y d&amp;iacute;gitos est&amp;aacute; controlada por las tablas de caracteres de bajo valor de PCRE, y puede variar si se lleva a cabo una coincidencia espec&amp;iacute;fica de la configuraci&amp;oacute;n regional (consulte &quot;Soporte de configuraci&amp;oacute;n regional&quot; en la p&amp;aacute;gina de pcreapi). Por ejemplo, en la configuraci&amp;oacute;n regional &quot;fr_FR&quot; (franc&amp;eacute;s), algunos c&amp;oacute;digos de caracteres superiores a 128 se utilizan para letras acentuadas, y estos se corresponden con &lt;code&gt;\w&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaba2403682a17469ecab3c6f2cc502e7be26d2b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HttpRequestError&lt;/code&gt; will be raised if the server responds with a client error (status code 4xx) or a server error (status code 5xx).</source>
          <target state="translated">Se generar&amp;aacute; un error &lt;code&gt;HttpRequestError&lt;/code&gt; si el servidor responde con un error del cliente (c&amp;oacute;digo de estado 4xx) o un error del servidor (c&amp;oacute;digo de estado 5xx).</target>
        </trans-unit>
        <trans-unit id="d81d68641d8bf3ceba1aef0cf067b5ab815956a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ValueError&lt;/code&gt; exception will be raised if the value is not an integer.</source>
          <target state="translated">Se &lt;code&gt;ValueError&lt;/code&gt; excepci&amp;oacute;n ValueError si el valor no es un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="49a6495aba25fcc0345009a64738a98f0c760abf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;block&lt;/code&gt; doesn't need an name, in which case &lt;code&gt;nnkEmpty&lt;/code&gt; is used.</source>
          <target state="translated">Un &lt;code&gt;block&lt;/code&gt; no necesita un nombre, en cuyo caso se usa &lt;code&gt;nnkEmpty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde4d27b77941b8a2e8d7b668c0d8b482525e40c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;closure&lt;/code&gt; proc var can call ordinary procs of the default Nim calling convention. But not the other way round! A closure is implemented as a &lt;code&gt;tuple[prc, env]&lt;/code&gt;. &lt;code&gt;env&lt;/code&gt; can be nil implying a call without a closure. This means that a call through a closure generates an &lt;code&gt;if&lt;/code&gt; but the interoperability is worth the cost of the &lt;code&gt;if&lt;/code&gt;. Thunk generation would be possible too, but it's slightly more effort to implement.</source>
          <target state="translated">Un proceso de &lt;code&gt;closure&lt;/code&gt; var puede llamar procesos ordinarios de la convenci&amp;oacute;n de llamada predeterminada de Nim. &amp;iexcl;Pero no al rev&amp;eacute;s! Un cierre se implementa como una &lt;code&gt;tuple[prc, env]&lt;/code&gt; . &lt;code&gt;env&lt;/code&gt; puede ser nil, lo que implica una llamada sin un cierre. Esto significa que una llamada a trav&amp;eacute;s de un cierre genera un &lt;code&gt;if&lt;/code&gt; pero la interoperabilidad vale el costo del &lt;code&gt;if&lt;/code&gt; . La generaci&amp;oacute;n de thunk tambi&amp;eacute;n ser&amp;iacute;a posible, pero su implementaci&amp;oacute;n requiere un poco m&amp;aacute;s de esfuerzo.</target>
        </trans-unit>
        <trans-unit id="46ca6bf4504c12b38f73b70158bd4cc5686ceec6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;continue&lt;/code&gt; statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:</source>
          <target state="translated">Una instrucci&amp;oacute;n &lt;code&gt;continue&lt;/code&gt; conduce a la siguiente iteraci&amp;oacute;n inmediata de la construcci&amp;oacute;n de bucle circundante. Solo est&amp;aacute; permitido dentro de un bucle. Una instrucci&amp;oacute;n continue es az&amp;uacute;car sint&amp;aacute;ctica para un bloque anidado:</target>
        </trans-unit>
        <trans-unit id="fa532fc8ce7dbe2864f24cd2a27ac73e6fc36afd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;distinct&lt;/code&gt; type is new type derived from a &lt;span id=&quot;base-type_1&quot;&gt;base type&lt;/span&gt; that is incompatible with its base type. In particular, it is an essential property of a distinct type that it &lt;strong&gt;does not&lt;/strong&gt; imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also &lt;code&gt;distinctBase&lt;/code&gt; to get the reverse operation.</source>
          <target state="translated">Un tipo &lt;code&gt;distinct&lt;/code&gt; es un tipo nuevo derivado de un &lt;span id=&quot;base-type_1&quot;&gt;tipo base&lt;/span&gt; que es incompatible con su tipo base. En particular, es una propiedad esencial de un tipo distinto que &lt;strong&gt;no&lt;/strong&gt; implica una relaci&amp;oacute;n de subtipo entre &amp;eacute;l y su tipo base. Se permiten las conversiones de tipo expl&amp;iacute;cito de un tipo diferenciado a su tipo base y viceversa. Consulte tambi&amp;eacute;n &lt;code&gt;distinctBase&lt;/code&gt; para obtener la operaci&amp;oacute;n inversa.</target>
        </trans-unit>
        <trans-unit id="fec0b8e4f99548ff52eae3d0e8ec4be16fcde6a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; statement declares new local and global &lt;span id=&quot;single-assignment_1&quot;&gt;single assignment&lt;/span&gt; variables and binds a value to them. The syntax is the same as that of the &lt;code&gt;var&lt;/code&gt; statement, except that the keyword &lt;code&gt;var&lt;/code&gt; is replaced by the keyword &lt;code&gt;let&lt;/code&gt;. Let variables are not l-values and can thus not be passed to &lt;code&gt;var&lt;/code&gt; parameters nor can their address be taken. They cannot be assigned new values.</source>
          <target state="translated">Una instrucci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; declara nuevas variables de &lt;span id=&quot;single-assignment_1&quot;&gt;asignaci&amp;oacute;n &amp;uacute;nica&lt;/span&gt; locales y globales y les vincula un valor. La sintaxis es la misma que la de la instrucci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; , excepto que la palabra clave &lt;code&gt;var&lt;/code&gt; se reemplaza por la palabra clave &lt;code&gt;let&lt;/code&gt; . Dejemos que las variables no sean valores l y, por lo tanto, no se pueden pasar a par&amp;aacute;metros &lt;code&gt;var&lt;/code&gt; ni se puede tomar su direcci&amp;oacute;n. No se les pueden asignar nuevos valores.</target>
        </trans-unit>
        <trans-unit id="8fe78b3a2821fa1451c04e1ee9b03eb161700c9d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;raises&lt;/code&gt; list can also be attached to a proc type. This affects type compatibility:</source>
          <target state="translated">Una &lt;code&gt;raises&lt;/code&gt; lista tambi&amp;eacute;n se puede conectar a un tipo proc. Esto afecta la compatibilidad de tipos:</target>
        </trans-unit>
        <trans-unit id="c8cb08453579d0f15d45b19ab781ad1eab51f587" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is an openarray parameter that additionally allows to pass a variable number of arguments to a procedure. The compiler converts the list of arguments to an array implicitly:</source>
          <target state="translated">Un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; es un par&amp;aacute;metro openarray que adem&amp;aacute;s permite pasar un n&amp;uacute;mero variable de argumentos a un procedimiento. El compilador convierte la lista de argumentos en una matriz impl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="9932ed67f0c5e1f713b0339fd155b7567d8b4c9b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:</source>
          <target state="translated">Un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; es como un par&amp;aacute;metro openarray. Sin embargo, tambi&amp;eacute;n es un medio para implementar el paso de un n&amp;uacute;mero variable de argumentos a un procedimiento. El compilador convierte la lista de argumentos en una matriz autom&amp;aacute;ticamente:</target>
        </trans-unit>
        <trans-unit id="e982b06375e4d6cb9864cbab229ee93da8102df8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;$&lt;/em&gt; proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</source>
          <target state="translated">Se define un &lt;em&gt;$&lt;/em&gt; proc para cstrings que devuelve una cadena. Por lo tanto, para obtener una cadena nim de un cstring:</target>
        </trans-unit>
        <trans-unit id="4924981c6cf86467817a6848ae253feb1dd3d357" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Source Code Filter&lt;/em&gt; transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.</source>
          <target state="translated">Un &lt;em&gt;filtro de c&amp;oacute;digo fuente&lt;/em&gt; transforma el flujo de caracteres de entrada en un flujo de salida en memoria antes de analizar. Se puede utilizar un filtro para proporcionar sistemas de plantillas o preprocesadores.</target>
        </trans-unit>
        <trans-unit id="787f1149d9267dbcf887509536779010033aad01" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subex&lt;/em&gt; (&lt;em&gt;Substitution Expression&lt;/em&gt;) represents an advanced string substitution. In contrast to a &lt;span id=&quot;regex_1&quot;&gt;regex&lt;/span&gt; which deals with string analysis, a &lt;em&gt;subex&lt;/em&gt; deals with string synthesis.</source>
          <target state="translated">Un &lt;em&gt;subex&lt;/em&gt; ( &lt;em&gt;expresi&amp;oacute;n de sustituci&amp;oacute;n&lt;/em&gt; ) representa una sustituci&amp;oacute;n de cadena avanzada. A diferencia de una &lt;span id=&quot;regex_1&quot;&gt;expresi&amp;oacute;n regular&lt;/span&gt; que se ocupa del an&amp;aacute;lisis de cadenas, un &lt;em&gt;subex se&lt;/em&gt; ocupa de la s&amp;iacute;ntesis de cadenas.</target>
        </trans-unit>
        <trans-unit id="889eb097f34d2cb2326af79e37dd19352cd4b767" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;checked-runtime-error_1&quot;&gt;checked runtime error&lt;/span&gt; is an error that the implementation detects and reports at runtime. The method for reporting such errors is via &lt;em&gt;raising exceptions&lt;/em&gt; or &lt;em&gt;dying with a fatal error&lt;/em&gt;. However, the implementation provides a means to disable these runtime checks. See the section &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; for details.</source>
          <target state="translated">Un &lt;span id=&quot;checked-runtime-error_1&quot;&gt;error de tiempo de ejecuci&amp;oacute;n verificado&lt;/span&gt; es un error que la implementaci&amp;oacute;n detecta y notifica durante el tiempo de ejecuci&amp;oacute;n. El m&amp;eacute;todo para informar tales errores es &lt;em&gt;generar excepciones&lt;/em&gt; o &lt;em&gt;morir con un error fatal&lt;/em&gt; . Sin embargo, la implementaci&amp;oacute;n proporciona un medio para desactivar estas comprobaciones en tiempo de ejecuci&amp;oacute;n. Consulte la secci&amp;oacute;n &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="31c99118ea561948c45f870ebd2c2cce4b7b646d" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;guard_1&quot;&gt;guard&lt;/span&gt; annotation is introduced to prevent data races.</source>
          <target state="translated">Se introduce una anotaci&amp;oacute;n de &lt;span id=&quot;guard_1&quot;&gt;guardia&lt;/span&gt; para evitar carreras de datos.</target>
        </trans-unit>
        <trans-unit id="386e659d1429b589f185720a9d5bf0ba95205db0" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;narrowing type conversion&lt;/span&gt; converts a larger to a smaller type (for example &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt;. A &lt;span id=&quot;widening-type-conversion_1&quot;&gt;widening type conversion&lt;/span&gt; converts a smaller type to a larger type (for example &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt;). In Nim only widening type conversions are &lt;em&gt;implicit&lt;/em&gt;:</source>
          <target state="translated">Una &lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;conversi&amp;oacute;n de&lt;/span&gt; tipo de &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt; convierte un tipo m&amp;aacute;s grande en uno m&amp;aacute;s peque&amp;ntilde;o (por ejemplo, int32 -&amp;gt; int16 . Una &lt;span id=&quot;widening-type-conversion_1&quot;&gt;conversi&amp;oacute;n de tipo de ampliaci&amp;oacute;n&lt;/span&gt; convierte un tipo m&amp;aacute;s peque&amp;ntilde;o en un tipo m&amp;aacute;s grande (por ejemplo, &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt; ). En Nim, solo las conversiones de tipo de ampliaci&amp;oacute;n son &lt;em&gt;impl&amp;iacute;citas&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="387048b351545e7cdb57e945c46d2fba04806529" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt; is an error that the implementation detects before program execution. Unless explicitly classified, an error is a static error.</source>
          <target state="translated">Un &lt;span id=&quot;static-error_1&quot;&gt;error est&amp;aacute;tico&lt;/span&gt; es un error que la implementaci&amp;oacute;n detecta antes de la ejecuci&amp;oacute;n del programa. A menos que se clasifique expl&amp;iacute;citamente, un error es un error est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="130e98a36d1ad0d5fa779c624d02b3795704ff33" translate="yes" xml:space="preserve">
          <source>A Distinct type allows for the creation of new type that &quot;does not imply a subtype relationship between it and its base type&quot;. You must &lt;strong&gt;explicitly&lt;/strong&gt; define all behaviour for the distinct type. To help with this, both the distinct type and its base type can cast from one type to the other. Examples are provided in the &lt;a href=&quot;manual#types-distinct-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Un tipo Distinto permite la creaci&amp;oacute;n de un nuevo tipo que &quot;no implica una relaci&amp;oacute;n de subtipo entre &amp;eacute;l y su tipo base&quot;. Debe definir &lt;strong&gt;expl&amp;iacute;citamente&lt;/strong&gt; todo el comportamiento del tipo diferenciado. Para ayudar con esto, tanto el tipo diferenciado como su tipo base pueden pasar de un tipo a otro. En el &lt;a href=&quot;manual#types-distinct-type&quot;&gt;manual&lt;/a&gt; se proporcionan ejemplos .</target>
        </trans-unit>
        <trans-unit id="79b065193cd9e9953658e8235e333843b91d5cf1" translate="yes" xml:space="preserve">
          <source>A Nim &lt;code&gt;string&lt;/code&gt; is implicitly convertible to &lt;code&gt;cstring&lt;/code&gt; for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to &lt;code&gt;cstring&lt;/code&gt; too:</source>
          <target state="translated">Una &lt;code&gt;string&lt;/code&gt; Nim se puede convertir impl&amp;iacute;citamente en &lt;code&gt;cstring&lt;/code&gt; por conveniencia. Si una cadena Nim se pasa a un proceso variadic de estilo C, tambi&amp;eacute;n se convierte impl&amp;iacute;citamente en &lt;code&gt;cstring&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="69460fedc7d49aa8bfd391ea3c8be3ae26318394" translate="yes" xml:space="preserve">
          <source>A Nim procedure is asynchronous when it includes the &lt;code&gt;{.async.}&lt;/code&gt; pragma. It should always have a &lt;code&gt;Future[T]&lt;/code&gt; return type or not have a return type at all. A &lt;code&gt;Future[void]&lt;/code&gt; return type is assumed by default.</source>
          <target state="translated">Un procedimiento de Nim es as&amp;iacute;ncrono cuando incluye el &lt;code&gt;{.async.}&lt;/code&gt; . Siempre debe tener un tipo de retorno &lt;code&gt;Future[T]&lt;/code&gt; o no tener ning&amp;uacute;n tipo de retorno. De forma predeterminada, se asume un tipo de retorno &lt;code&gt;Future[void]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd52730a119bb22be3969f6811e2133725811be" translate="yes" xml:space="preserve">
          <source>A Nim program specifies a computation that acts on a memory consisting of components called &lt;span id=&quot;locations_1&quot;&gt;locations&lt;/span&gt;. A variable is basically a name for a location. Each variable and location is of a certain &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. The variable's type is called &lt;span id=&quot;static-type_1&quot;&gt;static type&lt;/span&gt;, the location's type is called &lt;span id=&quot;dynamic-type_1&quot;&gt;dynamic type&lt;/span&gt;. If the static type is not the same as the dynamic type, it is a super-type or subtype of the dynamic type.</source>
          <target state="translated">Un programa de Nim especifica un c&amp;aacute;lculo que act&amp;uacute;a sobre una memoria que consta de componentes llamados &lt;span id=&quot;locations_1&quot;&gt;ubicaciones&lt;/span&gt; . Una variable es b&amp;aacute;sicamente el nombre de una ubicaci&amp;oacute;n. Cada variable y ubicaci&amp;oacute;n es de un &lt;span id=&quot;type_1&quot;&gt;tipo&lt;/span&gt; determinado . El tipo de la variable se llama &lt;span id=&quot;static-type_1&quot;&gt;tipo est&amp;aacute;tico&lt;/span&gt; , el &lt;span id=&quot;static-type_1&quot;&gt;tipo de&lt;/span&gt; la ubicaci&amp;oacute;n se llama &lt;span id=&quot;dynamic-type_1&quot;&gt;tipo din&amp;aacute;mico&lt;/span&gt; . Si el tipo est&amp;aacute;tico no es el mismo que el tipo din&amp;aacute;mico, es un supertipo o subtipo del tipo din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="4d649a9b73eb1b75df006205a78131f546ab13c9" translate="yes" xml:space="preserve">
          <source>A PEG (Parsing expression grammar) is a simple deterministic grammar, that can be directly used for parsing. The current implementation has been designed as a more powerful replacement for regular expressions. UTF-8 is supported.</source>
          <target state="translated">Una PEG (gramática de expresión de análisis)es una gramática determinista simple,que puede ser utilizada directamente para el análisis.La aplicación actual ha sido diseñada como un sustituto más poderoso de las expresiones regulares.Se admite el UTF-8.</target>
        </trans-unit>
        <trans-unit id="33b07af826ffc1642e9db6c9aa9ff6e43b9cc68a" translate="yes" xml:space="preserve">
          <source>A application-level error condition. For example, some user input generated an exception. The application will continue to run, but functionality or data was impacted, possibly visible to users.</source>
          <target state="translated">Una condición de error a nivel de aplicación.Por ejemplo,algunas entradas de usuario generaron una excepción.La aplicación seguirá funcionando,pero la funcionalidad o los datos se vieron afectados,posiblemente de forma visible para los usuarios.</target>
        </trans-unit>
        <trans-unit id="5d9beef18f6feec8ed926e501f6bc8ef50b29384" translate="yes" xml:space="preserve">
          <source>A application-level fatal condition. FATAL usually means that the application cannot go on and will exit (but this logging event will not do that for you).</source>
          <target state="translated">Una condición fatal a nivel de aplicación.FATAL normalmente significa que la aplicación no puede continuar y saldrá (pero este evento de registro no lo hará por usted).</target>
        </trans-unit>
        <trans-unit id="0bc66569c7f749a991c86255655ab99ac30e86d5" translate="yes" xml:space="preserve">
          <source>A backslash followed by a letter is a built-in macro, otherwise it is used for ordinary escaping:</source>
          <target state="translated">Una barra invertida seguida de una letra es una macro incorporada,de lo contrario se utiliza para la fuga ordinaria:</target>
        </trans-unit>
        <trans-unit id="519b373c181ee8d4be473dddf120c85a8c41428c" translate="yes" xml:space="preserve">
          <source>A block can be left prematurely with a &lt;code&gt;break&lt;/code&gt; statement. The break statement can leave a &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; statement. It leaves the innermost construct, unless a label of a block is given:</source>
          <target state="translated">Un bloque se puede dejar prematuramente con una declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; . La sentencia break puede dejar una sentencia &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; o &lt;code&gt;block&lt;/code&gt; . Deja la construcci&amp;oacute;n m&amp;aacute;s interna, a menos que se d&amp;eacute; una etiqueta de un bloque:</target>
        </trans-unit>
        <trans-unit id="8018e99c199800e7c1d485e8e8e1d2de44558695" translate="yes" xml:space="preserve">
          <source>A call to an asynchronous procedure usually needs &lt;code&gt;await&lt;/code&gt; to wait for the completion of the &lt;code&gt;Future&lt;/code&gt;.</source>
          <target state="translated">Una llamada a un procedimiento asincr&amp;oacute;nico generalmente necesita &lt;code&gt;await&lt;/code&gt; para esperar la finalizaci&amp;oacute;n del &lt;code&gt;Future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd1dcf8b598ce13fe780f11e538b4c3679116e3" translate="yes" xml:space="preserve">
          <source>A character is not an Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">Un car&amp;aacute;cter no es un car&amp;aacute;cter Unicode sino un solo byte. La raz&amp;oacute;n de esto es la eficiencia: para la gran mayor&amp;iacute;a de los casos de uso, los programas resultantes seguir&amp;aacute;n manejando UTF-8 correctamente, ya que UTF-8 fue dise&amp;ntilde;ado especialmente para esto. Otra raz&amp;oacute;n es que Nim puede, por tanto, admitir &lt;code&gt;array[char, int]&lt;/code&gt; o &lt;code&gt;set[char]&lt;/code&gt; eficiente, ya que muchos algoritmos se basan en esta caracter&amp;iacute;stica. El tipo &lt;em&gt;Rune&lt;/em&gt; se utiliza para caracteres Unicode, puede representar cualquier car&amp;aacute;cter Unicode. &lt;code&gt;Rune&lt;/code&gt; se declara en el &lt;a href=&quot;unicode&quot;&gt;m&amp;oacute;dulo Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27a21ba557cb1102184eb887daf5fb2f0ee516b2" translate="yes" xml:space="preserve">
          <source>A compile-time error will be produced if the supplied type is not generic.</source>
          <target state="translated">Se producirá un error en tiempo de compilación si el tipo suministrado no es genérico.</target>
        </trans-unit>
        <trans-unit id="9e63142b740226a78a46d8a1af8bf22743ac95c8" translate="yes" xml:space="preserve">
          <source>A config file was loaded.</source>
          <target state="translated">Se cargó un archivo de configuración.</target>
        </trans-unit>
        <trans-unit id="9d676346fde6cb6856b2edfe8fcc862ca9818983" translate="yes" xml:space="preserve">
          <source>A contains element e</source>
          <target state="translated">A contiene el elemento e</target>
        </trans-unit>
        <trans-unit id="cd669926d307684088d5ef478be7b22480b9a5f4" translate="yes" xml:space="preserve">
          <source>A convenience procedure that executes &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;startProcess&lt;/code&gt; and returns its output as a string. WARNING: this function uses poEvalCommand by default for backward compatibility. Make sure to pass options explicitly.</source>
          <target state="translated">Un procedimiento de conveniencia que ejecuta un &lt;code&gt;command&lt;/code&gt; con &lt;code&gt;startProcess&lt;/code&gt; y devuelve su salida como una cadena. ADVERTENCIA: esta funci&amp;oacute;n usa poEvalCommand por defecto para compatibilidad con versiones anteriores. Aseg&amp;uacute;rese de pasar las opciones expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="d5eda57047be93a6d8ede446c939b622a61fcad5" translate="yes" xml:space="preserve">
          <source>A convention is that exceptions should be raised in &lt;em&gt;exceptional&lt;/em&gt; cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).</source>
          <target state="translated">Una convenci&amp;oacute;n es que se deben generar excepciones en casos &lt;em&gt;excepcionales&lt;/em&gt; : por ejemplo, si un archivo no se puede abrir, esto no debe generar una excepci&amp;oacute;n ya que esto es bastante com&amp;uacute;n (el archivo puede no existir).</target>
        </trans-unit>
        <trans-unit id="9dc4e7e8a36779be1253db430e17a3ece42f97f6" translate="yes" xml:space="preserve">
          <source>A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided.</source>
          <target state="translated">También se puede invocar explícitamente un convertidor para mejorar la legibilidad.Obsérvese que no se admite el encadenamiento implícito de convertidores:Si hay un convertidor de tipo A a tipo B y de tipo B a tipo C,no se proporciona la conversión implícita de A a C.</target>
        </trans-unit>
        <trans-unit id="0fabf98da32833f2ac2d72c57027f686f2dbd28b" translate="yes" xml:space="preserve">
          <source>A converter is like an ordinary proc except that it enhances the &quot;implicitly convertible&quot; type relation (see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;):</source>
          <target state="translated">Un convertidor es como un proceso ordinario, excepto que mejora la relaci&amp;oacute;n de tipo &quot;impl&amp;iacute;citamente convertible&quot; (ver &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Relaci&amp;oacute;n convertible&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="ff0115af818672bc6f62e11d492d4642e32f4663" translate="yes" xml:space="preserve">
          <source>A converter is similar to a proc.</source>
          <target state="translated">Un convertidor es similar a un proc.</target>
        </trans-unit>
        <trans-unit id="95b68e940e0a6eefa4655d5db413050f4aee06c6" translate="yes" xml:space="preserve">
          <source>A curly expression with commas in it like &lt;code&gt;{x, argA, argB}&lt;/code&gt; could be transformed to &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</source>
          <target state="translated">Una expresi&amp;oacute;n rizada con comas como &lt;code&gt;{x, argA, argB}&lt;/code&gt; podr&amp;iacute;a transformarse a &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; para admitir formateadores que no necesitan analizar un idioma personalizado dentro de un idioma personalizado, sino que prefieren para utilizar la sintaxis existente de Nim. Esto tambi&amp;eacute;n ayuda a mejorar la legibilidad, ya que hay una cantidad limitada que puede incluir en DSL de una sola letra.</target>
        </trans-unit>
        <trans-unit id="af339bf252ebc6686a22fa957452c6666fabae1d" translate="yes" xml:space="preserve">
          <source>A destructible context is currently only the following:</source>
          <target state="translated">Un contexto destructible es actualmente sólo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a4828b4e1e76af08cdc61d3da41001844c8e7647" translate="yes" xml:space="preserve">
          <source>A destructor is attached to the type it destructs; expressions of this type can then only be used in &lt;em&gt;destructible contexts&lt;/em&gt; and as parameters:</source>
          <target state="translated">Un destructor se adjunta al tipo que destruye; Las expresiones de este tipo solo se pueden usar en &lt;em&gt;contextos destructibles&lt;/em&gt; y como par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="5433f8711be01e7d00dc897cddea4967983783a7" translate="yes" xml:space="preserve">
          <source>A destructor must have a single parameter with a concrete type (the name of a generic type is allowed too). The name of the destructor has to be &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="translated">Un destructor debe tener un solo par&amp;aacute;metro con un tipo concreto (tambi&amp;eacute;n se permite el nombre de un tipo gen&amp;eacute;rico). El nombre del destructor tiene que ser &lt;code&gt;=destroy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b51be317d37d0d9e5679921ffa2c4f39470a9227" translate="yes" xml:space="preserve">
          <source>A directory can also be a so called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</source>
          <target state="translated">Un directorio también puede ser un llamado &quot;pseudo directorio&quot;.Se pueden utilizar para evitar la ambigüedad cuando hay varios módulos con la misma ruta.</target>
        </trans-unit>
        <trans-unit id="2010acb176bc59e66e9596fccd16c6be234aa62b" translate="yes" xml:space="preserve">
          <source>A distinct type can be used to model different physical &lt;span id=&quot;units_1&quot;&gt;units&lt;/span&gt; with a numerical base type, for example. The following example models currencies.</source>
          <target state="translated">Se puede utilizar un tipo diferenciado para modelar diferentes &lt;span id=&quot;units_1&quot;&gt;unidades&lt;/span&gt; f&amp;iacute;sicas con un tipo de base num&amp;eacute;rica, por ejemplo. El siguiente ejemplo modela monedas.</target>
        </trans-unit>
        <trans-unit id="0dcbf503ecd251b550b20573f306de222e9f6e39" translate="yes" xml:space="preserve">
          <source>A does not contain element e</source>
          <target state="translated">A no contiene el elemento e</target>
        </trans-unit>
        <trans-unit id="7339291827f4b694e439170ba77d07b22a6ba2d9" translate="yes" xml:space="preserve">
          <source>A dot following the hash &lt;code&gt;#.&lt;/code&gt; indicates that the call should use C++'s dot or arrow notation.</source>
          <target state="translated">Un punto que sigue al hash &lt;code&gt;#.&lt;/code&gt; indica que la llamada debe usar la notaci&amp;oacute;n de puntos o flechas de C ++.</target>
        </trans-unit>
        <trans-unit id="91daa2e8d1d787e2cb1cebec501d70a447fbdd47" translate="yes" xml:space="preserve">
          <source>A double quotation mark preceded by a backslash (&quot;) is interpreted as a literal double quotation mark character (&quot;).</source>
          <target state="translated">Una comilla doble precedida de una barra invertida (&quot;)se interpreta como una comilla doble literal (&quot;).</target>
        </trans-unit>
        <trans-unit id="5b983689cc856655c0945357d3fc5752f335fd52" translate="yes" xml:space="preserve">
          <source>A double-ended queue backed with a ringed seq buffer.</source>
          <target state="translated">Una cola de doble final respaldada con un buffer secuencial anillado.</target>
        </trans-unit>
        <trans-unit id="01ed7c56b187204e313f1f9d97ebfebcc0fecee3" translate="yes" xml:space="preserve">
          <source>A for loop variable.</source>
          <target state="translated">A de variable de bucle.</target>
        </trans-unit>
        <trans-unit id="7d654b825945bd5f2a34963e2ce499f362a2a00c" translate="yes" xml:space="preserve">
          <source>A friendlier version of &lt;em&gt;initRational&lt;/em&gt;. Example usage:</source>
          <target state="translated">Una versi&amp;oacute;n m&amp;aacute;s amigable de &lt;em&gt;initRational&lt;/em&gt; . Uso de ejemplo:</target>
        </trans-unit>
        <trans-unit id="d411518da35d7d553e49043b1323d3beb87db97b" translate="yes" xml:space="preserve">
          <source>A generic hash set that remembers insertion order.</source>
          <target state="translated">Un juego de hachís genérico que recuerda el orden de inserción.</target>
        </trans-unit>
        <trans-unit id="e82bc7694d12c8d0a1eda93534f23d36363f6058" translate="yes" xml:space="preserve">
          <source>A generic hash set.</source>
          <target state="translated">Un juego de hachís genérico.</target>
        </trans-unit>
        <trans-unit id="9e98d244bf1a5c7aeeae52fd19acf41b5eb1f418" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;#&lt;/code&gt; symbol is replaced by the first or next argument.</source>
          <target state="translated">Un s&amp;iacute;mbolo de almohadilla &lt;code&gt;#&lt;/code&gt; se reemplaza por el primer argumento o el siguiente.</target>
        </trans-unit>
        <trans-unit id="a53f6ddc26d79601afed6742fbd39fc945dc2d24" translate="yes" xml:space="preserve">
          <source>A helper for wrapping callback-based functions into promises and async procedures</source>
          <target state="translated">Un ayudante para envolver las funciones basadas en la devolución de llamada en promesas y procedimientos de sincronización</target>
        </trans-unit>
        <trans-unit id="8f2cac0c1f19b93707af84e96c8e8344199be1d8" translate="yes" xml:space="preserve">
          <source>A higher level &lt;em&gt;ODBC&lt;/em&gt; database wrapper.</source>
          <target state="translated">Un contenedor de base de datos &lt;em&gt;ODBC de&lt;/em&gt; nivel superior .</target>
        </trans-unit>
        <trans-unit id="d7086b8bccfe459c43887557d6fccf6aaa7324be" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt; database wrapper. The same interface is implemented for other databases too.</source>
          <target state="translated">Un contenedor de base de datos &lt;span id=&quot;mysql_1&quot;&gt;mySQL de&lt;/span&gt; nivel superior . La misma interfaz tambi&amp;eacute;n se implementa para otras bases de datos.</target>
        </trans-unit>
        <trans-unit id="7ed449265b711e313a4301b54cee15ef550acdbf" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt; database wrapper. This interface is implemented for other databases also.</source>
          <target state="translated">Un contenedor de &lt;span id=&quot;postgresql_1&quot;&gt;base de&lt;/span&gt; datos &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL de&lt;/span&gt; nivel superior . Esta interfaz tambi&amp;eacute;n se implementa para otras bases de datos.</target>
        </trans-unit>
        <trans-unit id="18d9c046b2d8f8fc8c6daccb16db460900a01a66" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt; database wrapper. This interface is implemented for other databases too.</source>
          <target state="translated">Un contenedor de &lt;span id=&quot;sqlite_1&quot;&gt;base de&lt;/span&gt; datos &lt;span id=&quot;sqlite_1&quot;&gt;SQLite de&lt;/span&gt; nivel superior . Esta interfaz tambi&amp;eacute;n est&amp;aacute; implementada para otras bases de datos.</target>
        </trans-unit>
        <trans-unit id="17cc08bc05f9e3c22bbf4a01b73d4951016af63c" translate="yes" xml:space="preserve">
          <source>A label (used in &lt;code&gt;block&lt;/code&gt; statements).</source>
          <target state="translated">Una etiqueta (usada en declaraciones de &lt;code&gt;block&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="89265eb4f02e06930cfb5c35dd5f76b04d9c0a16" translate="yes" xml:space="preserve">
          <source>A last tip when writing a macro: if you are not sure the AST you are building looks ok, you may be tempted to use the &lt;code&gt;dumpTree&lt;/code&gt; macro. But you can't use it &lt;em&gt;inside&lt;/em&gt; the macro you are writting/debugging. Instead &lt;code&gt;echo&lt;/code&gt; the string generated by &lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr&lt;/a&gt;. If at the end of the this example you add &lt;code&gt;echo treeRepr(result)&lt;/code&gt; you should get the same output as using the &lt;code&gt;dumpTree&lt;/code&gt; macro, but of course you can call that at any point of the macro where you might be having troubles.</source>
          <target state="translated">Un &amp;uacute;ltimo consejo al escribir una macro: si no est&amp;aacute; seguro de que el AST que est&amp;aacute; construyendo se vea bien, puede tener la tentaci&amp;oacute;n de usar la macro &lt;code&gt;dumpTree&lt;/code&gt; . Pero no puede usarlo &lt;em&gt;dentro de&lt;/em&gt; la macro que est&amp;aacute; escribiendo / depurando. En su lugar, &lt;a href=&quot;macros#treeRepr&quot;&gt;haga &lt;/a&gt; &lt;code&gt;echo&lt;/code&gt; la cadena generada por treeRepr . Si al final de este ejemplo agrega &lt;code&gt;echo treeRepr(result)&lt;/code&gt; , deber&amp;iacute;a obtener el mismo resultado que usando la macro &lt;code&gt;dumpTree&lt;/code&gt; , pero por supuesto puede llamar a eso en cualquier punto de la macro donde podr&amp;iacute;a tener problemas.</target>
        </trans-unit>
        <trans-unit id="e62c0496669da44a5936805a3cdfee1fe957384a" translate="yes" xml:space="preserve">
          <source>A leaf of the AST often corresponds to a terminal symbol in the concrete syntax. Note that the default &lt;code&gt;float&lt;/code&gt; in Nim maps to &lt;code&gt;float64&lt;/code&gt; such that the default AST for a float is &lt;code&gt;nnkFloat64Lit&lt;/code&gt; as below.</source>
          <target state="translated">Una hoja del AST a menudo corresponde a un s&amp;iacute;mbolo de terminal en la sintaxis concreta. Tenga en cuenta que el &lt;code&gt;float&lt;/code&gt; predeterminado en Nim se asigna a &lt;code&gt;float64&lt;/code&gt; ,de modo que el AST predeterminado para un flotante es &lt;code&gt;nnkFloat64Lit&lt;/code&gt; como se muestra a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="af284b25e3830a68d5e3016b0dc1d22187bec97a" translate="yes" xml:space="preserve">
          <source>A local variable shadows another local variable of an outer scope.</source>
          <target state="translated">Una variable local ensombrece otra variable local de un alcance exterior.</target>
        </trans-unit>
        <trans-unit id="d15ac9d0ba716c535ed2ce2885c3b9d90285db47" translate="yes" xml:space="preserve">
          <source>A macro is a special function that is executed at compile-time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. The transformed AST is then passed to the compiler as if the macro invocation would have been replaced by its result in the source code. This can be used to implement &lt;span id=&quot;domain-specific-languages_1&quot;&gt;domain specific languages&lt;/span&gt;.</source>
          <target state="translated">Una macro es una funci&amp;oacute;n especial que se ejecuta en tiempo de compilaci&amp;oacute;n. Normalmente, la entrada para una macro es un &amp;aacute;rbol de sintaxis abstracta (AST) del c&amp;oacute;digo que se le pasa. La macro puede entonces hacer transformaciones en ella y devolver el AST transformado. El AST transformado luego se pasa al compilador como si la invocaci&amp;oacute;n de la macro hubiera sido reemplazada por su resultado en el c&amp;oacute;digo fuente. Esto se puede utilizar para implementar &lt;span id=&quot;domain-specific-languages_1&quot;&gt;lenguajes espec&amp;iacute;ficos de dominio&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="2320939f622f35d906ef2dffec7b8d388f8158e3" translate="yes" xml:space="preserve">
          <source>A macro that needs to be called &lt;span id=&quot;match_1&quot;&gt;match&lt;/span&gt; can be used to rewrite &lt;code&gt;case&lt;/code&gt; statements in order to implement &lt;span id=&quot;pattern-matching_1&quot;&gt;pattern matching&lt;/span&gt; for certain types. The following example implements a simplistic form of pattern matching for tuples, leveraging the existing equality operator for tuples (as provided in &lt;code&gt;system.==&lt;/code&gt;):</source>
          <target state="translated">Una macro que debe llamarse &lt;span id=&quot;match_1&quot;&gt;coincidencia&lt;/span&gt; se puede utilizar para reescribir declaraciones de &lt;code&gt;case&lt;/code&gt; a fin de implementar &lt;span id=&quot;pattern-matching_1&quot;&gt;la coincidencia de patrones&lt;/span&gt; para ciertos tipos. El siguiente ejemplo implementa una forma simplista de coincidencia de patrones para tuplas, aprovechando el operador de igualdad existente para tuplas (como se proporciona en &lt;code&gt;system.==&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c4a6d2ce7ae67ff08002aecf71f9b696f9005b38" translate="yes" xml:space="preserve">
          <source>A macro that takes as its only input parameter an expression of the special type &lt;code&gt;system.ForLoopStmt&lt;/code&gt; can rewrite the entirety of a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Una macro que toma como &amp;uacute;nico par&amp;aacute;metro de entrada una expresi&amp;oacute;n del tipo especial &lt;code&gt;system.ForLoopStmt&lt;/code&gt; puede reescribir la totalidad de un bucle &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d8df2d80cd89e184b1f75f28697093931c58d398" translate="yes" xml:space="preserve">
          <source>A module alias can be introduced via the &lt;code&gt;as&lt;/code&gt; keyword:</source>
          <target state="translated">Se puede introducir un alias de m&amp;oacute;dulo mediante la palabra clave &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4afefca445f32ee9a9bac5a6c407d25bf9bc289" translate="yes" xml:space="preserve">
          <source>A module's top-level statements are executed at the start of the program. This can be used to initialize complex data structures for example.</source>
          <target state="translated">Las declaraciones de alto nivel de un módulo se ejecutan al inicio del programa.Esto puede ser usado para inicializar estructuras de datos complejas,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="a99c0a025e79be3ef687fadc0cc6086e9682f6fb" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;main&lt;/code&gt; async procedure must be declared to allow the use of the &lt;code&gt;await&lt;/code&gt; keyword. The connection will complete asynchronously and the client will be connected after the &lt;code&gt;await ftp.connect()&lt;/code&gt; call.</source>
          <target state="translated">Se debe declarar un nuevo procedimiento asincr&amp;oacute;nico &lt;code&gt;main&lt;/code&gt; para permitir el uso de la palabra clave &lt;code&gt;await&lt;/code&gt; . La conexi&amp;oacute;n se completar&amp;aacute; de forma asincr&amp;oacute;nica y el cliente se conectar&amp;aacute; despu&amp;eacute;s de la llamada &lt;code&gt;await ftp.connect()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4f09c089b0b64dd84f87655d31d40b67c7f610c" translate="yes" xml:space="preserve">
          <source>A new entry will be added to the index using the format &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt;. The file part will come from the &lt;em&gt;htmlFile&lt;/em&gt; parameter.</source>
          <target state="translated">Se agregar&amp;aacute; una nueva entrada al &amp;iacute;ndice usando el &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt; formato &amp;lt;tab&amp;gt; file # id . La parte del archivo vendr&amp;aacute; del par&amp;aacute;metro &lt;em&gt;htmlFile&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fc67102da94ccd07b62bc7ef2e58c87c378eee76" translate="yes" xml:space="preserve">
          <source>A non-error message that may indicate a potential problem rising or impacted performance.</source>
          <target state="translated">Un mensaje no erróneo que puede indicar un posible problema de aumento o impacto en el rendimiento.</target>
        </trans-unit>
        <trans-unit id="911a5ad83db128f4812253b45faa46d98027ca72" translate="yes" xml:space="preserve">
          <source>A parameter &lt;code&gt;p&lt;/code&gt; in a template is even substituted in the expression &lt;code&gt;x.p&lt;/code&gt;. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</source>
          <target state="translated">Un par&amp;aacute;metro &lt;code&gt;p&lt;/code&gt; en una plantilla incluso se sustituye en la expresi&amp;oacute;n &lt;code&gt;x.p&lt;/code&gt; . Por lo tanto, los argumentos de plantilla se pueden usar como nombres de campo y un s&amp;iacute;mbolo global se puede sombrear con el mismo nombre de argumento incluso cuando est&amp;aacute; completamente calificado:</target>
        </trans-unit>
        <trans-unit id="b19cf459adbb632e3345bc4ce82a5563aa028fe2" translate="yes" xml:space="preserve">
          <source>A parameter may be declared with a default value which is used if the caller does not provide a value for the argument.</source>
          <target state="translated">Se puede declarar un parámetro con un valor por defecto que se utiliza si el llamante no proporciona un valor para el argumento.</target>
        </trans-unit>
        <trans-unit id="cd0e5a46bea204df5866abc8071f4ce20c751ed1" translate="yes" xml:space="preserve">
          <source>A parameter of type &lt;code&gt;untyped&lt;/code&gt; always matches any argument (as long as there is any argument passed to it).</source>
          <target state="translated">Un par&amp;aacute;metro de tipo sin &lt;code&gt;untyped&lt;/code&gt; siempre coincide con cualquier argumento (siempre que se le pase alg&amp;uacute;n argumento).</target>
        </trans-unit>
        <trans-unit id="dbc7adf040bff90855d92e494801c3ab8308d57e" translate="yes" xml:space="preserve">
          <source>A pattern expression can be bound to a pattern parameter via the &lt;code&gt;expr{param}&lt;/code&gt; notation:</source>
          <target state="translated">Una expresi&amp;oacute;n de patr&amp;oacute;n se puede vincular a un par&amp;aacute;metro de patr&amp;oacute;n mediante la notaci&amp;oacute;n &lt;code&gt;expr{param}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="84dbef3c0526b967ebfd2aa664f1b6a0e87d7f54" translate="yes" xml:space="preserve">
          <source>A possible common use case for &lt;em&gt;rsplit&lt;/em&gt; is path manipulation, particularly on systems that don't use a common delimiter.</source>
          <target state="translated">Un posible caso de uso com&amp;uacute;n de &lt;em&gt;rsplit&lt;/em&gt; es la manipulaci&amp;oacute;n de rutas, particularmente en sistemas que no usan un delimitador com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="468ffea579d79393dcb2eb8fd23d5f70574b0406" translate="yes" xml:space="preserve">
          <source>A proc can be marked with the &lt;code&gt;asmNoStackFrame&lt;/code&gt; pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like &lt;code&gt;return result;&lt;/code&gt; generated and the generated C function is declared as &lt;code&gt;__declspec(naked)&lt;/code&gt; or &lt;code&gt;__attribute__((naked))&lt;/code&gt; (depending on the used C compiler).</source>
          <target state="translated">Un proc se puede marcar con el pragma &lt;code&gt;asmNoStackFrame&lt;/code&gt; para decirle al compilador que no debe generar un marco de pila para el proc. Tampoco hay declaraciones de salida como &lt;code&gt;return result;&lt;/code&gt; generado y la funci&amp;oacute;n de C generada se declara como &lt;code&gt;__declspec(naked)&lt;/code&gt; o &lt;code&gt;__attribute__((naked))&lt;/code&gt; (seg&amp;uacute;n el compilador de C utilizado).</target>
        </trans-unit>
        <trans-unit id="451fbc26f5ae1ee9316fb78b0e6ca76aa2f9e794" translate="yes" xml:space="preserve">
          <source>A proc that is executed as a new thread of execution should be marked by the &lt;code&gt;thread&lt;/code&gt; pragma for reasons of readability. The compiler checks for violations of the &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;no heap sharing restriction&lt;/span&gt;: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.</source>
          <target state="translated">Un proceso que se ejecuta como un nuevo subproceso de ejecuci&amp;oacute;n debe estar marcado por el &lt;code&gt;thread&lt;/code&gt; pragma por razones de legibilidad. El compilador comprueba si hay violaciones de la &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;restricci&amp;oacute;n de no compartir&lt;/span&gt; montones: esta restricci&amp;oacute;n implica que no es v&amp;aacute;lido construir una estructura de datos que consista en memoria asignada desde diferentes montones (subprocesos locales).</target>
        </trans-unit>
        <trans-unit id="c8f7a283eb6acfde98dfa18ad4771346a71dcb69" translate="yes" xml:space="preserve">
          <source>A proc, converter or iterator may return a &lt;code&gt;var&lt;/code&gt; type which means that the returned value is an l-value and can be modified by the caller:</source>
          <target state="translated">Un proceso, convertidor o iterador puede devolver un tipo &lt;code&gt;var&lt;/code&gt; ,lo que significa que el valor devuelto es un valor l y puede ser modificado por la persona que llama:</target>
        </trans-unit>
        <trans-unit id="4ba9d6d1f4765955e60cabd2afda1cfb0cacfe70" translate="yes" xml:space="preserve">
          <source>A procedural type is a (somewhat abstract) pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">Un tipo de procedimiento es un puntero (algo abstracto) a un procedimiento. &lt;code&gt;nil&lt;/code&gt; es un valor permitido para una variable de tipo procedimental. Nim utiliza tipos de procedimiento para lograr t&amp;eacute;cnicas de programaci&amp;oacute;n &lt;span id=&quot;functional_1&quot;&gt;funcional&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="dbca622df4cb9e116b8115ae0a141864eed44cd7" translate="yes" xml:space="preserve">
          <source>A procedural type is internally a pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for variables of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">Un tipo de procedimiento es internamente un puntero a un procedimiento. &lt;code&gt;nil&lt;/code&gt; es un valor permitido para variables de tipo procedimental. Nim utiliza tipos de procedimiento para lograr t&amp;eacute;cnicas de programaci&amp;oacute;n &lt;span id=&quot;functional_1&quot;&gt;funcional&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="bf770f6e5979c1f778e9340dd0cdb848252fa2f0" translate="yes" xml:space="preserve">
          <source>A procedure may call itself recursively.</source>
          <target state="translated">Un procedimiento puede llamarse a sí mismo recursivamente.</target>
        </trans-unit>
        <trans-unit id="198d46da979417aa29b92d0cafdd5b26b6aa26bb" translate="yes" xml:space="preserve">
          <source>A procedure that returns a value has an implicit &lt;code&gt;result&lt;/code&gt; variable declared that represents the return value. A &lt;code&gt;return&lt;/code&gt; statement with no expression is a shorthand for &lt;code&gt;return result&lt;/code&gt;. The &lt;code&gt;result&lt;/code&gt; value is always returned automatically at the end of a procedure if there is no &lt;code&gt;return&lt;/code&gt; statement at the exit.</source>
          <target state="translated">Un procedimiento que devuelve un valor tiene una variable de &lt;code&gt;result&lt;/code&gt; ado impl&amp;iacute;cita declarada que representa el valor de retorno. Una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; sin expresi&amp;oacute;n es una forma abreviada de &lt;code&gt;return result&lt;/code&gt; . El valor del &lt;code&gt;result&lt;/code&gt; ado siempre se devuelve autom&amp;aacute;ticamente al final de un procedimiento si no hay una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; en la salida.</target>
        </trans-unit>
        <trans-unit id="4479e2a3631b65d0dd4c690b9db368a8f3b1652a" translate="yes" xml:space="preserve">
          <source>A project can also have a project specific configuration file named &lt;code&gt;$project.nim.cfg&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the &lt;code&gt;--skipProjCfg&lt;/code&gt; command line option.</source>
          <target state="translated">Un proyecto tambi&amp;eacute;n puede tener un archivo de configuraci&amp;oacute;n espec&amp;iacute;fico del proyecto llamado &lt;code&gt;$project.nim.cfg&lt;/code&gt; que reside en el mismo directorio que &lt;code&gt;$project.nim&lt;/code&gt; . Este archivo se puede omitir con la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--skipProjCfg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e60afd1721ef96b7c6739e2759b02cb38c2c2d8c" translate="yes" xml:space="preserve">
          <source>A proxy can be specified as a param to any of the procedures defined in this module. To do this, use the &lt;code&gt;newProxy&lt;/code&gt; constructor. Unfortunately, only basic authentication is supported at the moment.</source>
          <target state="translated">Se puede especificar un proxy como par&amp;aacute;metro para cualquiera de los procedimientos definidos en este m&amp;oacute;dulo. Para hacer esto, use el constructor &lt;code&gt;newProxy&lt;/code&gt; . Desafortunadamente, solo se admite la autenticaci&amp;oacute;n b&amp;aacute;sica en este momento.</target>
        </trans-unit>
        <trans-unit id="eac1d47b4a0730fb9551845dd67bf5ea00259685" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:</source>
          <target state="translated">Una expresión regular es un patrón que se ajusta a una cadena de sujetos de izquierda a derecha.La mayoría de los caracteres se mantienen en un patrón,y coinciden con los caracteres correspondientes en el sujeto.Como un ejemplo trivial,el patrón:</target>
        </trans-unit>
        <trans-unit id="5df947512d73d9e3cb7375e44d4a39fd584e964d" translate="yes" xml:space="preserve">
          <source>A routine &lt;code&gt;p&lt;/code&gt; matches better than a routine &lt;code&gt;q&lt;/code&gt; if the following algorithm returns true:</source>
          <target state="translated">Una rutina &lt;code&gt;p&lt;/code&gt; coincide mejor que una rutina &lt;code&gt;q&lt;/code&gt; si el siguiente algoritmo devuelve verdadero:</target>
        </trans-unit>
        <trans-unit id="fdff97566890f772e04c8438a24bb2cbb00af4bb" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents::</source>
          <target state="translated">Un segundo uso de la barra invertida proporciona una forma de codificar los caracteres no impresos en patrones de manera visible.No existe ninguna restricción en cuanto a la apariencia de los caracteres no imprimibles,aparte del cero binario que termina un patrón,pero cuando se prepara un patrón mediante la edición de texto,suele ser más fácil utilizar una de las siguientes secuencias de escape que el carácter binario que representa::</target>
        </trans-unit>
        <trans-unit id="3eac564020abe821a021c684a0c7e182c5615b2f" translate="yes" xml:space="preserve">
          <source>A section you should use to mark &lt;span id=&quot;runnable-example_1&quot;&gt;runnable example&lt;/span&gt; code with.</source>
          <target state="translated">Una secci&amp;oacute;n que debe usar para marcar el c&amp;oacute;digo de &lt;span id=&quot;runnable-example_1&quot;&gt;ejemplo ejecutable&lt;/span&gt; con.</target>
        </trans-unit>
        <trans-unit id="d3b57f32de0396cba5ad9e9d00b3af349a475164" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to a parameter that is of type &lt;em&gt;open array&lt;/em&gt;.</source>
          <target state="translated">Se puede pasar una secuencia a un par&amp;aacute;metro que sea de tipo &lt;em&gt;matriz abierta&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="42f4d3d39137f32b8ca5b909c4ff4309a61d6eac" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to an openarray parameter.</source>
          <target state="translated">Se puede pasar una secuencia a un parámetro de red abierta.</target>
        </trans-unit>
        <trans-unit id="e9939043c42e4aaaff588930f28e3fb87a4c1d18" translate="yes" xml:space="preserve">
          <source>A set with all the possible characters.</source>
          <target state="translated">Un conjunto con todos los personajes posibles.</target>
        </trans-unit>
        <trans-unit id="13fa5f0ea96be473acaa7e27bc838b91426d27e9" translate="yes" xml:space="preserve">
          <source>A shared GC'ed heap might be provided.</source>
          <target state="translated">Se podría proporcionar un montón de GC'ed compartido.</target>
        </trans-unit>
        <trans-unit id="af38f1c5146159966de284e8a35e5d86d3ab12b9" translate="yes" xml:space="preserve">
          <source>A shorthand for:</source>
          <target state="translated">Una abreviatura de:</target>
        </trans-unit>
        <trans-unit id="dac4b4b7dce5d63bf65005785b5b8b3dd2313f8a" translate="yes" xml:space="preserve">
          <source>A similar thing happens with C code invoking Nim code which returns a &lt;code&gt;cstring&lt;/code&gt;. Consider the following proc:</source>
          <target state="translated">Algo similar sucede con el c&amp;oacute;digo C que invoca el c&amp;oacute;digo Nim que devuelve un &lt;code&gt;cstring&lt;/code&gt; . Considere el siguiente proceso:</target>
        </trans-unit>
        <trans-unit id="a48f6996b6131883f1b9650bc68f70d8d02303fe" translate="yes" xml:space="preserve">
          <source>A simple XML tree. More efficient and simpler than the DOM.</source>
          <target state="translated">Un simple árbol XML.Más eficiente y simple que el DOM.</target>
        </trans-unit>
        <trans-unit id="b881695a1cfe6f9170c0ac327d2994cb87b8beb2" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;&quot;*&quot;&lt;/code&gt; can be used for globbing.</source>
          <target state="translated">Se puede utilizar un solo &lt;code&gt;&quot;*&quot;&lt;/code&gt; para el globbing.</target>
        </trans-unit>
        <trans-unit id="17eb06b5b98ef723497f736d4beb2106d493fd2b" translate="yes" xml:space="preserve">
          <source>A static statement/expression can be used to enforce compile time evaluation explicitly. Enforced compile time evaluation can even evaluate code that has side effects:</source>
          <target state="translated">Se puede utilizar una declaración/expresión estática para hacer cumplir la evaluación del tiempo de compilación explícitamente.La evaluación del tiempo de compilación forzada puede incluso evaluar el código que tiene efectos secundarios:</target>
        </trans-unit>
        <trans-unit id="793061e8f68073a7cc2b6e8e7cb7430e9cb435af" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; but &lt;em&gt;t&lt;/em&gt; has more elements than &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Un subconjunto estricto o propio &lt;em&gt;s&lt;/em&gt; tiene todos sus miembros en &lt;em&gt;t&lt;/em&gt; pero &lt;em&gt;t&lt;/em&gt; tiene m&amp;aacute;s elementos que &lt;em&gt;s&lt;/em&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="692f4550479e6001b1a436a04309e4819905d924" translate="yes" xml:space="preserve">
          <source>A string surrounded by double quotation marks (&quot;string&quot;) is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</source>
          <target state="translated">Una cadena rodeada de comillas dobles (&quot;cadena&quot;)se interpreta como un único argumento,independientemente del espacio en blanco que contenga.Una cadena entre comillas puede ser incrustada en un argumento.</target>
        </trans-unit>
        <trans-unit id="ebec3b61b900cc32aa099451f2c6e12dd07c334c" translate="yes" xml:space="preserve">
          <source>A string variable is initialized with the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Una variable de cadena se inicializa con la cadena vac&amp;iacute;a &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a00e56e1710bd679d0173c57dab6fbeebbe31b" translate="yes" xml:space="preserve">
          <source>A subrange type has the same size as its base type (&lt;code&gt;int&lt;/code&gt; in the Subrange example).</source>
          <target state="translated">Un tipo de subrango tiene el mismo tama&amp;ntilde;o que su tipo base ( &lt;code&gt;int&lt;/code&gt; en el ejemplo de subrango).</target>
        </trans-unit>
        <trans-unit id="7a08933979326f8850950a1173db1b99805f1785" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an integer or enumeration type (the base type). Example:</source>
          <target state="translated">Un tipo de subgama es un rango de valores de un tipo entero o de enumeración (el tipo base).Ejemplo:</target>
        </trans-unit>
        <trans-unit id="5216761dae1ae277a963814830873f1da9e08d5b" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an ordinal or floating point type (the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type:</source>
          <target state="translated">Un tipo de subgama es un rango de valores de un tipo ordinal o de punto flotante (el tipo base).Para definir un tipo de subrango,hay que especificar sus valores límite:el valor más bajo y el más alto del tipo:</target>
        </trans-unit>
        <trans-unit id="05319ab331bb8be9fb80a1ea2da5bff936f37a01" translate="yes" xml:space="preserve">
          <source>A subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; and &lt;em&gt;t&lt;/em&gt; doesn't necessarily have more members than &lt;em&gt;s&lt;/em&gt;. That is, &lt;em&gt;s&lt;/em&gt; can be equal to &lt;em&gt;t&lt;/em&gt;. Example:</source>
          <target state="translated">Un subconjunto &lt;em&gt;s&lt;/em&gt; tiene todos sus miembros en &lt;em&gt;t&lt;/em&gt; y &lt;em&gt;t&lt;/em&gt; no tiene necesariamente m&amp;aacute;s miembros que &lt;em&gt;s&lt;/em&gt; . Es decir, &lt;em&gt;s&lt;/em&gt; puede ser igual a &lt;em&gt;t&lt;/em&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="23fcaa56fd8e693a2e943e96baf6a166ee24925f" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. As a special extension, a procedure of the calling convention &lt;code&gt;nimcall&lt;/code&gt; can be passed to a parameter that expects a proc of the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">Un problema sutil con los tipos de procedimiento es que la convenci&amp;oacute;n de llamada del procedimiento influye en la compatibilidad de tipos: los tipos de procedimiento solo son compatibles si tienen la misma convenci&amp;oacute;n de llamada. Como extensi&amp;oacute;n especial, un procedimiento de la convenci&amp;oacute;n de llamada &lt;code&gt;nimcall&lt;/code&gt; puede pasarse a un par&amp;aacute;metro que espera un proceso del &lt;code&gt;closure&lt;/code&gt; convenci&amp;oacute;n de llamada .</target>
        </trans-unit>
        <trans-unit id="33ba9ca12af44d34318811768b34fc09edc238c4" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the &lt;a href=&quot;manual#types-procedural-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Un problema sutil con los tipos de procedimiento es que la convenci&amp;oacute;n de llamada del procedimiento influye en la compatibilidad de tipos: los tipos de procedimiento solo son compatibles si tienen la misma convenci&amp;oacute;n de llamada. Las diferentes convenciones de llamadas se enumeran en el &lt;a href=&quot;manual#types-procedural-type&quot;&gt;manual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a98d0d55b4f56cd1973186508a85d670c67f313d" translate="yes" xml:space="preserve">
          <source>A symbol can be forced to be open by a &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; declaration:</source>
          <target state="translated">Se puede forzar la apertura de un s&amp;iacute;mbolo mediante una declaraci&amp;oacute;n &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="0462b1952d8449154ce73caf7ef4db9422926829" translate="yes" xml:space="preserve">
          <source>A symbol of a module &lt;em&gt;can&lt;/em&gt; be &lt;em&gt;qualified&lt;/em&gt; with the &lt;code&gt;module.symbol&lt;/code&gt; syntax. And if a symbol is ambiguous, it &lt;em&gt;must&lt;/em&gt; be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:</source>
          <target state="translated">Un s&amp;iacute;mbolo de un m&amp;oacute;dulo &lt;em&gt;se&lt;/em&gt; puede &lt;em&gt;calificar&lt;/em&gt; con la sintaxis &lt;code&gt;module.symbol&lt;/code&gt; . Y si un s&amp;iacute;mbolo es ambiguo, &lt;em&gt;debe&lt;/em&gt; calificarse. Un s&amp;iacute;mbolo es ambiguo si est&amp;aacute; definido en dos (o m&amp;aacute;s) m&amp;oacute;dulos diferentes y ambos m&amp;oacute;dulos son importados por un tercero:</target>
        </trans-unit>
        <trans-unit id="b3a7ad38688e4496bf760973d6609aeb8d3bfad8" translate="yes" xml:space="preserve">
          <source>A symbol which is a &lt;code&gt;let&lt;/code&gt; variable.</source>
          <target state="translated">Un s&amp;iacute;mbolo que es una variable &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25afae3a203b27eb5151fb8ba040656c33e3555a" translate="yes" xml:space="preserve">
          <source>A symbol which is a constant.</source>
          <target state="translated">Un símbolo que es una constante.</target>
        </trans-unit>
        <trans-unit id="18336a58e1597be288809ec54b26b76e902b5f18" translate="yes" xml:space="preserve">
          <source>A symbol which is a converter.</source>
          <target state="translated">Un símbolo que es un convertidor.</target>
        </trans-unit>
        <trans-unit id="34e5a133463d35676b1ce7b0d26dcb4084186353" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in a tuple or an object.</source>
          <target state="translated">Un símbolo que es un campo en una tupla o un objeto.</target>
        </trans-unit>
        <trans-unit id="dbc7ff0193694a8a6df3edaa4feafaf08a548d9c" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in an enumeration.</source>
          <target state="translated">Un símbolo que es un campo en una enumeración.</target>
        </trans-unit>
        <trans-unit id="b0f4c02b65e3aca97fa198aef1b1d7f8f50540e1" translate="yes" xml:space="preserve">
          <source>A symbol which is a generic parameter.</source>
          <target state="translated">Un símbolo que es un parámetro genérico.</target>
        </trans-unit>
        <trans-unit id="cee1e54f067d3a3df195ebd26b86fefccf9d512a" translate="yes" xml:space="preserve">
          <source>A symbol which is a macro.</source>
          <target state="translated">Un símbolo que es una macro.</target>
        </trans-unit>
        <trans-unit id="8ba65c84aa50b6b4fa8d3cfd3055d6bba8e59df2" translate="yes" xml:space="preserve">
          <source>A symbol which is a method.</source>
          <target state="translated">Un símbolo que es un método.</target>
        </trans-unit>
        <trans-unit id="397a59c937f508b55f4f508768e9f30b05e604a7" translate="yes" xml:space="preserve">
          <source>A symbol which is a module.</source>
          <target state="translated">Un símbolo que es un módulo.</target>
        </trans-unit>
        <trans-unit id="2ebe7a11b22366113570683c1b68d2ed707218ec" translate="yes" xml:space="preserve">
          <source>A symbol which is a parameter.</source>
          <target state="translated">Un símbolo que es un parámetro.</target>
        </trans-unit>
        <trans-unit id="28496412faf0d454dab9dc1a6af576954c0a1ed5" translate="yes" xml:space="preserve">
          <source>A symbol which is a proc.</source>
          <target state="translated">Un símbolo que es un proc.</target>
        </trans-unit>
        <trans-unit id="b83a50e7c38bef4fa30f012bba6b90bc90afc9ea" translate="yes" xml:space="preserve">
          <source>A symbol which is a template.</source>
          <target state="translated">Un símbolo que es una plantilla.</target>
        </trans-unit>
        <trans-unit id="3462dea1dd2d1f68df6439bcca6ca7bca98f2daf" translate="yes" xml:space="preserve">
          <source>A symbol which is a type.</source>
          <target state="translated">Un símbolo que es un tipo.</target>
        </trans-unit>
        <trans-unit id="2a1357b126b87914b1b6f8a549043e8db1b4ede2" translate="yes" xml:space="preserve">
          <source>A symbol which is a variable.</source>
          <target state="translated">Un símbolo que es una variable.</target>
        </trans-unit>
        <trans-unit id="2d0634ee6e934140b8250f79b8ba8901843ddbb9" translate="yes" xml:space="preserve">
          <source>A symbol which is an iterator.</source>
          <target state="translated">Un símbolo que es un iterador.</target>
        </trans-unit>
        <trans-unit id="4e393c2bf071d79fe321a01e0a6eea1010d9f40a" translate="yes" xml:space="preserve">
          <source>A system call for device-specific input/output operations and other operations which cannot be expressed by regular system calls</source>
          <target state="translated">Una llamada de sistema para operaciones de entrada/salida de dispositivos específicos y otras operaciones que no pueden ser expresadas por las llamadas regulares del sistema</target>
        </trans-unit>
        <trans-unit id="fc9ce8dd56e57484f7771a0858bc6ea64b79d22b" translate="yes" xml:space="preserve">
          <source>A table constructor is syntactic sugar for an array constructor:</source>
          <target state="translated">Un constructor de mesa es el azúcar sintáctico para un constructor de arreglos:</target>
        </trans-unit>
        <trans-unit id="4a7a5f8021ef6500926b1cb58e60a0f63620d3dd" translate="yes" xml:space="preserve">
          <source>A table literal can be put into a &lt;code&gt;const&lt;/code&gt; section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.</source>
          <target state="translated">Un literal de tabla puede colocarse en una secci&amp;oacute;n &lt;code&gt;const&lt;/code&gt; ante y el compilador puede colocarlo f&amp;aacute;cilmente en la secci&amp;oacute;n de datos del ejecutable, al igual que para las matrices y la secci&amp;oacute;n de datos generados requiere una cantidad m&amp;iacute;nima de memoria.</target>
        </trans-unit>
        <trans-unit id="cfef19ba2df017b1840fca787af14959a3b9fbf8" translate="yes" xml:space="preserve">
          <source>A tag has to be a type name. A &lt;code&gt;tags&lt;/code&gt; list - like a &lt;code&gt;raises&lt;/code&gt; list - can also be attached to a proc type. This affects type compatibility.</source>
          <target state="translated">Una etiqueta debe ser un nombre de tipo. Una lista de &lt;code&gt;tags&lt;/code&gt; , como una lista de &lt;code&gt;raises&lt;/code&gt; , tambi&amp;eacute;n se puede adjuntar a un tipo de proceso. Esto afecta la compatibilidad de tipos.</target>
        </trans-unit>
        <trans-unit id="c7c12a1bbcf06851adacdd13e78109f4548a353d" translate="yes" xml:space="preserve">
          <source>A template is a &lt;span id=&quot;hygienic_1&quot;&gt;hygienic&lt;/span&gt; macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</source>
          <target state="translated">Una plantilla es una macro &lt;span id=&quot;hygienic_1&quot;&gt;higi&amp;eacute;nica&lt;/span&gt; y, por lo tanto, abre un nuevo &amp;aacute;mbito. La mayor&amp;iacute;a de los s&amp;iacute;mbolos est&amp;aacute;n vinculados al &amp;aacute;mbito de definici&amp;oacute;n de la plantilla:</target>
        </trans-unit>
        <trans-unit id="3d0909aebdac7146ab483112e0cffc46ee0650d8" translate="yes" xml:space="preserve">
          <source>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</source>
          <target state="translated">Una plantilla es una forma simple de una macro:Es un simple mecanismo de sustitucion que opera en los arboles de sintaxis abstracta de Nim.Se procesa en el pase semántico del compilador.</target>
        </trans-unit>
        <trans-unit id="4957f2f98151d72020ad997ae5b0177dbfe8bd70" translate="yes" xml:space="preserve">
          <source>A template where every parameter is &lt;code&gt;untyped&lt;/code&gt; is called an &lt;span id=&quot;immediate_1&quot;&gt;immediate&lt;/span&gt; template. For historical reasons templates can be explicitly annotated with an &lt;code&gt;immediate&lt;/code&gt; pragma and then these templates do not take part in overloading resolution and the parameters' types are &lt;em&gt;ignored&lt;/em&gt; by the compiler. Explicit immediate templates are now deprecated.</source>
          <target state="translated">Una plantilla en la que cada par&amp;aacute;metro &lt;code&gt;untyped&lt;/code&gt; tiene tipo se denomina plantilla &lt;span id=&quot;immediate_1&quot;&gt;inmediata&lt;/span&gt; . Por razones hist&amp;oacute;ricas, las plantillas se pueden anotar expl&amp;iacute;citamente con un pragma &lt;code&gt;immediate&lt;/code&gt; y luego estas plantillas no participan en la resoluci&amp;oacute;n de sobrecarga y el compilador &lt;em&gt;ignora&lt;/em&gt; los tipos de par&amp;aacute;metros . Las plantillas inmediatas expl&amp;iacute;citas ahora est&amp;aacute;n en desuso.</target>
        </trans-unit>
        <trans-unit id="2c5c46bd6cd44a46ae88e10ca57070a21a6c5dbc" translate="yes" xml:space="preserve">
          <source>A test suite is a series of one or more related tests sharing a common fixture (&lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt;). The fixture is executed for EACH test.</source>
          <target state="translated">Un conjunto de pruebas es una serie de una o m&amp;aacute;s pruebas relacionadas que comparten un dispositivo com&amp;uacute;n ( &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;teardown&lt;/code&gt; ). El dispositivo se ejecuta para CADA prueba.</target>
        </trans-unit>
        <trans-unit id="31bf8aebbb82c9b930fd2c075ab23a6c84bd7bab" translate="yes" xml:space="preserve">
          <source>A thread proc is passed to &lt;code&gt;createThread&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; and invoked indirectly; so the &lt;code&gt;thread&lt;/code&gt; pragma implies &lt;code&gt;procvar&lt;/code&gt;.</source>
          <target state="translated">Se pasa un proceso de &lt;code&gt;createThread&lt;/code&gt; a createThread o &lt;code&gt;spawn&lt;/code&gt; y se invoca indirectamente; por lo que el &lt;code&gt;thread&lt;/code&gt; pragma implica &lt;code&gt;procvar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41bb5d8b499e01e5a1190386e45f8f1ab3dfd432" translate="yes" xml:space="preserve">
          <source>A thunk would need to call 'returnsDefaultCC[i]' somehow and that would require an &lt;em&gt;additional&lt;/em&gt; closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem which this solution is that it's not GC-safe to pass a proc pointer around via a generic &lt;code&gt;ref&lt;/code&gt; type.</source>
          <target state="translated">Un procesador necesitar&amp;iacute;a llamar a 'returnsDefaultCC [i]' de alguna manera y eso requerir&amp;iacute;a una generaci&amp;oacute;n de cierre &lt;em&gt;adicional&lt;/em&gt; ... Ok, no realmente, pero requiere pasar la funci&amp;oacute;n para llamar. Entonces terminar&amp;iacute;amos con 2 llamadas indirectas en lugar de una. Otro problema mucho m&amp;aacute;s grave al que se enfrenta esta soluci&amp;oacute;n es que no es seguro para GC pasar un puntero proc a trav&amp;eacute;s de un tipo de &lt;code&gt;ref&lt;/code&gt; erencia gen&amp;eacute;rico .</target>
        </trans-unit>
        <trans-unit id="a71df16ade8aee765ef43a13e09747416cdfc482" translate="yes" xml:space="preserve">
          <source>A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.</source>
          <target state="translated">Se puede especificar un tiempo de espera en milisegundos,si los datos no se reciben dentro del tiempo especificado se planteará una excepción de ETimeout.</target>
        </trans-unit>
        <trans-unit id="9b5284b25f36831bd8cd3b0848696b52af7ef955" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</source>
          <target state="translated">Se puede especificar un tiempo de espera en milisegundos,si no se reciben suficientes datos en el tiempo especificado se planteará una excepción de ETimeout.</target>
        </trans-unit>
        <trans-unit id="b206d5f711dced99df1aa8e9ea0d1479edc748b9" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an TimeoutError exception will be raised.</source>
          <target state="translated">El tiempo de espera puede especificarse en milisegundos,si no se reciben suficientes datos en el tiempo especificado se planteará una excepción de TimeoutError.</target>
        </trans-unit>
        <trans-unit id="5a5e0bec046a288f45da3539bee961bd4b7e1bc5" translate="yes" xml:space="preserve">
          <source>A tuple type defines various named &lt;em&gt;fields&lt;/em&gt; and an &lt;em&gt;order&lt;/em&gt; of the fields. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify fields of the same type and of the same name in the same order.</source>
          <target state="translated">Un tipo de tupla define varios &lt;em&gt;campos con&lt;/em&gt; nombre y un &lt;em&gt;orden&lt;/em&gt; de los campos. El constructor &lt;code&gt;()&lt;/code&gt; se puede utilizar para construir tuplas. El orden de los campos en el constructor debe coincidir con el orden en la definici&amp;oacute;n de la tupla. Diferentes tipos de tupla son &lt;em&gt;equivalentes&lt;/em&gt; si especifican campos del mismo tipo y del mismo nombre en el mismo orden.</target>
        </trans-unit>
        <trans-unit id="5e6444b3f99eb953e87888c66966bcbc524ea4f4" translate="yes" xml:space="preserve">
          <source>A tuple with one unnamed field can be constructed with the parentheses and a trailing comma:</source>
          <target state="translated">Se puede construir una tupla con un campo sin nombre con los paréntesis y una coma:</target>
        </trans-unit>
        <trans-unit id="14170c2ff1e7de54f4e2348d1e871df1403c7064" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;explicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">Un tipo &lt;code&gt;a&lt;/code&gt; es &lt;strong&gt;expl&amp;iacute;citamente&lt;/strong&gt; convertible en tipo &lt;code&gt;b&lt;/code&gt; si el siguiente algoritmo devuelve verdadero:</target>
        </trans-unit>
        <trans-unit id="0e266a33b4be68e2d75b658bf09d5fcd023a82b7" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;implicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">Un tipo &lt;code&gt;a&lt;/code&gt; es &lt;strong&gt;impl&amp;iacute;citamente&lt;/strong&gt; convertible en tipo &lt;code&gt;b&lt;/code&gt; si el siguiente algoritmo devuelve verdadero:</target>
        </trans-unit>
        <trans-unit id="506a88b6ff206893ad4b7e57e9c4e7e99b518ff4" translate="yes" xml:space="preserve">
          <source>A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the &lt;code&gt;is&lt;/code&gt; operator. Nim supports the following built-in type classes:</source>
          <target state="translated">Una clase de tipo es un pseudo-tipo especial que se puede utilizar para comparar tipos en el contexto de la resoluci&amp;oacute;n de sobrecarga o el operador &lt;code&gt;is&lt;/code&gt; . Nim admite las siguientes clases de tipos integradas:</target>
        </trans-unit>
        <trans-unit id="ec2661446eb8287aeb52ad012da364775c3dbaac" translate="yes" xml:space="preserve">
          <source>A type section begins with the &lt;code&gt;type&lt;/code&gt; keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single &lt;code&gt;type&lt;/code&gt; section. Nominal types like &lt;code&gt;objects&lt;/code&gt; or &lt;code&gt;enums&lt;/code&gt; can only be defined in a &lt;code&gt;type&lt;/code&gt; section.</source>
          <target state="translated">Una secci&amp;oacute;n de tipo comienza con la palabra clave &lt;code&gt;type&lt;/code&gt; . Contiene m&amp;uacute;ltiples definiciones de tipos. Una definici&amp;oacute;n de tipo vincula un tipo a un nombre. Las definiciones de tipos pueden ser recursivas o incluso recursivas entre s&amp;iacute;. Los tipos recursivos mutuos solo son posibles dentro de una &amp;uacute;nica secci&amp;oacute;n de &lt;code&gt;type&lt;/code&gt; . Los tipos nominales como &lt;code&gt;objects&lt;/code&gt; o &lt;code&gt;enums&lt;/code&gt; solo se pueden definir en una secci&amp;oacute;n de &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0511cf3cc72e09256f19cf736ca74f42546431bf" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&lt;/code&gt; for convenience so that mixing integer types work better.</source>
          <target state="translated">Una versi&amp;oacute;n especializada en tipos de &lt;code&gt;..&lt;/code&gt; por conveniencia para que la combinaci&amp;oacute;n de tipos enteros funcione mejor.</target>
        </trans-unit>
        <trans-unit id="1aca1ed394a97d0358e43ad02e64f2e9f0dad035" translate="yes" xml:space="preserve">
          <source>A valid identifier starts with a character of the set &lt;em&gt;IdentStartChars&lt;/em&gt; and is followed by any number of characters of the set &lt;em&gt;IdentChars&lt;/em&gt;.</source>
          <target state="translated">Un identificador v&amp;aacute;lido comienza con un car&amp;aacute;cter del conjunto &lt;em&gt;IdentStartChars&lt;/em&gt; y va seguido de cualquier n&amp;uacute;mero de caracteres del conjunto &lt;em&gt;IdentChars&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d0abd94780a5ea8e9be893452be742a7ec90a256" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;Option[T]&lt;/code&gt; either contains a value &lt;em&gt;x&lt;/em&gt; (represented as &lt;code&gt;some(x)&lt;/code&gt;) or is empty (&lt;code&gt;none(T)&lt;/code&gt;).</source>
          <target state="translated">Un valor de tipo &lt;code&gt;Option[T]&lt;/code&gt; contiene un valor &lt;em&gt;x&lt;/em&gt; (representado como &lt;code&gt;some(x)&lt;/code&gt; ) o est&amp;aacute; vac&amp;iacute;o ( &lt;code&gt;none(T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="061691c897942e6f7639e5b9fc01836fcff953a0" translate="yes" xml:space="preserve">
          <source>A variable can be marked with the &lt;code&gt;threadvar&lt;/code&gt; pragma, which makes it a &lt;span id=&quot;threadminuslocal_1&quot;&gt;thread-local&lt;/span&gt; variable; Additionally, this implies all the effects of the &lt;code&gt;global&lt;/code&gt; pragma.</source>
          <target state="translated">Una variable se puede marcar con &lt;code&gt;threadvar&lt;/code&gt; pragma, lo que la convierte en una variable &lt;span id=&quot;threadminuslocal_1&quot;&gt;local de subproceso&lt;/span&gt; ; Adem&amp;aacute;s, esto implica todos los efectos del pragma &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf2d03ae6a2d13d0af73951ec3e536467f5ec85" translate="yes" xml:space="preserve">
          <source>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects and sets belong to the structured types.</source>
          <target state="translated">Una variable de tipo estructurado puede contener múltiples valores al mismo tiempo.Los tipos estructurados pueden anidarse a niveles ilimitados.Los arreglos,secuencias,tuplas,objetos y conjuntos pertenecen a los tipos estructurados.</target>
        </trans-unit>
        <trans-unit id="c3f3d14f490e58bdf5285ce0bef4d7745002ec1a" translate="yes" xml:space="preserve">
          <source>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named &lt;em&gt;fields&lt;/em&gt; of a type. A tuple also defines an &lt;em&gt;order&lt;/em&gt; of the fields. Tuples are meant for heterogeneous storage types with no overhead and few abstraction possibilities. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify the same fields of the same type in the same order. The &lt;em&gt;names&lt;/em&gt; of the fields also have to be identical.</source>
          <target state="translated">Una variable de tupla o tipo de objeto es un contenedor de almacenamiento heterog&amp;eacute;neo. Una tupla u objeto define varios &lt;em&gt;campos con&lt;/em&gt; nombre de un tipo. Una tupla tambi&amp;eacute;n define un &lt;em&gt;orden&lt;/em&gt; de los campos. Las tuplas est&amp;aacute;n pensadas para tipos de almacenamiento heterog&amp;eacute;neos sin gastos generales y con pocas posibilidades de abstracci&amp;oacute;n. El constructor &lt;code&gt;()&lt;/code&gt; se puede utilizar para construir tuplas. El orden de los campos en el constructor debe coincidir con el orden de la definici&amp;oacute;n de la tupla. Diferentes tipos de tupla son &lt;em&gt;equivalentes&lt;/em&gt; si especifican los mismos campos del mismo tipo en el mismo orden. Los &lt;em&gt;nombres&lt;/em&gt; de los campos tambi&amp;eacute;n deben ser id&amp;eacute;nticos.</target>
        </trans-unit>
        <trans-unit id="7bdc1f89d378b40222906883361628b1181e0aa3" translate="yes" xml:space="preserve">
          <source>A variable of an enumeration type can only be assigned one of the enumeration's specified values. These values are a set of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1 and so on. For example:</source>
          <target state="translated">A una variable de un tipo de enumeración sólo se le puede asignar uno de los valores especificados de la enumeración.Estos valores son un conjunto de símbolos ordenados.Cada símbolo se asigna internamente a un valor entero.El primer símbolo se representa en tiempo de ejecución por 0,el segundo por 1 y así sucesivamente.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="03eb03003aebc272b7eb136b33ffcf55da04a588" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;connect&lt;/code&gt; for non-blocking sockets.</source>
          <target state="translated">Una variante de &lt;code&gt;connect&lt;/code&gt; para enchufes sin bloqueo.</target>
        </trans-unit>
        <trans-unit id="71ed9093f7d2c5cbb9aa8a3933ec4cb522e39e48" translate="yes" xml:space="preserve">
          <source>A while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The &lt;code&gt;block&lt;/code&gt; statement can be used to open a new block explicitly:</source>
          <target state="translated">Una instrucci&amp;oacute;n while (for) introduce un bloque impl&amp;iacute;cito. Los identificadores solo son visibles dentro del bloque que han sido declarados. La declaraci&amp;oacute;n de &lt;code&gt;block&lt;/code&gt; se puede utilizar para abrir un nuevo bloque expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="bc56783853877b4342018f4f4752a7c166237a4d" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\W&lt;/code&gt; (i.e. one matches &lt;code&gt;\w&lt;/code&gt; and the other matches &lt;code&gt;\W&lt;/code&gt;), or the start or end of the string if the first or last character matches &lt;code&gt;\w&lt;/code&gt;, respectively.</source>
          <target state="translated">Un l&amp;iacute;mite de palabra es una posici&amp;oacute;n en la cadena de asunto donde el car&amp;aacute;cter actual y el car&amp;aacute;cter anterior no coinciden con &lt;code&gt;\w&lt;/code&gt; o &lt;code&gt;\W&lt;/code&gt; (es decir, uno coincide con &lt;code&gt;\w&lt;/code&gt; y el otro con &lt;code&gt;\W&lt;/code&gt; ), o el comienzo o el final de la cadena si el primer o &amp;uacute;ltimo car&amp;aacute;cter coincide con &lt;code&gt;\w&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="469aae2fa20a5b364724db93849620fbab87ad21" translate="yes" xml:space="preserve">
          <source>API naming design</source>
          <target state="translated">Diseño del nombre de la API</target>
        </trans-unit>
        <trans-unit id="6e86868dfa064831def0a9a32949fcd3f02c8b05" translate="yes" xml:space="preserve">
          <source>AST based overloading</source>
          <target state="translated">Sobrecarga basada en la AST</target>
        </trans-unit>
        <trans-unit id="b08670d9d509dc53f0d69a06ccafcdfc0680021a" translate="yes" xml:space="preserve">
          <source>AST:</source>
          <target state="translated">AST:</target>
        </trans-unit>
        <trans-unit id="ed89ae3b78e13637e55b85c4b03f6daaccfcbc6b" translate="yes" xml:space="preserve">
          <source>Abbreviated three-letter form of the month.</source>
          <target state="translated">Forma abreviada de tres letras del mes.</target>
        </trans-unit>
        <trans-unit id="02befbd420c9754ded8c9a688a174615ddafd2a6" translate="yes" xml:space="preserve">
          <source>About this document</source>
          <target state="translated">Sobre este documento</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="1b33443d15e91efce2e27797d2c769792a4be765" translate="yes" xml:space="preserve">
          <source>Abstract base class for all exceptions that Nim's runtime raises but that are strictly uncatchable as they can also be mapped to a &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; operation.</source>
          <target state="translated">Clase base abstracta para todas las excepciones de tiempo de ejecuci&amp;oacute;n que eleva de Nim, pero que son estrictamente inalcanzable, ya que tambi&amp;eacute;n se pueden asignar a un &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="07ade5cd2426cf2d96d9f115a542fdf23ea73fb2" translate="yes" xml:space="preserve">
          <source>Abstract class for all exceptions that are catchable.</source>
          <target state="translated">Clase abstracta para todas las excepciones que son capturables.</target>
        </trans-unit>
        <trans-unit id="1cf35ec1eeb0cdf41c798e53ae7c4bdbcf3c6e03" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;astGenRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Acepta un bloque de c&amp;oacute;digo nim e imprime el &amp;aacute;rbol de sintaxis abstracta analizado usando la funci&amp;oacute;n &lt;em&gt;astGenRepr&lt;/em&gt; . La impresi&amp;oacute;n se realiza &lt;em&gt;en tiempo de compilaci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6e301f36546045d51728adbff6b973b0918094" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;lispRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Acepta un bloque de c&amp;oacute;digo nim e imprime el &amp;aacute;rbol de sintaxis abstracta analizado usando la funci&amp;oacute;n &lt;em&gt;lispRepr&lt;/em&gt; . La impresi&amp;oacute;n se realiza &lt;em&gt;en tiempo de compilaci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7eb919c05e9f3591e4b18f0af2d7cce492e0545f" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;treeRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Acepta un bloque de c&amp;oacute;digo nim e imprime el &amp;aacute;rbol de sintaxis abstracta analizado mediante la funci&amp;oacute;n &lt;em&gt;treeRepr&lt;/em&gt; . La impresi&amp;oacute;n se realiza &lt;em&gt;en tiempo de compilaci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce207f0652d5a79c6fb92d9892844f64c3c7bc7f" translate="yes" xml:space="preserve">
          <source>Accepts a new client connection.</source>
          <target state="translated">Acepta una nueva conexión con el cliente.</target>
        </trans-unit>
        <trans-unit id="0612c97d4b20e5af1b9ee2e86992dd16c29c8cbf" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">Acepta una nueva conexión.Devuelve un futuro que contiene el enchufe del cliente correspondiente a esa conexión y la dirección remota del cliente.El futuro se completará cuando la conexión sea aceptada con éxito.</target>
        </trans-unit>
        <trans-unit id="bb38da96bcf63ef07293cca8f7fae610327e435b" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">Acepta una nueva conexión.Devuelve un futuro que contiene el enchufe del cliente correspondiente a esa conexión.El futuro se completará cuando la conexión sea aceptada con éxito.</target>
        </trans-unit>
        <trans-unit id="6813381cdc37c15725205e39fd4619d20653f02f" translate="yes" xml:space="preserve">
          <source>Accepts an instantiated generic type and returns its uninstantiated form.</source>
          <target state="translated">Acepta un tipo genérico instanciado y devuelve su forma no instanciada.</target>
        </trans-unit>
        <trans-unit id="faf4ef0e56229453f96a306fcf1a0f1923d413de" translate="yes" xml:space="preserve">
          <source>Acceses a specified &lt;em&gt;entry&lt;/em&gt; from the current row.</source>
          <target state="translated">Accede a una &lt;em&gt;entrada&lt;/em&gt; especificada de la fila actual.</target>
        </trans-unit>
        <trans-unit id="f9e9dd7a48db03f7a1f9615c265496ab948af3da" translate="yes" xml:space="preserve">
          <source>Access the currently matched character</source>
          <target state="translated">Accede al personaje actualmente coincidente</target>
        </trans-unit>
        <trans-unit id="9e2f25bad75994a6d0402acd174ffe98487bb1e8" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; and returns a mutable reference to it.</source>
          <target state="translated">Accede al elemento i-&amp;eacute;simo de &lt;em&gt;deq&lt;/em&gt; y devuelve una referencia mutable a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="b235504e101d141812cbd31b5736348cbd949d54" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; by order from first to last. deq[0] is the first, deq[^1] is the last.</source>
          <target state="translated">Acceda al elemento i-&amp;eacute;simo de &lt;em&gt;deq&lt;/em&gt; por orden del primero al &amp;uacute;ltimo. deq [0] es el primero, deq [^ 1] es el &amp;uacute;ltimo.</target>
        </trans-unit>
        <trans-unit id="c47d1e40dccddf8bf9622ec7b3c9e44c4af97584" translate="yes" xml:space="preserve">
          <source>Accumulator</source>
          <target state="translated">Accumulator</target>
        </trans-unit>
        <trans-unit id="737a162e2ca0961109be76dcbc40928b7272da0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock and then executes the code.</source>
          <target state="translated">Adquiere la cerradura dada y luego ejecuta el código.</target>
        </trans-unit>
        <trans-unit id="e94c5bb8f50ed78a7cd750db454d2af3ae23df56" translate="yes" xml:space="preserve">
          <source>Acquires the given lock, executes the statements in body and releases the lock after the statements finish executing.</source>
          <target state="translated">Adquiere el candado dado,ejecuta las declaraciones en cuerpo y libera el candado después de que las declaraciones terminen de ejecutarse.</target>
        </trans-unit>
        <trans-unit id="1a3e3046bdb90198f8603411233d3c6451ca3f0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock.</source>
          <target state="translated">Adquiere la cerradura dada.</target>
        </trans-unit>
        <trans-unit id="d2f9d48fe60d96f7c86fe92fea51a30eef86ea2a" translate="yes" xml:space="preserve">
          <source>Acts in a similar fashion to the &lt;em&gt;recvLine&lt;/em&gt; in the sockets module. Returns false when no data is available to be read. &lt;em&gt;Line&lt;/em&gt; must be initialized and not nil!</source>
          <target state="translated">Act&amp;uacute;a de forma similar a &lt;em&gt;recvLine&lt;/em&gt; en el m&amp;oacute;dulo de sockets. Devuelve falso cuando no hay datos disponibles para leer. &lt;em&gt;&amp;iexcl;La l&amp;iacute;nea&lt;/em&gt; debe estar inicializada y no nula!</target>
        </trans-unit>
        <trans-unit id="b05779dfde7404de32c688c1c9a48959dd22bdd2" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;y&lt;/em&gt; a &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4feee750a058b68182288ba271fbda6845aca1fd" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;y&lt;/em&gt; al n&amp;uacute;mero complejo &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c680f465bd9dc1e03f6e6d6ea7255c81ff7a44a5" translate="yes" xml:space="preserve">
          <source>Add a duration of time to a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Agregue una duraci&amp;oacute;n de tiempo a un &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0329e59f93f564c5dfc0e70569d15fb9e15a73e3" translate="yes" xml:space="preserve">
          <source>Add a file to the multipart data &lt;em&gt;p&lt;/em&gt;, specifying filename, contentType and content manually.</source>
          <target state="translated">Agregue un archivo a los datos de varias partes &lt;em&gt;p&lt;/em&gt; , especificando el nombre de archivo, contentType y content manualmente.</target>
        </trans-unit>
        <trans-unit id="eec5847211247b4fd74ccdc819e2406c975b05b5" translate="yes" xml:space="preserve">
          <source>Add a list of multipart entries to the multipart data &lt;em&gt;p&lt;/em&gt;. All values are added without a filename and without a content type.</source>
          <target state="translated">Agregue una lista de entradas multiparte a los datos multiparte &lt;em&gt;p&lt;/em&gt; . Todos los valores se agregan sin un nombre de archivo y sin un tipo de contenido.</target>
        </trans-unit>
        <trans-unit id="798a336ba2abb70a55f061577e20dced31fde63c" translate="yes" xml:space="preserve">
          <source>Add a multipart entry to the multipart data &lt;em&gt;p&lt;/em&gt;. The value is added without a filename and without a content type.</source>
          <target state="translated">Agregue una entrada de varias partes a los datos de varias partes &lt;em&gt;p&lt;/em&gt; . El valor se agrega sin un nombre de archivo y sin un tipo de contenido.</target>
        </trans-unit>
        <trans-unit id="f04550fc57e117bf8d9e7db6f83bdeafaba0d38d" translate="yes" xml:space="preserve">
          <source>Add a value to the multipart data. Raises a &lt;em&gt;ValueError&lt;/em&gt; exception if &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;filename&lt;/em&gt; or &lt;em&gt;contentType&lt;/em&gt; contain newline characters.</source>
          <target state="translated">Agregue un valor a los datos de varias partes. &lt;em&gt;Genera&lt;/em&gt; una excepci&amp;oacute;n &lt;em&gt;ValueError&lt;/em&gt; si el &lt;em&gt;nombre&lt;/em&gt; , el &lt;em&gt;nombre de &lt;/em&gt;&lt;em&gt;archivo&lt;/em&gt; o &lt;em&gt;contentType&lt;/em&gt; contienen caracteres de nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="772b15743a6941c602fc6966a8c9ad76de348c4b" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the beginning of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Agregue un &lt;em&gt;elemento&lt;/em&gt; al comienzo de la &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2f6d2bfa601515402b5cd9a27e6de27a42f1ae49" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the end of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Agregue un &lt;em&gt;elemento&lt;/em&gt; al final de la &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="804dca14340f9191ea44cbc9a5b612d3b7b60531" translate="yes" xml:space="preserve">
          <source>Add complex &lt;em&gt;x&lt;/em&gt; to float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma el complejo &lt;em&gt;x&lt;/em&gt; para flotar &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91af401e69eb5db85492da365b587bfdcdd3c94f" translate="yes" xml:space="preserve">
          <source>Add files to a multipart data object. The file will be opened from your disk, read and sent with the automatically determined MIME type. Raises an &lt;em&gt;IOError&lt;/em&gt; if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use &lt;em&gt;[]=&lt;/em&gt; instead.</source>
          <target state="translated">Agregue archivos a un objeto de datos de varias partes. El archivo se abrir&amp;aacute; desde su disco, se leer&amp;aacute; y enviar&amp;aacute; con el tipo MIME determinado autom&amp;aacute;ticamente. Genera un &lt;em&gt;IOError&lt;/em&gt; si el archivo no se puede abrir o la lectura falla. Para especificar manualmente el contenido del archivo, el nombre del archivo y el tipo MIME, utilice &lt;em&gt;[] = en su&lt;/em&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="406ccec3a46c7096b360cd3465737a8b535aea4c" translate="yes" xml:space="preserve">
          <source>Add float &lt;em&gt;x&lt;/em&gt; to complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma float &lt;em&gt;x&lt;/em&gt; al complejo &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="505c6693913fe1565ef1c731c3ebc737609d4c48" translate="yes" xml:space="preserve">
          <source>Add ident to dest if it is not present. This is intended for use with pragmas.</source>
          <target state="translated">Añade la identificación al destino si no está presente.Esto está destinado a ser usado con los pragmas.</target>
        </trans-unit>
        <trans-unit id="b50017805b1b6fc4f451182d9127fec897f8b761" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;x&lt;/em&gt; to rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma int &lt;em&gt;x&lt;/em&gt; a &lt;em&gt;y&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="9fd52413273ba8dedf3c71352a83c577246c8699" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma int &lt;em&gt;y&lt;/em&gt; a &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="f18a8ab635db264a0fe3a0922ec6560932edcddf" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;x&lt;/em&gt; to int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;x&lt;/em&gt; racional a int &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa6c134ddb31344adb0018507fd22c268b0cb12" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;y&lt;/em&gt; racional a &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="d1747c4bec3777bff15f92b0cac11995facbb754" translate="yes" xml:space="preserve">
          <source>Add two complex numbers.</source>
          <target state="translated">Sume dos números complejos.</target>
        </trans-unit>
        <trans-unit id="10e886ac53c1940ea63eb1399092efb3e0175be5" translate="yes" xml:space="preserve">
          <source>Add two durations together.</source>
          <target state="translated">Sume dos duraciones juntas.</target>
        </trans-unit>
        <trans-unit id="918bdd0b6e0ab8c7e512d1c14637656e65c676d4" translate="yes" xml:space="preserve">
          <source>Add two rational numbers.</source>
          <target state="translated">Sume dos números racionales.</target>
        </trans-unit>
        <trans-unit id="f9f4e2a4ee342e53c003797651594c460da995fd" translate="yes" xml:space="preserve">
          <source>Adding a method to a class the programmer has no control over is impossible or needs ugly workarounds.</source>
          <target state="translated">Añadir un método a una clase sobre la que el programador no tiene control es imposible o requiere de un feo trabajo.</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">Características adicionales</target>
        </trans-unit>
        <trans-unit id="050d53ae9db89d00328e7590301c21bc8b18552a" translate="yes" xml:space="preserve">
          <source>Additional compilation switches</source>
          <target state="translated">Interruptores de compilación adicionales</target>
        </trans-unit>
        <trans-unit id="40896bd1d7fb4e2d2b859f8c06ae9aa5ebd3ac5f" translate="yes" xml:space="preserve">
          <source>Additional documentation about Nim's GC and how to operate it in a</source>
          <target state="translated">Documentación adicional sobre el GC de Nim y cómo operarlo en un</target>
        </trans-unit>
        <trans-unit id="a15fa56393dfeea6e8ddbb0e0c2a6f3cc24b93de" translate="yes" xml:space="preserve">
          <source>Additional resources</source>
          <target state="translated">Recursos adicionales</target>
        </trans-unit>
        <trans-unit id="683593bbc9f4d0095e1a329b2a170a4f6b64749a" translate="yes" xml:space="preserve">
          <source>Additionally adds the encosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.</source>
          <target state="translated">Además añade el texto encapsulado al índice como un término.Dado que nos interesa que diferentes instancias del mismo término tengan diferentes entradas,se utiliza una tabla para llevar un registro de la cantidad de veces que un término ha aparecido anteriormente para dar un valor de identificación diferente para cada una.</target>
        </trans-unit>
        <trans-unit id="83025bdbec6a244fe913cb7d0ff67dac39e81e46" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass a value along with the symbol: &lt;code&gt;-d:x=y&lt;/code&gt; which may be used in conjunction with the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;compile time define pragmas&lt;/a&gt; to override symbols during build time.</source>
          <target state="translated">Adem&amp;aacute;s, puede pasar un valor junto con el s&amp;iacute;mbolo: &lt;code&gt;-d:x=y&lt;/code&gt; que puede usarse junto con los &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;pragmas de definici&amp;oacute;n de tiempo de compilaci&amp;oacute;n&lt;/a&gt; para anular los s&amp;iacute;mbolos durante el tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c9cc91072a9c61406bb688685c655da8fcf1e11e" translate="yes" xml:space="preserve">
          <source>Addr operator</source>
          <target state="translated">Operador de la dirección</target>
        </trans-unit>
        <trans-unit id="e6513e72133cdea4324350e6d4ade50552f0fa2a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;arg&lt;/code&gt; as a &lt;code&gt;Node&lt;/code&gt; to the &lt;code&gt;NList&lt;/code&gt; If a node with the same name is already present in this map, it is replaced by the new one.</source>
          <target state="translated">Agrega &lt;code&gt;arg&lt;/code&gt; como un &lt;code&gt;Node&lt;/code&gt; a &lt;code&gt;NList&lt;/code&gt; . Si un nodo con el mismo nombre ya est&amp;aacute; presente en este mapa, se reemplaza por el nuevo.</target>
        </trans-unit>
        <trans-unit id="c0973ea96bcd93e616194aea6ada7ee253f95770" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;handler&lt;/code&gt; to the list of handlers.</source>
          <target state="translated">Agrega &lt;code&gt;handler&lt;/code&gt; a la lista de controladores.</target>
        </trans-unit>
        <trans-unit id="09af7b91c6e7df51cd37d298bdc37f650d040831" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are added in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">Agrega &lt;code&gt;interval&lt;/code&gt; o a &lt;code&gt;dt&lt;/code&gt; . Los componentes del &lt;code&gt;interval&lt;/code&gt; o se agregan en el orden de su tama&amp;ntilde;o, es decir, primero el componente de &lt;code&gt;years&lt;/code&gt; , luego el componente de &lt;code&gt;months&lt;/code&gt; y as&amp;iacute; sucesivamente. El &lt;code&gt;DateTime&lt;/code&gt; devuelto tendr&amp;aacute; la misma zona horaria que la entrada.</target>
        </trans-unit>
        <trans-unit id="b3703e66f4731d1cd49994e51655ed816fcd0462" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;mimetype&lt;/code&gt; to the &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">Agrega &lt;code&gt;mimetype&lt;/code&gt; al &lt;code&gt;mimedb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d55bd8510c4909907c3b0b1b51f22ef8bfe1dc23" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initalized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">Suma &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; a menos que &lt;code&gt;x&lt;/code&gt; no se haya iniciado todav&amp;iacute;a; en ese caso, &lt;code&gt;x&lt;/code&gt; se convierte en &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08dd7691271b1b3cf31cdaad9abf0dd1ed892c5b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initialized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;@[y]&lt;/code&gt;</source>
          <target state="translated">Suma &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; a menos que &lt;code&gt;x&lt;/code&gt; a&amp;uacute;n no se haya inicializado; en ese caso, &lt;code&gt;x&lt;/code&gt; se convierte en &lt;code&gt;@[y]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="910ee17a6a799e67a937708e73b9aedb33f3b0aa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; it is initialized to &lt;code&gt;&quot;&quot;&lt;/code&gt;</source>
          <target state="translated">Suma &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;nil&lt;/code&gt; , se inicializa en &lt;code&gt;&quot;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4d013d42946fcbe3af0f01b7362386e1eb7f928" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a JArray node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">Agrega &lt;em&gt;hijo&lt;/em&gt; a un &lt;em&gt;padre de&lt;/em&gt; nodo JArray .</target>
        </trans-unit>
        <trans-unit id="277d7264e0b31954fb3f91658c21ef53fbc9f98b" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a SList node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">Agrega &lt;em&gt;hijo&lt;/em&gt; a un &lt;em&gt;padre de&lt;/em&gt; nodo SList .</target>
        </trans-unit>
        <trans-unit id="282a03494ac60232eca16c10011aa2a3e77244c0" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;interval&lt;/em&gt; to &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">Agrega &lt;em&gt;intervalo&lt;/em&gt; al &lt;em&gt;tiempo&lt;/em&gt; . Si el &lt;em&gt;intervalo&lt;/em&gt; contiene a&amp;ntilde;os, meses, semanas o d&amp;iacute;as, la operaci&amp;oacute;n se realiza en la zona horaria local.</target>
        </trans-unit>
        <trans-unit id="168959e8e3da827112e6480f035af90769452610" translate="yes" xml:space="preserve">
          <source>Adds a &lt;em&gt;term&lt;/em&gt; to the index using the specified hyperlink identifier.</source>
          <target state="translated">Agrega un &lt;em&gt;t&amp;eacute;rmino&lt;/em&gt; al &amp;iacute;ndice utilizando el identificador de hiperv&amp;iacute;nculo especificado.</target>
        </trans-unit>
        <trans-unit id="46517870669c98767730789efc1c2a63afe0fd37" translate="yes" xml:space="preserve">
          <source>Adds a char to string &lt;em&gt;s&lt;/em&gt; and applies the following escaping:</source>
          <target state="translated">Agrega un car&amp;aacute;cter a la cadena &lt;em&gt;sy&lt;/em&gt; aplica el siguiente escape:</target>
        </trans-unit>
        <trans-unit id="1f8aac4240d0d2f3105af4d844dbcb2abbdecf97" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the localName and namespaceURI of &lt;code&gt;newAttr&lt;/code&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Agrega un nuevo nodo de atributo, si hay un atributo con localName y namespaceURI de &lt;code&gt;newAttr&lt;/code&gt; , se reemplaza por el nuevo y se devuelve el atributo reemplazado; de lo contrario, se devuelve &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49966f2ea34f557267d410935160fd5454f498db" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the same &lt;em&gt;nodeName&lt;/em&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Agrega un nuevo atributo nodo, si hay un atributo con el mismo &lt;em&gt;nodeName&lt;/em&gt; , se reemplaza por el nuevo y se devuelve el atributo reemplazado, de lo contrario se devuelve &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d941c7f90a962f0302be00a817bf48658be8c09" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; If an attribute with that name is already present in the element, its value is changed to be that of the value parameter Raises the EInvalidCharacterErr if the specified &lt;code&gt;name&lt;/code&gt; contains illegal characters</source>
          <target state="translated">Agrega un nuevo atributo, seg&amp;uacute;n lo especificado por el &lt;code&gt;name&lt;/code&gt; y el &lt;code&gt;value&lt;/code&gt; Si un atributo con ese nombre ya est&amp;aacute; presente en el elemento, su valor se cambia para que sea el del par&amp;aacute;metro de valor Eleva el EInvalidCharacterErr si el &lt;code&gt;name&lt;/code&gt; especificado contiene caracteres ilegales</target>
        </trans-unit>
        <trans-unit id="70b9921234cbd8dc467e865419512e1db5aa80e1" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;namespaceURI&lt;/code&gt;, &lt;code&gt;localName&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Agrega un nuevo atributo, seg&amp;uacute;n lo especificado por &lt;code&gt;namespaceURI&lt;/code&gt; , &lt;code&gt;localName&lt;/code&gt; y &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175780a3fa3d64a9dc7aa37e3d80ca0adc76b294" translate="yes" xml:space="preserve">
          <source>Adds a node using its &lt;code&gt;namespaceURI&lt;/code&gt; and &lt;code&gt;localName&lt;/code&gt;</source>
          <target state="translated">Agrega un nodo usando su &lt;code&gt;namespaceURI&lt;/code&gt; y &lt;code&gt;localName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71b9366e5b895a616623ffad66668f7f54484c12" translate="yes" xml:space="preserve">
          <source>Adds a separator to &lt;em&gt;dest&lt;/em&gt; only if its length is bigger than &lt;em&gt;startLen&lt;/em&gt;.</source>
          <target state="translated">Agrega un separador a &lt;em&gt;dest&lt;/em&gt; solo si su longitud es mayor que &lt;em&gt;startLen&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="719fea5dd090dc5f35241a78b628149a3f6e753c" translate="yes" xml:space="preserve">
          <source>Adds each child of &lt;em&gt;children&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the &lt;em&gt;father&lt;/em&gt; node so that calls can be nested.</source>
          <target state="translated">Agrega cada hijo de los &lt;em&gt;hijos&lt;/em&gt; al nodo &lt;em&gt;padre&lt;/em&gt; . Devuelve el nodo &lt;em&gt;padre&lt;/em&gt; para que las llamadas se puedan anidar.</target>
        </trans-unit>
        <trans-unit id="77594e2b861c1fa8f8e68498df51e03371d37a9b" translate="yes" xml:space="preserve">
          <source>Adds pragma to routine definition</source>
          <target state="translated">Añade pragmatismo a la definición de rutina</target>
        </trans-unit>
        <trans-unit id="392b56977e8236b6698f4ca58ac6c2f28d25c68f" translate="yes" xml:space="preserve">
          <source>Adds the &lt;em&gt;child&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the father node so that calls can be nested.</source>
          <target state="translated">Agrega el &lt;em&gt;hijo&lt;/em&gt; al nodo &lt;em&gt;padre&lt;/em&gt; . Devuelve el nodo padre para que las llamadas se puedan anidar.</target>
        </trans-unit>
        <trans-unit id="4be1f166b02d308f1b99389ad08b9ecee806fca1" translate="yes" xml:space="preserve">
          <source>Adds the callbacks proc to be called when the future completes.</source>
          <target state="translated">Añade el procedimiento de devolución de llamadas que se llamará cuando el futuro se complete.</target>
        </trans-unit>
        <trans-unit id="087cbeb9fcc85f71b469524d8a7510230c6f6abc" translate="yes" xml:space="preserve">
          <source>Adds the file extension &lt;em&gt;ext&lt;/em&gt; to &lt;em&gt;filename&lt;/em&gt;, unless &lt;em&gt;filename&lt;/em&gt; already has an extension.</source>
          <target state="translated">Agrega la extensi&amp;oacute;n de archivo &lt;em&gt;ext&lt;/em&gt; al &lt;em&gt;nombre&lt;/em&gt; de &lt;em&gt;archivo&lt;/em&gt; , a menos que el &lt;em&gt;nombre de archivo&lt;/em&gt; ya tenga una extensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38e43d237023eab5acc2b848d42530e464a0a37f" translate="yes" xml:space="preserve">
          <source>Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.</source>
          <target state="translated">Añade el nodo newChild al final de la lista de hijos de este nodo.Si el newChild ya está en el árbol,primero se elimina.</target>
        </trans-unit>
        <trans-unit id="2a72a2ff357c75992d2d25db54f40e31c444189e" translate="yes" xml:space="preserve">
          <source>Adds the specified value to the specified key. Appends to any existing values associated with the key.</source>
          <target state="translated">Añade el valor especificado a la clave especificada.Añade a cualquier valor existente asociado a la clave.</target>
        </trans-unit>
        <trans-unit id="dcb76173f8b3f736f04cf7a85a76442e3061c9f2" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;TimeInterval&lt;/code&gt; objects together.</source>
          <target state="translated">Agrega dos objetos &lt;code&gt;TimeInterval&lt;/code&gt; juntos.</target>
        </trans-unit>
        <trans-unit id="0cd028f03aa8100d6b3d714eae3d5348fe823a2f" translate="yes" xml:space="preserve">
          <source>Adds/registers a quit procedure.</source>
          <target state="translated">Añade/registra un procedimiento para dejar de fumar.</target>
        </trans-unit>
        <trans-unit id="5090ef07df2944062324712ca6950298e056c7f1" translate="yes" xml:space="preserve">
          <source>Adopting type for gui inspector in a game engine:</source>
          <target state="translated">Adoptando el tipo para el inspector de guias en un motor de juego:</target>
        </trans-unit>
        <trans-unit id="cd58779782de2792380285200da5a98425f86d02" translate="yes" xml:space="preserve">
          <source>Advanced command line switches are:</source>
          <target state="translated">Los interruptores avanzados de la línea de mando son:</target>
        </trans-unit>
        <trans-unit id="7a3a43835953e413f721f837036117df744dbd00" translate="yes" xml:space="preserve">
          <source>Advanced commands:</source>
          <target state="translated">Comandos avanzados:</target>
        </trans-unit>
        <trans-unit id="21604196a5b5f020863aebeb14786b98a2ec02e1" translate="yes" xml:space="preserve">
          <source>Advanced options:</source>
          <target state="translated">Opciones avanzadas:</target>
        </trans-unit>
        <trans-unit id="f1c748b61ceca05da788dea58f761592f09389bc" translate="yes" xml:space="preserve">
          <source>Advanced types</source>
          <target state="translated">Tipos avanzados</target>
        </trans-unit>
        <trans-unit id="4eaa54faaeebcdcf16ca6cecc39180523a7c29ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\0&lt;/code&gt; up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence &lt;code&gt;\0\x\07&lt;/code&gt; specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">Despu&amp;eacute;s de &lt;code&gt;\0&lt;/code&gt; se leen hasta dos d&amp;iacute;gitos octales m&amp;aacute;s. En ambos casos, si hay menos de dos d&amp;iacute;gitos, solo se utilizan los que est&amp;aacute;n presentes. As&amp;iacute;, la secuencia &lt;code&gt;\0\x\07&lt;/code&gt; especifica dos ceros binarios seguidos de un car&amp;aacute;cter BEL (valor de c&amp;oacute;digo 7). Aseg&amp;uacute;rese de proporcionar dos d&amp;iacute;gitos despu&amp;eacute;s del cero inicial si el car&amp;aacute;cter de patr&amp;oacute;n que sigue es en s&amp;iacute; mismo un d&amp;iacute;gito octal.</target>
        </trans-unit>
        <trans-unit id="c71390a639ed6627641b3cfd1f9a329a5cc9c625" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\x&lt;/code&gt;, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, or if there is no terminating &lt;code&gt;}&lt;/code&gt;, this form of escape is not recognized. Instead, the initial &lt;code&gt;\x&lt;/code&gt; will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.</source>
          <target state="translated">Despu&amp;eacute;s de &lt;code&gt;\x&lt;/code&gt; , se leen de cero a dos d&amp;iacute;gitos hexadecimales (las letras pueden estar en may&amp;uacute;sculas o min&amp;uacute;sculas). En el modo UTF-8, cualquier n&amp;uacute;mero de d&amp;iacute;gitos hexadecimales puede aparecer entre &lt;code&gt;\x{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; , pero el valor del c&amp;oacute;digo de car&amp;aacute;cter debe ser menor que 2 ** 31 (es decir, el valor hexadecimal m&amp;aacute;ximo es 7FFFFFFF). Si aparecen caracteres que no sean d&amp;iacute;gitos hexadecimales entre &lt;code&gt;\x{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; , o si no hay terminaci&amp;oacute;n &lt;code&gt;}&lt;/code&gt; , esta forma de escape no se reconoce. En cambio, la &lt;code&gt;\x&lt;/code&gt; inicial se interpretar&amp;aacute; como un escape hexadecimal b&amp;aacute;sico, sin d&amp;iacute;gitos siguientes, dando un car&amp;aacute;cter cuyo valor es cero.</target>
        </trans-unit>
        <trans-unit id="622cf30c89947b71767229b80f2f6c86dfa76768" translate="yes" xml:space="preserve">
          <source>After a connection is made you can use the &lt;code&gt;store&lt;/code&gt; procedure to upload a new file to the FTP server. Make sure to check you are in the correct working directory before you do so with the &lt;code&gt;pwd&lt;/code&gt; procedure, you can also instead specify an absolute path.</source>
          <target state="translated">Una vez realizada la conexi&amp;oacute;n, puede utilizar el procedimiento de &lt;code&gt;store&lt;/code&gt; para cargar un nuevo archivo en el servidor FTP. Aseg&amp;uacute;rese de verificar que est&amp;aacute; en el directorio de trabajo correcto antes de hacerlo con el procedimiento &lt;code&gt;pwd&lt;/code&gt; , tambi&amp;eacute;n puede especificar una ruta absoluta.</target>
        </trans-unit>
        <trans-unit id="f73d43ab167cd4ac21b418e91451904852662e79" translate="yes" xml:space="preserve">
          <source>After compilation is finished you will hopefully end up with the nim compiler in the &lt;code&gt;bin&lt;/code&gt; directory. You can add Nim's &lt;code&gt;bin&lt;/code&gt; directory to your &lt;code&gt;$PATH&lt;/code&gt; or use the &lt;a href=&quot;#install-command&quot;&gt;install command&lt;/a&gt; to place it where it will be found.</source>
          <target state="translated">Una vez finalizada la compilaci&amp;oacute;n, es de esperar que termine con el compilador nim en el directorio &lt;code&gt;bin&lt;/code&gt; . Puede agregar el directorio &lt;code&gt;bin&lt;/code&gt; de Nim a su &lt;code&gt;$PATH&lt;/code&gt; o usar el &lt;a href=&quot;#install-command&quot;&gt;comando de instalaci&amp;oacute;n&lt;/a&gt; para colocarlo donde se encontrar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="7e10a07a137ad912e35e4faef7ca70acb747eef5" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;from&lt;/code&gt; statement a module name follows followed by an &lt;code&gt;import&lt;/code&gt; to list the symbols one likes to use without explicit full qualification:</source>
          <target state="translated">Despu&amp;eacute;s de la instrucci&amp;oacute;n &lt;code&gt;from&lt;/code&gt; , sigue un nombre de m&amp;oacute;dulo seguido de una &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n para enumerar los s&amp;iacute;mbolos que a uno le gusta usar sin una calificaci&amp;oacute;n completa expl&amp;iacute;cita:</target>
        </trans-unit>
        <trans-unit id="4f797b80df1f8d64852f55b778851d191514b53d" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;import&lt;/code&gt; statement a list of module names can follow or a single module name followed by an &lt;code&gt;except&lt;/code&gt; list to prevent some symbols to be imported:</source>
          <target state="translated">Despu&amp;eacute;s de la declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n , puede seguir una lista de nombres de m&amp;oacute;dulo o un nombre de m&amp;oacute;dulo &amp;uacute;nico seguido de una lista de &lt;code&gt;except&lt;/code&gt; para evitar que se importen algunos s&amp;iacute;mbolos:</target>
        </trans-unit>
        <trans-unit id="ee8f6842719daac0ef2d06cdb2e7fa5bd3d11c84" translate="yes" xml:space="preserve">
          <source>After the execution of &lt;code&gt;handleRequest&lt;/code&gt; the client socket will be closed automatically unless it has already been closed.</source>
          <target state="translated">Despu&amp;eacute;s de la ejecuci&amp;oacute;n de &lt;code&gt;handleRequest&lt;/code&gt; , el socket del cliente se cerrar&amp;aacute; autom&amp;aacute;ticamente a menos que ya se haya cerrado.</target>
        </trans-unit>
        <trans-unit id="cf6dcadff9cc79e46d3555b76c916fb3ed022d34" translate="yes" xml:space="preserve">
          <source>After you add &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; for your custom type everything will work. Currently however &lt;code&gt;hash&lt;/code&gt; for objects is not defined, whereas &lt;code&gt;system.==&lt;/code&gt; for objects does exist and performs a &quot;deep&quot; comparison (every field is compared) which is usually what you want. So in the following example implementing only &lt;code&gt;hash&lt;/code&gt; suffices:</source>
          <target state="translated">Despu&amp;eacute;s de agregar &lt;code&gt;hash&lt;/code&gt; y &lt;code&gt;==&lt;/code&gt; para su tipo personalizado, todo funcionar&amp;aacute;. Sin embargo, actualmente el &lt;code&gt;hash&lt;/code&gt; para los objetos no est&amp;aacute; definido, mientras que &lt;code&gt;system.==&lt;/code&gt; para los objetos s&amp;iacute; existe y realiza una comparaci&amp;oacute;n &quot;profunda&quot; (se comparan todos los campos) que suele ser lo que usted desea. Entonces, en el siguiente ejemplo, la implementaci&amp;oacute;n solo de &lt;code&gt;hash&lt;/code&gt; es suficiente:</target>
        </trans-unit>
        <trans-unit id="c3ae9a42c0ef5d71d82ed6ff94ea44fa57d69eaa" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can create a TCP server by calling the &lt;code&gt;bindAddr&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; procedures.</source>
          <target state="translated">Despu&amp;eacute;s de crear un socket con el procedimiento &lt;code&gt;newSocket&lt;/code&gt; , puede crear un servidor TCP llamando a los procedimientos &lt;code&gt;bindAddr&lt;/code&gt; y &lt;code&gt;listen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f5c4359047c1c4029762b09cefac6ce55773f8" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can easily connect it to a server running at a known hostname (or IP address) and port. To do so over TCP, use the example below.</source>
          <target state="translated">Despu&amp;eacute;s de crear un socket con el procedimiento &lt;code&gt;newSocket&lt;/code&gt; , puede conectarlo f&amp;aacute;cilmente a un servidor que se ejecute en un nombre de host (o direcci&amp;oacute;n IP) y un puerto conocidos. Para hacerlo a trav&amp;eacute;s de TCP, use el siguiente ejemplo.</target>
        </trans-unit>
        <trans-unit id="5458c4cb0f05f3f6ed419b885d419d370bdf563e" translate="yes" xml:space="preserve">
          <source>Again, if you are wrapping a library which &lt;em&gt;mallocs&lt;/em&gt; and &lt;em&gt;frees&lt;/em&gt; data structures, you need to expose the appropriate &lt;em&gt;free&lt;/em&gt; function to Nim so you can clean it up. And of course, once cleaned you should avoid accessing it from Nim (or C for that matter). Typically C data structures have their own &lt;code&gt;malloc_structure&lt;/code&gt; and &lt;code&gt;free_structure&lt;/code&gt; specific functions, so wrapping these for the Nim side should be enough.</source>
          <target state="translated">Nuevamente, si est&amp;aacute; &lt;em&gt;encapsulando&lt;/em&gt; una biblioteca que &lt;em&gt;malloc&lt;/em&gt; y &lt;em&gt;libera&lt;/em&gt; estructuras de datos, necesita exponer la funci&amp;oacute;n &lt;em&gt;libre&lt;/em&gt; apropiada a Nim para que pueda limpiarla. Y, por supuesto, una vez limpio, debe evitar acceder a &amp;eacute;l desde Nim (o C para el caso). Normalmente, las estructuras de datos C tienen sus propias funciones espec&amp;iacute;ficas &lt;code&gt;malloc_structure&lt;/code&gt; y &lt;code&gt;free_structure&lt;/code&gt; , por lo que incluirlas en el lado de Nim deber&amp;iacute;a ser suficiente.</target>
        </trans-unit>
        <trans-unit id="2def8d1f86d78a731890a66e16deb2b5e1ea4254" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​para la &lt;a href=&quot;#difference&quot;&gt;diferencia (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a02e1746a71e7fb0864cabf7b39376b3a63a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#intersection&quot;&gt;intersecci&amp;oacute;n (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2391f38322eb20263936b3bfa8fc3471e6b69b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d86fe62b7538063ec7bfae9f6c08a83088df2cff" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41b739a23c6fc05ac36095d9dd959eb84d6a5a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​para &lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3db9334116c6d200d159599181aa97f7e9eee70" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#union&quot;&gt;uni&amp;oacute;n (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b5be6f17bdfd8cbcd14d0c4aa54788e9e3d34a0" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;none(T)&lt;/code&gt;.</source>
          <target state="translated">Alias ​​para &lt;code&gt;none(T)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="880b74f9b1a7d4cf4585f8c8f387bcb20192549a" translate="yes" xml:space="preserve">
          <source>Alias for for countSetBits (Hamming weight.)</source>
          <target state="translated">Alias para para countSetBits (Hamming weight.)</target>
        </trans-unit>
        <trans-unit id="2feaf49576ccc73f2b86d27faa6075fa943090f4" translate="yes" xml:space="preserve">
          <source>Aligns &lt;code&gt;s&lt;/code&gt; using &lt;code&gt;fill&lt;/code&gt; char. This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers.</source>
          <target state="translated">Alinea &lt;code&gt;s&lt;/code&gt; usando el car&amp;aacute;cter de &lt;code&gt;fill&lt;/code&gt; . Esto solo es de inter&amp;eacute;s si desea escribir un proceso de &lt;code&gt;format&lt;/code&gt; o personalizado que deba admitir los especificadores de formato est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="4a373b51ddb20415acc6f2cab49e7a886d4418f7" translate="yes" xml:space="preserve">
          <source>Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">Alinea una cadena &lt;em&gt;es&lt;/em&gt; con &lt;em&gt;el relleno&lt;/em&gt; , por lo que es de longitud &lt;em&gt;recuento&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="18f77fc6c5026c1d2d103f3b97daf7c1dbd054f5" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;db_*&lt;/code&gt; modules support the same form of parameter substitution. That is, using the &lt;code&gt;?&lt;/code&gt; (question mark) to signify the place where a value should be placed. For example:</source>
          <target state="translated">Todos los m&amp;oacute;dulos &lt;code&gt;db_*&lt;/code&gt; admiten la misma forma de sustituci&amp;oacute;n de par&amp;aacute;metros. Es decir, usando el &lt;code&gt;?&lt;/code&gt; (signo de interrogaci&amp;oacute;n) para indicar el lugar donde se debe colocar un valor. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9552063c6dac2a0b2b6f80dd47ebd5c82800945e" translate="yes" xml:space="preserve">
          <source>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform.</source>
          <target state="translated">Todos los archivos fuente de Nim están en la codificación UTF-8 (o su subconjunto ASCII).Otras codificaciones no son soportadas.Se puede utilizar cualquiera de las secuencias de terminación de línea de la plataforma estándar-la forma Unix que utiliza ASCII LF (salto de línea),la forma Windows que utiliza la secuencia ASCII CR LF (retorno seguido de salto de línea),o la antigua forma Macintosh que utiliza el carácter ASCII CR (retorno).Todas estas formas pueden ser utilizadas por igual,independientemente de la plataforma.</target>
        </trans-unit>
        <trans-unit id="2c0abd1c94e3986f0fc217d43c9ce2e325e352e8" translate="yes" xml:space="preserve">
          <source>All asynchronous functions returning a &lt;code&gt;Future&lt;/code&gt; will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.</source>
          <target state="translated">Todas las funciones asincr&amp;oacute;nicas que devuelven un &lt;code&gt;Future&lt;/code&gt; no se bloquear&amp;aacute;n. Sin embargo, no regresar&amp;aacute;n de inmediato. Una funci&amp;oacute;n asincr&amp;oacute;nica tendr&amp;aacute; un c&amp;oacute;digo que se ejecutar&amp;aacute; antes de que se realice una solicitud asincr&amp;oacute;nica, en la mayor&amp;iacute;a de los casos este c&amp;oacute;digo configura la solicitud.</target>
        </trans-unit>
        <trans-unit id="987c15958bc12d3f55c911e8dc5fec4777c6bc5e" translate="yes" xml:space="preserve">
          <source>All expressions have a type which is known at compile time. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</source>
          <target state="translated">Todas las expresiones tienen un tipo que se conoce en tiempo de compilación.Nim esta estaticamente tipificado.Uno puede declarar nuevos tipos,lo cual es en esencia definir un identificador que puede ser usado para denotar este tipo personalizado.</target>
        </trans-unit>
        <trans-unit id="f984cab28f61b914c2bd533b03fae6756c4294ad" translate="yes" xml:space="preserve">
          <source>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are &lt;em&gt;not&lt;/em&gt; available. The &lt;span id=&quot;system_1&quot;&gt;system&lt;/span&gt; module is automatically imported in every module.</source>
          <target state="translated">Todos los identificadores de un m&amp;oacute;dulo son v&amp;aacute;lidos desde el punto de declaraci&amp;oacute;n hasta el final del m&amp;oacute;dulo. Los identificadores de m&amp;oacute;dulos indirectamente dependientes &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n disponibles. El m&amp;oacute;dulo del &lt;span id=&quot;system_1&quot;&gt;sistema&lt;/span&gt; se importa autom&amp;aacute;ticamente en cada m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="cded9aa9ab6801c06f94e1f6e9e5425ed01952a5" translate="yes" xml:space="preserve">
          <source>All of the available idetools commands require you to specify a query location through the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--trackDirty&lt;/code&gt; switches. The general idetools invocations are:</source>
          <target state="translated">Todos los comandos de idetools disponibles requieren que especifique una ubicaci&amp;oacute;n de consulta a trav&amp;eacute;s de los interruptores &lt;code&gt;--track&lt;/code&gt; o &lt;code&gt;--trackDirty&lt;/code&gt; . Las invocaciones de idetools generales son:</target>
        </trans-unit>
        <trans-unit id="96cbbecb3e99c48c7b4fe7081d99be9e034325bf" translate="yes" xml:space="preserve">
          <source>All string literals are of the type &lt;code&gt;string&lt;/code&gt;. A string in Nim is very similar to a sequence of characters. However, strings in Nim are both zero-terminated and have a length field. One can retrieve the length with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero.</source>
          <target state="translated">Todos los literales de cadena son del tipo &lt;code&gt;string&lt;/code&gt; . Una cadena en Nim es muy similar a una secuencia de caracteres. Sin embargo, las cadenas en Nim terminan en cero y tienen un campo de longitud. Se puede recuperar la longitud con el procedimiento de &lt;code&gt;len&lt;/code&gt; incorporado ; la longitud nunca cuenta el cero final.</target>
        </trans-unit>
        <trans-unit id="c6b1a1f14d43339564b33e2a129f631ca1f3956e" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;tests/caas/*.txt&lt;/code&gt; files encode a session with the compiler:</source>
          <target state="translated">Todos los archivos &lt;code&gt;tests/caas/*.txt&lt;/code&gt; codifican una sesi&amp;oacute;n con el compilador:</target>
        </trans-unit>
        <trans-unit id="d7d265f3de6bf8deede109e19dc230beea86f266" translate="yes" xml:space="preserve">
          <source>All the characters that count as whitespace.</source>
          <target state="translated">Todos los personajes que cuentan como espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="0858ffb5249b4b454db4fc31e3311bb8f257c071" translate="yes" xml:space="preserve">
          <source>All the comparison operators can be used with enumeration types.</source>
          <target state="translated">Todos los operadores de comparación pueden utilizarse con los tipos de enumeración.</target>
        </trans-unit>
        <trans-unit id="6c891dcf4573456ce1e2da5262b50d0a08307027" translate="yes" xml:space="preserve">
          <source>All the operations have to perform efficiently. Because a Cellset can become huge a hash table alone is not suitable for this.</source>
          <target state="translated">Todas las operaciones deben realizarse de manera eficiente.Debido a que un Cellset puede llegar a ser enorme,una mesa de hachís por sí sola no es adecuada para esto.</target>
        </trans-unit>
        <trans-unit id="d7919c15f302a782639503db1ddcfd789a925698" translate="yes" xml:space="preserve">
          <source>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence &lt;code&gt;\b&lt;/code&gt; is interpreted as the backspace character (hex 08), and the sequence &lt;code&gt;\X&lt;/code&gt; is interpreted as the character &quot;X&quot;. Outside a character class, these sequences have different meanings (see below).</source>
          <target state="translated">Todas las secuencias que definen un valor de un solo byte o un solo car&amp;aacute;cter UTF-8 (en modo UTF-8) se pueden utilizar tanto dentro como fuera de las clases de caracteres. Adem&amp;aacute;s, dentro de una clase de car&amp;aacute;cter, la secuencia &lt;code&gt;\b&lt;/code&gt; se interpreta como el car&amp;aacute;cter de retroceso (hexadecimal 08) y la secuencia &lt;code&gt;\X&lt;/code&gt; se interpreta como el car&amp;aacute;cter &quot;X&quot;. Fuera de una clase de personaje, estas secuencias tienen diferentes significados (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="169951f4b6d1d7f1a4b31b9a082c85cf7bcb2136" translate="yes" xml:space="preserve">
          <source>All top level constants or types appearing within the concept body are accessible through the dot operator in procs where the concept was successfully matched to a concrete type:</source>
          <target state="translated">Todas las constantes o tipos de nivel superior que aparecen en el cuerpo del concepto son accesibles a través del operador de puntos en los procedimientos en los que el concepto se ha adaptado con éxito a un tipo concreto:</target>
        </trans-unit>
        <trans-unit id="3c975cb1e2ba6e75d38b206700dca326fdb354fc" translate="yes" xml:space="preserve">
          <source>All types for that &lt;code&gt;nil&lt;/code&gt; is a valid value can be annotated to exclude &lt;code&gt;nil&lt;/code&gt; as a valid value with the &lt;code&gt;not nil&lt;/code&gt; annotation:</source>
          <target state="translated">Todos los tipos para ese &lt;code&gt;nil&lt;/code&gt; es un valor v&amp;aacute;lido se pueden anotar para excluir &lt;code&gt;nil&lt;/code&gt; como un valor v&amp;aacute;lido con la anotaci&amp;oacute;n &lt;code&gt;not nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="029f6357cfa5fa54f588a79c60e26072ee6dc04a" translate="yes" xml:space="preserve">
          <source>Also, you won't find raw &lt;code&gt;\n&lt;/code&gt; characters breaking the one answer per line format. Instead you will need to parse sequences in the form &lt;code&gt;\xHH&lt;/code&gt;, where &lt;em&gt;HH&lt;/em&gt; is a hexadecimal value (e.g. newlines generate the sequence &lt;code&gt;\x0A&lt;/code&gt;).</source>
          <target state="translated">Adem&amp;aacute;s, no encontrar&amp;aacute; caracteres &lt;code&gt;\n&lt;/code&gt; sin procesar que rompan el formato de una respuesta por l&amp;iacute;nea. En su lugar, necesitar&amp;aacute; analizar secuencias en la forma &lt;code&gt;\xHH&lt;/code&gt; , donde &lt;em&gt;HH&lt;/em&gt; es un valor hexadecimal (por ejemplo, las nuevas l&amp;iacute;neas generan la secuencia &lt;code&gt;\x0A&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4521b364cb9ce19f839632eb99d99bb31f52f57b" translate="yes" xml:space="preserve">
          <source>Alternate version of the above.</source>
          <target state="translated">Versión alternativa de lo anterior.</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="24a6f9561b6fb31bcce22dd9eefb7cb23c8efb12" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;distinct&lt;/code&gt; type modifier can be applied to the type class to allow each param matching the type class to bind to a different type. Such type classes are called &lt;span id=&quot;bind-many_1&quot;&gt;bind many&lt;/span&gt; types.</source>
          <target state="translated">Alternativamente, el modificador de tipo &lt;code&gt;distinct&lt;/code&gt; se puede aplicar a la clase de tipo para permitir que cada par&amp;aacute;metro que coincida con la clase de tipo se vincule a un tipo diferente. Estas clases de tipos se denominan &lt;span id=&quot;bind-many_1&quot;&gt;unir muchos&lt;/span&gt; tipos.</target>
        </trans-unit>
        <trans-unit id="c5c9b8d75bae0a4e7883c1afe39fba029a2a402f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;em&gt;type&lt;/em&gt; operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</source>
          <target state="translated">Alternativamente, el operador de &lt;em&gt;tipo&lt;/em&gt; se puede usar sobre los par&amp;aacute;metros de proceso para un efecto similar cuando se usan clases de tipos an&amp;oacute;nimas o distintas.</target>
        </trans-unit>
        <trans-unit id="5b30b701e37924ad0c27b052555995c52f8814d1" translate="yes" xml:space="preserve">
          <source>Although Nim supports a variety of code and formatting styles, it is nevertheless beneficial that certain community efforts, such as the standard library, should follow a consistent set of style guidelines when suitable. This enhancement proposal aims to list a series of guidelines that the standard library should follow.</source>
          <target state="translated">Aunque Nim soporta una variedad de estilos de código y formato,es sin embargo beneficioso que ciertos esfuerzos de la comunidad,como la biblioteca estándar,sigan un conjunto consistente de pautas de estilo cuando sea apropiado.Esta propuesta de mejora tiene por objeto enumerar una serie de directrices que la biblioteca estándar debería seguir.</target>
        </trans-unit>
        <trans-unit id="e818f14ba9bbedb672b0a658dcc233bb37218e4d" translate="yes" xml:space="preserve">
          <source>Although the types use nanosecond time resolution, the underlying resolution used by &lt;code&gt;getTime()&lt;/code&gt; depends on the platform and backend (JS is limited to millisecond precision).</source>
          <target state="translated">Aunque los tipos utilizan una resoluci&amp;oacute;n de tiempo de nanosegundos, la resoluci&amp;oacute;n subyacente utilizada por &lt;code&gt;getTime()&lt;/code&gt; depende de la plataforma y el backend (JS est&amp;aacute; limitado a una precisi&amp;oacute;n de milisegundos).</target>
        </trans-unit>
        <trans-unit id="d3c0c9ff9b3e9a28a9649fc31261da1cd44edd57" translate="yes" xml:space="preserve">
          <source>Although use of whitespace for stylistic reasons other than the ones endorsed by this guide are allowed, careful thought should be put into such practices. Not all editors support automatic alignment of code sections, and re-aligning long sections of code by hand can quickly become tedious.</source>
          <target state="translated">Aunque se permite el uso de los espacios en blanco por razones estilísticas distintas de las aprobadas en esta guía,se debe pensar cuidadosamente en tales prácticas.No todos los editores apoyan la alineación automática de las secciones de código,y la realineación de largas secciones de código a mano puede resultar rápidamente tediosa.</target>
        </trans-unit>
        <trans-unit id="614ddcbf931903423c230b8f0212d11059c5ec82" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ValueError&lt;/code&gt; exception will be thrown if no exception exists in the specified Future.</source>
          <target state="translated">Se &lt;code&gt;ValueError&lt;/code&gt; excepci&amp;oacute;n ValueError si no existe ninguna excepci&amp;oacute;n en el futuro especificado.</target>
        </trans-unit>
        <trans-unit id="ef24e3c1b8f7b901d42c45e46f29ceddb0745dc1" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;export&lt;/code&gt; statement can be used for symbol forwarding so that client modules don't need to import a module's dependencies:</source>
          <target state="translated">Se puede utilizar una declaraci&amp;oacute;n de &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n para el reenv&amp;iacute;o de s&amp;iacute;mbolos, de modo que los m&amp;oacute;dulos de cliente no necesiten importar las dependencias de un m&amp;oacute;dulo:</target>
        </trans-unit>
        <trans-unit id="73a35d34d5220f34295669a5c8b933dc1ceedeca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;untyped&lt;/code&gt; parameter means that symbol lookups and type resolution is not performed before the expression is passed to the template. This means that for example &lt;em&gt;undeclared&lt;/em&gt; identifiers can be passed to the template:</source>
          <target state="translated">Un par&amp;aacute;metro sin &lt;code&gt;untyped&lt;/code&gt; significa que las b&amp;uacute;squedas de s&amp;iacute;mbolos y la resoluci&amp;oacute;n de tipos no se realizan antes de que la expresi&amp;oacute;n se pase a la plantilla. Esto significa que, por ejemplo, los identificadores &lt;em&gt;no declarados&lt;/em&gt; se pueden pasar a la plantilla:</target>
        </trans-unit>
        <trans-unit id="bae34c49da483225476ede34178ee0a4cd7dbb4e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;if expression&lt;/em&gt; is almost like an if statement, but it is an expression. Example:</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n if&lt;/em&gt; es casi como una declaraci&amp;oacute;n if, pero es una expresi&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="6913655373469dbc7b3bf423a90b3116ade5a64c" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;identifier_1&quot;&gt;identifier&lt;/span&gt; is a symbol declared as a name for a variable, type, procedure, etc. The region of the program over which a declaration applies is called the &lt;span id=&quot;scope_1&quot;&gt;scope&lt;/span&gt; of the declaration. Scopes can be nested. The meaning of an identifier is determined by the smallest enclosing scope in which the identifier is declared unless overloading resolution rules suggest otherwise.</source>
          <target state="translated">Un &lt;span id=&quot;identifier_1&quot;&gt;identificador&lt;/span&gt; es un s&amp;iacute;mbolo declarado como nombre de una variable, tipo, procedimiento, etc. La regi&amp;oacute;n del programa sobre la que se aplica una declaraci&amp;oacute;n se denomina &lt;span id=&quot;scope_1&quot;&gt;alcance&lt;/span&gt; de la declaraci&amp;oacute;n. Los &amp;aacute;mbitos se pueden anidar. El significado de un identificador est&amp;aacute; determinado por el &amp;aacute;mbito envolvente m&amp;aacute;s peque&amp;ntilde;o en el que se declara el identificador, a menos que las reglas de resoluci&amp;oacute;n de sobrecarga sugieran lo contrario.</target>
        </trans-unit>
        <trans-unit id="27d850be93dc755d2b65d8e923239958da9648c2" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;unchecked runtime error&lt;/span&gt; is an error that is not guaranteed to be detected, and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only &lt;span id=&quot;safe_1&quot;&gt;safe&lt;/span&gt; language features are used.</source>
          <target state="translated">Un &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;error de tiempo de ejecuci&amp;oacute;n no verificado&lt;/span&gt; es un error que no se garantiza que se detecte y puede causar que el comportamiento posterior del c&amp;aacute;lculo sea arbitrario. No se pueden producir errores de tiempo de ejecuci&amp;oacute;n sin comprobar si solo se utilizan funciones de lenguaje &lt;span id=&quot;safe_1&quot;&gt;seguro&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="d086f48ed32221353a34e9e09e19fc50d2b08517" translate="yes" xml:space="preserve">
          <source>An EOS (or ESSL if socket is an SSL socket) exception is raised if an error occurs.</source>
          <target state="translated">Una excepción EOS (o ESSL si el zócalo es un zócalo SSL)se plantea si se produce un error.</target>
        </trans-unit>
        <trans-unit id="fad595a4ff6c034a05915aa77a9cf525f3217cd5" translate="yes" xml:space="preserve">
          <source>An EOS exception will be raised in the case of a socket error.</source>
          <target state="translated">Una excepción de EOS se planteará en el caso de un error en el enchufe.</target>
        </trans-unit>
        <trans-unit id="3690729b1f993aa06abd14818e2a3ebd8ae6f4b1" translate="yes" xml:space="preserve">
          <source>An OS-dependent trailing slash is always present at the end of the returned string; &lt;em&gt;` on Windows and `/&lt;/em&gt; on all other OSs.</source>
          <target state="translated">Una barra diagonal dependiente del sistema operativo siempre est&amp;aacute; presente al final de la cadena devuelta; &lt;em&gt;`en Windows y` /&lt;/em&gt; en todos los dem&amp;aacute;s sistemas operativos.</target>
        </trans-unit>
        <trans-unit id="cb3c7dd4ccfc76b560ed8bea7cb91f6e590b5de7" translate="yes" xml:space="preserve">
          <source>An SQL statement that is passed from Nim to an SQL database might be modelled as a string. However, using string templates and filling in the values is vulnerable to the famous &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL injection attack&lt;/span&gt;:</source>
          <target state="translated">Una sentencia SQL que se pasa de Nim a una base de datos SQL puede modelarse como una cadena. Sin embargo, usar plantillas de cadenas y completar los valores es vulnerable al famoso &lt;span id=&quot;sql-injection-attack_1&quot;&gt;ataque de inyecci&amp;oacute;n SQL&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="d6b5b2a52bea6b4b6255ab33c977d4534669e142" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Un alias para &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="544692451d460228f4efd605a86e7c0dab8a35ee" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;countup(a, b, 1)&lt;/em&gt;.</source>
          <target state="translated">Un alias para &lt;em&gt;countup (a, b, 1)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="936583901537efa6474af706c7cbc7258cf9502a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">Un alias para el &lt;em&gt;nombre&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d96ad4829046669ed22f88ed72333f46e46f422a" translate="yes" xml:space="preserve">
          <source>An alias for copyNimTree().</source>
          <target state="translated">Un alias para copyNimTree().</target>
        </trans-unit>
        <trans-unit id="2bb4f7d6ba1dc1ca472b28bc42274504e162f7f7" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or the same as &lt;em&gt;DirSep&lt;/em&gt; if only one separator character exists. This is set to '/' on Windows systems where &lt;em&gt;DirSep&lt;/em&gt; is a backslash.</source>
          <target state="translated">Un car&amp;aacute;cter alternativo utilizado por el sistema operativo para separar los componentes del nombre de ruta, o el mismo que &lt;em&gt;DirSep&lt;/em&gt; si solo existe un car&amp;aacute;cter separador. Se establece en '/' en sistemas Windows donde &lt;em&gt;DirSep&lt;/em&gt; es una barra invertida.</target>
        </trans-unit>
        <trans-unit id="b10f9786df0315b28bef975ab41acecfb36800af" translate="yes" xml:space="preserve">
          <source>An apostrophe &lt;code&gt;'&lt;/code&gt; followed by an integer &lt;code&gt;i&lt;/code&gt; in the range 0..9 is replaced by the i'th parameter &lt;em&gt;type&lt;/em&gt;. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the &lt;code&gt;'&lt;/code&gt; and the digit an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; &lt;code&gt;T*&lt;/code&gt; becomes &lt;code&gt;T&lt;/code&gt;.) Two stars can be used to get to the element type of the element type etc.</source>
          <target state="translated">Un ap&amp;oacute;strofo &lt;code&gt;'&lt;/code&gt; seguido de un entero &lt;code&gt;i&lt;/code&gt; en el rango 0..9 se reemplaza por el &lt;em&gt;tipo de&lt;/em&gt; par&amp;aacute;metro i'th . La posici&amp;oacute;n 0 es el tipo de resultado. Esto se puede utilizar para pasar tipos a las plantillas de funciones de C ++. Entre el &lt;code&gt;'&lt;/code&gt; y el d&amp;iacute;gito se puede usar un asterisco para llegar al tipo base del tipo. (Por lo tanto, &quot;quita una estrella&quot; del tipo; &lt;code&gt;T*&lt;/code&gt; se convierte en &lt;code&gt;T&lt;/code&gt; . ) Se pueden usar dos estrellas para llegar al tipo de elemento del tipo de elemento, etc.</target>
        </trans-unit>
        <trans-unit id="dcf4f417901eafdc569fc787f5454f9027073421" translate="yes" xml:space="preserve">
          <source>An array is a simple fixed length container. Each element in an array has the same type. The array's index type can be any ordinal type.</source>
          <target state="translated">Un array es un simple contenedor de longitud fija.Cada elemento de una matriz tiene el mismo tipo.El tipo de índice de la matriz puede ser cualquier tipo ordinal.</target>
        </trans-unit>
        <trans-unit id="00d1d57ff3f35fb4d74599ef1b920f45e23521b6" translate="yes" xml:space="preserve">
          <source>An asynchronous procedure is marked using the &lt;code&gt;{.async.}&lt;/code&gt; pragma. When marking a procedure with the &lt;code&gt;{.async.}&lt;/code&gt; pragma it must have a &lt;code&gt;Future[T]&lt;/code&gt; return type or no return type at all. If you do not specify a return type then &lt;code&gt;Future[void]&lt;/code&gt; is assumed.</source>
          <target state="translated">Un procedimiento asincr&amp;oacute;nico se marca mediante el &lt;code&gt;{.async.}&lt;/code&gt; . Cuando se marca un procedimiento con el &lt;code&gt;{.async.}&lt;/code&gt; , Debe tener un tipo de retorno &lt;code&gt;Future[T]&lt;/code&gt; o ning&amp;uacute;n tipo de retorno. Si no especifica un tipo de retorno &lt;code&gt;Future[void]&lt;/code&gt; se asume Future [void] .</target>
        </trans-unit>
        <trans-unit id="00cfb3b823850859ac087c9650335459fba3693e" translate="yes" xml:space="preserve">
          <source>An at symbol &lt;code&gt;@&lt;/code&gt; is replaced by the remaining arguments, separated by commas.</source>
          <target state="translated">Un s&amp;iacute;mbolo &lt;code&gt;@&lt;/code&gt; se reemplaza por los argumentos restantes, separados por comas.</target>
        </trans-unit>
        <trans-unit id="e0a7ceb8146505e07f088182b71243011ca4cc3a" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;discard&lt;/code&gt; statement is often used as a null statement:</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;discard&lt;/code&gt; vac&amp;iacute;a se usa a menudo como una declaraci&amp;oacute;n nula:</target>
        </trans-unit>
        <trans-unit id="63b984f97355b1726a5cf0fa4b3612ccc2253bdc" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;raises&lt;/code&gt; list (&lt;code&gt;raises: []&lt;/code&gt;) means that no exception may be raised:</source>
          <target state="translated">Una lista de &lt;code&gt;raises&lt;/code&gt; vac&amp;iacute;a ( &lt;code&gt;raises: []&lt;/code&gt; ) significa que no se puede generar ninguna excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="03f5c98cab13364c0bdb7873271e1f3fbcb787f2" translate="yes" xml:space="preserve">
          <source>An empty subscript &lt;code&gt;[]&lt;/code&gt; notation can be used to derefer a reference, the &lt;code&gt;addr&lt;/code&gt; procedure returns the address of an item. An address is always an untraced reference. Thus the usage of &lt;code&gt;addr&lt;/code&gt; is an &lt;em&gt;unsafe&lt;/em&gt; feature.</source>
          <target state="translated">Se puede usar una notaci&amp;oacute;n de sub&amp;iacute;ndice &lt;code&gt;[]&lt;/code&gt; vac&amp;iacute;a para eliminar una referencia, el procedimiento &lt;code&gt;addr&lt;/code&gt; devuelve la direcci&amp;oacute;n de un elemento. Una direcci&amp;oacute;n es siempre una referencia sin rastrear. Por tanto, el uso de &lt;code&gt;addr&lt;/code&gt; es una caracter&amp;iacute;stica &lt;em&gt;peligrosa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fd0163ff197f89984c82c49af75d8bfe8b3b9a66" translate="yes" xml:space="preserve">
          <source>An enum can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that it's fields are added to a special module specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as &lt;code&gt;MyEnum.value&lt;/code&gt;:</source>
          <target state="translated">Una enumeraci&amp;oacute;n se puede marcar con el pragma &lt;code&gt;pure&lt;/code&gt; para que sus campos se agreguen a un &amp;aacute;mbito oculto espec&amp;iacute;fico del m&amp;oacute;dulo especial que solo se consulta como &amp;uacute;ltimo intento. Solo se agregan a este alcance s&amp;iacute;mbolos no ambiguos. Pero siempre se puede acceder a estos a trav&amp;eacute;s de la calificaci&amp;oacute;n de tipo escrita como &lt;code&gt;MyEnum.value&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="390d5ff2cbaae78dc0fa4290b4e9610666cc8fdf" translate="yes" xml:space="preserve">
          <source>An enum type can be marked as &lt;code&gt;pure&lt;/code&gt;. Then access of its fields always requires full qualification.</source>
          <target state="translated">Un tipo de enumeraci&amp;oacute;n se puede marcar como &lt;code&gt;pure&lt;/code&gt; . Entonces, el acceso a sus campos siempre requiere una calificaci&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="367c78270c2f231073a0357927182872afdf0f63" translate="yes" xml:space="preserve">
          <source>An enum which hold event types</source>
          <target state="translated">Una lista que contiene los tipos de eventos</target>
        </trans-unit>
        <trans-unit id="4dcfd8f767ff68c968ba90d84fa6dca78b2ac575" translate="yes" xml:space="preserve">
          <source>An enumeration's symbol can be qualified to avoid ambiguities: &lt;code&gt;Direction.south&lt;/code&gt;.</source>
          <target state="translated">El s&amp;iacute;mbolo de una enumeraci&amp;oacute;n se puede calificar para evitar ambig&amp;uuml;edades: &lt;code&gt;Direction.south&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83a58494419b1a3e524ebfb95e03913553034371" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;handleAccept&lt;/code&gt; follows:</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo de &lt;code&gt;handleAccept&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="993744896fbb24a8143d61db93a5b797f2af5f88" translate="yes" xml:space="preserve">
          <source>An explicit ordered enum can have &lt;em&gt;holes&lt;/em&gt;:</source>
          <target state="translated">Una enumeraci&amp;oacute;n ordenada expl&amp;iacute;cita puede tener &lt;em&gt;agujeros&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a5f3c80df868038bd59209ddaecef0136b0eb492" translate="yes" xml:space="preserve">
          <source>An exported helper proc that parses the &quot;standard format specifiers&quot;, as specified by the grammar:</source>
          <target state="translated">Un procedimiento de ayuda exportado que analiza los &quot;especificadores de formato estándar&quot;,según lo especificado por la gramática:</target>
        </trans-unit>
        <trans-unit id="129cc9980afbc0b6d02dd90e59a7e2eac8eb8d2f" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;b&lt;/code&gt; can be assigned to an expression &lt;code&gt;a&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is an &lt;em&gt;l-value&lt;/em&gt; and &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; holds.</source>
          <target state="translated">Se puede asignar una expresi&amp;oacute;n &lt;code&gt;b&lt;/code&gt; a una expresi&amp;oacute;n &lt;code&gt;a&lt;/code&gt; si &lt;code&gt;a&lt;/code&gt; es un &lt;em&gt;valor l&lt;/em&gt; y se &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d2a0ca1f92482471cb1498e046b1a61df5075bd" translate="yes" xml:space="preserve">
          <source>An expression like &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; is transformed into:</source>
          <target state="translated">Una expresi&amp;oacute;n como &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; se transforma en:</target>
        </trans-unit>
        <trans-unit id="5cf1e65690ce8b0321d174674e5faf95e0f45bd9" translate="yes" xml:space="preserve">
          <source>An expression specifies a computation that produces a value or location. Expressions that produce locations are called &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt;. An l-value can denote either a location or the value the location contains, depending on the context. Expressions whose values can be determined statically are called &lt;span id=&quot;constant-expressions_1&quot;&gt;constant expressions&lt;/span&gt;; they are never l-values.</source>
          <target state="translated">Una expresi&amp;oacute;n especifica un c&amp;aacute;lculo que produce un valor o una ubicaci&amp;oacute;n. Las expresiones que producen ubicaciones se denominan &lt;span id=&quot;lminusvalues_1&quot;&gt;valores l&lt;/span&gt; . Un valor l puede denotar una ubicaci&amp;oacute;n o el valor que contiene la ubicaci&amp;oacute;n, seg&amp;uacute;n el contexto. Las expresiones cuyos valores pueden determinarse est&amp;aacute;ticamente se denominan &lt;span id=&quot;constant-expressions_1&quot;&gt;expresiones constantes&lt;/span&gt; ; nunca son valores l.</target>
        </trans-unit>
        <trans-unit id="1e306939f1b61ed5f05365a4a82b6e0e9f803e5d" translate="yes" xml:space="preserve">
          <source>An if expression always results in a value, so the &lt;code&gt;else&lt;/code&gt; part is required. &lt;code&gt;Elif&lt;/code&gt; parts are also allowed.</source>
          <target state="translated">Una expresi&amp;oacute;n if siempre da como resultado un valor, por lo &lt;code&gt;else&lt;/code&gt; se requiere la parte else . Tambi&amp;eacute;n se permiten piezas &lt;code&gt;Elif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55f00c59e69693d5b27bf05aeea67c1b5656b713" translate="yes" xml:space="preserve">
          <source>An implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; are true.</source>
          <target state="translated">Una implementaci&amp;oacute;n siempre debe usar la m&amp;aacute;xima precisi&amp;oacute;n disponible para evaluar los valores de puntero flotante en tiempo de compilaci&amp;oacute;n; esto significa que expresiones como &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; son verdaderas.</target>
        </trans-unit>
        <trans-unit id="4faf8ef86d99d8f87188a85418d2cafbed7c672a" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at &lt;strong&gt;0&lt;/strong&gt;.</source>
          <target state="translated">Un n&amp;uacute;mero entero con la columna que vas a consultar. Para el compilador, las columnas comienzan en &lt;strong&gt;0&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7140df7bbe5e3e07dff6576529cef23b438e6cf3" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at zero, so the first column will be &lt;strong&gt;0&lt;/strong&gt; and the last in an 80 column terminal will be &lt;strong&gt;79&lt;/strong&gt;.</source>
          <target state="translated">Un n&amp;uacute;mero entero con la columna que vas a consultar. Para las columnas del compilador comienzan en cero, por lo que la primera columna ser&amp;aacute; &lt;strong&gt;0&lt;/strong&gt; y la &amp;uacute;ltima en una terminal de 80 columnas ser&amp;aacute; &lt;strong&gt;79&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="58c18cab7c4720f0e3aa95f69ca0b844006c41f0" translate="yes" xml:space="preserve">
          <source>An integer with the line you are going to query. For the compiler lines start at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">Un n&amp;uacute;mero entero con la l&amp;iacute;nea que vas a consultar. Para las l&amp;iacute;neas del compilador, comience en &lt;strong&gt;1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fd63b4dca2c3b56a63f528ea8506804126dab43c" translate="yes" xml:space="preserve">
          <source>An iterator is similar to a procedure, except that it can be called in the context of a &lt;code&gt;for&lt;/code&gt; loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a &lt;code&gt;for&lt;/code&gt; loop plays the &lt;code&gt;yield&lt;/code&gt; statement in the called iterator. Whenever a &lt;code&gt;yield&lt;/code&gt; statement is reached the data is bound to the &lt;code&gt;for&lt;/code&gt; loop variables and control continues in the body of the &lt;code&gt;for&lt;/code&gt; loop. The iterator's local variables and execution state are automatically saved between calls. Example:</source>
          <target state="translated">Un iterador es similar a un procedimiento, excepto que se puede llamar en el contexto de un bucle &lt;code&gt;for&lt;/code&gt; . Los iteradores proporcionan una forma de especificar la iteraci&amp;oacute;n sobre un tipo abstracto. Un papel clave en la ejecuci&amp;oacute;n de un bucle &lt;code&gt;for&lt;/code&gt; es la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; en el iterador llamado. Siempre que se alcanza una declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; , los datos est&amp;aacute;n vinculados a las variables del ciclo &lt;code&gt;for&lt;/code&gt; y el control contin&amp;uacute;a en el cuerpo del ciclo &lt;code&gt;for&lt;/code&gt; . Las variables locales del iterador y el estado de ejecuci&amp;oacute;n se guardan autom&amp;aacute;ticamente entre llamadas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="1f5ff3abd757e3cba00a39f18b56b5fb6446a8c0" translate="yes" xml:space="preserve">
          <source>An object type can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</source>
          <target state="translated">Un tipo de objeto se puede marcar con el pragma &lt;code&gt;pure&lt;/code&gt; modo que se omita su campo de tipo que se utiliza para la identificaci&amp;oacute;n del tipo en tiempo de ejecuci&amp;oacute;n. Esto sol&amp;iacute;a ser necesario para la compatibilidad binaria con otros lenguajes compilados.</target>
        </trans-unit>
        <trans-unit id="2e8278ca51d6d95aa64a5e6c057a546e2ca28c42" translate="yes" xml:space="preserve">
          <source>An object which holds descriptors to be checked for read/write status</source>
          <target state="translated">Un objeto que contiene descriptores que deben ser comprobados para el estado de lectura/escritura</target>
        </trans-unit>
        <trans-unit id="3274465cde86ef19fbd6e85a8dde25fac63bf653" translate="yes" xml:space="preserve">
          <source>An object which holds result for descriptor</source>
          <target state="translated">Un objeto que contiene el resultado para el descriptor</target>
        </trans-unit>
        <trans-unit id="e62ca354a533c308819dea987dbbf454b1323735" translate="yes" xml:space="preserve">
          <source>An object which holds user defined event</source>
          <target state="translated">Un objeto que contiene un evento definido por el usuario</target>
        </trans-unit>
        <trans-unit id="004526c446f1ac6d78516b74ee9cfa40b5941993" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if reading from the</source>
          <target state="translated">Se puede especificar un tiempo de espera opcional en milisegundos,si la lectura del</target>
        </trans-unit>
        <trans-unit id="be0cf6034a987ab54cdc28a91621a1407148ad61" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</source>
          <target state="translated">Se puede especificar un tiempo de espera opcional en milisegundos,si el salto de los bytes toma más tiempo que el especificado se elevará una excepción de ETimeout.</target>
        </trans-unit>
        <trans-unit id="1436ea667171f8c043927d94a1771aba02c31130" translate="yes" xml:space="preserve">
          <source>An optional type that stores its value and state separately in a boolean.</source>
          <target state="translated">Un tipo opcional que almacena su valor y estado por separado en un booleano.</target>
        </trans-unit>
        <trans-unit id="1492892ce7573ee3544c47d10217feac9a1ffe27" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the end of the input. No character is consumed. Same as &lt;code&gt;!.&lt;/code&gt;.</source>
          <target state="translated">Anchor: coincide con el final de la entrada. No se consume ning&amp;uacute;n personaje. Igual que &lt;code&gt;!.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28501d5ba1b7346ee45610593888631bf0f75364" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the start of the input. No character is consumed.</source>
          <target state="translated">Ancla:Coincide al principio de la entrada.No se consume ningún personaje.</target>
        </trans-unit>
        <trans-unit id="d5b80e8f8af7973d49e632e415ee520559b6880c" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;main&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;foo/x&lt;/code&gt; is imported. If &lt;code&gt;other&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt; then both &lt;code&gt;$lib/x.nim&lt;/code&gt; and &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; match and so the compiler should reject it. Currently however this check is not implemented and instead the first matching file is used.</source>
          <target state="translated">Y las &lt;code&gt;main&lt;/code&gt; importaciones &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;foo/x&lt;/code&gt; se importan. Si &lt;code&gt;other&lt;/code&gt; importaciones &lt;code&gt;x&lt;/code&gt; , tanto &lt;code&gt;$lib/x.nim&lt;/code&gt; como &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; coinciden, por lo que el compilador deber&amp;iacute;a rechazarlo. Sin embargo, actualmente esta verificaci&amp;oacute;n no est&amp;aacute; implementada y en su lugar se usa el primer archivo coincidente.</target>
        </trans-unit>
        <trans-unit id="242f34bf16bfc5e83d5742e55f63b87c019f679a" translate="yes" xml:space="preserve">
          <source>And copy the executable somewhere in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">Y copie el ejecutable en alg&amp;uacute;n lugar de su &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83dda4bc1c55dc87decca365a7ad42665d8106b1" translate="yes" xml:space="preserve">
          <source>And for a debug version compatible with GDB:</source>
          <target state="translated">Y para una versión de depuración compatible con GDB:</target>
        </trans-unit>
        <trans-unit id="4e8296500ed287ca2f86dd1c2fab187b68fe5d29" translate="yes" xml:space="preserve">
          <source>And predicate: Indicate success if expression &lt;em&gt;E&lt;/em&gt; matches the text ahead; otherwise indicate failure. Do not consume any text.</source>
          <target state="translated">Y predicado: indica el &amp;eacute;xito si la expresi&amp;oacute;n &lt;em&gt;E&lt;/em&gt; coincide con el texto anterior; de lo contrario, indique falla. No consumas ning&amp;uacute;n texto.</target>
        </trans-unit>
        <trans-unit id="dd21179e471067255e31c8a35037ea42bc51b5d1" translate="yes" xml:space="preserve">
          <source>And the following code:</source>
          <target state="translated">Y el siguiente código:</target>
        </trans-unit>
        <trans-unit id="529975d2ca1b9c8b1f9dc8715723302d776e3685" translate="yes" xml:space="preserve">
          <source>Annotating procs with raised exceptions</source>
          <target state="translated">Anotando los procedimientos con excepciones planteadas</target>
        </trans-unit>
        <trans-unit id="1372df72c3414caae306a6854fbd73da2739c232" translate="yes" xml:space="preserve">
          <source>Anonymous Procs</source>
          <target state="translated">Protestas anónimas...</target>
        </trans-unit>
        <trans-unit id="fc69ddcac99b9b9a8d29c74edd5dd97109c0f888" translate="yes" xml:space="preserve">
          <source>Another common example is this:</source>
          <target state="translated">Otro ejemplo común es este:</target>
        </trans-unit>
        <trans-unit id="46de23dafaa5135d298c4e6932bfd58f0a55fcd3" translate="yes" xml:space="preserve">
          <source>Another way is to make Nim invoke a cross compiler toolchain:</source>
          <target state="translated">Otra forma es hacer que Nim invoque una cadena de herramientas de compilación cruzada:</target>
        </trans-unit>
        <trans-unit id="220b3fd15cb7730c1f91330b6bd071c4acf9137b" translate="yes" xml:space="preserve">
          <source>Another way to branch is provided by the case statement. A case statement is a multi-branch:</source>
          <target state="translated">Otra forma de ramificación es la declaración del caso.La declaración de un caso es una rama múltiple:</target>
        </trans-unit>
        <trans-unit id="b109a7f72d501d6581c64b2e20010ee624b143d1" translate="yes" xml:space="preserve">
          <source>Another way to do the same without &lt;code&gt;when&lt;/code&gt; is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the &lt;em&gt;value&lt;/em&gt; to.</source>
          <target state="translated">Otra forma de hacer lo mismo sin &lt;code&gt;when&lt;/code&gt; es dejar la tarea de elegir el c&amp;oacute;digo apropiado a un proceso secundario al que sobrecargas para cada tipo de campo y le pasas el &lt;em&gt;valor&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cdcc64fe4174864c656f8d5ecbd49e1c1178af4e" translate="yes" xml:space="preserve">
          <source>Another way to look at the method call syntax is that it provides the missing postfix notation.</source>
          <target state="translated">Otra forma de ver el método llamado sintaxis es que proporciona la notación postfija que falta.</target>
        </trans-unit>
        <trans-unit id="a741689c8b0db1dc353a46642a34688e7e01c9fe" translate="yes" xml:space="preserve">
          <source>Any Unicode character: If there is an UTF-8 character ahead, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Cualquier personaje de Unicode:Si hay un personaje UTF-8 adelante,consumirlo e indicar el éxito.De lo contrario,indica fracaso.</target>
        </trans-unit>
        <trans-unit id="5778ef8422665afffa8cd59a1ebfe6af7a70d367" translate="yes" xml:space="preserve">
          <source>Any character: If there is a character ahead, consume it and indicate success. Otherwise (that is, at the end of input) indicate failure.</source>
          <target state="translated">Cualquier personaje:Si hay un personaje por delante,consumirlo e indicar el éxito.De lo contrario (es decir,al final de la entrada)indica fracaso.</target>
        </trans-unit>
        <trans-unit id="7358bbc6ca3777f85150f64affeb40b274702a17" translate="yes" xml:space="preserve">
          <source>Any comments which are preceded by a double-hash (##), are interpreted as documentation. Comments are parsed as RST (see &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;reference&lt;/a&gt;), providing Nim module authors the ability to easily generate richly formatted documentation with only their well-documented code.</source>
          <target state="translated">Cualquier comentario que est&amp;eacute; precedido por un doble hash (##), se interpretar&amp;aacute; como documentaci&amp;oacute;n. Los comentarios se analizan como RST (consulte la &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;referencia&lt;/a&gt; ), lo que brinda a los autores de m&amp;oacute;dulos de Nim la capacidad de generar f&amp;aacute;cilmente documentaci&amp;oacute;n con un gran formato con solo su c&amp;oacute;digo bien documentado.</target>
        </trans-unit>
        <trans-unit id="91e820fd709a7f87728034af624c9132692282ae" translate="yes" xml:space="preserve">
          <source>Any operator can be called like an ordinary proc with the '&lt;em&gt;opr&lt;/em&gt;' notation. (Thus an operator can have more than two parameters):</source>
          <target state="translated">Cualquier operador puede llamarse como un proceso ordinario con la notaci&amp;oacute;n ' &lt;em&gt;opr&lt;/em&gt; '. (Por lo tanto, un operador puede tener m&amp;aacute;s de dos par&amp;aacute;metros):</target>
        </trans-unit>
        <trans-unit id="28a8d44708b00ee5f8ab5f8950f4590e672372e9" translate="yes" xml:space="preserve">
          <source>Any previously stored value will be overwritten.</source>
          <target state="translated">Cualquier valor almacenado previamente será sobrescrito.</target>
        </trans-unit>
        <trans-unit id="85cdc7b1f239ca6691d5ad4bd7ee32149be2368a" translate="yes" xml:space="preserve">
          <source>Any statements following the &lt;code&gt;defer&lt;/code&gt; in the current block will be considered to be in an implicit try block:</source>
          <target state="translated">Cualquier declaraci&amp;oacute;n que siga al &lt;code&gt;defer&lt;/code&gt; en el bloque actual se considerar&amp;aacute; en un bloque try impl&amp;iacute;cito:</target>
        </trans-unit>
        <trans-unit id="f6cede9c40103cfeb38206a514d0e207b6286657" translate="yes" xml:space="preserve">
          <source>Any user defined destructors</source>
          <target state="translated">Cualquier destructor definido por el usuario</target>
        </trans-unit>
        <trans-unit id="474bae604f6e9971bd49456c68cefe4610021141" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;spawn&lt;/code&gt; and &lt;code&gt;parallel&lt;/code&gt; Nim also provides all the common low level concurrency mechanisms like locks, atomic intrinsics or condition variables.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;code&gt;spawn&lt;/code&gt; y &lt;code&gt;parallel&lt;/code&gt; Nim tambi&amp;eacute;n proporciona todos los mecanismos comunes de concurrencia de bajo nivel como bloqueos, intr&amp;iacute;nsecos at&amp;oacute;micos o variables de condici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="562f1ef0862bc54a9d91c121544eee328c801e91" translate="yes" xml:space="preserve">
          <source>Apart from a few built-in keyword operators such as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, operators always consist of these characters: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</source>
          <target state="translated">Aparte de unos cuantos incorporado operadores de palabras clave tales como &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , los operadores siempre constan de los siguientes caracteres: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfe80b93d1b3cc277c929cdfd0838f7556135094" translate="yes" xml:space="preserve">
          <source>Apart from built-in operations like array indexing, memory allocation, etc. the &lt;code&gt;raise&lt;/code&gt; statement is the only way to raise an exception.</source>
          <target state="translated">Aparte de las operaciones integradas como indexaci&amp;oacute;n de matrices, asignaci&amp;oacute;n de memoria, etc., la declaraci&amp;oacute;n de &lt;code&gt;raise&lt;/code&gt; es la &amp;uacute;nica forma de generar una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7dc1626458ca624671bbd7eb79e937465433fdf8" translate="yes" xml:space="preserve">
          <source>Apart from strings you can also encode lists of integers or characters:</source>
          <target state="translated">Además de las cadenas,también puedes codificar listas de enteros o caracteres:</target>
        </trans-unit>
        <trans-unit id="aafd7f63cf0cf31a35bff642569ecbe5c87f627c" translate="yes" xml:space="preserve">
          <source>Apart from the minimal syntactic sugar the language core does not need to know about tables.</source>
          <target state="translated">Aparte del mínimo azúcar sintáctico,el núcleo del lenguaje no necesita saber sobre tablas.</target>
        </trans-unit>
        <trans-unit id="86d0496a927c4a27939c0fe3200738c8416afc23" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;x&lt;/em&gt; to string &lt;em&gt;s&lt;/em&gt; in place, applying quoting and escaping if &lt;em&gt;x&lt;/em&gt; is a string or char. See &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; for the escaping scheme. When &lt;em&gt;x&lt;/em&gt; is a string, characters in the range &lt;code&gt;{\128..\255}&lt;/code&gt; are never escaped so that multibyte UTF-8 characters are untouched (note that this behavior is different from &lt;code&gt;addEscapedChar&lt;/code&gt;).</source>
          <target state="translated">Agrega &lt;em&gt;x&lt;/em&gt; a la cadena &lt;em&gt;s&lt;/em&gt; en su lugar, aplicando comillas y escapando si &lt;em&gt;x&lt;/em&gt; es una cadena o un car&amp;aacute;cter. Consulte &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; para conocer el esquema de escape. Cuando &lt;em&gt;x&lt;/em&gt; es una cadena, los caracteres en el rango &lt;code&gt;{\128..\255}&lt;/code&gt; nunca se escapan, por lo que los caracteres UTF-8 multibyte no se modifican (tenga en cuenta que este comportamiento es diferente de &lt;code&gt;addEscapedChar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="646ba0c86d2da62ac809b41c7876c8d4d437f4fd" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt; in place</source>
          <target state="translated">Anexa &lt;em&gt;y&lt;/em&gt; a &lt;em&gt;x&lt;/em&gt; en lugar</target>
        </trans-unit>
        <trans-unit id="621c0cff6d7cb368d8e84f223d0bb258c1851898" translate="yes" xml:space="preserve">
          <source>Appends element y to the end of the sequence. Requires copying of the sequence</source>
          <target state="translated">Añade el elemento y al final de la secuencia.Requiere la copia de la secuencia</target>
        </trans-unit>
        <trans-unit id="4b93e2750d5e019c95354307daa55b9ae9ae1eb1" translate="yes" xml:space="preserve">
          <source>Appends url to url.</source>
          <target state="translated">Añade url a url.</target>
        </trans-unit>
        <trans-unit id="8b39b7cf4b0a60e8defe6d54cb8868dcdb0f1e4b" translate="yes" xml:space="preserve">
          <source>Applies &lt;em&gt;op&lt;/em&gt; to every item in &lt;em&gt;s&lt;/em&gt; modifying it directly.</source>
          <target state="translated">Se aplica &lt;em&gt;op&lt;/em&gt; a cada elemento de &lt;em&gt;s&lt;/em&gt; modific&amp;aacute;ndolo directamente.</target>
        </trans-unit>
        <trans-unit id="47c68a697222d8231db69fecdc76aa3f8118fca0" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option</source>
          <target state="translated">Aplica una llamada de retorno al valor en esta opción</target>
        </trans-unit>
        <trans-unit id="1f6c6510cdda5cd1b191679d2ebcc3574091831b" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned</source>
          <target state="translated">Aplica una llamada al valor de esta opción y devuelve una opción que contiene el nuevo valor.Si esta opción es Ninguna,se devolverá Ninguna</target>
        </trans-unit>
        <trans-unit id="4405334856a221170be55f8b9f5688d6a0be9c57" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned. Similar to &lt;code&gt;map&lt;/code&gt;, with the difference that the callback returns an Option, not a raw value. This allows multiple procs with a signature of &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (including A = B) to be chained together.</source>
          <target state="translated">Aplica una devoluci&amp;oacute;n de llamada al valor de esta opci&amp;oacute;n y devuelve una opci&amp;oacute;n que contiene el nuevo valor. Si esta opci&amp;oacute;n es Ninguno, se devolver&amp;aacute; Ninguno. Similar al &lt;code&gt;map&lt;/code&gt; a , con la diferencia de que la devoluci&amp;oacute;n de llamada devuelve una opci&amp;oacute;n, no un valor sin procesar. Esto permite que m&amp;uacute;ltiples procesos con una firma de &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (incluyendo A = B) sean encadenados.</target>
        </trans-unit>
        <trans-unit id="465dd40623dd93f42a5f03dcd0c6972a66643b81" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option. If the callback returns &lt;em&gt;true&lt;/em&gt;, the option is returned as a Some. If it returns false, it is returned as a None.</source>
          <target state="translated">Aplica una devoluci&amp;oacute;n de llamada al valor de esta opci&amp;oacute;n. Si la devoluci&amp;oacute;n de llamada devuelve &lt;em&gt;verdadero&lt;/em&gt; , la opci&amp;oacute;n se devuelve como Some. Si devuelve falso, se devuelve como Ninguno.</target>
        </trans-unit>
        <trans-unit id="31b8834506fb3b7c5be5a3ce85e8e0c3db7c0b3f" translate="yes" xml:space="preserve">
          <source>Arguments are delimited by white space, which is either a space or a tab.</source>
          <target state="translated">Los argumentos están delimitados por un espacio en blanco,que es un espacio o una pestaña.</target>
        </trans-unit>
        <trans-unit id="401bb179f3db6b973c284e019e2540619d382218" translate="yes" xml:space="preserve">
          <source>Arguments that are passed to a &lt;code&gt;varargs&lt;/code&gt; parameter are wrapped in an array constructor expression. This is why &lt;code&gt;debug&lt;/code&gt; iterates over all of &lt;code&gt;n&lt;/code&gt;'s children.</source>
          <target state="translated">Los argumentos que se pasan a un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; se envuelven en una expresi&amp;oacute;n de constructor de matriz. Esta es la raz&amp;oacute;n por la que la &lt;code&gt;debug&lt;/code&gt; itera sobre todos los hijos de &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="52bae2349fbad4ef35978d796cfe4b7d32461d9e" translate="yes" xml:space="preserve">
          <source>Array access operator &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">Operador de acceso a la matriz &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="935c34e59be520dab8667587be24775c6b59c8e5" translate="yes" xml:space="preserve">
          <source>Array and sequence types</source>
          <target state="translated">Tipos de arreglos y secuencias</target>
        </trans-unit>
        <trans-unit id="b66b4ebd826229d404911b2c9ca9b59007c74879" translate="yes" xml:space="preserve">
          <source>Array with no bounds checking</source>
          <target state="translated">La matriz sin límites de control...</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7c78840740ada4caee391a3c7d72b96b3524a2c8" translate="yes" xml:space="preserve">
          <source>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length which is specified at compile time (except for open arrays). They can be indexed by any ordinal type. A parameter &lt;code&gt;A&lt;/code&gt; may be an &lt;em&gt;open array&lt;/em&gt;, in which case it is indexed by integers from 0 to &lt;code&gt;len(A)-1&lt;/code&gt;. An array expression may be constructed by the array constructor &lt;code&gt;[]&lt;/code&gt;. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertable to this type.</source>
          <target state="translated">Las matrices son un tipo homog&amp;eacute;neo, lo que significa que cada elemento de la matriz tiene el mismo tipo. Las matrices siempre tienen una longitud fija que se especifica en tiempo de compilaci&amp;oacute;n (excepto para matrices abiertas). Se pueden indexar por cualquier tipo ordinal. Un par&amp;aacute;metro &lt;code&gt;A&lt;/code&gt; puede ser una &lt;em&gt;matriz abierta&lt;/em&gt; , en cuyo caso est&amp;aacute; indexado por n&amp;uacute;meros enteros de 0 a &lt;code&gt;len(A)-1&lt;/code&gt; . Una expresi&amp;oacute;n de matriz puede ser construida por el constructor de matriz &lt;code&gt;[]&lt;/code&gt; . El tipo de elemento de esta expresi&amp;oacute;n de matriz se infiere del tipo del primer elemento. Todos los dem&amp;aacute;s elementos deben ser convertibles impl&amp;iacute;citamente a este tipo.</target>
        </trans-unit>
        <trans-unit id="07316b5238311cac8e4fe1961ee02c15801cb68e" translate="yes" xml:space="preserve">
          <source>Arrays are always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--boundChecks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">Las matrices siempre se comprueban por l&amp;iacute;mites (en tiempo de compilaci&amp;oacute;n o en tiempo de ejecuci&amp;oacute;n). Estas comprobaciones pueden desactivarse mediante pragmas o invocando el compilador con el &lt;code&gt;--boundChecks:off&lt;/code&gt; l&amp;iacute;nea de comando --boundChecks: off .</target>
        </trans-unit>
        <trans-unit id="5f5ec03ff46845d078f8cf64b1238f79972295a5" translate="yes" xml:space="preserve">
          <source>Arrays are value types, like any other Nim type. The assignment operator copies the whole array contents.</source>
          <target state="translated">Los arreglos son tipos de valores,como cualquier otro tipo de Nim.El operador de asignación copia todo el contenido del arreglo.</target>
        </trans-unit>
        <trans-unit id="025a9e98dcb0da2dd59c51da809f12fce4980b2a" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed using &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">Las matrices se pueden construir usando &lt;code&gt;[]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c735544485e105956e388f5a452d2502051ca6e1" translate="yes" xml:space="preserve">
          <source>Artifact being compiled.</source>
          <target state="translated">El artefacto está siendo compilado.</target>
        </trans-unit>
        <trans-unit id="2681d14f693853cb31e8a490d26bf55ce9311d0e" translate="yes" xml:space="preserve">
          <source>As a regular expression &lt;code&gt;\[.*\]&lt;/code&gt; matches the longest possible text between &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;. As a PEG it never matches anything, because a PEG is deterministic: &lt;code&gt;.*&lt;/code&gt; consumes the rest of the input, so &lt;code&gt;\]&lt;/code&gt; never matches. As a PEG this needs to be written as: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (or &lt;code&gt;\[ @ \]&lt;/code&gt;).</source>
          <target state="translated">Como expresi&amp;oacute;n regular &lt;code&gt;\[.*\]&lt;/code&gt; Coincide con el texto m&amp;aacute;s largo posible entre &lt;code&gt;'['&lt;/code&gt; y &lt;code&gt;']'&lt;/code&gt; . Como PEG, nunca coincide con nada, porque un PEG es determinista:. &lt;code&gt;.*&lt;/code&gt; Consume el resto de la entrada, por lo que &lt;code&gt;\]&lt;/code&gt; nunca coincide. Como PEG, esto debe escribirse como: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (O &lt;code&gt;\[ @ \]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7d98662c0a3a8c4fd899d63977fd61a1ce489676" translate="yes" xml:space="preserve">
          <source>As a result of using optimized function/intrinsics some functions can return undefined results if the input is invalid. You can use the flag &lt;em&gt;noUndefinedBitOpts&lt;/em&gt; to force predictable behaviour for all input, causing a small performance hit.</source>
          <target state="translated">Como resultado del uso de funciones / intr&amp;iacute;nsecas optimizadas, algunas funciones pueden devolver resultados indefinidos si la entrada no es v&amp;aacute;lida. Puede usar la &lt;em&gt;marca noUndefinedBitOpts&lt;/em&gt; para forzar un comportamiento predecible para todas las entradas, lo que provoca un peque&amp;ntilde;o impacto en el rendimiento.</target>
        </trans-unit>
        <trans-unit id="1664c8e0b3003ab199f6ca491156febd8a7827ee" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.</source>
          <target state="translated">Como regla general,se permite la indentación dentro de las expresiones después de los operadores,un paréntesis abierto y después de las comas.</target>
        </trans-unit>
        <trans-unit id="1bbf2a9820bf41bcc3ae860ff3066a54791d55a8" translate="yes" xml:space="preserve">
          <source>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a [parenthetical function call](./macros.html#calls-expressions-call-with) with &lt;code&gt;nnkAccQuoted&lt;/code&gt;, as follows:</source>
          <target state="translated">Como nota al margen, si eliges usar operadores infijos en forma de prefijo, el AST se comporta como una [llamada a funci&amp;oacute;n entre par&amp;eacute;ntesis] (./ macros.html # llamadas-expresiones-llamada-con) con &lt;code&gt;nnkAccQuoted&lt;/code&gt; , de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="15211f47465417179a8c67c3321dc2d1d401fb39" translate="yes" xml:space="preserve">
          <source>As a special more convenient notation, proc expressions involved in procedure calls can use the &lt;code&gt;do&lt;/code&gt; keyword:</source>
          <target state="translated">Como una notaci&amp;oacute;n especial m&amp;aacute;s conveniente, las expresiones proc involucradas en llamadas a procedimientos pueden usar la palabra clave &lt;code&gt;do&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce683dd181064064b72fd86d9d3e2b66acc2d7ce" translate="yes" xml:space="preserve">
          <source>As a special rule to keep backwards compatibility with older versions of the &lt;code&gt;importcpp&lt;/code&gt; pragma, if there is no special pattern character (any of &lt;code&gt;# ' @&lt;/code&gt;) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</source>
          <target state="translated">Como regla especial para mantener la compatibilidad con versiones anteriores del pragma &lt;code&gt;importcpp&lt;/code&gt; , si no hay ning&amp;uacute;n car&amp;aacute;cter de patr&amp;oacute;n especial (cualquiera de &lt;code&gt;# ' @&lt;/code&gt; ), se asume la notaci&amp;oacute;n de punto o flecha de C ++, por lo que el ejemplo anterior tambi&amp;eacute;n se puede escribir como :</target>
        </trans-unit>
        <trans-unit id="afa79fbae0eabebb420b9fe3f09c01088cf66351" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;decodePlus&lt;/code&gt; is true, &lt;code&gt;'+'&lt;/code&gt; characters are converted to a space.</source>
          <target state="translated">Como regla especial, cuando el valor de &lt;code&gt;decodePlus&lt;/code&gt; es verdadero, &lt;code&gt;'+'&lt;/code&gt; caracteres '+' se convierten en un espacio.</target>
        </trans-unit>
        <trans-unit id="1b120a7d9f07026a29d56a412d87eb19ed8fa37b" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;usePlus&lt;/code&gt; is true, spaces are encoded as &lt;code&gt;'+'&lt;/code&gt; instead of &lt;code&gt;'%20'&lt;/code&gt;.</source>
          <target state="translated">Como regla especial, cuando el valor de &lt;code&gt;usePlus&lt;/code&gt; es verdadero, los espacios se codifican como &lt;code&gt;'+'&lt;/code&gt; en lugar de &lt;code&gt;'%20'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babff93920d51965108f37a93de33ae42b21d0fb" translate="yes" xml:space="preserve">
          <source>As a special semantic extension, an expression in an &lt;code&gt;of&lt;/code&gt; branch of a case statement may evaluate to a set or array constructor; the set or array is then expanded into a list of its elements:</source>
          <target state="translated">Como una extensi&amp;oacute;n sem&amp;aacute;ntica especial, una expresi&amp;oacute;n en una &lt;code&gt;of&lt;/code&gt; ramas de una declaraci&amp;oacute;n de caso puede evaluar a un conjunto o matriz constructora; el conjunto o matriz se expande luego en una lista de sus elementos:</target>
        </trans-unit>
        <trans-unit id="d1d6a828142c8108ac0deb4cc6c8484c64faae27" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, the built-in &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt; pretends to be free of side effects, so that it can be used for debugging routines marked as &lt;code&gt;noSideEffect&lt;/code&gt;.</source>
          <target state="translated">Como regla sem&amp;aacute;ntica especial, el &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho integrado&lt;/a&gt; pretende estar libre de efectos secundarios, por lo que se puede usar para depurar rutinas marcadas como &lt;code&gt;noSideEffect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71489e93932a05f2ea411285eaceb3bbe24614d1" translate="yes" xml:space="preserve">
          <source>As a syntactical extension &lt;code&gt;object&lt;/code&gt; types can be anonymous if declared in a type section via the &lt;code&gt;ref object&lt;/code&gt; or &lt;code&gt;ptr object&lt;/code&gt; notations. This feature is useful if an object should only gain reference semantics:</source>
          <target state="translated">Como extensi&amp;oacute;n sint&amp;aacute;ctica, los tipos de &lt;code&gt;object&lt;/code&gt; pueden ser an&amp;oacute;nimos si se declaran en una secci&amp;oacute;n de tipos a trav&amp;eacute;s de las &lt;code&gt;ptr object&lt;/code&gt; &lt;code&gt;ref object&lt;/code&gt; o ptr . Esta funci&amp;oacute;n es &amp;uacute;til si un objeto solo debe obtener sem&amp;aacute;ntica de referencia:</target>
        </trans-unit>
        <trans-unit id="7859c8bf7a7bf8df21005d62f29109f1c4a9707d" translate="yes" xml:space="preserve">
          <source>As a top level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently these usages have to be put into a &lt;code&gt;.push/pop&lt;/code&gt; environment:</source>
          <target state="translated">Como declaraci&amp;oacute;n de nivel superior, el pragma experimental habilita una caracter&amp;iacute;stica para el resto del m&amp;oacute;dulo en el que est&amp;aacute; habilitado. Esto es problem&amp;aacute;tico para las instancias macro y gen&amp;eacute;ricas que cruzan el alcance de un m&amp;oacute;dulo. Actualmente, estos usos deben colocarse en un &lt;code&gt;.push/pop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1cc9ba3f444ef5f2a70c370287d23a7b3c9d81c8" translate="yes" xml:space="preserve">
          <source>As an example,</source>
          <target state="translated">Como ejemplo,</target>
        </trans-unit>
        <trans-unit id="4faf2cad17e66616bc46eb370913033cba7d7ffe" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, C's macros with parameters are mapped to Nim's templates. This mapping is the best one can do, but it is of course not accurate: Nim's templates operate on syntax trees whereas C's macros work on the token level. c2nim cannot translate any macro that contains the &lt;code&gt;##&lt;/code&gt; token concatenation operator.</source>
          <target state="translated">Como puede verse en el ejemplo, las macros de C con par&amp;aacute;metros se asignan a las plantillas de Nim. Este mapeo es lo mejor que se puede hacer, pero por supuesto no es exacto: las plantillas de Nim operan en &amp;aacute;rboles de sintaxis mientras que las macros de C funcionan a nivel de token. c2nim no puede traducir ninguna macro que contenga el operador de concatenaci&amp;oacute;n de tokens &lt;code&gt;##&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="033710d5a2d1054844b9448ca63a783fde847ed0" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, it is possible to both specify a field's ordinal value and its string value by using a tuple. It is also possible to only specify one of them.</source>
          <target state="translated">Como puede verse en el ejemplo,es posible especificar tanto el valor ordinal de un campo como su valor de cadena utilizando una tupla.También es posible especificar sólo uno de ellos.</target>
        </trans-unit>
        <trans-unit id="33db679c8421cd1a5bcfed816339b58d55a90cf0" translate="yes" xml:space="preserve">
          <source>As can be seen from the examples, strings are matched verbatim except for substrings starting with &lt;code&gt;$&lt;/code&gt;. These constructions are available:</source>
          <target state="translated">Como se puede ver en los ejemplos, las cadenas coinciden literalmente, excepto las subcadenas que comienzan con &lt;code&gt;$&lt;/code&gt; . Estas construcciones est&amp;aacute;n disponibles:</target>
        </trans-unit>
        <trans-unit id="3690ed0de51a088f748c4a5d9756e00f903b6456" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, base methods have to be annotated with the &lt;span id=&quot;base_1&quot;&gt;base&lt;/span&gt; pragma. The &lt;code&gt;base&lt;/code&gt; pragma also acts as a reminder for the programmer that a base method &lt;code&gt;m&lt;/code&gt; is used as the foundation to determine all the effects that a call to &lt;code&gt;m&lt;/code&gt; might cause.</source>
          <target state="translated">Como se puede ver en el ejemplo, los m&amp;eacute;todos base deben anotarse con el pragma &lt;span id=&quot;base_1&quot;&gt;base&lt;/span&gt; . El pragma &lt;code&gt;base&lt;/code&gt; tambi&amp;eacute;n act&amp;uacute;a como un recordatorio para el programador de que se usa un m&amp;eacute;todo base &lt;code&gt;m&lt;/code&gt; como base para determinar todos los efectos que una llamada a &lt;code&gt;m&lt;/code&gt; podr&amp;iacute;a causar.</target>
        </trans-unit>
        <trans-unit id="a5a364bd18b5eaef7b5722d6cd78c85c92bfa5dd" translate="yes" xml:space="preserve">
          <source>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating point literals may be given in decimal (no prefix), binary (prefix &lt;code&gt;0b&lt;/code&gt;), octal (prefix &lt;code&gt;0o&lt;/code&gt;) and hexadecimal (prefix &lt;code&gt;0x&lt;/code&gt;) notation.</source>
          <target state="translated">Como se puede ver en las producciones, las constantes num&amp;eacute;ricas pueden contener guiones bajos para facilitar la lectura. Los literales enteros y de coma flotante se pueden dar en notaci&amp;oacute;n decimal (sin prefijo), binario (prefijo &lt;code&gt;0b&lt;/code&gt; ), octal (prefijo &lt;code&gt;0o&lt;/code&gt; ) y hexadecimal (prefijo &lt;code&gt;0x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7dad921df2b5a3cd443f8e5461c7a9ccced2c050" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">Como se puede ver en el ejemplo,una ventaja de una jerarquía de objetos es que no se necesita un reparto entre los diferentes tipos de objetos.Sin embargo,el acceso a campos de objetos no válidos plantea una excepción.</target>
        </trans-unit>
        <trans-unit id="86acee0719e4df42b833d89f9ce00671880b3bee" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">Como se puede ver en el ejemplo,una ventaja de una jerarquía de objetos es que no se necesita una conversión entre los diferentes tipos de objetos.Sin embargo,el acceso a campos de objetos no válidos plantea una excepción.</target>
        </trans-unit>
        <trans-unit id="8bd2dc16961a30c8b20a5aa5ef6562993b9d9ea9" translate="yes" xml:space="preserve">
          <source>As case statements perform compile-time exhaustiveness checks, the value in every &lt;code&gt;of&lt;/code&gt; branch must be known at compile time. This fact is also exploited to generate more performant code.</source>
          <target state="translated">Como las declaraciones de casos realizan comprobaciones de exhaustividad en tiempo de compilaci&amp;oacute;n, el valor en todos los &lt;code&gt;of&lt;/code&gt; rama debe ser conocido en tiempo de compilaci&amp;oacute;n. Este hecho tambi&amp;eacute;n se aprovecha para generar un c&amp;oacute;digo m&amp;aacute;s eficaz.</target>
        </trans-unit>
        <trans-unit id="a3cf4fdd8a46537cb17ba2fc74bca88aa30a4384" translate="yes" xml:space="preserve">
          <source>As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.</source>
          <target state="translated">Como convención,este procedimiento dividirá los archivos de índice en dos categorías:documentación y API.Los índices API se unirán en un único gran índice clasificado,haciendo el grueso del índice final.Esto es bueno para la documentación de la API porque muchos símbolos se repiten en diferentes módulos.Por otra parte,los índices de la documentación son esencialmente tablas de contenido más algunos marcadores especiales.Estos documentos se presentarán en una sección separada que trata de mantener el orden y la jerarquía de los símbolos en el archivo de índice.</target>
        </trans-unit>
        <trans-unit id="e35fce15f7b6d0e8ddfe4a222398b9462fecc9a2" translate="yes" xml:space="preserve">
          <source>As in generics symbol binding can be influenced via &lt;code&gt;mixin&lt;/code&gt; or &lt;code&gt;bind&lt;/code&gt; statements.</source>
          <target state="translated">Al igual que en los gen&amp;eacute;ricos, la vinculaci&amp;oacute;n de s&amp;iacute;mbolos se puede influir mediante declaraciones &lt;code&gt;mixin&lt;/code&gt; o &lt;code&gt;bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0887bf802c49a565d93917f60c9350172010518c" translate="yes" xml:space="preserve">
          <source>As it can be seen, for an &lt;code&gt;of&lt;/code&gt; branch a comma separated list of values is also allowed.</source>
          <target state="translated">Como se puede ver, para una &lt;code&gt;of&lt;/code&gt; rama una coma separ&amp;oacute; la lista de valores tambi&amp;eacute;n est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="026e19060b7027adb0d7fdc31274d77b9a547e42" translate="yes" xml:space="preserve">
          <source>As long as a type &lt;code&gt;T&lt;/code&gt; is incomplete &lt;code&gt;sizeof(T)&lt;/code&gt; or &quot;runtime type information&quot; for &lt;code&gt;T&lt;/code&gt; is not available.</source>
          <target state="translated">Siempre que un tipo &lt;code&gt;T&lt;/code&gt; sea ​​incompleto, el &lt;code&gt;sizeof(T)&lt;/code&gt; o la &quot;informaci&amp;oacute;n del tipo de tiempo de ejecuci&amp;oacute;n&quot; para &lt;code&gt;T&lt;/code&gt; no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="2dca63b7a6f1fd2e2ca6e65f781d803b65614773" translate="yes" xml:space="preserve">
          <source>As long as you don't use the threadvar emulation Nim uses native thread variables, of which you get a fresh version whenever you create a thread. You can then attach a GC to this thread via</source>
          <target state="translated">Mientras no uses la emulación de threadvar Nim usa variables de hilos nativos,de los cuales obtienes una versión fresca cada vez que creas un hilo.Puedes entonces adjuntar un GC a este hilo a través de</target>
        </trans-unit>
        <trans-unit id="26a74fa3cef27390dd0524bd6f48c70bfa5b9b01" translate="yes" xml:space="preserve">
          <source>As many &lt;code&gt;nnkIdent&lt;/code&gt; appear as there are pragmas between &lt;code&gt;{..}&lt;/code&gt;. Note that the declaration of new pragmas is essentially the same:</source>
          <target state="translated">&lt;code&gt;nnkIdent&lt;/code&gt; tantos nnkIdent como pragmas hay entre &lt;code&gt;{..}&lt;/code&gt; . Tenga en cuenta que la declaraci&amp;oacute;n de nuevos pragmas es esencialmente la misma:</target>
        </trans-unit>
        <trans-unit id="45b0ed81197cf305d45603349a135b9f85fd6ed7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, the built-in &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; (stringify) operator turns any basic type into a string, which you can then print to the console using the &lt;code&gt;echo&lt;/code&gt; proc. However, advanced types, and your own custom types, won't work with the &lt;code&gt;$&lt;/code&gt; operator until you define it for them. Sometimes you just want to debug the current value of a complex type without having to write its &lt;code&gt;$&lt;/code&gt; operator. You can use then the &lt;a href=&quot;system#repr&quot;&gt;repr&lt;/a&gt; proc which works with any type and even complex data graphs with cycles. The following example shows that even for basic types there is a difference between the &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;repr&lt;/code&gt; outputs:</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, el operador &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; (stringify) incorporado convierte cualquier tipo b&amp;aacute;sico en una cadena, que luego puede imprimir en la consola usando el proc &lt;code&gt;echo&lt;/code&gt; . Sin embargo, los tipos avanzados y sus propios tipos personalizados no funcionar&amp;aacute;n con el operador &lt;code&gt;$&lt;/code&gt; hasta que lo defina para ellos. A veces, solo desea depurar el valor actual de un tipo complejo sin tener que escribir su operador &lt;code&gt;$&lt;/code&gt; . Puede usar entonces el proceso &lt;a href=&quot;system#repr&quot;&gt;repr&lt;/a&gt; que funciona con cualquier tipo e incluso gr&amp;aacute;ficos de datos complejos con ciclos. El siguiente ejemplo muestra que incluso para los tipos b&amp;aacute;sicos hay una diferencia entre las salidas &lt;code&gt;$&lt;/code&gt; y &lt;code&gt;repr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5c0e6c3f6dc802ee854147fa74a0509740327d59" translate="yes" xml:space="preserve">
          <source>As seen in the above example, the case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value, much like in an &lt;em&gt;expr&lt;/em&gt; template.</source>
          <target state="translated">Como se ve en el ejemplo anterior, la expresi&amp;oacute;n de caso tambi&amp;eacute;n puede introducir efectos secundarios. Cuando se dan varias declaraciones para una rama, Nim usar&amp;aacute; la &amp;uacute;ltima expresi&amp;oacute;n como valor de resultado, al igual que en una plantilla &lt;em&gt;expr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="439f48dfdc54a1d1cb2592abb741204d4e9306e5" translate="yes" xml:space="preserve">
          <source>As seen in the previous example, in such instantiations, it's not necessary to supply all type parameters of the generic type, because any missing ones will be inferred to have the equivalent of the &lt;em&gt;any&lt;/em&gt; type class and thus they will match anything without discrimination.</source>
          <target state="translated">Como se vio en el ejemplo anterior, en tales instancias, no es necesario proporcionar todos los par&amp;aacute;metros de tipo del tipo gen&amp;eacute;rico, porque se inferir&amp;aacute; que los que faltan tienen el equivalente de &lt;em&gt;cualquier&lt;/em&gt; clase de tipo y, por lo tanto, coincidir&amp;aacute;n con cualquier cosa sin discriminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b6e6a7e96d415104630cd8f0ead0c140e77a0902" translate="yes" xml:space="preserve">
          <source>As seen in the previous examples, you can refer to generic concepts such as &lt;em&gt;Enumerable[T]&lt;/em&gt; just by their short name. Much like the regular generic types, the concept will be automatically instantiated with the bind once auto type in the place of each missing generic param.</source>
          <target state="translated">Como se vio en los ejemplos anteriores, puede hacer referencia a conceptos gen&amp;eacute;ricos como &lt;em&gt;Enumerable [T]&lt;/em&gt; simplemente por su nombre corto. Al igual que los tipos gen&amp;eacute;ricos normales, el concepto se instanciar&amp;aacute; autom&amp;aacute;ticamente con el enlace una vez que se escriba autom&amp;aacute;ticamente en el lugar de cada par&amp;aacute;metro gen&amp;eacute;rico que falte.</target>
        </trans-unit>
        <trans-unit id="e9c1fc890399facee98adf935d7347503148926c" translate="yes" xml:space="preserve">
          <source>As such it supports a resolution of nanoseconds internally; however the API uses microseconds for convenience.</source>
          <target state="translated">Como tal,soporta una resolución de nanosegundos internamente;sin embargo,la API utiliza microsegundos por conveniencia.</target>
        </trans-unit>
        <trans-unit id="01367ae653af83b7f5aec2955cfd950745102be9" translate="yes" xml:space="preserve">
          <source>As such, a check to see if the deque is empty is needed before any access, unless your program logic guarantees it indirectly.</source>
          <target state="translated">Por lo tanto,es necesario comprobar si el deque está vacío antes de cualquier acceso,a menos que la lógica de su programa lo garantice indirectamente.</target>
        </trans-unit>
        <trans-unit id="286afc9752bec98ed25f43fb3fd09c91c5151ede" translate="yes" xml:space="preserve">
          <source>As the above example shows, Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Como muestra el ejemplo anterior, Nim no necesita &lt;em&gt;propiedades de&lt;/em&gt; obtenci&amp;oacute;n: los procedimientos de obtenci&amp;oacute;n ordinarios que se llaman con la &lt;em&gt;sintaxis de llamada&lt;/em&gt; al &lt;em&gt;m&amp;eacute;todo&lt;/em&gt; logran lo mismo. Pero establecer un valor es diferente; para esto se necesita una sintaxis especial de setter:</target>
        </trans-unit>
        <trans-unit id="e739d8d09978b2dcb0c312361958c802f83a064a" translate="yes" xml:space="preserve">
          <source>As the example demonstrates, invocation of a multi-method cannot be ambiguous: Collide 2 is preferred over collide 1 because the resolution works from left to right. Thus &lt;code&gt;Unit, Thing&lt;/code&gt; is preferred over &lt;code&gt;Thing, Unit&lt;/code&gt;.</source>
          <target state="translated">Como demuestra el ejemplo, la invocaci&amp;oacute;n de un m&amp;eacute;todo m&amp;uacute;ltiple no puede ser ambigua: se prefiere colisionar 2 a colisionar 1 porque la resoluci&amp;oacute;n funciona de izquierda a derecha. Por lo tanto &lt;code&gt;Unit, Thing&lt;/code&gt; se prefiere Unidad, Cosa sobre &lt;code&gt;Thing, Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eb5ab0367cdd1ab709d3f90ffd6f79cf740c8bc" translate="yes" xml:space="preserve">
          <source>As the example shows &lt;code&gt;computedGoto&lt;/code&gt; is mostly useful for interpreters. If the underlying backend (C compiler) does not support the computed goto extension the pragma is simply ignored.</source>
          <target state="translated">Como muestra el ejemplo, &lt;code&gt;computedGoto&lt;/code&gt; es principalmente &amp;uacute;til para int&amp;eacute;rpretes. Si el backend subyacente (compilador C) no admite la extensi&amp;oacute;n goto calculada, el pragma simplemente se ignora.</target>
        </trans-unit>
        <trans-unit id="aa6410949c68317244c63b45dcd8f86123a06792" translate="yes" xml:space="preserve">
          <source>As the example shows, passing arguments to a filter can be done just like an ordinary procedure call with named or positional arguments. The available parameters depend on the invoked filter. Before version 0.12.0 of the language &lt;code&gt;#!&lt;/code&gt; was used instead of &lt;code&gt;#?&lt;/code&gt;.</source>
          <target state="translated">Como muestra el ejemplo, pasar argumentos a un filtro se puede hacer como una llamada a un procedimiento ordinario con argumentos con nombre o posicionales. Los par&amp;aacute;metros disponibles dependen del filtro invocado. Antes de la versi&amp;oacute;n 0.12.0 del idioma &lt;code&gt;#!&lt;/code&gt; se us&amp;oacute; en lugar de &lt;code&gt;#?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d5a0e7057a8c33abd1db459e64ad340a213114" translate="yes" xml:space="preserve">
          <source>As the regular expressions supported by this module are enormous, the reader is referred to &lt;a href=&quot;http://perldoc.perl.org/perlre.html&quot;&gt;http://perldoc.perl.org/perlre.html&lt;/a&gt; for the full documentation of Perl's regular expressions.</source>
          <target state="translated">Como las expresiones regulares soportadas por este m&amp;oacute;dulo son enormes, se remite al lector a &lt;a href=&quot;http://perldoc.perl.org/perlre.html&quot;&gt;http://perldoc.perl.org/perlre.html&lt;/a&gt; para la documentaci&amp;oacute;n completa de las expresiones regulares de Perl.</target>
        </trans-unit>
        <trans-unit id="868dd43083390b7b1e29d7736d8260c51c9f2330" translate="yes" xml:space="preserve">
          <source>As their name suggests, static parameters must be known at compile-time:</source>
          <target state="translated">Como su nombre lo sugiere,los parámetros estáticos deben ser conocidos en tiempo de compilación:</target>
        </trans-unit>
        <trans-unit id="62dcfc00fb0387dbffe758f0f4162e7a2adedb56" translate="yes" xml:space="preserve">
          <source>As usual &lt;code&gt;locks&lt;/code&gt; is an inferred effect and there is a subtype relation: &lt;code&gt;proc () {.locks: N.}&lt;/code&gt; is a subtype of &lt;code&gt;proc () {.locks: M.}&lt;/code&gt; iff (M &amp;lt;= N).</source>
          <target state="translated">Como de costumbre, los &lt;code&gt;locks&lt;/code&gt; son un efecto inferido y hay una relaci&amp;oacute;n de subtipo: &lt;code&gt;proc () {.locks: N.}&lt;/code&gt; es un subtipo de &lt;code&gt;proc () {.locks: M.}&lt;/code&gt; iff (M &amp;lt;= N).</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="translated">Declaración de Asm</target>
        </trans-unit>
        <trans-unit id="02bb6749711a6c6662b3a9fd807816e9e50ff52d" translate="yes" xml:space="preserve">
          <source>Assembler statement</source>
          <target state="translated">Declaración de la asamblea</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="d726d517f001352072c6361a864be12f97f89db4" translate="yes" xml:space="preserve">
          <source>Assignment compatibility</source>
          <target state="translated">Compatibilidad de asignación</target>
        </trans-unit>
        <trans-unit id="d9203ef0427904fd0cb4f5281674fd37cff746c1" translate="yes" xml:space="preserve">
          <source>Assignments are not special, the left-hand-side expression is evaluated before the right-hand side:</source>
          <target state="translated">Las asignaciones no son especiales,la expresión del lado izquierdo se evalúa antes que la del lado derecho:</target>
        </trans-unit>
        <trans-unit id="1091ff5f3536a87992e1a98e7fdf3572d7d495bf" translate="yes" xml:space="preserve">
          <source>Associate application-defined &lt;code&gt;data&lt;/code&gt; with descriptor &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">Asocie &lt;code&gt;data&lt;/code&gt; definidos por la aplicaci&amp;oacute;n con el descriptor &lt;code&gt;fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="c10e87299448214997c9ba36a197edc020ad8d7c" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;a href=&quot;#readHeaderRow.CsvParser&quot;&gt;readHeaderRow&lt;/a&gt; has already been called.</source>
          <target state="translated">Supone que ya se ha llamado a &lt;a href=&quot;#readHeaderRow.CsvParser&quot;&gt;readHeaderRow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="464eb5858db553f9a4e084882b2d692e14f18a75" translate="yes" xml:space="preserve">
          <source>Async IO in Nim consists of multiple layers (from highest to lowest):</source>
          <target state="translated">Async IO en Nim consiste en múltiples capas (de la más alta a la más baja):</target>
        </trans-unit>
        <trans-unit id="d57562f32a2344e4a892e8ad77de461a0dddac00" translate="yes" xml:space="preserve">
          <source>Async alternative to TFTPClient.</source>
          <target state="translated">Alternativa de sincronización con el cliente TFTPC.</target>
        </trans-unit>
        <trans-unit id="61a0af2d907e2fd6001d764ad03dc8d1c0e711f3" translate="yes" xml:space="preserve">
          <source>Async await</source>
          <target state="translated">Async espera</target>
        </trans-unit>
        <trans-unit id="bb9065007b1394a4c890c8c730359a31cd3d4af2" translate="yes" xml:space="preserve">
          <source>Async version of &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">Versi&amp;oacute;n &lt;code&gt;recv&lt;/code&gt; de recv .</target>
        </trans-unit>
        <trans-unit id="48e12dfeb54ee671e650066950d5a652045b9307" translate="yes" xml:space="preserve">
          <source>AsyncDispatch</source>
          <target state="translated">AsyncDispatch</target>
        </trans-unit>
        <trans-unit id="8b371c51c3d43e683cda1ca13b2b61e13b7f6e7b" translate="yes" xml:space="preserve">
          <source>Asynchronous IO in Nim</source>
          <target state="translated">IO asincrónica en Nim</target>
        </trans-unit>
        <trans-unit id="7b9ef39877db01dd17657705a2bbb4a6bc49d720" translate="yes" xml:space="preserve">
          <source>Asynchronous procedures</source>
          <target state="translated">Procedimientos asincrónicos</target>
        </trans-unit>
        <trans-unit id="c80b1fc2540985a4b46e1a0759e789f85aac96b9" translate="yes" xml:space="preserve">
          <source>Asynchronous procedures remove the pain of working with callbacks. They do this by allowing you to write asynchronous code the same way as you would write synchronous code.</source>
          <target state="translated">Los procedimientos asíncronos eliminan el dolor de trabajar con devoluciones de llamada.Lo hacen permitiéndote escribir código asíncrono de la misma manera que escribirías código síncrono.</target>
        </trans-unit>
        <trans-unit id="b4324fe839ee2fc80392c528dbb2288500cc3cc5" translate="yes" xml:space="preserve">
          <source>Asynchronous sockets</source>
          <target state="translated">Enchufes asíncronos</target>
        </trans-unit>
        <trans-unit id="04fc05d16ff1681dbd084361e286ad3b082b3c13" translate="yes" xml:space="preserve">
          <source>Asynchronous sockets are supported, however a better alternative is to use the &lt;a href=&quot;asyncio&quot;&gt;asyncio&lt;/a&gt; module.</source>
          <target state="translated">Se admiten sockets asincr&amp;oacute;nicos, sin embargo, una mejor alternativa es usar el m&amp;oacute;dulo &lt;a href=&quot;asyncio&quot;&gt;asyncio&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c54cd214970569c34b0894bafdff80b326240d3" translate="yes" xml:space="preserve">
          <source>At runtime the dynamic library is searched for (in this order):</source>
          <target state="translated">En tiempo de ejecución se busca la biblioteca dinámica (en este orden):</target>
        </trans-unit>
        <trans-unit id="1e0afa779399055030a34271b80bf03107242a5a" translate="yes" xml:space="preserve">
          <source>At the moment idetools support is still in development so the test suite is not integrated with the main test suite and you have to run it manually. First you have to compile the tester:</source>
          <target state="translated">Por el momento,el soporte de idetools está todavía en desarrollo,por lo que el conjunto de pruebas no está integrado con el conjunto de pruebas principal y hay que ejecutarlo manualmente.Primero tienes que compilar el probador:</target>
        </trans-unit>
        <trans-unit id="f92987b2f51905d6ac8ecf565a309b7358bafb43" translate="yes" xml:space="preserve">
          <source>At this time only &lt;em&gt;fastLog2&lt;/em&gt;, &lt;em&gt;firstSetBit, `countLeadingZeroBits&lt;/em&gt;, &lt;em&gt;countTrailingZeroBits&lt;/em&gt; may return undefined and/or platform dependant value if given invalid input.</source>
          <target state="translated">En este momento, solo &lt;em&gt;fastLog2&lt;/em&gt; , &lt;em&gt;firstSetBit, `countLeadingZeroBits&lt;/em&gt; , &lt;em&gt;countTrailingZeroBits&lt;/em&gt; pueden devolver un valor indefinido y / o dependiente de la plataforma si se proporciona una entrada no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="dc088b4a46ed03929326ec3129e2350a99f0a990" translate="yes" xml:space="preserve">
          <source>Auto type</source>
          <target state="translated">Tipo de auto</target>
        </trans-unit>
        <trans-unit id="9e0bd780b5a4993d6aec3f619069ec9a81419d34" translate="yes" xml:space="preserve">
          <source>Automatic dereferencing</source>
          <target state="translated">Derivación automática</target>
        </trans-unit>
        <trans-unit id="b34f3f41021aba6582ca800065938665aaa25537" translate="yes" xml:space="preserve">
          <source>Automatic dereferencing is also performed for the first argument of a routine call. But currently this feature has to be only enabled via &lt;code&gt;{.experimental: &quot;implicitDeref&quot;.}&lt;/code&gt;:</source>
          <target state="translated">La eliminaci&amp;oacute;n de referencias autom&amp;aacute;tica tambi&amp;eacute;n se realiza para el primer argumento de una llamada de rutina. Pero actualmente esta funci&amp;oacute;n solo debe habilitarse a trav&amp;eacute;s de &lt;code&gt;{.experimental: &quot;implicitDeref&quot;.}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f2f8a2fddb2e537990a2864cb34d8eee2d1446d" translate="yes" xml:space="preserve">
          <source>Automatic self insertions</source>
          <target state="translated">Autoinserciones automáticas</target>
        </trans-unit>
        <trans-unit id="d489cd84b7c72c977a3c1f79e61d852ca4f5fd46" translate="yes" xml:space="preserve">
          <source>Automatic type conversion in expressions with different kinds of floating point types is performed: See &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt; for further details. Arithmetic performed on floating point types follows the IEEE standard. Integer types are not converted to floating point types automatically and vice versa.</source>
          <target state="translated">Se realiza la conversi&amp;oacute;n autom&amp;aacute;tica de tipos en expresiones con diferentes tipos de tipos de punto flotante: consulte &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Relaci&amp;oacute;n convertible&lt;/a&gt; para obtener m&amp;aacute;s detalles. La aritm&amp;eacute;tica realizada en tipos de coma flotante sigue el est&amp;aacute;ndar IEEE. Los tipos enteros no se convierten a tipos de coma flotante autom&amp;aacute;ticamente y viceversa.</target>
        </trans-unit>
        <trans-unit id="b64d4599316074da7ef005b5cd10b87308f8b012" translate="yes" xml:space="preserve">
          <source>Automatic type conversion in expressions with different kinds of floating point types is performed: the smaller type is converted to the larger. Integer types are &lt;strong&gt;not&lt;/strong&gt; converted to floating point types automatically, nor vice versa. Use the &lt;a href=&quot;system#toInt&quot;&gt;toInt&lt;/a&gt; and &lt;a href=&quot;system#toFloat&quot;&gt;toFloat&lt;/a&gt; procs for these conversions.</source>
          <target state="translated">Se realiza la conversi&amp;oacute;n autom&amp;aacute;tica de tipos en expresiones con diferentes tipos de tipos de punto flotante: el tipo m&amp;aacute;s peque&amp;ntilde;o se convierte en el m&amp;aacute;s grande. Los tipos enteros &lt;strong&gt;no se&lt;/strong&gt; convierten a tipos de coma flotante autom&amp;aacute;ticamente, ni viceversa. Utilice los &lt;a href=&quot;system#toInt&quot;&gt;procesos toInt&lt;/a&gt; y &lt;a href=&quot;system#toFloat&quot;&gt;toFloat&lt;/a&gt; para estas conversiones.</target>
        </trans-unit>
        <trans-unit id="bc40764f7876b20ac068b0f8a1ac400c090ad482" translate="yes" xml:space="preserve">
          <source>Available filters</source>
          <target state="translated">Los filtros disponibles</target>
        </trans-unit>
        <trans-unit id="48dc005192dc15899b10a69113ce172a5a8e8e1d" translate="yes" xml:space="preserve">
          <source>Avoiding SQL injection attacks</source>
          <target state="translated">Evitar los ataques de inyección SQL</target>
        </trans-unit>
        <trans-unit id="ed59754f17e7c2d9945cda54ca5d2aa1dec958df" translate="yes" xml:space="preserve">
          <source>Back reference to the &lt;code&gt;i``th capture. ``i&lt;/code&gt; counts from 1.</source>
          <target state="translated">Referencia posterior a la &lt;code&gt;i``th capture. ``i&lt;/code&gt; cuento desde 1.</target>
        </trans-unit>
        <trans-unit id="c1b87da997dc3c85ddc08c2e6d0f37c746574592" translate="yes" xml:space="preserve">
          <source>Backend code calling Nim</source>
          <target state="translated">Código del backend llamando a Nim</target>
        </trans-unit>
        <trans-unit id="d2d1e1c764fd65afb7dd5b1cfc7187320a368f3d" translate="yes" xml:space="preserve">
          <source>Backend code can interface with Nim code exposed through the &lt;a href=&quot;manual#exportc-pragma&quot;&gt;exportc pragma&lt;/a&gt;. The &lt;code&gt;exportc&lt;/code&gt; pragma is the &lt;em&gt;generic&lt;/em&gt; way of making Nim symbols available to the backends. By default the Nim compiler will mangle all the Nim symbols to avoid any name collision, so the most significant thing the &lt;code&gt;exportc&lt;/code&gt; pragma does is maintain the Nim symbol name, or if specified, use an alternative symbol for the backend in case the symbol rules don't match.</source>
          <target state="translated">El c&amp;oacute;digo de backend puede interactuar con el c&amp;oacute;digo de Nim expuesto a trav&amp;eacute;s de &lt;a href=&quot;manual#exportc-pragma&quot;&gt;exportc pragma&lt;/a&gt; . El pragma &lt;code&gt;exportc&lt;/code&gt; es la forma &lt;em&gt;gen&amp;eacute;rica&lt;/em&gt; de hacer que los s&amp;iacute;mbolos Nim est&amp;eacute;n disponibles para los backends. De forma predeterminada, el compilador de Nim modificar&amp;aacute; todos los s&amp;iacute;mbolos de Nim para evitar cualquier colisi&amp;oacute;n de nombres, por lo que lo m&amp;aacute;s importante que hace &lt;code&gt;exportc&lt;/code&gt; pragma es mantener el nombre del s&amp;iacute;mbolo de Nim o, si se especifica, utilizar un s&amp;iacute;mbolo alternativo para el backend en caso de que las reglas del s&amp;iacute;mbolo no no coincide.</target>
        </trans-unit>
        <trans-unit id="4409ab544e7304fef23a5593b1e7c39ba4acd8f5" translate="yes" xml:space="preserve">
          <source>Backend issues</source>
          <target state="translated">Los números atrasados</target>
        </trans-unit>
        <trans-unit id="b76b69c33162b1653a17f2c6f93e78edc8380818" translate="yes" xml:space="preserve">
          <source>Backend language options</source>
          <target state="translated">Opciones de idioma del backend</target>
        </trans-unit>
        <trans-unit id="b3776d63ad7b7a84bfe20d9c6d4a53a2b25d0e43" translate="yes" xml:space="preserve">
          <source>Backends</source>
          <target state="translated">Backends</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="d761e5a62561f09ed0d44ad1cb46328e1f217a6f" translate="yes" xml:space="preserve">
          <source>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</source>
          <target state="translated">Las barras invertidas se interpretan literalmente,a menos que precedan inmediatamente a una comilla doble.</target>
        </trans-unit>
        <trans-unit id="927ec03da92f02ddd56de8e2adaa715fed9bcf2d" translate="yes" xml:space="preserve">
          <source>Base class for floating point exceptions.</source>
          <target state="translated">Clase base para las excepciones de punto flotante.</target>
        </trans-unit>
        <trans-unit id="c01b2a5ff5b7f9aeb57693046b04a30f8f31374f" translate="yes" xml:space="preserve">
          <source>Base exception class.</source>
          <target state="translated">Clase de excepción de la base.</target>
        </trans-unit>
        <trans-unit id="a7eab2acbe559b446c1a8d7cd0fa8164b769b943" translate="yes" xml:space="preserve">
          <source>Base exception object for all DOM Exceptions</source>
          <target state="translated">Objeto de excepción de base para todas las excepciones DOM</target>
        </trans-unit>
        <trans-unit id="83973edfe760182bfdbc649edc3760f5c0702635" translate="yes" xml:space="preserve">
          <source>Base filename plus anchor hyper link (eg. &lt;code&gt;algorithm.html#*,int,SortOrder&lt;/code&gt;).</source>
          <target state="translated">Nombre de archivo base m&amp;aacute;s hiperv&amp;iacute;nculo de anclaje (por ejemplo, &lt;code&gt;algorithm.html#*,int,SortOrder&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="18bb69613ad5672181aef86b3bcfc02639a73650" translate="yes" xml:space="preserve">
          <source>Basic command line switches are:</source>
          <target state="translated">Los interruptores básicos de la línea de mando son:</target>
        </trans-unit>
        <trans-unit id="65e84bd37e76307cd618b3b242847f165ff6ea89" translate="yes" xml:space="preserve">
          <source>Basic math routines for Nim. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">Rutinas matem&amp;aacute;ticas b&amp;aacute;sicas para Nim. Este m&amp;oacute;dulo est&amp;aacute; disponible para el &lt;a href=&quot;backends#the-javascript-target&quot;&gt;destino JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">Tipos básicos</target>
        </trans-unit>
        <trans-unit id="8fc3f098aacbac78663d7394b49aef616d056323" translate="yes" xml:space="preserve">
          <source>Be aware that destructors are not called for objects allocated with &lt;code&gt;new&lt;/code&gt;. This may change in future versions of language, but for now the &lt;span id=&quot;finalizer_1&quot;&gt;finalizer&lt;/span&gt; parameter to &lt;code&gt;new&lt;/code&gt; has to be used.</source>
          <target state="translated">Tenga en cuenta que los destructores no se llaman para objetos asignados con &lt;code&gt;new&lt;/code&gt; . Esto puede cambiar en futuras versiones del idioma, pero por ahora se debe usar el par&amp;aacute;metro del &lt;span id=&quot;finalizer_1&quot;&gt;finalizador&lt;/span&gt; a &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3e15a7b46caea989a1213b44375d001f13628fc" translate="yes" xml:space="preserve">
          <source>Be sure your callback &lt;code&gt;cb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, if you want to remove watch of &lt;em&gt;read&lt;/em&gt; notifications, and &lt;code&gt;false&lt;/code&gt;, if you want to continue receiving notifications.</source>
          <target state="translated">Aseg&amp;uacute;rese de que su &lt;code&gt;cb&lt;/code&gt; de devoluci&amp;oacute;n de llamada devuelva &lt;code&gt;true&lt;/code&gt; , si desea eliminar el reloj de notificaciones &lt;em&gt;le&amp;iacute;das&lt;/em&gt; , y &lt;code&gt;false&lt;/code&gt; , si desea continuar recibiendo notificaciones.</target>
        </trans-unit>
        <trans-unit id="8fba0a783eb77900741ec80cede356c924d6db33" translate="yes" xml:space="preserve">
          <source>Be sure your callback &lt;code&gt;cb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, if you want to remove watch of &lt;em&gt;write&lt;/em&gt; notifications, and &lt;code&gt;false&lt;/code&gt;, if you want to continue receiving notifications.</source>
          <target state="translated">Aseg&amp;uacute;rese de que su &lt;code&gt;cb&lt;/code&gt; de devoluci&amp;oacute;n de llamada devuelva &lt;code&gt;true&lt;/code&gt; , si desea eliminar el reloj de notificaciones de &lt;em&gt;escritura&lt;/em&gt; , y &lt;code&gt;false&lt;/code&gt; , si desea continuar recibiendo notificaciones.</target>
        </trans-unit>
        <trans-unit id="c4102f62e5cacc86882ccbd463d607ec09aa3efa" translate="yes" xml:space="preserve">
          <source>Because the backslash &lt;code&gt;\&lt;/code&gt; is a meta character both in the Nim programming language and in regular expressions, it is strongly recommended that one uses the &lt;em&gt;raw&lt;/em&gt; strings of Nim, so that backslashes are interpreted by the regular expression engine:</source>
          <target state="translated">Debido a que la barra invertida &lt;code&gt;\&lt;/code&gt; es un metacar&amp;aacute;cter tanto en el lenguaje de programaci&amp;oacute;n Nim como en las expresiones regulares, se recomienda encarecidamente que se utilicen las cadenas &lt;em&gt;sin&lt;/em&gt; formato de Nim, de modo que las barras invertidas sean interpretadas por el motor de expresiones regulares:</target>
        </trans-unit>
        <trans-unit id="9712a92a80197b448150bfcf6e22b8f9c9c72490" translate="yes" xml:space="preserve">
          <source>Because the literal is a raw string literal, the &lt;code&gt;\n&lt;/code&gt; is not interpreted as an escape sequence.</source>
          <target state="translated">Debido a que el literal es un literal de cadena sin formato, &lt;code&gt;\n&lt;/code&gt; no se interpreta como una secuencia de escape.</target>
        </trans-unit>
        <trans-unit id="d8fb87298b9236d186e536c812e43df39ea168a6" translate="yes" xml:space="preserve">
          <source>Because the underlying &lt;code&gt;cmp()&lt;/code&gt; is defined for tuples you can do a nested sort like in the following example:</source>
          <target state="translated">Debido a que el &lt;code&gt;cmp()&lt;/code&gt; subyacente est&amp;aacute; definido para tuplas, puede hacer una ordenaci&amp;oacute;n anidada como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="d6d168f46ea8f3c36c56fc3253836f0e10427b1e" translate="yes" xml:space="preserve">
          <source>Before stopping the program the &quot;quit procedures&quot; are called in the opposite order they were added with &lt;a href=&quot;#addQuitProc&quot;&gt;addQuitProc&lt;/a&gt;. &lt;code&gt;quit&lt;/code&gt; never returns and ignores any exception that may have been raised by the quit procedures. It does &lt;em&gt;not&lt;/em&gt; call the garbage collector to free all the memory, unless a quit procedure calls &lt;a href=&quot;#GC_fullCollect&quot;&gt;GC_fullCollect&lt;/a&gt;.</source>
          <target state="translated">Antes de detener el programa, los &quot;procedimientos de salida&quot; se llaman en el orden opuesto al que se agregaron con &lt;a href=&quot;#addQuitProc&quot;&gt;addQuitProc&lt;/a&gt; . &lt;code&gt;quit&lt;/code&gt; nunca regresa e ignora cualquier excepci&amp;oacute;n que pueda haber sido provocada por los procedimientos de salida. No &lt;em&gt;, no&lt;/em&gt; llamar al recolector de basura para liberar toda la memoria, a menos que una salga de llamadas a procedimientos &lt;a href=&quot;#GC_fullCollect&quot;&gt;GC_fullCollect&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43d498bdad3123202c81edb42a89596ea2e8269d" translate="yes" xml:space="preserve">
          <source>Before the line is processed as a regular expression, some basic variables are searched for and replaced in the tests. The variables which will be replaced are:</source>
          <target state="translated">Antes de que la línea se procese como una expresión regular,se buscan algunas variables básicas y se reemplazan en las pruebas.Las variables que serán reemplazadas son:</target>
        </trans-unit>
        <trans-unit id="b0e4a0c03109bf4544e258937ad71acfe78c0f79" translate="yes" xml:space="preserve">
          <source>Before the thread exits, you should tear down the thread's GC to prevent memory leaks by calling</source>
          <target state="translated">Antes de que el hilo salga,deberías derribar el GC del hilo para evitar fugas de memoria llamando a</target>
        </trans-unit>
        <trans-unit id="310e2e763625e5d6d59dce2240ea063af385856f" translate="yes" xml:space="preserve">
          <source>Before using this proc you need to initialise a &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and parse a rst file with &lt;code&gt;rstParse&lt;/code&gt; from the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. Example:</source>
          <target state="translated">Antes de usar este proceso, debe inicializar un &lt;code&gt;RstGenerator&lt;/code&gt; con &lt;code&gt;initRstGenerator&lt;/code&gt; y analizar un primer archivo con &lt;code&gt;rstParse&lt;/code&gt; desde el &lt;a href=&quot;rst&quot;&gt;m&amp;oacute;dulo packages / docutils / rst&lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="966b254aa9447e510a7ca9c23d5f788a878f610b" translate="yes" xml:space="preserve">
          <source>Begins a never ending global dispatcher poll loop.</source>
          <target state="translated">Comienza un interminable ciclo de encuestas de los despachadores globales.</target>
        </trans-unit>
        <trans-unit id="700e73def7ceec3f6434ea58699b8763915742e0" translate="yes" xml:space="preserve">
          <source>Begins connecting &lt;code&gt;sock&lt;/code&gt; to &lt;code&gt;name&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">Comienza a conectar el &lt;code&gt;sock&lt;/code&gt; al &lt;code&gt;name&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b6ca901e484b0f0288a15e878ab0c9feab7a2af" translate="yes" xml:space="preserve">
          <source>Behaves similar to &lt;code&gt;sockets.readLine&lt;/code&gt;, however it handles non-blocking sockets properly. This function guarantees that &lt;code&gt;line&lt;/code&gt; is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved, when this happens False will be returned. True will only be returned if a full line has been retrieved or the socket has been disconnected in which case &lt;code&gt;line&lt;/code&gt; will be set to &quot;&quot;.</source>
          <target state="translated">Se comporta de forma similar a &lt;code&gt;sockets.readLine&lt;/code&gt; , sin embargo, maneja los sockets sin bloqueo correctamente. Esta funci&amp;oacute;n garantiza que la &lt;code&gt;line&lt;/code&gt; sea ​​una l&amp;iacute;nea completa, si esta funci&amp;oacute;n solo puede recuperar algunos datos; guardar&amp;aacute; estos datos y los agregar&amp;aacute; al resultado cuando se recupere una l&amp;iacute;nea completa, cuando esto suceda, se devolver&amp;aacute; False. True solo se devolver&amp;aacute; si se ha recuperado una l&amp;iacute;nea completa o si se ha desconectado el conector, en cuyo caso la &lt;code&gt;line&lt;/code&gt; se establecer&amp;aacute; en &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="c4326a5636a46dcb618755741f866f4b972d0a19" translate="yes" xml:space="preserve">
          <source>Behaves similar to &lt;code&gt;sockets.recvLine&lt;/code&gt;, however it handles non-blocking sockets properly. This function guarantees that &lt;code&gt;line&lt;/code&gt; is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved.</source>
          <target state="translated">Se comporta de manera similar a &lt;code&gt;sockets.recvLine&lt;/code&gt; , sin embargo, maneja los sockets sin bloqueo correctamente. Esta funci&amp;oacute;n garantiza que la &lt;code&gt;line&lt;/code&gt; sea ​​una l&amp;iacute;nea completa, si esta funci&amp;oacute;n solo puede recuperar algunos datos; guardar&amp;aacute; estos datos y los agregar&amp;aacute; al resultado cuando se recupere una l&amp;iacute;nea completa.</target>
        </trans-unit>
        <trans-unit id="265943f4fdc43174a25de385d384224b6714c3a1" translate="yes" xml:space="preserve">
          <source>Better serialization/deserialization control:</source>
          <target state="translated">Mejor control de serialización/deserialización:</target>
        </trans-unit>
        <trans-unit id="2f93848862aa5b35417b63e68af291d5b94657ce" translate="yes" xml:space="preserve">
          <source>Beware of nesting:</source>
          <target state="translated">Cuidado con los nidos:</target>
        </trans-unit>
        <trans-unit id="79d0274d51b13cfe02935327c0fc3f6297737534" translate="yes" xml:space="preserve">
          <source>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</source>
          <target state="translated">Tengan cuidado:¡Esto puede llevar a un código no optimizado y a una ejecución lenta! La mayoría de los problemas se resuelven más eficientemente usando un iterador o una conversión a una secuencia de Rune.</target>
        </trans-unit>
        <trans-unit id="07e70f2fb17a35e7addfb3cce97a4c40deb42dbf" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*&lt;/em&gt; operator for an integer.</source>
          <target state="translated">Operador binario &lt;em&gt;*&lt;/em&gt; para un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="b4d78a434e47f392f05a75db91b17acd6fe4fa07" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">Operador binario &lt;em&gt;*&lt;/em&gt; para enteros sin signo.</target>
        </trans-unit>
        <trans-unit id="26698f4bdcaf441cc8334749d82e3e3d352fb191" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*=&lt;/em&gt; operator for ordinals</source>
          <target state="translated">Binario &lt;em&gt;* =&lt;/em&gt; operador para ordinales</target>
        </trans-unit>
        <trans-unit id="330bd303262cb5101ce0efe34c05186ca99997f7" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;+&lt;/em&gt; operator for an integer.</source>
          <target state="translated">Operador binario &lt;em&gt;+&lt;/em&gt; para un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="38c5372d40da823748edf7ea2383e6eece6eff5b" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;+&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">Operador binario &lt;em&gt;+&lt;/em&gt; para enteros sin signo.</target>
        </trans-unit>
        <trans-unit id="af8d9afe7721543aea25b34b98173554127fcd0b" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;-&lt;/em&gt; operator for an integer.</source>
          <target state="translated">Binario &lt;em&gt;:&lt;/em&gt; operador para un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="8ccf951823bb2d33004b173d71cc94c3047b4785" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;-&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">Binario &lt;em&gt;:&lt;/em&gt; operador para enteros sin signo.</target>
        </trans-unit>
        <trans-unit id="560f98c3ead9f955754deb12fba064845d75b979" translate="yes" xml:space="preserve">
          <source>Binary operators whose first character is &lt;code&gt;^&lt;/code&gt; are right-associative, all other binary operators are left-associative.</source>
          <target state="translated">Los operadores binarios cuyo primer car&amp;aacute;cter es &lt;code&gt;^&lt;/code&gt; son asociativos por la derecha, todos los dem&amp;aacute;s operadores binarios son asociativos por la izquierda.</target>
        </trans-unit>
        <trans-unit id="360d45a25b59088bfa51b40dd2c0ffd7a2333f6c" translate="yes" xml:space="preserve">
          <source>Binary. Outputs the number in base 2.</source>
          <target state="translated">Binario.Emite el número en la base 2.</target>
        </trans-unit>
        <trans-unit id="d087993ff800b452527c7966565ad3f6a2e4d837" translate="yes" xml:space="preserve">
          <source>Bind matching to some action</source>
          <target state="translated">La unión de la pareja con alguna acción</target>
        </trans-unit>
        <trans-unit id="af1a43872e0146a37b3fc6fec03f088b6f0c7d84" translate="yes" xml:space="preserve">
          <source>Bind statement</source>
          <target state="translated">Declaración vinculante</target>
        </trans-unit>
        <trans-unit id="d59366ada08751ecfdb863b4a3641304d02f31a6" translate="yes" xml:space="preserve">
          <source>BindSym</source>
          <target state="translated">BindSym</target>
        </trans-unit>
        <trans-unit id="e09df968e0a484a9efbeb94427ec16a9be185b7d" translate="yes" xml:space="preserve">
          <source>Binds &lt;code&gt;address&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt; to the socket.</source>
          <target state="translated">Vincula la &lt;code&gt;address&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; al socket.</target>
        </trans-unit>
        <trans-unit id="659ea289b78cfbcca53efa111220718b2e750524" translate="yes" xml:space="preserve">
          <source>Binds Unix socket to &lt;em&gt;path&lt;/em&gt;. This only works on Unix-style systems: Mac OS X, BSD and Linux</source>
          <target state="translated">Vincula el socket Unix a la &lt;em&gt;ruta&lt;/em&gt; . Esto solo funciona en sistemas de estilo Unix: Mac OS X, BSD y Linux</target>
        </trans-unit>
        <trans-unit id="8e8aaeecce239b0f06469ead101c23881541a5d5" translate="yes" xml:space="preserve">
          <source>Bits for which fields are set</source>
          <target state="translated">Los bits para los cuales se establecen los campos</target>
        </trans-unit>
        <trans-unit id="cd3e66f022e12b57b1f5fe62492942f67ba04841" translate="yes" xml:space="preserve">
          <source>Bitsize pragma</source>
          <target state="translated">Pragmatismo de tamaño reducido</target>
        </trans-unit>
        <trans-unit id="234ac99e0a5dfd13079331f5a645966c4b4a76a7" translate="yes" xml:space="preserve">
          <source>Blank lines are skipped.</source>
          <target state="translated">Las líneas en blanco se saltan.</target>
        </trans-unit>
        <trans-unit id="40f4277d9e2e9642b7c7082b91e613d62eab845f" translate="yes" xml:space="preserve">
          <source>Block device.</source>
          <target state="translated">Dispositivo de bloqueo.</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">Bloquear el alcance</target>
        </trans-unit>
        <trans-unit id="d900d959e6c700afd03ab9e7a37649c54ebba876" translate="yes" xml:space="preserve">
          <source>Block statement</source>
          <target state="translated">Declaración de bloqueo</target>
        </trans-unit>
        <trans-unit id="f5b504d04d5a39d2d24b7595634cf4c7ea12b1e0" translate="yes" xml:space="preserve">
          <source>Blocks until a connection is being made from a client. When a connection is made sets &lt;code&gt;client&lt;/code&gt; to the client socket and &lt;code&gt;address&lt;/code&gt; to the address of the connecting client. If &lt;code&gt;server&lt;/code&gt; is non-blocking then this function returns immediately, and if there are no connections queued the returned socket will be &lt;code&gt;InvalidSocket&lt;/code&gt;. This function will raise EOS if an error occurs.</source>
          <target state="translated">Bloquea hasta que se establece una conexi&amp;oacute;n desde un cliente. Cuando se establece una conexi&amp;oacute;n, establece el &lt;code&gt;client&lt;/code&gt; e en el conector del cliente y la &lt;code&gt;address&lt;/code&gt; en la direcci&amp;oacute;n del cliente que se conecta. Si el &lt;code&gt;server&lt;/code&gt; no es bloqueante, esta funci&amp;oacute;n regresa inmediatamente, y si no hay conexiones en cola, el socket devuelto ser&amp;aacute; &lt;code&gt;InvalidSocket&lt;/code&gt; . Esta funci&amp;oacute;n aumentar&amp;aacute; EOS si ocurre un error.</target>
        </trans-unit>
        <trans-unit id="6d6f90513642da6009f2dec4733272a1e46e96f3" translate="yes" xml:space="preserve">
          <source>Blocks until a connection is being made from a client. When a connection is made sets &lt;code&gt;client&lt;/code&gt; to the client socket and &lt;code&gt;address&lt;/code&gt; to the address of the connecting client. This function will raise EOS if an error occurs.</source>
          <target state="translated">Bloquea hasta que se establece una conexi&amp;oacute;n desde un cliente. Cuando se establece una conexi&amp;oacute;n, establece el &lt;code&gt;client&lt;/code&gt; e en el conector del cliente y la &lt;code&gt;address&lt;/code&gt; en la direcci&amp;oacute;n del cliente que se conecta. Esta funci&amp;oacute;n aumentar&amp;aacute; EOS si ocurre un error.</target>
        </trans-unit>
        <trans-unit id="70bf1baa003257ad55f9ad962d42ef3e987cd33e" translate="yes" xml:space="preserve">
          <source>Boolean &lt;code&gt;and&lt;/code&gt;; returns true iff &lt;code&gt;x == y == true&lt;/code&gt;. Evaluation is lazy: if &lt;code&gt;x&lt;/code&gt; is false, &lt;code&gt;y&lt;/code&gt; will not even be evaluated.</source>
          <target state="translated">Booleano &lt;code&gt;and&lt;/code&gt; ; devuelve verdadero sif &lt;code&gt;x == y == true&lt;/code&gt; . La evaluaci&amp;oacute;n es perezosa: si &lt;code&gt;x&lt;/code&gt; es falso, &lt;code&gt;y&lt;/code&gt; ni siquiera se evaluar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="8a3c45029fde7152ef764416ecfd26148ba5b9ad" translate="yes" xml:space="preserve">
          <source>Boolean &lt;code&gt;or&lt;/code&gt;; returns true iff &lt;code&gt;not (not x and not y)&lt;/code&gt;. Evaluation is lazy: if &lt;code&gt;x&lt;/code&gt; is true, &lt;code&gt;y&lt;/code&gt; will not even be evaluated.</source>
          <target state="translated">Booleano &lt;code&gt;or&lt;/code&gt; ; devuelve verdadero si &lt;code&gt;not (not x and not y)&lt;/code&gt; . La evaluaci&amp;oacute;n es perezosa: si &lt;code&gt;x&lt;/code&gt; es verdadera, &lt;code&gt;y&lt;/code&gt; ni siquiera se evaluar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="02bbffdde9a8f3f92162c50254a83eda75717823" translate="yes" xml:space="preserve">
          <source>Boolean &lt;em&gt;exclusive or&lt;/em&gt;; returns true iff &lt;code&gt;x != y&lt;/code&gt;.</source>
          <target state="translated">Booleano &lt;em&gt;exclusivo o&lt;/em&gt; ; devuelve verdadero sif &lt;code&gt;x != y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4f6a62c295e099a6e5cc6ca486fd23a80fe9b9d" translate="yes" xml:space="preserve">
          <source>Boolean flag that indicates if the system supports nanosecond time resolution in the fields of &lt;code&gt;Stat&lt;/code&gt;. Note that the nanosecond based fields (&lt;code&gt;Stat.st_atim&lt;/code&gt;, &lt;code&gt;Stat.st_mtim&lt;/code&gt; and &lt;code&gt;Stat.st_ctim&lt;/code&gt;) can be accessed without checking this flag, because this module defines fallback procs when they are not available.</source>
          <target state="translated">Bandera booleana que indica si el sistema admite resoluci&amp;oacute;n de tiempo de nanosegundos en los campos de &lt;code&gt;Stat&lt;/code&gt; . Tenga en cuenta que se puede acceder a los campos basados ​​en nanosegundos ( &lt;code&gt;Stat.st_atim&lt;/code&gt; , &lt;code&gt;Stat.st_mtim&lt;/code&gt; y &lt;code&gt;Stat.st_ctim&lt;/code&gt; ) sin marcar este indicador, porque este m&amp;oacute;dulo define procesos de respaldo cuando no est&amp;aacute;n disponibles.</target>
        </trans-unit>
        <trans-unit id="20ba3c881998fa4098ce5ba4cafd77d368e565ad" translate="yes" xml:space="preserve">
          <source>Boolean not; returns true iff &lt;code&gt;x == false&lt;/code&gt;.</source>
          <target state="translated">Booleano no; devuelve verdadero sif &lt;code&gt;x == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cad44960020fa76bebce8ad95937acc2bd15d81f" translate="yes" xml:space="preserve">
          <source>Boolean socket options.</source>
          <target state="translated">Opciones de enchufes booleanos.</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">Tipo booleano</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="0add89edb9f4ac0882e5974a2ed406404a13002f" translate="yes" xml:space="preserve">
          <source>Bootstrapping the compiler</source>
          <target state="translated">Bootstrapping el compilador</target>
        </trans-unit>
        <trans-unit id="bd4dea3d9dc65cab9bb66d4cc6a6ce01c2e41ab8" translate="yes" xml:space="preserve">
          <source>Both parts have the same sign as &lt;em&gt;x&lt;/em&gt;. Analogous to the &lt;em&gt;modf&lt;/em&gt; function in C.</source>
          <target state="translated">Ambas partes tienen el mismo signo que &lt;em&gt;x&lt;/em&gt; . An&amp;aacute;loga a la funci&amp;oacute;n &lt;em&gt;modf&lt;/em&gt; en C.</target>
        </trans-unit>
        <trans-unit id="35a56c974fb1825347f0fe1529b19d7c99f2d402" translate="yes" xml:space="preserve">
          <source>Both the multi method and the type converter problems are solved by the AST replay implementation.</source>
          <target state="translated">Tanto los problemas del método múltiple como los del convertidor de tipos se resuelven con la implementación de la repetición de la AST.</target>
        </trans-unit>
        <trans-unit id="19ab36d21e3e2bca80b33ef2b7f048e8235fb8c0" translate="yes" xml:space="preserve">
          <source>Brackets</source>
          <target state="translated">Brackets</target>
        </trans-unit>
        <trans-unit id="c53284da9f760cfe1b6f6b9f75108f3e5f34245e" translate="yes" xml:space="preserve">
          <source>Brackets are used as the array constructor.</source>
          <target state="translated">Los soportes se utilizan como constructor de la matriz.</target>
        </trans-unit>
        <trans-unit id="2f1e60578f3cd76d5527fed043c9442139cd2cd3" translate="yes" xml:space="preserve">
          <source>Break statement</source>
          <target state="translated">Declaración de ruptura</target>
        </trans-unit>
        <trans-unit id="d1d87f5d380c5544ae2b99408021a09200064c57" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop may cause a driver error for subsequenct queries</source>
          <target state="translated">Romper el iterador fastRows()durante un bucle puede causar un error en el controlador para consultas posteriores</target>
        </trans-unit>
        <trans-unit id="ec4a222af9465c04b4a8d052175ff58043442831" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop will cause the next database query to raise a DbError exception &lt;code&gt;unable to close due to ...&lt;/code&gt;.</source>
          <target state="translated">Rompiendo las fastRows () iterador en un bucle har&amp;aacute; que la pr&amp;oacute;xima consulta de base de datos para elevar una excepci&amp;oacute;n DBERROR &lt;code&gt;unable to close due to ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c7a0ef890af1a51c57cdb3dba04d6c6a9bbd34e" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop will cause the next database query to raise an [EDb] exception &lt;code&gt;Commands out of sync&lt;/code&gt;.</source>
          <target state="translated">Romper el iterador fastRows () durante un bucle har&amp;aacute; que la siguiente consulta de la base de datos genere una excepci&amp;oacute;n [EDb]. Los &lt;code&gt;Commands out of sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9c84b3329de1f9c1a856698aa2ec5cff34e5ad" translate="yes" xml:space="preserve">
          <source>Breaks &lt;em&gt;x&lt;/em&gt; into an integral and a fractional part.</source>
          <target state="translated">Divide &lt;em&gt;x&lt;/em&gt; en una parte integral y una fraccionaria.</target>
        </trans-unit>
        <trans-unit id="8b6724e85f24d7713d447fc9d1ecbadafa7df149" translate="yes" xml:space="preserve">
          <source>Breaks this node into two nodes at the specified offset, keeping both in the tree as siblings.</source>
          <target state="translated">Rompe este nodo en dos nodos con el desfase especificado,manteniendo a ambos en el árbol como hermanos.</target>
        </trans-unit>
        <trans-unit id="425b1ac3be0544ab3f6c956fa14370b9d4fb8322" translate="yes" xml:space="preserve">
          <source>Build and test examples:</source>
          <target state="translated">Construir y probar ejemplos:</target>
        </trans-unit>
        <trans-unit id="6239081298122df79f8acd6439e80ca8b6b91469" translate="yes" xml:space="preserve">
          <source>Building your first macro</source>
          <target state="translated">Construyendo su primera macro</target>
        </trans-unit>
        <trans-unit id="646a6e4f96059c15c08aa818c66b65c410dfb9b2" translate="yes" xml:space="preserve">
          <source>Built-in macro for a longer expression.</source>
          <target state="translated">Macro incorporado para una expresión más larga.</target>
        </trans-unit>
        <trans-unit id="4d613da9be22e4083b43024dca2bbeaca3d83302" translate="yes" xml:space="preserve">
          <source>Built-in macros</source>
          <target state="translated">Macros incorporadas</target>
        </trans-unit>
        <trans-unit id="b5a84b589b9501cdc3df0931004c7cc42b59cde3" translate="yes" xml:space="preserve">
          <source>Builtin 'addr' operator for taking the address of a memory location. Cannot be overloaded.</source>
          <target state="translated">Operador &quot;addr&quot; incorporado para tomar la dirección de una ubicación de memoria.No puede ser sobrecargado.</target>
        </trans-unit>
        <trans-unit id="c463568500df5b37582c13d23e61bcb20c8accaa" translate="yes" xml:space="preserve">
          <source>Builtin 'addr' operator for taking the address of a memory location. This works even for &lt;code&gt;let&lt;/code&gt; variables or parameters for better interop with C and so it is considered even more unsafe than the ordinary &lt;code&gt;addr&lt;/code&gt;. When you use it to write a wrapper for a C library, you should always check that the original library does never write to data behind the pointer that is returned from this procedure. Cannot be overloaded.</source>
          <target state="translated">Operador 'addr' incorporado para tomar la direcci&amp;oacute;n de una ubicaci&amp;oacute;n de memoria. Esto funciona incluso para &lt;code&gt;let&lt;/code&gt; variables o par&amp;aacute;metros para una mejor interoperabilidad con C y, por lo tanto, se considera incluso m&amp;aacute;s inseguro que el &lt;code&gt;addr&lt;/code&gt; ordinario . Cuando lo usa para escribir un contenedor para una biblioteca C, siempre debe verificar que la biblioteca original nunca escriba en los datos detr&amp;aacute;s del puntero que se devuelve desde este procedimiento. No se puede sobrecargar.</target>
        </trans-unit>
        <trans-unit id="f8ca99ea406ea54b032b966a06afdbf917b785d6" translate="yes" xml:space="preserve">
          <source>But a &lt;code&gt;bind&lt;/code&gt; is rarely useful because symbol binding from the definition scope is the default.</source>
          <target state="translated">Sin embargo, un &lt;code&gt;bind&lt;/code&gt; rara vez es &amp;uacute;til porque la uni&amp;oacute;n del &amp;aacute;mbito definici&amp;oacute;n de s&amp;iacute;mbolo es el valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="f3a68bc3de013b49eccd2fd19fb51ef8acfea012" translate="yes" xml:space="preserve">
          <source>But it seems all this boilerplate code needs to be repeated for the &lt;code&gt;Euro&lt;/code&gt; currency. This can be solved with &lt;a href=&quot;#templates&quot;&gt;templates&lt;/a&gt;.</source>
          <target state="translated">Pero parece que todo este c&amp;oacute;digo repetitivo debe repetirse para la moneda &lt;code&gt;Euro&lt;/code&gt; . Esto se puede solucionar con &lt;a href=&quot;#templates&quot;&gt;plantillas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b442f85caf3d7cde4cea2e5e9eb91a280936441" translate="yes" xml:space="preserve">
          <source>But one has to watch out because other overloads might trigger the argument's resolution:</source>
          <target state="translated">Pero hay que tener cuidado porque otras sobrecargas podrían desencadenar la resolución del argumento:</target>
        </trans-unit>
        <trans-unit id="c53e0632274551f5aa1f6a36373db50475b33d38" translate="yes" xml:space="preserve">
          <source>But the global symbol can properly be captured by a &lt;code&gt;bind&lt;/code&gt; statement:</source>
          <target state="translated">Pero el s&amp;iacute;mbolo global se puede capturar correctamente mediante una declaraci&amp;oacute;n de &lt;code&gt;bind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="527742dcc91f3b4388a5222a890c0118d3a5e0d7" translate="yes" xml:space="preserve">
          <source>But this rule does not apply to procedures or iterators. Here the overloading rules apply:</source>
          <target state="translated">Pero esta regla no se aplica a los procedimientos o a los iteradores.Aquí se aplican las reglas de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="9250d320cadcddd0ef262bd8559df915bc7e0bc6" translate="yes" xml:space="preserve">
          <source>By default Nim's &lt;code&gt;dynlib&lt;/code&gt; pragma causes the compiler to generate &lt;code&gt;GetProcAddress&lt;/code&gt; (or their Unix counterparts) calls to bind to a DLL. With the &lt;code&gt;dynlibOverride&lt;/code&gt; command line switch this can be prevented and then via &lt;code&gt;--passL&lt;/code&gt; the static library can be linked against. For instance, to link statically against Lua this command might work on Linux:</source>
          <target state="translated">Por defecto, &lt;code&gt;dynlib&lt;/code&gt; pragma de Nim hace que el compilador genere &lt;code&gt;GetProcAddress&lt;/code&gt; (o sus contrapartes de Unix) para unirse a una DLL. Con el &lt;code&gt;dynlibOverride&lt;/code&gt; l&amp;iacute;nea de comando dynlibOverride, esto se puede evitar y luego, a trav&amp;eacute;s de &lt;code&gt;--passL&lt;/code&gt; , se puede vincular la biblioteca est&amp;aacute;tica. Por ejemplo, para vincular est&amp;aacute;ticamente con Lua, este comando podr&amp;iacute;a funcionar en Linux:</target>
        </trans-unit>
        <trans-unit id="d02d9c4acff9cf60b68f15e507f7e43cd5939742" translate="yes" xml:space="preserve">
          <source>By default a debug version is created, passing this option will force a release build, which is much faster and should be preferred unless you are debugging the compiler.</source>
          <target state="translated">Por defecto se crea una versión de depuración,al pasar esta opción se forzará una compilación de liberación,que es mucho más rápida y debería ser preferible a menos que esté depurando el compilador.</target>
        </trans-unit>
        <trans-unit id="48b684a5792df5c5364095950ec05af76390e113" translate="yes" xml:space="preserve">
          <source>By default c2nim marks every top level identifier (proc name, variable, etc.) as exported (the export marker is &lt;code&gt;*&lt;/code&gt; in Nim). With the &lt;code&gt;#private&lt;/code&gt; directive identifiers can be marked as private so that the resulting Nim module does not export them. The &lt;code&gt;#private&lt;/code&gt; directive takes a PEG pattern:</source>
          <target state="translated">Por defecto, c2nim marca cada identificador de nivel superior (nombre de proceso, variable, etc.) como exportado (el marcador de exportaci&amp;oacute;n es &lt;code&gt;*&lt;/code&gt; en Nim). Con la directiva &lt;code&gt;#private&lt;/code&gt; , los identificadores se pueden marcar como privados para que el m&amp;oacute;dulo Nim resultante no los exporte. La directiva &lt;code&gt;#private&lt;/code&gt; toma un patr&amp;oacute;n PEG:</target>
        </trans-unit>
        <trans-unit id="0de21675c01f240e6592367c51b6d906f03a3d78" translate="yes" xml:space="preserve">
          <source>By default the Nim compiler generates a large amount of runtime checks aiming for your debugging pleasure. With &lt;code&gt;-d:release&lt;/code&gt; these checks are &lt;a href=&quot;nimc#compiler-usage-compile-time-symbols&quot;&gt;turned off and optimizations are turned on&lt;/a&gt;.</source>
          <target state="translated">De forma predeterminada, el compilador de Nim genera una gran cantidad de comprobaciones en tiempo de ejecuci&amp;oacute;n que buscan su placer de depuraci&amp;oacute;n. Con &lt;code&gt;-d:release&lt;/code&gt; , estas comprobaciones se &lt;a href=&quot;nimc#compiler-usage-compile-time-symbols&quot;&gt;desactivan y las optimizaciones se activan&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53714c20b023fb0e9acbdf38f380565e04810da2" translate="yes" xml:space="preserve">
          <source>By default the documentation will be built in parallel using the number of available CPU cores. If any documentation build sub commands fail, they will be rerun in serial fashion so that meaninful error output can be gathered for inspection. The &lt;code&gt;--parallelBuild:n&lt;/code&gt; switch or configuration option can be used to force a specific number of parallel jobs or run everything serially from the start (&lt;code&gt;n == 1&lt;/code&gt;).</source>
          <target state="translated">De forma predeterminada, la documentaci&amp;oacute;n se crear&amp;aacute; en paralelo utilizando la cantidad de n&amp;uacute;cleos de CPU disponibles. Si alguno de los subcomandos de creaci&amp;oacute;n de documentaci&amp;oacute;n falla, se volver&amp;aacute; a ejecutar en serie para poder recopilar la salida de error significativo para su inspecci&amp;oacute;n. El conmutador o la opci&amp;oacute;n de configuraci&amp;oacute;n &lt;code&gt;--parallelBuild:n&lt;/code&gt; se puede usar para forzar un n&amp;uacute;mero espec&amp;iacute;fico de trabajos en paralelo o ejecutar todo en serie desde el principio ( &lt;code&gt;n == 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a12f023f59a39b1f378be96457f00762035b5df" translate="yes" xml:space="preserve">
          <source>By default, c2nim translates an &lt;code&gt;#include&lt;/code&gt; that is not followed by &lt;code&gt;&amp;lt;&lt;/code&gt; (like in &lt;code&gt;#include &amp;lt;stdlib&amp;gt;&lt;/code&gt;) to a Nim &lt;code&gt;import&lt;/code&gt; statement. This directive tells c2nim to just skip any &lt;code&gt;#include&lt;/code&gt;.</source>
          <target state="translated">Por defecto, c2nim traduce un &lt;code&gt;#include&lt;/code&gt; que no va seguido de &lt;code&gt;&amp;lt;&lt;/code&gt; (como en &lt;code&gt;#include &amp;lt;stdlib&amp;gt;&lt;/code&gt; ) a una declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n de Nim . Esta directiva le dice a c2nim que simplemente omita cualquier &lt;code&gt;#include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fae71acbfd2891a1634971f65ec8cdeff58500b" translate="yes" xml:space="preserve">
          <source>By default, during overload resolution each named type class will bind to exactly one concrete type. We call such type classes &lt;span id=&quot;bind-once_1&quot;&gt;bind once&lt;/span&gt; types. Here is an example taken directly from the system module to illustrate this:</source>
          <target state="translated">De forma predeterminada, durante la resoluci&amp;oacute;n de sobrecarga, cada clase de tipo con nombre se unir&amp;aacute; exactamente a un tipo concreto. A este tipo de clases las llamamos tipos de &lt;span id=&quot;bind-once_1&quot;&gt;uni&amp;oacute;n &amp;uacute;nica&lt;/span&gt; . Aqu&amp;iacute; hay un ejemplo tomado directamente del m&amp;oacute;dulo del sistema para ilustrar esto:</target>
        </trans-unit>
        <trans-unit id="73cb09bc05777230e6e5fe1e7143a2c142ee2d0d" translate="yes" xml:space="preserve">
          <source>By default, the compiler will report the matching errors in concepts only when no other overload can be selected and a normal compilation error is produced. When you need to understand why the compiler is not matching a particular concept and, as a result, a wrong overload is selected, you can apply the &lt;code&gt;explain&lt;/code&gt; pragma to either the concept body or a particular call-site.</source>
          <target state="translated">De forma predeterminada, el compilador informar&amp;aacute; los errores de coincidencia en los conceptos solo cuando no se pueda seleccionar ninguna otra sobrecarga y se produzca un error de compilaci&amp;oacute;n normal. Cuando necesite comprender por qu&amp;eacute; el compilador no coincide con un concepto en particular y, como resultado, se selecciona una sobrecarga incorrecta, puede aplicar el pragma de &lt;code&gt;explain&lt;/code&gt; al cuerpo del concepto o al sitio de llamada en particular.</target>
        </trans-unit>
        <trans-unit id="80f5e65dfa0cd584e698223d82de76d94317241e" translate="yes" xml:space="preserve">
          <source>By default, uses the IEC/ISO standard binary prefixes, so 1024 will be formatted as 1KiB. Set prefix to &lt;em&gt;bpColloquial&lt;/em&gt; to use the colloquial names from the SI standard (e.g. k for 1000 being reused as 1024).</source>
          <target state="translated">De forma predeterminada, utiliza los prefijos binarios est&amp;aacute;ndar IEC / ISO, por lo que 1024 se formatear&amp;aacute; como 1 KB. Establezca el prefijo en &lt;em&gt;bpColloquial&lt;/em&gt; para usar los nombres coloquiales del est&amp;aacute;ndar SI (por ejemplo, k para 1000 se reutiliza como 1024).</target>
        </trans-unit>
        <trans-unit id="bc61bfc923f0134f76f08848fd47d85a5225ef86" translate="yes" xml:space="preserve">
          <source>Bycopy pragma</source>
          <target state="translated">El pragmatismo de la Bicopia</target>
        </trans-unit>
        <trans-unit id="dc786d2e8550e65dba6f478b2c981035a039ff49" translate="yes" xml:space="preserve">
          <source>Byref pragma</source>
          <target state="translated">El pragmatismo de Byref</target>
        </trans-unit>
        <trans-unit id="e373e36949fb915e82bd278056c90511b6ce4a56" translate="yes" xml:space="preserve">
          <source>C implementation: &lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&lt;/a&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n de C: &lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbf459b1966378eb6b198b4db1484574fc622a26" translate="yes" xml:space="preserve">
          <source>C invocation example</source>
          <target state="translated">Ejemplo de invocación C</target>
        </trans-unit>
        <trans-unit id="cef9b186930ae3fbcdf84f2ca1df6e923c10face" translate="yes" xml:space="preserve">
          <source>C to Nim source converter. Translates C header files to Nim.</source>
          <target state="translated">Convertidor de fuente C a Nim.Traduce los archivos de encabezado C a Nim.</target>
        </trans-unit>
        <trans-unit id="aa0b476ef445e23e653ff55250eadd2a609d86ee" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;,&lt;/code&gt; operator (comma operator) is not supported.</source>
          <target state="translated">C &lt;code&gt;,&lt;/code&gt; operador (operador de coma) no es compatible.</target>
        </trans-unit>
        <trans-unit id="6e567e8ea65384f4c7990dd6fd015e5dc179fcdc" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;union&lt;/code&gt; are translated to Nim's objects and only the first field is included in the object type. This way there is a high chance that it is binary compatible to the union.</source>
          <target state="translated">La &lt;code&gt;union&lt;/code&gt; de C se traduce a los objetos de Nim y solo el primer campo se incluye en el tipo de objeto. De esta forma, existe una alta probabilidad de que sea compatible binariamente con la uni&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8f522347c60c0922b17da1143403e53d860a58d2" translate="yes" xml:space="preserve">
          <source>C2nim</source>
          <target state="translated">C2nim</target>
        </trans-unit>
        <trans-unit id="f30d6a6fe6e12777a78cd63942d1e0466d7744a4" translate="yes" xml:space="preserve">
          <source>CANNOT BE int64 BECAUSE OF ALIGNMENT</source>
          <target state="translated">No puede ser int64 por causa de la alineación</target>
        </trans-unit>
        <trans-unit id="c5a976de7b5231fa616fbeac8a2d2805c1e84ee2" translate="yes" xml:space="preserve">
          <source>CC</source>
          <target state="translated">CC</target>
        </trans-unit>
        <trans-unit id="dfa0a6adb0d6b924e9559526a04fdb494693340f" translate="yes" xml:space="preserve">
          <source>Calculate the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">Calcule el arco tangente de &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5de1a650a2f08daab441e97db705f2a8290b44f" translate="yes" xml:space="preserve">
          <source>Calculate the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;. &lt;em&gt;atan2&lt;/em&gt; returns the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;; it produces correct results even when the resulting angle is near pi/2 or -pi/2 (&lt;em&gt;x&lt;/em&gt; near 0).</source>
          <target state="translated">Calcule el arco tangente de &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt; . &lt;em&gt;atan2&lt;/em&gt; devuelve el arco tangente de &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt; ; produce resultados correctos incluso cuando el &amp;aacute;ngulo resultante est&amp;aacute; cerca de pi / 2 o -pi / 2 ( &lt;em&gt;x&lt;/em&gt; cerca de 0).</target>
        </trans-unit>
        <trans-unit id="56ec6774caee72173cca3d600df6df4ad5cea2f4" translate="yes" xml:space="preserve">
          <source>Calculate the bit parity in integer. If number of 1-bit is odd parity is 1, otherwise 0.</source>
          <target state="translated">Calcula la paridad de bits en entero.Si el número de 1-bit es paridad impar es 1,en caso contrario 0.</target>
        </trans-unit>
        <trans-unit id="24670fb674da2394dd2a0f4959fd3a294516adae" translate="yes" xml:space="preserve">
          <source>Calculate the reciprocal of &lt;em&gt;x&lt;/em&gt;. (1/x)</source>
          <target state="translated">Calcula el rec&amp;iacute;proco de &lt;em&gt;x&lt;/em&gt; . (1 / x)</target>
        </trans-unit>
        <trans-unit id="932f4eb5f8468f8594b47ae0aae880a0c60dbe3e" translate="yes" xml:space="preserve">
          <source>Calculates the best rational numerator and denominator that approximates to &lt;em&gt;x&lt;/em&gt;, where the denominator is smaller than &lt;em&gt;n&lt;/em&gt; (default is the largest possible int to give maximum resolution).</source>
          <target state="translated">Calcula el mejor numerador y denominador racional que se aproxima &lt;em&gt;ax&lt;/em&gt; , donde el denominador es menor que &lt;em&gt;n&lt;/em&gt; (el valor predeterminado es el mayor int posible para dar la m&amp;aacute;xima resoluci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="3010c6d2f4fa47d3ebb08435fd6265b2c82ae435" translate="yes" xml:space="preserve">
          <source>Calculates the next lexicographic permutation, directly modifying &lt;code&gt;x&lt;/code&gt;. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.</source>
          <target state="translated">Calcula la siguiente permutaci&amp;oacute;n lexicogr&amp;aacute;fica, modificando directamente &lt;code&gt;x&lt;/code&gt; . El resultado es si ocurri&amp;oacute; una permutaci&amp;oacute;n; de lo contrario, hemos alcanzado la &amp;uacute;ltima permutaci&amp;oacute;n ordenada.</target>
        </trans-unit>
        <trans-unit id="926f466377c398ffb795b1c416217100d99d20d7" translate="yes" xml:space="preserve">
          <source>Calculates the previous lexicographic permutation, directly modifying &lt;code&gt;x&lt;/code&gt;. The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.</source>
          <target state="translated">Calcula la permutaci&amp;oacute;n lexicogr&amp;aacute;fica anterior, modificando directamente &lt;code&gt;x&lt;/code&gt; . El resultado es si ocurri&amp;oacute; una permutaci&amp;oacute;n; de lo contrario, hemos alcanzado la permutaci&amp;oacute;n en primer orden.</target>
        </trans-unit>
        <trans-unit id="f5b27c0795360d24a64c7b68bf2cc3b1338d3199" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;cbproc&lt;/code&gt; &quot;soon&quot;.</source>
          <target state="translated">Llame a &lt;code&gt;cbproc&lt;/code&gt; &quot;pronto&quot;.</target>
        </trans-unit>
        <trans-unit id="3ced0e76c83f56c5d573ca3272434ebf912be391" translate="yes" xml:space="preserve">
          <source>Call this if you scanned over 'L' in the buffer; it returns the the position to continue the scanning from. &lt;em&gt;pos&lt;/em&gt; must be the position of the 'L'.</source>
          <target state="translated">Ll&amp;aacute;melo si escane&amp;oacute; 'L' en el b&amp;uacute;fer; devuelve la posici&amp;oacute;n desde la que continuar el escaneo. &lt;em&gt;pos&lt;/em&gt; debe ser la posici&amp;oacute;n de la 'L'.</target>
        </trans-unit>
        <trans-unit id="77d5fa0614be1a0c2dc98ca10137b9644cb75099" translate="yes" xml:space="preserve">
          <source>Call this if you scanned over 'c' in the buffer; it returns the the position to continue the scanning from. &lt;em&gt;pos&lt;/em&gt; must be the position of the 'c'.</source>
          <target state="translated">Ll&amp;aacute;melo si escane&amp;oacute; 'c' en el b&amp;uacute;fer; devuelve la posici&amp;oacute;n desde la que continuar el escaneo. &lt;em&gt;pos&lt;/em&gt; debe ser la posici&amp;oacute;n de la 'c'.</target>
        </trans-unit>
        <trans-unit id="1ef18f3ccda6fa4b7049be2ee5f84665bbb0ce03" translate="yes" xml:space="preserve">
          <source>Call user defined proc &lt;code&gt;foo&lt;/code&gt; to &lt;strong&gt;skip&lt;/strong&gt; some optional parts in the input string. See below for more details.</source>
          <target state="translated">Llame a proc &lt;code&gt;foo&lt;/code&gt; definido por el usuario para &lt;strong&gt;omitir&lt;/strong&gt; algunas partes opcionales en la cadena de entrada. Consulte a continuaci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="02241663160dcc2a31527f886c0c708b65f901d7" translate="yes" xml:space="preserve">
          <source>Call with &lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">Llamar con &lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da6c999c007bfe15edd1f0f081d6f9072a370ddb" translate="yes" xml:space="preserve">
          <source>Call with named arguments</source>
          <target state="translated">Llamada con argumentos nombrados</target>
        </trans-unit>
        <trans-unit id="4f1be644dd81e7d1af3decb76997fc722787c242" translate="yes" xml:space="preserve">
          <source>Call with raw string literal</source>
          <target state="translated">Llamada con cuerda cruda literal</target>
        </trans-unit>
        <trans-unit id="bfcb7c395fc4a2662bfef50abfeba239833faf54" translate="yes" xml:space="preserve">
          <source>Callable type</source>
          <target state="translated">Tipo de llamada</target>
        </trans-unit>
        <trans-unit id="d6a9bd6a90d6905593fcbe3587fd9fc40af85f67" translate="yes" xml:space="preserve">
          <source>Calling a procedure can be done in many different ways:</source>
          <target state="translated">Llamar a un procedimiento puede hacerse de muchas maneras diferentes:</target>
        </trans-unit>
        <trans-unit id="f026609c17e6af082dd6bc47161a40d8bcada7a1" translate="yes" xml:space="preserve">
          <source>Calling ordinary Nim procs inside the macro is possible:</source>
          <target state="translated">Llamar a los procesos Nim ordinarios dentro de la macro es posible:</target>
        </trans-unit>
        <trans-unit id="a6642199094bd906db4fb13f403e5d9864fe5992" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;styledWrite&lt;/code&gt; and appends a newline at the end.</source>
          <target state="translated">Llama a &lt;code&gt;styledWrite&lt;/code&gt; y agrega una nueva l&amp;iacute;nea al final.</target>
        </trans-unit>
        <trans-unit id="7e723e08242f8573f5209a7864aabe4641ef9035" translate="yes" xml:space="preserve">
          <source>Calls/expressions</source>
          <target state="translated">Calls/expressions</target>
        </trans-unit>
        <trans-unit id="cfe2ed24a31b4d3b922301946dba17cf4d7769e4" translate="yes" xml:space="preserve">
          <source>Can a &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; proc be written that supports this loop? Lets try:</source>
          <target state="translated">&amp;iquest; &lt;a href=&quot;system#countup&quot;&gt;Se&lt;/a&gt; puede escribir un proceso de conteo ascendente que admita este bucle? Intentemos:</target>
        </trans-unit>
        <trans-unit id="311200cff08c958701bc83ae616b08935d475e3d" translate="yes" xml:space="preserve">
          <source>Can be used to convert a pointer type to an option type. It converts &lt;code&gt;nil&lt;/code&gt; to the none-option.</source>
          <target state="translated">Se puede utilizar para convertir un tipo de puntero en un tipo de opci&amp;oacute;n. Convierte &lt;code&gt;nil&lt;/code&gt; en la opci&amp;oacute;n none.</target>
        </trans-unit>
        <trans-unit id="73a3789c9cc42ae286b2bc07d22e73c5d6441a2b" translate="yes" xml:space="preserve">
          <source>CannotOpenFile</source>
          <target state="translated">CannotOpenFile</target>
        </trans-unit>
        <trans-unit id="a4b36f5e09cea9865cb6993e0accb43f1789f9cd" translate="yes" xml:space="preserve">
          <source>Capture: Apply expression &lt;em&gt;E&lt;/em&gt; and store the substring that matched &lt;em&gt;E&lt;/em&gt; into a &lt;em&gt;capture&lt;/em&gt; that can be accessed after the matching process.</source>
          <target state="translated">Captura: aplique la expresi&amp;oacute;n &lt;em&gt;E&lt;/em&gt; y almacene la subcadena que coincidi&amp;oacute; con &lt;em&gt;E&lt;/em&gt; en una &lt;em&gt;captura a la&lt;/em&gt; que se puede acceder despu&amp;eacute;s del proceso de comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dada321496f3f4fb22895c4b7cd0802a93ca5d72" translate="yes" xml:space="preserve">
          <source>Captured Search: Shorthand for &lt;code&gt;{(!E .)*} E&lt;/code&gt;. (Search loop for the pattern &lt;em&gt;E&lt;/em&gt;.) Everything until and exluding &lt;em&gt;E&lt;/em&gt; is captured.</source>
          <target state="translated">Buscar capturado: Abreviatura de &lt;code&gt;{(!E .)*} E&lt;/code&gt; . (Bucle de b&amp;uacute;squeda para el patr&amp;oacute;n &lt;em&gt;E.&lt;/em&gt; ) Se captura todo hasta que se captura la &lt;em&gt;E&lt;/em&gt; excluida .</target>
        </trans-unit>
        <trans-unit id="58721ba126309ca208430cd499d98df05aa97730" translate="yes" xml:space="preserve">
          <source>Card stands for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Cardinality&quot;&gt;cardinality&lt;/a&gt; of a set.</source>
          <target state="translated">La tarjeta representa la &lt;a href=&quot;http://en.wikipedia.org/wiki/Cardinality&quot;&gt;cardinalidad&lt;/a&gt; de un conjunto.</target>
        </trans-unit>
        <trans-unit id="f3a52f7d1133fe19bed724efe1bcc5b99763e6ec" translate="yes" xml:space="preserve">
          <source>Case expression</source>
          <target state="translated">Expresión del caso</target>
        </trans-unit>
        <trans-unit id="ca901f84d981e4405cbb31e5c66f958f39995d61" translate="yes" xml:space="preserve">
          <source>Case statement</source>
          <target state="translated">Declaración del caso</target>
        </trans-unit>
        <trans-unit id="67a5699f66f3a4d73b5d418a7b08b0c7350d984e" translate="yes" xml:space="preserve">
          <source>Case statement macros</source>
          <target state="translated">Macros de declaración del caso</target>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="translated">Operador de reparto</target>
        </trans-unit>
        <trans-unit id="b883b50cc0a7ec97e8c1c6aa366453f73a26413f" translate="yes" xml:space="preserve">
          <source>Change current implementation of &lt;code&gt;callSoon&lt;/code&gt;. This is normally called when dispatcher from &lt;code&gt;asyncdispatcher&lt;/code&gt; is initialized.</source>
          <target state="translated">Cambiar la implementaci&amp;oacute;n actual de &lt;code&gt;callSoon&lt;/code&gt; . Normalmente se llama cuando se inicializa el despachador de &lt;code&gt;asyncdispatcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a7e15fb6b1d9ffe60a97b971875a5fd14c3986" translate="yes" xml:space="preserve">
          <source>Change the i-th element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Cambie el i-&amp;eacute;simo elemento de &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a378d275114814e060b77abd531dd213c169f954" translate="yes" xml:space="preserve">
          <source>Changes permission of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">Cambia el permiso de la &lt;code&gt;path&lt;/code&gt; a los &lt;code&gt;permissions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bc9d87771e5da3b869e9e85828f5d8bc801b455" translate="yes" xml:space="preserve">
          <source>Changes the current directory on the remote FTP server to &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">Cambia el directorio actual en el servidor FTP remoto a &lt;code&gt;dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c055bf809996f18dce65f9e3f155faf78c41dcc7" translate="yes" xml:space="preserve">
          <source>Changes the current directory to the parent of the current directory.</source>
          <target state="translated">Cambia el directorio actual por el padre del directorio actual.</target>
        </trans-unit>
        <trans-unit id="a9e433ae359b493762f4f0a4bb510351b98a08de" translate="yes" xml:space="preserve">
          <source>Changes the file extension to &lt;em&gt;ext&lt;/em&gt;.</source>
          <target state="translated">Cambia la extensi&amp;oacute;n del archivo a &lt;em&gt;ext&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca5b74490314ec55a9cac4706975c4e89ff805e" translate="yes" xml:space="preserve">
          <source>Changing of files' permissions.</source>
          <target state="translated">Cambio de los permisos de los archivos.</target>
        </trans-unit>
        <trans-unit id="419e96b941fe3d26a3baefa01150ca56eff780d7" translate="yes" xml:space="preserve">
          <source>Channel support for threads. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">Soporte de canal para hilos. &lt;strong&gt;Nota&lt;/strong&gt; : esto es parte del m&amp;oacute;dulo del sistema. No lo importe directamente. Para activar la compatibilidad con subprocesos, debe compilar con el par&amp;aacute;metro &lt;code&gt;--threads:on&lt;/code&gt; l&amp;iacute;nea de comandos.</target>
        </trans-unit>
        <trans-unit id="0abdb5ab8a3afbc3386522492aae1bd812508530" translate="yes" xml:space="preserve">
          <source>Character class: If the character ahead appears in the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Clase de car&amp;aacute;cter: si el car&amp;aacute;cter de delante aparece en la cadena &lt;em&gt;s&lt;/em&gt; , cons&amp;uacute;melo e indica &amp;eacute;xito. De lo contrario, indique falla.</target>
        </trans-unit>
        <trans-unit id="1ce4e1be05a213a12afbc5b91825b11c73d700b6" translate="yes" xml:space="preserve">
          <source>Character device.</source>
          <target state="translated">Dispositivo de carácter.</target>
        </trans-unit>
        <trans-unit id="b86bbfa9fed7ada0a389375eb5146d27ca6ab1fb" translate="yes" xml:space="preserve">
          <source>Character literals</source>
          <target state="translated">Literales de los personajes</target>
        </trans-unit>
        <trans-unit id="7e96bdb902b32980dacb34ac72b2007caf92e425" translate="yes" xml:space="preserve">
          <source>Character literals are enclosed in single quotes &lt;code&gt;''&lt;/code&gt; and can contain the same escape sequences as strings - with one exception: the platform dependent &lt;span id=&quot;newline_2&quot;&gt;newline&lt;/span&gt; (&lt;code&gt;\p&lt;/code&gt;) is not allowed as it may be wider than one character (often it is the pair CR/LF for example). Here are the valid &lt;span id=&quot;escape-sequences_2&quot;&gt;escape sequences&lt;/span&gt; for character literals:</source>
          <target state="translated">Los literales de caracteres est&amp;aacute;n encerrados entre comillas simples &lt;code&gt;''&lt;/code&gt; y pueden contener las mismas secuencias de escape que las cadenas, con una excepci&amp;oacute;n: la &lt;span id=&quot;newline_2&quot;&gt;nueva l&amp;iacute;nea&lt;/span&gt; dependiente de la plataforma ( &lt;code&gt;\p&lt;/code&gt; ) no est&amp;aacute; permitida ya que puede ser m&amp;aacute;s ancha que un car&amp;aacute;cter (a menudo es el par CR / LF por ejemplo). Aqu&amp;iacute; est&amp;aacute;n las &lt;span id=&quot;escape-sequences_2&quot;&gt;secuencias de escape&lt;/span&gt; v&amp;aacute;lidas para caracteres literales:</target>
        </trans-unit>
        <trans-unit id="ed1a1da8d910c3e98f7e3471a4032afafec5eb29" translate="yes" xml:space="preserve">
          <source>Character range: If the character ahead is one from the range &lt;em&gt;a&lt;/em&gt; through &lt;em&gt;b&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Rango de caracteres: si el personaje de adelante es uno del rango de &lt;em&gt;a&lt;/em&gt; a &lt;em&gt;b&lt;/em&gt; , cons&amp;uacute;malo e indica &amp;eacute;xito. De lo contrario, indique falla.</target>
        </trans-unit>
        <trans-unit id="b6a6c483aae1575a0185147caca2a33f4a949438" translate="yes" xml:space="preserve">
          <source>Character type</source>
          <target state="translated">Tipo de personaje</target>
        </trans-unit>
        <trans-unit id="d50cd4e4889823f54696871b43521ee7b2cd7335" translate="yes" xml:space="preserve">
          <source>Character with decimal code &lt;em&gt;ddd&lt;/em&gt;.</source>
          <target state="translated">Car&amp;aacute;cter con c&amp;oacute;digo decimal &lt;em&gt;ddd&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="bf30516c00576762fbbb621668144d424821087b" translate="yes" xml:space="preserve">
          <source>Chars can be compared with the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. The &lt;code&gt;$&lt;/code&gt; operator converts a &lt;code&gt;char&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;. Chars cannot be mixed with integers; to get the ordinal value of a &lt;code&gt;char&lt;/code&gt; use the &lt;code&gt;ord&lt;/code&gt; proc. Converting from an integer to a &lt;code&gt;char&lt;/code&gt; is done with the &lt;code&gt;chr&lt;/code&gt; proc.</source>
          <target state="translated">Los caracteres se pueden comparar con los operadores &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; . El operador &lt;code&gt;$&lt;/code&gt; convierte un &lt;code&gt;char&lt;/code&gt; en una &lt;code&gt;string&lt;/code&gt; . Los caracteres no se pueden mezclar con n&amp;uacute;meros enteros; para obtener el valor ordinal de un &lt;code&gt;char&lt;/code&gt; , utilice el &lt;code&gt;ord&lt;/code&gt; . La conversi&amp;oacute;n de un n&amp;uacute;mero entero a un &lt;code&gt;char&lt;/code&gt; se realiza con el &lt;code&gt;chr&lt;/code&gt; proc.</target>
        </trans-unit>
        <trans-unit id="68664dd02e350ea5073e0ae4aa9b4b05b3c91960" translate="yes" xml:space="preserve">
          <source>Chat server</source>
          <target state="translated">Servidor de chat</target>
        </trans-unit>
        <trans-unit id="929ff11e672655b0a3b8087213ef8d4a743bae97" translate="yes" xml:space="preserve">
          <source>Check if &lt;em&gt;s&lt;/em&gt; matches Nim's &quot;while&quot; keyword:</source>
          <target state="translated">Compruebe si &lt;em&gt;s&lt;/em&gt; coincide con la palabra clave &quot;while&quot; de Nim:</target>
        </trans-unit>
        <trans-unit id="8cf370f6b8ec38a29e2432bba075fad77aab417e" translate="yes" xml:space="preserve">
          <source>Check if a &lt;code&gt;FutureStream&lt;/code&gt; is finished. &lt;code&gt;true&lt;/code&gt; value means that no more data will be placed inside the stream _&lt;a href=&quot;#and&quot;&gt;and&lt;/a&gt; that there is no data waiting to be retrieved.</source>
          <target state="translated">Compruebe si un &lt;code&gt;FutureStream&lt;/code&gt; est&amp;aacute; terminado. valor &lt;code&gt;true&lt;/code&gt; significa que no se colocar&amp;aacute;n m&amp;aacute;s datos dentro del flujo _ &lt;a href=&quot;#and&quot;&gt;y&lt;/a&gt; que no hay datos esperando ser recuperados.</target>
        </trans-unit>
        <trans-unit id="f166d2a8f7a171d1bb127378eb23732d41da0d11" translate="yes" xml:space="preserve">
          <source>Check if a &lt;span id=&quot;directory_1&quot;&gt;directory&lt;/span&gt;&lt;em&gt;dir&lt;/em&gt; exists, and create it otherwise.</source>
          <target state="translated">Comprobar si un &lt;span id=&quot;directory_1&quot;&gt;directorio &lt;/span&gt;&lt;em&gt;dir&lt;/em&gt; existe, y crear de otra manera.</target>
        </trans-unit>
        <trans-unit id="984fcebb18e75b7e703ed2015d054cab99f8aaec" translate="yes" xml:space="preserve">
          <source>Check two nodes for equality</source>
          <target state="translated">Revisar dos nodos para la igualdad</target>
        </trans-unit>
        <trans-unit id="da7416e40baa75d7c56d32d6f86dd948f4e19c78" translate="yes" xml:space="preserve">
          <source>Checking the progress of a file transfer</source>
          <target state="translated">Comprobar el progreso de una transferencia de archivos</target>
        </trans-unit>
        <trans-unit id="132dba3d8ecc2f1b5ab2812aeccdc98f5e82e566" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;osLastError&lt;/code&gt; for a valid error. If it has been reset it uses the last error stored in the socket object.</source>
          <target state="translated">Comprueba &lt;code&gt;osLastError&lt;/code&gt; para un error v&amp;aacute;lido. Si se ha reiniciado, utiliza el &amp;uacute;ltimo error almacenado en el objeto socket.</target>
        </trans-unit>
        <trans-unit id="cc61b0718a3e619d1bd3a5d9f1cd5caf0d888789" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;bool&lt;/em&gt; variables</source>
          <target state="translated">Comprueba la igualdad entre dos variables &lt;em&gt;bool&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f860c207f2a11f0e1a3d019e6937c4ffa577ce1" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;char&lt;/em&gt; variables</source>
          <target state="translated">Comprueba la igualdad entre dos variables &lt;em&gt;char&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb71cf56026acbd41603489b57883dd164a92da2" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;cstring&lt;/em&gt; variables.</source>
          <target state="translated">Comprueba la igualdad entre dos variables &lt;em&gt;cstring&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6693c72afaf2ac68bebd9822b5f0ce79ca5dfcae" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;string&lt;/em&gt; variables</source>
          <target state="translated">Comprueba la igualdad entre dos variables de &lt;em&gt;cadena&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5987179982937ecdc2f511a6d1b5e95c1f8fd6e8" translate="yes" xml:space="preserve">
          <source>Checks for equality between two variables of type &lt;em&gt;set&lt;/em&gt;</source>
          <target state="translated">Comprueba la igualdad entre dos variables de &lt;em&gt;conjunto&lt;/em&gt; de tipos&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99503e3efa2622079cb2940b4767dc3ac6ea82f5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;key&lt;/em&gt; exists in &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">Comprueba si la &lt;em&gt;clave&lt;/em&gt; existe en el &lt;em&gt;nodo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a8474632e4fae06f8ce5b7c82b1279000374e87d" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;s&lt;/em&gt; is nil or consists entirely of whitespace characters.</source>
          <target state="translated">Comprueba si &lt;em&gt;s&lt;/em&gt; es nulo o si consta completamente de caracteres de espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="c736c01c5bfa8a1c6f5bac3b24beb2893e45e7de" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;s&lt;/em&gt; is nil or empty.</source>
          <target state="translated">Comprueba si &lt;em&gt;s&lt;/em&gt; es nulo o est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="59f775bd733836ecb4200f87a57e67e9cfc67799" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;val&lt;/em&gt; exists in array &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">Comprueba si existe &lt;em&gt;val&lt;/em&gt; en el &lt;em&gt;nodo de&lt;/em&gt; matriz .</target>
        </trans-unit>
        <trans-unit id="f46cbda82eb5e9585af47785b7a218005abe05c4" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;value&lt;/em&gt; is within the range of &lt;em&gt;s&lt;/em&gt;; returns true iff &lt;em&gt;value &amp;gt;= s.a and value &amp;lt;= s.b&lt;/em&gt;</source>
          <target state="translated">Comprueba si el &lt;em&gt;valor&lt;/em&gt; est&amp;aacute; dentro del rango de &lt;em&gt;s&lt;/em&gt; ; devuelve verdadero &lt;em&gt;valor&lt;/em&gt; iff &lt;em&gt;&amp;gt; = sa y valor &amp;lt;= sb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f0ff90bf51c73226b0a0ba5e93e479486fcfc7a" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;x&lt;/em&gt; has a type of &lt;em&gt;y&lt;/em&gt;</source>
          <target state="translated">Comprueba si &lt;em&gt;x&lt;/em&gt; tiene un tipo de &lt;em&gt;y&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="daf104d7238ae02de9f7b8d4b2ef3a9d0dd7836c" translate="yes" xml:space="preserve">
          <source>Checks if T is of the same type as S</source>
          <target state="translated">Comprueba si T es del mismo tipo que S</target>
        </trans-unit>
        <trans-unit id="3e2a37d26b80f14b9376ff0970807fa4ec421d07" translate="yes" xml:space="preserve">
          <source>Checks if a cookie of &lt;em&gt;name&lt;/em&gt; exists.</source>
          <target state="translated">Comprueba si existe una cookie de &lt;em&gt;nombre&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="44e4d80ce5f7a1e55199005e073fe653afa2fabc" translate="yes" xml:space="preserve">
          <source>Checks if a string is an IP address Returns true if it is, false otherwise</source>
          <target state="translated">Comprueba si una cadena es una dirección IP Devuelve verdadero si lo es,falso en caso contrario</target>
        </trans-unit>
        <trans-unit id="91fcb8e30c84d0132cb566b30317c70326d854cb" translate="yes" xml:space="preserve">
          <source>Checks if every item fulfills the predicate.</source>
          <target state="translated">Comprueba si cada artículo cumple con el predicado.</target>
        </trans-unit>
        <trans-unit id="af2565e07778c49efe297f906f075760048c0b14" translate="yes" xml:space="preserve">
          <source>Checks if some item fulfills the predicate.</source>
          <target state="translated">Comprueba si algún artículo cumple con el predicado.</target>
        </trans-unit>
        <trans-unit id="239c89279a3bce5516e0481e4f55258a02a144dd" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;proc&lt;/em&gt; variables refer to the same procedure</source>
          <target state="translated">Comprueba que dos variables &lt;em&gt;proc se&lt;/em&gt; refieran al mismo procedimiento</target>
        </trans-unit>
        <trans-unit id="ca5e50261c267853c17b8d0483f9eeeb373544ad" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;ptr&lt;/em&gt; variables refer to the same item</source>
          <target state="translated">Comprueba que dos variables &lt;em&gt;ptr se&lt;/em&gt; refieran al mismo elemento</target>
        </trans-unit>
        <trans-unit id="e8feb74c6a474812ed4a3894be2a37759dfadb64" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;ref&lt;/em&gt; variables refer to the same item</source>
          <target state="translated">Comprueba que dos &lt;em&gt;&amp;aacute;rbitro&lt;/em&gt; variables se refieren al mismo tema</target>
        </trans-unit>
        <trans-unit id="2efb60769de3f5e8c0d857e5d64a4a1d598026d9" translate="yes" xml:space="preserve">
          <source>Checks to see whether &lt;em&gt;a&lt;/em&gt; is already sorted in &lt;em&gt;order&lt;/em&gt; using &lt;em&gt;cmp&lt;/em&gt; for the comparison. Parameters identical to &lt;em&gt;sort&lt;/em&gt;</source>
          <target state="translated">Comprueba si &lt;em&gt;una&lt;/em&gt; ya est&amp;aacute; ordenada en &lt;em&gt;orden&lt;/em&gt; usando &lt;em&gt;CMP&lt;/em&gt; para la comparaci&amp;oacute;n. Par&amp;aacute;metros id&amp;eacute;nticos a &lt;em&gt;ordenar&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb0fddbd515d81fc29a204bb7d47e5506b13b3dc" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;s&lt;/code&gt; is lower case.</source>
          <target state="translated">Comprueba si &lt;code&gt;s&lt;/code&gt; es min&amp;uacute;scula.</target>
        </trans-unit>
        <trans-unit id="a95f9a2833efadf810a077d161631c3c1a37d62b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;s&lt;/code&gt; is upper case.</source>
          <target state="translated">Comprueba si &lt;code&gt;s&lt;/code&gt; est&amp;aacute; en may&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="c19cc9513c0bf1c1425112be49c299ffd561ef33" translate="yes" xml:space="preserve">
          <source>Checks whether a given &lt;em&gt;path&lt;/em&gt; is a root directory</source>
          <target state="translated">Comprueba si una &lt;em&gt;ruta&lt;/em&gt; determinada es un directorio ra&amp;iacute;z</target>
        </trans-unit>
        <trans-unit id="2b2e978aedf3c96424b9cc68407ee36744d6e1fe" translate="yes" xml:space="preserve">
          <source>Checks whether a given &lt;em&gt;path&lt;/em&gt; is absolute.</source>
          <target state="translated">Comprueba si una &lt;em&gt;ruta&lt;/em&gt; determinada es absoluta.</target>
        </trans-unit>
        <trans-unit id="ee4c2aa7f06d4dab8347c552766eb0e82241c0bc" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a lower case character.</source>
          <target state="translated">Comprueba si &lt;em&gt;c&lt;/em&gt; es un car&amp;aacute;cter en min&amp;uacute;scula.</target>
        </trans-unit>
        <trans-unit id="e62669610340d11599af3c49e990b8563987c907" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a number.</source>
          <target state="translated">Comprueba si &lt;em&gt;c&lt;/em&gt; es un n&amp;uacute;mero o no .</target>
        </trans-unit>
        <trans-unit id="dec21879462a972a9215d78983d9622f9e614ece" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a whitespace character.</source>
          <target state="translated">Comprueba si &lt;em&gt;c&lt;/em&gt; es un car&amp;aacute;cter de espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="66ef64629cfaff59e4dda1f006a57dd1a8b7a659" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is alphabetical.</source>
          <target state="translated">Comprueba si &lt;em&gt;c&lt;/em&gt; es alfab&amp;eacute;tico o no .</target>
        </trans-unit>
        <trans-unit id="8bbff5e8bf3937ea9eac7179b7b1803460bcfd4b" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is alphanumeric.</source>
          <target state="translated">Comprueba si &lt;em&gt;c&lt;/em&gt; es alfanum&amp;eacute;rico o no .</target>
        </trans-unit>
        <trans-unit id="783f60adb58a778d0bdcb0ed1f898546ed698d6c" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is an upper case character.</source>
          <target state="translated">Comprueba si &lt;em&gt;c&lt;/em&gt; es un car&amp;aacute;cter en may&amp;uacute;sculas o no .</target>
        </trans-unit>
        <trans-unit id="96e7693a15498ac9fcc81a271241dceee25a1fa0" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is a numeric value.</source>
          <target state="translated">Comprueba si &lt;em&gt;s&lt;/em&gt; es un valor num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="bdff523a789009cf024b82e48a29ed38f90b665d" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is a unicode title.</source>
          <target state="translated">Comprueba si &lt;em&gt;s&lt;/em&gt; es un t&amp;iacute;tulo Unicode.</target>
        </trans-unit>
        <trans-unit id="e633a4c42c8c1c1a6b480f4086e931c947915d1a" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is alphabetical.</source>
          <target state="translated">Comprueba si &lt;em&gt;s&lt;/em&gt; es alfab&amp;eacute;tico o no .</target>
        </trans-unit>
        <trans-unit id="05a69f1cbe4ef4451b315649a574990d236315ae" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is alphanumeric.</source>
          <target state="translated">Comprueba si &lt;em&gt;s&lt;/em&gt; es alfanum&amp;eacute;rico o no .</target>
        </trans-unit>
        <trans-unit id="a4cb2611d9b736cb54c98723c01635d46689fc8b" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is completely whitespace.</source>
          <target state="translated">Comprueba si &lt;em&gt;s&lt;/em&gt; es completamente un espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="5589a38b0e9e9fce2e0e9bb1532225529e28fbfc" translate="yes" xml:space="preserve">
          <source>Checks whether values within the &lt;em&gt;same enum&lt;/em&gt; have the same underlying value</source>
          <target state="translated">Comprueba si los valores dentro de la &lt;em&gt;misma enumeraci&amp;oacute;n&lt;/em&gt; tienen el mismo valor subyacente</target>
        </trans-unit>
        <trans-unit id="60654a8d0b43196c10e1df25c6c3376b674ea1de" translate="yes" xml:space="preserve">
          <source>Checks, whether &lt;em&gt;x&lt;/em&gt; has a property of name &lt;em&gt;prop&lt;/em&gt;.</source>
          <target state="translated">Comprueba si &lt;em&gt;x&lt;/em&gt; tiene una propiedad del nombre &lt;em&gt;prop&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8a71440783140db7ed4f5845038e0d0ef495c4b8" translate="yes" xml:space="preserve">
          <source>Classifies a floating point value. Returns &lt;em&gt;x&lt;/em&gt;'s class as specified by &lt;em&gt;FloatClass&lt;/em&gt;.</source>
          <target state="translated">Clasifica un valor de coma flotante. Devuelve la clase de &lt;em&gt;x&lt;/em&gt; seg&amp;uacute;n lo especificado por &lt;em&gt;FloatClass&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0676a856119b9f43d3b722b7e1f13d155840cdb" translate="yes" xml:space="preserve">
          <source>Clear the supported exceptions represented by &lt;em&gt;excepts&lt;/em&gt;.</source>
          <target state="translated">Borre las excepciones admitidas representadas por &lt;em&gt;excepciones&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bbdc3e1cf1b38d523d6171b4db601a4ff9f5cdbb" translate="yes" xml:space="preserve">
          <source>Clears the HashSet back to an empty state, without shrinking any of the existing storage. O(n) where n is the size of the hash bucket.</source>
          <target state="translated">Limpia el HashSet de nuevo a un estado vacío,sin encoger nada del almacenamiento existente.O(n)donde n es el tamaño del cubo de hash.</target>
        </trans-unit>
        <trans-unit id="500eb6a58ee99ed5a10bac0307d2399525789e8b" translate="yes" xml:space="preserve">
          <source>Clears the OrderedSet back to an empty state, without shrinking any of the existing storage. O(n) where n is the size of the hash bucket.</source>
          <target state="translated">Borra el OrderedSet a un estado vacío,sin reducir el almacenamiento existente.O(n)donde n es el tamaño del cubo de hachís.</target>
        </trans-unit>
        <trans-unit id="3253f000f2b69e9ea7ef993e1158952274e09f15" translate="yes" xml:space="preserve">
          <source>Clears the list of callbacks and sets the callback proc to be called when the future completes.</source>
          <target state="translated">Borra la lista de llamadas de retorno y establece el procedimiento de retorno que se llamará cuando el futuro se complete.</target>
        </trans-unit>
        <trans-unit id="507ebd324f496a23794692a20495953cda164297" translate="yes" xml:space="preserve">
          <source>Clients can also use Postgres keyword/value connection strings to connect.</source>
          <target state="translated">Los clientes también pueden usar las cadenas de conexión palabra clave/valor de Postgres para conectarse.</target>
        </trans-unit>
        <trans-unit id="a9cbac01b8a8251fed166d82028202652414e266" translate="yes" xml:space="preserve">
          <source>Closes &lt;code&gt;sock&lt;/code&gt;. Terminates any current connections.</source>
          <target state="translated">Cierra el &lt;code&gt;sock&lt;/code&gt; . Termina cualquier conexi&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="a734b28e01c24d279132bdbcfaf68f5165797f44" translate="yes" xml:space="preserve">
          <source>Closes a socket and ensures that it is unregistered.</source>
          <target state="translated">Cierra un enchufe y se asegura de que no esté registrado.</target>
        </trans-unit>
        <trans-unit id="caf7e77bedd43df5afff7efafdc353d87046a94d" translate="yes" xml:space="preserve">
          <source>Closes a socket.</source>
          <target state="translated">Cierra un enchufe.</target>
        </trans-unit>
        <trans-unit id="1ced522c89f62b7dce08c4647da6d4cf514e789f" translate="yes" xml:space="preserve">
          <source>Closes any connections held by the HTTP client.</source>
          <target state="translated">Cierra cualquier conexión mantenida por el cliente HTTP.</target>
        </trans-unit>
        <trans-unit id="6e4ad07cceacc544c46a9fcbeb6a76c8d0de27a4" translate="yes" xml:space="preserve">
          <source>Closes event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">Cierra evento &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33c90fcaa7ffb78d8a27467591953ef2c7afae9a" translate="yes" xml:space="preserve">
          <source>Closes the &lt;code&gt;AsyncScgiState&lt;/code&gt;.</source>
          <target state="translated">Cierra &lt;code&gt;AsyncScgiState&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
