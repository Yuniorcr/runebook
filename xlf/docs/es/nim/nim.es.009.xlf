<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="737a9761248665739efdb7e092488b1f4438a576" translate="yes" xml:space="preserve">
          <source>However it is not efficient to do:</source>
          <target state="translated">Sin embargo,no es eficiente hacerlo:</target>
        </trans-unit>
        <trans-unit id="2cbd76edbf731ff982e8e168638d25504365da00" translate="yes" xml:space="preserve">
          <source>However later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="translated">Sin embargo, versiones posteriores del lenguaje podr&amp;iacute;an cambiar esto para significar &quot;inferir los tipos de par&amp;aacute;metros del cuerpo&quot;. Entonces el &lt;code&gt;foo&lt;/code&gt; anterior ser&amp;iacute;a rechazado ya que los tipos de par&amp;aacute;metros no se pueden inferir de una declaraci&amp;oacute;n de &lt;code&gt;discard&lt;/code&gt; vac&amp;iacute;a .</target>
        </trans-unit>
        <trans-unit id="368170efcb2db228f96a4630432ea5c83ce54ea6" translate="yes" xml:space="preserve">
          <source>However such features are not context sensitive and work simply on string matching, which can be problematic in Nim especially due to the case insensitiveness of the language (plus underscores as separators!).</source>
          <target state="translated">Sin embargo,tales características no son sensibles al contexto y trabajan simplemente en el emparejamiento de cuerdas,lo cual puede ser problemático en Nim especialmente debido a la insensibilidad al caso del lenguaje (¡además de los subrayados como separadores!).</target>
        </trans-unit>
        <trans-unit id="c8aede1d3274012cc4621182cf281306471b02d9" translate="yes" xml:space="preserve">
          <source>However the biggest problem is that dead code elimination breaks modularity! To see why, consider this scenario: The module &lt;code&gt;G&lt;/code&gt; (for example the huge Gtk2 module...) is compiled with dead code elimination turned on. So none of &lt;code&gt;G&lt;/code&gt;'s procs is generated at all.</source>
          <target state="translated">Sin embargo, el mayor problema es que la eliminaci&amp;oacute;n del c&amp;oacute;digo muerto rompe la modularidad. Para ver por qu&amp;eacute;, considere este escenario: el m&amp;oacute;dulo &lt;code&gt;G&lt;/code&gt; (por ejemplo, el enorme m&amp;oacute;dulo Gtk2 ...) se compila con la eliminaci&amp;oacute;n de c&amp;oacute;digo muerto activada. Por tanto, no se genera ninguno de los procesos de &lt;code&gt;G&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acb7eac83c404f63f4743f9a82480d0d20a94377" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, a unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is valid too (although only for years in the range 1..9999).</source>
          <target state="translated">Sin embargo, no es necesario que separe necesariamente los patrones de formato, una cadena de formato inequ&amp;iacute;voca como &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; es v&amp;aacute;lida (aunque solo para a&amp;ntilde;os en el rango 1..9999).</target>
        </trans-unit>
        <trans-unit id="742bd46b7a132e000ef82d863fbcce49eb7c5b85" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;int&lt;/code&gt; literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so &lt;code&gt;myInt16 + 34&lt;/code&gt; produces an &lt;code&gt;int16&lt;/code&gt; result.</source>
          <target state="translated">Sin embargo, los literales &lt;code&gt;int&lt;/code&gt; se pueden convertir impl&amp;iacute;citamente a un tipo entero m&amp;aacute;s peque&amp;ntilde;o si el valor del literal se ajusta a este tipo m&amp;aacute;s peque&amp;ntilde;o y dicha conversi&amp;oacute;n es menos costosa que otras conversiones impl&amp;iacute;citas, por lo que &lt;code&gt;myInt16 + 34&lt;/code&gt; produce un resultado &lt;code&gt;int16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf8251069a2532e90f19da84e2234188384c198" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;void&lt;/code&gt; type cannot be inferred in generic code:</source>
          <target state="translated">Sin embargo, no se puede inferir un tipo &lt;code&gt;void&lt;/code&gt; en c&amp;oacute;digo gen&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="4c9fbaef3ddd5b531468395ce9dec2a5ab4f5ae7" translate="yes" xml:space="preserve">
          <source>However, depending on the use case &lt;code&gt;new Foo&lt;/code&gt; can also be wrapped like this instead:</source>
          <target state="translated">Sin embargo, dependiendo del caso de uso, el &lt;code&gt;new Foo&lt;/code&gt; tambi&amp;eacute;n se puede envolver as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="31eaf302275d7d94ef88ad6acf5c8f08d9355de8" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, para los objetivos tipo C, debe vincular el c&amp;oacute;digo externo de forma est&amp;aacute;tica o din&amp;aacute;mica. La forma preferida de integrar c&amp;oacute;digo nativo es usar enlaces din&amp;aacute;micos porque le permite compilar programas Nim sin la necesidad de tener instaladas las bibliotecas de desarrollo relacionadas. Esto se hace a trav&amp;eacute;s de &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma para la importaci&amp;oacute;n&lt;/a&gt; , aunque se puede obtener un control m&amp;aacute;s espec&amp;iacute;fico usando el &lt;a href=&quot;dynlib&quot;&gt;m&amp;oacute;dulo dynlib&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d22d44af2cd8e5a6cc6b8f108be38e9a251be52" translate="yes" xml:space="preserve">
          <source>However, if more than a single statistical calculation is required, it is more efficient to push the data once to the RunningStat object, and call the numerous statistical procs for the RunningStat object.</source>
          <target state="translated">Sin embargo,si se requiere más de un solo cálculo estadístico,es más eficiente empujar los datos una vez al objeto RunningStat,y llamar a los numerosos procedimientos estadísticos para el objeto RunningStat.</target>
        </trans-unit>
        <trans-unit id="a5f20f62b2a4c64e2d22b78b12676a0c62815d5f" translate="yes" xml:space="preserve">
          <source>However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="translated">Sin embargo, ya no es un ordinal, por lo que no es posible utilizar estas enumeraciones como un tipo de &amp;iacute;ndice para matrices. Los procedimientos &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;dec&lt;/code&gt; , &lt;code&gt;succ&lt;/code&gt; y &lt;code&gt;pred&lt;/code&gt; tampoco est&amp;aacute;n disponibles para ellos.</target>
        </trans-unit>
        <trans-unit id="a7f19c857394d2f63dc7cf9130779ed557032b2a" translate="yes" xml:space="preserve">
          <source>However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.</source>
          <target state="translated">Sin embargo,como una plantilla no puede iterar sobre las varargs,esta característica es generalmente mucho más útil para las macros.</target>
        </trans-unit>
        <trans-unit id="91f963bca7858da3bd237b4e32710ada3fd1260b" translate="yes" xml:space="preserve">
          <source>However, sometimes one has to optimize. Do it in the following order:</source>
          <target state="translated">Sin embargo,a veces hay que optimizar.Hágalo en el siguiente orden:</target>
        </trans-unit>
        <trans-unit id="406663563bd897705cf8a1dfd9829c366e1e27d8" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;header&lt;/code&gt; pragma is often the better alternative.</source>
          <target state="translated">Sin embargo, el pragma del &lt;code&gt;header&lt;/code&gt; suele ser la mejor alternativa.</target>
        </trans-unit>
        <trans-unit id="0681510216903f8e2197cf4eef03fbf990baedec" translate="yes" xml:space="preserve">
          <source>However, the above code does not compile: the reason is that you have to cover every value that &lt;code&gt;n&lt;/code&gt; may contain, but the code only handles the values &lt;code&gt;0..8&lt;/code&gt;. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:</source>
          <target state="translated">Sin embargo, el c&amp;oacute;digo anterior no se compila: la raz&amp;oacute;n es que debe cubrir todos los valores que &lt;code&gt;n&lt;/code&gt; puede contener, pero el c&amp;oacute;digo solo maneja los valores &lt;code&gt;0..8&lt;/code&gt; . Dado que no es muy pr&amp;aacute;ctico enumerar todos los dem&amp;aacute;s n&amp;uacute;meros enteros posibles (aunque es posible gracias a la notaci&amp;oacute;n de rango), solucionamos esto dici&amp;eacute;ndole al compilador que para cada otro valor no se debe hacer nada:</target>
        </trans-unit>
        <trans-unit id="fb9aeb69b131c87d8cd6853cf77ea1cf9dd6d2ce" translate="yes" xml:space="preserve">
          <source>However, the constraints &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; are not available in ordinary routines.</source>
          <target state="translated">Sin embargo, los &lt;code&gt;alias&lt;/code&gt; y &lt;code&gt;noalias&lt;/code&gt; de restricciones no est&amp;aacute;n disponibles en rutinas ordinarias.</target>
        </trans-unit>
        <trans-unit id="f56c3539085a2fed48c36c5577618ef3c9427982" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU and CC the file has been compiled for.</source>
          <target state="translated">Sin embargo,el código C generado no es independiente de la plataforma.El código C generado para Linux no compila en Windows,por ejemplo.El comentario en la parte superior del archivo C enumera el sistema operativo,la CPU y el CC para el que se ha compilado el archivo.</target>
        </trans-unit>
        <trans-unit id="a13fe01a81aad0de40fb6ccb549edb2976ed2c1b" translate="yes" xml:space="preserve">
          <source>However, the modules &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;, &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;, and &lt;a href=&quot;times&quot;&gt;times&lt;/a&gt; are available! To access the DOM, use the &lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt; module that is only available for the JavaScript platform.</source>
          <target state="translated">Sin embargo, los m&amp;oacute;dulos &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt; , &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; y &lt;a href=&quot;times&quot;&gt;times&lt;/a&gt; est&amp;aacute;n disponibles. Para acceder al DOM, use el m&amp;oacute;dulo &lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt; que solo est&amp;aacute; disponible para la plataforma JavaScript.</target>
        </trans-unit>
        <trans-unit id="94036a9c51a3400f9ddd28a5c63cabe204e0c9a5" translate="yes" xml:space="preserve">
          <source>However, the symbols &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are already bound and are not looked up again. As the example shows, &lt;code&gt;bindSym&lt;/code&gt; does work with overloaded symbols implicitly.</source>
          <target state="translated">Sin embargo, los s&amp;iacute;mbolos &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; y &lt;code&gt;stdout&lt;/code&gt; ya est&amp;aacute;n vinculados y no se vuelven a buscar. Como muestra el ejemplo, &lt;code&gt;bindSym&lt;/code&gt; funciona con s&amp;iacute;mbolos sobrecargados impl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="db3f8b29b6aa7fbf63138a0a422b4e572110ad5c" translate="yes" xml:space="preserve">
          <source>However, the values being strings/json is quite problematic: Many lookup tables that are built at compiletime embed &lt;em&gt;proc vars&lt;/em&gt; and types which have no obvious string representation... Seems like AST diffing is still the best idea as it will not require to use an alien API and works with some existing Nimble packages, at least.</source>
          <target state="translated">Sin embargo, los valores que son strings / json son bastante problem&amp;aacute;ticos: muchas tablas de b&amp;uacute;squeda que se crean en tiempo de compilaci&amp;oacute;n incrustan &lt;em&gt;proc vars&lt;/em&gt; y tipos que no tienen una representaci&amp;oacute;n de cadena obvia ... Parece que la diferenciaci&amp;oacute;n de AST sigue siendo la mejor idea, ya que no es necesario usarla una API ajena y funciona con algunos paquetes Nimble existentes, al menos.</target>
        </trans-unit>
        <trans-unit id="5b442e77c451b3f66ae133bcb7a6fa4d2d93f7cd" translate="yes" xml:space="preserve">
          <source>However, this does not work. The problem is that the procedure should not only &lt;code&gt;return&lt;/code&gt;, but return and &lt;strong&gt;continue&lt;/strong&gt; after an iteration has finished. This &lt;em&gt;return and continue&lt;/em&gt; is called a &lt;em&gt;yield&lt;/em&gt; statement. Now the only thing left to do is to replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;iterator&lt;/code&gt; and here it is - our first iterator:</source>
          <target state="translated">Sin embargo, esto no funciona. El problema es que el procedimiento no solo debe &lt;code&gt;return&lt;/code&gt; , sino regresar y &lt;strong&gt;continuar&lt;/strong&gt; despu&amp;eacute;s de que una iteraci&amp;oacute;n haya terminado. Este &lt;em&gt;retorno y continuaci&amp;oacute;n&lt;/em&gt; se denomina declaraci&amp;oacute;n de &lt;em&gt;rendimiento&lt;/em&gt; . Ahora lo &amp;uacute;nico que queda por hacer es reemplazar la palabra clave &lt;code&gt;proc&lt;/code&gt; por &lt;code&gt;iterator&lt;/code&gt; y aqu&amp;iacute; est&amp;aacute;: nuestro primer iterador:</target>
        </trans-unit>
        <trans-unit id="11fb6436d40287c29f4518b54ff0c8803e2c0fb2" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="translated">Sin embargo, esto rara vez es necesario. El caso m&amp;aacute;s com&amp;uacute;n es extraer un mensaje de error de &lt;code&gt;e&lt;/code&gt; , y para tales situaciones es suficiente usar &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ae0752c04a35700e1c477d06f622ee35116b587" translate="yes" xml:space="preserve">
          <source>However, you can also use a &lt;code&gt;closure&lt;/code&gt; iterator to get a different set of restrictions. See &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;first class iterators&lt;/a&gt; for details. Iterators can have the same name and parameters as a proc, since essentially they have their own namespaces. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like &lt;code&gt;split&lt;/code&gt; from the &lt;a href=&quot;strutils&quot;&gt;strutils module&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, tambi&amp;eacute;n puede usar un iterador de &lt;code&gt;closure&lt;/code&gt; para obtener un conjunto diferente de restricciones. Consulte &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;los iteradores&lt;/a&gt; de primera clase para obtener m&amp;aacute;s detalles. Los iteradores pueden tener el mismo nombre y par&amp;aacute;metros que un proceso, ya que esencialmente tienen sus propios espacios de nombres. Por lo tanto, es una pr&amp;aacute;ctica com&amp;uacute;n envolver iteradores en procesos del mismo nombre que acumulan el resultado del iterador y lo devuelven como una secuencia, como &lt;code&gt;split&lt;/code&gt; del &lt;a href=&quot;strutils&quot;&gt;m&amp;oacute;dulo strutils&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56d4f245bec69d0b576c1bfc554101ec8df594ad" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Representaci&amp;oacute;n de cadena amigable para los humanos de &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="079d3eca7e1c9c2fd619c47e7f37d0a7860da8ba" translate="yes" xml:space="preserve">
          <source>Hygiene in templates</source>
          <target state="translated">La higiene en las plantillas</target>
        </trans-unit>
        <trans-unit id="0fcb4de22af01003cbbe36bbdb61566a4be791e9" translate="yes" xml:space="preserve">
          <source>I use the term &lt;em&gt;cell&lt;/em&gt; here to refer to everything that is traced (sequences, refs, strings). This section describes how the GC works.</source>
          <target state="translated">Utilizo el t&amp;eacute;rmino &lt;em&gt;celda&lt;/em&gt; aqu&amp;iacute; para referirme a todo lo que se rastrea (secuencias, referencias, cadenas). Esta secci&amp;oacute;n describe c&amp;oacute;mo funciona el GC.</target>
        </trans-unit>
        <trans-unit id="1adbf823c203d9176878f1ea4880115650f6355a" translate="yes" xml:space="preserve">
          <source>IO effect.</source>
          <target state="translated">Efecto IO.</target>
        </trans-unit>
        <trans-unit id="43cbc65c44c1dc2f182c90bae6d0aeab5672e98a" translate="yes" xml:space="preserve">
          <source>IPv4 mapped address.</source>
          <target state="translated">Dirección IPv4 mapeada.</target>
        </trans-unit>
        <trans-unit id="5c90dad54fd1910854f6a4d59c28bd806cb73299" translate="yes" xml:space="preserve">
          <source>IPv4-compatible address.</source>
          <target state="translated">Dirección compatible con IPv4.</target>
        </trans-unit>
        <trans-unit id="a44628ba8c21044e8636076b5b9d6ce7f49f8e2a" translate="yes" xml:space="preserve">
          <source>Identifier Mangling</source>
          <target state="translated">Manipulación de identificadores</target>
        </trans-unit>
        <trans-unit id="1c28aa3eba3eb83da8260427d9817edabf51acf1" translate="yes" xml:space="preserve">
          <source>Identifier construction</source>
          <target state="translated">Identificar la construcción</target>
        </trans-unit>
        <trans-unit id="f85967cd9bf8fa30a0c4ed8ed9689bd0527d9092" translate="yes" xml:space="preserve">
          <source>Identifier equality</source>
          <target state="translated">Igualdad de identidades</target>
        </trans-unit>
        <trans-unit id="33920d1761007ef9f769013f951c310d3a56264f" translate="yes" xml:space="preserve">
          <source>Identifiers &amp;amp; Keywords</source>
          <target state="translated">Identificadores y palabras clave</target>
        </trans-unit>
        <trans-unit id="20cd19ee47a89934f0e36a1ce365b38563d00949" translate="yes" xml:space="preserve">
          <source>Identifiers are &lt;code&gt;nnkIdent&lt;/code&gt; nodes. After the name lookup pass these nodes get transferred into &lt;code&gt;nnkSym&lt;/code&gt; nodes.</source>
          <target state="translated">Los identificadores son nodos &lt;code&gt;nnkIdent&lt;/code&gt; . Despu&amp;eacute;s de la b&amp;uacute;squeda de nombre, estos nodos se transfieren a los nodos &lt;code&gt;nnkSym&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f77e9cbcac065322f642e26369053cdd2f513b" translate="yes" xml:space="preserve">
          <source>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</source>
          <target state="translated">Los identificadores son válidos desde el punto de su declaración hasta el final del bloque en el que se produjo la declaración.El rango en el que se conoce el identificador es el alcance del mismo.El alcance exacto de un identificador depende de la forma en que se declaró.</target>
        </trans-unit>
        <trans-unit id="d92daa59c2bffaa34e4f7d06ae7114ce23760fe1" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, beginning with a letter. Two immediate following underscores &lt;code&gt;__&lt;/code&gt; are not allowed:</source>
          <target state="translated">Los identificadores en Nim pueden ser cualquier cadena de letras, d&amp;iacute;gitos y guiones bajos, comenzando con una letra. No se permiten dos guiones bajos &lt;code&gt;__&lt;/code&gt; inmediatos :</target>
        </trans-unit>
        <trans-unit id="952eeefab257b1dc395adc18dd057b07d99f8b74" translate="yes" xml:space="preserve">
          <source>Identifies version of block</source>
          <target state="translated">Identifica la versión del bloque</target>
        </trans-unit>
        <trans-unit id="9041398445fc89d9adc20f2af276ac74b5c7695f" translate="yes" xml:space="preserve">
          <source>Idetools invocation</source>
          <target state="translated">Invocación de ideas</target>
        </trans-unit>
        <trans-unit id="aa8a0ddc0c68ca8c1cc048c8fc326b77812b0717" translate="yes" xml:space="preserve">
          <source>Idetools outputs is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Los resultados de Idetools siempre se devuelven en l&amp;iacute;neas individuales separadas por caracteres de tabulaci&amp;oacute;n ( &lt;code&gt;\t&lt;/code&gt; ). Los valores de cada columna son:</target>
        </trans-unit>
        <trans-unit id="3d0ad0f39f445a61643d2d4071287f67b574496b" translate="yes" xml:space="preserve">
          <source>Idetools will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Idetools siempre responderá con una sola definición o ninguna si no encuentra ningún símbolo válido que coincida con la posición de la consulta.</target>
        </trans-unit>
        <trans-unit id="e1275cffa883535748d5035619b8b0ef08c96ca9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;address&lt;/code&gt; is &quot;&quot; then ADDR_ANY will be bound.</source>
          <target state="translated">Si la &lt;code&gt;address&lt;/code&gt; es &quot;&quot;, se vincular&amp;aacute; ADDR_ANY.</target>
        </trans-unit>
        <trans-unit id="37372fbcdbd5728a2d0bd860fbfc0027fc538aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">Si &lt;code&gt;async&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; , no se lanzar&amp;aacute; ning&amp;uacute;n error en el caso de que el error se deba a que no hay datos disponibles para leer.</target>
        </trans-unit>
        <trans-unit id="389371efa6da3c7248da8f138d099fa9af63f943" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">Si &lt;code&gt;async&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; no se producir&amp;aacute; ning&amp;uacute;n error en el caso de que el error se deba a que no hay datos disponibles para leer.</target>
        </trans-unit>
        <trans-unit id="f92b13775ef5d4abd1b179130a1e53880a7cf964" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;break&lt;/code&gt; is used without a jump-to location, &lt;code&gt;nnkEmpty&lt;/code&gt; replaces &lt;code&gt;nnkIdent&lt;/code&gt;.</source>
          <target state="translated">Si se usa &lt;code&gt;break&lt;/code&gt; sin una ubicaci&amp;oacute;n de salto, &lt;code&gt;nnkEmpty&lt;/code&gt; reemplaza a &lt;code&gt;nnkIdent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="307e3b5354402d4ec96fc67123487c24bedd7bdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cache&lt;/code&gt; is not empty, the results of &lt;code&gt;staticExec&lt;/code&gt; are cached within the &lt;code&gt;nimcache&lt;/code&gt; directory. Use &lt;code&gt;--forceBuild&lt;/code&gt; to get rid of this caching behaviour then. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for &lt;code&gt;cache&lt;/code&gt;:</source>
          <target state="translated">Si la &lt;code&gt;cache&lt;/code&gt; no est&amp;aacute; vac&amp;iacute;a, los resultados de &lt;code&gt;staticExec&lt;/code&gt; se almacenan en cach&amp;eacute; dentro del directorio &lt;code&gt;nimcache&lt;/code&gt; . Utilice &lt;code&gt;--forceBuild&lt;/code&gt; para deshacerse de este comportamiento de almacenamiento en cach&amp;eacute;. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (la cadena concatenada) se usa para determinar si la entrada en la cach&amp;eacute; sigue siendo v&amp;aacute;lida. Puede utilizar la informaci&amp;oacute;n de versiones para la &lt;code&gt;cache&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b345cf9e0a07a334467009e3e58006f18498e01b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; cannot be sent immediately it will be buffered and sent when &lt;code&gt;sock&lt;/code&gt; becomes writeable (during the &lt;code&gt;handleWrite&lt;/code&gt; event). It's possible that only a part of &lt;code&gt;data&lt;/code&gt; will be sent immediately, while the rest of it will be buffered and sent later.</source>
          <target state="translated">Si los &lt;code&gt;data&lt;/code&gt; no se pueden enviar inmediatamente, se almacenar&amp;aacute;n en b&amp;uacute;fer y se enviar&amp;aacute;n cuando &lt;code&gt;sock&lt;/code&gt; se &lt;code&gt;handleWrite&lt;/code&gt; escribir (durante el evento handleWrite ). Es posible que solo una parte de los &lt;code&gt;data&lt;/code&gt; se env&amp;iacute;e inmediatamente, mientras que el resto se almacenar&amp;aacute; en b&amp;uacute;fer y se enviar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="50c45493d4069c7c7e10803f397d81b028853a8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;err&lt;/code&gt; is not lower than 0 no exception will be raised.</source>
          <target state="translated">Si &lt;code&gt;err&lt;/code&gt; no es menor que 0, no se generar&amp;aacute; ninguna excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0cf358d5e12d7a571236022c026e1ba653036067" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="translated">Si &lt;code&gt;format == ffDecimal&lt;/code&gt; , la precisi&amp;oacute;n es el n&amp;uacute;mero de d&amp;iacute;gitos que se imprimir&amp;aacute;n despu&amp;eacute;s del punto decimal. Si &lt;code&gt;format == ffScientific&lt;/code&gt; , la precisi&amp;oacute;n es el n&amp;uacute;mero m&amp;aacute;ximo de d&amp;iacute;gitos significativos que se imprimir&amp;aacute;n. El valor predeterminado de &lt;em&gt;precisi&amp;oacute;n&lt;/em&gt; es el n&amp;uacute;mero m&amp;aacute;ximo de d&amp;iacute;gitos significativos despu&amp;eacute;s del punto decimal para el tipo de &lt;code&gt;biggestFloat&lt;/code&gt; m&amp;aacute;s grande de Nim .</target>
        </trans-unit>
        <trans-unit id="54b435b8d0e06d5409c71a6bb322a443d196828c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">Si &lt;code&gt;format == ffDecimal&lt;/code&gt; , la precisi&amp;oacute;n es el n&amp;uacute;mero de d&amp;iacute;gitos que se imprimir&amp;aacute;n despu&amp;eacute;s del punto decimal. Si &lt;code&gt;format == ffScientific&lt;/code&gt; , la precisi&amp;oacute;n es el n&amp;uacute;mero m&amp;aacute;ximo de d&amp;iacute;gitos significativos que se imprimir&amp;aacute;n. El valor predeterminado de &lt;em&gt;precisi&amp;oacute;n&lt;/em&gt; es el n&amp;uacute;mero m&amp;aacute;ximo de d&amp;iacute;gitos significativos despu&amp;eacute;s del punto decimal para el tipo &lt;code&gt;float&lt;/code&gt; de Nim .</target>
        </trans-unit>
        <trans-unit id="5ace460fa7284386356689f6617103ecd8499358" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fut&lt;/code&gt; completes first the returned future will hold true, otherwise, if &lt;code&gt;timeout&lt;/code&gt; milliseconds has elapsed first, the returned future will hold false.</source>
          <target state="translated">Si &lt;code&gt;fut&lt;/code&gt; se completa primero, el futuro devuelto se mantendr&amp;aacute; verdadero; de lo contrario, si el &lt;code&gt;timeout&lt;/code&gt; milisegundos ha transcurrido primero, el futuro devuelto ser&amp;aacute; falso.</target>
        </trans-unit>
        <trans-unit id="407f272e1c73737914b8601c245e937e7c1645a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in&lt;/code&gt; had been declared as &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; then &lt;code&gt;T&lt;/code&gt; would have been bound to &lt;code&gt;char&lt;/code&gt;. But &lt;code&gt;s&lt;/code&gt; is not compatible to type &lt;code&gt;set[char]&lt;/code&gt;! The solution is to bind &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;range['a'..'z']&lt;/code&gt;. This is achieved by reversing the parameters for &lt;code&gt;contains&lt;/code&gt;; &lt;code&gt;in&lt;/code&gt; then passes its arguments in reverse order.</source>
          <target state="translated">Si &lt;code&gt;in&lt;/code&gt; se hubiera declarado como &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; entonces &lt;code&gt;T&lt;/code&gt; se habr&amp;iacute;a vinculado a &lt;code&gt;char&lt;/code&gt; . &amp;iexcl;Pero &lt;code&gt;s&lt;/code&gt; no es compatible con el tipo &lt;code&gt;set[char]&lt;/code&gt; ! La soluci&amp;oacute;n es unir &lt;code&gt;T&lt;/code&gt; al &lt;code&gt;range['a'..'z']&lt;/code&gt; . Esto se logra invirtiendo los par&amp;aacute;metros de &lt;code&gt;contains&lt;/code&gt; ; &lt;code&gt;in&lt;/code&gt; pasa entonces sus argumentos en orden inverso.</target>
        </trans-unit>
        <trans-unit id="026648ef593a1b1232f572c220366aa54c2ea801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the binary number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Si &lt;code&gt;maxLen == 0&lt;/code&gt; la longitud del n&amp;uacute;mero binario no tiene l&amp;iacute;mite superior. De lo contrario, no se &lt;code&gt;start + maxLen&lt;/code&gt; caracteres start + maxLen , hasta la longitud de la cadena.</target>
        </trans-unit>
        <trans-unit id="a51b764ac263fbad8833f0cd967c9d52db03faf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the hexadecimal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Si &lt;code&gt;maxLen == 0&lt;/code&gt; la longitud del n&amp;uacute;mero hexadecimal no tiene l&amp;iacute;mite superior. De lo contrario, no se &lt;code&gt;start + maxLen&lt;/code&gt; caracteres start + maxLen , hasta la longitud de la cadena.</target>
        </trans-unit>
        <trans-unit id="a562677ba8a99d4d9a7cacc5ea3e9107a7861eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the octal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Si &lt;code&gt;maxLen == 0&lt;/code&gt; la longitud del n&amp;uacute;mero octal no tiene l&amp;iacute;mite superior. De lo contrario, no se &lt;code&gt;start + maxLen&lt;/code&gt; caracteres start + maxLen , hasta la longitud de la cadena.</target>
        </trans-unit>
        <trans-unit id="595e68e557aa9284038e74f56a160c9ff7b91ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true, the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="translated">Si &lt;code&gt;nested&lt;/code&gt; es verdadero, los literales se reemplazan en todas partes en el &lt;code&gt;constructor&lt;/code&gt; AST; de lo contrario, solo se considera el primer nivel:</target>
        </trans-unit>
        <trans-unit id="4f29ea9e8bc8cec92963dfa196efcc3cdd9dbf0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;oneshot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, timer will be notified only once.</source>
          <target state="translated">Si un &lt;code&gt;oneshot&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el temporizador solo se notificar&amp;aacute; una vez.</target>
        </trans-unit>
        <trans-unit id="a70580e1cf0a168c03d50768037af1f65f6b54c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision == -1&lt;/code&gt;, it tries to format it nicely.</source>
          <target state="translated">Si &lt;code&gt;precision == -1&lt;/code&gt; , intenta formatearlo bien.</target>
        </trans-unit>
        <trans-unit id="5bf1390f2bc8d6e9c194a681c0dcbd434ac66ce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Si el &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; se devuelve verdadero.</target>
        </trans-unit>
        <trans-unit id="f39dfcd47dad136aebe8c56a844f53a0d8d6ae02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;em&gt;true&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;em&gt;false&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es uno de los siguientes valores: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt; , luego devuelve &lt;em&gt;true&lt;/em&gt; . Si &lt;code&gt;s&lt;/code&gt; es uno de los siguientes valores: &lt;code&gt;n, no, false, 0, off&lt;/code&gt; , devuelve &lt;em&gt;falso&lt;/em&gt; . Si &lt;code&gt;s&lt;/code&gt; es algo m&amp;aacute;s, se &lt;code&gt;ValueError&lt;/code&gt; una excepci&amp;oacute;n ValueError .</target>
        </trans-unit>
        <trans-unit id="010a71c05f1179f8db0658264d0a7a515cb8b523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es falso, devuelve verdadero solo si todos los caracteres en &lt;code&gt;s&lt;/code&gt; son alfab&amp;eacute;ticos y en min&amp;uacute;scula.</target>
        </trans-unit>
        <trans-unit id="4f5851e215627025c8523ee634c01c31772cd434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es falso, devuelve verdadero solo si todos los caracteres de &lt;code&gt;s&lt;/code&gt; son alfab&amp;eacute;ticos y en may&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="a9ffc30f44ce015254cb84f1d8acff12890af1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es falso, devuelve verdadero solo si todas las runas en &lt;code&gt;s&lt;/code&gt; son alfab&amp;eacute;ticas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="8c1ee7df97e960b64a9a34fca52a4ee613463ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es falso, devuelve verdadero solo si todas las runas en &lt;code&gt;s&lt;/code&gt; son alfab&amp;eacute;ticas y en may&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="d7daf16ddab2ec83f10b25fc93d560bdca6cc331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es verdadero, devuelve verdadero si todos los caracteres alfab&amp;eacute;ticos en &lt;code&gt;s&lt;/code&gt; son min&amp;uacute;sculas. Devuelve falso si ninguno de los caracteres de &lt;code&gt;s&lt;/code&gt; es alfab&amp;eacute;tico.</target>
        </trans-unit>
        <trans-unit id="5690821da9c726f211bd0d9f591332cb14d7d459" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es verdadero, devuelve verdadero si todos los caracteres alfab&amp;eacute;ticos en &lt;code&gt;s&lt;/code&gt; est&amp;aacute;n en may&amp;uacute;sculas. Devuelve falso si ninguno de los caracteres de &lt;code&gt;s&lt;/code&gt; es alfab&amp;eacute;tico.</target>
        </trans-unit>
        <trans-unit id="317dfb0d58e9180509c313e714059b2f64b10411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es verdadero, devuelve verdadero si todas las runas alfab&amp;eacute;ticas en &lt;code&gt;s&lt;/code&gt; son min&amp;uacute;sculas. Devuelve falso si ninguna de las runas en &lt;code&gt;s&lt;/code&gt; est&amp;aacute; en orden alfab&amp;eacute;tico.</target>
        </trans-unit>
        <trans-unit id="ed588c14681cc5f1a8b51d3a7fac0541af404239" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Si &lt;code&gt;skipNonAlpha&lt;/code&gt; es verdadero, devuelve verdadero si todas las runas alfab&amp;eacute;ticas en &lt;code&gt;s&lt;/code&gt; est&amp;aacute;n en may&amp;uacute;sculas. Devuelve falso si ninguna de las runas en &lt;code&gt;s&lt;/code&gt; est&amp;aacute; en orden alfab&amp;eacute;tico.</target>
        </trans-unit>
        <trans-unit id="046a824089b8e2afbd1bb54bbb407aa442933340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL socket a handshake will be automatically performed.</source>
          <target state="translated">Si el &lt;code&gt;socket&lt;/code&gt; es un socket SSL, se realizar&amp;aacute; autom&amp;aacute;ticamente un protocolo de enlace.</target>
        </trans-unit>
        <trans-unit id="c110971e46a836dd2629952749afa315b2670098" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Si &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; se devuelve verdadero.</target>
        </trans-unit>
        <trans-unit id="d757e24742c24af41e66e6d5cd0f46d4cd8adcb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Si se devuelve el &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; verdadero.</target>
        </trans-unit>
        <trans-unit id="b73051fe1df0d6852ad033cd16067f76b3c7f36d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; esperando &lt;code&gt;fv&lt;/code&gt; no se bloquear&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="bc9c3ff2a3345cd590a6fedc6177790735c03231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation where &lt;code&gt;c&lt;/code&gt; is an iterator is preferred over the other interpretations:</source>
          <target state="translated">Si se usa &lt;code&gt;type&lt;/code&gt; para determinar el tipo de resultado de una llamada a proc / iterator / converter &lt;code&gt;c(X)&lt;/code&gt; (donde &lt;code&gt;X&lt;/code&gt; representa una lista de argumentos posiblemente vac&amp;iacute;a), la interpretaci&amp;oacute;n donde &lt;code&gt;c&lt;/code&gt; es un iterador es preferible a las otras interpretaciones:</target>
        </trans-unit>
        <trans-unit id="3a2410e0f5521d539c525fb5bab4dfb899762d20" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fromRoot&lt;/em&gt; is set, the traversal will start from the file system root diretory. If &lt;em&gt;inclusive&lt;/em&gt; is set, the original argument will be included in the traversal.</source>
          <target state="translated">Si se establece &lt;em&gt;fromRoot&lt;/em&gt; , el recorrido se iniciar&amp;aacute; desde el directorio ra&amp;iacute;z del sistema de archivos. Si se establece &lt;em&gt;inclusivo&lt;/em&gt; , el argumento original se incluir&amp;aacute; en el recorrido.</target>
        </trans-unit>
        <trans-unit id="199de5473c17b3499d89cf849af056dcb7ec2a21" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;leading&lt;/em&gt; is true, leading &lt;em&gt;chars&lt;/em&gt; are stripped. If &lt;em&gt;trailing&lt;/em&gt; is true, trailing &lt;em&gt;chars&lt;/em&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">Si el &lt;em&gt;interlineado&lt;/em&gt; es verdadero, los &lt;em&gt;caracteres&lt;/em&gt; principales se eliminan. Si el &lt;em&gt;seguimiento&lt;/em&gt; es verdadero, los &lt;em&gt;caracteres&lt;/em&gt; finales se eliminan. Si ambos son falsos, la cadena se devuelve sin cambios.</target>
        </trans-unit>
        <trans-unit id="858dcc140fb894e0ab39988b41a394056e356424" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linkTitle&lt;/em&gt; or &lt;em&gt;linkDesc&lt;/em&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="translated">Si &lt;em&gt;linkTitle&lt;/em&gt; o &lt;em&gt;linkDesc&lt;/em&gt; no son la cadena vac&amp;iacute;a, se agregar&amp;aacute;n dos columnas adicionales con su contenido.</target>
        </trans-unit>
        <trans-unit id="4e866237eb46ef9c2e685eaa551676cfb806b047" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnElement&lt;/em&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="translated">Si &lt;em&gt;n&lt;/em&gt; es &lt;em&gt;xnElement&lt;/em&gt; , se ejecuta de forma recursiva en cada nodo hijo y concatena los resultados.</target>
        </trans-unit>
        <trans-unit id="fa2323ffef001ae4f50de61394ed2c4c06dd1eef" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnText&lt;/em&gt; or &lt;em&gt;xnEntity&lt;/em&gt;, returns its content.</source>
          <target state="translated">Si &lt;em&gt;n&lt;/em&gt; es &lt;em&gt;xnText&lt;/em&gt; o &lt;em&gt;xnEntity&lt;/em&gt; , devuelve su contenido.</target>
        </trans-unit>
        <trans-unit id="6015dc5849733f7831bc335a048414718d188cdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JArray&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">Si &lt;em&gt;n&lt;/em&gt; es un &lt;em&gt;JArray&lt;/em&gt; , devuelve el n&amp;uacute;mero de elementos. Si &lt;em&gt;n&lt;/em&gt; es un &lt;em&gt;JObject&lt;/em&gt; , devuelve el n&amp;uacute;mero de pares. De lo contrario, devuelve 0.</target>
        </trans-unit>
        <trans-unit id="bd5549ec7eeae51a8cdef6008f85c363b39530b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;SList&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">Si &lt;em&gt;n&lt;/em&gt; es una &lt;em&gt;SList&lt;/em&gt; , devuelve el n&amp;uacute;mero de elementos. Si &lt;em&gt;n&lt;/em&gt; es un &lt;em&gt;JObject&lt;/em&gt; , devuelve el n&amp;uacute;mero de pares. De lo contrario, devuelve 0.</target>
        </trans-unit>
        <trans-unit id="b5d453d0776be5e831bfbd8ed97503ad7f979cee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no directory component, &lt;em&gt;dir&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no filename component, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;ext&lt;/em&gt; are empty strings.</source>
          <target state="translated">Si la &lt;em&gt;ruta&lt;/em&gt; no tiene extensi&amp;oacute;n, &lt;em&gt;ext&lt;/em&gt; es la cadena vac&amp;iacute;a. Si la &lt;em&gt;ruta&lt;/em&gt; no tiene un componente de directorio, &lt;em&gt;dir&lt;/em&gt; es la cadena vac&amp;iacute;a. Si la &lt;em&gt;ruta&lt;/em&gt; no tiene un componente de &lt;em&gt;nombre de&lt;/em&gt; archivo, &lt;em&gt;name&lt;/em&gt; y &lt;em&gt;ext&lt;/em&gt; son cadenas vac&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="80be0c8b8f0887f6f6256d7bd08befefadc198dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;places&lt;/em&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;em&gt;round(54.5) -&amp;gt; 55.0&lt;/em&gt;). If &lt;em&gt;places&lt;/em&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;em&gt;round(54.346, 2) -&amp;gt; 54.35&lt;/em&gt;. If &lt;em&gt;places&lt;/em&gt; is negative, round to the left of the decimal place, e.g. &lt;em&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</source>
          <target state="translated">Si los &lt;em&gt;lugares&lt;/em&gt; son 0 (o se omiten), redondee al valor integral m&amp;aacute;s cercano siguiendo las reglas matem&amp;aacute;ticas normales de redondeo (por ejemplo, &lt;em&gt;redondee (54,5) -&amp;gt; 55,0&lt;/em&gt; ). Si los &lt;em&gt;lugares&lt;/em&gt; son mayores que 0, redondee al n&amp;uacute;mero dado de lugares decimales, por ejemplo, &lt;em&gt;redondee (54.346, 2) -&amp;gt; 54.35&lt;/em&gt; . Si los &lt;em&gt;lugares&lt;/em&gt; son negativos, redondee a la izquierda del lugar decimal, por ejemplo, &lt;em&gt;redondee (537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85943ee873870ccb602997d1ba558ce262f536fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; contains none of the characters in &lt;em&gt;chars&lt;/em&gt;, -1 is returned.</source>
          <target state="translated">Si &lt;em&gt;s&lt;/em&gt; no contiene ninguno de los caracteres de los &lt;em&gt;caracteres&lt;/em&gt; , se devuelve -1.</target>
        </trans-unit>
        <trans-unit id="918bef596764b0dd1abc0034e3aca9f099546dd6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="translated">Si &lt;em&gt;s&lt;/em&gt; no comienza con el &lt;code&gt;prefix&lt;/code&gt; y termina con el &lt;code&gt;suffix&lt;/code&gt; generar&amp;aacute; una excepci&amp;oacute;n ValueError.</target>
        </trans-unit>
        <trans-unit id="ffecd98c556448bc07a363bac2464a9be3914393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid binary integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Si &lt;em&gt;s&lt;/em&gt; no es un entero binario v&amp;aacute;lido, se &lt;em&gt;genera ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; pueden tener uno de los siguientes prefijos opcionales: &lt;code&gt;0b&lt;/code&gt; , &lt;code&gt;0B&lt;/code&gt; . Los guiones bajos dentro de &lt;em&gt;s&lt;/em&gt; se ignoran.</target>
        </trans-unit>
        <trans-unit id="22934de3f162a4b17792ea0eea7d5289abc794bc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid hex integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Si &lt;em&gt;s&lt;/em&gt; no es un entero hexadecimal v&amp;aacute;lido, se &lt;em&gt;genera ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; pueden tener uno de los siguientes prefijos opcionales: &lt;code&gt;0x&lt;/code&gt; , &lt;code&gt;0X&lt;/code&gt; , &lt;code&gt;#&lt;/code&gt; . Los guiones bajos dentro de &lt;em&gt;s&lt;/em&gt; se ignoran.</target>
        </trans-unit>
        <trans-unit id="31f1b5486de0d368adaea367eae29e732db7fbdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid integer, &lt;em&gt;ValueError&lt;/em&gt; is raised.</source>
          <target state="translated">Si &lt;em&gt;s&lt;/em&gt; no es un entero v&amp;aacute;lido, se &lt;em&gt;genera ValueError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a06a939f49597f675f8bb03c0e2cb909dc45d17e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid oct integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Si &lt;em&gt;s&lt;/em&gt; no es un entero de oct v&amp;aacute;lido, se &lt;em&gt;genera ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; pueden tener uno de los siguientes prefijos opcionales: &lt;code&gt;0o&lt;/code&gt; , &lt;code&gt;0O&lt;/code&gt; . Los guiones bajos dentro de &lt;em&gt;s&lt;/em&gt; se ignoran.</target>
        </trans-unit>
        <trans-unit id="27d35434baea7af37a0b648eef07955006978983" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;siPrefix&lt;/em&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;em&gt;u&lt;/em&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;em&gt;siPrefix&lt;/em&gt; is true.</source>
          <target state="translated">Si &lt;em&gt;siPrefix&lt;/em&gt; se establece en verdadero, el n&amp;uacute;mero se mostrar&amp;aacute; con el prefijo SI correspondiente al exponente. Por ejemplo, 4100 se mostrar&amp;aacute; como &quot;4.1 k&quot; en lugar de &quot;4.1e3&quot;. Tenga en cuenta que &lt;em&gt;u&lt;/em&gt; se usa para micro- en lugar de la letra griega mu (&amp;mu;) seg&amp;uacute;n ISO 2955. Los n&amp;uacute;meros con un valor absoluto fuera del rango 1e-18 &amp;lt;f &amp;lt;1000e18 (1a &amp;lt;f &amp;lt;1000E) se mostrar&amp;aacute;n con un exponente en lugar de un prefijo SI, independientemente de si &lt;em&gt;siPrefix&lt;/em&gt; es verdadero.</target>
        </trans-unit>
        <trans-unit id="3c153378df49ceb0514b8f9591a7fe13753328b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spread&lt;/em&gt; is false and the length of &lt;em&gt;s&lt;/em&gt; is not a multiple of &lt;em&gt;num&lt;/em&gt;, the proc will max out the first sub sequences with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="translated">Si la &lt;em&gt;extensi&amp;oacute;n&lt;/em&gt; es falsa y la longitud de &lt;em&gt;s&lt;/em&gt; no es un m&amp;uacute;ltiplo de &lt;em&gt;num&lt;/em&gt; , el proceso maximizar&amp;aacute; las primeras subsecuencias con &lt;code&gt;1 + len(s) div num&lt;/code&gt; entradas, dejando el resto de elementos en la &amp;uacute;ltima secuencia.</target>
        </trans-unit>
        <trans-unit id="4775826ae44f8348308b950ee7f0228f3079a862" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;trim&lt;/em&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;em&gt;precision&lt;/em&gt; will always be shown.</source>
          <target state="translated">Si &lt;em&gt;trim&lt;/em&gt; se establece en verdadero, se eliminar&amp;aacute;n los ceros finales; si es falso, siempre se mostrar&amp;aacute; el n&amp;uacute;mero de d&amp;iacute;gitos especificado por &lt;em&gt;precisi&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3df1de57df75f3d46e50b0da67618c0e39c016" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;useUnitSpace&lt;/em&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="translated">Si &lt;em&gt;useUnitSpace&lt;/em&gt; es verdadero, la unidad proporcionada se agregar&amp;aacute; a la cadena (con un espacio como lo requiere el est&amp;aacute;ndar SI). Este comportamiento es ligeramente diferente a agregar la unidad al resultado, ya que la ubicaci&amp;oacute;n del espacio se altera dependiendo de si hay un exponente.</target>
        </trans-unit>
        <trans-unit id="0c624e82a301cd1b0a01c9e7e8780b498a5b18ce" translate="yes" xml:space="preserve">
          <source>If a declared symbol is marked with an &lt;span id=&quot;asterisk_1&quot;&gt;asterisk&lt;/span&gt; it is exported from the current module:</source>
          <target state="translated">Si un s&amp;iacute;mbolo declarado est&amp;aacute; marcado con un &lt;span id=&quot;asterisk_1&quot;&gt;asterisco&lt;/span&gt; , se exporta desde el m&amp;oacute;dulo actual:</target>
        </trans-unit>
        <trans-unit id="10f356aa84e307221ea1ddc951ea76e3235c5f18" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;ReadFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">Si se ha recuperado una l&amp;iacute;nea completa; Se devuelve &lt;code&gt;ReadFullLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6e2de7dd3af4670ee12c88866b53b3fc6104073" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;RecvFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">Si se ha recuperado una l&amp;iacute;nea completa; Se devuelve &lt;code&gt;RecvFullLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4edfbe8476a0a7a39ffd09f45852fb65cecbf1" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">Si se lee una l&amp;iacute;nea completa, &lt;code&gt;\r\L&lt;/code&gt; no se agrega a la &lt;code&gt;line&lt;/code&gt; , sin embargo, si solo se lee &lt;code&gt;\r\L&lt;/code&gt; entonces se establecer&amp;aacute; la &lt;code&gt;line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c16eab689c4842392a5a11dd1c091bb5c2263373" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to the result, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then the result will be set to it.</source>
          <target state="translated">Si se lee una l&amp;iacute;nea completa, &lt;code&gt;\r\L&lt;/code&gt; no se agrega al resultado, sin embargo, si solo se lee &lt;code&gt;\r\L&lt;/code&gt; , el resultado se establecer&amp;aacute; en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="2e37450d6f575130f1da8f99af9d57374a8a5ea4" translate="yes" xml:space="preserve">
          <source>If a full line is received &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is received then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">Si se recibe una l&amp;iacute;nea completa, &lt;code&gt;\r\L&lt;/code&gt; no se agrega a la &lt;code&gt;line&lt;/code&gt; , sin embargo, si solo se recibe &lt;code&gt;\r\L&lt;/code&gt; , la &lt;code&gt;line&lt;/code&gt; se configurar&amp;aacute; con ella.</target>
        </trans-unit>
        <trans-unit id="4578160882d9270d9e934109afdfbf00113bc1cc" translate="yes" xml:space="preserve">
          <source>If a line starts with &lt;code&gt;#&lt;/code&gt; it will be ignored completely, so you can use that for comments.</source>
          <target state="translated">Si una l&amp;iacute;nea comienza con &lt;code&gt;#&lt;/code&gt; , se ignorar&amp;aacute; por completo, por lo que puede usarla para comentarios.</target>
        </trans-unit>
        <trans-unit id="9bc3730afa8c59c97647c426e37011adafd8a176" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="translated">Si un módulo importa un identificador por dos módulos diferentes,cada ocurrencia del identificador debe ser calificada,a menos que se trate de un procedimiento o un iterador sobrecargado,en cuyo caso la resolución de la sobrecarga tiene lugar:</target>
        </trans-unit>
        <trans-unit id="efe916c21117e3859222aca055e9bea6cec4eac2" translate="yes" xml:space="preserve">
          <source>If a node is used in a different document than the one that created it (that doesn't support it)</source>
          <target state="translated">Si un nodo es usado en un documento diferente al que lo creó (que no lo soporta)</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">Si un parámetro o una operación no es soportada por el objeto subyacente.</target>
        </trans-unit>
        <trans-unit id="3086cb848c98b3dd77a110e77a2de136bf838978" translate="yes" xml:space="preserve">
          <source>If a proc is annotated with the &lt;code&gt;noinit&lt;/code&gt; pragma this refers to its implicit &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">Si un proc est&amp;aacute; anotado con el pragma &lt;code&gt;noinit&lt;/code&gt; , esto se refiere a su variable de &lt;code&gt;result&lt;/code&gt; ado impl&amp;iacute;cita :</target>
        </trans-unit>
        <trans-unit id="056e8beb820913d3d337f02913145eef09e66318" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Si una referencia no apunta a &lt;em&gt;nada&lt;/em&gt; , tiene el valor &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ad2206a1169aba9bd7c1b09f9fb0941ea61337" translate="yes" xml:space="preserve">
          <source>If a section of code holds a lock of level &lt;code&gt;M&lt;/code&gt; than it can also acquire any lock of level &lt;code&gt;N &amp;lt; M&lt;/code&gt;. Another lock of level &lt;code&gt;M&lt;/code&gt; cannot be acquired. Locks of the same level can only be acquired &lt;em&gt;at the same time&lt;/em&gt; within a single &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">Si una secci&amp;oacute;n de c&amp;oacute;digo tiene un bloqueo de nivel &lt;code&gt;M&lt;/code&gt; , entonces tambi&amp;eacute;n puede adquirir cualquier bloqueo de nivel &lt;code&gt;N &amp;lt; M&lt;/code&gt; . No se puede adquirir otra cerradura de nivel &lt;code&gt;M&lt;/code&gt; . Las cerraduras del mismo nivel solo se pueden adquirir &lt;em&gt;al mismo tiempo&lt;/em&gt; dentro de una &amp;uacute;nica secci&amp;oacute;n de &lt;code&gt;locks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f883af41470e39046741ce71193805e04a0fb408" translate="yes" xml:space="preserve">
          <source>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</source>
          <target state="translated">Si un tipo estructurado presenta un campo con un tipo destructible y el usuario no ha proporcionado una implementación explícita,se generará automáticamente un destructor para el tipo estructurado.Se insertarán llamadas a cualquier clase base de destructores tanto en los destructores definidos por el usuario como en los generados.</target>
        </trans-unit>
        <trans-unit id="0db08f2b2e98ccda7902cf1898e764d8c7f5e868" translate="yes" xml:space="preserve">
          <source>If a type section uses generic parameters, they are treated here:</source>
          <target state="translated">Si una sección de tipo utiliza parámetros genéricos,se tratan aquí:</target>
        </trans-unit>
        <trans-unit id="de9d3f35f669e256aa6c736e6a1afde344da10ae" translate="yes" xml:space="preserve">
          <source>If an assertion in Nim's memory manager or GC fails, the stack trace keeps allocating memory! Thus a stack overflow may happen, hiding the real issue.</source>
          <target state="translated">Si una afirmación en el administrador de memoria o GC de Nim falla,el rastro de la pila sigue asignando memoria! Por lo tanto,un desbordamiento de la pila puede ocurrir,ocultando el verdadero problema.</target>
        </trans-unit>
        <trans-unit id="995c8ccff46b0b1f2916c13247fc81cbf289033e" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere</source>
          <target state="translated">Si se intenta añadir un atributo que ya se utiliza en otros lugares</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">Si se intenta crear o modificar un objeto de manera incorrecta en lo que respecta a los espacios de nombres.</target>
        </trans-unit>
        <trans-unit id="7d19aea11801948c78474316888135ae6018e7ae" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed</source>
          <target state="translated">Si se intenta modificar un objeto donde las modificaciones no están permitidas</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">Si se intenta modificar el tipo del objeto subyacente.</target>
        </trans-unit>
        <trans-unit id="c2268feb0b92960c8ac6e11b1ff1a253a519fe84" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a node in a context where it does not exist</source>
          <target state="translated">Si se intenta hacer referencia a un nodo en un contexto en el que no existe</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">Si se intenta utilizar un objeto que no es,o ya no es,utilizable.</target>
        </trans-unit>
        <trans-unit id="4a5a5458cfa721632e1a44b5d3d63641a792b115" translate="yes" xml:space="preserve">
          <source>If an awaited future completes with an error, then &lt;code&gt;await&lt;/code&gt; will re-raise this error. To avoid this, you can use the &lt;code&gt;yield&lt;/code&gt; keyword instead of &lt;code&gt;await&lt;/code&gt;. The following section shows different ways that you can handle exceptions in async procs.</source>
          <target state="translated">Si un futuro esperado se completa con un error, &lt;code&gt;await&lt;/code&gt; volver&amp;aacute; a generar este error. Para evitar esto, puede utilizar la palabra clave &lt;code&gt;yield&lt;/code&gt; en lugar de &lt;code&gt;await&lt;/code&gt; . La siguiente secci&amp;oacute;n muestra diferentes formas en que puede manejar excepciones en procesos as&amp;iacute;ncronos.</target>
        </trans-unit>
        <trans-unit id="9cfe3c7dc34bbfcf5eaa53fe4a526fe2fa04f7a3" translate="yes" xml:space="preserve">
          <source>If an error occurs EOS will be raised.</source>
          <target state="translated">Si se produce un error,el EOS se elevará.</target>
        </trans-unit>
        <trans-unit id="20075c8048a0853ffcb0c572ffb4edf2ab4dea98" translate="yes" xml:space="preserve">
          <source>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="translated">Si se produce un error,se planteará una excepción EOS.De lo contrario,el valor de retorno será la longitud de los datos recibidos.</target>
        </trans-unit>
        <trans-unit id="ee9dd9a88b7a108b3b5ddebf055242224e607202" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised.</source>
          <target state="translated">Si se produce un error,se planteará una excepción de OSError.</target>
        </trans-unit>
        <trans-unit id="9df3e94f40e9f0642b83425fe8366b3839215739" translate="yes" xml:space="preserve">
          <source>If an error occurs the return value will be &lt;code&gt;-1&lt;/code&gt;. Otherwise the return value will be the length of data received.</source>
          <target state="translated">Si ocurre un error, el valor devuelto ser&amp;aacute; &lt;code&gt;-1&lt;/code&gt; . De lo contrario, el valor de retorno ser&amp;aacute; la longitud de los datos recibidos.</target>
        </trans-unit>
        <trans-unit id="65934c6d6036cdaf55bf0800e92c5afaa296761f" translate="yes" xml:space="preserve">
          <source>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</source>
          <target state="translated">Si un número par de barras invertidas va seguido de una comilla doble,se coloca una barra invertida en la matriz de argv por cada par de barras invertidas,y la comilla doble se interpreta como un delimitador de cadena.</target>
        </trans-unit>
        <trans-unit id="7464323e44d0ae19ebeba4498e456ca8adf8480b" translate="yes" xml:space="preserve">
          <source>If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.</source>
          <target state="translated">Si se da un inicializador,el tipo puede ser omitido:la variable es entonces del mismo tipo que la expresión inicializadora.Las variables se inicializan siempre con un valor por defecto si no hay expresión inicializadora.El valor por defecto depende del tipo y es siempre un cero en binario.</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">Si se especifica una cadena inválida o ilegal.</target>
        </trans-unit>
        <trans-unit id="31248330f03fa20f9122a001da3f7a4b63664cf0" translate="yes" xml:space="preserve">
          <source>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</source>
          <target state="translated">Si un número impar de barras invertidas va seguido de una comilla doble,se coloca una barra invertida en la matriz argv por cada par de barras invertidas,y la comilla doble se &quot;escapa&quot; por la barra invertida restante,causando que se coloque una comilla doble literal (&quot;)en argv.</target>
        </trans-unit>
        <trans-unit id="ac9b41083a3085bc3f11ff622b38e4fe8c4f414b" translate="yes" xml:space="preserve">
          <source>If an optional argument is present the following lookup algorithm is used:</source>
          <target state="translated">Si un argumento opcional está presente,se utiliza el siguiente algoritmo de búsqueda:</target>
        </trans-unit>
        <trans-unit id="a9811584c6a21ee0c14d6db331e13ba352d14ad0" translate="yes" xml:space="preserve">
          <source>If an unary operator's first character is &lt;code&gt;@&lt;/code&gt; it is a &lt;span id=&quot;sigilminuslike_1&quot;&gt;sigil-like&lt;/span&gt; operator which binds stronger than a &lt;code&gt;primarySuffix&lt;/code&gt;: &lt;code&gt;@x.abc&lt;/code&gt; is parsed as &lt;code&gt;(@x).abc&lt;/code&gt; whereas &lt;code&gt;$x.abc&lt;/code&gt; is parsed as &lt;code&gt;$(x.abc)&lt;/code&gt;.</source>
          <target state="translated">Si el primer car&amp;aacute;cter de un operador unario es &lt;code&gt;@&lt;/code&gt; , es un operador &lt;span id=&quot;sigilminuslike_1&quot;&gt;similar a&lt;/span&gt; un &lt;span id=&quot;sigilminuslike_1&quot;&gt;sigilo&lt;/span&gt; que se une m&amp;aacute;s fuerte que un &lt;code&gt;primarySuffix&lt;/code&gt; : &lt;code&gt;@x.abc&lt;/code&gt; se analiza como &lt;code&gt;(@x).abc&lt;/code&gt; mientras que &lt;code&gt;$x.abc&lt;/code&gt; se analiza como &lt;code&gt;$(x.abc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6f49d0dfcf12fec7bb99768e6a680d44371f26" translate="yes" xml:space="preserve">
          <source>If any node is inserted somewhere it doesn't belong</source>
          <target state="translated">Si algún nodo se inserta en algún lugar que no pertenece</target>
        </trans-unit>
        <trans-unit id="7a913709639c29598ea85076fb70279d360292bd" translate="yes" xml:space="preserve">
          <source>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</source>
          <target state="translated">Si las afirmaciones se apagan,no hace nada.Si las aseveraciones están activadas,las versiones posteriores revisarán la cadena para comprobar la sintaxis válida.</target>
        </trans-unit>
        <trans-unit id="74b5d1a57a127216acbfd875469a1f6d6875a284" translate="yes" xml:space="preserve">
          <source>If async dispatcher is not running, &lt;code&gt;cbproc&lt;/code&gt; will be executed immediately.</source>
          <target state="translated">Si el despachador as&amp;iacute;ncrono no se est&amp;aacute; ejecutando, &lt;code&gt;cbproc&lt;/code&gt; se ejecutar&amp;aacute; inmediatamente.</target>
        </trans-unit>
        <trans-unit id="7eaacc538f76088f4558f36cb9f8907f19b9ce21" translate="yes" xml:space="preserve">
          <source>If async dispatcher is running, &lt;code&gt;cbproc&lt;/code&gt; will be executed during next dispatcher tick.</source>
          <target state="translated">Si el despachador as&amp;iacute;ncrono se est&amp;aacute; ejecutando, &lt;code&gt;cbproc&lt;/code&gt; se ejecutar&amp;aacute; durante el pr&amp;oacute;ximo tick del despachador.</target>
        </trans-unit>
        <trans-unit id="7324648ec3da0700c798c83a7252c4467f507aa2" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;code&gt;RecvFail&lt;/code&gt; is returned.</source>
          <target state="translated">Si la llamada a la &lt;code&gt;recv&lt;/code&gt; fall&amp;oacute;; Se devuelve &lt;code&gt;RecvFail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71f6a401dad3e06dd5b3b05ed44e34fcc7b8ef06" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;strong&gt;an EOS exception is raised.&lt;/strong&gt;</source>
          <target state="translated">Si la llamada a la &lt;code&gt;recv&lt;/code&gt; fall&amp;oacute;; &lt;strong&gt;se genera una excepci&amp;oacute;n EOS.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caa867aef2e9b590f00e0b0045de459f37c6f8f5" translate="yes" xml:space="preserve">
          <source>If data is specified for a node which does not support data</source>
          <target state="translated">Si se especifican datos para un nodo que no soporta datos</target>
        </trans-unit>
        <trans-unit id="e824895cdb4cef64be7375ea8413a63a868d2ccc" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; or &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="translated">Si se define la variable de entorno &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; , &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; o &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) o &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). Este archivo se puede omitir con la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--skipUserCfg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20ac8fdf916d130ad74ee2dd25e10ce69bd5ec18" translate="yes" xml:space="preserve">
          <source>If expression</source>
          <target state="translated">Si la expresión</target>
        </trans-unit>
        <trans-unit id="69dbcb321d20b0e49d118ee95433af7f3dbbbc3b" translate="yes" xml:space="preserve">
          <source>If future has already completed then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">Si el futuro ya se ha completado , se llamar&amp;aacute; inmediatamente a &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d41b28de410ec7385af014da7c0540575e3aaaaf" translate="yes" xml:space="preserve">
          <source>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</source>
          <target state="translated">Si la cabeza es la cuerda vacía,la cola se devuelve.Si la cola es la cuerda vacía,la cabeza se devuelve con un separador de camino.Si la cola comienza con un separador de camino,será eliminada cuando se concatene con la cabeza.Otros separadores de senderos que no se encuentren en los límites no serán modificados.Más ejemplos en Unix:</target>
        </trans-unit>
        <trans-unit id="7ed9d728cd6081bbf88a148e476d401db74961e1" translate="yes" xml:space="preserve">
          <source>If in the above example module &lt;code&gt;B&lt;/code&gt; is re-compiled, but &lt;code&gt;A&lt;/code&gt; is not then &lt;code&gt;B&lt;/code&gt; needs to be aware of &lt;code&gt;toBool&lt;/code&gt; even though &lt;code&gt;toBool&lt;/code&gt; is not referenced in &lt;code&gt;B&lt;/code&gt;&lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">Si en el ejemplo anterior, el m&amp;oacute;dulo &lt;code&gt;B&lt;/code&gt; se vuelve a compilar, pero &lt;code&gt;A&lt;/code&gt; no, entonces &lt;code&gt;B&lt;/code&gt; debe conocer &lt;code&gt;toBool&lt;/code&gt; aunque no se haga referencia a &lt;code&gt;toBool&lt;/code&gt; en &lt;code&gt;B&lt;/code&gt; &lt;em&gt;expl&amp;iacute;citamente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f6d860796a5fd822923ee9652b94bac30474c3be" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value</source>
          <target state="translated">Si el índice o el tamaño es negativo,o mayor que el valor permitido</target>
        </trans-unit>
        <trans-unit id="e39e35b0fbc867536af0e669f2cd71c2245083f7" translate="yes" xml:space="preserve">
          <source>If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.</source>
          <target state="translated">Si se espera que se añadan más elementos,simplemente añada esa cantidad extra esperada al parámetro antes de llamar a esto.</target>
        </trans-unit>
        <trans-unit id="053100f3c7f667ff05d2bace27aa288dee22ba26" translate="yes" xml:space="preserve">
          <source>If more precise control is needed, the apostrophe &lt;code&gt;'&lt;/code&gt; can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.</source>
          <target state="translated">Si se necesita un control m&amp;aacute;s preciso, el ap&amp;oacute;strofe &lt;code&gt;'&lt;/code&gt; se puede utilizar en el patr&amp;oacute;n suministrado para indicar los par&amp;aacute;metros de tipo concreto del tipo gen&amp;eacute;rico. Consulte el uso del operador de ap&amp;oacute;strofo en patrones proc para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="ce96d5e60286391515a7cbb0c79e9c3bb3e9d383" translate="yes" xml:space="preserve">
          <source>If nimcache already contains compiled code from a different compiler for the same project, add the &lt;code&gt;-f&lt;/code&gt; flag to force all files to be recompiled.</source>
          <target state="translated">Si nimcache ya contiene c&amp;oacute;digo compilado de un compilador diferente para el mismo proyecto, agregue el indicador &lt;code&gt;-f&lt;/code&gt; para forzar la recompilaci&amp;oacute;n de todos los archivos.</target>
        </trans-unit>
        <trans-unit id="5153d6410770a93b318a519a75636621e9c4c3aa" translate="yes" xml:space="preserve">
          <source>If no data could be retrieved; &lt;code&gt;ReadNone&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se pudieron recuperar datos; Se devuelve &lt;code&gt;ReadNone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec6c8813bd137356b82ff72079b75a071a3a49ec" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="translated">Si no se proporciona un nombre de excepci&amp;oacute;n, se &lt;span id=&quot;reminusraised_1&quot;&gt;vuelve a&lt;/span&gt; generar la excepci&amp;oacute;n actual . La excepci&amp;oacute;n &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; se &lt;span id=&quot;reraiseerror_1&quot;&gt;genera&lt;/span&gt; si no hay ninguna excepci&amp;oacute;n para volver a generar. De ello se deduce que la declaraci&amp;oacute;n de &lt;code&gt;raise&lt;/code&gt; &lt;em&gt;siempre&lt;/em&gt; genera una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bcb6340cf10c05ccf2a7bfa1e1c0783de9d0f0ba" translate="yes" xml:space="preserve">
          <source>If object &lt;code&gt;a&lt;/code&gt; inherits from &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;b&lt;/code&gt;. This subtype relation is extended to the types &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt;:</source>
          <target state="translated">Si el objeto &lt;code&gt;a&lt;/code&gt; hereda de &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; es un subtipo de &lt;code&gt;b&lt;/code&gt; . Esta relaci&amp;oacute;n de subtipo se extiende a los tipos &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="54ad6ae52f22f23880a6fa7417dc9ed9f2690573" translate="yes" xml:space="preserve">
          <source>If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!</source>
          <target state="translated">Si es posible,el parámetro del nombre debe coincidir con el nombre utilizado en la base de datos tz.Si la zona horaria no existe en la base de datos tz,o si el nombre de la zona horaria es desconocido,entonces se puede utilizar cualquier cadena que describa la zona horaria sin ambigüedades.¡Tengan en cuenta que el nombre de la zona horaria se utiliza para comprobar la igualdad!</target>
        </trans-unit>
        <trans-unit id="83cab258bfaceba0e5d7e569b163a43ec079fd90" translate="yes" xml:space="preserve">
          <source>If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string &quot;LOCAL&quot; is used for the systems local timezone.</source>
          <target state="translated">Si es posible,el nombre será el utilizado en la base de datos de tz.Si la zona horaria no existe en la base de datos tz,o si el nombre de la zona horaria es desconocido,entonces se podrá utilizar cualquier cadena que describa la zona horaria sin ambigüedades.Por ejemplo,la cadena &quot;LOCAL&quot; se utiliza para la zona horaria local del sistema.</target>
        </trans-unit>
        <trans-unit id="7d4e5a5abdc253c34bc8994506a514f7e8a3ab93" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Si el enchufe est&amp;aacute; desconectado y no hay datos disponibles para leer, el futuro se completar&amp;aacute; con un valor de &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddadec8d4ad0814aaa2791b6db2a33e17de90113" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Si el enchufe est&amp;aacute; desconectado y no hay datos disponibles para leer, el futuro se completar&amp;aacute; con un valor de &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3029d46833d06111b6e34f35f0929a92d0edb0" translate="yes" xml:space="preserve">
          <source>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</source>
          <target state="translated">Si se desconecta el enchufe durante la operación de recuperación,entonces el futuro puede completarse con sólo una parte de los datos solicitados.</target>
        </trans-unit>
        <trans-unit id="0df46d3074a79a13b57275819c9d87a8439b076c" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;ReadPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">Si se han recuperado algunos datos; Se devuelve &lt;code&gt;ReadPartialLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f385d830d03b348ca6c7d251ed0e117515ba157e" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;RecvPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">Si se han recuperado algunos datos; Se devuelve &lt;code&gt;RecvPartialLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99b6837e1f741f3a2cc549944f6142c90af6d182" translate="yes" xml:space="preserve">
          <source>If statement</source>
          <target state="translated">Si la declaración</target>
        </trans-unit>
        <trans-unit id="841bf5112e092c8cd39e9d2e2357a35f6b5f6da7" translate="yes" xml:space="preserve">
          <source>If the '#' character is present, integers use the 'alternate form' for formatting. This means that binary, octal, and hexadecimal output will be prefixed with '0b', '0o', and '0x', respectively.</source>
          <target state="translated">Si el carácter &quot;#&quot; está presente,los números enteros usan la &quot;forma alternativa&quot; para el formato.Esto significa que la salida binaria,octal y hexadecimal tendrá el prefijo &quot;0b&quot;,&quot;0o&quot; y &quot;0x&quot;,respectivamente.</target>
        </trans-unit>
        <trans-unit id="2701e9b83a0e728206e51f442c68eb180551bc76" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;experimental mode&lt;/a&gt; is active and no other match is found, the first argument &lt;code&gt;a&lt;/code&gt; is dereferenced automatically if it's a pointer type and overloading resolution is tried with &lt;code&gt;a[]&lt;/code&gt; instead.</source>
          <target state="translated">Si el &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;modo experimental&lt;/a&gt; est&amp;aacute; activo y no se encuentra ninguna otra coincidencia, el primer argumento &lt;code&gt;a&lt;/code&gt; se desreferencia autom&amp;aacute;ticamente si es un tipo de puntero y la resoluci&amp;oacute;n de sobrecarga se intenta con &lt;code&gt;a[]&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="30f04b40fb234123c9240535d5420bf04b4bad00" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;line&lt;/code&gt; pragma is used with a parameter, the parameter needs be a &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt;. If it is used without a parameter, &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; is used.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; pragma se usa con un par&amp;aacute;metro, el par&amp;aacute;metro debe ser una &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt; . Si se usa sin un par&amp;aacute;metro, se usa &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc91ac0b9432830816ba69fa3ae8519ab1eeae46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;raise&lt;/code&gt; keyword is not followed by an expression, the last exception is &lt;em&gt;re-raised&lt;/em&gt;. For the purpose of avoiding repeating this common code pattern, the template &lt;code&gt;newException&lt;/code&gt; in the &lt;code&gt;system&lt;/code&gt; module can be used:</source>
          <target state="translated">Si la palabra clave &lt;code&gt;raise&lt;/code&gt; no va seguida de una expresi&amp;oacute;n, se &lt;em&gt;vuelve a &lt;/em&gt;generar la &amp;uacute;ltima excepci&amp;oacute;n . Con el fin de evitar la repetici&amp;oacute;n de este patr&amp;oacute;n de c&amp;oacute;digo com&amp;uacute;n, se puede utilizar la plantilla &lt;code&gt;newException&lt;/code&gt; en el m&amp;oacute;dulo del &lt;code&gt;system&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a29b5294c2d5b8f33f39477a3e8ec43eeb105639" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">Si la opci&amp;oacute;n &lt;code&gt;stackTrace&lt;/code&gt; est&amp;aacute; activada, el C generado contiene c&amp;oacute;digo para garantizar que se proporcionen los seguimientos de pila adecuados si el programa falla o se genera una excepci&amp;oacute;n no detectada.</target>
        </trans-unit>
        <trans-unit id="69353978c65a0ffe1cd9e998af57fe30abaceb6d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;filename&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; will be added. If &lt;em&gt;ext&lt;/em&gt; == &quot;&quot; then any extension is removed. &lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">Si el &lt;em&gt;nombre&lt;/em&gt; del &lt;em&gt;archivo&lt;/em&gt; no tiene extensi&amp;oacute;n, se agregar&amp;aacute; &lt;em&gt;ext&lt;/em&gt; . Si &lt;em&gt;ext&lt;/em&gt; == &quot;&quot; entonces se elimina cualquier extensi&amp;oacute;n. &lt;em&gt;Ext se&lt;/em&gt; debe proporcionar sin el '.' Inicial, porque algunos sistemas de archivos pueden usar un car&amp;aacute;cter diferente. (Aunque no conozco ninguna bestia as&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="79ace98adbbf3c8936f6e66ea8ff73968f01fefd" translate="yes" xml:space="preserve">
          <source>If the GNU assembler is used, quotes and newlines are inserted automatically:</source>
          <target state="translated">Si se usa el ensamblador GNU,las citas y las nuevas líneas se insertan automáticamente:</target>
        </trans-unit>
        <trans-unit id="0f567e3c2047b434a83b4adc7353c2da45d5c2c6" translate="yes" xml:space="preserve">
          <source>If the awaited futures &lt;em&gt;are&lt;/em&gt;&lt;code&gt;Future[void]&lt;/code&gt;, this proc returns &lt;code&gt;Future[void]&lt;/code&gt;.</source>
          <target state="translated">Si los futuros esperados &lt;em&gt;son &lt;/em&gt; &lt;code&gt;Future[void]&lt;/code&gt; , este proceso devuelve &lt;code&gt;Future[void]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa43020aaaa8cf58315161b2bb7c7b775d6b572a" translate="yes" xml:space="preserve">
          <source>If the awaited futures are not &lt;code&gt;Future[void]&lt;/code&gt;, the returned future will hold the values of all awaited futures in a sequence.</source>
          <target state="translated">Si los futuros esperados no son &lt;code&gt;Future[void]&lt;/code&gt; , el futuro devuelto contendr&amp;aacute; los valores de todos los futuros esperados en una secuencia.</target>
        </trans-unit>
        <trans-unit id="5fe1d39f639c6431559fde4aae2a700b0d4ccf44" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;em&gt;EIO&lt;/em&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">Si el archivo no existe, se &lt;em&gt;genera EIO&lt;/em&gt; . Los caracteres de nueva l&amp;iacute;nea finales se eliminan de las l&amp;iacute;neas iteradas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="bafa24e01b0dca07bfac7c2248312106929d5bde" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then an empty string is returned.</source>
          <target state="translated">Si el puntero del archivo está más allá del final del archivo,entonces se devuelve una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="76343cf0f621f6a2b7f316008b6f0e6e56f15e33" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then zero is returned and no bytes are read into &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">Si el puntero del archivo pasa del final del archivo, se devuelve cero y no se leen bytes en &lt;code&gt;buf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9e8d1e3329be3b1efe953e0d47c9f6690b475b1" translate="yes" xml:space="preserve">
          <source>If the for loop expression &lt;code&gt;e&lt;/code&gt; does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to &lt;code&gt;items(e)&lt;/code&gt;; ie. an &lt;code&gt;items&lt;/code&gt; iterator is implicitly invoked:</source>
          <target state="translated">Si la expresi&amp;oacute;n de ciclo for &lt;code&gt;e&lt;/code&gt; no denota un iterador y el ciclo for tiene exactamente 1 variable, la expresi&amp;oacute;n de ciclo for se reescribe en los &lt;code&gt;items(e)&lt;/code&gt; ; es decir. un iterador de &lt;code&gt;items&lt;/code&gt; se invoca impl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="f1948e286ab2aa083c7abdf710bb8b040d1a1433" translate="yes" xml:space="preserve">
          <source>If the for loop has exactly 2 variables, a &lt;code&gt;pairs&lt;/code&gt; iterator is implicitly invoked.</source>
          <target state="translated">Si el bucle for tiene exactamente 2 variables, se invoca impl&amp;iacute;citamente un iterador de &lt;code&gt;pairs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6316f54cbdea61f6ea28df0e5d5c083559be9b99" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="translated">Si el par&amp;aacute;metro formal &lt;code&gt;f&lt;/code&gt; es de tipo &lt;code&gt;var T&lt;/code&gt; adem&amp;aacute;s de la verificaci&amp;oacute;n de tipo ordinaria, se verifica que el argumento sea un &lt;span id=&quot;lminusvalue_1&quot;&gt;valor l&lt;/span&gt; . &lt;code&gt;var T&lt;/code&gt; coincide mejor que solo &lt;code&gt;T&lt;/code&gt; entonces.</target>
        </trans-unit>
        <trans-unit id="06c385a15682548ea060388897b3ee567fedd764" translate="yes" xml:space="preserve">
          <source>If the future stream already has data or is finished then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">Si la transmisi&amp;oacute;n futura ya tiene datos o est&amp;aacute; finalizada , se llamar&amp;aacute; inmediatamente a &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a17c29c098e84ef9b5397d265f349b1b95a392e" translate="yes" xml:space="preserve">
          <source>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</source>
          <target state="translated">Si el manejador no plantea una excepción,el flujo de control ordinario continúa y el programa se termina.</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">Si la aplicación no soporta el tipo de objeto u operación solicitado.</target>
        </trans-unit>
        <trans-unit id="e36df26fc214c0ac51566c4f11deb9d6bc0cf23a" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</source>
          <target state="translated">Si la información no puede ser recuperada,como cuando el manejo del archivo es inválido,se producirá un error.</target>
        </trans-unit>
        <trans-unit id="931654e57ac7ff5e6e25ca20aeac61e7abee7076" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</source>
          <target state="translated">Si la información no puede ser recuperada,como cuando la ruta no existe,o cuando las restricciones de permiso impiden que el programa recupere la información de los archivos,se producirá un error.</target>
        </trans-unit>
        <trans-unit id="c9e1e4f07efdbdfe683f438bf843008ae55e735b" translate="yes" xml:space="preserve">
          <source>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</source>
          <target state="translated">Si el iterador produce una tupla,puede haber tantas variables de iteración como componentes tenga la tupla.El tipo de la variable de iteración es el tipo del componente de la tupla.En otras palabras,se admite el desempaquetamiento implícito de la tupla en un contexto de bucle for.</target>
        </trans-unit>
        <trans-unit id="6f90e673e99dd8f0b56aa326b33eb0d0306fdf75" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second lowest precedence.</source>
          <target state="translated">Si los extremos de operador con &lt;code&gt;=&lt;/code&gt; y su primer car&amp;aacute;cter es ninguno de &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , es un &lt;em&gt;operador de asignaci&amp;oacute;n&lt;/em&gt; que tiene la segunda precedencia m&amp;aacute;s baja.</target>
        </trans-unit>
        <trans-unit id="77d5ae1836106c51a0b36a1a34e1eea987b0968e" translate="yes" xml:space="preserve">
          <source>If the proc declaration has no body, it is a &lt;span id=&quot;forward_1&quot;&gt;forward&lt;/span&gt; declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named &lt;span id=&quot;result_2&quot;&gt;result&lt;/span&gt; that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments. Example:</source>
          <target state="translated">Si la declaraci&amp;oacute;n proc no tiene cuerpo, es una declaraci&amp;oacute;n &lt;span id=&quot;forward_1&quot;&gt;hacia adelante&lt;/span&gt; . Si proc devuelve un valor, el cuerpo del procedimiento puede acceder a una variable declarada impl&amp;iacute;citamente denominada &lt;span id=&quot;result_2&quot;&gt;resultado&lt;/span&gt; que representa el valor devuelto. Los procesos pueden estar sobrecargados. El algoritmo de resoluci&amp;oacute;n de sobrecarga determina qu&amp;eacute; proceso es el mejor para los argumentos. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="7f9553b958c19cddce23d7730df0fa25e4ae656d" translate="yes" xml:space="preserve">
          <source>If the procedure needs to modify the argument for the caller, a &lt;code&gt;var&lt;/code&gt; parameter can be used:</source>
          <target state="translated">Si el procedimiento necesita modificar el argumento de la persona que llama, se puede usar un par&amp;aacute;metro &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ffce8267c957e13dff8b29b02ca2b908de49e40" translate="yes" xml:space="preserve">
          <source>If the result of the future is an error then that error will be raised.</source>
          <target state="translated">Si el resultado del futuro es un error,entonces ese error se elevará.</target>
        </trans-unit>
        <trans-unit id="16b303009a30beca5105d2aa322ae24b48a52b7d" translate="yes" xml:space="preserve">
          <source>If the resulting string is not longer than the original input string, only a single memory allocation is required.</source>
          <target state="translated">Si la cadena resultante no es más larga que la cadena de entrada original,sólo se requiere una única asignación de memoria.</target>
        </trans-unit>
        <trans-unit id="a9b83a69915f2923c508823edf191d18bfe7c62b" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;ReadDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">Si el enchufe se ha desconectado; Se devuelve &lt;code&gt;ReadDisconnected&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f2159e99fd16ad61ca59fb4cff56737dc03dd06" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;RecvDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">Si el enchufe se ha desconectado; Se devuelve &lt;code&gt;RecvDisconnected&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06267d9401718740a7aedde535d821882f38a309" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected in the middle of a line (before &lt;code&gt;\r\L&lt;/code&gt; is read) then line will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;. The partial line &lt;strong&gt;will be lost&lt;/strong&gt;.</source>
          <target state="translated">Si el enchufe se desconecta en medio de una l&amp;iacute;nea (antes de que se lea &lt;code&gt;\r\L&lt;/code&gt; ), la l&amp;iacute;nea se establecer&amp;aacute; en &lt;code&gt;&quot;&quot;&lt;/code&gt; . La l&amp;iacute;nea parcial &lt;strong&gt;se perder&amp;aacute;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="aff4ce46ec1145925961993e78a141b3df5cdc42" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; will be returned.</source>
          <target state="translated">Si el enchufe est&amp;aacute; desconectado, la &lt;code&gt;line&lt;/code&gt; se establecer&amp;aacute; en &lt;code&gt;&quot;&quot;&lt;/code&gt; y se devolver&amp;aacute; &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4152f2601369713f5b3377cbe629187b41c395fa" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Si el enchufe est&amp;aacute; desconectado, la &lt;code&gt;line&lt;/code&gt; se establecer&amp;aacute; en &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7db7153a9dd78804e9f3e45b8ee428bd5b09802b" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, the result will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Si se desconecta el enchufe, el resultado se establecer&amp;aacute; en &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d578dee840a7c31291fc81e023d496e5514d739" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a DOMString Currently not used(Since DOMString is just string)</source>
          <target state="translated">Si el rango de texto especificado no cabe en una DOMString Actualmente no se usa (Ya que DOMString es sólo una cadena)</target>
        </trans-unit>
        <trans-unit id="81b18a9e716c01074670be16ff9f7b2d4da9d53a" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned off, &lt;code&gt;TaintedString&lt;/code&gt; is simply an alias for &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Si el modo de &lt;code&gt;TaintedString&lt;/code&gt; est&amp;aacute; desactivado, TaintedString es simplemente un alias de &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ade66f9e7d10ed2722b60a91ec1dc67330d9fa7" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned on (via the &lt;code&gt;--taintMode:on&lt;/code&gt; command line option) it is a distinct string type which helps to detect input validation errors:</source>
          <target state="translated">Si el modo &lt;code&gt;--taintMode:on&lt;/code&gt; est&amp;aacute; activado (a trav&amp;eacute;s de la opci&amp;oacute;n --taintMode: en la l&amp;iacute;nea de comando), es un tipo de cadena distinto que ayuda a detectar errores de validaci&amp;oacute;n de entrada:</target>
        </trans-unit>
        <trans-unit id="9614b1e1a8be3e96f495969f1af445d51d40d1c3" translate="yes" xml:space="preserve">
          <source>If the template does not have types for its parameters, the type identifiers inside &lt;code&gt;nnkFormalParams&lt;/code&gt; just becomes &lt;code&gt;nnkEmpty&lt;/code&gt;.</source>
          <target state="translated">Si la plantilla no tiene tipos para sus par&amp;aacute;metros, los identificadores de tipo dentro de &lt;code&gt;nnkFormalParams&lt;/code&gt; simplemente se convierten en &lt;code&gt;nnkEmpty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80a4298614b1c88fcba898b49b736115a77cf332" translate="yes" xml:space="preserve">
          <source>If the template has no explicit return type, &lt;code&gt;void&lt;/code&gt; is used for consistency with procs and methods.</source>
          <target state="translated">Si la plantilla no tiene un tipo de retorno expl&amp;iacute;cito, &lt;code&gt;void&lt;/code&gt; se usa para mantener la coherencia con los procesos y m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="bea9fb33db15316176ec096b57a2d7c1faae43c3" translate="yes" xml:space="preserve">
          <source>If the width field is preceded by a zero ('0') character, this enables zero-padding.</source>
          <target state="translated">Si el campo de ancho es precedido por un carácter de cero ('0'),esto permite el relleno de cero.</target>
        </trans-unit>
        <trans-unit id="08e24dc66cc5899916445680c12d07116f7a31f9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;finally&lt;/code&gt; part, it is always executed after the exception handlers.</source>
          <target state="translated">Si hay una parte &lt;code&gt;finally&lt;/code&gt; , siempre se ejecuta despu&amp;eacute;s de los controladores de excepciones.</target>
        </trans-unit>
        <trans-unit id="5403f5f769c6890d6ee94ea9cf83af93e0867d21" translate="yes" xml:space="preserve">
          <source>If there is a &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; clause, it is always executed after the exception handlers.</source>
          <target state="translated">Si hay una cl&amp;aacute;usula &lt;span id=&quot;finally_1&quot;&gt;finalmente&lt;/span&gt; , siempre se ejecuta despu&amp;eacute;s de los manejadores de excepciones.</target>
        </trans-unit>
        <trans-unit id="b016123034bebbefe22ae78b4065b8c3fdf35002" translate="yes" xml:space="preserve">
          <source>If there is no data to be read from the socket &lt;code&gt;False&lt;/code&gt; will be returned.</source>
          <target state="translated">Si no hay datos para leer del socket , se devolver&amp;aacute; &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="675af36ecdb4bc1179580030d8540852cbfd5745" translate="yes" xml:space="preserve">
          <source>If this algorithm returns &quot;ambiguous&quot; further disambiguation is performed: If the argument &lt;code&gt;a&lt;/code&gt; matches both the parameter type &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; of &lt;code&gt;q&lt;/code&gt; via a subtyping relation, the inheritance depth is taken into account:</source>
          <target state="translated">Si este algoritmo devuelve &quot;ambiguo&quot;, se realiza una mayor desambiguaci&amp;oacute;n: si el argumento &lt;code&gt;a&lt;/code&gt; coincide con el tipo de par&amp;aacute;metro &lt;code&gt;f&lt;/code&gt; de &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;g&lt;/code&gt; de &lt;code&gt;q&lt;/code&gt; mediante una relaci&amp;oacute;n de subtipificaci&amp;oacute;n, se tiene en cuenta la profundidad de la herencia:</target>
        </trans-unit>
        <trans-unit id="fa135c30bca2146e78a4a18c707a6e4c9777b26c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the attributes from &lt;em&gt;source&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt;. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions()&lt;/a&gt;.</source>
          <target state="translated">Si esto falla, se &lt;em&gt;genera OSError&lt;/em&gt; . En la plataforma Windows, este proceso copiar&amp;aacute; los atributos de la &lt;em&gt;fuente&lt;/em&gt; a &lt;em&gt;dest&lt;/em&gt; . En otras plataformas, los archivos y directorios creados heredar&amp;aacute;n los permisos predeterminados de un archivo / directorio reci&amp;eacute;n creado para el usuario. Para conservar los atributos de forma recursiva en estas plataformas, utilice &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba7406fce433f75c1da2d28edafd72b5ca2511c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; proc), otherwise &lt;em&gt;dest&lt;/em&gt; will inherit the default permissions of a newly created file for the user. If &lt;em&gt;dest&lt;/em&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="translated">Si esto falla, se &lt;em&gt;genera OSError&lt;/em&gt; . En la plataforma Windows, este proceso copiar&amp;aacute; los atributos del archivo fuente en dest. En otras plataformas, es necesario utilizar &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions ()&lt;/a&gt; y &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions ()&lt;/a&gt; para copiarlos a mano (o utilizar la conveniencia &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; proc), de lo contrario, &lt;em&gt;dest&lt;/em&gt; heredar&amp;aacute; los permisos predeterminados de un archivo reci&amp;eacute;n creado para el usuario. Si &lt;em&gt;dest&lt;/em&gt; ya existe, los atributos del archivo se conservar&amp;aacute;n y el contenido se sobrescribir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="1c44eb8131bad6bf3fd6310d51476fb0e8f9dddf" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This does not fail if the directory never existed in the first place.</source>
          <target state="translated">Si esto falla, se &lt;em&gt;genera OSError&lt;/em&gt; . Esto no falla si el directorio nunca existi&amp;oacute; en primer lugar.</target>
        </trans-unit>
        <trans-unit id="b23ad4f30781ff872aab84374d7929409d46858b" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; on non Windows platforms. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">Si esto falla, se &lt;em&gt;genera OSError&lt;/em&gt; . Este es un proceso de envoltura alrededor de &lt;a href=&quot;#copyDir&quot;&gt;copyDir ()&lt;/a&gt; y &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; en plataformas que no son Windows. En Windows, este proceso es solo un contenedor para &lt;a href=&quot;#copyDir&quot;&gt;copyDir ()&lt;/a&gt; ya que ese proceso ya copia atributos.</target>
        </trans-unit>
        <trans-unit id="c9a699519eb4bcfd6e9b388099f313da1c21a6c3" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;from ... import&lt;/code&gt;, the result is different, too.</source>
          <target state="translated">Si usamos &lt;code&gt;from ... import&lt;/code&gt; , el resultado tambi&amp;eacute;n es diferente.</target>
        </trans-unit>
        <trans-unit id="6d41cc53a37945c747c32e0bc6d03f91d352c9cd" translate="yes" xml:space="preserve">
          <source>If you are using simple standard types like &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt; for the keys of the table you won't have any problems, but as soon as you try to use a more complex object as a key you will be greeted by a strange compiler error:</source>
          <target state="translated">Si est&amp;aacute; utilizando tipos est&amp;aacute;ndar simples como &lt;code&gt;int&lt;/code&gt; o &lt;code&gt;string&lt;/code&gt; para las claves de la tabla, no tendr&amp;aacute; ning&amp;uacute;n problema, pero tan pronto como intente usar un objeto m&amp;aacute;s complejo como clave, recibir&amp;aacute; un extra&amp;ntilde;o error del compilador:</target>
        </trans-unit>
        <trans-unit id="a61618067feb2692a61a1309fe70a37f092e0dcd" translate="yes" xml:space="preserve">
          <source>If you don't want to run all the test case files you can pass any substring as a parameter to &lt;code&gt;caasdriver&lt;/code&gt;. Only files matching the passed substring will be run. The filtering doesn't use any globbing metacharacters, it's a plain match. For example, to run only &lt;code&gt;*-compile*.txt&lt;/code&gt; tests in verbose mode:</source>
          <target state="translated">Si no desea ejecutar todos los archivos de casos de prueba, puede pasar cualquier subcadena como par&amp;aacute;metro a &lt;code&gt;caasdriver&lt;/code&gt; . Solo se ejecutar&amp;aacute;n los archivos que coincidan con la subcadena pasada. El filtrado no utiliza metacaracteres globulares, es una coincidencia sencilla. Por ejemplo, para ejecutar solo &lt;code&gt;*-compile*.txt&lt;/code&gt; en modo detallado:</target>
        </trans-unit>
        <trans-unit id="3b65c5702c4312fa92bc7a7a75f7b1cedc2ffdcc" translate="yes" xml:space="preserve">
          <source>If you hyper link a plain name symbol and there are other matches on the same HTML file, most browsers will go to the first one. To differentiate the rest, you will need to use the complex name. A complex name for a callable type is made up from several parts:</source>
          <target state="translated">Si enlaza un símbolo de nombre simple y hay otras coincidencias en el mismo archivo HTML,la mayoría de los navegadores irán al primero.Para diferenciar el resto,necesitarás usar el nombre complejo.Un nombre complejo para un tipo llamable se compone de varias partes:</target>
        </trans-unit>
        <trans-unit id="d77f4e6941e6c25de4bc7bce05e47c82dde3f100" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="translated">Si sabe lo que est&amp;aacute; haciendo, tambi&amp;eacute;n puede marcar objetos de una sola cadena (o secuencia) como &lt;span id=&quot;shallow_1&quot;&gt;poco profundos&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="5c5621699cffb5f6aa7c0cfe6aad046283804e80" translate="yes" xml:space="preserve">
          <source>If you need a asynchronous server socket but you wish to process the clients synchronously then you can use the &lt;code&gt;getSocket&lt;/code&gt; converter to get a &lt;code&gt;Socket&lt;/code&gt; from the &lt;code&gt;AsyncSocket&lt;/code&gt; object, this can then be combined with &lt;code&gt;accept&lt;/code&gt; like so:</source>
          <target state="translated">Si necesita un socket de servidor as&amp;iacute;ncrono pero desea procesar los clientes de manera s&amp;iacute;ncrona, puede usar el convertidor &lt;code&gt;getSocket&lt;/code&gt; para obtener un &lt;code&gt;Socket&lt;/code&gt; del objeto &lt;code&gt;AsyncSocket&lt;/code&gt; , esto luego se puede combinar con &lt;code&gt;accept&lt;/code&gt; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="006ed832ed732b3be5a2f86089a58493d5e5cace" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the keys you can use &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq()&lt;/a&gt; on the iterator. Usage example:</source>
          <target state="translated">Si necesita una secuencia con las claves, puede usar &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq ()&lt;/a&gt; en el iterador. Ejemplo de uso:</target>
        </trans-unit>
        <trans-unit id="33cbb4e4f9774399c5110d17e6f93b09e6789def" translate="yes" xml:space="preserve">
          <source>If you need to &lt;em&gt;access&lt;/em&gt; the actual exception object or message inside an &lt;code&gt;except&lt;/code&gt; branch you can use the &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException()&lt;/a&gt; and &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg()&lt;/a&gt; procs from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Example:</source>
          <target state="translated">Si necesita &lt;em&gt;acceder&lt;/em&gt; al objeto o mensaje de excepci&amp;oacute;n real dentro de una rama &lt;code&gt;except&lt;/code&gt; , puede usar los &lt;a href=&quot;system#getCurrentException&quot;&gt;procesos getCurrentException ()&lt;/a&gt; y &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg ()&lt;/a&gt; desde el m&amp;oacute;dulo del &lt;a href=&quot;system&quot;&gt;sistema&lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="369d846e4c1b566404807c8b598a810efa4157ad" translate="yes" xml:space="preserve">
          <source>If you need to allow the rst &lt;code&gt;include&lt;/code&gt; directive or tweak the generated output you have to create your own &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and related procs.</source>
          <target state="translated">Si necesita permitir la primera directiva de &lt;code&gt;include&lt;/code&gt; o modificar la salida generada, debe crear su propio &lt;code&gt;RstGenerator&lt;/code&gt; con &lt;code&gt;initRstGenerator&lt;/code&gt; y procesos relacionados.</target>
        </trans-unit>
        <trans-unit id="6e0f3b7f2a6e094f5e44833f3b6b6ef4c156c0ee" translate="yes" xml:space="preserve">
          <source>If you need to create multiple identifiers you need to use the lower level &lt;code&gt;newNimNode&lt;/code&gt;:</source>
          <target state="translated">Si necesita crear varios identificadores, debe utilizar el nivel inferior &lt;code&gt;newNimNode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d0579aebab140b65d01d9ce28fdabf2191699ecf" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the GC. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="translated">Si necesita pasar la memoria asignada por Nim a C, puede usar los &lt;code&gt;GC_ref&lt;/code&gt; y &lt;code&gt;GC_unref&lt;/code&gt; para marcar objetos como referenciados para evitar que el GC los libere. Otros procesos &amp;uacute;tiles del &lt;a href=&quot;system&quot;&gt;sistema&lt;/a&gt; que puede utilizar para realizar un seguimiento de la memoria son:</target>
        </trans-unit>
        <trans-unit id="605d3be2a51e005f46c2c854f15f5f73980b42f0" translate="yes" xml:space="preserve">
          <source>If you use Nim's flexible calling syntax (as in &lt;code&gt;x.len()&lt;/code&gt;), the result is the same as above but wrapped in an &lt;code&gt;nnkCall&lt;/code&gt;.</source>
          <target state="translated">Si usa la sintaxis de llamada flexible de Nim (como en &lt;code&gt;x.len()&lt;/code&gt; ), el resultado es el mismo que el anterior pero envuelto en una &lt;code&gt;nnkCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaabbf0881b8169255900fc2e0a496ccef7b23be" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</source>
          <target state="translated">Si utiliza esta función,no necesita usar asyncdispatch.recv()o asyncdispatch.accept(),porque están usando IOCP,por favor use nativesockets.recv()y nativesockets.accept()en su lugar.</target>
        </trans-unit>
        <trans-unit id="1badf00dcf0f3800f03821ebc8ea8986cacd6adb" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</source>
          <target state="translated">Si usas esta función,no necesitas usar asyncdispatch.send()o asyncdispatch.connect(),porque están usando IOCP,por favor usa nativesockets.send()y nativesockets.connect()en su lugar.</target>
        </trans-unit>
        <trans-unit id="cac223c9791d80e68510ee018f308f5d57991c7e" translate="yes" xml:space="preserve">
          <source>If you want to add the &lt;code&gt;{.raises.}&lt;/code&gt; pragma to existing code, the compiler can also help you. You can add the &lt;code&gt;{.effects.}&lt;/code&gt; pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim &lt;code&gt;doc2&lt;/code&gt; command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's &lt;a href=&quot;manual#effect-system&quot;&gt;effect system and related pragmas in the manual&lt;/a&gt;.</source>
          <target state="translated">Si desea agregar el &lt;code&gt;{.raises.}&lt;/code&gt; c&amp;oacute;digo existente, el compilador tambi&amp;eacute;n puede ayudarlo. Puede agregar la &lt;code&gt;{.effects.}&lt;/code&gt; pragma {.effects.} A su proceso y el compilador generar&amp;aacute; todos los efectos inferidos hasta ese punto (el seguimiento de excepciones es parte del sistema de efectos de Nim). Otra forma m&amp;aacute;s indirecta de averiguar la lista de excepciones generadas por un proc es usar el comando Nim &lt;code&gt;doc2&lt;/code&gt; que genera documentaci&amp;oacute;n para un m&amp;oacute;dulo completo y decora todos los procs con la lista de excepciones generadas. Puede leer m&amp;aacute;s sobre el &lt;a href=&quot;manual#effect-system&quot;&gt;sistema de efectos&lt;/a&gt; de Nim y los pragmas relacionados en el manual .</target>
        </trans-unit>
        <trans-unit id="d0c0f4c00b1012d51fb6739c3f68752cf2b7b509" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types you will end up writing the following kind of skeleton of code:</source>
          <target state="translated">Si quieres implementar hash procs para tus tipos personalizados terminarás escribiendo el siguiente tipo de esqueleto de código:</target>
        </trans-unit>
        <trans-unit id="421d4b3269fa42e83ec4575e39cc5f8f9348120c" translate="yes" xml:space="preserve">
          <source>If you want to reset the state of a global variable on each reload, just re-assign a value anywhere within the top-level code:</source>
          <target state="translated">Si quieres restablecer el estado de una variable global en cada recarga,sólo tienes que reasignar un valor en cualquier lugar dentro del código de nivel superior:</target>
        </trans-unit>
        <trans-unit id="95147b50335541913ec2b4cdcd60beea22400d5c" translate="yes" xml:space="preserve">
          <source>If you want to reuse this feature in your own documentation you will have to modify &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; to contain a &lt;code&gt;doc.item.seesrc&lt;/code&gt; value with a hyper link to your own code repository. As you will see by the comments in that file, the value &lt;code&gt;txt&lt;/code&gt; passed on the command line will be used in the HTML template along others like &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$line&lt;/code&gt;.</source>
          <target state="translated">Si desea reutilizar esta caracter&amp;iacute;stica en su propia documentaci&amp;oacute;n, tendr&amp;aacute; que modificar &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; para que contenga un valor &lt;code&gt;doc.item.seesrc&lt;/code&gt; con un hiperv&amp;iacute;nculo a su propio repositorio de c&amp;oacute;digo. Como ver&amp;aacute; por los comentarios en ese archivo, el valor &lt;code&gt;txt&lt;/code&gt; pasado en la l&amp;iacute;nea de comando se usar&amp;aacute; en la plantilla HTML junto con otros como &lt;code&gt;$path&lt;/code&gt; y &lt;code&gt;$line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52843b664ac77e24f197735860350aeff2499277" translate="yes" xml:space="preserve">
          <source>If you want to start the server using stdin/stdout as communication you need to type:</source>
          <target state="translated">Si quieres iniciar el servidor usando stdin/stdout como comunicación tienes que escribir:</target>
        </trans-unit>
        <trans-unit id="5faec14ac2e7f3a0dbf5ac1fc6670f916e429298" translate="yes" xml:space="preserve">
          <source>If you want to start the server using tcp and a port, you need to type:</source>
          <target state="translated">Si quieres iniciar el servidor usando tcp y un puerto,tienes que escribir:</target>
        </trans-unit>
        <trans-unit id="0e57ef06f554ec131431cf7cc7b3e87b3087eb9a" translate="yes" xml:space="preserve">
          <source>If you would like to remove the callback simply set it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Si desea eliminar la devoluci&amp;oacute;n de llamada, simplemente config&amp;uacute;relo en &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af0996b6e01e303c65f963b0e8fbe7eeea90dc53" translate="yes" xml:space="preserve">
          <source>If your custom types contain fields for which there already is a hash proc, like for example objects made up of &lt;code&gt;strings&lt;/code&gt;, you can simply hash together the hash value of the individual fields:</source>
          <target state="translated">Si sus tipos personalizados contienen campos para los que ya existe un proceso de hash, como por ejemplo, objetos formados por &lt;code&gt;strings&lt;/code&gt; , simplemente puede combinar el valor hash de los campos individuales:</target>
        </trans-unit>
        <trans-unit id="ee7d8473b3b03509d036a9e18c0f69477806dbbf" translate="yes" xml:space="preserve">
          <source>Ignoring the return value of a procedure without using a discard statement is a static error.</source>
          <target state="translated">Ignorar el valor de retorno de un procedimiento sin usar una declaración de descarte es un error estático.</target>
        </trans-unit>
        <trans-unit id="234aba6f014c3210479a86e1f7e85db4fc781aa3" translate="yes" xml:space="preserve">
          <source>Implementation Specific Pragmas</source>
          <target state="translated">Implementación de Pragmas específicos</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Detalles de la implementación</target>
        </trans-unit>
        <trans-unit id="e4c1e2458dab48a54a1e7f70dcc8c85f1ecef51b" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;span id=&quot;deque_1&quot;&gt;deque&lt;/span&gt; (double-ended queue). The underlying implementation uses a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">Implementaci&amp;oacute;n de una &lt;span id=&quot;deque_1&quot;&gt;deque&lt;/span&gt; (cola de dos extremos). La implementaci&amp;oacute;n subyacente usa una &lt;code&gt;seq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7a46b17c56770ce055c6ddb62375ac14462a9c" translate="yes" xml:space="preserve">
          <source>Implementation of singly and doubly linked lists. Because it makes no sense to do so, the 'next' and 'prev' pointers are not hidden from you and can be manipulated directly for efficiency.</source>
          <target state="translated">Implementación de listas de enlaces simples y dobles.Porque no tiene sentido hacerlo,los puntos &quot;siguiente&quot; y &quot;anterior&quot; no se le ocultan y pueden ser manipulados directamente por eficiencia.</target>
        </trans-unit>
        <trans-unit id="a6c736db4db506401e673a9f4f1f349ad3e618b7" translate="yes" xml:space="preserve">
          <source>Implements Nim's 'spawn'.</source>
          <target state="translated">Implementa la &quot;semilla&quot; de Nim.</target>
        </trans-unit>
        <trans-unit id="36d95a1a4e4b67185b0210fb79bcd67e7997dd49" translate="yes" xml:space="preserve">
          <source>Implict items/pairs invocations</source>
          <target state="translated">Implantar las invocaciones de los artículos/pares</target>
        </trans-unit>
        <trans-unit id="3ed691724b16d193322f0f4e5a05ffaa21ad149b" translate="yes" xml:space="preserve">
          <source>Import section</source>
          <target state="translated">Sección de importación</target>
        </trans-unit>
        <trans-unit id="e1814134be9eb4b4edfac453d80420ef792ece15" translate="yes" xml:space="preserve">
          <source>Import statement</source>
          <target state="translated">Declaración de importación</target>
        </trans-unit>
        <trans-unit id="13f50b27b1067e54a93395faae2bf7e5ac61b5af" translate="yes" xml:space="preserve">
          <source>ImportCpp pragma</source>
          <target state="translated">ImportCpp pragma</target>
        </trans-unit>
        <trans-unit id="1a87c0305fa3a21d3483f32794feeb2ede2ded57" translate="yes" xml:space="preserve">
          <source>ImportObjC pragma</source>
          <target state="translated">ImportObjC pragma</target>
        </trans-unit>
        <trans-unit id="b131713cc5dd52d93c263e9eaa3064820c90d46d" translate="yes" xml:space="preserve">
          <source>Importc pragma</source>
          <target state="translated">Importa pragmatismo</target>
        </trans-unit>
        <trans-unit id="26fce7795dc194794340bfe9430c05967fd0f0b6" translate="yes" xml:space="preserve">
          <source>Importcpp for enums</source>
          <target state="translated">Importación de enums</target>
        </trans-unit>
        <trans-unit id="13bc024961b54b45de0538df5d4d8a1057ce09e2" translate="yes" xml:space="preserve">
          <source>Importcpp for objects</source>
          <target state="translated">Importación de objetos</target>
        </trans-unit>
        <trans-unit id="c0f89463b661b1c831d73789e1f9b7febf176bb2" translate="yes" xml:space="preserve">
          <source>Importcpp for procs</source>
          <target state="translated">Importcpp para los procedimientos</target>
        </trans-unit>
        <trans-unit id="2a87ed2bec73f0f4c4783390b3b8eb37f3539383" translate="yes" xml:space="preserve">
          <source>Imported exceptions</source>
          <target state="translated">Excepciones importadas</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="651038eb78adfd6971475066b4835457bc4c8cee" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document</source>
          <target state="translated">Importa un nodo de otro documento a este documento</target>
        </trans-unit>
        <trans-unit id="c57c28d05a963f62cc6e0646415b874f5ec5d460" translate="yes" xml:space="preserve">
          <source>Impure libraries</source>
          <target state="translated">Bibliotecas impuras</target>
        </trans-unit>
        <trans-unit id="fd75085c09d97b8e3bec53c3d230c26383e2dd2b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;if&lt;/code&gt; statements new scopes begin immediately after the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; keywords and ends after the corresponding &lt;em&gt;then&lt;/em&gt; block. For visualization purposes the scopes have been enclosed in &lt;code&gt;{| |}&lt;/code&gt; in the following example:</source>
          <target state="translated">En las declaraciones &lt;code&gt;if&lt;/code&gt; , los nuevos alcances comienzan inmediatamente despu&amp;eacute;s de las palabras clave &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; y terminan despu&amp;eacute;s del bloque &lt;em&gt;then&lt;/em&gt; correspondiente . Para fines de visualizaci&amp;oacute;n, los &amp;aacute;mbitos se han incluido en &lt;code&gt;{| |}&lt;/code&gt; en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="f8b317a37aea00acb6907f904d75b22bdcc1d94d" translate="yes" xml:space="preserve">
          <source>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module defines an exception hierarchy that you might want to stick to. Exceptions derive from &lt;code&gt;system.Exception&lt;/code&gt;, which provides the common interface.</source>
          <target state="translated">En Nim, las excepciones son objetos. Por convenci&amp;oacute;n, los tipos de excepciones tienen el sufijo &quot;Error&quot;. El m&amp;oacute;dulo del &lt;a href=&quot;system&quot;&gt;sistema&lt;/a&gt; define una jerarqu&amp;iacute;a de excepciones a la que es posible que desee ce&amp;ntilde;irse. Las excepciones se derivan de &lt;code&gt;system.Exception&lt;/code&gt; , que proporciona la interfaz com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="bcd1f399e06fb598711f24d731eec160a7ac7612" translate="yes" xml:space="preserve">
          <source>In Nim new types can be defined within a &lt;code&gt;type&lt;/code&gt; statement:</source>
          <target state="translated">En Nim, se pueden definir nuevos tipos dentro de una declaraci&amp;oacute;n de &lt;code&gt;type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b627b4840bb1e194f3e870e54e41a26eeaaa32b6" translate="yes" xml:space="preserve">
          <source>In Nim the compiler cannot always know if a reference is stored on the stack or not. This is caused by var parameters. Consider this example:</source>
          <target state="translated">En Nim el compilador no siempre puede saber si una referencia está almacenada en la pila o no.Esto es causado por los parámetros var.Considera este ejemplo:</target>
        </trans-unit>
        <trans-unit id="3c1e31b69bdf6fd850da3e70033d8d8c55e35892" translate="yes" xml:space="preserve">
          <source>In Nim there is a distinction between &lt;em&gt;simple statements&lt;/em&gt; and &lt;em&gt;complex statements&lt;/em&gt;. &lt;em&gt;Simple statements&lt;/em&gt; cannot contain other statements: Assignment, procedure calls or the &lt;code&gt;return&lt;/code&gt; statement belong to the simple statements. &lt;em&gt;Complex statements&lt;/em&gt; like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:</source>
          <target state="translated">En Nim hay una distinci&amp;oacute;n entre &lt;em&gt;declaraciones simples&lt;/em&gt; y &lt;em&gt;declaraciones complejas&lt;/em&gt; . &lt;em&gt;Las declaraciones simples&lt;/em&gt; no pueden contener otras declaraciones: la asignaci&amp;oacute;n, las llamadas a procedimientos o la declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; pertenecen a las declaraciones simples. &lt;em&gt;Declaraciones complejas&lt;/em&gt; como &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; pueden contener otras declaraciones. Para evitar ambig&amp;uuml;edades, las declaraciones complejas siempre deben estar sangradas, pero las declaraciones simples simples no:</target>
        </trans-unit>
        <trans-unit id="36d31e1fe2a898ddbcb325dce9d25ddd964de3ec" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values greater than 128 never match &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, and always match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. This is true even when Unicode character property support is available.</source>
          <target state="translated">En el modo UTF-8, los caracteres con valores superiores a 128 no coinciden &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , o &lt;code&gt;\w&lt;/code&gt; , y siempre coinciden &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , y &lt;code&gt;\W&lt;/code&gt; . Esto es cierto incluso cuando se dispone de compatibilidad con propiedades de caracteres Unicode.</target>
        </trans-unit>
        <trans-unit id="3617947965a09e75ebe2e8b672a9f2c8fd3657b4" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; statement tuple unpacking can be performed. The special identifier &lt;code&gt;_&lt;/code&gt; can be used to ignore some parts of the tuple:</source>
          <target state="translated">En una instrucci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; o &lt;code&gt;let&lt;/code&gt; , se puede realizar un desempaquetado de tuplas. El identificador especial &lt;code&gt;_&lt;/code&gt; se puede utilizar para ignorar algunas partes de la tupla:</target>
        </trans-unit>
        <trans-unit id="82817ac3f312f0760fba2fa577dfeca03d6206c4" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported at compiletime.</source>
          <target state="translated">En una llamada &lt;code&gt;p(args)&lt;/code&gt; la rutina &lt;code&gt;p&lt;/code&gt; que mejor se adapta. Si varias rutinas coinciden igualmente bien, la ambig&amp;uuml;edad se informa en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6fc62f480a3f9078cee56fe51f6444a9d5250214" translate="yes" xml:space="preserve">
          <source>In a list of statements every expression except the last one needs to have the type &lt;code&gt;void&lt;/code&gt;. In addition to this rule an assignment to the builtin &lt;code&gt;result&lt;/code&gt; symbol also triggers a mandatory &lt;code&gt;void&lt;/code&gt; context for the subsequent expressions:</source>
          <target state="translated">En una lista de declaraciones, todas las expresiones, excepto la &amp;uacute;ltima, deben tener el tipo &lt;code&gt;void&lt;/code&gt; . Adem&amp;aacute;s de esta regla, una asignaci&amp;oacute;n al s&amp;iacute;mbolo de &lt;code&gt;result&lt;/code&gt; ado incorporado tambi&amp;eacute;n desencadena un contexto &lt;code&gt;void&lt;/code&gt; obligatorio para las siguientes expresiones:</target>
        </trans-unit>
        <trans-unit id="488140be7cd1e3d7c93b424038a2aded23329152" translate="yes" xml:space="preserve">
          <source>In a multi-method all parameters that have an object type are used for the dispatching:</source>
          <target state="translated">En un multimétodo se utilizan todos los parámetros que tienen un tipo de objeto para el envío:</target>
        </trans-unit>
        <trans-unit id="51b365021e4df4ac8585444b431ae5bb9f1b96ec" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the GC by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, or &lt;code&gt;allocCStringArray&lt;/code&gt;. The GC won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs when you are done with them or they will leak.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;code&gt;GC_ref&lt;/code&gt; y &lt;code&gt;GC_unref&lt;/code&gt; , puede evitar el GC asignando memoria manualmente con &lt;code&gt;alloc&lt;/code&gt; como alloc , &lt;code&gt;allocShared&lt;/code&gt; o &lt;code&gt;allocCStringArray&lt;/code&gt; . El GC no intentar&amp;aacute; liberarlos, debe llamar a sus respectivos pares de &lt;em&gt;dealloc&lt;/em&gt; cuando haya terminado con ellos o se filtrar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="590bed6910696c3c90f97fbde2ce87692b87d870" translate="yes" xml:space="preserve">
          <source>In addition to fields, routine applications are also rewritten, but only if no other interpretation of the call is possible:</source>
          <target state="translated">Además de los campos,las aplicaciones de rutina también se reescriben,pero sólo si no es posible otra interpretación de la llamada:</target>
        </trans-unit>
        <trans-unit id="3c1eb48be581c9adefbce7b80eb339a9d4bdac6f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;untyped&lt;/code&gt; meta-type that prevents type checking there is also &lt;code&gt;varargs[untyped]&lt;/code&gt; so that not even the number of parameters is fixed:</source>
          <target state="translated">Adem&amp;aacute;s de la &lt;code&gt;untyped&lt;/code&gt; del tipo meta que previene la comprobaci&amp;oacute;n de tipos tambi&amp;eacute;n hay &lt;code&gt;varargs[untyped]&lt;/code&gt; de modo que ni siquiera el n&amp;uacute;mero de par&amp;aacute;metros es fijo:</target>
        </trans-unit>
        <trans-unit id="387616e73907f1f0c0f9c9b26be0a31bf6568eb0" translate="yes" xml:space="preserve">
          <source>In addition to the previous levels dumps a debug stack trace for compiler developers.</source>
          <target state="translated">Además de los niveles anteriores descarga un rastro de la pila de depuración para los desarrolladores del compilador.</target>
        </trans-unit>
        <trans-unit id="fa62a58dee28a4f60ea67a6c8e5a270a2279ae13" translate="yes" xml:space="preserve">
          <source>In addition to the usual arithmetic operators for signed and unsigned integers (&lt;code&gt;+ - *&lt;/code&gt; etc.) there are also operators that formally work on &lt;em&gt;signed&lt;/em&gt; integers but treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the &lt;code&gt;%&lt;/code&gt; suffix as convention:</source>
          <target state="translated">Adem&amp;aacute;s de los operadores aritm&amp;eacute;ticos habituales para enteros con y sin signo ( &lt;code&gt;+ - *&lt;/code&gt; etc.), tambi&amp;eacute;n hay operadores que trabajan formalmente con enteros con &lt;em&gt;signo,&lt;/em&gt; pero tratan sus argumentos como &lt;em&gt;sin signo&lt;/em&gt; : se proporcionan principalmente para compatibilidad con versiones anteriores del lenguaje que carec&amp;iacute;a de tipos enteros sin signo. Estas operaciones sin firmar para enteros con signo usan el sufijo &lt;code&gt;%&lt;/code&gt; como convenci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a505d4cbc395f14732ae7d9715a2d71dbaa23d6d" translate="yes" xml:space="preserve">
          <source>In all descendant types of the object type.</source>
          <target state="translated">En todos los tipos de descendientes del tipo de objeto.</target>
        </trans-unit>
        <trans-unit id="8255fdf45779c837c0b26b5faea383860b8d458a" translate="yes" xml:space="preserve">
          <source>In both cases the server will start up and await further commands. The syntax of the commands you can now send to the server is practically the same as running the nim compiler on the commandline, you only need to remove the name of the compiler since you are already talking to it. The server will answer with as many lines of text it thinks necessary plus an empty line to indicate the end of the answer.</source>
          <target state="translated">En ambos casos el servidor se iniciará y esperará más órdenes.La sintaxis de los comandos que puedes enviar al servidor es prácticamente la misma que la del compilador nim en la línea de comandos,sólo tienes que eliminar el nombre del compilador ya que ya estás hablando con él.El servidor responderá con tantas líneas de texto como crea necesario más una línea vacía para indicar el final de la respuesta.</target>
        </trans-unit>
        <trans-unit id="87fcb4c9412aaaad5556b10d061891f17209ecf3" translate="yes" xml:space="preserve">
          <source>In contrast to that, a &lt;span id=&quot;closure-iterator_1&quot;&gt;closure iterator&lt;/span&gt; can be passed around more freely:</source>
          <target state="translated">En contraste con eso, un &lt;span id=&quot;closure-iterator_1&quot;&gt;iterador de cierre&lt;/span&gt; se puede pasar m&amp;aacute;s libremente:</target>
        </trans-unit>
        <trans-unit id="d690804e9c35517f69d4546186980d7be8f2789c" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace.</source>
          <target state="translated">En el modo de depuración las excepciones almacenan el rastro de la pila que les llevó a ellas.Una StackTraceEntry es una entrada única del rastro de la pila.</target>
        </trans-unit>
        <trans-unit id="af9ba250b7498b9006c490eda9c8a41290e0b66a" translate="yes" xml:space="preserve">
          <source>In every module compilation, reset the variable to its default value.</source>
          <target state="translated">En cada compilación de módulos,reajuste la variable a su valor por defecto.</target>
        </trans-unit>
        <trans-unit id="b9d14a65a6bcb84eea05fa7cf43ef339b198f107" translate="yes" xml:space="preserve">
          <source>In fact, a trailing comma is allowed for every tuple construction.</source>
          <target state="translated">De hecho,se permite una coma en cada tupla de construcción.</target>
        </trans-unit>
        <trans-unit id="d9e80bc5993cb0fc4644c16fb07461ebb339b897" translate="yes" xml:space="preserve">
          <source>In fact, this decribes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="translated">De hecho, esto describe c&amp;oacute;mo se debe almacenar el AST en la base de datos, como un &amp;aacute;rbol &quot;superficial&quot;. Supongamos que compilamos el m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; con el siguiente contenido:</target>
        </trans-unit>
        <trans-unit id="d7200c67cd9ab4646acaefd95fd28854405ad659" translate="yes" xml:space="preserve">
          <source>In general the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.</source>
          <target state="translated">En general,la declaración de caso se utiliza para los tipos de subgama o enumeraciones en que es de gran ayuda que el compilador compruebe que usted cubrió cualquier valor posible.</target>
        </trans-unit>
        <trans-unit id="df2250e080bf643576540d132cb54644051a2eb3" translate="yes" xml:space="preserve">
          <source>In general, declaring types mirrors this syntax (i.e., &lt;code&gt;nnkStaticTy&lt;/code&gt; for &lt;code&gt;static&lt;/code&gt;, etc.). Examples follow (exceptions marked by &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">En general, la declaraci&amp;oacute;n de tipos refleja esta sintaxis (es decir, &lt;code&gt;nnkStaticTy&lt;/code&gt; para &lt;code&gt;static&lt;/code&gt; , etc.). A continuaci&amp;oacute;n se muestran algunos ejemplos (excepciones marcadas con &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="1393a34bf1d4daea288238586a51eb0e1faccf00" translate="yes" xml:space="preserve">
          <source>In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no &lt;em&gt;devel&lt;/em&gt; packages need to be installed.</source>
          <target state="translated">En general, la importaci&amp;oacute;n de una biblioteca din&amp;aacute;mica no requiere ninguna opci&amp;oacute;n especial de vinculaci&amp;oacute;n o vinculaci&amp;oacute;n con bibliotecas de importaci&amp;oacute;n. Esto tambi&amp;eacute;n implica que no es necesario instalar paquetes de &lt;em&gt;desarrollo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0d0713666c6f10149634654fda5f08d4b39e3997" translate="yes" xml:space="preserve">
          <source>In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.</source>
          <target state="translated">Sin embargo,en casos muy concretos (un bucle de envío de un intérprete de códigos de bytes,por ejemplo)puede resultar beneficioso.</target>
        </trans-unit>
        <trans-unit id="ccadb2f2afa462fe0a8e3a89f264df971c7a74b0" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim allows you to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, &lt;code&gt;type&lt;/code&gt; is considered their special type.</source>
          <target state="translated">En muchos contextos, Nim le permite tratar los nombres de tipos como valores regulares. Estos valores existen solo durante la fase de compilaci&amp;oacute;n, pero como todos los valores deben tener un tipo, el &lt;code&gt;type&lt;/code&gt; se considera su tipo especial.</target>
        </trans-unit>
        <trans-unit id="92effa90645c39523ba9f53c9bfe7bc808f9c10d" translate="yes" xml:space="preserve">
          <source>In normal debug and release builds code within a &lt;code&gt;runnableExamples&lt;/code&gt; section is ignored.</source>
          <target state="translated">En las versiones normales de depuraci&amp;oacute;n y publicaci&amp;oacute;n , se ignora el c&amp;oacute;digo dentro de una secci&amp;oacute;n de &lt;code&gt;runnableExamples&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fce6426da4fa8e50461c5a84f0b4bb26d70a6f7" translate="yes" xml:space="preserve">
          <source>In order to begin any sort of transfer of files you must first connect to an FTP server. You can do so with the &lt;code&gt;connect&lt;/code&gt; procedure.</source>
          <target state="translated">Para comenzar cualquier tipo de transferencia de archivos, primero debe conectarse a un servidor FTP. Puede hacerlo con el procedimiento de &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b84c550d9a8232bb0005f5c64c0b247f3554dd" translate="yes" xml:space="preserve">
          <source>In order to check for symbols accepting &lt;code&gt;type&lt;/code&gt; params, you must prefix the type with the explicit &lt;code&gt;type&lt;/code&gt; modifier. The named instance of the type, following the &lt;code&gt;concept&lt;/code&gt; keyword is also considered to have the explicit modifier and will be matched only as a type.</source>
          <target state="translated">Para comprobar si los s&amp;iacute;mbolos aceptan par&amp;aacute;metros de &lt;code&gt;type&lt;/code&gt; , debe anteponer el tipo con el modificador de &lt;code&gt;type&lt;/code&gt; expl&amp;iacute;cito . La instancia nombrada del tipo, que sigue a la palabra clave &lt;code&gt;concept&lt;/code&gt; , tambi&amp;eacute;n se considera que tiene el modificador expl&amp;iacute;cito y solo se comparar&amp;aacute; como un tipo.</target>
        </trans-unit>
        <trans-unit id="ea6a479b9d25899b927b071796e99387ee4ff9e8" translate="yes" xml:space="preserve">
          <source>In order to compile Nim correctly, type-checking has to be separated from parsing. Otherwise generics cannot work.</source>
          <target state="translated">Para compilar Nim correctamente,el chequeo de tipos tiene que ser separado del análisis.De otra manera los genericos no pueden trabajar.</target>
        </trans-unit>
        <trans-unit id="f3802bfad258aac8c84f9a57c30500e4a9483a31" translate="yes" xml:space="preserve">
          <source>In order to encode some text simply call the &lt;code&gt;encode&lt;/code&gt; procedure:</source>
          <target state="translated">Para codificar alg&amp;uacute;n texto, simplemente llame al procedimiento de &lt;code&gt;encode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a773d5bee7ad3c817ebe19e70c4e28c0ee6b821" translate="yes" xml:space="preserve">
          <source>In order to simplify structural type checking, recursive tuples are not valid:</source>
          <target state="translated">Para simplificar la comprobación del tipo estructural,las tuplas recursivas no son válidas:</target>
        </trans-unit>
        <trans-unit id="312ff897ae89606cffe84af5ae7f281fbffba243" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag.</source>
          <target state="translated">Para utilizar los procedimientos SSL definidos en este m&amp;oacute;dulo, necesitar&amp;aacute; compilar su aplicaci&amp;oacute;n con el indicador &lt;code&gt;-d:ssl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="560248995a8c3109fbb872863af1490f690d2896" translate="yes" xml:space="preserve">
          <source>In ordinary object oriented languages, procedures (also called &lt;em&gt;methods&lt;/em&gt;) are bound to a class. This has disadvantages:</source>
          <target state="translated">En los lenguajes orientados a objetos ordinarios, los procedimientos (tambi&amp;eacute;n llamados &lt;em&gt;m&amp;eacute;todos&lt;/em&gt; ) est&amp;aacute;n vinculados a una clase. Esto tiene desventajas:</target>
        </trans-unit>
        <trans-unit id="95f94a22baed9e59f27d8a4126864041ec912710" translate="yes" xml:space="preserve">
          <source>In other words, the lifetime of what &lt;code&gt;result&lt;/code&gt; points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the callsite.</source>
          <target state="translated">En otras palabras, el tiempo de vida de lo que apunta el &lt;code&gt;result&lt;/code&gt; ado se adjunta al tiempo de vida del primer par&amp;aacute;metro y ese es el conocimiento suficiente para verificar la seguridad de la memoria en el sitio de llamada.</target>
        </trans-unit>
        <trans-unit id="102f6667e274b32df706ad020620d76cc4f12944" translate="yes" xml:space="preserve">
          <source>In other words, the macro needs to transform the full &lt;code&gt;case&lt;/code&gt; statement but only the statement's selector expression is used to determine which macro to call.</source>
          <target state="translated">En otras palabras, la macro necesita transformar la declaraci&amp;oacute;n de &lt;code&gt;case&lt;/code&gt; completa , pero solo se usa la expresi&amp;oacute;n del selector de la declaraci&amp;oacute;n para determinar a qu&amp;eacute; macro llamar.</target>
        </trans-unit>
        <trans-unit id="f0ffdfd405410c78e024047ef7872e44df7c644e" translate="yes" xml:space="preserve">
          <source>In practice, things are worse still, consider &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt;. We only know the root is &lt;code&gt;someGlobal&lt;/code&gt; but the concrete path to the data is unknown as is the value that is added. We could compute a &quot;diff&quot; between the global states and use that to compute a symbol patchset, but this is quite some work, expensive to do at runtime (it would need to run after every module has been compiled) and also would break for hash tables.</source>
          <target state="translated">En la pr&amp;aacute;ctica, las cosas est&amp;aacute;n peor a&amp;uacute;n, considere &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt; . Solo sabemos que la ra&amp;iacute;z es &lt;code&gt;someGlobal&lt;/code&gt; , pero se desconoce la ruta concreta a los datos, al igual que el valor que se agrega. Podr&amp;iacute;amos calcular una &quot;diferencia&quot; entre los estados globales y usarla para calcular un conjunto de parches de s&amp;iacute;mbolos, pero esto es bastante trabajo, costoso de hacer en tiempo de ejecuci&amp;oacute;n (tendr&amp;iacute;a que ejecutarse despu&amp;eacute;s de que se haya compilado cada m&amp;oacute;dulo) y tambi&amp;eacute;n se interrumpir&amp;iacute;a por tablas hash.</target>
        </trans-unit>
        <trans-unit id="b855cc2f2c105e6dd103557865ed5b380e3a2628" translate="yes" xml:space="preserve">
          <source>In raw literals the backslash is not an escape character.</source>
          <target state="translated">En los textos crudos,la barra invertida no es un personaje de escape.</target>
        </trans-unit>
        <trans-unit id="c7f10b9ab29ce16208f7daf440d19bf68a4e424e" translate="yes" xml:space="preserve">
          <source>In templates identifiers can be constructed with the backticks notation:</source>
          <target state="translated">En las plantillas se pueden construir identificadores con la anotación de los palillos:</target>
        </trans-unit>
        <trans-unit id="b2768586236fda36fbb8835c6640e3bbf9f72b7a" translate="yes" xml:space="preserve">
          <source>In the above example, because the string ends in a period, to get the portion of the string that is &quot;useless&quot; and replace it with &quot;useful&quot;.</source>
          <target state="translated">En el ejemplo anterior,debido a que la cuerda termina en un período,para obtener la porción de la cuerda que es &quot;inútil&quot; y sustituirla por &quot;útil&quot;.</target>
        </trans-unit>
        <trans-unit id="1c735dfcff9ac999e211c2de3309c6b523627b0e" translate="yes" xml:space="preserve">
          <source>In the above example, providing the -d flag causes the symbol &lt;code&gt;FooBar&lt;/code&gt; to be overwritten at compile time, printing out 42. If the &lt;code&gt;-d:FooBar=42&lt;/code&gt; were to be omitted, the default value of 5 would be used.</source>
          <target state="translated">En el ejemplo anterior, proporcionar la bandera -d hace que el s&amp;iacute;mbolo &lt;code&gt;FooBar&lt;/code&gt; se sobrescriba en tiempo de compilaci&amp;oacute;n, imprimiendo 42. Si se &lt;code&gt;-d:FooBar=42&lt;/code&gt; se usar&amp;iacute;a el valor predeterminado de 5.</target>
        </trans-unit>
        <trans-unit id="6ef0c534b48c5ddbaf66e5a1fa0de3c409abe7be" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;recv&lt;/code&gt; function will return a brand new &lt;code&gt;Future&lt;/code&gt; instance once the request for data to be read from the socket is made. This &lt;code&gt;Future&lt;/code&gt; instance will complete once the requested amount of data is read, in this case it is 100 bytes. The second line sets a callback on this future which will be called once the future completes. All the callback does is write the data stored in the future to &lt;code&gt;stdout&lt;/code&gt;. The &lt;code&gt;read&lt;/code&gt; function is used for this and it checks whether the future completes with an error for you (if it did it will simply raise the error), if there is no error however it returns the value of the future.</source>
          <target state="translated">En el ejemplo anterior, la funci&amp;oacute;n &lt;code&gt;recv&lt;/code&gt; devolver&amp;aacute; una nueva instancia &lt;code&gt;Future&lt;/code&gt; una vez que se realice la solicitud de lectura de datos desde el socket. Esta instancia de &lt;code&gt;Future&lt;/code&gt; se completar&amp;aacute; una vez que se lea la cantidad de datos solicitada, en este caso, son 100 bytes. La segunda l&amp;iacute;nea establece una devoluci&amp;oacute;n de llamada en este futuro que se llamar&amp;aacute; una vez que se complete el futuro. Todo lo que hace la devoluci&amp;oacute;n de llamada es escribir los datos almacenados en el futuro en &lt;code&gt;stdout&lt;/code&gt; . La funci&amp;oacute;n de &lt;code&gt;read&lt;/code&gt; se usa para esto y verifica si el futuro se completa con un error para usted (si lo hizo, simplemente generar&amp;aacute; el error), si no hay error, sin embargo, devuelve el valor del futuro.</target>
        </trans-unit>
        <trans-unit id="21c40f021cb3285301a10da6c518a7dfee56f66a" translate="yes" xml:space="preserve">
          <source>In the above example, the search loop is unrolled by a factor 4. The unroll factor can be left out too; the compiler then chooses an appropriate unroll factor.</source>
          <target state="translated">En el ejemplo anterior,el bucle de búsqueda se desenrolla por un factor 4.El factor de desenrollado también se puede omitir;el compilador elige entonces un factor de desenrollado apropiado.</target>
        </trans-unit>
        <trans-unit id="447fba0bf5092295ea3ef5df369d20395a2954e0" translate="yes" xml:space="preserve">
          <source>In the age of HTTP, HTML, FTP, TCP, IP, UTF, WWW it is foolish to pretend these are somewhat special words requiring all uppercase. Instead treat them as what they are: Real words. So it's &lt;code&gt;parseUrl&lt;/code&gt; rather than &lt;code&gt;parseURL&lt;/code&gt;, &lt;code&gt;checkHttpHeader&lt;/code&gt; instead of &lt;code&gt;checkHTTPHeader&lt;/code&gt; etc.</source>
          <target state="translated">En la era de HTTP, HTML, FTP, TCP, IP, UTF, WWW, es una tonter&amp;iacute;a pretender que son palabras un tanto especiales que requieren todas las may&amp;uacute;sculas. En cambio, tr&amp;aacute;telos como lo que son: palabras reales. Entonces es &lt;code&gt;parseUrl&lt;/code&gt; en lugar de &lt;code&gt;parseURL&lt;/code&gt; , &lt;code&gt;checkHttpHeader&lt;/code&gt; en lugar de &lt;code&gt;checkHTTPHeader&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="1aaaccd5328576322733f4b1a0d0cfc0189406e9" translate="yes" xml:space="preserve">
          <source>In the case of Nim's own documentation, the &lt;code&gt;txt&lt;/code&gt; value is just a commit hash to append to a formatted URL to &lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim&lt;/a&gt;. The &lt;code&gt;tools/nimweb.nim&lt;/code&gt; helper queries the current git commit hash during doc generation, but since you might be working on an unpublished repository, it also allows specifying a &lt;code&gt;githash&lt;/code&gt; value in &lt;code&gt;web/website.ini&lt;/code&gt; to force a specific commit in the output.</source>
          <target state="translated">En el caso de la propia documentaci&amp;oacute;n de Nim, el valor &lt;code&gt;txt&lt;/code&gt; es solo un hash de confirmaci&amp;oacute;n para agregar a una URL formateada en &lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim&lt;/a&gt; . El helper &lt;code&gt;tools/nimweb.nim&lt;/code&gt; consulta el hash de confirmaci&amp;oacute;n de git actual durante la generaci&amp;oacute;n del documento, pero dado que es posible que est&amp;eacute; trabajando en un repositorio no publicado, tambi&amp;eacute;n permite especificar un valor de &lt;code&gt;githash&lt;/code&gt; en &lt;code&gt;web/website.ini&lt;/code&gt; para forzar una confirmaci&amp;oacute;n espec&amp;iacute;fica en la salida.</target>
        </trans-unit>
        <trans-unit id="222b18bf0bb9eca48a64b5eb7ba691094c380acc" translate="yes" xml:space="preserve">
          <source>In the current implementation &lt;code&gt;FloatDivByZeroError&lt;/code&gt; and &lt;code&gt;FloatInexactError&lt;/code&gt; are never raised. &lt;code&gt;FloatOverflowError&lt;/code&gt; is raised instead of &lt;code&gt;FloatDivByZeroError&lt;/code&gt;. There is also a &lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks&lt;/span&gt; pragma that is a short-cut for the combination of &lt;code&gt;nanChecks&lt;/code&gt; and &lt;code&gt;infChecks&lt;/code&gt; pragmas. &lt;code&gt;floatChecks&lt;/code&gt; are turned off as default.</source>
          <target state="translated">En la implementaci&amp;oacute;n actual, &lt;code&gt;FloatDivByZeroError&lt;/code&gt; y &lt;code&gt;FloatInexactError&lt;/code&gt; nunca se generan . &lt;code&gt;FloatOverflowError&lt;/code&gt; se genera en lugar de &lt;code&gt;FloatDivByZeroError&lt;/code&gt; . Tambi&amp;eacute;n hay un &lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks&lt;/span&gt; pragma que es un atajo para la combinaci&amp;oacute;n de &lt;code&gt;nanChecks&lt;/code&gt; y &lt;code&gt;infChecks&lt;/code&gt; pragmas. &lt;code&gt;floatChecks&lt;/code&gt; est&amp;aacute;n desactivados por defecto.</target>
        </trans-unit>
        <trans-unit id="bff2144a51b7a2c294698601ad8d94335ce9f207" translate="yes" xml:space="preserve">
          <source>In the example &lt;code&gt;name&lt;/code&gt; is instantiated with &lt;code&gt;myint&lt;/code&gt;, so `T name` becomes &lt;code&gt;Tmyint&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo, el &lt;code&gt;name&lt;/code&gt; se instancia con &lt;code&gt;myint&lt;/code&gt; , por lo que `T name` se convierte en &lt;code&gt;Tmyint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3d915c7fda05ffa880f1a94fe575c45d57c7e6" translate="yes" xml:space="preserve">
          <source>In the example a new pragma named &lt;code&gt;rtl&lt;/code&gt; is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.</source>
          <target state="translated">En el ejemplo, se introduce un nuevo pragma llamado &lt;code&gt;rtl&lt;/code&gt; que importa un s&amp;iacute;mbolo de una biblioteca din&amp;aacute;mica o exporta el s&amp;iacute;mbolo para generar una biblioteca din&amp;aacute;mica.</target>
        </trans-unit>
        <trans-unit id="93f65483d248fc770a9b18bebde69fbd09a74d5c" translate="yes" xml:space="preserve">
          <source>In the example a tree structure is declared with the &lt;code&gt;Node&lt;/code&gt; type. Note that the type definition is recursive and the GC has to assume that objects of this type may form a cyclic graph. The &lt;code&gt;acyclic&lt;/code&gt; pragma passes the information that this cannot happen to the GC. If the programmer uses the &lt;code&gt;acyclic&lt;/code&gt; pragma for data types that are in reality cyclic, the GC may leak memory, but nothing worse happens.</source>
          <target state="translated">En el ejemplo, una estructura de &amp;aacute;rbol se declara con el tipo de &lt;code&gt;Node&lt;/code&gt; . Tenga en cuenta que la definici&amp;oacute;n de tipo es recursiva y el GC debe asumir que los objetos de este tipo pueden formar un gr&amp;aacute;fico c&amp;iacute;clico. El pragma &lt;code&gt;acyclic&lt;/code&gt; transmite la informaci&amp;oacute;n de que esto no puede suceder al GC. Si el programador usa el pragma &lt;code&gt;acyclic&lt;/code&gt; para tipos de datos que en realidad son c&amp;iacute;clicos, el GC puede perder memoria, pero no ocurre nada peor.</target>
        </trans-unit>
        <trans-unit id="c223baf4c7b9145e95ff7b9ff3609cc1168a5f2c" translate="yes" xml:space="preserve">
          <source>In the example c2nim treats the declaration of &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; as if it has been defined via &lt;code&gt;#def&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo, c2nim trata la declaraci&amp;oacute;n de &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; como si se hubiera definido mediante &lt;code&gt;#def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4931fb24c88d4a3add48a67517bb1d6df1d7d83b" translate="yes" xml:space="preserve">
          <source>In the example the &lt;code&gt;kind&lt;/code&gt; field is called the &lt;span id=&quot;discriminator_1&quot;&gt;discriminator&lt;/span&gt;: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. For an object branch switch &lt;code&gt;system.reset&lt;/code&gt; has to be used. Also, when the fields of a particular branch are specified during object construction, the correct value for the discriminator must be supplied at compile-time.</source>
          <target state="translated">En el ejemplo, el campo de &lt;code&gt;kind&lt;/code&gt; se llama &lt;span id=&quot;discriminator_1&quot;&gt;discriminador&lt;/span&gt; : por seguridad, su direcci&amp;oacute;n no se puede tomar y las asignaciones a &amp;eacute;l est&amp;aacute;n restringidas: el nuevo valor no debe provocar un cambio de la rama del objeto activo. Para una rama de objeto, se debe usar &lt;code&gt;system.reset&lt;/code&gt; . Adem&amp;aacute;s, cuando los campos de una rama en particular se especifican durante la construcci&amp;oacute;n del objeto, se debe proporcionar el valor correcto para el discriminador en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f870d1827ccced8c4dc81fc21ba54ed53d3b7fa4" translate="yes" xml:space="preserve">
          <source>In the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because they should use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">En el ejemplo, los constructores &lt;code&gt;newLit&lt;/code&gt; y &lt;code&gt;newPlus&lt;/code&gt; son procs porque deber&amp;iacute;an usar un enlace est&amp;aacute;tico, pero &lt;code&gt;eval&lt;/code&gt; es un m&amp;eacute;todo porque requiere un enlace din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="ffcf0c9fc73817d81ec1bb90e18296fae7f0e1e3" translate="yes" xml:space="preserve">
          <source>In the example the external name of &lt;code&gt;p&lt;/code&gt; is set to &lt;code&gt;prefixp&lt;/code&gt;. Only &lt;code&gt;$1&lt;/code&gt; is available and a literal dollar sign must be written as &lt;code&gt;$$&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo, el nombre externo de &lt;code&gt;p&lt;/code&gt; se establece en &lt;code&gt;prefixp&lt;/code&gt; . Solo &lt;code&gt;$1&lt;/code&gt; est&amp;aacute; disponible y un signo de d&amp;oacute;lar literal debe escribirse como &lt;code&gt;$$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="207cdaa4265565920d4f81786bf2ce395e20de1e" translate="yes" xml:space="preserve">
          <source>In the example the generic &lt;code&gt;==&lt;/code&gt; for tuples (as defined in the system module) uses the &lt;code&gt;==&lt;/code&gt; operators of the tuple's components. However, the &lt;code&gt;==&lt;/code&gt; for the &lt;code&gt;Index&lt;/code&gt; type is defined &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;==&lt;/code&gt; for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.</source>
          <target state="translated">En el ejemplo, el &lt;code&gt;==&lt;/code&gt; gen&amp;eacute;rico para tuplas (como se define en el m&amp;oacute;dulo del sistema) usa los operadores &lt;code&gt;==&lt;/code&gt; de los componentes de la tupla. Sin embargo, el &lt;code&gt;==&lt;/code&gt; para el &lt;code&gt;Index&lt;/code&gt; tipo se define &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; la &lt;code&gt;==&lt;/code&gt; para tuplas; sin embargo, el ejemplo se compila ya que la instanciaci&amp;oacute;n tambi&amp;eacute;n tiene en cuenta los s&amp;iacute;mbolos definidos actualmente.</target>
        </trans-unit>
        <trans-unit id="e3d09a6862f895be9685356eda8db42c91b15ade" translate="yes" xml:space="preserve">
          <source>In the example the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;body&lt;/code&gt; parameter. The &lt;code&gt;withFile&lt;/code&gt; template contains boilerplate code and helps to avoid a common bug: to forget to close the file. Note how the &lt;code&gt;let fn = filename&lt;/code&gt; statement ensures that &lt;code&gt;filename&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">En el ejemplo, las dos sentencias &lt;code&gt;writeLine&lt;/code&gt; est&amp;aacute;n vinculadas al par&amp;aacute;metro &lt;code&gt;body&lt;/code&gt; . La plantilla &lt;code&gt;withFile&lt;/code&gt; contiene c&amp;oacute;digo repetitivo y ayuda a evitar un error com&amp;uacute;n: olvidar cerrar el archivo. Observe c&amp;oacute;mo la declaraci&amp;oacute;n &lt;code&gt;let fn = filename&lt;/code&gt; garantiza que el &lt;code&gt;filename&lt;/code&gt; se eval&amp;uacute;e solo una vez.</target>
        </trans-unit>
        <trans-unit id="6e573c188d155c097bab8635e952a84f3906a513" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. Note that the above example would better make use of a tuple as a return value instead of using var parameters.</source>
          <target state="translated">En el ejemplo, &lt;code&gt;res&lt;/code&gt; y el &lt;code&gt;remainder&lt;/code&gt; son &lt;em&gt;par&amp;aacute;metros var&lt;/em&gt; . Los par&amp;aacute;metros de Var pueden ser modificados por el procedimiento y los cambios son visibles para la persona que llama. Tenga en cuenta que el ejemplo anterior har&amp;iacute;a mejor uso de una tupla como valor de retorno en lugar de usar par&amp;aacute;metros var.</target>
        </trans-unit>
        <trans-unit id="e99258ef6102af84c3e85eb151f26d0965f922fd" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. The argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers. The above example is equivalent to:</source>
          <target state="translated">En el ejemplo, &lt;code&gt;res&lt;/code&gt; y el &lt;code&gt;remainder&lt;/code&gt; son &lt;em&gt;par&amp;aacute;metros var&lt;/em&gt; . Los par&amp;aacute;metros de Var pueden ser modificados por el procedimiento y los cambios son visibles para la persona que llama. El argumento pasado a un par&amp;aacute;metro var debe ser un valor l. Los par&amp;aacute;metros Var se implementan como punteros ocultos. El ejemplo anterior es equivalente a:</target>
        </trans-unit>
        <trans-unit id="2ce83aae39fe686c17231fc96b454e933bdbf835" translate="yes" xml:space="preserve">
          <source>In the example, the case branches &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.</source>
          <target state="translated">En el ejemplo, las ramas de caso &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; son mucho m&amp;aacute;s comunes que los otros casos. Por lo tanto, el c&amp;oacute;digo de ensamblador generado debe probar estos valores primero, de modo que el predictor de rama de la CPU tenga una buena oportunidad de tener &amp;eacute;xito (evitando una costosa parada de la tuber&amp;iacute;a de la CPU). Los otros casos podr&amp;iacute;an colocarse en una tabla de salto para O (1) sobrecarga, pero a costa de una (muy probable) p&amp;eacute;rdida de la tuber&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="449891737730fed7e4e9e268f5440bde8cd00a54" translate="yes" xml:space="preserve">
          <source>In the example, the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;actions&lt;/code&gt; parameter.</source>
          <target state="translated">En el ejemplo, las dos instrucciones &lt;code&gt;writeLine&lt;/code&gt; est&amp;aacute;n vinculadas al par&amp;aacute;metro &lt;code&gt;actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05f29e9409204f7156a8b49a6edfe66f0ff90993" translate="yes" xml:space="preserve">
          <source>In the examples, var parameters or pointers are used to provide two return values. This can be done in a cleaner way by returning a tuple:</source>
          <target state="translated">En los ejemplos,los parámetros var o punteros se utilizan para proporcionar dos valores de retorno.Esto puede hacerse de una manera más limpia devolviendo una tupla:</target>
        </trans-unit>
        <trans-unit id="cf1b069c247f4187c31c21ebbe40e040b094bad5" translate="yes" xml:space="preserve">
          <source>In the following sections &lt;em&gt;global&lt;/em&gt; means &lt;em&gt;shared between modules&lt;/em&gt; or &lt;em&gt;property of the whole program&lt;/em&gt;.</source>
          <target state="translated">En las siguientes secciones, &lt;em&gt;los&lt;/em&gt; medios &lt;em&gt;globales &lt;/em&gt;&lt;em&gt;compartidos entre m&amp;oacute;dulos&lt;/em&gt; o &lt;em&gt;propiedad de todo el programa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f42fa9bad92a4bca57282426b4b7870e70495fb5" translate="yes" xml:space="preserve">
          <source>In the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.</source>
          <target state="translated">En el ejemplo anterior,los cortes se utilizan para modificar una parte de una cadena.Los límites de la rebanada pueden contener cualquier valor soportado por su tipo,pero es el proc.usando el objeto rebanada el que define qué valores son aceptados.</target>
        </trans-unit>
        <trans-unit id="d9143e669402c29ee0475ca379b33b947a4800d5" translate="yes" xml:space="preserve">
          <source>In the previous sections the &lt;code&gt;NimMain()&lt;/code&gt; function reared its head. Since JavaScript already provides automatic memory management, you can freely pass objects between the two language without problems. In C and derivate languages you need to be careful about what you do and how you share memory. The previous examples only dealt with simple scalar values, but passing a Nim string to C, or reading back a C string in Nim already requires you to be aware of who controls what to avoid crashing.</source>
          <target state="translated">En las secciones anteriores, la funci&amp;oacute;n &lt;code&gt;NimMain()&lt;/code&gt; cabeza. Dado que JavaScript ya proporciona administraci&amp;oacute;n autom&amp;aacute;tica de memoria, puede pasar objetos libremente entre los dos idiomas sin problemas. En C y lenguajes derivados, debe tener cuidado con lo que hace y c&amp;oacute;mo comparte la memoria. Los ejemplos anteriores solo trataban con valores escalares simples, pero pasar una cadena Nim a C, o leer una cadena C en Nim, ya requiere que sepa qui&amp;eacute;n controla qu&amp;eacute; para evitar fallar.</target>
        </trans-unit>
        <trans-unit id="1678b121aeb51003f37c84a3a8b55dda38dde0ae" translate="yes" xml:space="preserve">
          <source>In the standard library every name of a routine that returns a &lt;code&gt;var&lt;/code&gt; type starts with the prefix &lt;code&gt;m&lt;/code&gt; per convention.</source>
          <target state="translated">En la biblioteca est&amp;aacute;ndar, cada nombre de una rutina que devuelve un tipo &lt;code&gt;var&lt;/code&gt; comienza con el prefijo &lt;code&gt;m&lt;/code&gt; por convenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3573423166a3714205c4fd8df064a462e9f793fc" translate="yes" xml:space="preserve">
          <source>In this context, a line is any string seperated by a newline combination. A line can be an empty string.</source>
          <target state="translated">En este contexto,una línea es cualquier cadena separada por una nueva combinación de líneas.Una línea puede ser una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="f0c0be54e609e08ad5ac67f5c3b4c12362798deb" translate="yes" xml:space="preserve">
          <source>In this example &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. Note that &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; applied to strings is a nop.</source>
          <target state="translated">En este ejemplo, &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; se aplica a cualquier argumento que se pase al par&amp;aacute;metro &lt;code&gt;a&lt;/code&gt; . Tenga en cuenta que &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; aplicado a cadenas es un nop.</target>
        </trans-unit>
        <trans-unit id="cd49a3b7329e865d00fe88035f180e3a31be031d" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;$&lt;/code&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. (Note that &lt;code&gt;$&lt;/code&gt; applied to strings is a nop.)</source>
          <target state="translated">En este ejemplo, &lt;code&gt;$&lt;/code&gt; se aplica a cualquier argumento que se pase al par&amp;aacute;metro &lt;code&gt;a&lt;/code&gt; . (Tenga en cuenta que &lt;code&gt;$&lt;/code&gt; aplicado a cadenas es un nop.)</target>
        </trans-unit>
        <trans-unit id="caf41cefb1ec542e92b76fcef06da5301961d50c" translate="yes" xml:space="preserve">
          <source>In this example both macros are combined seamlessly in order to maximise efficiency and perform different checks.</source>
          <target state="translated">En este ejemplo,ambas macros se combinan a la perfección para maximizar la eficiencia y realizar diferentes comprobaciones.</target>
        </trans-unit>
        <trans-unit id="fbd15640684b666f33817b98a57e6ad3f6b44475" translate="yes" xml:space="preserve">
          <source>In this example custom pragmas are used to describe how Nim objects are mapped to the schema of the relational database. Custom pragmas can have zero or more arguments. In order to pass multiple arguments use one of template call syntaxes. All arguments are typed and follow standard overload resolution rules for templates. Therefore, it is possible to have default values for arguments, pass by name, varargs, etc.</source>
          <target state="translated">En este ejemplo se utilizan pragmas personalizados para describir cómo se asignan los objetos Nim al esquema de la base de datos relacional.Los pragmas personalizados pueden tener cero o más argumentos.Para pasar múltiples argumentos usa una de las sintaxis de llamada de la plantilla.Todos los argumentos son tecleados y siguen las reglas estándar de resolución de sobrecarga para las plantillas.Por lo tanto,es posible tener valores por defecto para los argumentos,pasar por nombre,varargs,etc.</target>
        </trans-unit>
        <trans-unit id="664c924f4e9ba31a6bee85a98d981b31c47a324a" translate="yes" xml:space="preserve">
          <source>In this example, we define a helper proc &lt;code&gt;someSep&lt;/code&gt; that skips some separators which we then use in our scanf pattern to help us in the matching process:</source>
          <target state="translated">En este ejemplo, definimos un helper proc &lt;code&gt;someSep&lt;/code&gt; que omite algunos separadores que luego usamos en nuestro patr&amp;oacute;n scanf para ayudarnos en el proceso de comparaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="534570485c11beb7704f319727846b8b4f022eb5" translate="yes" xml:space="preserve">
          <source>Include statement</source>
          <target state="translated">Incluya la declaración</target>
        </trans-unit>
        <trans-unit id="bbc642ae58ad84741186ba01bd7a4f6256a9bccf" translate="yes" xml:space="preserve">
          <source>Includes &lt;em&gt;key&lt;/em&gt; in the set &lt;em&gt;s&lt;/em&gt; and tells if &lt;em&gt;key&lt;/em&gt; was added to &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Incluye &lt;em&gt;clave&lt;/em&gt; en el conjunto &lt;em&gt;sy&lt;/em&gt; indica si la &lt;em&gt;clave&lt;/em&gt; se agreg&amp;oacute; a &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64f932923a0eaeac8401c0d332e7ec2bbdcdc32c" translate="yes" xml:space="preserve">
          <source>Includes all elements from &lt;em&gt;other&lt;/em&gt; into &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Incluye todos los elementos de &lt;em&gt;otros&lt;/em&gt; en &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1bf1db1ba56c9fed3c108674752a59dfcd9da4" translate="yes" xml:space="preserve">
          <source>Includes an element &lt;em&gt;key&lt;/em&gt; in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Incluye una &lt;em&gt;clave de&lt;/em&gt; elemento en &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="122d72fb5f4934f490f955173c3eef92832e3bcb" translate="yes" xml:space="preserve">
          <source>IncompleteStruct pragma</source>
          <target state="translated">Pragmatismo de estructura incompleta</target>
        </trans-unit>
        <trans-unit id="e458e98e024804e2195312b10a3a11a67d6582fd" translate="yes" xml:space="preserve">
          <source>Increments an ordinal</source>
          <target state="translated">Incrementa un ordinal</target>
        </trans-unit>
        <trans-unit id="3579152b0f13082bc2ed763d516b6eeee04f5e41" translate="yes" xml:space="preserve">
          <source>Increments in place a floating point number</source>
          <target state="translated">Incrementos en el lugar de un número de punto flotante</target>
        </trans-unit>
        <trans-unit id="3917b825256b71ec29e2860d96b9f3c57a46e2bf" translate="yes" xml:space="preserve">
          <source>Indent with two spaces.</source>
          <target state="translated">Con dos espacios en blanco.</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="3e69016e62b22706518f7fd44403f71f6f86a464" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;const&lt;/code&gt; keyword to list a whole section of constants:</source>
          <target state="translated">La sangr&amp;iacute;a se puede usar despu&amp;eacute;s de la palabra clave &lt;code&gt;const&lt;/code&gt; para enumerar una secci&amp;oacute;n completa de constantes:</target>
        </trans-unit>
        <trans-unit id="6f45c825c4626280194b953ea0dec3e48ce7fccc" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;var&lt;/code&gt; keyword to list a whole section of variables:</source>
          <target state="translated">La sangr&amp;iacute;a se puede usar despu&amp;eacute;s de la palabra clave &lt;code&gt;var&lt;/code&gt; para enumerar una secci&amp;oacute;n completa de variables:</target>
        </trans-unit>
        <trans-unit id="520792c3a2538ee8e56f0b4f71803ca37955634d" translate="yes" xml:space="preserve">
          <source>Indents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">Cada l&amp;iacute;nea de guiones &lt;code&gt;s&lt;/code&gt; por &lt;code&gt;count&lt;/code&gt; cantidad de &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="f2171e3002af9c53c4ea2469894d127d907cca3e" translate="yes" xml:space="preserve">
          <source>Index (idx) file format</source>
          <target state="translated">Formato de archivo índice (idx)</target>
        </trans-unit>
        <trans-unit id="7086b5dce7145d779101ccd8901d9bbb698cae3d" translate="yes" xml:space="preserve">
          <source>Index files are line oriented and tab separated (newline and tab characters have to be escaped). Each line represents a record with at least two fields, but can have up to four (additional columns are ignored). The content of these columns is:</source>
          <target state="translated">Los archivos de índice están orientados a la línea y separados por tabuladores (los caracteres de la nueva línea y del tabulador tienen que escaparse).Cada línea representa un registro con al menos dos campos,pero puede tener hasta cuatro (las columnas adicionales se ignoran).El contenido de estas columnas es:</target>
        </trans-unit>
        <trans-unit id="0c5d6204871842ba1c9f7cd8b0f7f94f787509f2" translate="yes" xml:space="preserve">
          <source>Index switch</source>
          <target state="translated">Interruptor de índice</target>
        </trans-unit>
        <trans-unit id="7d2d080b9c23631882a620ee4cef31b37b3e5e98" translate="yes" xml:space="preserve">
          <source>Index the collection with the proc provided.</source>
          <target state="translated">Indice la colección con el procedimiento proporcionado.</target>
        </trans-unit>
        <trans-unit id="9b0343473193cfc7e99b7802a4d65dded5509d30" translate="yes" xml:space="preserve">
          <source>Indicates that a leading space should be used on positive numbers.</source>
          <target state="translated">Indica que se debe usar un espacio de liderazgo en los números positivos.</target>
        </trans-unit>
        <trans-unit id="2c549fa4a0ba269a959c6226777ab5a0b50f1df5" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used for both positive as well as negative numbers.</source>
          <target state="translated">Indica que se debe utilizar un signo tanto para los números positivos como para los negativos.</target>
        </trans-unit>
        <trans-unit id="a0c8cf09bdbe9d14558c3f28be789e07866609de" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used only for negative numbers (this is the default behavior).</source>
          <target state="translated">Indica que un signo debe ser usado sólo para los números negativos (este es el comportamiento por defecto).</target>
        </trans-unit>
        <trans-unit id="02d4b08a1673b232bf3018ee2f9d0a8e9fa2025c" translate="yes" xml:space="preserve">
          <source>Inexact: operation produces a result that cannot be represented with infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.</source>
          <target state="translated">Inexacto:la operación produce un resultado que no puede ser representado con una precisión infinita,por ejemplo,2.0/3.0,log(1.1)y 0.1 en la entrada.</target>
        </trans-unit>
        <trans-unit id="63d5b176942ca6a8ddb9add205f21b0d98945888" translate="yes" xml:space="preserve">
          <source>Infix operator call</source>
          <target state="translated">Llamada de la operadora de Infix</target>
        </trans-unit>
        <trans-unit id="eb712e4e263d88043891e59382c4f31c8c4157de" translate="yes" xml:space="preserve">
          <source>Inheritance is done with the &lt;code&gt;object of&lt;/code&gt; syntax. Multiple inheritance is currently not supported. If an object type has no suitable ancestor, &lt;code&gt;RootObj&lt;/code&gt; can be used as its ancestor, but this is only a convention. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt;. You can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;. (This is used in the GTK wrapper for instance.)</source>
          <target state="translated">La herencia se realiza con el &lt;code&gt;object of&lt;/code&gt; sintaxis. Actualmente, no se admite la herencia m&amp;uacute;ltiple. Si un tipo de objeto no tiene un antepasado adecuado, &lt;code&gt;RootObj&lt;/code&gt; se puede utilizar como su antepasado, pero esto es solo una convenci&amp;oacute;n. Los objetos que no tienen antepasados ​​son impl&amp;iacute;citamente &lt;code&gt;final&lt;/code&gt; es . Puede usar el pragma &lt;code&gt;inheritable&lt;/code&gt; para introducir nuevas ra&amp;iacute;ces de objetos adem&amp;aacute;s de &lt;code&gt;system.RootObj&lt;/code&gt; . (Esto se usa en el contenedor GTK, por ejemplo).</target>
        </trans-unit>
        <trans-unit id="862fae5c64569c192f0058ccd3bbb5d19a019f65" translate="yes" xml:space="preserve">
          <source>Inhibit dynamic method resolution via procCall</source>
          <target state="translated">Inhibir la resolución del método dinámico a través de procCall</target>
        </trans-unit>
        <trans-unit id="5c4f1d9bb4b4c00271c428db76888f539a5526ec" translate="yes" xml:space="preserve">
          <source>Init procs must not be &quot;forgotten&quot; to be called.</source>
          <target state="translated">Los procedimientos iniciales no deben ser &quot;olvidados&quot; para ser llamados.</target>
        </trans-unit>
        <trans-unit id="e0133811d52fc5e0ce7548998427d86c5ecbabc3" translate="yes" xml:space="preserve">
          <source>Initialises an AsyncSocket object. If a socket cannot be initialised EOS is raised.</source>
          <target state="translated">Inicializa un objeto AsyncSocket.Si un enchufe no puede ser inicializado,el EOS se eleva.</target>
        </trans-unit>
        <trans-unit id="0e8796999c73166ae179e51a98cc0d932f6227e2" translate="yes" xml:space="preserve">
          <source>Initialize SSL using OPENSSL_init_ssl for OpenSSL &amp;gt;= 1.1.0 otherwise SSL_library_init</source>
          <target state="translated">Inicialice SSL usando OPENSSL_init_ssl para OpenSSL&amp;gt; = 1.1.0 de lo contrario SSL_library_init</target>
        </trans-unit>
        <trans-unit id="881e0294c3d407bde48feb8c4affbeeef0f33574" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RstGenerator&lt;/code&gt;.</source>
          <target state="translated">Inicializa un &lt;code&gt;RstGenerator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40151f2c3d201480764280228665dd4a245cb8ae" translate="yes" xml:space="preserve">
          <source>Initializes a URI.</source>
          <target state="translated">Inicializa una URI.</target>
        </trans-unit>
        <trans-unit id="405224e088cd409637c05da8068dcfb0b7324f95" translate="yes" xml:space="preserve">
          <source>Initializes a hash set.</source>
          <target state="translated">Inicializa un set de hachís.</target>
        </trans-unit>
        <trans-unit id="e84a4c040ee7b5e4ea1966bc93e94a695c273213" translate="yes" xml:space="preserve">
          <source>Initializes an ordered hash set.</source>
          <target state="translated">Inicializa un set de hachís ordenado.</target>
        </trans-unit>
        <trans-unit id="580bcf0259f858c591c1bdfb9fe2dbcc9bf29a6d" translate="yes" xml:space="preserve">
          <source>Initializes the default random number generator with a specific seed.</source>
          <target state="translated">Inicializa el generador de números aleatorios por defecto con una semilla específica.</target>
        </trans-unit>
        <trans-unit id="dacee3e957999d4c882a7ef1c7b8e6793e30746e" translate="yes" xml:space="preserve">
          <source>Initializes the given condition variable.</source>
          <target state="translated">Inicializa la variable de la condición dada.</target>
        </trans-unit>
        <trans-unit id="0f32d11dbd1ff544f08160af91e946d34a75cd48" translate="yes" xml:space="preserve">
          <source>Initializes the given lock.</source>
          <target state="translated">Inicializa el bloqueo dado.</target>
        </trans-unit>
        <trans-unit id="6ede6304ec6e7bf4a6a2e3d80c6b1eeb81cc73f8" translate="yes" xml:space="preserve">
          <source>Initializes the random number generator with a &quot;random&quot; number, i.e. a tickcount. Note: Does not work for NimScript.</source>
          <target state="translated">Inicializa el generador de números aleatorios con un número &quot;aleatorio&quot;,es decir,un recuento de garrapatas.Nota:No funciona con NimScript.</target>
        </trans-unit>
        <trans-unit id="7656a50f2e0ac5db2e06ce5648c4594fc345f831" translate="yes" xml:space="preserve">
          <source>InjectStmt pragma</source>
          <target state="translated">Pragmatismo de InjectStmt</target>
        </trans-unit>
        <trans-unit id="1ee7de66fcff05572c93c829536da75cc7683b42" translate="yes" xml:space="preserve">
          <source>Input flags.</source>
          <target state="translated">Banderas de entrada.</target>
        </trans-unit>
        <trans-unit id="f9e1ac91d7701d8e495d0f11ba5f1b00fdf6ed7f" translate="yes" xml:space="preserve">
          <source>Insert node B into A at pos</source>
          <target state="translated">Insertar el nodo B en A en pos</target>
        </trans-unit>
        <trans-unit id="2db3b3fd15b7bb4b34dad30c689dad9d16b24896" translate="yes" xml:space="preserve">
          <source>Inserting data</source>
          <target state="translated">Insertar datos</target>
        </trans-unit>
        <trans-unit id="dd923f823166b6196d06cbdd3db676002c784b17" translate="yes" xml:space="preserve">
          <source>Inserts items from &lt;em&gt;src&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt; at position &lt;em&gt;pos&lt;/em&gt;. This modifies &lt;em&gt;dest&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">Inserta elementos de &lt;em&gt;src&lt;/em&gt; en &lt;em&gt;dest&lt;/em&gt; en la posici&amp;oacute;n &lt;em&gt;pos&lt;/em&gt; . Esto modifica &lt;em&gt;dest en&lt;/em&gt; s&amp;iacute; mismo, no devuelve una copia.</target>
        </trans-unit>
        <trans-unit id="04298198949aebc6d2892e5fc955264070b8ebb9" translate="yes" xml:space="preserve">
          <source>Inserts the node &lt;code&gt;newChild&lt;/code&gt; before the existing child node &lt;code&gt;refChild&lt;/code&gt;. If &lt;code&gt;refChild&lt;/code&gt; is nil, insert &lt;code&gt;newChild&lt;/code&gt; at the end of the list of children.</source>
          <target state="translated">Inserta el nodo &lt;code&gt;newChild&lt;/code&gt; antes del nodo secundario existente &lt;code&gt;refChild&lt;/code&gt; . Si &lt;code&gt;refChild&lt;/code&gt; es nulo, inserte &lt;code&gt;newChild&lt;/code&gt; al final de la lista de hijos.</target>
        </trans-unit>
        <trans-unit id="786ea42ccb1f6bb0efafd8f2b61725cd22b7b01c" translate="yes" xml:space="preserve">
          <source>Inserts the separator &lt;em&gt;sep&lt;/em&gt; after &lt;em&gt;digits&lt;/em&gt; digits from right to left.</source>
          <target state="translated">Inserta el separador de &lt;em&gt;septiembre&lt;/em&gt; despu&amp;eacute;s de &lt;em&gt;d&amp;iacute;gitos&lt;/em&gt; d&amp;iacute;gitos de derecha a izquierda.</target>
        </trans-unit>
        <trans-unit id="873af15bd68c477178748ca072cfddf8b2be43af" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">Dentro de una clase de caracteres,o si el número decimal es mayor que 9 y no ha habido tantas capturas de subpatrones,PCRE vuelve a leer hasta tres dígitos octales siguiendo la barra invertida,y genera un único byte a partir de los 8 bits menos significativos del valor.Cualquier dígito subsiguiente se mantiene por sí mismo.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ca77b6367a8fe2f8a03241e2199780113a61f688" translate="yes" xml:space="preserve">
          <source>Inside asynchronous procedures &lt;code&gt;await&lt;/code&gt; can be used to call any procedures which return a &lt;code&gt;Future&lt;/code&gt;; this includes asynchronous procedures. When a procedure is &quot;awaited&quot;, the asynchronous procedure it is awaited in will suspend its execution until the awaited procedure's Future completes. At which point the asynchronous procedure will resume its execution. During the period when an asynchronous procedure is suspended other asynchronous procedures will be run by the dispatcher.</source>
          <target state="translated">Los procedimientos asincr&amp;oacute;nicos internos en &lt;code&gt;await&lt;/code&gt; se pueden usar para llamar a cualquier procedimiento que devuelva un &lt;code&gt;Future&lt;/code&gt; ; esto incluye procedimientos asincr&amp;oacute;nicos. Cuando un procedimiento est&amp;aacute; &quot;en espera&quot;, el procedimiento asincr&amp;oacute;nico en el que se espera suspender&amp;aacute; su ejecuci&amp;oacute;n hasta que se complete el Futuro del procedimiento esperado. En ese momento, el procedimiento asincr&amp;oacute;nico reanudar&amp;aacute; su ejecuci&amp;oacute;n. Durante el per&amp;iacute;odo en que se suspende un procedimiento asincr&amp;oacute;nico, el despachador ejecutar&amp;aacute; otros procedimientos asincr&amp;oacute;nicos.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="58445a9dc8fa874d6c0999c2be877243221f8374" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;#@ @#&lt;/code&gt; Nim's pragma brackets &lt;code&gt;{. .}&lt;/code&gt; can also be used, but not nested since the &lt;code&gt;.}&lt;/code&gt; doesn't have to be on a line of its own:</source>
          <target state="translated">En lugar de los corchetes de pragma de &lt;code&gt;#@ @#&lt;/code&gt; Nim &lt;code&gt;{. .}&lt;/code&gt; tambi&amp;eacute;n se puede usar, pero no anidado, ya que &lt;code&gt;.}&lt;/code&gt; no tiene que estar en una l&amp;iacute;nea propia:</target>
        </trans-unit>
        <trans-unit id="ed085b50e598c9e9c3c998d8d02d824b13f51bfb" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;self&lt;/code&gt; any other identifier can be used too, but &lt;code&gt;{.this: self.}&lt;/code&gt; will become the default directive for the whole language eventually.</source>
          <target state="translated">En lugar de &lt;code&gt;self&lt;/code&gt; , tambi&amp;eacute;n se puede usar cualquier otro identificador, pero &lt;code&gt;{.this: self.}&lt;/code&gt; Eventualmente se convertir&amp;aacute; en la directiva predeterminada para todo el lenguaje.</target>
        </trans-unit>
        <trans-unit id="5150cf2c23ac3058436fce11d312cb4ab7dd9726" translate="yes" xml:space="preserve">
          <source>Instead of a &lt;code&gt;try finally&lt;/code&gt; statement a &lt;code&gt;defer&lt;/code&gt; statement can be used.</source>
          <target state="translated">En lugar de una declaraci&amp;oacute;n de &lt;code&gt;try finally&lt;/code&gt; , se puede utilizar una declaraci&amp;oacute;n de &lt;code&gt;defer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03665382599317cc60a7efd5af43d25b36a35438" translate="yes" xml:space="preserve">
          <source>Instead of depending on the generation of the individual &lt;code&gt;.c&lt;/code&gt; files you can also ask the Nim compiler to generate a statically linked library:</source>
          <target state="translated">En lugar de depender de la generaci&amp;oacute;n de los archivos &lt;code&gt;.c&lt;/code&gt; individuales , tambi&amp;eacute;n puede pedirle al compilador de Nim que genere una biblioteca vinculada est&amp;aacute;ticamente:</target>
        </trans-unit>
        <trans-unit id="ff60c5d0007a18ea981f49f0360da2385ccc4565" translate="yes" xml:space="preserve">
          <source>Instead of keeping 2 versions of &lt;code&gt;define foo&lt;/code&gt; around, one &lt;code&gt;#def foo&lt;/code&gt; for c2nim and one ordinary &lt;code&gt;#define foo&lt;/code&gt; for C/C++, it is often more convenient to tell c2nim that &lt;code&gt;foo&lt;/code&gt; is to be interpreted as a &lt;code&gt;#def&lt;/code&gt;. This is what the &lt;code&gt;#pp&lt;/code&gt; directive accomplishes:</source>
          <target state="translated">En lugar de mantener 2 versiones de &lt;code&gt;define foo&lt;/code&gt; , una &lt;code&gt;#def foo&lt;/code&gt; para c2nim y una &lt;code&gt;#define foo&lt;/code&gt; ordinaria para C / C ++, a menudo es m&amp;aacute;s conveniente decirle a c2nim que &lt;code&gt;foo&lt;/code&gt; debe interpretarse como una &lt;code&gt;#def&lt;/code&gt; . Esto es lo que &lt;code&gt;#pp&lt;/code&gt; directiva #pp :</target>
        </trans-unit>
        <trans-unit id="c7301e8180a639fec5b0ce81d171622b155df52d" translate="yes" xml:space="preserve">
          <source>Instead of removing &lt;code&gt;EXTERN()&lt;/code&gt; from the input source file (which cannot be done reliably even with a regular expression!), one can tell c2nim that &lt;code&gt;EXTERN&lt;/code&gt; is a macro that should be expanded by c2nim too:</source>
          <target state="translated">En lugar de eliminar &lt;code&gt;EXTERN()&lt;/code&gt; del archivo fuente de entrada (&amp;iexcl;lo que no se puede hacer de manera confiable incluso con una expresi&amp;oacute;n regular!), Se puede decir a c2nim que &lt;code&gt;EXTERN&lt;/code&gt; es una macro que tambi&amp;eacute;n deber&amp;iacute;a expandirse con c2nim:</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">En lugar de:</target>
        </trans-unit>
        <trans-unit id="84737859654b67b2b9a33e5c2db83b51683c5344" translate="yes" xml:space="preserve">
          <source>Instead this code has to be used:</source>
          <target state="translated">En su lugar hay que usar este código:</target>
        </trans-unit>
        <trans-unit id="ec54b2dcce7fd1b6d6a547c96c19205ad88a3d5d" translate="yes" xml:space="preserve">
          <source>Int values of &lt;em&gt;x&lt;/em&gt; are simply converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">Los valores int de &lt;em&gt;x&lt;/em&gt; simplemente se convierten en &lt;code&gt;float&lt;/code&gt; y se llama a la otra operaci&amp;oacute;n de inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2adc71fa12ee88a61833caad8062097e6410346c" translate="yes" xml:space="preserve">
          <source>Integer division for durations.</source>
          <target state="translated">División entera para las duraciones.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="584a126c172b3ef1ff0c69307f68a5ebdd0d1d09" translate="yes" xml:space="preserve">
          <source>Integers, bool, characters and enumeration types (and subranges of these types) belong to ordinal types. For reasons of simplicity of implementation the types &lt;code&gt;uint&lt;/code&gt; and &lt;code&gt;uint64&lt;/code&gt; are not ordinal types.</source>
          <target state="translated">Los tipos enteros, bool, caracteres y enumeraci&amp;oacute;n (y subrangos de estos tipos) pertenecen a tipos ordinales. Por razones de simplicidad de implementaci&amp;oacute;n, los tipos &lt;code&gt;uint&lt;/code&gt; y &lt;code&gt;uint64&lt;/code&gt; no son tipos ordinales.</target>
        </trans-unit>
        <trans-unit id="90c35cf1c7e9e4b6aa47b681a51fc9aa23f2f3de" translate="yes" xml:space="preserve">
          <source>Integral conversion match: &lt;code&gt;a&lt;/code&gt; is convertible to &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is some integer or floating point type.</source>
          <target state="translated">Coincidencia de conversi&amp;oacute;n integral: &lt;code&gt;a&lt;/code&gt; es convertible &lt;code&gt;f&lt;/code&gt; y &lt;code&gt;f&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; es un tipo entero o de punto flotante.</target>
        </trans-unit>
        <trans-unit id="2cea7df8891dd1065020c3b86bf5bf912b6baca2" translate="yes" xml:space="preserve">
          <source>Interfacing</source>
          <target state="translated">Interfacing</target>
        </trans-unit>
        <trans-unit id="a954e42be7d65d0d68df6c2475675a3e2ab46fae" translate="yes" xml:space="preserve">
          <source>Internal documentation</source>
          <target state="translated">Documentación interna</target>
        </trans-unit>
        <trans-unit id="6be940d65e52db18b5d8edc969f415c8720649fa" translate="yes" xml:space="preserve">
          <source>Internal type representation</source>
          <target state="translated">Representación de tipo interno</target>
        </trans-unit>
        <trans-unit id="664fc2f86af06c6988fa72f769d3e17fcd2731e8" translate="yes" xml:space="preserve">
          <source>Internally, we want mustRehash(rightSize(x), x) == false.</source>
          <target state="translated">Internamente,queremos mustRehash(rightSize(x),x)==falso.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="2938da18cdb579e62b1141f39929cc36fdc8e917" translate="yes" xml:space="preserve">
          <source>Internals of the Nim Compiler</source>
          <target state="translated">Internos del Compilador Nim</target>
        </trans-unit>
        <trans-unit id="efedd1f6d18388871beb5b8937b0af027d8bf044" translate="yes" xml:space="preserve">
          <source>Internet Protocols and Support</source>
          <target state="translated">Protocolos de Internet y apoyo</target>
        </trans-unit>
        <trans-unit id="c77102105a7e484189908c6c3aaa8b4fde6d5bd4" translate="yes" xml:space="preserve">
          <source>Interpolates a format string with the values from &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">Interpola una cadena de formato con los valores de &lt;em&gt;a&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1a2e25ef70924b9dc72d6e9cae42a42464d5c3ae" translate="yes" xml:space="preserve">
          <source>Invalid SQL encountered</source>
          <target state="translated">SQL inválido encontrado</target>
        </trans-unit>
        <trans-unit id="3579c51a9cfa004f6051766e66c67a34af9f5d6d" translate="yes" xml:space="preserve">
          <source>Invalid: operations with mathematically invalid operands, for example 0.0/0.0, sqrt(-1.0), and log(-37.8).</source>
          <target state="translated">Inválido:operaciones con operandos matemáticamente inválidos,por ejemplo 0.0/0.0,sqrt(-1.0),y log(-37.8).</target>
        </trans-unit>
        <trans-unit id="e0c13b2efd4e2d6dec9f73473d4c5e30f853cc74" translate="yes" xml:space="preserve">
          <source>Invocation context</source>
          <target state="translated">Contexto de la invocación</target>
        </trans-unit>
        <trans-unit id="45e47edcb41b8a29e3a098022eba6bd2db5b9ca3" translate="yes" xml:space="preserve">
          <source>Invocation of a multi-method cannot be ambiguous: collide 2 is preferred over collide 1 because the resolution works from left to right. In the example &lt;code&gt;Unit, Thing&lt;/code&gt; is preferred over &lt;code&gt;Thing, Unit&lt;/code&gt;.</source>
          <target state="translated">La invocaci&amp;oacute;n de un m&amp;eacute;todo m&amp;uacute;ltiple no puede ser ambigua: se prefiere colisionar 2 a colisionar 1 porque la resoluci&amp;oacute;n funciona de izquierda a derecha. En el ejemplo &lt;code&gt;Unit, Thing&lt;/code&gt; se prefiere a &lt;code&gt;Thing, Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">Es equivalente a:</target>
        </trans-unit>
        <trans-unit id="a8f35cc2588d6df7883512e310eaf3cfe55f22b5" translate="yes" xml:space="preserve">
          <source>Is operator</source>
          <target state="translated">Es el operador</target>
        </trans-unit>
        <trans-unit id="3bcc962b75eed7b2e391c690e8701aa2754af2d5" translate="yes" xml:space="preserve">
          <source>Is rewritten to:</source>
          <target state="translated">se reescribe para..:</target>
        </trans-unit>
        <trans-unit id="41e7fee403015340d1195de277c32fe1acf8a866" translate="yes" xml:space="preserve">
          <source>Is short for:</source>
          <target state="translated">Es la abreviatura de:</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">Es lo mismo que:</target>
        </trans-unit>
        <trans-unit id="ae0bcdcfc983072ff2e5010acbd964825c34f849" translate="yes" xml:space="preserve">
          <source>Is translated into:</source>
          <target state="translated">Se traduce en:</target>
        </trans-unit>
        <trans-unit id="6f20666fec7d3538d857abddfabb7eb0323d351c" translate="yes" xml:space="preserve">
          <source>Is translated to:</source>
          <target state="translated">Se traduce a:</target>
        </trans-unit>
        <trans-unit id="90d19d41b3a53b1379c3459c0faab9f64cca3759" translate="yes" xml:space="preserve">
          <source>It allows programmers to mostly use their own preferred spelling style, be it humpStyle or snake_style, and libraries written by different programmers cannot use incompatible conventions. A Nim-aware editor or IDE can show the identifiers as preferred. Another advantage is that it frees the programmer from remembering the exact spelling of an identifier. The exception with respect to the first letter allows common code like &lt;code&gt;var foo: Foo&lt;/code&gt; to be parsed unambiguously.</source>
          <target state="translated">Permite a los programadores utilizar principalmente su propio estilo de ortograf&amp;iacute;a preferido, ya sea humpStyle o snake_style, y las bibliotecas escritas por diferentes programadores no pueden utilizar convenciones incompatibles. Un editor o IDE compatible con Nim puede mostrar los identificadores como prefiera. Otra ventaja es que libera al programador de recordar la ortograf&amp;iacute;a exacta de un identificador. La excepci&amp;oacute;n con respecto a la primera letra permite que c&amp;oacute;digo com&amp;uacute;n como &lt;code&gt;var foo: Foo&lt;/code&gt; sea ​​analizado sin ambig&amp;uuml;edades.</target>
        </trans-unit>
        <trans-unit id="2fe9d58777a4819a056f680773675b458bc59f43" translate="yes" xml:space="preserve">
          <source>It also possible to pass arguments to a user definable matcher:</source>
          <target state="translated">También es posible pasar los argumentos a un comparador definible por el usuario:</target>
        </trans-unit>
        <trans-unit id="4b2feef416362147669a39cf0c612de62bb2d19e" translate="yes" xml:space="preserve">
          <source>It also provides some fast iterators over lines in text files (or other &quot;line-like&quot;, variable length, delimited records).</source>
          <target state="translated">También proporciona algunos iteradores rápidos sobre las líneas de los archivos de texto (u otros registros &quot;similares a las líneas&quot;,de longitud variable y delimitados).</target>
        </trans-unit>
        <trans-unit id="dff3ae584541038e537e5a342c1930160c45bf0a" translate="yes" xml:space="preserve">
          <source>It can also be used when defines are being referred to, as c2nim currently does not expand defines:</source>
          <target state="translated">También puede utilizarse cuando se hace referencia a las definiciones,ya que actualmente el c2nim no amplía las definiciones:</target>
        </trans-unit>
        <trans-unit id="f0075f000dd30ff460292c5c1bbbe6ad98332e6c" translate="yes" xml:space="preserve">
          <source>It can be used to parse a wild HTML document and output it as valid XHTML document (well, if you are lucky):</source>
          <target state="translated">Puede ser usado para analizar un documento HTML salvaje y producirlo como un documento XHTML válido (bueno,si tienes suerte):</target>
        </trans-unit>
        <trans-unit id="589d528fa76550fcfe67d75a7cc3b724508c0925" translate="yes" xml:space="preserve">
          <source>It does not make sense to multiply a dollar with a dollar, but with a number without unit; and the same holds for division:</source>
          <target state="translated">No tiene sentido multiplicar un dólar por un dólar,sino por un número sin unidad;y lo mismo vale para la división:</target>
        </trans-unit>
        <trans-unit id="c9187f5ee38c2d68fe98474af10e0521e2ff318b" translate="yes" xml:space="preserve">
          <source>It helps to think that the iterator actually returns a pair &lt;code&gt;(value, done)&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; is used to access the hidden &lt;code&gt;done&lt;/code&gt; field.</source>
          <target state="translated">Es &amp;uacute;til pensar que el iterador realmente devuelve un par &lt;code&gt;(value, done)&lt;/code&gt; y &lt;code&gt;finished&lt;/code&gt; se usa para acceder al campo &lt;code&gt;done&lt;/code&gt; oculto .</target>
        </trans-unit>
        <trans-unit id="b7934ea36bb3abaeb6de1ae68617ee4fa3e89f7c" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; safe to disable the garbage collector and enable it after the call from your background thread even if the code you are calling is short lived.</source>
          <target state="translated">Es &lt;strong&gt;no&lt;/strong&gt; seguro para desactivar el recolector de basura y habilitarlo despu&amp;eacute;s de la llamada desde el subproceso en segundo plano, incluso si el c&amp;oacute;digo que est&amp;aacute; llamando es de corta duraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0ce32c42207b074e8614eb82e24a7a71033a751d" translate="yes" xml:space="preserve">
          <source>It is a compile time error if the implicitly introduced pointer could be used to access a location beyond its lifetime:</source>
          <target state="translated">Es un error de tiempo de compilación si el puntero introducido implícitamente puede ser utilizado para acceder a un lugar más allá de su vida útil:</target>
        </trans-unit>
        <trans-unit id="654b26d139effb1815e88b12fee61a0a858572c0" translate="yes" xml:space="preserve">
          <source>It is also important that the replay involves the &lt;code&gt;import&lt;/code&gt; statement so that the dependencies are resolved properly.</source>
          <target state="translated">Tambi&amp;eacute;n es importante que la reproducci&amp;oacute;n incluya la declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n para que las dependencias se resuelvan correctamente.</target>
        </trans-unit>
        <trans-unit id="2d729a9913be11aee103dc8aea1b73a4c4edcc41" translate="yes" xml:space="preserve">
          <source>It is an essential property of abstract types that they &lt;strong&gt;do not&lt;/strong&gt; imply a subtype relation between the abstract type and its base type. Explicit type conversions from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;SQL&lt;/code&gt; are allowed:</source>
          <target state="translated">Es una propiedad esencial de los tipos abstractos que &lt;strong&gt;no&lt;/strong&gt; implican una relaci&amp;oacute;n de subtipo entre el tipo abstracto y su tipo base. Se permiten conversiones de tipo expl&amp;iacute;cito de &lt;code&gt;string&lt;/code&gt; a &lt;code&gt;SQL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e31fcf4a46656a66279b459e1a0815babbcc226" translate="yes" xml:space="preserve">
          <source>It is important to note that reordering &lt;em&gt;only&lt;/em&gt; works for symbols at top level scope. Therefore, the following will &lt;em&gt;fail to compile:&lt;/em&gt;</source>
          <target state="translated">Es importante tener en cuenta que el reordenamiento &lt;em&gt;solo&lt;/em&gt; funciona para s&amp;iacute;mbolos en el alcance de nivel superior. Por lo tanto, &lt;em&gt;no se podr&amp;aacute; compilar lo siguiente:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eccab016e9c85070b264d0771a05edb52b43822b" translate="yes" xml:space="preserve">
          <source>It is not checked that the &lt;code&gt;except&lt;/code&gt; list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.</source>
          <target state="translated">No se comprueba que la lista de &lt;code&gt;except&lt;/code&gt; se haya exportado realmente desde el m&amp;oacute;dulo. Esta caracter&amp;iacute;stica permite compilar contra una versi&amp;oacute;n anterior del m&amp;oacute;dulo que no exporta estos identificadores.</target>
        </trans-unit>
        <trans-unit id="f56aa33e889a1d3e8b0dbe2f53303f6d1de0ebdc" translate="yes" xml:space="preserve">
          <source>It is possible to define custom typed pragmas. Custom pragmas do not effect code generation directly, but their presence can be detected by macros. Custom pragmas are defined using templates annotated with pragma &lt;code&gt;pragma&lt;/code&gt;:</source>
          <target state="translated">Es posible definir pragmas escritos personalizados. Los pragmas personalizados no afectan la generaci&amp;oacute;n de c&amp;oacute;digo directamente, pero su presencia puede ser detectada por macros. Los pragmas personalizados se definen utilizando plantillas anotadas con pragma &lt;code&gt;pragma&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc420b00d95b0079b6bcd9cda3e4f93970825224" translate="yes" xml:space="preserve">
          <source>It is possible to raise/catch imported C++ exceptions. Types imported using &lt;em&gt;importcpp&lt;/em&gt; can be raised or caught. Exceptions are raised by value and caught by reference. Example:</source>
          <target state="translated">Es posible generar / capturar excepciones importadas de C ++. Los tipos importados mediante &lt;em&gt;importcpp se&lt;/em&gt; pueden &lt;em&gt;generar&lt;/em&gt; o capturar. Las excepciones se plantean por valor y se capturan por referencia. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="82b23252352db8b301d0df8ca78112f74b272448" translate="yes" xml:space="preserve">
          <source>It is quite common to have arrays start at zero, so there's a shortcut syntax to specify a range from zero to the specified index minus one:</source>
          <target state="translated">Es bastante común que los arreglos comiencen en cero,por lo que existe una sintaxis de atajo para especificar un rango desde cero hasta el índice especificado menos uno:</target>
        </trans-unit>
        <trans-unit id="82118804703a69ba666b11e8579a1411bb333d2a" translate="yes" xml:space="preserve">
          <source>It may be surprising but the function as a whole can take longer than the specified timeout, only individual internal calls on the socket are affected. In practice this means that as long as the server is sending data an exception will not be raised, if however data does not reach the client within the specified timeout a &lt;code&gt;TimeoutError&lt;/code&gt; exception will be raised.</source>
          <target state="translated">Puede resultar sorprendente, pero la funci&amp;oacute;n en su conjunto puede tardar m&amp;aacute;s que el tiempo de espera especificado, solo se ven afectadas las llamadas internas individuales en el socket. En la pr&amp;aacute;ctica, esto significa que mientras el servidor est&amp;eacute; enviando datos, no se generar&amp;aacute; una excepci&amp;oacute;n; sin embargo, si los datos no llegan al cliente dentro del tiempo de espera especificado, se &lt;code&gt;TimeoutError&lt;/code&gt; una excepci&amp;oacute;n TimeoutError .</target>
        </trans-unit>
        <trans-unit id="919d2993bd870949c788657a2aacbe74a9e6d3fc" translate="yes" xml:space="preserve">
          <source>It must be a call expression &lt;code&gt;f(a, ...)&lt;/code&gt;.</source>
          <target state="translated">Debe ser una expresi&amp;oacute;n de llamada &lt;code&gt;f(a, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1bdeab513f38cc4e202661fc69c3b7e5aa7c684" translate="yes" xml:space="preserve">
          <source>It must contain &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">Debe contener &lt;code&gt;else&lt;/code&gt; rama.</target>
        </trans-unit>
        <trans-unit id="9f548d24fefd8a46690cd32590a6cce7dfd8f4a7" translate="yes" xml:space="preserve">
          <source>It must not contain &lt;code&gt;elif&lt;/code&gt; branches.</source>
          <target state="translated">No debe contener ramas &lt;code&gt;elif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0657d7c3802eac9139afa1fdbbc00243500a126" translate="yes" xml:space="preserve">
          <source>It's a static error if the compiler cannot perform the evaluation at compile time.</source>
          <target state="translated">Es un error estático si el compilador no puede realizar la evaluación en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="b08a29bb41e597ad7a05123c2e5513c91c059874" translate="yes" xml:space="preserve">
          <source>It's also possible to use &lt;code&gt;from module import nil&lt;/code&gt; if one wants to import the module but wants to enforce fully qualified access to every symbol in &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n es posible utilizar &lt;code&gt;from module import nil&lt;/code&gt; si uno quiere importar el m&amp;oacute;dulo pero quiere forzar un acceso completo a cada s&amp;iacute;mbolo en el &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de95b4993b261b85e3332b1324f8a0290c259dec" translate="yes" xml:space="preserve">
          <source>It's recommended to use &lt;code&gt;addCallback&lt;/code&gt; or &lt;code&gt;then&lt;/code&gt; instead.</source>
          <target state="translated">Se recomienda usar &lt;code&gt;addCallback&lt;/code&gt; o &lt;code&gt;then&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="cadaa83ad0b6b331d838560da721266dc244b734" translate="yes" xml:space="preserve">
          <source>Iterate over all the directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">Repita todos los directorios que coincidan con el &lt;em&gt;patr&amp;oacute;n&lt;/em&gt; . En POSIX, esto usa la llamada &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="e75e34b52a6961303566d6b4dd5b3c4b21d77274" translate="yes" xml:space="preserve">
          <source>Iterate over all the files and directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">Repita todos los archivos y directorios que coincidan con el &lt;em&gt;patr&amp;oacute;n&lt;/em&gt; . En POSIX, esto usa la llamada &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="9d643234b1583c1062d05608e19e2329372f5e89" translate="yes" xml:space="preserve">
          <source>Iterate over all the files that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">Repita todos los archivos que coincidan con el &lt;em&gt;patr&amp;oacute;n&lt;/em&gt; . En POSIX, esto usa la llamada &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="584cc308ff50e7947ff5a4e8292a45088ef391f4" translate="yes" xml:space="preserve">
          <source>Iterate over any line in the file &lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">Iterar sobre cualquier l&amp;iacute;nea del archivo &lt;em&gt;f&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a1c0deeb78059911d4801816fdd1f4f108e438a" translate="yes" xml:space="preserve">
          <source>Iterates over [optional &lt;em&gt;eat&lt;/em&gt;] &lt;em&gt;delim&lt;/em&gt;-delimited slices in MemFile &lt;em&gt;mfile&lt;/em&gt;.</source>
          <target state="translated">Itera sobre [opcional &lt;em&gt;comen&lt;/em&gt; ] &lt;em&gt;delim&lt;/em&gt; -delimited rebanadas en fichero de memoria &lt;em&gt;MFILE&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="52d58a07e8a9d8fd6b99e5571402712d73dfd13e" translate="yes" xml:space="preserve">
          <source>Iterates over all the children of &lt;em&gt;n&lt;/em&gt; returning those matching &lt;em&gt;tag&lt;/em&gt;.</source>
          <target state="translated">Itera sobre todos los hijos de &lt;em&gt;n que&lt;/em&gt; devuelven esas &lt;em&gt;etiquetas&lt;/em&gt; coincidentes .</target>
        </trans-unit>
        <trans-unit id="b19228b3b231795b187dec3bdf8a6cb478e6ffc7" translate="yes" xml:space="preserve">
          <source>Iterates over any line in the file named &lt;em&gt;filename&lt;/em&gt;.</source>
          <target state="translated">Itera sobre cualquier l&amp;iacute;nea del archivo llamado &lt;em&gt;nombre de archivo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="232f547ddc65be9624e107036fe1044b4d2a410d" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning runes</source>
          <target state="translated">Itera sobre cualquier Unicode car&amp;aacute;cter de la cadena &lt;code&gt;s&lt;/code&gt; runas que regresan</target>
        </trans-unit>
        <trans-unit id="8bc06e9d0c093f624eaf1ffbfc94ebe52d5cb792" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning utf8 values</source>
          <target state="translated">Itera sobre cualquier Unicode car&amp;aacute;cter de la cadena &lt;code&gt;s&lt;/code&gt; valores utf8 que regresan</target>
        </trans-unit>
        <trans-unit id="0388ab64e5b2bc44c4842558d16b95e6873ca62a" translate="yes" xml:space="preserve">
          <source>Iterates over every field of &lt;em&gt;x&lt;/em&gt; returning their name and value.</source>
          <target state="translated">Itera sobre cada campo de &lt;em&gt;x&lt;/em&gt; devolviendo su nombre y valor.</target>
        </trans-unit>
        <trans-unit id="00e6300c1169713ff3c5939859f36401dc5c4eee" translate="yes" xml:space="preserve">
          <source>Iterates over every line in the stream. The iteration is based on &lt;code&gt;readLine&lt;/code&gt;.</source>
          <target state="translated">Repite todas las l&amp;iacute;neas de la secuencia. La iteraci&amp;oacute;n se basa en &lt;code&gt;readLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d86ccc2321238c55eb2895e898e51e2cea46b931" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the ordered set &lt;em&gt;s&lt;/em&gt; in insertion order.</source>
          <target state="translated">Repite claves en el conjunto ordenado &lt;em&gt;s&lt;/em&gt; con el fin de inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c71c7420dcf70891eaaf12e2494e2aabe991e2e1" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the set &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Repite claves en el conjunto &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="46bdee16e1d678daf2434ac56d4f6f640c4d7297" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt; and its indices.</source>
          <target state="translated">Itera sobre los elementos secundarios del NimNode &lt;code&gt;n&lt;/code&gt; y sus &amp;iacute;ndices.</target>
        </trans-unit>
        <trans-unit id="a478441af6bfca796118a06d6ecf3801a9262e8d" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Itera sobre los hijos del NimNode &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019eedce602970f3a59ce2f86870397544031ca8" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if every item fulfills the predicate.</source>
          <target state="translated">Itera a través de un contenedor y comprueba si cada artículo cumple con el predicado.</target>
        </trans-unit>
        <trans-unit id="3501cb1c35511e4764121e28692134446b5075eb" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if some item fulfills the predicate.</source>
          <target state="translated">Itera a través de un contenedor y comprueba si algún elemento cumple con el predicado.</target>
        </trans-unit>
        <trans-unit id="7fbdcafeaa504e0cbb5d1d512e8dfbaba8410003" translate="yes" xml:space="preserve">
          <source>Iterates through a container and yields every item that fulfills the predicate.</source>
          <target state="translated">Itera a través de un contenedor y produce cada elemento que cumple con el predicado.</target>
        </trans-unit>
        <trans-unit id="81ad0b1b4463be831a5785f4d06c130b3622cb6b" translate="yes" xml:space="preserve">
          <source>Iterator declaration</source>
          <target state="translated">Declaración de Iterator</target>
        </trans-unit>
        <trans-unit id="edfa2bc8a9c8c3896d560c27f80be0217d6f76a5" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject.</source>
          <target state="translated">Iterador para los elementos secundarios de &lt;em&gt;node&lt;/em&gt; . &lt;em&gt;nodo&lt;/em&gt; tiene que ser un JObject.</target>
        </trans-unit>
        <trans-unit id="7b68d08a7df61a331ce7105b12ff381cd2542871" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject. Values can be modified</source>
          <target state="translated">Iterador para los elementos secundarios de &lt;em&gt;node&lt;/em&gt; . &lt;em&gt;nodo&lt;/em&gt; tiene que ser un JObject. Los valores se pueden modificar</target>
        </trans-unit>
        <trans-unit id="6229022bcfa1dd29b2c2a761afb0d2b506503b49" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray.</source>
          <target state="translated">Iterador para los elementos del &lt;em&gt;nodo&lt;/em&gt; . &lt;em&gt;El nodo&lt;/em&gt; tiene que ser un JArray.</target>
        </trans-unit>
        <trans-unit id="937eeb4e7eb8e59ed90bf865be25f2439aa4af89" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray. Items can be modified.</source>
          <target state="translated">Iterador para los elementos del &lt;em&gt;nodo&lt;/em&gt; . &lt;em&gt;El nodo&lt;/em&gt; tiene que ser un JArray. Los elementos se pueden modificar.</target>
        </trans-unit>
        <trans-unit id="853abfbfe15cced2111de5887bb206586352e215" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList.</source>
          <target state="translated">Iterador para los elementos del &lt;em&gt;nodo&lt;/em&gt; . &lt;em&gt;El nodo&lt;/em&gt; tiene que ser una SList.</target>
        </trans-unit>
        <trans-unit id="cba2124d3f6e176e90018e400cd94d03ff65e532" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList. Items can be modified.</source>
          <target state="translated">Iterador para los elementos del &lt;em&gt;nodo&lt;/em&gt; . &lt;em&gt;El nodo&lt;/em&gt; tiene que ser una SList. Los elementos se pueden modificar.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e0b6581a3426edca0a47a508b898e82d9d301321" translate="yes" xml:space="preserve">
          <source>Iterators and the for statement</source>
          <target state="translated">Iteradores y la declaración de for</target>
        </trans-unit>
        <trans-unit id="c425b7e3d2bb19788f1181a2d9b7a44e6225c0c2" translate="yes" xml:space="preserve">
          <source>Iterators can only be called from for loops.</source>
          <target state="translated">Sólo se puede llamar a los iteradores para los bucles.</target>
        </trans-unit>
        <trans-unit id="df973b05a9a30c48e0cd32ea43a5a32471fddcf5" translate="yes" xml:space="preserve">
          <source>Iterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)</source>
          <target state="translated">Los iteradores no pueden ser declarados hacia adelante,porque el compilador debe ser capaz de poner en línea un iterador.(Esta restricción desaparecerá en una futura versión del compilador).</target>
        </trans-unit>
        <trans-unit id="5ab10982165c8e92be42e548c908af50f06450ed" translate="yes" xml:space="preserve">
          <source>Iterators cannot contain a &lt;code&gt;return&lt;/code&gt; statement (and procs cannot contain a &lt;code&gt;yield&lt;/code&gt; statement).</source>
          <target state="translated">Los iteradores no pueden contener una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; (y los procesos no pueden contener una declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6bf87542270934bc52223ff3fd2180cee9913ce5" translate="yes" xml:space="preserve">
          <source>Iterators do not support recursion.</source>
          <target state="translated">Los iteradores no apoyan la recursión.</target>
        </trans-unit>
        <trans-unit id="f13b815d55263a0262e1d3f448ea1ef694f0c5ac" translate="yes" xml:space="preserve">
          <source>Iterators have no implicit &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">Los iteradores no tienen una variable de &lt;code&gt;result&lt;/code&gt; ado impl&amp;iacute;cita .</target>
        </trans-unit>
        <trans-unit id="876bf01455350b312419f0cdb54d8032bb9cad66" translate="yes" xml:space="preserve">
          <source>Iterators look very similar to procedures, but there are several important differences:</source>
          <target state="translated">Los iteradores se parecen mucho a los procedimientos,pero hay varias diferencias importantes:</target>
        </trans-unit>
        <trans-unit id="6bc9cd0b4b1a838a8dbe53e1eea311fe67780b4c" translate="yes" xml:space="preserve">
          <source>Iterators that are neither marked &lt;code&gt;{.closure.}&lt;/code&gt; nor &lt;code&gt;{.inline.}&lt;/code&gt; explicitly default to being inline, but this may change in future versions of the implementation.</source>
          <target state="translated">Los iteradores que no est&amp;aacute;n marcados como &lt;code&gt;{.closure.}&lt;/code&gt; Ni &lt;code&gt;{.inline.}&lt;/code&gt; Expl&amp;iacute;citamente predeterminados est&amp;aacute;n en l&amp;iacute;nea, pero esto puede cambiar en futuras versiones de la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38589c6c98e2050e493732fa1ecf1db5355eff6a" translate="yes" xml:space="preserve">
          <source>Its expression must always be &lt;code&gt;nimvm&lt;/code&gt;. More complex expressions are not allowed.</source>
          <target state="translated">Su expresi&amp;oacute;n debe ser siempre &lt;code&gt;nimvm&lt;/code&gt; . No se permiten expresiones m&amp;aacute;s complejas.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="cc51bafafaa93b2fbf580ec2042f2d93d08d2a66" translate="yes" xml:space="preserve">
          <source>JSON node</source>
          <target state="translated">Nodo JSON</target>
        </trans-unit>
        <trans-unit id="10e429d7ec1e1bc197f5757d96b736f7f4406dc2" translate="yes" xml:space="preserve">
          <source>JSON representation is stored in the passed &lt;em&gt;result&lt;/em&gt;</source>
          <target state="translated">La representaci&amp;oacute;n JSON se almacena en el &lt;em&gt;resultado&lt;/em&gt; pasado&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d58199ede61c8be4b203d8081423f4280c50eb7c" translate="yes" xml:space="preserve">
          <source>JavaScript compatibility</source>
          <target state="translated">Compatibilidad con JavaScript</target>
        </trans-unit>
        <trans-unit id="f916a308bc581d1790072c2938487f3e908716e7" translate="yes" xml:space="preserve">
          <source>JavaScript invocation example</source>
          <target state="translated">Ejemplo de invocación de JavaScript</target>
        </trans-unit>
        <trans-unit id="763eb4bbded920e91a4a60898d473e2e59d035cd" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;delete&lt;/em&gt; operator</source>
          <target state="translated">Operador de &lt;em&gt;eliminaci&amp;oacute;n&lt;/em&gt; de JavaScript</target>
        </trans-unit>
        <trans-unit id="7069adda83e85fa6bdd1af127a53c1cd02199edc" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;require&lt;/em&gt; function</source>
          <target state="translated">La funci&amp;oacute;n &lt;em&gt;requerida&lt;/em&gt; de JavaScript</target>
        </trans-unit>
        <trans-unit id="e59bd4e62783475d358a55e576f9e1db556cc458" translate="yes" xml:space="preserve">
          <source>JavaScript's __dirname pseudo-variable</source>
          <target state="translated">La pseudo-variable del nombre del directorio de JavaScript</target>
        </trans-unit>
        <trans-unit id="c05cec6255459be0665ced8c38873552b1af2710" translate="yes" xml:space="preserve">
          <source>JavaScript's __filename pseudo-variable</source>
          <target state="translated">El nombre de archivo de JavaScript es una pseudo-variable...</target>
        </trans-unit>
        <trans-unit id="48e39cbab3720cf60b021ee6573c7b065c55248f" translate="yes" xml:space="preserve">
          <source>JavaScript's arguments pseudo-variable</source>
          <target state="translated">Los argumentos de JavaScript pseudo-variable</target>
        </trans-unit>
        <trans-unit id="54d029c76d92f4b9cfa620d278a0227c9c10f25f" translate="yes" xml:space="preserve">
          <source>JavaScript's null literal</source>
          <target state="translated">El literal nulo de JavaScript</target>
        </trans-unit>
        <trans-unit id="cf269e0f71fff143464c4dce0ba8941aff38d4fb" translate="yes" xml:space="preserve">
          <source>JavaScript's undefined literal</source>
          <target state="translated">El literal indefinido de JavaScript</target>
        </trans-unit>
        <trans-unit id="dcbcd7e22ce06dbd66e5b01adffbd52ed0a91c58" translate="yes" xml:space="preserve">
          <source>Joins two URLs together, separating them with / if needed.</source>
          <target state="translated">Une dos URLs,separándolas con/si es necesario.</target>
        </trans-unit>
        <trans-unit id="6b949efa98af5de2c9a9e2aa57c0ac512664c7bb" translate="yes" xml:space="preserve">
          <source>Joins two directory names to one.</source>
          <target state="translated">Une dos nombres de directorio a uno.</target>
        </trans-unit>
        <trans-unit id="f916106b08687c9b3604d03769854685d4185a21" translate="yes" xml:space="preserve">
          <source>Just like an &lt;em&gt;if expression&lt;/em&gt;, but corresponding to the when statement.</source>
          <target state="translated">Como una &lt;em&gt;expresi&amp;oacute;n if&lt;/em&gt; , pero correspondiente a la instrucci&amp;oacute;n when.</target>
        </trans-unit>
        <trans-unit id="1f5a23579b9dec30ee62832658d6b0b949930854" translate="yes" xml:space="preserve">
          <source>Just like in regular type classes, Nim discriminates between &lt;code&gt;bind once&lt;/code&gt; and &lt;code&gt;bind many&lt;/code&gt; types when matching the concept. You can add the &lt;code&gt;distinct&lt;/code&gt; modifier to any of the otherwise inferable types to get a type that will be matched without permanently inferring it. This may be useful when you need to match several procs accepting the same wide class of types:</source>
          <target state="translated">Al igual que en las clases de tipos normales, Nim discrimina entre &lt;code&gt;bind once&lt;/code&gt; y &lt;code&gt;bind many&lt;/code&gt; tipos al hacer coincidir el concepto. Puede agregar el modificador &lt;code&gt;distinct&lt;/code&gt; a cualquiera de los tipos que de otro modo se podr&amp;iacute;an deducir para obtener un tipo que coincidir&amp;aacute; sin inferirlo permanentemente. Esto puede ser &amp;uacute;til cuando necesita hacer coincidir varios procesos que aceptan la misma amplia clase de tipos:</target>
        </trans-unit>
        <trans-unit id="3706f82fc751aa40a365d4e0255b0c559571efe9" translate="yes" xml:space="preserve">
          <source>Just like in this example we pass the path to the &lt;code&gt;mylib.a&lt;/code&gt; library (and we could as well pass &lt;code&gt;logic.o&lt;/code&gt;) we could be passing switches to link any other static C library.</source>
          <target state="translated">Al igual que en este ejemplo, pasamos la ruta a la biblioteca &lt;code&gt;mylib.a&lt;/code&gt; (y tambi&amp;eacute;n podr&amp;iacute;amos pasar &lt;code&gt;logic.o&lt;/code&gt; . O ) podr&amp;iacute;amos estar pasando conmutadores para vincular cualquier otra biblioteca C est&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="ec69238a91ddb84ddd174a422a2bc6d89e341833" translate="yes" xml:space="preserve">
          <source>Just like strings, custom data types that are to be shared between Nim and the backend will need careful consideration of who controls who. If you want to hand a Nim reference to C code, you will need to use &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; to mark the reference as used, so it does not get freed. And for the C backend you will need to expose the &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; proc to clean up this memory when it is not required any more.</source>
          <target state="translated">Al igual que las cadenas, los tipos de datos personalizados que se compartir&amp;aacute;n entre Nim y el backend necesitar&amp;aacute;n una consideraci&amp;oacute;n cuidadosa de qui&amp;eacute;n controla a qui&amp;eacute;n. Si desea entregar una referencia de Nim al c&amp;oacute;digo C, deber&amp;aacute; usar &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; para marcar la referencia como usada, para que no se libere. Y para el backend de C, necesitar&amp;aacute; exponer el proceso &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; para limpiar esta memoria cuando ya no se necesite.</target>
        </trans-unit>
        <trans-unit id="a1934a4d1d0bfda8c814a6f373c36bed11fcc1a9" translate="yes" xml:space="preserve">
          <source>Just like with regular pointers, covariance will be enabled only for immutable values:</source>
          <target state="translated">Al igual que con los punteros regulares,la covarianza se habilitará sólo para valores inmutables:</target>
        </trans-unit>
        <trans-unit id="ba04be8caff7a5b413c929b67abe644a93a8234c" translate="yes" xml:space="preserve">
          <source>Keeping track of memory</source>
          <target state="translated">Manteniendo la memoria...</target>
        </trans-unit>
        <trans-unit id="c3cc4a28dc3c7c50a7cedf645fccd862a77c3448" translate="yes" xml:space="preserve">
          <source>Keeps the items in the passed sequence if they fulfilled the predicate. Same as the &lt;code&gt;filter&lt;/code&gt; proc, but modifies the sequence directly.</source>
          <target state="translated">Mantiene los elementos en la secuencia pasada si cumplieron con el predicado. Igual que el &lt;code&gt;filter&lt;/code&gt; proc, pero modifica la secuencia directamente.</target>
        </trans-unit>
        <trans-unit id="cd0b9402bb38009f565aff1f5e64a66bff29662b" translate="yes" xml:space="preserve">
          <source>Kill the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGKILL&lt;/code&gt; to the process. On Windows &lt;code&gt;kill()&lt;/code&gt; is simply an alias for &lt;code&gt;terminate()&lt;/code&gt;.</source>
          <target state="translated">Mata el proceso &lt;em&gt;p&lt;/em&gt; . En los sistemas operativos Posix, el procedimiento env&amp;iacute;a &lt;code&gt;SIGKILL&lt;/code&gt; al proceso. En Windows, &lt;code&gt;kill()&lt;/code&gt; es simplemente un alias de &lt;code&gt;terminate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">Limitaciones conocidas:</target>
        </trans-unit>
        <trans-unit id="71e0d9df3f621a55340e5e059ae130eb41a5eb1c" translate="yes" xml:space="preserve">
          <source>Lambda lifting is implemented as part of the &lt;code&gt;transf&lt;/code&gt; pass. The &lt;code&gt;transf&lt;/code&gt; pass generates code to setup the environment and to pass it around. However, this pass does not change the types! So we have some kind of mismatch here; on the one hand the proc expression becomes an explicit tuple, on the other hand the tyProc(ccClosure) type is not changed. For C code generation it's also important the hidden formal param is &lt;code&gt;void*&lt;/code&gt; and not something more specialized. However the more specialized env type needs to passed to the backend somehow. We deal with this by modifying &lt;code&gt;s.ast[paramPos]&lt;/code&gt; to contain the formal hidden parameter, but not &lt;code&gt;s.typ&lt;/code&gt;!</source>
          <target state="translated">Lambda de elevaci&amp;oacute;n se implementa como parte de la &lt;code&gt;transf&lt;/code&gt; pase. El pase &lt;code&gt;transf&lt;/code&gt; genera c&amp;oacute;digo para configurar el entorno y pasarlo. Sin embargo, &amp;iexcl;este pase no cambia los tipos! As&amp;iacute; que tenemos alg&amp;uacute;n tipo de desajuste aqu&amp;iacute;; por un lado, la expresi&amp;oacute;n proc se convierte en una tupla expl&amp;iacute;cita, por otro lado, el tipo tyProc (ccClosure) no cambia. Para la generaci&amp;oacute;n de c&amp;oacute;digo C tambi&amp;eacute;n es importante que el par&amp;aacute;metro formal oculto sea &lt;code&gt;void*&lt;/code&gt; y no algo m&amp;aacute;s especializado. Sin embargo, el tipo de env m&amp;aacute;s especializado debe pasar al backend de alguna manera. Nos ocupamos de esto modificando el &lt;code&gt;s.ast[paramPos]&lt;/code&gt; para que contenga el par&amp;aacute;metro oculto formal, &amp;iexcl;pero no el &lt;code&gt;s.typ&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="6f81dcaf384dc8f0c6782aafff539ab7cb63534e" translate="yes" xml:space="preserve">
          <source>Language Manual</source>
          <target state="translated">Manual del lenguaje</target>
        </trans-unit>
        <trans-unit id="f1a81de77c30016ff417d2dc8525d90f0c658140" translate="yes" xml:space="preserve">
          <source>Large example</source>
          <target state="translated">Un gran ejemplo</target>
        </trans-unit>
        <trans-unit id="309493ddacc4fb8306467fc937e00c3cfc275435" translate="yes" xml:space="preserve">
          <source>Larger example</source>
          <target state="translated">Un ejemplo más grande</target>
        </trans-unit>
        <trans-unit id="84d8b12a98abf233ce61b735b7f623dfa748d624" translate="yes" xml:space="preserve">
          <source>Later versions of Nim can be more precise about the borrowing rule with a syntax like:</source>
          <target state="translated">Versiones posteriores de Nim pueden ser más precisas sobre la regla de préstamo con una sintaxis como:</target>
        </trans-unit>
        <trans-unit id="b84ad3bb11b5b72ae8064b2e03ac6593bfc14c79" translate="yes" xml:space="preserve">
          <source>Later versions of the language will weaken the requirements for forward declarations.</source>
          <target state="translated">Las versiones posteriores del idioma debilitarán los requisitos de las declaraciones a posteriori.</target>
        </trans-unit>
        <trans-unit id="b6e6ff1bcd7ed1a5e8f4c37ec0106d2e2587cae3" translate="yes" xml:space="preserve">
          <source>Lazy type resolution for untyped</source>
          <target state="translated">La resolución de tipo perezoso para los no escritos</target>
        </trans-unit>
        <trans-unit id="a4f7fe013eb75f3bd7abaac6e67f4376f5da9c25" translate="yes" xml:space="preserve">
          <source>Leaf nodes/Atoms</source>
          <target state="translated">Nodos de la hoja/Átomos</target>
        </trans-unit>
        <trans-unit id="a6702a5291853b1308e7bd674d53f7e0975e6409" translate="yes" xml:space="preserve">
          <source>Left-Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">Izquierda-Alinea una cadena &lt;em&gt;es&lt;/em&gt; con &lt;em&gt;el relleno&lt;/em&gt; , por lo que es de longitud &lt;em&gt;recuento&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="581f4b8c009369b50e3d9ba5325d87417e6534b8" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 16-bits value.</source>
          <target state="translated">Bits de rotación izquierda en un valor de 16 bits.</target>
        </trans-unit>
        <trans-unit id="d3409f80fea6038549fe1206956266f2e8a6fbb1" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 32-bits value.</source>
          <target state="translated">Bits de rotación izquierda en un valor de 32 bits.</target>
        </trans-unit>
        <trans-unit id="0aef55ce888f5b32fb20afe0a6d757edd1ce8821" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 64-bits value.</source>
          <target state="translated">Bits de rotación izquierda en un valor de 64 bits.</target>
        </trans-unit>
        <trans-unit id="73e3851ee7450c9ad9c84aa2c1e0ca99eeb3856b" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 8-bits value.</source>
          <target state="translated">Bits de rotación izquierda en un valor de 8 bits.</target>
        </trans-unit>
        <trans-unit id="08b05a7cc45a3cfbb0bd52f3553051c002b98ea9" translate="yes" xml:space="preserve">
          <source>Let section</source>
          <target state="translated">Deje que la sección</target>
        </trans-unit>
        <trans-unit id="aa344992ab3c9cce0c812154c891a2082a0f43d5" translate="yes" xml:space="preserve">
          <source>Let us look at Nim's lexical elements in more detail: like other programming languages Nim consists of (string) literals, identifiers, keywords, comments, operators, and other punctuation marks.</source>
          <target state="translated">Veamos los elementos lexicales de Nim con más detalle:como otros lenguajes de programación Nim consiste en literales (de cadena),identificadores,palabras clave,comentarios,operadores y otros signos de puntuación.</target>
        </trans-unit>
        <trans-unit id="b472892cf2e180fd60510de81af55b7e2fd6e956" translate="yes" xml:space="preserve">
          <source>Let's return to the simple counting example:</source>
          <target state="translated">Volvamos al ejemplo del recuento simple:</target>
        </trans-unit>
        <trans-unit id="3714e6d8f0e24eacd7b52251a4d193e3636ffbc7" translate="yes" xml:space="preserve">
          <source>Let's start with an example: a procedure that finds the index of a character in a string.</source>
          <target state="translated">Comencemos con un ejemplo:un procedimiento que encuentra el índice de un personaje en una cadena.</target>
        </trans-unit>
        <trans-unit id="1be636c6149d23a6ac7030b7b471d95740b30580" translate="yes" xml:space="preserve">
          <source>Let's take a look at a procedure with a lot of interesting aspects to get a feel for how procedure calls are broken down.</source>
          <target state="translated">Echemos un vistazo a un procedimiento con un montón de aspectos interesantes para tener una idea de cómo se descomponen las llamadas de procedimiento.</target>
        </trans-unit>
        <trans-unit id="f090ebad1e9028f1098a5af4e5a797eb536bf181" translate="yes" xml:space="preserve">
          <source>Lets</source>
          <target state="translated">Lets</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="0948974278e3b95cbbb246e9eab8bec6da78b254" translate="yes" xml:space="preserve">
          <source>Lexical Analysis</source>
          <target state="translated">Análisis léxico</target>
        </trans-unit>
        <trans-unit id="484504bca1de9d78289cf5ed0ff59489797fb25f" translate="yes" xml:space="preserve">
          <source>Lexical elements</source>
          <target state="translated">Elementos léxicos</target>
        </trans-unit>
        <trans-unit id="fd70e598fcf927041c896f6dc4b87e917b2286bf" translate="yes" xml:space="preserve">
          <source>Library documentation</source>
          <target state="translated">Documentación de la biblioteca</target>
        </trans-unit>
        <trans-unit id="850e532a72f1397362ed6c2e2c7768467301292f" translate="yes" xml:space="preserve">
          <source>Licence of the PCRE library</source>
          <target state="translated">Licencia de la biblioteca PCRE</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Con licencia del MIT.</target>
        </trans-unit>
        <trans-unit id="7babbd6a13612f2b75fad2536bf20e3a90be6f3a" translate="yes" xml:space="preserve">
          <source>Lifting Procs</source>
          <target state="translated">Los procedimientos de levantamiento</target>
        </trans-unit>
        <trans-unit id="133720a88f4f0b2480df1a722653e8f80be2609a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exportc&lt;/code&gt; or &lt;code&gt;importc&lt;/code&gt;, the &lt;code&gt;extern&lt;/code&gt; pragma affects name mangling. The string literal passed to &lt;code&gt;extern&lt;/code&gt; can be a format string:</source>
          <target state="translated">Como &lt;code&gt;exportc&lt;/code&gt; o &lt;code&gt;importc&lt;/code&gt; , el pragma &lt;code&gt;extern&lt;/code&gt; o afecta la alteraci&amp;oacute;n de nombres. La cadena literal pasada a &lt;code&gt;extern&lt;/code&gt; puede ser una cadena de formato:</target>
        </trans-unit>
        <trans-unit id="a89c659521de912108568798c30a4d3b9390dd11" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkDiscardStmt&lt;/code&gt; kind.</source>
          <target state="translated">Como &lt;code&gt;return&lt;/code&gt; , pero con el tipo &lt;code&gt;nnkDiscardStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70b76be5ae3e05bda0dbd20d90abcc0ff40f9de9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkYieldStmt&lt;/code&gt; kind.</source>
          <target state="translated">Como &lt;code&gt;return&lt;/code&gt; , pero con el tipo &lt;code&gt;nnkYieldStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cf638ae85ebba4736e92856cb8c627ef275c96" translate="yes" xml:space="preserve">
          <source>Like a plain &lt;code&gt;import&lt;/code&gt; statement but with &lt;code&gt;nnkIncludeStmt&lt;/code&gt;.</source>
          <target state="translated">Como una declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n simple pero con &lt;code&gt;nnkIncludeStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63a95e62d7c911dbac4f0639f9bb4cb823deae98" translate="yes" xml:space="preserve">
          <source>Like in many other programming languages, a &lt;code&gt;continue&lt;/code&gt; statement starts the next iteration immediately:</source>
          <target state="translated">Como en muchos otros lenguajes de programaci&amp;oacute;n, una instrucci&amp;oacute;n &lt;code&gt;continue&lt;/code&gt; inicia la siguiente iteraci&amp;oacute;n inmediatamente:</target>
        </trans-unit>
        <trans-unit id="35a4297befbf3cbceda9715d4684f55b9e927a9e" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;if&lt;/code&gt; statement, but the root has the kind &lt;code&gt;nnkWhenStmt&lt;/code&gt;.</source>
          <target state="translated">Como la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; , pero la ra&amp;iacute;z tiene el tipo &lt;code&gt;nnkWhenStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab04aac5a7e1d598d2f186753e388a3731d77143" translate="yes" xml:space="preserve">
          <source>Like tuples, objects are a means to pack different values together in a structured way. However, objects provide many features that tuples do not: They provide inheritance and information hiding. Because objects encapsulate data, the &lt;code&gt;T()&lt;/code&gt; object constructor should only be used internally and the programmer should provide a proc to initialize the object (this is called a &lt;em&gt;constructor&lt;/em&gt;).</source>
          <target state="translated">Al igual que las tuplas, los objetos son un medio para agrupar diferentes valores de forma estructurada. Sin embargo, los objetos proporcionan muchas caracter&amp;iacute;sticas que las tuplas no ofrecen: proporcionan herencia y ocultaci&amp;oacute;n de informaci&amp;oacute;n. Debido a que los objetos encapsulan datos, el constructor de objetos &lt;code&gt;T()&lt;/code&gt; solo debe usarse internamente y el programador debe proporcionar un proceso para inicializar el objeto (esto se llama &lt;em&gt;constructor&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="07bc01629a98c42a6a26d28d793349cd9ddcb413" translate="yes" xml:space="preserve">
          <source>Likewise &lt;code&gt;T = ref T&lt;/code&gt; is an invalid type.</source>
          <target state="translated">Asimismo, &lt;code&gt;T = ref T&lt;/code&gt; es un tipo no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="012148b3c7c09fe4183a821ac0dfc3df94a4644a" translate="yes" xml:space="preserve">
          <source>Likewise for generic matches the most specialized generic type (that still matches) is preferred:</source>
          <target state="translated">Asimismo,para las coincidencias genéricas se prefiere el tipo genérico más especializado (que sigue coincidiendo):</target>
        </trans-unit>
        <trans-unit id="9fe316ffb5c502363f1602369491e5771962db68" translate="yes" xml:space="preserve">
          <source>Likewise the following does not make sense as the name is &lt;code&gt;strutils&lt;/code&gt; already:</source>
          <target state="translated">Del mismo modo, lo siguiente no tiene sentido ya que el nombre ya es &lt;code&gt;strutils&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="79cb6c70879ccadb6a188effd65c3c269014aee8" translate="yes" xml:space="preserve">
          <source>Limitations of the method call syntax</source>
          <target state="translated">Limitaciones del método llamado sintaxis</target>
        </trans-unit>
        <trans-unit id="7556b5753ea0ca8128d6f780d7fa036fc5b03486" translate="yes" xml:space="preserve">
          <source>Limitations/Bugs</source>
          <target state="translated">Limitations/Bugs</target>
        </trans-unit>
        <trans-unit id="81e5623d345118d762dbee1a0e1de32ed5723969" translate="yes" xml:space="preserve">
          <source>Limitations: If used within nim VM context &lt;code&gt;sizeof&lt;/code&gt; will only work for simple types.</source>
          <target state="translated">Limitaciones: Si se usa dentro del contexto de nim VM, &lt;code&gt;sizeof&lt;/code&gt; solo funcionar&amp;aacute; para tipos simples.</target>
        </trans-unit>
        <trans-unit id="4c46adaafc40b789df2ecf20dd985f671faba467" translate="yes" xml:space="preserve">
          <source>Line exceeds the maximum length.</source>
          <target state="translated">La línea excede la longitud máxima.</target>
        </trans-unit>
        <trans-unit id="223cc1feb0fa894d9ee9937b64e7b5859c71bc96" translate="yes" xml:space="preserve">
          <source>Line where the symbol is located in the file. Lines start to count at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">L&amp;iacute;nea donde se encuentra el s&amp;iacute;mbolo en el archivo. Las l&amp;iacute;neas comienzan a contar en &lt;strong&gt;1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6975daf276430ee5b07e3f0247df76b80c98d27d" translate="yes" xml:space="preserve">
          <source>LineDir option</source>
          <target state="translated">Opción LineDir</target>
        </trans-unit>
        <trans-unit id="268d8379173ac37e106048c36fff01d9c9b4910e" translate="yes" xml:space="preserve">
          <source>LineTooLong</source>
          <target state="translated">LineTooLong</target>
        </trans-unit>
        <trans-unit id="064387f46f31232c3427cd5f69fac7318fd9f966" translate="yes" xml:space="preserve">
          <source>LineTrace option</source>
          <target state="translated">Opción LineTrace</target>
        </trans-unit>
        <trans-unit id="ac3679d78b17b02969cddb03c164e6e2d4dc3390" translate="yes" xml:space="preserve">
          <source>Lines should be no longer than 80 characters. Limiting the amount of information present on each line makes for more readable code - the reader has smaller chunks to process.</source>
          <target state="translated">Las líneas no deben tener más de 80 caracteres.Limitar la cantidad de información presente en cada línea hace que el código sea más legible-el lector tiene trozos más pequeños para procesar.</target>
        </trans-unit>
        <trans-unit id="b0876c4bcec0ae3cbb0d666f7829f1981ec34562" translate="yes" xml:space="preserve">
          <source>Lines starting with &lt;code&gt;&amp;gt;&lt;/code&gt; indicate a command to be sent to the compiler and the lines following a command include checks for expected or forbidden output (&lt;code&gt;!&lt;/code&gt; for forbidden).</source>
          <target state="translated">Las l&amp;iacute;neas que comienzan con &lt;code&gt;&amp;gt;&lt;/code&gt; indican un comando que se enviar&amp;aacute; al compilador y las l&amp;iacute;neas que siguen a un comando incluyen comprobaciones de salida esperada o prohibida ( &lt;code&gt;!&lt;/code&gt; For prohibido).</target>
        </trans-unit>
        <trans-unit id="d0517071aa376e797705058bbad4b658954b9930" translate="yes" xml:space="preserve">
          <source>Link</source>
          <target state="translated">Link</target>
        </trans-unit>
        <trans-unit id="1c3cb2684d19be6954dbbdc4f8e73df679e8e5d0" translate="yes" xml:space="preserve">
          <source>Link pragma</source>
          <target state="translated">Vincular la pragmática</target>
        </trans-unit>
        <trans-unit id="9da74ab1a4b986bea87990a9a620e399e5636c76" translate="yes" xml:space="preserve">
          <source>Linking phase.</source>
          <target state="translated">Fase de enlace.</target>
        </trans-unit>
        <trans-unit id="29298813156f944560ccc7706430702f6f4ee582" translate="yes" xml:space="preserve">
          <source>List comprehension, returns a sequence. &lt;em&gt;comp&lt;/em&gt; is the actual list comprehension, for example &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt;. &lt;em&gt;typ&lt;/em&gt; is the type that will be stored inside the result seq.</source>
          <target state="translated">Comprensi&amp;oacute;n de listas, devuelve una secuencia. &lt;em&gt;comp&lt;/em&gt; es la comprensi&amp;oacute;n de la lista real, por ejemplo &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt; . &lt;em&gt;typ&lt;/em&gt; es el tipo que se almacenar&amp;aacute; dentro de la secuencia de resultados.</target>
        </trans-unit>
        <trans-unit id="f8243f1d71ba9600f36e4fd5c7ce82f383a50045" translate="yes" xml:space="preserve">
          <source>List of hints</source>
          <target state="translated">Lista de pistas</target>
        </trans-unit>
        <trans-unit id="5516fee04290d8fb240eb1035f9649b7af9c46bc" translate="yes" xml:space="preserve">
          <source>List of warnings</source>
          <target state="translated">Lista de advertencias</target>
        </trans-unit>
        <trans-unit id="104e72166267b2e14189f97dfc051685f78e0501" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory.</source>
          <target state="translated">Lista todos los archivos en &lt;code&gt;dir&lt;/code&gt; . Si &lt;code&gt;dir&lt;/code&gt; es &lt;code&gt;&quot;&quot;&lt;/code&gt; , usa el directorio de trabajo actual.</target>
        </trans-unit>
        <trans-unit id="1ab878ae07a9cde029575d5b2c8f1f1831aa46a7" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory. If &lt;code&gt;async&lt;/code&gt; is true, this function will return immediately and it will be your job to call asyncio's &lt;code&gt;poll&lt;/code&gt; to progress this operation.</source>
          <target state="translated">Lista todos los archivos en &lt;code&gt;dir&lt;/code&gt; . Si &lt;code&gt;dir&lt;/code&gt; es &lt;code&gt;&quot;&quot;&lt;/code&gt; , usa el directorio de trabajo actual. Si &lt;code&gt;async&lt;/code&gt; es verdadero, esta funci&amp;oacute;n regresar&amp;aacute; inmediatamente y ser&amp;aacute; su trabajo llamar a la &lt;code&gt;poll&lt;/code&gt; de asyncio para avanzar en esta operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="236263cf5e9fb34d2dba2a5c051ef5dc5349c21d" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">Literal &lt;code&gt;&quot;&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="b0e13df3237422a975bbec14b9ac839dee36c914" translate="yes" xml:space="preserve">
          <source>Literal match: &lt;code&gt;a&lt;/code&gt; is an integer literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a signed or unsigned integer type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range. Or: &lt;code&gt;a&lt;/code&gt; is a floating point literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a floating point type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range.</source>
          <target state="translated">Partido literal: &lt;code&gt;a&lt;/code&gt; es un literal entero de valor &lt;code&gt;v&lt;/code&gt; y &lt;code&gt;f&lt;/code&gt; es un tipo entero con o sin signo y &lt;code&gt;v&lt;/code&gt; est&amp;aacute; en &lt;code&gt;f&lt;/code&gt; gama 's. O bien: &lt;code&gt;a&lt;/code&gt; es un punto literal flotante del valor de &lt;code&gt;v&lt;/code&gt; , y &lt;code&gt;f&lt;/code&gt; es un tipo de punto flotante y &lt;code&gt;v&lt;/code&gt; es en &lt;code&gt;f&lt;/code&gt; gama 's.</target>
        </trans-unit>
        <trans-unit id="b9727a86e89a8cbd82800b60294dabca16499a86" translate="yes" xml:space="preserve">
          <source>Literals are bounds checked so that they fit the datatype. Non base-10 literals are used mainly for flags and bit pattern representations, therefore bounds checking is done on bit width, not value range. If the literal fits in the bit width of the datatype, it is accepted. Hence: 0b10000000'u8 == 0x80'u8 == 128, but, 0b10000000'i8 == 0x80'i8 == -1 instead of causing an overflow error.</source>
          <target state="translated">Los literales se comprueban para que se ajusten al tipo de datos.Los literales que no son de base 10 se utilizan principalmente para banderas y representaciones de patrones de bits,por lo que la comprobación de límites se hace en el ancho de los bits,no en el rango de valores.Si el literal encaja en el ancho de bit del tipo de datos,se acepta.Por lo tanto:0b10000000'u8 ==0x80'u8 ==128,pero,0b10000000'i8 ==0x80'i8 ==-1 en lugar de causar un error de desbordamiento.</target>
        </trans-unit>
        <trans-unit id="8b2a6eba528cf2e8ab33fb4a2bec0b163b834789" translate="yes" xml:space="preserve">
          <source>Literals are compile-time computable.</source>
          <target state="translated">Los literales son computables en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="de51bd63110c92754499c41c1b9fc0a1062026bc" translate="yes" xml:space="preserve">
          <source>Load the specified configuration file into a new Config instance.</source>
          <target state="translated">Cargue el archivo de configuración especificado en una nueva instancia de configuración.</target>
        </trans-unit>
        <trans-unit id="1a9e1513745115068212c830b486292757f91900" translate="yes" xml:space="preserve">
          <source>Load the specified configuration from stream into a new Config instance. &lt;em&gt;filename&lt;/em&gt; parameter is only used for nicer error messages.</source>
          <target state="translated">Cargue la configuraci&amp;oacute;n especificada de la secuencia en una nueva instancia de configuraci&amp;oacute;n. &lt;em&gt;El&lt;/em&gt; par&amp;aacute;metro de &lt;em&gt;nombre de archivo&lt;/em&gt; solo se usa para mensajes de error m&amp;aacute;s agradables.</target>
        </trans-unit>
        <trans-unit id="a139e4bbf5ca5504f1d17d1d98e927f4b59c9a47" translate="yes" xml:space="preserve">
          <source>Loading a simple C function</source>
          <target state="translated">Cargando una simple función C</target>
        </trans-unit>
        <trans-unit id="d468cd435069219754afbbe7d097d97a919d76a4" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">Carga y analiza HTML desde el archivo especificado por la &lt;code&gt;path&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Todos los errores de an&amp;aacute;lisis se ignoran.</target>
        </trans-unit>
        <trans-unit id="e13175d1bc7af2e5d6755aeb721e7338069be90d" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;em&gt;errors&lt;/em&gt; sequence.</source>
          <target state="translated">Carga y analiza HTML desde el archivo especificado por la &lt;code&gt;path&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Cada error de an&amp;aacute;lisis producido se agrega a la secuencia de &lt;em&gt;errores&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4296f849be147d08fdb9d341d2ab77c8da850fd7" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">Carga y analiza XML desde un archivo especificado por &lt;code&gt;path&lt;/code&gt; y devuelve un &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e2e2e83d566103f2e7459a72bbf8e836f49d66" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a stream specified by &lt;code&gt;stream&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">Carga y analiza XML de un flujo especificado por &lt;code&gt;stream&lt;/code&gt; y devuelve un &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="045d13349b264d2eba76a0804c08fa59e6a17cff" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a string specified by &lt;code&gt;xml&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">Carga y analiza XML desde una cadena especificada por &lt;code&gt;xml&lt;/code&gt; y devuelve un &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9e01e6b541364451c7b06cd42daa257c56a015" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">Carga y analiza XML desde el archivo especificado por la &lt;code&gt;path&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Todos los errores de an&amp;aacute;lisis se convierten en una excepci&amp;oacute;n &lt;code&gt;XmlError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58715b2c04bf6ee07528232196803acf3ddcf9e8" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;code&gt;errors&lt;/code&gt; sequence.</source>
          <target state="translated">Carga y analiza XML desde el archivo especificado por la &lt;code&gt;path&lt;/code&gt; y devuelve un &lt;code&gt;XmlNode&lt;/code&gt; . Cada error de an&amp;aacute;lisis producido se agrega a la secuencia de &lt;code&gt;errors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7db461111deca6d0f8236779f0bb1263494a8e8" translate="yes" xml:space="preserve">
          <source>Lock levels</source>
          <target state="translated">Niveles de bloqueo</target>
        </trans-unit>
        <trans-unit id="98f1e767de995c2aa21fe38394145cda4db0f95d" translate="yes" xml:space="preserve">
          <source>Lock levels are used to enforce a global locking order in order to prevent deadlocks at compile-time. A lock level is an constant integer in the range 0..1_000. Lock level 0 means that no lock is acquired at all.</source>
          <target state="translated">Los niveles de bloqueo se utilizan para hacer cumplir una orden de bloqueo global con el fin de evitar bloqueos en tiempo de compilación.Un nivel de bloqueo es un entero constante en el rango 0..1_000.El nivel de bloqueo 0 significa que no se adquiere ningún bloqueo.</target>
        </trans-unit>
        <trans-unit id="a026b72d4824601afcdf130fca670d0c8d13f97d" translate="yes" xml:space="preserve">
          <source>Locks and routines can be annotated with &lt;span id=&quot;lock-levels_1&quot;&gt;lock levels&lt;/span&gt; to prevent deadlocks at compile time.</source>
          <target state="translated">Los bloqueos y rutinas se pueden anotar con &lt;span id=&quot;lock-levels_1&quot;&gt;niveles de bloqueo&lt;/span&gt; para evitar interbloqueos en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8e5c380132554658df14cbe018d3eebcce0b49de" translate="yes" xml:space="preserve">
          <source>Logs a debug message to all registered handlers.</source>
          <target state="translated">Registra un mensaje de depuración a todos los manejadores registrados.</target>
        </trans-unit>
        <trans-unit id="4c7f919536de93b8ad43c3247437839e50803cac" translate="yes" xml:space="preserve">
          <source>Logs a fatal error message to all registered handlers.</source>
          <target state="translated">Registra un mensaje de error fatal a todos los manejadores registrados.</target>
        </trans-unit>
        <trans-unit id="5dfc8bdbe4c51442cb3331391bf133dae2303823" translate="yes" xml:space="preserve">
          <source>Logs a message to all registered handlers at the given level.</source>
          <target state="translated">Registra un mensaje a todos los manejadores registrados en el nivel dado.</target>
        </trans-unit>
        <trans-unit id="57d8e0636873737f16f4b7cc780f237140e75837" translate="yes" xml:space="preserve">
          <source>Logs a warning message to all registered handlers.</source>
          <target state="translated">Registra un mensaje de advertencia a todos los manejadores registrados.</target>
        </trans-unit>
        <trans-unit id="9317adaad7621328486bdf8c1ddb1b9fc41f1e55" translate="yes" xml:space="preserve">
          <source>Logs an error message to all registered handlers.</source>
          <target state="translated">Registra un mensaje de error a todos los manejadores registrados.</target>
        </trans-unit>
        <trans-unit id="4b60a8dc51101a47288a87fdd0bfadc5f86cbf8e" translate="yes" xml:space="preserve">
          <source>Logs an info message to all registered handlers.</source>
          <target state="translated">Registra un mensaje de información a todos los manejadores registrados.</target>
        </trans-unit>
        <trans-unit id="d163792610c410f93f355f367ec68f39a5ba2888" translate="yes" xml:space="preserve">
          <source>Logs an notice message to all registered handlers.</source>
          <target state="translated">Registra un mensaje de aviso a todos los manejadores registrados.</target>
        </trans-unit>
        <trans-unit id="968b9d0e2a2ece8aa91b1cc23a28091c21b0a82f" translate="yes" xml:space="preserve">
          <source>Logs to a file using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">Se registra en un archivo utilizando &amp;uacute;nicamente el &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9ec4044346457b95a04e72c6feb17b0ce890ff" translate="yes" xml:space="preserve">
          <source>Logs to a file using rolling &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">Se registra en un archivo utilizando &amp;uacute;nicamente el &lt;code&gt;logger&lt;/code&gt; rodante .</target>
        </trans-unit>
        <trans-unit id="50128c469a86270a2da91f8b00b431458f68392b" translate="yes" xml:space="preserve">
          <source>Logs to the console using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">Inicia sesi&amp;oacute;n en la consola usando &amp;uacute;nicamente el &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ee53aa3b26fe91c5819ca15b134a56f645ac1e" translate="yes" xml:space="preserve">
          <source>Lookup rules for template parameters</source>
          <target state="translated">Reglas de búsqueda para los parámetros de la plantilla</target>
        </trans-unit>
        <trans-unit id="ce44bf0dea95522d8571be7ae1c1bf020f1c61c5" translate="yes" xml:space="preserve">
          <source>Loopback address.</source>
          <target state="translated">Dirección del bucle de retorno.</target>
        </trans-unit>
        <trans-unit id="ed3b229a877674fc9085bfff9aad369487b7967d" translate="yes" xml:space="preserve">
          <source>Lossless &lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Automatic type conversion&lt;/span&gt; is performed in expressions where different kinds of integer types are used. However, if the type conversion would cause loss of information, the &lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt; exception is raised (if the error cannot be detected at compile time).</source>
          <target state="translated">&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;La conversi&amp;oacute;n autom&amp;aacute;tica&lt;/span&gt; sin p&amp;eacute;rdida de &lt;span id=&quot;automatic-type-conversion_1&quot;&gt;tipos&lt;/span&gt; se realiza en expresiones en las que se utilizan diferentes tipos de tipos enteros. Sin embargo, si la conversi&amp;oacute;n de tipo causara p&amp;eacute;rdida de informaci&amp;oacute;n, se &lt;span id=&quot;eoutofrange_1&quot;&gt;genera la&lt;/span&gt; excepci&amp;oacute;n &lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt; (si el error no se puede detectar en el momento de la compilaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="5ca6f7c7b2f3fcead3d5cf315885d15734fca9dc" translate="yes" xml:space="preserve">
          <source>Lots of other small issues...</source>
          <target state="translated">Muchas otras pequeñas cuestiones...</target>
        </trans-unit>
        <trans-unit id="b8a68b12b71fd0a8e62d67043581d497f4e0c387" translate="yes" xml:space="preserve">
          <source>Macro declaration</source>
          <target state="translated">Declaración de la macrodeclaración</target>
        </trans-unit>
        <trans-unit id="d5f312834ff09b9cbab1f1a3ebc0bbe0f1a19b93" translate="yes" xml:space="preserve">
          <source>Macro which converts normal procedures into javascript-compatible async procedures</source>
          <target state="translated">Macro que convierte los procedimientos normales en procedimientos de asincronía compatibles con javascript</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="bcf4850e55a2614c2efa81a2629e41ec19afef8b" translate="yes" xml:space="preserve">
          <source>Macros as pragmas</source>
          <target state="translated">Macros los pragmas</target>
        </trans-unit>
        <trans-unit id="980cf51d761ff2e575f35b48bf655118288e07f9" translate="yes" xml:space="preserve">
          <source>Macros behave like templates, but &lt;code&gt;nnkTemplateDef&lt;/code&gt; is replaced with &lt;code&gt;nnkMacroDef&lt;/code&gt;.</source>
          <target state="translated">Las macros se comportan como plantillas, pero &lt;code&gt;nnkTemplateDef&lt;/code&gt; se reemplaza por &lt;code&gt;nnkMacroDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fabe264274a80515010384b77dc0559e962ca19d" translate="yes" xml:space="preserve">
          <source>Macros enable advanced compile-time code transformations, but they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway. Macros have to be implemented in pure Nim code if the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;foreign function interface (FFI)&lt;/a&gt; is not enabled in the compiler, but other than that restriction (which at some point in the future will go away) you can write any kind of Nim code and the compiler will run it at compile time.</source>
          <target state="translated">Las macros permiten transformaciones de c&amp;oacute;digo en tiempo de compilaci&amp;oacute;n avanzadas, pero no pueden cambiar la sintaxis de Nim. Sin embargo, esto no es una restricci&amp;oacute;n real porque la sintaxis de Nim es lo suficientemente flexible de todos modos. Las macros deben implementarse en c&amp;oacute;digo Nim puro si la &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;interfaz de funci&amp;oacute;n externa (FFI)&lt;/a&gt; no est&amp;aacute; habilitada en el compilador, pero aparte de esa restricci&amp;oacute;n (que en alg&amp;uacute;n momento en el futuro desaparecer&amp;aacute;), puede escribir cualquier tipo de c&amp;oacute;digo Nim y el compilador lo ejecutar&amp;aacute; en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4316199fa5a1551b8a3aa00b57acfb7552982193" translate="yes" xml:space="preserve">
          <source>Macros module includes helpers which can be used to simplify custom pragma access &lt;em&gt;hasCustomPragma&lt;/em&gt;, &lt;em&gt;getCustomPragmaVal&lt;/em&gt;. Please consult macros module documentation for details. These macros are no magic, they don't do anything you cannot do yourself by walking AST object representation.</source>
          <target state="translated">El m&amp;oacute;dulo de macros incluye ayudantes que se pueden usar para simplificar el acceso a pragma personalizado &lt;em&gt;hasCustomPragma&lt;/em&gt; , &lt;em&gt;getCustomPragmaVal&lt;/em&gt; . Consulte la documentaci&amp;oacute;n del m&amp;oacute;dulo de macros para obtener m&amp;aacute;s detalles. Estas macros no son m&amp;aacute;gicas, no hacen nada que no puedas hacer t&amp;uacute; mismo al caminar la representaci&amp;oacute;n de objetos AST.</target>
        </trans-unit>
        <trans-unit id="fcb1a29368fba3810f040b19c708029e63713744" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;osproc&lt;/code&gt; use &lt;code&gt;fork&lt;/code&gt; instead of &lt;code&gt;posix_spawn&lt;/code&gt;.</source>
          <target state="translated">Hace que &lt;code&gt;osproc&lt;/code&gt; use &lt;code&gt;fork&lt;/code&gt; en lugar de &lt;code&gt;posix_spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c651f2d69bb1c5e0aa5eb7b1418517d939a6973" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log.</source>
          <target state="translated">Hace que la salida de Nim se rastree a stdout,en vez de al registro del servidor.</target>
        </trans-unit>
        <trans-unit id="499d78e3579f7c7ce46ccd08c0c7e05dcf497fe4" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log. Depracated alias for setStackTraceStdout.</source>
          <target state="translated">Hace que la salida de Nim se rastree a stdout,en vez de al registro del servidor.Un alias privado para setStackTraceStdout.</target>
        </trans-unit>
        <trans-unit id="2e3d974a9298c4b4ebf6fa1f9cde4cea6a610923" translate="yes" xml:space="preserve">
          <source>Makes Nim use C's &lt;span id=&quot;malloc_1&quot;&gt;malloc&lt;/span&gt; instead of Nim's own memory manager, ableit prefixing each allocation with its size to support clearing memory on reallocation. This only works with &lt;code&gt;gc:none&lt;/code&gt;.</source>
          <target state="translated">Hace que Nim use &lt;span id=&quot;malloc_1&quot;&gt;malloc&lt;/span&gt; de C en lugar del administrador de memoria propio de Nim, pudiendo prefijar cada asignaci&amp;oacute;n con su tama&amp;ntilde;o para permitir borrar la memoria en la reasignaci&amp;oacute;n. Esto solo funciona con &lt;code&gt;gc:none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c24f6fa722204e68ea302ade8ca94caa0a75902" translate="yes" xml:space="preserve">
          <source>Mandatory term being indexed. Terms can include quoting according to Nim's rules (eg. `^`).</source>
          <target state="translated">Término obligatorio que se está indexando.Los términos pueden incluir citas de acuerdo a las reglas de Nim (por ejemplo,`^`).</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="8b04fd7fca9bde6ca081d5a883719b86d91603ee" translate="yes" xml:space="preserve">
          <source>Manual: AST based overloading</source>
          <target state="translated">Manual:Sobrecarga basada en la AST</target>
        </trans-unit>
        <trans-unit id="defb0de64fe7ca08a6ed982374de4bb9a85c2662" translate="yes" xml:space="preserve">
          <source>Manual: Effect system</source>
          <target state="translated">Manual:Sistema de efectos</target>
        </trans-unit>
        <trans-unit id="c96afc4df608947a129115509fc6ac1d02f56202" translate="yes" xml:space="preserve">
          <source>Manual: Exception handling</source>
          <target state="translated">Manual:Manejo de excepciones</target>
        </trans-unit>
        <trans-unit id="ddfc1de56c3bd1d03afdd4142362226685aca4b2" translate="yes" xml:space="preserve">
          <source>Manual: Foreign function interface</source>
          <target state="translated">Manual:Interfaz de funciones externas</target>
        </trans-unit>
        <trans-unit id="e56aa0932cbe0a4d0a9778061468fdfecc37f816" translate="yes" xml:space="preserve">
          <source>Manual: Generics</source>
          <target state="translated">Manual:Generics</target>
        </trans-unit>
        <trans-unit id="5774a3094051cc1a01178d4abbdf9174054d2afa" translate="yes" xml:space="preserve">
          <source>Manual: Guards and locks</source>
          <target state="translated">Manual:Guardias y cerraduras</target>
        </trans-unit>
        <trans-unit id="034ba2f8aa22d8c1659925669461f5c6bb46d48d" translate="yes" xml:space="preserve">
          <source>Manual: Implementation Specific Pragmas</source>
          <target state="translated">Manual:Implementación de Pragmas específicos</target>
        </trans-unit>
        <trans-unit id="5b04a062ff7cc9d86ce05472065106035a8097fa" translate="yes" xml:space="preserve">
          <source>Manual: Import statement Include statement Module names in imports Collective imports from a directory Pseudo import/include paths From import statement Export statement</source>
          <target state="translated">Manual:Declaración de importación Incluir declaración Nombres de módulos en las importaciones Importaciones colectivas desde un directorio Seudoimportación/incluir rutas Desde la declaración de importación Declaración de exportación</target>
        </trans-unit>
        <trans-unit id="fd76cbedf6737eb16d94623f5ae0365ae0d604f1" translate="yes" xml:space="preserve">
          <source>Manual: Iterators and the for statement</source>
          <target state="translated">Manual:Iteradores y la declaración de for</target>
        </trans-unit>
        <trans-unit id="a243b6fe56c421c23e6ef513dd30b788f1257a68" translate="yes" xml:space="preserve">
          <source>Manual: Lexical Analysis</source>
          <target state="translated">Manual:Análisis léxico</target>
        </trans-unit>
        <trans-unit id="ed3d84a9118355ed8740c1a7b3f3b4c841535124" translate="yes" xml:space="preserve">
          <source>Manual: Macros</source>
          <target state="translated">Manual:Macros</target>
        </trans-unit>
        <trans-unit id="4bafc4dbfa5c0e3c58d2fb274d692bbf25d243fc" translate="yes" xml:space="preserve">
          <source>Manual: Modules</source>
          <target state="translated">Manual:Módulos</target>
        </trans-unit>
        <trans-unit id="9a290e826830f6686d0f05fcc67ab7c270d95dbb" translate="yes" xml:space="preserve">
          <source>Manual: Multi-methods</source>
          <target state="translated">Manual:Multi-métodos</target>
        </trans-unit>
        <trans-unit id="11714535fa66e7fe2732c23bbc152d68d14f704d" translate="yes" xml:space="preserve">
          <source>Manual: Overloading resolution</source>
          <target state="translated">Manual:Resolución de sobrecarga</target>
        </trans-unit>
        <trans-unit id="856ff8f109b24f9933255ac3581aadee568cd2dc" translate="yes" xml:space="preserve">
          <source>Manual: Parallel &amp;amp; Spawn</source>
          <target state="translated">Manual: Paralelo y aparici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="7ec22936b55b7f305c2be8dba10aa5109567b287" translate="yes" xml:space="preserve">
          <source>Manual: Pragmas</source>
          <target state="translated">Manual:Pragmas</target>
        </trans-unit>
        <trans-unit id="770e4cc3468cd2ab34e2292349c2fc7f1254bba1" translate="yes" xml:space="preserve">
          <source>Manual: Procedures</source>
          <target state="translated">Manual:Procedimientos</target>
        </trans-unit>
        <trans-unit id="1b494587e353e28a4fb14cede5251f048106d63a" translate="yes" xml:space="preserve">
          <source>Manual: Special Operators</source>
          <target state="translated">Manual:Operadores especiales</target>
        </trans-unit>
        <trans-unit id="67456811ead6b001268c25ae75d8eb80bf9b78d4" translate="yes" xml:space="preserve">
          <source>Manual: Special Types</source>
          <target state="translated">Manual:Tipos especiales</target>
        </trans-unit>
        <trans-unit id="6decf7713585353b542d22a07833a9e3f4608374" translate="yes" xml:space="preserve">
          <source>Manual: Statements and expressions</source>
          <target state="translated">Manual:Declaraciones y expresiones</target>
        </trans-unit>
        <trans-unit id="c06b311819398e9a7a08be8caed1736017ac7522" translate="yes" xml:space="preserve">
          <source>Manual: Syntax</source>
          <target state="translated">Manual:Sintaxis</target>
        </trans-unit>
        <trans-unit id="bacd5ce7b4fc6c233337b20743738357eb3d4917" translate="yes" xml:space="preserve">
          <source>Manual: Templates</source>
          <target state="translated">Manual:Plantillas</target>
        </trans-unit>
        <trans-unit id="817f3b64b7fab30fc4fa2987f47b2de7d799191c" translate="yes" xml:space="preserve">
          <source>Manual: Term rewriting macros</source>
          <target state="translated">Manual:Macros de reescritura de términos</target>
        </trans-unit>
        <trans-unit id="cbe3bd9f8e9a36414594a7b27bafcc1a597a3da5" translate="yes" xml:space="preserve">
          <source>Manual: Threads</source>
          <target state="translated">Manual:Hilos</target>
        </trans-unit>
        <trans-unit id="aafb451a891596fbad0f0184b0ad302e74ebffc7" translate="yes" xml:space="preserve">
          <source>Manual: Type bound operations</source>
          <target state="translated">Manual:Operaciones de tipo vinculante</target>
        </trans-unit>
        <trans-unit id="166a47f26935d8e4d08a27d4c17c4e1d1999f722" translate="yes" xml:space="preserve">
          <source>Manual: Type relations</source>
          <target state="translated">Manual:Escriba las relaciones...</target>
        </trans-unit>
        <trans-unit id="bd029877fffa549daa894766df47948479afd2f1" translate="yes" xml:space="preserve">
          <source>Manual: Types</source>
          <target state="translated">Manual:Tipos</target>
        </trans-unit>
        <trans-unit id="2a1633f65bbc398d71c3ebfc3241c0af807273d5" translate="yes" xml:space="preserve">
          <source>Mark the test as skipped. Should be used directly in case when it is not possible to perform test for reasons depending on outer environment, or certain application logic conditions or configurations. The test code is still executed.</source>
          <target state="translated">Marque la prueba como omitida.Debe utilizarse directamente en caso de que no sea posible realizar la prueba por razones que dependen del entorno exterior,o de ciertas condiciones o configuraciones lógicas de la aplicación.El código de prueba sigue ejecutándose.</target>
        </trans-unit>
        <trans-unit id="1d3b7aa9b4c642f5735f40da06dfed06fbca163e" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;socket&lt;/code&gt; as accepting connections. &lt;code&gt;Backlog&lt;/code&gt; specifies the maximum length of the queue of pending connections.</source>
          <target state="translated">Marca el &lt;code&gt;socket&lt;/code&gt; como aceptando conexiones. &lt;code&gt;Backlog&lt;/code&gt; especifica la longitud m&amp;aacute;xima de la cola de conexiones pendientes.</target>
        </trans-unit>
        <trans-unit id="f07f226b4437e06fea4e70beb870cd20dccb2b33" translate="yes" xml:space="preserve">
          <source>Matches a binary integer. This uses &lt;code&gt;parseutils.parseBin&lt;/code&gt;.</source>
          <target state="translated">Coincide con un entero binario. Esto usa &lt;code&gt;parseutils.parseBin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61f72fda5d63c33af385805c251186ac41827a95" translate="yes" xml:space="preserve">
          <source>Matches a character set</source>
          <target state="translated">Coincide con un conjunto de personajes</target>
        </trans-unit>
        <trans-unit id="7c21df5bb89686108056b549eda7fc196d394426" translate="yes" xml:space="preserve">
          <source>Matches a decimal integer. This uses &lt;code&gt;parseutils.parseInt&lt;/code&gt;.</source>
          <target state="translated">Coincide con un entero decimal. Esto usa &lt;code&gt;parseutils.parseInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12cb4b049a1da7e03f068b60b69ca0670549bfd" translate="yes" xml:space="preserve">
          <source>Matches a floating pointer number. Uses &lt;code&gt;parseFloat&lt;/code&gt;.</source>
          <target state="translated">Coincide con un n&amp;uacute;mero de puntero flotante. Utiliza &lt;code&gt;parseFloat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2464cd36660069f3fcf2e58ee0a418607e32a9bc" translate="yes" xml:space="preserve">
          <source>Matches a hex integer. This uses &lt;code&gt;parseutils.parseHex&lt;/code&gt;.</source>
          <target state="translated">Coincide con un entero hexadecimal. Esto usa &lt;code&gt;parseutils.parseHex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="532fa54ee42246846545dbf2fc331f03ad0daeed" translate="yes" xml:space="preserve">
          <source>Matches a single character</source>
          <target state="translated">Coincide con un solo personaje...</target>
        </trans-unit>
        <trans-unit id="e01edc99d3df652b0b10d0cd88889a4c6db28db5" translate="yes" xml:space="preserve">
          <source>Matches a single dollar sign.</source>
          <target state="translated">Coincide con un solo signo de dólar.</target>
        </trans-unit>
        <trans-unit id="56b8550638d15898163432e2ef863037d24cf3ab" translate="yes" xml:space="preserve">
          <source>Matches a string</source>
          <target state="translated">Coincide con una cadena</target>
        </trans-unit>
        <trans-unit id="2b0f27dc90ddd03570b6691c4598abffade1d014" translate="yes" xml:space="preserve">
          <source>Matches an ASCII identifier: &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt;.</source>
          <target state="translated">Coincide con un identificador ASCII: &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f19ab90d0dfde58576111f53aea6162591341ee" translate="yes" xml:space="preserve">
          <source>Matches an octal integer. This uses &lt;code&gt;parseutils.parseOct&lt;/code&gt;.</source>
          <target state="translated">Coincide con un entero octal. Esto usa &lt;code&gt;parseutils.parseOct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8507509e46ea139d748c7c784f7cdc32a09d48f7" translate="yes" xml:space="preserve">
          <source>Matches if the end of the input string has been reached.</source>
          <target state="translated">Coincide si se ha alcanzado el final de la cadena de entrada.</target>
        </trans-unit>
        <trans-unit id="44e83eb14a6d865158691b6ead9b69eedf905cb4" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$*&lt;/code&gt; was found. The match is allowed to be of 0 length.</source>
          <target state="translated">Coincidencias hasta que se encuentre el token que sigue a &lt;code&gt;$*&lt;/code&gt; . Se permite que la coincidencia sea de longitud 0.</target>
        </trans-unit>
        <trans-unit id="548a91d3213ffddd1a11e82050c55439466aaf2f" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$+&lt;/code&gt; was found. The match must consist of at least one char.</source>
          <target state="translated">Coincidencias hasta que se encuentre el token que sigue a &lt;code&gt;$+&lt;/code&gt; . La coincidencia debe constar de al menos un car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="ac458e6963c6ebdd9c5ca1f8b279a9eb42dfc913" translate="yes" xml:space="preserve">
          <source>Math libraries</source>
          <target state="translated">Bibliotecas de matemáticas</target>
        </trans-unit>
        <trans-unit id="6e4c4838bcc55297c563147e236843926c319da6" translate="yes" xml:space="preserve">
          <source>Max line length is 80 characters.</source>
          <target state="translated">La longitud máxima de la línea es de 80 caracteres.</target>
        </trans-unit>
        <trans-unit id="353de93dd15ff6db8a4b838f009f42da8fc085cc" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">Exponente máximo (positivo)para los números de 32 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="1d2ac0d1ca31ee91cf5ff6056f9a16027dd8fd2a" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">Exponente máximo (positivo)para los números de 64 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="8bbd4cef55a64a4e58be3f1e60ec750e94d7d807" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">Exponente máximo (positivo)en base 10 para números de 32 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="50184f5eb64ad277177d238e645f028ed1a230ab" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">Exponente máximo (positivo)en base 10 para números de 64 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="ed71d9f1d146dd9fd80c9fea6cf2280768a6a052" translate="yes" xml:space="preserve">
          <source>Maybe you didn't notice, but in the &lt;code&gt;dumpTree&lt;/code&gt; example the first constant explicitly specifies the type of the constant. That's why in the tree output the two last constants have their second child &lt;code&gt;Empty&lt;/code&gt; but the first has a string identifier. So basically a &lt;code&gt;const&lt;/code&gt; definition is made up from an identifier, optionally a type (can be an &lt;em&gt;empty&lt;/em&gt; node) and the value. Armed with this knowledge, let's look at the finished version of the AST building macro:</source>
          <target state="translated">Tal vez no te hayas dado cuenta, pero en el ejemplo de &lt;code&gt;dumpTree&lt;/code&gt; , la primera constante especifica expl&amp;iacute;citamente el tipo de constante. Es por eso que en la salida del &amp;aacute;rbol las dos &amp;uacute;ltimas constantes tienen su segundo hijo &lt;code&gt;Empty&lt;/code&gt; pero la primera tiene un identificador de cadena. Entonces, b&amp;aacute;sicamente, una definici&amp;oacute;n &lt;code&gt;const&lt;/code&gt; ante se compone de un identificador, opcionalmente un tipo (puede ser un nodo &lt;em&gt;vac&amp;iacute;o&lt;/em&gt; ) y el valor. Armados con este conocimiento, veamos la versi&amp;oacute;n terminada de la macro de construcci&amp;oacute;n AST:</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">Gestión de la memoria</target>
        </trans-unit>
        <trans-unit id="9baa9878dfbef1d35fc905168a10b0c4a8c0fbd9" translate="yes" xml:space="preserve">
          <source>Memory safety for returning by &lt;code&gt;var T&lt;/code&gt; is ensured by a simple borrowing rule: If &lt;code&gt;result&lt;/code&gt; does not refer to a location pointing to the heap (that is in &lt;code&gt;result = X&lt;/code&gt; the &lt;code&gt;X&lt;/code&gt; involves a &lt;code&gt;ptr&lt;/code&gt; or &lt;code&gt;ref&lt;/code&gt; access) then it has to be deviated by the routine's first parameter:</source>
          <target state="translated">La seguridad de la memoria para el retorno de &lt;code&gt;var T&lt;/code&gt; est&amp;aacute; garantizada por una regla de pr&amp;eacute;stamo simple: si el &lt;code&gt;result&lt;/code&gt; ado no se refiere a una ubicaci&amp;oacute;n que apunta al mont&amp;oacute;n (es decir, &lt;code&gt;result = X&lt;/code&gt; la &lt;code&gt;X&lt;/code&gt; implica un acceso &lt;code&gt;ptr&lt;/code&gt; o &lt;code&gt;ref&lt;/code&gt; ), entonces debe desviarse por primer par&amp;aacute;metro de la rutina:</target>
        </trans-unit>
        <trans-unit id="50ff34431595cf400d81245be2a86a83f82386dd" translate="yes" xml:space="preserve">
          <source>Merges all index files in &lt;em&gt;dir&lt;/em&gt; and returns the generated index as HTML.</source>
          <target state="translated">Fusiona todos los archivos de &amp;iacute;ndice en &lt;em&gt;dir&lt;/em&gt; y devuelve el &amp;iacute;ndice generado como HTML.</target>
        </trans-unit>
        <trans-unit id="c08446305ac72d52aeff6051e72faf9d7787f9fc" translate="yes" xml:space="preserve">
          <source>Merges all separated TextNodes together, and removes any empty TextNodes</source>
          <target state="translated">Fusiona todos los Nodos de Texto separados entre sí,y elimina cualquier Nodo de Texto vacío</target>
        </trans-unit>
        <trans-unit id="33ef168ac38cdf5d66a3f96ccc53c0bcb2bec97c" translate="yes" xml:space="preserve">
          <source>Messages that are generated during the normal operation of an application and are of no particular importance. Useful to aggregate for potential later analysis.</source>
          <target state="translated">Mensajes que se generan durante el funcionamiento normal de una aplicación y que no tienen una importancia particular.Es útil para agregarlos para un posible análisis posterior.</target>
        </trans-unit>
        <trans-unit id="949ba2d44e279ebf601f54248d567bd067f76669" translate="yes" xml:space="preserve">
          <source>Messages that are useful to the application developer only and are usually turned off in release.</source>
          <target state="translated">Mensajes que sólo son útiles para el desarrollador de la aplicación y que normalmente se desactivan en el lanzamiento.</target>
        </trans-unit>
        <trans-unit id="de329f9988dc07ac218d31798f3d3fb0e319aeeb" translate="yes" xml:space="preserve">
          <source>Method call syntax</source>
          <target state="translated">Sintaxis de la llamada de método</target>
        </trans-unit>
        <trans-unit id="b768cedc4687283126d9b1ed420f777b12a98828" translate="yes" xml:space="preserve">
          <source>Method dispatchers are global.</source>
          <target state="translated">Los despachadores del método son globales.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="3c397a7933a859382d85ab67743d94fecb8793cf" translate="yes" xml:space="preserve">
          <source>Methods and type converters</source>
          <target state="translated">Métodos y convertidores de tipos</target>
        </trans-unit>
        <trans-unit id="70972ae112e939ad343653a1ba078194eea37b73" translate="yes" xml:space="preserve">
          <source>Methods imply &lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt; and idetools performs a static analysis on the code. For this reason idetools may not return the definition of the correct method you are querying because it may be impossible to know until the code is executed. It will try to return the method which covers the most possible cases (i.e. for variations of different classes in a hierarchy it will prefer methods using the base class).</source>
          <target state="translated">Los m&amp;eacute;todos implican &lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;un env&amp;iacute;o din&amp;aacute;mico&lt;/a&gt; y las idetools realizan un an&amp;aacute;lisis est&amp;aacute;tico del c&amp;oacute;digo. Por esta raz&amp;oacute;n, es posible que las idetools no devuelvan la definici&amp;oacute;n del m&amp;eacute;todo correcto que est&amp;aacute; consultando porque puede ser imposible saberlo hasta que se ejecute el c&amp;oacute;digo. Intentar&amp;aacute; devolver el m&amp;eacute;todo que cubre la mayor&amp;iacute;a de los casos posibles (es decir, para variaciones de diferentes clases en una jerarqu&amp;iacute;a, preferir&amp;aacute; m&amp;eacute;todos que utilicen la clase base).</target>
        </trans-unit>
        <trans-unit id="53abbdb21e81e3f2df2cf14c89d5b6dbabdbe501" translate="yes" xml:space="preserve">
          <source>Microseconds display</source>
          <target state="translated">Pantalla de microsegundos</target>
        </trans-unit>
        <trans-unit id="71a3c685e2a1c832e7011ccdc9b0d684ec6c5b11" translate="yes" xml:space="preserve">
          <source>Milliseconds display</source>
          <target state="translated">Pantalla de milisegundos</target>
        </trans-unit>
        <trans-unit id="f0ba6bd90de6cbdc1ad731d5daa371ecb83efe18" translate="yes" xml:space="preserve">
          <source>Minimal output level for the compiler.</source>
          <target state="translated">Nivel de salida mínimo para el compilador.</target>
        </trans-unit>
        <trans-unit id="011feb85fd840211ebe3cbea6d10c757384f0950" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">Exponente mínimo (negativo)para los números de 32 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="a6a8707c6b54291fbf3e81a23b30ec1365b0f17e" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">Exponente mínimo (negativo)para los números de 64 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="c80cc0223dc92abbd631516781aea6a70a2336ee" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">Exponente mínimo (negativo)en base 10 para números de 32 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="8c0da4d03317d4bba985f6d156cd17b8a1e9fe83" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">Exponente mínimo (negativo)en base 10 para números de 64 bits de punto flotante.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="fde8fd6d013071c5b0da03141012d8c86a59338b" translate="yes" xml:space="preserve">
          <source>Mixin statement</source>
          <target state="translated">Declaración de Mixin</target>
        </trans-unit>
        <trans-unit id="54a58f4d81597ea468c275c465f53b922146c355" translate="yes" xml:space="preserve">
          <source>Mixing parameters that should use the &lt;code&gt;using&lt;/code&gt; declaration with parameters that are explicitly typed is possible and requires a semicolon between them.</source>
          <target state="translated">Es posible mezclar par&amp;aacute;metros que deben usar la declaraci&amp;oacute;n &lt;code&gt;using&lt;/code&gt; con par&amp;aacute;metros que est&amp;aacute;n escritos expl&amp;iacute;citamente y requiere un punto y coma entre ellos.</target>
        </trans-unit>
        <trans-unit id="e4544d11fd6da006e85425de7ccf9cc035a9102d" translate="yes" xml:space="preserve">
          <source>Modelling currencies</source>
          <target state="translated">Modelización de monedas</target>
        </trans-unit>
        <trans-unit id="aa74d48711737b61f9e3b5b05bb11e9299107ca2" translate="yes" xml:space="preserve">
          <source>Modifies the prefix of this node</source>
          <target state="translated">Modifica el prefijo de este nodo</target>
        </trans-unit>
        <trans-unit id="08534cfcbbc9538479a2881f8f4160931eb1a4e4" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by adding &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Modifique &lt;code&gt;a&lt;/code&gt; en su lugar agregando &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d316a8d9b4204cded1b078dfca344f13947d6088" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by subtracting &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Modifique &lt;code&gt;a&lt;/code&gt; en su lugar restando &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf753b23cff3eb87675698eadfe1b3df8dc21c1" translate="yes" xml:space="preserve">
          <source>Modifying a configuration file.</source>
          <target state="translated">Modificar un archivo de configuración.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="37f0da15f20ceb74b60fd308e1dca9126540cb05" translate="yes" xml:space="preserve">
          <source>Module algorithm</source>
          <target state="translated">Algoritmo del módulo</target>
        </trans-unit>
        <trans-unit id="98195ccd152814f0ec7cb526f9dfddd0c0f2d040" translate="yes" xml:space="preserve">
          <source>Module asyncdispatch</source>
          <target state="translated">Módulo asyncdispatch</target>
        </trans-unit>
        <trans-unit id="4bc2eee542f289752eea25797a5b576fdb1f0212" translate="yes" xml:space="preserve">
          <source>Module asyncfile</source>
          <target state="translated">Módulo asyncfile</target>
        </trans-unit>
        <trans-unit id="1982b034043183e25a12a7f8201ac7aedfe1337c" translate="yes" xml:space="preserve">
          <source>Module asyncftpclient</source>
          <target state="translated">Módulo asyncftpclient</target>
        </trans-unit>
        <trans-unit id="c8ecdd97327b90a5e22c271e6446280bc42a28c4" translate="yes" xml:space="preserve">
          <source>Module asyncfutures</source>
          <target state="translated">Módulo asíncrono</target>
        </trans-unit>
        <trans-unit id="36cb7286c251d44bed6e333ac6ff256e07f23e46" translate="yes" xml:space="preserve">
          <source>Module asynchttpserver</source>
          <target state="translated">Módulo asynchttpserver</target>
        </trans-unit>
        <trans-unit id="a17c24b3dfb9bd981141eb4c7df0cf7bc771a15a" translate="yes" xml:space="preserve">
          <source>Module asyncio</source>
          <target state="translated">Módulo asincio</target>
        </trans-unit>
        <trans-unit id="c68f5ddf8354a55f6684c3fbe9c3bf177423a499" translate="yes" xml:space="preserve">
          <source>Module asyncjs</source>
          <target state="translated">Módulo asyncjs</target>
        </trans-unit>
        <trans-unit id="101489cc366780f3080d0d181d612c9897002730" translate="yes" xml:space="preserve">
          <source>Module asyncnet</source>
          <target state="translated">Módulo asyncnet</target>
        </trans-unit>
        <trans-unit id="6fed8121401f7f3d76d9ac08c713d6fc1d80130c" translate="yes" xml:space="preserve">
          <source>Module asyncstreams</source>
          <target state="translated">Módulo asyncstreams</target>
        </trans-unit>
        <trans-unit id="7760e4149a4aa9f2f5276da9842c763efe627d2d" translate="yes" xml:space="preserve">
          <source>Module base64</source>
          <target state="translated">Módulo base64</target>
        </trans-unit>
        <trans-unit id="90d38995e07bc5f4bab2517945813fb23c0f041c" translate="yes" xml:space="preserve">
          <source>Module bitops</source>
          <target state="translated">Módulo de bitops</target>
        </trans-unit>
        <trans-unit id="50eadb9d8cc85daa18b406eb03722df6d8ad89ae" translate="yes" xml:space="preserve">
          <source>Module browsers</source>
          <target state="translated">Navegadores de módulos</target>
        </trans-unit>
        <trans-unit id="541c25a9eda5bd8f8b769d4123a86bdd4573b52d" translate="yes" xml:space="preserve">
          <source>Module cgi</source>
          <target state="translated">Módulo cgi</target>
        </trans-unit>
        <trans-unit id="582466c566af045f4b9e5cd6e35678516157979c" translate="yes" xml:space="preserve">
          <source>Module channels</source>
          <target state="translated">Los canales de los módulos</target>
        </trans-unit>
        <trans-unit id="9b8b21dabbac15d101b015114dad88029c7c9e26" translate="yes" xml:space="preserve">
          <source>Module colors</source>
          <target state="translated">Los colores del módulo</target>
        </trans-unit>
        <trans-unit id="eed8ec6f020ff8aa124c5b37641c245a63ddde69" translate="yes" xml:space="preserve">
          <source>Module complex</source>
          <target state="translated">Módulo complejo</target>
        </trans-unit>
        <trans-unit id="374208eb48a6ab162ea9a9795c69a75d26d8d0d8" translate="yes" xml:space="preserve">
          <source>Module cookies</source>
          <target state="translated">Cookies del módulo</target>
        </trans-unit>
        <trans-unit id="a4721d23b264afe3adb6840e441ad673c273dbe5" translate="yes" xml:space="preserve">
          <source>Module coro</source>
          <target state="translated">Módulo coro</target>
        </trans-unit>
        <trans-unit id="0b7487264409b62ec77bc44946eb6949835043bd" translate="yes" xml:space="preserve">
          <source>Module cpuinfo</source>
          <target state="translated">Módulo cpuinfo</target>
        </trans-unit>
        <trans-unit id="65a4bb57d62e6d50e39758f49fa5d45582a06fcf" translate="yes" xml:space="preserve">
          <source>Module cpuload</source>
          <target state="translated">Módulo cpuload</target>
        </trans-unit>
        <trans-unit id="0eaf026ca68438c31c5ddb66759abefe57ca491a" translate="yes" xml:space="preserve">
          <source>Module critbits</source>
          <target state="translated">El módulo de critbits</target>
        </trans-unit>
        <trans-unit id="17fb6170e7c4b5192d13d3ef92b62003adec52ed" translate="yes" xml:space="preserve">
          <source>Module cstrutils</source>
          <target state="translated">Módulo cstrutils</target>
        </trans-unit>
        <trans-unit id="dccbda4248191deb5d482692eac7fa4e615cc212" translate="yes" xml:space="preserve">
          <source>Module db_common</source>
          <target state="translated">Módulo db_común</target>
        </trans-unit>
        <trans-unit id="8d09576b4e94ea8a8b0016794ba4536d4b1759df" translate="yes" xml:space="preserve">
          <source>Module db_mysql</source>
          <target state="translated">Módulo db_mysql</target>
        </trans-unit>
        <trans-unit id="6624ca243c80fc450c0491ae2bd086e7f22e2273" translate="yes" xml:space="preserve">
          <source>Module db_odbc</source>
          <target state="translated">Módulo db_odbc</target>
        </trans-unit>
        <trans-unit id="fd6fae1e074c3591c208c14db853d9f0744b3fe6" translate="yes" xml:space="preserve">
          <source>Module db_postgres</source>
          <target state="translated">Módulo db_postgres</target>
        </trans-unit>
        <trans-unit id="b401aafda6e7b26047ce7d9b236e3e28ead3b900" translate="yes" xml:space="preserve">
          <source>Module db_sqlite</source>
          <target state="translated">Módulo db_sqlite</target>
        </trans-unit>
        <trans-unit id="a36cab96e59f81b2cfa2e287c992565577181e19" translate="yes" xml:space="preserve">
          <source>Module deques</source>
          <target state="translated">Módulo deques</target>
        </trans-unit>
        <trans-unit id="230fe8691288c49b13cd6d0d633b0aa094bba0ba" translate="yes" xml:space="preserve">
          <source>Module distros</source>
          <target state="translated">Distros de módulos</target>
        </trans-unit>
        <trans-unit id="b98b5015c00736657c4dd0da231c080c137bf240" translate="yes" xml:space="preserve">
          <source>Module docgen_sample</source>
          <target state="translated">Módulo docgen_sample</target>
        </trans-unit>
        <trans-unit id="9b3df8bd64b5aae95560173051cb9413193a2ac6" translate="yes" xml:space="preserve">
          <source>Module dom</source>
          <target state="translated">Módulo dom</target>
        </trans-unit>
        <trans-unit id="941b4acd398cb84658e8c03ee70acb8a6a6ad12b" translate="yes" xml:space="preserve">
          <source>Module dynlib</source>
          <target state="translated">Módulo dynlib</target>
        </trans-unit>
        <trans-unit id="0b682ac70a1c85d9baf3957f2aa8f759d24240e0" translate="yes" xml:space="preserve">
          <source>Module encodings</source>
          <target state="translated">Codificaciones de módulos</target>
        </trans-unit>
        <trans-unit id="db5b0c91c31ae7c7d91818dc9b614356c8ac354a" translate="yes" xml:space="preserve">
          <source>Module endians</source>
          <target state="translated">Módulo de los ingleses...</target>
        </trans-unit>
        <trans-unit id="bd74d2f3f124ee315af73875094015c9b005becf" translate="yes" xml:space="preserve">
          <source>Module fenv</source>
          <target state="translated">Módulo fenv</target>
        </trans-unit>
        <trans-unit id="731086b25ca52f0d4ba784e9023a512802282c5d" translate="yes" xml:space="preserve">
          <source>Module for computing MD5 checksums.</source>
          <target state="translated">Módulo para computar las sumas de control MD5.</target>
        </trans-unit>
        <trans-unit id="b4be1b80500b5ac048dcc726ed598ece6701931b" translate="yes" xml:space="preserve">
          <source>Module ftpclient</source>
          <target state="translated">Módulo ftpclient</target>
        </trans-unit>
        <trans-unit id="3c4f086976fa89f11b3a0b18d36e2a8854016a20" translate="yes" xml:space="preserve">
          <source>Module hashes</source>
          <target state="translated">Módulo de hashes</target>
        </trans-unit>
        <trans-unit id="a2e15c184ec6f1cb32588bee5d5ccb0d11dcc6e5" translate="yes" xml:space="preserve">
          <source>Module heapqueue</source>
          <target state="translated">Módulo heapqueue</target>
        </trans-unit>
        <trans-unit id="83b2786d0af670a8727d352ab2cc17a4801a8fde" translate="yes" xml:space="preserve">
          <source>Module highlite</source>
          <target state="translated">Módulo highlite</target>
        </trans-unit>
        <trans-unit id="68378bdbde20dbf762ba106c90a960cc76a0c343" translate="yes" xml:space="preserve">
          <source>Module htmlgen</source>
          <target state="translated">Módulo htmlgen</target>
        </trans-unit>
        <trans-unit id="11585b007040719709343df6d82764795667bb4d" translate="yes" xml:space="preserve">
          <source>Module htmlparser</source>
          <target state="translated">Módulo htmlparser</target>
        </trans-unit>
        <trans-unit id="ce266765149cfec68daffab151c2d1cbb6ebb974" translate="yes" xml:space="preserve">
          <source>Module httpclient</source>
          <target state="translated">Módulo httpclient</target>
        </trans-unit>
        <trans-unit id="ae17027dff9b5c5e08184e61c512b15de51aca77" translate="yes" xml:space="preserve">
          <source>Module httpcore</source>
          <target state="translated">Módulo httpcore</target>
        </trans-unit>
        <trans-unit id="efcdd786f2c6fa38c8e234f0d6d253c5564d8710" translate="yes" xml:space="preserve">
          <source>Module intsets</source>
          <target state="translated">Módulo intsets</target>
        </trans-unit>
        <trans-unit id="ae1f8df6d1f31431338fdcd3f32d3d351bdb0f67" translate="yes" xml:space="preserve">
          <source>Module iup</source>
          <target state="translated">Módulo iup</target>
        </trans-unit>
        <trans-unit id="8abdec2103ddf3b91238dc0ef753306e3cf948a1" translate="yes" xml:space="preserve">
          <source>Module jscore</source>
          <target state="translated">Módulo jscore</target>
        </trans-unit>
        <trans-unit id="2445c7a3a0648ca25b67b51a400e8dde36b920dc" translate="yes" xml:space="preserve">
          <source>Module jsffi</source>
          <target state="translated">Módulo jsffi</target>
        </trans-unit>
        <trans-unit id="3e231af76878f00ab682498609250b7a33902b37" translate="yes" xml:space="preserve">
          <source>Module json</source>
          <target state="translated">Módulo json</target>
        </trans-unit>
        <trans-unit id="37345fc873fd9ef2206568b360b1c24cb44c6a79" translate="yes" xml:space="preserve">
          <source>Module lenientops</source>
          <target state="translated">Módulo lenientops</target>
        </trans-unit>
        <trans-unit id="580e2f376943e7c873eabc0e8de78d45329a29d4" translate="yes" xml:space="preserve">
          <source>Module lexbase</source>
          <target state="translated">Módulo lexbase</target>
        </trans-unit>
        <trans-unit id="f7eb0bf35deb63519acf61a5dc69c51f5b06735f" translate="yes" xml:space="preserve">
          <source>Module lists</source>
          <target state="translated">Listas de módulos</target>
        </trans-unit>
        <trans-unit id="5fa64d315f22284a510ec90f2b3766f8771aa4d3" translate="yes" xml:space="preserve">
          <source>Module locks</source>
          <target state="translated">Las cerraduras de los módulos</target>
        </trans-unit>
        <trans-unit id="d68a3f14f1246e34391c7c956005b435126a1feb" translate="yes" xml:space="preserve">
          <source>Module logging</source>
          <target state="translated">Registro del módulo</target>
        </trans-unit>
        <trans-unit id="70e578149237a5fb397ecdf712216171be19d22c" translate="yes" xml:space="preserve">
          <source>Module macros</source>
          <target state="translated">Macros del módulo</target>
        </trans-unit>
        <trans-unit id="8e11adceffbd4622428572ca4afc35c17c825d9b" translate="yes" xml:space="preserve">
          <source>Module marshal</source>
          <target state="translated">Módulo mariscal</target>
        </trans-unit>
        <trans-unit id="33c70e8cca5fc846249c996c55efdccf09fa04af" translate="yes" xml:space="preserve">
          <source>Module matchers</source>
          <target state="translated">Los módulos de fósforos...</target>
        </trans-unit>
        <trans-unit id="60528f0928b59cfa4557a3b1b994edb4024106b0" translate="yes" xml:space="preserve">
          <source>Module math</source>
          <target state="translated">Módulo de matemáticas</target>
        </trans-unit>
        <trans-unit id="56d8fbdebc1eb23f12cddf043b4f3037a450710a" translate="yes" xml:space="preserve">
          <source>Module md5</source>
          <target state="translated">Módulo md5</target>
        </trans-unit>
        <trans-unit id="bce77eb47d51483993e4fa0db56b0547cc3dd24c" translate="yes" xml:space="preserve">
          <source>Module memfiles</source>
          <target state="translated">Los archivos de memoria del módulo...</target>
        </trans-unit>
        <trans-unit id="20df3a115fcb30f9b530aa03bdc18faa0ae695c2" translate="yes" xml:space="preserve">
          <source>Module mersenne</source>
          <target state="translated">Módulo mersenne</target>
        </trans-unit>
        <trans-unit id="cc1b82bbab0603a47f41c5adca38b87a9321bee7" translate="yes" xml:space="preserve">
          <source>Module mimetypes</source>
          <target state="translated">Mimetipos de módulos</target>
        </trans-unit>
        <trans-unit id="6657cfabe7d07bf51cc2fb118ba722ffc96aba89" translate="yes" xml:space="preserve">
          <source>Module mysql</source>
          <target state="translated">Módulo mysql</target>
        </trans-unit>
        <trans-unit id="31d0c7d344fc5c65774ddf00049b1876645f3b19" translate="yes" xml:space="preserve">
          <source>Module names in imports</source>
          <target state="translated">Los nombres de los módulos en las importaciones</target>
        </trans-unit>
        <trans-unit id="30df598104815cce6ad06791aec2a9d153b164f7" translate="yes" xml:space="preserve">
          <source>Module nativesockets</source>
          <target state="translated">El módulo de los bolsillos de los nativos</target>
        </trans-unit>
        <trans-unit id="a3d7a3865b172afee6c2b7c8977de511e77b6757" translate="yes" xml:space="preserve">
          <source>Module net</source>
          <target state="translated">Red de módulos</target>
        </trans-unit>
        <trans-unit id="6c357de2b2a9a1de2189540c4281941a77608057" translate="yes" xml:space="preserve">
          <source>Module odbcsql</source>
          <target state="translated">Módulo odbcsql</target>
        </trans-unit>
        <trans-unit id="9ac9afd12fcca720ece0b72dd61269f6e7843617" translate="yes" xml:space="preserve">
          <source>Module oids</source>
          <target state="translated">Módulo oids</target>
        </trans-unit>
        <trans-unit id="df6c016676012b7a90d7af54c2025872180c6083" translate="yes" xml:space="preserve">
          <source>Module openssl</source>
          <target state="translated">Módulo openssl</target>
        </trans-unit>
        <trans-unit id="181f431ffc709c06a61935e69331ac8e4563f46c" translate="yes" xml:space="preserve">
          <source>Module options</source>
          <target state="translated">Opciones del módulo</target>
        </trans-unit>
        <trans-unit id="7f661395966d22306bb86d25ec0d945d397507a0" translate="yes" xml:space="preserve">
          <source>Module os</source>
          <target state="translated">Módulo os</target>
        </trans-unit>
        <trans-unit id="dae29e69d6fcac477476832d0c04d256e4219700" translate="yes" xml:space="preserve">
          <source>Module ospaths</source>
          <target state="translated">Módulo ospaths</target>
        </trans-unit>
        <trans-unit id="5395928ecc4ce4edf1eabd8f020d30b8523fd803" translate="yes" xml:space="preserve">
          <source>Module osproc</source>
          <target state="translated">Módulo osproc</target>
        </trans-unit>
        <trans-unit id="2bfeeb302a2c2fb80d26255c95b4f0b069b97c41" translate="yes" xml:space="preserve">
          <source>Module parsecfg</source>
          <target state="translated">Módulo parsecfg</target>
        </trans-unit>
        <trans-unit id="d9ee6d4bae252aefed2ecd2ae012f67dfe339140" translate="yes" xml:space="preserve">
          <source>Module parsecsv</source>
          <target state="translated">Módulo parsecsv</target>
        </trans-unit>
        <trans-unit id="348399e23d1c192b9c45e1b0c83d05337c92bf98" translate="yes" xml:space="preserve">
          <source>Module parsejson</source>
          <target state="translated">Módulo parsejson</target>
        </trans-unit>
        <trans-unit id="682e643a35975c3826db50e0bb0cd0dd5c2ca34f" translate="yes" xml:space="preserve">
          <source>Module parseopt</source>
          <target state="translated">Módulo parseopt</target>
        </trans-unit>
        <trans-unit id="0ed92eaefc270e8b9dd075eb2dd08dbaa5b51f01" translate="yes" xml:space="preserve">
          <source>Module parsesql</source>
          <target state="translated">Módulo parsesql</target>
        </trans-unit>
        <trans-unit id="855c130387d410a61e37f5b34d034cd98d89f8d8" translate="yes" xml:space="preserve">
          <source>Module parseutils</source>
          <target state="translated">Módulo de herramientas</target>
        </trans-unit>
        <trans-unit id="9371c7c885849232742553f842dca9202b5ed289" translate="yes" xml:space="preserve">
          <source>Module parsexml</source>
          <target state="translated">Módulo parsexml</target>
        </trans-unit>
        <trans-unit id="20024d265db3ebf3a4cb1f9d150f212626383df7" translate="yes" xml:space="preserve">
          <source>Module pcre</source>
          <target state="translated">Módulo Pcre</target>
        </trans-unit>
        <trans-unit id="a17a4c9cec16cef361a14841e228e5ed78a25395" translate="yes" xml:space="preserve">
          <source>Module pegs</source>
          <target state="translated">El módulo Pegs</target>
        </trans-unit>
        <trans-unit id="5f3bf0ccd39bc7809674b2d661113030c738201e" translate="yes" xml:space="preserve">
          <source>Module posix</source>
          <target state="translated">Módulo Posix</target>
        </trans-unit>
        <trans-unit id="eef6ef7935050ba1da22c08049e0e742ab0545c6" translate="yes" xml:space="preserve">
          <source>Module postgres</source>
          <target state="translated">Módulo Postgres</target>
        </trans-unit>
        <trans-unit id="4c337d9754fa6144e8e8c63eb6714830a7bf2680" translate="yes" xml:space="preserve">
          <source>Module random</source>
          <target state="translated">Módulo aleatorio</target>
        </trans-unit>
        <trans-unit id="6f3863bd09c8389a708515de060c50fe217a1fc5" translate="yes" xml:space="preserve">
          <source>Module rationals</source>
          <target state="translated">Módulo de racionalidad</target>
        </trans-unit>
        <trans-unit id="1c6043ad9977193e14836b1453a2c14e877b9c12" translate="yes" xml:space="preserve">
          <source>Module re</source>
          <target state="translated">Módulo re</target>
        </trans-unit>
        <trans-unit id="beb8a46432b339ddaa74839d412412426afb7728" translate="yes" xml:space="preserve">
          <source>Module rlocks</source>
          <target state="translated">El módulo se bloquea</target>
        </trans-unit>
        <trans-unit id="373d2a7e384e4c78df72f2a532ade493280ab5b9" translate="yes" xml:space="preserve">
          <source>Module ropes</source>
          <target state="translated">Las cuerdas del módulo</target>
        </trans-unit>
        <trans-unit id="791fafc4980538594d1205be2e024d8f062a8ef6" translate="yes" xml:space="preserve">
          <source>Module rst</source>
          <target state="translated">Módulo rst</target>
        </trans-unit>
        <trans-unit id="e62ac437c8e15e65ba3f4a9ec5166f39349d24d8" translate="yes" xml:space="preserve">
          <source>Module rstast</source>
          <target state="translated">Módulo rstast</target>
        </trans-unit>
        <trans-unit id="71d839f9565a57347512e1bcb1209ad6ecbd1571" translate="yes" xml:space="preserve">
          <source>Module rstgen</source>
          <target state="translated">Módulo rstgen</target>
        </trans-unit>
        <trans-unit id="64202e11eebaa8fdc9db2592feeeca4f21b321b4" translate="yes" xml:space="preserve">
          <source>Module rtarrays</source>
          <target state="translated">Módulo de rayos X</target>
        </trans-unit>
        <trans-unit id="34de3c41db61af2ec348412e142cf1de55f30e2c" translate="yes" xml:space="preserve">
          <source>Module scgi</source>
          <target state="translated">Módulo scgi</target>
        </trans-unit>
        <trans-unit id="9d18a075abac676c24c84bba7822fb5ce2702cec" translate="yes" xml:space="preserve">
          <source>Module scope</source>
          <target state="translated">Alcance del módulo</target>
        </trans-unit>
        <trans-unit id="b6a250923bc9b9d586fc748c435010dc3db2a298" translate="yes" xml:space="preserve">
          <source>Module segfaults</source>
          <target state="translated">Segmentos del módulo</target>
        </trans-unit>
        <trans-unit id="8208cbe439f9b79060081af450aa66cdb0a714b6" translate="yes" xml:space="preserve">
          <source>Module selectors</source>
          <target state="translated">Los selectores de módulos</target>
        </trans-unit>
        <trans-unit id="23026b5c559a2292c7babd2476fc9f08c5816964" translate="yes" xml:space="preserve">
          <source>Module sequtils</source>
          <target state="translated">Módulo de secuencias</target>
        </trans-unit>
        <trans-unit id="c3ea468cd06b16c0644d2bacc8da61f318bab4bb" translate="yes" xml:space="preserve">
          <source>Module sets</source>
          <target state="translated">Juegos de módulos</target>
        </trans-unit>
        <trans-unit id="a16a3e9b2eb88fe04764ed85fb0218873cc38566" translate="yes" xml:space="preserve">
          <source>Module sexp</source>
          <target state="translated">Módulo sexp</target>
        </trans-unit>
        <trans-unit id="59d0872f6bd60a77e18aa4238e904f432277b85d" translate="yes" xml:space="preserve">
          <source>Module sha1</source>
          <target state="translated">Módulo sha1</target>
        </trans-unit>
        <trans-unit id="4ece62635ed6e99fbdb3e080b7996745d5c3b1f3" translate="yes" xml:space="preserve">
          <source>Module sharedlist</source>
          <target state="translated">Lista de módulos compartidos</target>
        </trans-unit>
        <trans-unit id="b5e68bfc8c55fb54fde0c83c3f95af5feaf92c9b" translate="yes" xml:space="preserve">
          <source>Module sharedtables</source>
          <target state="translated">Módulo de mesas compartidas</target>
        </trans-unit>
        <trans-unit id="c339964428c500099d3daed6fb8542e3b613f1ef" translate="yes" xml:space="preserve">
          <source>Module smtp</source>
          <target state="translated">Módulo smtp</target>
        </trans-unit>
        <trans-unit id="ac4edb7026adc886e3dd2c3c0e2fa6b2624eac99" translate="yes" xml:space="preserve">
          <source>Module sockets</source>
          <target state="translated">Enchufes de módulos</target>
        </trans-unit>
        <trans-unit id="44b9eae64da1d100a47749f8e94861aceb4e1953" translate="yes" xml:space="preserve">
          <source>Module sqlite3</source>
          <target state="translated">Módulo sqlite3</target>
        </trans-unit>
        <trans-unit id="8c907d2d3470228660aa0f1c6e876cce39cd9be0" translate="yes" xml:space="preserve">
          <source>Module ssl</source>
          <target state="translated">Módulo ssl</target>
        </trans-unit>
        <trans-unit id="5dddec2bc7b6889e3d6e4572f0e2abcd568ae642" translate="yes" xml:space="preserve">
          <source>Module stats</source>
          <target state="translated">Estadísticas del módulo</target>
        </trans-unit>
        <trans-unit id="af7ea72f6db5731696a9ec545d89e8dbf5355b5e" translate="yes" xml:space="preserve">
          <source>Module streams</source>
          <target state="translated">Los flujos de módulos</target>
        </trans-unit>
        <trans-unit id="d563539aac0aa375abd30d9cff848fd83c1d6b90" translate="yes" xml:space="preserve">
          <source>Module strformat</source>
          <target state="translated">Módulo stratformat</target>
        </trans-unit>
        <trans-unit id="c5b35d487655735440b1511f4cbcb6212ffb09bf" translate="yes" xml:space="preserve">
          <source>Module strmisc</source>
          <target state="translated">Módulo strmisc</target>
        </trans-unit>
        <trans-unit id="39a556995953f0750f993afaabbda0fb9aa0c361" translate="yes" xml:space="preserve">
          <source>Module strscans</source>
          <target state="translated">El módulo explora</target>
        </trans-unit>
        <trans-unit id="9add54a0554d7d5e3b57ccafbebed36cfff3a00a" translate="yes" xml:space="preserve">
          <source>Module strtabs</source>
          <target state="translated">Módulo strtabs</target>
        </trans-unit>
        <trans-unit id="2c2fe9377d124f6f70ba53c4aac93232b71c1394" translate="yes" xml:space="preserve">
          <source>Module strutils</source>
          <target state="translated">Módulo de estrutilación</target>
        </trans-unit>
        <trans-unit id="c427c4ed878b917bab65e9b41afb7305c3c93c47" translate="yes" xml:space="preserve">
          <source>Module subexes</source>
          <target state="translated">Los subexos del módulo</target>
        </trans-unit>
        <trans-unit id="2ff9cf6c55f0b207b0fa1b96a01a770ee71c8eaa" translate="yes" xml:space="preserve">
          <source>Module sugar</source>
          <target state="translated">Módulo de azúcar</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="translated">Sistema de módulos</target>
        </trans-unit>
        <trans-unit id="e9cc05615900094d98054d721ed949701ef00a47" translate="yes" xml:space="preserve">
          <source>Module tables</source>
          <target state="translated">Mesas de módulos</target>
        </trans-unit>
        <trans-unit id="12b55983071a387f9c09feaf0f6a54c990c5be1d" translate="yes" xml:space="preserve">
          <source>Module terminal</source>
          <target state="translated">Terminal del módulo</target>
        </trans-unit>
        <trans-unit id="84ba9986fea98d5aed3aa1e050cd37789056e75a" translate="yes" xml:space="preserve">
          <source>Module that implements a fixed length array whose size is determined at runtime. Note: This is not ready for other people to use!</source>
          <target state="translated">Módulo que implementa un arreglo de longitud fija cuyo tamaño se determina en tiempo de ejecución.Nota:¡Esto no está listo para que lo usen otras personas!</target>
        </trans-unit>
        <trans-unit id="3b2dabb54c51f17c55a0e6927caa5f742504ae33" translate="yes" xml:space="preserve">
          <source>Module threadpool</source>
          <target state="translated">Módulo threadpool</target>
        </trans-unit>
        <trans-unit id="f92a75aeabfd1c4044569aecab8ccb991701806b" translate="yes" xml:space="preserve">
          <source>Module threads</source>
          <target state="translated">Hilos del módulo</target>
        </trans-unit>
        <trans-unit id="fb3625f5ec0037d48d6c0cb336a239dd3b00b7ca" translate="yes" xml:space="preserve">
          <source>Module times</source>
          <target state="translated">Los tiempos de los módulos</target>
        </trans-unit>
        <trans-unit id="80fdbaacf746a3cedeab4e5928808c2384a50612" translate="yes" xml:space="preserve">
          <source>Module typeinfo</source>
          <target state="translated">Módulo typeinfo</target>
        </trans-unit>
        <trans-unit id="2b741b4fc7fd10f81b2d720dc6c96f43017249fb" translate="yes" xml:space="preserve">
          <source>Module typetraits</source>
          <target state="translated">Retratos de los módulos</target>
        </trans-unit>
        <trans-unit id="9043c86e7cedc7aab24be69a0efdba5ddf0f80e5" translate="yes" xml:space="preserve">
          <source>Module unicode</source>
          <target state="translated">Módulo unicode</target>
        </trans-unit>
        <trans-unit id="7085badef4953ee4bbceb9688b13d4140b27c724" translate="yes" xml:space="preserve">
          <source>Module unittest</source>
          <target state="translated">Prueba de unidad del módulo</target>
        </trans-unit>
        <trans-unit id="8bbd7d4f48877a7314d216e6ebdb985da4bfafac" translate="yes" xml:space="preserve">
          <source>Module uri</source>
          <target state="translated">Módulo uri</target>
        </trans-unit>
        <trans-unit id="8a680992d6079b9c0e11b05251fd8f87bfbf1fe8" translate="yes" xml:space="preserve">
          <source>Module winlean</source>
          <target state="translated">Módulo winlean</target>
        </trans-unit>
        <trans-unit id="d8fdebbbc5615918cb9d798309cb31cd866e4994" translate="yes" xml:space="preserve">
          <source>Module xmldom</source>
          <target state="translated">Módulo xmldom</target>
        </trans-unit>
        <trans-unit id="f295719f36ed63526a4da7b30de4cad8a8999c32" translate="yes" xml:space="preserve">
          <source>Module xmldomparser</source>
          <target state="translated">Módulo xmldomparser</target>
        </trans-unit>
        <trans-unit id="634e83af2de2c8fae54f36c85ad255fa78fdc1fe" translate="yes" xml:space="preserve">
          <source>Module xmlparser</source>
          <target state="translated">Módulo xmlparser</target>
        </trans-unit>
        <trans-unit id="fffc921107774b45b37fb11a2ae26e6c1756df47" translate="yes" xml:space="preserve">
          <source>Module xmltree</source>
          <target state="translated">Módulo xmltree</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d4bb1d0c8920c90ab574ded6626feabfc7eb5056" translate="yes" xml:space="preserve">
          <source>Modules for JS backend</source>
          <target state="translated">Módulos para el backend JS</target>
        </trans-unit>
        <trans-unit id="04ed0b03aed0cadb43ffc6bfd838816a8c42b369" translate="yes" xml:space="preserve">
          <source>Modules like &lt;code&gt;os&lt;/code&gt; and &lt;code&gt;osproc&lt;/code&gt; use the Ansi versions of the Windows API. The default build uses the Unicode version.</source>
          <target state="translated">M&amp;oacute;dulos como &lt;code&gt;os&lt;/code&gt; y &lt;code&gt;osproc&lt;/code&gt; utilizan las versiones Ansi de la API de Windows. La compilaci&amp;oacute;n predeterminada usa la versi&amp;oacute;n Unicode.</target>
        </trans-unit>
        <trans-unit id="5492a7b7e10ca5189dd3f4f7cd04aaa834acbe84" translate="yes" xml:space="preserve">
          <source>More examples with custom pragmas:</source>
          <target state="translated">Más ejemplos con pragmas personalizados:</target>
        </trans-unit>
        <trans-unit id="02e1b6aeefcbcdce8ddb030e0d03e46f8f19c14b" translate="yes" xml:space="preserve">
          <source>More information: &lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt;/</source>
          <target state="translated">M&amp;aacute;s informaci&amp;oacute;n: &lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt; /</target>
        </trans-unit>
        <trans-unit id="2fa11c0cc6358778587e65242e73c28f8b0ce69a" translate="yes" xml:space="preserve">
          <source>Most (if not all) modules that use asyncio provide a userArg which is passed on with the events. The type that you set userArg to must be inheriting from &lt;code&gt;RootObj&lt;/code&gt;!</source>
          <target state="translated">La mayor&amp;iacute;a (si no todos) los m&amp;oacute;dulos que usan asyncio proporcionan un userArg que se transmite con los eventos. &amp;iexcl;El tipo que establezca userArg debe ser heredado de &lt;code&gt;RootObj&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="3a3648df8257d95dad8a542820feec7313dcffba" translate="yes" xml:space="preserve">
          <source>Most calling conventions exist only for the Windows 32-bit platform.</source>
          <target state="translated">La mayoría de las convenciones de llamada existen sólo para la plataforma Windows 32-bit.</target>
        </trans-unit>
        <trans-unit id="d682310dcece700c3a8748a725359d19f632cdec" translate="yes" xml:space="preserve">
          <source>Most native Nim types support conversion to strings with the special &lt;code&gt;$&lt;/code&gt; proc. When calling the &lt;code&gt;echo&lt;/code&gt; proc, for example, the built-in stringify operation for the parameter is called:</source>
          <target state="translated">La mayor&amp;iacute;a de los tipos nativos de Nim admiten la conversi&amp;oacute;n a cadenas con el &lt;code&gt;$&lt;/code&gt; proc especial . Al llamar al &lt;code&gt;echo&lt;/code&gt; proc, por ejemplo, se llama a la operaci&amp;oacute;n de stringify incorporada para el par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="c330bf74003c40f0baff1596cb0fe1aa69f44229" translate="yes" xml:space="preserve">
          <source>Most often integers are used for counting objects that reside in memory, so &lt;code&gt;int&lt;/code&gt; has the same size as a pointer.</source>
          <target state="translated">La mayor&amp;iacute;a de las veces, los n&amp;uacute;meros enteros se utilizan para contar objetos que residen en la memoria, por lo que &lt;code&gt;int&lt;/code&gt; tiene el mismo tama&amp;ntilde;o que un puntero.</target>
        </trans-unit>
        <trans-unit id="2dcc64ab52a078dbecfc23dc0e106a84a69bd521" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized ordered set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that ordered sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">La mayor&amp;iacute;a de las operaciones sobre un conjunto ordenado no inicializado fallar&amp;aacute;n en tiempo de ejecuci&amp;oacute;n y se &lt;a href=&quot;system#assert&quot;&gt;afirmar&amp;aacute;n&lt;/a&gt; en compilaciones de depuraci&amp;oacute;n. Puede utilizar este proceso en sus propios procesos para verificar que los conjuntos ordenados pasados ​​a sus procesos est&amp;eacute;n correctamente inicializados. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="b286a20955238c202888cbd22fcba1b32dbb5ccf" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">La mayor&amp;iacute;a de las operaciones sobre un conjunto no inicializado fallar&amp;aacute;n en tiempo de ejecuci&amp;oacute;n y se &lt;a href=&quot;system#assert&quot;&gt;afirmar&amp;aacute;n&lt;/a&gt; en compilaciones de depuraci&amp;oacute;n. Puede usar este proceso en sus propios procesos para verificar que los conjuntos pasados ​​a sus procesos est&amp;eacute;n correctamente inicializados. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="40f1f54ed50170dad3e2a2e1db2410306c0d2895" translate="yes" xml:space="preserve">
          <source>Most procedures raise OSError on error, but some may return &lt;code&gt;-1&lt;/code&gt; or a boolean &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">La mayor&amp;iacute;a de los procedimientos generan OSError en caso de error, pero algunos pueden devolver &lt;code&gt;-1&lt;/code&gt; o un booleano &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb5ab88dfbf525d498b45d241a40f2698fed97a" translate="yes" xml:space="preserve">
          <source>Mostly used by the &lt;a href=&quot;tables&quot;&gt;tables&lt;/a&gt; module, it can also be raised by other collection modules like &lt;a href=&quot;sets&quot;&gt;sets&lt;/a&gt; or &lt;a href=&quot;strtabs&quot;&gt;strtabs&lt;/a&gt;.</source>
          <target state="translated">Usado principalmente por el m&amp;oacute;dulo de &lt;a href=&quot;tables&quot;&gt;tablas&lt;/a&gt; , tambi&amp;eacute;n puede ser generado por otros m&amp;oacute;dulos de colecci&amp;oacute;n como &lt;a href=&quot;sets&quot;&gt;conjuntos&lt;/a&gt; o &lt;a href=&quot;strtabs&quot;&gt;strtabs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ff0881f9033325d1090cbf272495b3ea89cd9ef" translate="yes" xml:space="preserve">
          <source>Move optimization</source>
          <target state="translated">Optimización del movimiento</target>
        </trans-unit>
        <trans-unit id="4406458901a000581b1c862bae39b54d20d9bf38" translate="yes" xml:space="preserve">
          <source>Moves a directory from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised.</source>
          <target state="translated">Mueve un directorio de &lt;em&gt;origen&lt;/em&gt; a &lt;em&gt;destino&lt;/em&gt; . Si esto falla, se &lt;em&gt;genera OSError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8a88abf00e872b645596ba5706595492621b50d3" translate="yes" xml:space="preserve">
          <source>Moves a file from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. Can be used to &lt;span id=&quot;rename-files_1&quot;&gt;rename files&lt;/span&gt;</source>
          <target state="translated">Mueve un archivo de &lt;em&gt;origen&lt;/em&gt; a &lt;em&gt;destino&lt;/em&gt; . Si esto falla, se &lt;em&gt;genera OSError&lt;/em&gt; . Puede usarse para &lt;span id=&quot;rename-files_1&quot;&gt;cambiar el nombre de los archivos&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8720bd922009aac72de226d7d61d6fe73ea2154f" translate="yes" xml:space="preserve">
          <source>Moves the cursor backward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">Mueve el cursor hacia atr&amp;aacute;s por columnas de &lt;em&gt;conteo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4f5707c476bf0444f3d7ca4829bce587056960" translate="yes" xml:space="preserve">
          <source>Moves the cursor down by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">Mueve el cursor hacia abajo &lt;em&gt;contando&lt;/em&gt; filas.</target>
        </trans-unit>
        <trans-unit id="5731b74c9a2498294ab69fa71acf35d7129365e9" translate="yes" xml:space="preserve">
          <source>Moves the cursor forward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">Mueve el cursor hacia adelante por columnas de &lt;em&gt;conteo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eb4d28da6332be8ce6373d9d339c7fe48fa23486" translate="yes" xml:space="preserve">
          <source>Moves the cursor up by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">Mueve el cursor hacia arriba &lt;em&gt;contando&lt;/em&gt; filas.</target>
        </trans-unit>
        <trans-unit id="78732a3d2d5bc767bacb10d82e232dfa8d87404f" translate="yes" xml:space="preserve">
          <source>Much like generics, concepts are instantiated exactly once for each tested type and any static code included within the body is executed only once.</source>
          <target state="translated">Al igual que los genéricos,los conceptos se instancian exactamente una vez para cada tipo probado y cualquier código estático incluido en el cuerpo se ejecuta sólo una vez.</target>
        </trans-unit>
        <trans-unit id="1d5f2fd6e9c15080786fa9fc4a690a2cc1e48b6a" translate="yes" xml:space="preserve">
          <source>Multi-line procedure calls should continue on the same column as the opening parenthesis (like multi-line procedure declarations).</source>
          <target state="translated">Las llamadas de procedimientos multilínea deben continuar en la misma columna que el paréntesis de apertura (como las declaraciones de procedimientos multilínea).</target>
        </trans-unit>
        <trans-unit id="9254f56fa866823471402ac94c86d60cd0bf7ec3" translate="yes" xml:space="preserve">
          <source>Multi-methods</source>
          <target state="translated">Multi-methods</target>
        </trans-unit>
        <trans-unit id="f038ab50dbba14467b3f2d54ae4453034bd4e0b4" translate="yes" xml:space="preserve">
          <source>Multicast address.</source>
          <target state="translated">Dirección de multidifusión.</target>
        </trans-unit>
        <trans-unit id="7eef768291d80681527aa60e3df38506cba1a219" translate="yes" xml:space="preserve">
          <source>Multicast global address.</source>
          <target state="translated">Dirección mundial multicast.</target>
        </trans-unit>
        <trans-unit id="48369fed2a551361b8045057023eecff834b5fb1" translate="yes" xml:space="preserve">
          <source>Multicast link-local address.</source>
          <target state="translated">Dirección local de enlace multicast.</target>
        </trans-unit>
        <trans-unit id="24dcc40f5a40c25ac2feb7b6c8089ae89a9733cc" translate="yes" xml:space="preserve">
          <source>Multicast node-local address.</source>
          <target state="translated">Dirección local de nodos multicast.</target>
        </trans-unit>
        <trans-unit id="7b7ea2cc81efabb6fd79723109a63d77b71fcdc4" translate="yes" xml:space="preserve">
          <source>Multicast organization-local address.</source>
          <target state="translated">Organización multicast-dirección local.</target>
        </trans-unit>
        <trans-unit id="3867c8b804a55ef6500439f739768f84c270b65d" translate="yes" xml:space="preserve">
          <source>Multicast site-local address.</source>
          <target state="translated">Dirección local de un sitio de multidifusión.</target>
        </trans-unit>
        <trans-unit id="d8164f83c1acb0822b6c1157de32950f13f00bf8" translate="yes" xml:space="preserve">
          <source>Multiline comments</source>
          <target state="translated">Comentarios multilínea</target>
        </trans-unit>
        <trans-unit id="64ad927c3d1f8a60b8de3a4dcfa11cb5f9ed2b35" translate="yes" xml:space="preserve">
          <source>Multiline comments are started with &lt;code&gt;#[&lt;/code&gt; and terminated with &lt;code&gt;]#&lt;/code&gt;. Multiline comments can also be nested.</source>
          <target state="translated">Los comentarios de varias l&amp;iacute;neas comienzan con &lt;code&gt;#[&lt;/code&gt; y terminan con &lt;code&gt;]#&lt;/code&gt; . Los comentarios de varias l&amp;iacute;neas tambi&amp;eacute;n se pueden anidar.</target>
        </trans-unit>
        <trans-unit id="51b13e7abf733936d7df1349e642855933b8c93f" translate="yes" xml:space="preserve">
          <source>Multiline comments support nesting:</source>
          <target state="translated">Los comentarios multilínea apoyan el anidamiento:</target>
        </trans-unit>
        <trans-unit id="d8b83fc7a7727ea41499ff067b6d0dbb7149942a" translate="yes" xml:space="preserve">
          <source>Multiline documentation comments also exist and support nesting too:</source>
          <target state="translated">También existen comentarios de documentación multilínea que apoyan el anidamiento:</target>
        </trans-unit>
        <trans-unit id="cbf27a3ccf0fd00bcb0f6850421450358a6cae08" translate="yes" xml:space="preserve">
          <source>Multimedia support</source>
          <target state="translated">Soporte multimedia</target>
        </trans-unit>
        <trans-unit id="09f3196845a8359a6ecedfa5af3141e1edccd739" translate="yes" xml:space="preserve">
          <source>Multiple arguments can be used.</source>
          <target state="translated">Se pueden utilizar múltiples argumentos.</target>
        </trans-unit>
        <trans-unit id="a89c998a8939bd86eba71a1abb06f5d85c817883" translate="yes" xml:space="preserve">
          <source>Multiplies in place a floating point number</source>
          <target state="translated">Multiplica en el lugar un número de punto flotante</target>
        </trans-unit>
        <trans-unit id="fcd886e69a9b9ba9f155b8a7f1e41875370c7b1d" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;x&lt;/em&gt; with &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Multiplica &lt;em&gt;x&lt;/em&gt; por &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f2f1bb918524a79ef38752dea6ec686cd665c1" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Multiplica &lt;em&gt;y&lt;/em&gt; por &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cf4b7cc064435e9b222c2ae1ef88a90049e33ef7" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Multiplica &lt;em&gt;y&lt;/em&gt; por el n&amp;uacute;mero complejo &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="967a2a96e493c3fa19de6d580534df7c563be46e" translate="yes" xml:space="preserve">
          <source>Multiply a duration by some scalar.</source>
          <target state="translated">Multiplica una duración por un escalar.</target>
        </trans-unit>
        <trans-unit id="3992914db890fb69ae7d33ac0b14f1598d61248c" translate="yes" xml:space="preserve">
          <source>Multiply complex &lt;em&gt;x&lt;/em&gt; with float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Multiplica el complejo &lt;em&gt;x&lt;/em&gt; con float &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1b5c2c91504b80f3c83b9e589314371f1f27f89a" translate="yes" xml:space="preserve">
          <source>Multiply float &lt;em&gt;x&lt;/em&gt; with complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Multiplica el flotador &lt;em&gt;x&lt;/em&gt; por el complejo &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0476878c0b1cabcde1afe8aa70cf6a429753af27" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;x&lt;/em&gt; with rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Multiplica int &lt;em&gt;x&lt;/em&gt; con &lt;em&gt;y&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="10cf9524fcce1f51fd3027d067a68e18439d699b" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Multiplica int &lt;em&gt;y&lt;/em&gt; por &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="bfb40c2a917440a979a3937c83ab1838a96e6061" translate="yes" xml:space="preserve">
          <source>Multiply rational &lt;em&gt;x&lt;/em&gt; with int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Multiplica &lt;em&gt;x&lt;/em&gt; racional con int &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="be6d2d49f08d8ce52cada7a4e40308b84089a378" translate="yes" xml:space="preserve">
          <source>Multiply rationals &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Multiplica los racionales &lt;em&gt;y&lt;/em&gt; por &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="407f3e6e72365b49bada1f7c9b2babeb3f8c1e8f" translate="yes" xml:space="preserve">
          <source>Multiply two rational numbers.</source>
          <target state="translated">Multiplica dos números racionales.</target>
        </trans-unit>
        <trans-unit id="57d62a44db1dbaaab6871e35242edd989b03aa79" translate="yes" xml:space="preserve">
          <source>Mutually recursive types</source>
          <target state="translated">Tipos mutuamente recursivos</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="c83bf68eaf2532d248d1885057b7fe59c910abf7" translate="yes" xml:space="preserve">
          <source>Name of the test suite that contains this test case. Can be &lt;code&gt;nil&lt;/code&gt; if the test case is not in a suite.</source>
          <target state="translated">Nombre del conjunto de pruebas que contiene este caso de prueba. Puede ser &lt;code&gt;nil&lt;/code&gt; si el caso de prueba no est&amp;aacute; en una suite.</target>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="translated">Argumentos nombrados</target>
        </trans-unit>
        <trans-unit id="dc74246cc093982dca8a3a3f276b5d8b65d59486" translate="yes" xml:space="preserve">
          <source>Named pipe, or FIFO.</source>
          <target state="translated">Se llama tubería,o FIFO.</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">Convenciones de nombres</target>
        </trans-unit>
        <trans-unit id="c6c5f0ef33b66371fc9992be0b7555afe7072e1f" translate="yes" xml:space="preserve">
          <source>Naming scheme</source>
          <target state="translated">Esquema de nombres...</target>
        </trans-unit>
        <trans-unit id="9a732a9b195778d45aff4c029836d8016c6d092a" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last access.</source>
          <target state="translated">Nanosegundo-granularidad tiempo del último acceso.</target>
        </trans-unit>
        <trans-unit id="44a8ea231c9b25a28c6b1bae13f6d58d8ab769bb" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last data modification.</source>
          <target state="translated">Tiempo de granularidad de nanosegundos de la última modificación de datos.</target>
        </trans-unit>
        <trans-unit id="ac4471c1eac2668f96fa75ca630c4f282bc0b52a" translate="yes" xml:space="preserve">
          <source>Nanoseconds display</source>
          <target state="translated">Pantalla de nanosegundos</target>
        </trans-unit>
        <trans-unit id="8b8960e4540a492b4c2ade7385f3643ce326ec71" translate="yes" xml:space="preserve">
          <source>Natural log of the gamma function</source>
          <target state="translated">El registro natural de la función gamma</target>
        </trans-unit>
        <trans-unit id="40ae5bdaf41bbc2df0ddd3ba6cd0e29b307d851a" translate="yes" xml:space="preserve">
          <source>Navigation through the FTP server's directories.</source>
          <target state="translated">Navegación a través de los directorios del servidor FTP.</target>
        </trans-unit>
        <trans-unit id="b5c25dae4dbbde41bb6194a297db2a60c41076f4" translate="yes" xml:space="preserve">
          <source>Negated version of &lt;em&gt;is&lt;/em&gt;. Equivalent to &lt;code&gt;not(x is y)&lt;/code&gt;.</source>
          <target state="translated">Versi&amp;oacute;n negada de &lt;em&gt;is&lt;/em&gt; . Equivalente a &lt;code&gt;not(x is y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c0ca5089d3b83be1bafc4d4d1a8a2d03a288270" translate="yes" xml:space="preserve">
          <source>Neither inline nor closure iterators can be recursive.</source>
          <target state="translated">Ni los iteradores en línea ni los de cierre pueden ser recursivos.</target>
        </trans-unit>
        <trans-unit id="0db36e51e26b9948538aa75241b28b52b8a7c448" translate="yes" xml:space="preserve">
          <source>Neither the name of the University of Cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="translated">No se podrá utilizar el nombre de la Universidad de Cambridge ni los nombres de sus colaboradores para respaldar o promover productos derivados de este software sin un permiso específico previo por escrito.</target>
        </trans-unit>
        <trans-unit id="d050b1bc6d5102e8c3c43e52f8c2bc1d471d35c1" translate="yes" xml:space="preserve">
          <source>Network Programming and Internet Protocols</source>
          <target state="translated">Programación de redes y protocolos de Internet</target>
        </trans-unit>
        <trans-unit id="171eece6964ab33a2181793b80b9e480760fd86a" translate="yes" xml:space="preserve">
          <source>Never used by PCRE itself</source>
          <target state="translated">Nunca utilizado por el propio PCRE</target>
        </trans-unit>
        <trans-unit id="17c5fe945bffa6ac038aff7b2982abfca0575621" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;AsyncEvent&lt;/code&gt; object is not automatically registered with dispatcher like &lt;code&gt;AsyncSocket&lt;/code&gt;.</source>
          <target state="translated">El nuevo objeto &lt;code&gt;AsyncEvent&lt;/code&gt; no se registra autom&amp;aacute;ticamente con el despachador como &lt;code&gt;AsyncSocket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28d212a8c45cffe38583de7b76bc156d6b77f1fb" translate="yes" xml:space="preserve">
          <source>New data is written into the future stream.</source>
          <target state="translated">Se escriben nuevos datos en la corriente del futuro.</target>
        </trans-unit>
        <trans-unit id="567bb6ab39291d029af6c28280c594e2fe015993" translate="yes" xml:space="preserve">
          <source>New nil literal shortcut</source>
          <target state="translated">Nuevo atajo literal nulo</target>
        </trans-unit>
        <trans-unit id="8bcd0a2c52378cf0d5699266d7e259ed99978f8c" translate="yes" xml:space="preserve">
          <source>Nim</source>
          <target state="translated">Nim</target>
        </trans-unit>
        <trans-unit id="7793ecd2f1c81dc748001f595a446d07a21dca61" translate="yes" xml:space="preserve">
          <source>Nim Backend Integration</source>
          <target state="translated">Integración de Nim Backend</target>
        </trans-unit>
        <trans-unit id="16df2910cd311102e24b9deaaab6834d4ce68a59" translate="yes" xml:space="preserve">
          <source>Nim Compiler</source>
          <target state="translated">Compilador Nim</target>
        </trans-unit>
        <trans-unit id="21f8909f95c6aa6f948aea798f908963482f9a9e" translate="yes" xml:space="preserve">
          <source>Nim Compiler User Guide</source>
          <target state="translated">Guía del usuario del Compilador Nim</target>
        </trans-unit>
        <trans-unit id="4e729000a4923f3f92aa9b54b57cd9d13b461a42" translate="yes" xml:space="preserve">
          <source>Nim DocGen Tools Guide</source>
          <target state="translated">Guía de herramientas Nim DocGen</target>
        </trans-unit>
        <trans-unit id="3e73c9c60a5f0a7a9de0b9e82a823b0e9e25a26d" translate="yes" xml:space="preserve">
          <source>Nim Documentation</source>
          <target state="translated">Documentación de Nim</target>
        </trans-unit>
        <trans-unit id="f6faadf36850555183f2e6623ce564cd582735b7" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1</source>
          <target state="translated">Propuesta de mejora de Nim #1</target>
        </trans-unit>
        <trans-unit id="a017c7a8f194b967e2353a197aaf8085c32d102d" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1 - Standard Library Style Guide</source>
          <target state="translated">Propuesta de mejora de Nim #1-Guía de estilo de la biblioteca estándar</target>
        </trans-unit>
        <trans-unit id="088e91f2731d3d61908df7c6c9c0f48f04e35180" translate="yes" xml:space="preserve">
          <source>Nim IDE Integration Guide</source>
          <target state="translated">Guía de integración de Nim IDE</target>
        </trans-unit>
        <trans-unit id="ff5833e01f31589edf6457bc7ab5ad35afc09f25" translate="yes" xml:space="preserve">
          <source>Nim Manual</source>
          <target state="translated">Manual de Nim</target>
        </trans-unit>
        <trans-unit id="a5cb0d9617774a42fc73cf0e3f868eb3b8c421d4" translate="yes" xml:space="preserve">
          <source>Nim OID support. An OID is a global ID that consists of a timestamp, a unique counter and a random value. This combination should suffice to produce a globally distributed unique ID. This implementation was extracted from the Mongodb interface and it thus binary compatible with a Mongo OID.</source>
          <target state="translated">Apoyo de Nim OID.Un OID es una identificación global que consiste en una marca de tiempo,un contador único y un valor aleatorio.Esta combinación debería ser suficiente para producir una identificación única distribuida globalmente.Esta implementación se extrajo de la interfaz de Mongodb y,por lo tanto,es binaria y compatible con un OID de Mongo.</target>
        </trans-unit>
        <trans-unit id="8afe44256c32445d4aba7446f16d139424f08995" translate="yes" xml:space="preserve">
          <source>Nim Standard Library</source>
          <target state="translated">Biblioteca de Nim Standard</target>
        </trans-unit>
        <trans-unit id="322ec21475cb7cfeb95acf76114506a7658630c5" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part I)</source>
          <target state="translated">Tutorial de Nim (Parte I)</target>
        </trans-unit>
        <trans-unit id="e48ab7d7dac65733835e8b6fac71558fd72d4d0c" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part II)</source>
          <target state="translated">Tutorial de Nim (Parte II)</target>
        </trans-unit>
        <trans-unit id="ab4a51307d67466d1629dcfcafd64254208d0d47" translate="yes" xml:space="preserve">
          <source>Nim allows &lt;code&gt;.global, compiletime&lt;/code&gt; variables that can be filled by macro invokations across different modules. This feature breaks modularity in a severe way. Plenty of different solutions have been proposed:</source>
          <target state="translated">Nim permite &lt;code&gt;.global, compiletime&lt;/code&gt; variables en tiempo de compilaci&amp;oacute;n que se pueden completar mediante invocaciones de macros en diferentes m&amp;oacute;dulos. Esta caracter&amp;iacute;stica rompe la modularidad de una manera severa. Se han propuesto muchas soluciones diferentes:</target>
        </trans-unit>
        <trans-unit id="e7723fae5b868ab64bfd1ed4f9d563b3f719c2a6" translate="yes" xml:space="preserve">
          <source>Nim allows user defined operators. An operator is any combination of the following characters:</source>
          <target state="translated">Nim permite operadores definidos por el usuario.Un operador es cualquier combinación de los siguientes caracteres:</target>
        </trans-unit>
        <trans-unit id="dec77fd63ea6f3b6392da08312e8457c86c6a4ab" translate="yes" xml:space="preserve">
          <source>Nim allows user-definable operators. Binary operators have 11 different levels of precedence.</source>
          <target state="translated">Nim permite operadores definibles por el usuario.Los operadores binarios tienen 11 niveles diferentes de precedencia.</target>
        </trans-unit>
        <trans-unit id="bb3ac87c3ce8cafa37c2ac5913d2e44f2c0fae11" translate="yes" xml:space="preserve">
          <source>Nim also allows for type classes and regular types to be specified as &lt;span id=&quot;type-constraints_1&quot;&gt;type constraints&lt;/span&gt; of the generic type parameter:</source>
          <target state="translated">Nim tambi&amp;eacute;n permite que las clases de tipos y los tipos regulares se especifiquen como &lt;span id=&quot;type-constraints_1&quot;&gt;restricciones&lt;/span&gt; de tipo del par&amp;aacute;metro de tipo gen&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="c7367770c702c3c07c0edb5a157905ffed2fb24f" translate="yes" xml:space="preserve">
          <source>Nim avoids these problems by not assigning methods to a class. All methods in Nim are multi-methods. As we will see later, multi-methods are distinguished from procs only for dynamic binding purposes.</source>
          <target state="translated">Nim evita estos problemas no asignando métodos a una clase.Todos los métodos en Nim son multi-métodos.Como veremos más adelante,los multi-métodos se distinguen de los procedimientos sólo para fines de vinculación dinámica.</target>
        </trans-unit>
        <trans-unit id="5fb26fe48597e8b904be37ef641797aa814138fa" translate="yes" xml:space="preserve">
          <source>Nim can also generate &lt;span id=&quot;javascript_1&quot;&gt;JavaScript&lt;/span&gt; code through the &lt;code&gt;js&lt;/code&gt; command.</source>
          <target state="translated">Nim tambi&amp;eacute;n puede generar c&amp;oacute;digo &lt;span id=&quot;javascript_1&quot;&gt;JavaScript&lt;/span&gt; mediante el comando &lt;code&gt;js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af85440d1b434e6ec278854daf1f3f305d5ad156" translate="yes" xml:space="preserve">
          <source>Nim code calling the backend</source>
          <target state="translated">El código Nim llamando al backend</target>
        </trans-unit>
        <trans-unit id="6b156a5e46fd0f15d386450049ef7bee6965340f" translate="yes" xml:space="preserve">
          <source>Nim code can be compiled to JavaScript. However in order to write JavaScript-compatible code you should remember the following:</source>
          <target state="translated">El código Nim puede ser compilado en JavaScript.Sin embargo,para escribir código compatible con JavaScript debes recordar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="0c9fa29ab6035f83a6a5d536db8f22202827f364" translate="yes" xml:space="preserve">
          <source>Nim code can interface with the backend through the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;Foreign function interface&lt;/a&gt; mainly through the &lt;a href=&quot;manual#importc-pragma&quot;&gt;importc pragma&lt;/a&gt;. The &lt;code&gt;importc&lt;/code&gt; pragma is the &lt;em&gt;generic&lt;/em&gt; way of making backend symbols available in Nim and is available in all the target backends (JavaScript too). The C++ or Objective-C backends have their respective &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp&lt;/a&gt; and &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt; pragmas to call methods from classes.</source>
          <target state="translated">El c&amp;oacute;digo de Nim puede interactuar con el backend a trav&amp;eacute;s de la &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;interfaz de funciones &lt;/a&gt;&lt;a href=&quot;manual#importc-pragma&quot;&gt;externas&lt;/a&gt; principalmente a trav&amp;eacute;s de importc pragma . El pragma &lt;code&gt;importc&lt;/code&gt; es la forma &lt;em&gt;gen&amp;eacute;rica&lt;/em&gt; de hacer que los s&amp;iacute;mbolos de backend est&amp;eacute;n disponibles en Nim y est&amp;aacute; disponible en todos los backends de destino (JavaScript tambi&amp;eacute;n). El backends de Objective-C o C ++ tienen sus respectivos &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp&lt;/a&gt; y &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt; pragmas para llamar a los m&amp;eacute;todos de clases.</target>
        </trans-unit>
        <trans-unit id="31a93bb37537ccf8bc65c227c96a067156777ba9" translate="yes" xml:space="preserve">
          <source>Nim code renderer (AST back to its textual form)</source>
          <target state="translated">Renderizador de código Nim (AST de vuelta a su forma textual)</target>
        </trans-unit>
        <trans-unit id="fabc8c2c3d55b64590195b71fee1f8bf15a0783b" translate="yes" xml:space="preserve">
          <source>Nim condition variable</source>
          <target state="translated">La condición Nim variable</target>
        </trans-unit>
        <trans-unit id="d2f3eed8f027ae703cfbb62e68bece8443bf88e7" translate="yes" xml:space="preserve">
          <source>Nim contains a sophisticated compile-time evaluator, so procedures which have no side-effect can be used in constant expressions too:</source>
          <target state="translated">Nim contiene un sofisticado evaluador de tiempo de compilación,por lo que los procedimientos que no tienen ningún efecto secundario pueden utilizarse también en expresiones constantes:</target>
        </trans-unit>
        <trans-unit id="5a84a384a071f2c590cf4715be4dfac5778bd58a" translate="yes" xml:space="preserve">
          <source>Nim contains language features that are &lt;em&gt;global&lt;/em&gt;. The best example for that are multi methods: Introducing a new method with the same name and some compatible object parameter means that the method's dispatcher needs to take the new method into account. So the dispatching logic is only completely known after the whole program has been translated!</source>
          <target state="translated">Nim contiene caracter&amp;iacute;sticas de lenguaje que son &lt;em&gt;globales&lt;/em&gt; . El mejor ejemplo son los m&amp;eacute;todos m&amp;uacute;ltiples: la introducci&amp;oacute;n de un nuevo m&amp;eacute;todo con el mismo nombre y alg&amp;uacute;n par&amp;aacute;metro de objeto compatible significa que el despachador del m&amp;eacute;todo debe tener en cuenta el nuevo m&amp;eacute;todo. &amp;iexcl;As&amp;iacute; que la l&amp;oacute;gica de env&amp;iacute;o solo se conoce completamente despu&amp;eacute;s de que se haya traducido todo el programa!</target>
        </trans-unit>
        <trans-unit id="fc85ea062290958c11ff84b074507e523841a2ee" translate="yes" xml:space="preserve">
          <source>Nim coroutines implementation supports several context switching methods: ucontext: available on unix and alike (default) setjmp: available on unix and alike (x86/64 only) Fibers: available and required on windows.</source>
          <target state="translated">La implementación de Nim coroutines soporta varios métodos de cambio de contexto:ucontext:disponible en unix y similares (por defecto)setjmp:disponible en unix y similares (sólo x86/64)Fibras:disponibles y requeridas en windows.</target>
        </trans-unit>
        <trans-unit id="bd26dc8c514bd37794fcd3b5dc3270d84d36b348" translate="yes" xml:space="preserve">
          <source>Nim currently generates &lt;em&gt;async/await&lt;/em&gt; JavaScript code which is supported in modern EcmaScript and most modern versions of browsers, Node.js and Electron. If you need to use this module with older versions of JavaScript, you can use a tool that backports the resulting JavaScript code, as babel.</source>
          <target state="translated">Nim actualmente genera c&amp;oacute;digo JavaScript &lt;em&gt;as&amp;iacute;ncrono / en espera&lt;/em&gt; que es compatible con EcmaScript moderno y la mayor&amp;iacute;a de las versiones modernas de navegadores, Node.js y Electron. Si necesita usar este m&amp;oacute;dulo con versiones anteriores de JavaScript, puede usar una herramienta que respalde el c&amp;oacute;digo JavaScript resultante, como babel.</target>
        </trans-unit>
        <trans-unit id="9bb9f4917308e21a1a3ea298a44a71e622ad4adc" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;idetools&lt;/code&gt; command of &lt;a href=&quot;nimc&quot;&gt;the compiler&lt;/a&gt;, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim se diferencia de muchos otros compiladores en que es realmente r&amp;aacute;pido y, al ser tan r&amp;aacute;pido, es adecuado para proporcionar consultas externas a los editores de texto sobre el c&amp;oacute;digo fuente que se est&amp;aacute; escribiendo. A trav&amp;eacute;s del comando &lt;code&gt;idetools&lt;/code&gt; del &lt;a href=&quot;nimc&quot;&gt;compilador&lt;/a&gt; , cualquier IDE puede consultar un archivo fuente &lt;code&gt;.nim&lt;/code&gt; y obtener informaci&amp;oacute;n &amp;uacute;til como la definici&amp;oacute;n de s&amp;iacute;mbolos o sugerencias para completar.</target>
        </trans-unit>
        <trans-unit id="5f7c9cacf76b4e6e9b8bdb4149ed42fa0f2b0f03" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim se diferencia de muchos otros compiladores en que es realmente r&amp;aacute;pido y, al ser tan r&amp;aacute;pido, es adecuado para proporcionar consultas externas a los editores de texto sobre el c&amp;oacute;digo fuente que se est&amp;aacute; escribiendo. A trav&amp;eacute;s de la herramienta &lt;code&gt;nimsuggest&lt;/code&gt; , cualquier IDE puede consultar un archivo fuente &lt;code&gt;.nim&lt;/code&gt; y obtener informaci&amp;oacute;n &amp;uacute;til como la definici&amp;oacute;n de s&amp;iacute;mbolos o sugerencias para completar.</target>
        </trans-unit>
        <trans-unit id="2086951d5e25c94d3bcd3c946d696aab645c5e42" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects in a garbage collected heap, untraced references point to manually allocated objects or to objects elsewhere in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (e.g., accessing the hardware), untraced references are necessary.</source>
          <target state="translated">Distingue entre Nim &lt;span id=&quot;traced_1&quot;&gt;trazadas&lt;/span&gt; y &lt;span id=&quot;untraced_1&quot;&gt;no identificados&lt;/span&gt; referencias. Las referencias no rastreadas tambi&amp;eacute;n se denominan &lt;em&gt;punteros&lt;/em&gt; . Las referencias rastreadas apuntan a objetos en un mont&amp;oacute;n de basura recolectada, las referencias no rastreadas apuntan a objetos asignados manualmente o a objetos en otra parte de la memoria. Por lo tanto, las referencias sin rastrear &lt;em&gt;no&lt;/em&gt; son &lt;em&gt;seguras&lt;/em&gt; . Sin embargo, para ciertas operaciones de bajo nivel (por ejemplo, acceder al hardware), se necesitan referencias sin rastrear.</target>
        </trans-unit>
        <trans-unit id="ccd83d27c6d420699215e95b7549c5d18179dd95" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects of a garbage collected heap, untraced references point to manually allocated objects or to objects somewhere else in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (accessing the hardware) untraced references are unavoidable.</source>
          <target state="translated">Distingue entre Nim &lt;span id=&quot;traced_1&quot;&gt;trazadas&lt;/span&gt; y &lt;span id=&quot;untraced_1&quot;&gt;no identificados&lt;/span&gt; referencias. Las referencias no rastreadas tambi&amp;eacute;n se denominan &lt;em&gt;punteros&lt;/em&gt; . Las referencias rastreadas apuntan a objetos de un mont&amp;oacute;n de basura recolectada, las referencias no rastreadas apuntan a objetos asignados manualmente o a objetos en alg&amp;uacute;n otro lugar de la memoria. Por lo tanto, las referencias &lt;em&gt;no&lt;/em&gt; rastreadas &lt;em&gt;no&lt;/em&gt; son &lt;em&gt;seguras&lt;/em&gt; . Sin embargo, para ciertas operaciones de bajo nivel (acceso al hardware), las referencias no rastreadas son inevitables.</target>
        </trans-unit>
        <trans-unit id="dac7bba6bc8f19f6387033c2480f36e741751cd5" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;type-casts_1&quot;&gt;type casts&lt;/span&gt; and &lt;span id=&quot;type-conversions_1&quot;&gt;type conversions&lt;/span&gt;. Casts are done with the &lt;code&gt;cast&lt;/code&gt; operator and force the compiler to interpret a bit pattern to be of another type.</source>
          <target state="translated">Nim distingue entre &lt;span id=&quot;type-casts_1&quot;&gt;moldes tipo&lt;/span&gt; y &lt;span id=&quot;type-conversions_1&quot;&gt;conversiones de tipos&lt;/span&gt; . Los moldes se realizan con el &lt;code&gt;cast&lt;/code&gt; del operador y obligar al compilador para interpretar un patr&amp;oacute;n de bits a ser de otro tipo.</target>
        </trans-unit>
        <trans-unit id="0dc26f37589711a4ebd6a75d29c4f31d6f5268ca" translate="yes" xml:space="preserve">
          <source>Nim documentation tools</source>
          <target state="translated">Herramientas de documentación de Nim</target>
        </trans-unit>
        <trans-unit id="32a303beaf961d29337f0ffeb398d9c829260321" translate="yes" xml:space="preserve">
          <source>Nim expression</source>
          <target state="translated">La expresión de Nim</target>
        </trans-unit>
        <trans-unit id="835ecda86802386305ce589edd8369f0e4a635cf" translate="yes" xml:space="preserve">
          <source>Nim file input</source>
          <target state="translated">Entrada del archivo Nim</target>
        </trans-unit>
        <trans-unit id="07b88f09d9e474dda1eb0ea8c1cc96c629f4c605" translate="yes" xml:space="preserve">
          <source>Nim for embedded systems</source>
          <target state="translated">Nim para sistemas empotrados</target>
        </trans-unit>
        <trans-unit id="a0e42e450f6ef10bfc996fbef965403967ca2952" translate="yes" xml:space="preserve">
          <source>Nim for realtime systems</source>
          <target state="translated">Nim para sistemas en tiempo real</target>
        </trans-unit>
        <trans-unit id="ad31881a208f486ef9ab2bb940bdcd789a709ad9" translate="yes" xml:space="preserve">
          <source>Nim generates some warnings and hints (&quot;line too long&quot;) that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:</source>
          <target state="translated">Nim genera algunas advertencias y consejos (&quot;línea demasiado larga&quot;)que pueden molestar al usuario.Se proporciona un mecanismo para desactivar ciertos mensajes:Cada pista y mensaje de advertencia contiene un simbolo entre paréntesis.Este es el identificador del mensaje que se puede utilizar para activarlo o desactivarlo:</target>
        </trans-unit>
        <trans-unit id="956810679fde5bcd94729ea5a195b781ebc9936f" translate="yes" xml:space="preserve">
          <source>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; features should be used instead. Both parallel and spawn need the &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; module to work.</source>
          <target state="translated">Nim tiene un grupo de subprocesos incorporado que se puede usar para tareas intensivas de CPU. Para las tareas intensivas IO los &lt;code&gt;async&lt;/code&gt; y &lt;code&gt;await&lt;/code&gt; caracter&amp;iacute;sticas se deben utilizar en su lugar. Tanto el paralelo como el spawn necesitan que el m&amp;oacute;dulo &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; funcione.</target>
        </trans-unit>
        <trans-unit id="8271465a18dfd05fb2b43750bb600424d58f8d93" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Nim no necesita &lt;em&gt;propiedades&lt;/em&gt; get: los procedimientos get ordinarios que se llaman con la &lt;em&gt;sintaxis de llamada&lt;/em&gt; al &lt;em&gt;m&amp;eacute;todo&lt;/em&gt; logran lo mismo. Pero establecer un valor es diferente; para esto se necesita una sintaxis especial de setter:</target>
        </trans-unit>
        <trans-unit id="73a3428d8f1eb98b6a56266f5afa22c38fb951ee" translate="yes" xml:space="preserve">
          <source>Nim has no separate optimizer, but the C code that is produced is very efficient. Most C compilers have excellent optimizers, so usually it is not needed to optimize one's code. Nim has been designed to encourage efficient code: The most readable code in Nim is often the most efficient too.</source>
          <target state="translated">Nim no tiene un optimizador separado,pero el código C que se produce es muy eficiente.La mayoría de los compiladores C tienen excelentes optimizadores,así que usualmente no es necesario optimizar el código de uno.Nim ha sido diseñado para fomentar un código eficiente:El código más legible en Nim es a menudo el más eficiente también.</target>
        </trans-unit>
        <trans-unit id="d4433d8ee67c60caa5f14cbc4d36fb3fc5be0287" translate="yes" xml:space="preserve">
          <source>Nim has the concept of a global search path (PATH) that is queried to determine where to find imported modules or include files. If multiple files are found an ambiguity error is produced.</source>
          <target state="translated">Nim tiene el concepto de una ruta de búsqueda global (PATH)que se consulta para determinar dónde encontrar los módulos importados o incluir los archivos.Si se encuentran múltiples archivos se produce un error de ambigüedad.</target>
        </trans-unit>
        <trans-unit id="01727ad8d0bbaeeea62faa6f12c71312bf1ae451" translate="yes" xml:space="preserve">
          <source>Nim has these floating point types built-in: &lt;code&gt;float float32 float64&lt;/code&gt;.</source>
          <target state="translated">Nim tiene estos tipos de coma flotante incorporados: &lt;code&gt;float float32 float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3deb8348e9e32056d74290a50d876e63851d29" translate="yes" xml:space="preserve">
          <source>Nim has these integer types built-in: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt;.</source>
          <target state="translated">Nim tiene estos tipos de enteros integrados: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4f95676cbff4f6b732c078d876ae2ad27f446" translate="yes" xml:space="preserve">
          <source>Nim has two flavors of parallelism:</source>
          <target state="translated">Nim tiene dos sabores de paralelismo:</target>
        </trans-unit>
        <trans-unit id="dc5bf296e3c41484c147bfc3cd569c0d2a605bfb" translate="yes" xml:space="preserve">
          <source>Nim idetools integration</source>
          <target state="translated">La integración de las herramientas de Nim idetools</target>
        </trans-unit>
        <trans-unit id="fde430a55fc171aea53e7cacfbb81ff6931bd1b5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from C</source>
          <target state="translated">Ejemplo de invocación de Nim de C</target>
        </trans-unit>
        <trans-unit id="a9b0c283f30ebbd8bbc505d567707e20b58f9be5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from JavaScript</source>
          <target state="translated">Ejemplo de invocación de Nim desde JavaScript</target>
        </trans-unit>
        <trans-unit id="bdd28046b42c51d6419a24b949f2e431ad33feda" translate="yes" xml:space="preserve">
          <source>Nim is free software; it is licensed under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt;.</source>
          <target state="translated">Nim es un software gratuito; tiene licencia de &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7393409ca98f35a585605ecd27b0ce04bc6dc" translate="yes" xml:space="preserve">
          <source>Nim lock, re-entrant</source>
          <target state="translated">Nim lock,reentrada</target>
        </trans-unit>
        <trans-unit id="af2f77b6798efd1fe7af2c6d48238ea2e59af4d3" translate="yes" xml:space="preserve">
          <source>Nim lock; whether this is re-entrant or not is unspecified!</source>
          <target state="translated">Nim lock;si esto es reingresar o no,no está especificado!</target>
        </trans-unit>
        <trans-unit id="396c55174c1748ab5bec4b1cb866abf79d300e48" translate="yes" xml:space="preserve">
          <source>Nim maintenance script</source>
          <target state="translated">Guión de mantenimiento de Nim</target>
        </trans-unit>
        <trans-unit id="200b4437aaf50df9807fc02a8b32574618effddb" translate="yes" xml:space="preserve">
          <source>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</source>
          <target state="translated">Nim ofrece una familia especial de operadores de puntos que pueden utilizarse para interceptar y reescribir intentos de llamada de proc y de acceso al campo,refiriéndose a nombres de símbolos no declarados anteriormente.Pueden utilizarse para proporcionar una interfaz fluida a los objetos que se encuentran fuera de los límites estáticos del sistema de tipos,como los valores de los lenguajes de escritura dinámicos o los formatos de archivos dinámicos como JSON o XML.</target>
        </trans-unit>
        <trans-unit id="67e6a58d0659f4167e32702de63a078a70b84e7d" translate="yes" xml:space="preserve">
          <source>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</source>
          <target state="translated">Nim ofrece una interfaz bidireccional con el backend del objetivo.Esto significa que puedes llamar al código del backend desde Nim y el código Nim puede ser llamado por el código del backend.Usualmente la direccion de las llamadas depende de la arquitectura de tu software (es Nim tu programa principal o Nim provee un componente?).</target>
        </trans-unit>
        <trans-unit id="893f066137f8187ed8a07f2272b19d0871bbc768" translate="yes" xml:space="preserve">
          <source>Nim produces a warning for symbols that are not exported and not used either. The &lt;code&gt;used&lt;/code&gt; pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</source>
          <target state="translated">Nim genera una advertencia para los s&amp;iacute;mbolos que no se exportan y tampoco se utilizan. El pragma &lt;code&gt;used&lt;/code&gt; se puede adjuntar a un s&amp;iacute;mbolo para suprimir esta advertencia. Esto es particularmente &amp;uacute;til cuando el s&amp;iacute;mbolo fue generado por una macro:</target>
        </trans-unit>
        <trans-unit id="6150bb7b7dad74d65ce46c3a55145c510735a725" translate="yes" xml:space="preserve">
          <source>Nim provides language integration with external IDEs through the idetools command. See the documentation of &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; for further information.</source>
          <target state="translated">Nim proporciona integraci&amp;oacute;n de lenguaje con IDE externos a trav&amp;eacute;s del comando idetools. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6864a9277154b157b94a761e493fbd79ef8b809c" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; and &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; commands to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;docgen&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim proporciona los comandos &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; y &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; para generar documentaci&amp;oacute;n HTML a partir de archivos fuente &lt;code&gt;.nim&lt;/code&gt; . Solo los s&amp;iacute;mbolos exportados aparecer&amp;aacute;n en la salida. Para obtener m&amp;aacute;s detalles, &lt;a href=&quot;docgen&quot;&gt;consulte la documentaci&amp;oacute;n de docgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d0f9e0827a8dbea31dc2fbe4ce37db63cfa840c" translate="yes" xml:space="preserve">
          <source>Nim provides the ability to overload procedures similar to C++:</source>
          <target state="translated">Nim provee la habilidad de sobrecargar procedimientos similares a C++:</target>
        </trans-unit>
        <trans-unit id="082cc471f7e487d0e261d56375fe2f285b9ead9d" translate="yes" xml:space="preserve">
          <source>Nim provides the pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; and &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; to control whether the IEEE exceptions are ignored or trap a Nim exception:</source>
          <target state="translated">Nim proporciona los pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; e &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; para controlar si las excepciones IEEE se ignoran o atrapan una excepci&amp;oacute;n de Nim:</target>
        </trans-unit>
        <trans-unit id="86a99b555e8d5a547fbd7a8b6c3c5be83dc59b13" translate="yes" xml:space="preserve">
          <source>Nim search and replace utility.</source>
          <target state="translated">Nim busca y reemplaza la utilidad.</target>
        </trans-unit>
        <trans-unit id="cea72c6813825983207ed89ef6d7563250a6be64" translate="yes" xml:space="preserve">
          <source>Nim significantly improves on the safety of these features via additional pragmas:</source>
          <target state="translated">Nim mejora significativamente la seguridad de estas características a través de pragmas adicionales:</target>
        </trans-unit>
        <trans-unit id="13adb76d4a44fc6d0ed9557643b94613f8b29151" translate="yes" xml:space="preserve">
          <source>Nim support for &lt;span id=&quot;substitution-expressions_1&quot;&gt;substitution expressions&lt;/span&gt; (&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;).</source>
          <target state="translated">Soporte de Nim para &lt;span id=&quot;substitution-expressions_1&quot;&gt;expresiones de sustituci&amp;oacute;n&lt;/span&gt; ( &lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="f308ae3443ec85df73ede4f78102be2e349b672c" translate="yes" xml:space="preserve">
          <source>Nim supports exception tracking. The &lt;span id=&quot;raises_1&quot;&gt;raises&lt;/span&gt; pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</source>
          <target state="translated">Nim admite el seguimiento de excepciones. El pragma de &lt;span id=&quot;raises_1&quot;&gt;aumentos&lt;/span&gt; se puede usar para definir expl&amp;iacute;citamente qu&amp;eacute; excepciones puede generar un proc / iterator / method / converter. El compilador verifica esto:</target>
        </trans-unit>
        <trans-unit id="3f7af30571e6dd9a4e1318813044e95e94a257fb" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own &lt;span id=&quot;namespace_1&quot;&gt;namespace&lt;/span&gt;. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to symbols of another module by the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Recursive module dependencies&lt;/span&gt; are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is &lt;code&gt;identifier.nim&lt;/code&gt;).</source>
          <target state="translated">Nim admite la divisi&amp;oacute;n de un programa en partes mediante un concepto de m&amp;oacute;dulo. Cada m&amp;oacute;dulo debe estar en su propio archivo y tener su propio &lt;span id=&quot;namespace_1&quot;&gt;espacio de nombres&lt;/span&gt; . Los m&amp;oacute;dulos permiten &lt;span id=&quot;information-hiding_1&quot;&gt;ocultar informaci&amp;oacute;n&lt;/span&gt; y &lt;span id=&quot;separate-compilation_1&quot;&gt;compilarlos por separado&lt;/span&gt; . Un m&amp;oacute;dulo puede obtener acceso a los s&amp;iacute;mbolos de otro m&amp;oacute;dulo mediante la declaraci&amp;oacute;n de &lt;span id=&quot;import_1&quot;&gt;importaci&amp;oacute;n&lt;/span&gt; . Se permiten &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;dependencias de m&amp;oacute;dulo recursivas&lt;/span&gt; , pero un poco sutiles. Solo se exportan los s&amp;iacute;mbolos de nivel superior que est&amp;aacute;n marcados con un asterisco ( &lt;code&gt;*&lt;/code&gt; ). Un nombre de m&amp;oacute;dulo v&amp;aacute;lido solo puede ser un identificador de Nim v&amp;aacute;lido (y por lo tanto su nombre de archivo es &lt;code&gt;identifier.nim&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e44eef4a789fd3c119666d4ed23cb9494cb3bbf7" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to the symbols of another module by using the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported:</source>
          <target state="translated">Nim admite la divisi&amp;oacute;n de un programa en partes con un concepto de m&amp;oacute;dulo. Cada m&amp;oacute;dulo est&amp;aacute; en su propio archivo. Los m&amp;oacute;dulos permiten &lt;span id=&quot;information-hiding_1&quot;&gt;ocultar informaci&amp;oacute;n&lt;/span&gt; y &lt;span id=&quot;separate-compilation_1&quot;&gt;compilarlos por separado&lt;/span&gt; . Un m&amp;oacute;dulo puede obtener acceso a los s&amp;iacute;mbolos de otro m&amp;oacute;dulo utilizando la declaraci&amp;oacute;n de &lt;span id=&quot;import_1&quot;&gt;importaci&amp;oacute;n&lt;/span&gt; . Solo se exportan los s&amp;iacute;mbolos de nivel superior que est&amp;aacute;n marcados con un asterisco ( &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="46fdd12ce5e87d8ce22525d0fc7e670179c0d9e1" translate="yes" xml:space="preserve">
          <source>Nim supports the generation of DLLs. However, there must be only one instance of the GC per process/address space. This instance is contained in &lt;code&gt;nimrtl.dll&lt;/code&gt;. This means that every generated Nim DLL depends on &lt;code&gt;nimrtl.dll&lt;/code&gt;. To generate the &quot;nimrtl.dll&quot; file, use the command:</source>
          <target state="translated">Nim admite la generaci&amp;oacute;n de archivos DLL. Sin embargo, debe haber solo una instancia del GC por proceso / espacio de direcciones. Esta instancia est&amp;aacute; contenida en &lt;code&gt;nimrtl.dll&lt;/code&gt; . Esto significa que cada DLL de Nim generada depende de &lt;code&gt;nimrtl.dll&lt;/code&gt; . Para generar el archivo &quot;nimrtl.dll&quot;, use el comando:</target>
        </trans-unit>
        <trans-unit id="9716569bd8c70a883cc816b4d661c7ea0ac3b2d4" translate="yes" xml:space="preserve">
          <source>Nim supports these &lt;span id=&quot;calling-conventions_1&quot;&gt;calling conventions&lt;/span&gt;:</source>
          <target state="translated">Nim admite estas &lt;span id=&quot;calling-conventions_1&quot;&gt;convenciones de llamadas&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="abcf9d9cfc4c5456a80f226fb54d7c37497efa51" translate="yes" xml:space="preserve">
          <source>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Nim apunta a JavaScript 1.5, que es compatible con cualquier navegador ampliamente utilizado. Dado que JavaScript no tiene un medio port&amp;aacute;til para incluir otro m&amp;oacute;dulo, Nim solo genera un archivo &lt;code&gt;.js&lt;/code&gt; largo .</target>
        </trans-unit>
        <trans-unit id="d6334ba658939fb66c6d2eb5152d5c5e1ed6cc5c" translate="yes" xml:space="preserve">
          <source>Nim type</source>
          <target state="translated">Tipo de Nim</target>
        </trans-unit>
        <trans-unit id="12a335b577d343cb196e9cbe8abf689f02aa0bd4" translate="yes" xml:space="preserve">
          <source>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, &lt;em&gt;in pseudo-code&lt;/em&gt;, determines type equality:</source>
          <target state="translated">Nim utiliza la equivalencia de tipo estructural para la mayor&amp;iacute;a de los tipos. Solo para objetos, enumeraciones y tipos diferenciados se utiliza la equivalencia de nombres. El siguiente algoritmo, &lt;em&gt;en pseudoc&amp;oacute;digo&lt;/em&gt; , determina la igualdad de tipos:</target>
        </trans-unit>
        <trans-unit id="1870e8d051fa7bd2733b9612e24fa28e4e1bd585" translate="yes" xml:space="preserve">
          <source>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</source>
          <target state="translated">Nim usa la clásica arquitectura de compilación:Un lexer/escáner alimenta fichas para un analizador.El analizador construye un árbol de sintaxis que es usado por el generador de código.Este árbol de sintaxis es la interfaz entre el analizador y el generador de código.Es esencial entender la mayor parte del código del compilador.</target>
        </trans-unit>
        <trans-unit id="322b8b83d95b2969c2c0f758d4cccd2596086dda" translate="yes" xml:space="preserve">
          <source>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</source>
          <target state="translated">Nim utiliza el paradigma común de declaración/expresión:Las declaraciones no producen un valor en contraste con las expresiones.Sin embargo,algunas expresiones son declaraciones.</target>
        </trans-unit>
        <trans-unit id="16bf12211c3e06c6eb9e50a3ff54ca759ba185c1" translate="yes" xml:space="preserve">
          <source>Nim&amp;#x27;s Garbage Collector</source>
          <target state="translated">Recolector de basura de Nim</target>
        </trans-unit>
        <trans-unit id="9e747b8df254ba8adeea93bf65d5d26fc1f7c029" translate="yes" xml:space="preserve">
          <source>Nim's &lt;code&gt;import&lt;/code&gt; statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n de Nim en realidad tiene diferentes variaciones seg&amp;uacute;n las palabras clave presentes. Comencemos con la forma m&amp;aacute;s simple.</target>
        </trans-unit>
        <trans-unit id="576ef403ca389194e42a3457f0afbf3573e97c72" translate="yes" xml:space="preserve">
          <source>Nim's &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</source>
          <target state="translated">La &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (interfaz de funci&amp;oacute;n externa) de Nim es extensa y solo las partes que escalan a otros backends futuros (como los backends LLVM / JavaScript) est&amp;aacute;n documentadas aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b3a2a3b0146362c9c774e923c0df1b46db23ed52" translate="yes" xml:space="preserve">
          <source>Nim's Garbage Collector</source>
          <target state="translated">El recolector de basura de Nim</target>
        </trans-unit>
        <trans-unit id="a41682260d59280a2b3b6483204da1644fe3e4a8" translate="yes" xml:space="preserve">
          <source>Nim's boolean type is called &lt;code&gt;bool&lt;/code&gt; and consists of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in while, if, elif, and when statements must be of type bool.</source>
          <target state="translated">El tipo booleano de Nim se llama &lt;code&gt;bool&lt;/code&gt; y consta de dos valores predefinidos &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; . Las condiciones en las declaraciones while, if, elif y when deben ser de tipo bool.</target>
        </trans-unit>
        <trans-unit id="13ee675d367062e6a639dae94168d9a9c1a41f44" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different from other common programming languages (C, Pascal): Each thread has its own (garbage collected) heap and sharing of memory is restricted. This helps to prevent race conditions and improves efficiency. See &lt;a href=&quot;manual#threads&quot;&gt;the manual for details of this memory model&lt;/a&gt;.</source>
          <target state="translated">El modelo de memoria de Nim para subprocesos es bastante diferente de otros lenguajes de programaci&amp;oacute;n comunes (C, Pascal): cada subproceso tiene su propio mont&amp;oacute;n (recolecci&amp;oacute;n de basura) y el uso compartido de memoria est&amp;aacute; restringido. Esto ayuda a prevenir las condiciones de carrera y mejora la eficiencia. Consulte &lt;a href=&quot;manual#threads&quot;&gt;el manual para obtener detalles de este modelo de memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e98391c7155144865c0c684166fb6f91c4167fcb" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</source>
          <target state="translated">El modelo de memoria de Nim para los hilos es bastante diferente al de otros lenguajes de programación comunes (C,Pascal,Java):Cada hilo tiene su propio montón (de basura)y compartir la memoria está restringido a variables globales.Esto ayuda a prevenir condiciones de raza.La eficiencia del GC se mejora bastante,porque el GC nunca tiene que detener a otros hilos y ver a qué se refieren.La asignación de memoria no requiere ningún bloqueo.Este diseño se escala fácilmente a procesadores multinúcleo masivos que se están convirtiendo en la norma.</target>
        </trans-unit>
        <trans-unit id="9bd526290438cb61dffae2d2e60576f140904aaf" translate="yes" xml:space="preserve">
          <source>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</source>
          <target state="translated">La sintaxis de objetos de Nim es rica.Echemos un vistazo a un ejemplo implicado en su totalidad para ver algunas de las complejidades.</target>
        </trans-unit>
        <trans-unit id="0d1938981c78468bfa1d2da1e306dcbcb6376cdd" translate="yes" xml:space="preserve">
          <source>Nim's parser</source>
          <target state="translated">El analizador de Nim</target>
        </trans-unit>
        <trans-unit id="acf2817c0d9f0b146da2d625488e15fe41115e79" translate="yes" xml:space="preserve">
          <source>Nim's standard grammar describes an &lt;span id=&quot;indentation-sensitive_1&quot;&gt;indentation sensitive&lt;/span&gt; language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</source>
          <target state="translated">La gram&amp;aacute;tica est&amp;aacute;ndar de Nim describe un lenguaje &lt;span id=&quot;indentation-sensitive_1&quot;&gt;sensible a la sangr&amp;iacute;a&lt;/span&gt; . Esto significa que todas las estructuras de control se reconocen por sangr&amp;iacute;a. La sangr&amp;iacute;a consta solo de espacios; no se permiten tabuladores.</target>
        </trans-unit>
        <trans-unit id="1452a3d3fd11615a428ccdddc1e755ffef521766" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator. Based on the &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor/rotate/shift/rotate) library.</source>
          <target state="translated">Generador de n&amp;uacute;meros aleatorios est&amp;aacute;ndar de Nim. Basado en la &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor / rotate / shift / rotate).</target>
        </trans-unit>
        <trans-unit id="ea6b14412133ed2489b730e9fc4f06291eb4e8ce" translate="yes" xml:space="preserve">
          <source>Nimble</source>
          <target state="translated">Nimble</target>
        </trans-unit>
        <trans-unit id="5e3bca65182fa05bd8858bec9a6e6900f87e2adf" translate="yes" xml:space="preserve">
          <source>Nimble is a package manager for the Nim programming language. For instructions on how to install Nimble packages see &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;its README&lt;/a&gt;.</source>
          <target state="translated">Nimble es un administrador de paquetes para el lenguaje de programaci&amp;oacute;n Nim. Para obtener instrucciones sobre c&amp;oacute;mo instalar paquetes de Nimble, consulte &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;su archivo README&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5af01d1d4ff2ceea4a8135b93a3b16c4bb879507" translate="yes" xml:space="preserve">
          <source>Nimcache and C like targets</source>
          <target state="translated">Nimcache y C como objetivos</target>
        </trans-unit>
        <trans-unit id="d63113aa6032c199ac973f9c41b92f6b86bc69c5" translate="yes" xml:space="preserve">
          <source>Nimcache and the Javascript target</source>
          <target state="translated">Nimcache y el objetivo de Javascript</target>
        </trans-unit>
        <trans-unit id="7a7b1200d84cdfcc90e4068e405d16fe626da360" translate="yes" xml:space="preserve">
          <source>Nimcache naming logic</source>
          <target state="translated">La lógica de la denominación de Nimcache</target>
        </trans-unit>
        <trans-unit id="71db390f7498c8607ecf76f70925348383f07f46" translate="yes" xml:space="preserve">
          <source>Nimgrep has particularly good support for Nim's eccentric &lt;em&gt;style insensitivity&lt;/em&gt;. Apart from that it is a generic text manipulation tool.</source>
          <target state="translated">Nimgrep tiene un apoyo particularmente bueno para la &lt;em&gt;insensibilidad del estilo&lt;/em&gt; exc&amp;eacute;ntrico de Nim . Aparte de eso, es una herramienta gen&amp;eacute;rica de manipulaci&amp;oacute;n de texto.</target>
        </trans-unit>
        <trans-unit id="23ef2cadfc8ec56820149ad08675af48b8c2a012" translate="yes" xml:space="preserve">
          <source>Nimgrep is a command line tool for search&amp;amp;replace tasks. It can search for regex or peg patterns and can search whole directories at once. User confirmation for every single replace operation can be requested.</source>
          <target state="translated">Nimgrep es una herramienta de l&amp;iacute;nea de comandos para buscar y reemplazar tareas. Puede buscar patrones de regex o peg y puede buscar directorios completos a la vez. Se puede solicitar la confirmaci&amp;oacute;n del usuario para cada operaci&amp;oacute;n de reemplazo.</target>
        </trans-unit>
        <trans-unit id="b1cf2ee07bf536474f8a79eec9ae5297ea46f5b0" translate="yes" xml:space="preserve">
          <source>Nimsuggest for IDE support</source>
          <target state="translated">Nimsuggest para soporte IDE</target>
        </trans-unit>
        <trans-unit id="74dadd5fc671c88eec7c8cc084b2f4492ce2f149" translate="yes" xml:space="preserve">
          <source>Nimsuggest invocation</source>
          <target state="translated">Invocación de Nimsuggest</target>
        </trans-unit>
        <trans-unit id="5621d2e904ec7f4a1fa59a63968518771b43d445" translate="yes" xml:space="preserve">
          <source>Nimsuggest is part of Nim's core. Build it via:</source>
          <target state="translated">Nimsuggest es parte del núcleo de Nim.Constrúyelo a través de:</target>
        </trans-unit>
        <trans-unit id="b9338b400871e7a753e81682f58f03a8156017e7" translate="yes" xml:space="preserve">
          <source>Nimsuggest output is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">La salida de Nimsuggest siempre se devuelve en l&amp;iacute;neas individuales separadas por caracteres de tabulaci&amp;oacute;n ( &lt;code&gt;\t&lt;/code&gt; ). Los valores de cada columna son:</target>
        </trans-unit>
        <trans-unit id="5372c202a30284da7742441a108b564cdbdf5739" translate="yes" xml:space="preserve">
          <source>Nimsuggest than waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">Nimsuggest que espera a que se procesen las consultas. Una consulta consiste en un &quot;comando&quot; cr&amp;iacute;ptico de 3 letras &lt;code&gt;def&lt;/code&gt; o &lt;code&gt;con&lt;/code&gt; o &lt;code&gt;sug&lt;/code&gt; o &lt;code&gt;use&lt;/code&gt; seguido de una ubicaci&amp;oacute;n. Una ubicaci&amp;oacute;n de consulta consta de:</target>
        </trans-unit>
        <trans-unit id="95165223d15af7cefab907c1e06b8b4044d588d9" translate="yes" xml:space="preserve">
          <source>Nimsuggest will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Nimsuggest siempre responderá con una sola definición o ninguna si no encuentra ningún símbolo válido que coincida con la posición de la consulta.</target>
        </trans-unit>
        <trans-unit id="fb05c02eb40dd8659b5825634b0887e886c359fc" translate="yes" xml:space="preserve">
          <source>No longer actually used</source>
          <target state="translated">Ya no se usa realmente</target>
        </trans-unit>
        <trans-unit id="75b9c1b54338d8b9332efccba32605f983f91029" translate="yes" xml:space="preserve">
          <source>NoDecl pragma</source>
          <target state="translated">NoDeclarar pragmatismo</target>
        </trans-unit>
        <trans-unit id="83c63e0618d33e20ddbbc5fcacaa83b0217e5a9a" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;em&gt;delim&lt;/em&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">Se pueden pasar delimitadores no predeterminados para permitir la iteraci&amp;oacute;n sobre otros tipos de registros de longitud variable &quot;similares a l&amp;iacute;neas&quot;. Pase eat = '\ 0' para estar &lt;em&gt;delimitado&lt;/em&gt; estrictamente . (No se admite el uso de un prefijo opcional igual a '\ 0').</target>
        </trans-unit>
        <trans-unit id="51982015db8c39d38da4e016c910ad96f798d0ca" translate="yes" xml:space="preserve">
          <source>Non-printing characters</source>
          <target state="translated">Caracteres que no se imprimen</target>
        </trans-unit>
        <trans-unit id="418bd9eb8597b90fb89b70c50e626f53d89d17ca" translate="yes" xml:space="preserve">
          <source>Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.</source>
          <target state="translated">Los valores numéricos no puros deben utilizar CamelCase,mientras que los valores numéricos puros deben utilizar PascalCase.</target>
        </trans-unit>
        <trans-unit id="f8d7bfd0d37a23478caf5e01ccd5869426102765" translate="yes" xml:space="preserve">
          <source>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with &lt;code&gt;'&lt;/code&gt;. An example:</source>
          <target state="translated">Los no terminales comienzan con una letra min&amp;uacute;scula, los s&amp;iacute;mbolos de terminales abstractos est&amp;aacute;n en MAY&amp;Uacute;SCULAS. Los s&amp;iacute;mbolos finales textuales (incluidas las palabras clave) se citan con &lt;code&gt;'&lt;/code&gt; . Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="461551ab6e0521d38c563c8b4f15319bef024ec5" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;em&gt;boundChecks&lt;/em&gt; option, those procs will raise an &lt;em&gt;IndexError&lt;/em&gt; on such access. This should not be relied upon, as &lt;em&gt;-d:release&lt;/em&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">Ninguno de los procesos que obtienen un valor individual de la deque se puede usar en una deque vac&amp;iacute;a. Si se compila con la opci&amp;oacute;n &lt;em&gt;boundChecks&lt;/em&gt; , esos procesos generar&amp;aacute;n un &lt;em&gt;IndexError&lt;/em&gt; en dicho acceso. No se debe confiar en esto, ya que &lt;em&gt;-d: release&lt;/em&gt; desactivar&amp;aacute; esas comprobaciones y puede devolver basura o bloquear el programa.</target>
        </trans-unit>
        <trans-unit id="eb4fc459eedc650eb7092ee10047a19689f0d4cd" translate="yes" xml:space="preserve">
          <source>Nonoverloadable builtins</source>
          <target state="translated">Los componentes no sobrecargables</target>
        </trans-unit>
        <trans-unit id="cb66dc661861f381636ef80a030d6e4f15642186" translate="yes" xml:space="preserve">
          <source>Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hiearchy for document TOCs in the final index, and TOC entries found in &lt;code&gt;.nim&lt;/code&gt; files are discarded.</source>
          <target state="translated">Los s&amp;iacute;mbolos normales se agregan al &amp;iacute;ndice con los espacios en blanco circundantes eliminados. Una excepci&amp;oacute;n a esto son las entradas de la tabla de contenido (TOC). Las entradas de TOC se agregan al archivo de &amp;iacute;ndice y su tercera columna tiene tantos espacios de prefijo como su nivel en el TOC (al menos 1 car&amp;aacute;cter). El espacio en blanco del prefijo ayuda a filtrar las entradas de TOC de API o s&amp;iacute;mbolos de texto. Esto es importante porque la cantidad de espacios se usa para replicar la jerarqu&amp;iacute;a de las TOC de los documentos en el &amp;iacute;ndice final, y las entradas de TOC que se encuentran en los archivos &lt;code&gt;.nim&lt;/code&gt; se descartan.</target>
        </trans-unit>
        <trans-unit id="b2311ed7d695294572b2e47ef09cbf7395d919cc" translate="yes" xml:space="preserve">
          <source>Normalize a path.</source>
          <target state="translated">Normalizar un camino.</target>
        </trans-unit>
        <trans-unit id="cc401dc387c902dea14776d7f9bdd3484fd7eecd" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Normaliza la cadena &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2b87a9d966e87007d02f8daaa4c946c260411a9b" translate="yes" xml:space="preserve">
          <source>Not nil annotation</source>
          <target state="translated">No es una anotación nula</target>
        </trans-unit>
        <trans-unit id="8e5e6194b87f5a890650f1c4bfbf0e220197df8e" translate="yes" xml:space="preserve">
          <source>Not nil annotations are not supported.</source>
          <target state="translated">No se admiten anotaciones nulas.</target>
        </trans-unit>
        <trans-unit id="7a8674a1a5764153c229b94ca832a584559616dd" translate="yes" xml:space="preserve">
          <source>Not predicate</source>
          <target state="translated">No es un predicado</target>
        </trans-unit>
        <trans-unit id="3d01d18bf9a6daa3fb19ea60a23f7dd70f8af43a" translate="yes" xml:space="preserve">
          <source>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</source>
          <target state="translated">No es un predicado:Indicar el fracaso si la expresión E coincide con el texto que sigue;de lo contrario,indicar el éxito.No consuma ningún texto.</target>
        </trans-unit>
        <trans-unit id="542c73c0783f6a29758964ce1947b79cd5d16744" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find() proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">No es muy &amp;uacute;til por s&amp;iacute; solo, puede usarlo para crear conjuntos &lt;em&gt;invertidos&lt;/em&gt; para hacer que el proceso &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find ()&lt;/a&gt; encuentre caracteres &lt;strong&gt;no v&amp;aacute;lidos&lt;/strong&gt; en cadenas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="04228ae1050018eb31f9f0fcb6a78ef941137a15" translate="yes" xml:space="preserve">
          <source>Note how the built-in &lt;code&gt;len&lt;/code&gt; proc returns only the array's first dimension length. Another way of defining the &lt;code&gt;LightTower&lt;/code&gt; to better illustrate its nested nature would be to omit the previous definition of the &lt;code&gt;LevelSetting&lt;/code&gt; type and instead write it embedded directly as the type of the first dimension:</source>
          <target state="translated">Observe c&amp;oacute;mo el proceso &lt;code&gt;len&lt;/code&gt; incorporado devuelve solo la longitud de la primera dimensi&amp;oacute;n de la matriz. Otra forma de definir &lt;code&gt;LightTower&lt;/code&gt; para ilustrar mejor su naturaleza anidada ser&amp;iacute;a omitir la definici&amp;oacute;n anterior del tipo &lt;code&gt;LevelSetting&lt;/code&gt; y, en su lugar, escribirla incorporada directamente como el tipo de la primera dimensi&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cd3704db1df15da0eb18abb96f396dc8315f28b4" translate="yes" xml:space="preserve">
          <source>Note how the example contains extra C code to declare the &lt;code&gt;iupdll&lt;/code&gt; symbol in the generated Nim code.</source>
          <target state="translated">Observe c&amp;oacute;mo el ejemplo contiene c&amp;oacute;digo C adicional para declarar el s&amp;iacute;mbolo &lt;code&gt;iupdll&lt;/code&gt; en el c&amp;oacute;digo Nim generado.</target>
        </trans-unit>
        <trans-unit id="ce6b9b4ceabc50bdb117bfb8df4ea521f2a5d675" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getCurrentException&lt;/code&gt; always returns a &lt;code&gt;ref Exception&lt;/code&gt; type. If a variable of the proper type is needed (in the example above, &lt;code&gt;IOError&lt;/code&gt;), one must convert it explicitly:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;getCurrentException&lt;/code&gt; siempre devuelve un tipo de &lt;code&gt;ref Exception&lt;/code&gt; . Si se necesita una variable del tipo adecuado (en el ejemplo anterior, &lt;code&gt;IOError&lt;/code&gt; ), se debe convertir expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="15f8bf07037666cd628faf3d8b1289a1ebbe6888" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import math as m&lt;/code&gt; does not use a different node; rather, we use &lt;code&gt;nnkImportStmt&lt;/code&gt; with &lt;code&gt;as&lt;/code&gt; as an infix operator.</source>
          <target state="translated">Tenga en cuenta que la &lt;code&gt;import math as m&lt;/code&gt; no usa un nodo diferente; m&amp;aacute;s bien, usamos &lt;code&gt;nnkImportStmt&lt;/code&gt; con &lt;code&gt;as&lt;/code&gt; que un operador infijo.</target>
        </trans-unit>
        <trans-unit id="9b5663a783c31085b10a438aaa39d48ac8ef1674" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;system.finished&lt;/code&gt; is error prone to use because it only returns &lt;code&gt;true&lt;/code&gt; one iteration after the iterator has finished:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;system.finished&lt;/code&gt; es propenso a errores porque solo devuelve &lt;code&gt;true&lt;/code&gt; una iteraci&amp;oacute;n despu&amp;eacute;s de que el iterador haya finalizado:</target>
        </trans-unit>
        <trans-unit id="d65e48edf1a92ed7ba69b341dc76ceb955ed905a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el &lt;code&gt;using&lt;/code&gt; no se aplica a la &lt;code&gt;template&lt;/code&gt; ya que los par&amp;aacute;metros de la plantilla sin tipo son los predeterminados del tipo &lt;code&gt;system.untyped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eaa79a5d51a878bd30d77cb48d9cf5f64b35ea7" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que los literales de cadena sin formato extendidos de Nim admiten la sintaxis &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; como forma abreviada de &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66958a893582569a32abe154668c902b04b269b9" translate="yes" xml:space="preserve">
          <source>Note that a duration can be negative, so even if &lt;code&gt;a &amp;lt; b&lt;/code&gt; is true &lt;code&gt;a&lt;/code&gt; might represent a larger absolute duration. Use &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; to compare the absolute duration.</source>
          <target state="translated">Tenga en cuenta que una duraci&amp;oacute;n puede ser negativa, por lo que incluso si &lt;code&gt;a &amp;lt; b&lt;/code&gt; es verdadera, &lt;code&gt;a&lt;/code&gt; podr&amp;iacute;a representar una duraci&amp;oacute;n absoluta mayor. Utilice &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; para comparar la duraci&amp;oacute;n absoluta.</target>
        </trans-unit>
        <trans-unit id="31a61e95866e9147c08e9c2d0fd1b10e87385ea4" translate="yes" xml:space="preserve">
          <source>Note that an explicit array constructor passed to a &lt;code&gt;varargs&lt;/code&gt; parameter is not wrapped in another implicit array construction:</source>
          <target state="translated">Tenga en cuenta que un constructor de matriz expl&amp;iacute;cito pasado a un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; no est&amp;aacute; envuelto en otra construcci&amp;oacute;n de matriz impl&amp;iacute;cita:</target>
        </trans-unit>
        <trans-unit id="580208a43972b50356da5b1da0797b119e251075" translate="yes" xml:space="preserve">
          <source>Note that at the moment the word &lt;code&gt;proc&lt;/code&gt; is returned for the signature of the found method instead of the expected &lt;code&gt;method&lt;/code&gt;. This may change in the future.</source>
          <target state="translated">Tenga en cuenta que en este momento se devuelve la palabra &lt;code&gt;proc&lt;/code&gt; para la firma del m&amp;eacute;todo encontrado en lugar del &lt;code&gt;method&lt;/code&gt; esperado . Esto puede cambiar en el futuro.</target>
        </trans-unit>
        <trans-unit id="fe89c735f73e47df7589d2ce0f730288a5b272a5" translate="yes" xml:space="preserve">
          <source>Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will &lt;em&gt;unroll&lt;/em&gt; the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! For safety use side-effect free procedures if making multiple assignments.</source>
          <target state="translated">Tenga en cuenta que declarar m&amp;uacute;ltiples variables con una sola asignaci&amp;oacute;n que llama a un procedimiento puede tener resultados inesperados: el compilador &lt;em&gt;desenrollar&amp;aacute;&lt;/em&gt; las asignaciones y terminar&amp;aacute; llamando al procedimiento varias veces. Si el resultado del procedimiento depende de los efectos secundarios, &amp;iexcl;sus variables pueden terminar teniendo valores diferentes! Por seguridad, utilice procedimientos sin efectos secundarios si realiza varias asignaciones.</target>
        </trans-unit>
        <trans-unit id="f0fc07cec95ec5e1fead7b4c0cc4bdbd5f963690" translate="yes" xml:space="preserve">
          <source>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</source>
          <target state="translated">Obsérvese que deben existir el segundo o el tercer parámetro (o ambos)arriba mencionados,ya que el compilador necesita conocer el tipo de alguna manera (que puede deducir de la asignación dada).</target>
        </trans-unit>
        <trans-unit id="3974a69d8025c1886c72445a8fb4b0c0716b4564" translate="yes" xml:space="preserve">
          <source>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</source>
          <target state="translated">Obsérvese que para los sistemas con una pila continua (que es lo que tienen la mayoría de los sistemas)la comprobación de si el árbitro está en la pila es muy barata (sólo dos comparaciones).</target>
        </trans-unit>
        <trans-unit id="e095193050971ff047ad4d5c8afbbc2efec37383" translate="yes" xml:space="preserve">
          <source>Note that in the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because it makes more sense for them to use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">Tenga en cuenta que en el ejemplo los constructores &lt;code&gt;newLit&lt;/code&gt; y &lt;code&gt;newPlus&lt;/code&gt; son procs porque tiene m&amp;aacute;s sentido que usen enlaces est&amp;aacute;ticos, pero &lt;code&gt;eval&lt;/code&gt; es un m&amp;eacute;todo porque requiere enlaces din&amp;aacute;micos.</target>
        </trans-unit>
        <trans-unit id="11be0dfde35904fa7f02afe90c20970ebac48dfb" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">Tenga en cuenta que no todos los &lt;code&gt;nnkTypeDef&lt;/code&gt; utilizan &lt;code&gt;nnkIdent&lt;/code&gt; como su par&amp;aacute;metro. Uno de los usos m&amp;aacute;s comunes de las declaraciones de tipos es trabajar con objetos.</target>
        </trans-unit>
        <trans-unit id="0224a1f68a8585cd4a55cb358bf685741b3afb31" translate="yes" xml:space="preserve">
          <source>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</source>
          <target state="translated">Tenga en cuenta que los valores octales de 100 o más no deben ser introducidos por un cero inicial,porque nunca se leen más de tres dígitos octales.</target>
        </trans-unit>
        <trans-unit id="cb0c14568cc44b3aa6b93616a9638e1e67aa608b" translate="yes" xml:space="preserve">
          <source>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</source>
          <target state="translated">Tenga en cuenta que,como se trata de un iterador,no debe modificar la cadena sobre la que está iterando:podrían ocurrir cosas malas.</target>
        </trans-unit>
        <trans-unit id="5e26b1561a3f022726ef326aaca35071eca0d805" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Time&lt;/code&gt; argument does not represent a point in time, it represent a local time! E.g if &lt;code&gt;adjTime&lt;/code&gt; is &lt;code&gt;fromUnix(0)&lt;/code&gt;, it should be interpreted as 1970-01-01T00:00:00 in the &lt;code&gt;zone&lt;/code&gt; timezone, not in UTC.</source>
          <target state="translated">Tenga en cuenta que el argumento &lt;code&gt;Time&lt;/code&gt; no representa un punto en el tiempo, &amp;iexcl;representa una hora local! Por ejemplo, si &lt;code&gt;adjTime&lt;/code&gt; es &lt;code&gt;fromUnix(0)&lt;/code&gt; , debe interpretarse como 1970-01-01T00: 00: 00 en la &lt;code&gt;zone&lt;/code&gt; horaria, no en UTC.</target>
        </trans-unit>
        <trans-unit id="ff3153be7f62193c7a012288373ef96e64821a33" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;importcpp&lt;/code&gt; variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</source>
          <target state="translated">Tenga en cuenta que la variante &lt;code&gt;importcpp&lt;/code&gt; para procs usa un lenguaje de patrones algo cr&amp;iacute;ptico para una m&amp;aacute;xima flexibilidad:</target>
        </trans-unit>
        <trans-unit id="f79f9b3f84579ddfcfc49f356b7732e51770554f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;jsondoc&lt;/code&gt; command outputs it's JSON without pretty-printing it, while &lt;code&gt;jsondoc0&lt;/code&gt; outputs pretty-printed JSON.</source>
          <target state="translated">Tenga en cuenta que el comando &lt;code&gt;jsondoc&lt;/code&gt; genera su JSON sin tener una impresi&amp;oacute;n bonita, mientras que &lt;code&gt;jsondoc0&lt;/code&gt; genera JSON con una impresi&amp;oacute;n bonita.</target>
        </trans-unit>
        <trans-unit id="0657a4b90e474cfb90775d71e0fec2c9d65f4786" translate="yes" xml:space="preserve">
          <source>Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">Tenga en cuenta que la codificación no puede ser cambiada una vez que se ha establecido.Según la documentación de SQLite3,cualquier intento de cambiar la codificación después de que se cree la base de datos será ignorado silenciosamente.</target>
        </trans-unit>
        <trans-unit id="9cb042b8b29c59f41b3cd0e948e779e25db65a35" translate="yes" xml:space="preserve">
          <source>Note that the module name is still &lt;code&gt;strutils&lt;/code&gt; and not &lt;code&gt;lib/pure/strutils&lt;/code&gt; and so one &lt;strong&gt;cannot&lt;/strong&gt; do:</source>
          <target state="translated">Tenga en cuenta que el nombre del m&amp;oacute;dulo sigue siendo &lt;code&gt;strutils&lt;/code&gt; y no &lt;code&gt;lib/pure/strutils&lt;/code&gt; , por lo que &lt;strong&gt;no se puede&lt;/strong&gt; hacer:</target>
        </trans-unit>
        <trans-unit id="343c37cc8e2a037df9dff1a349a478f071828d8b" translate="yes" xml:space="preserve">
          <source>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</source>
          <target state="translated">Observe que el lenguaje de patrones naturalmente también cubre las capacidades de sobrecarga del operador de C++:</target>
        </trans-unit>
        <trans-unit id="8cde912a6f95d6bc0c0ad134a4919451e220d036" translate="yes" xml:space="preserve">
          <source>Note that the regular expression does not behave as intended either: in the example &lt;code&gt;*&lt;/code&gt; should not be greedy, so &lt;code&gt;\[.*?\]&lt;/code&gt; should be used instead.</source>
          <target state="translated">Tenga en cuenta que la expresi&amp;oacute;n regular tampoco se comporta como se esperaba: en el ejemplo &lt;code&gt;*&lt;/code&gt; no deber&amp;iacute;a ser codicioso, por lo que se deber&amp;iacute;a utilizar &lt;code&gt;\[.*?\]&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="f120496e6d813c76cb6c4055f029e22950f8809c" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be &lt;code&gt;nil&lt;/code&gt;. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">Tenga en cuenta que la secuencia se rellenar&amp;aacute; con entradas cero, lo que puede ser un problema para las secuencias que contienen cadenas, ya que su valor ser&amp;aacute; &lt;code&gt;nil&lt;/code&gt; . Despu&amp;eacute;s de la creaci&amp;oacute;n de la secuencia, debe asignar entradas a la secuencia en lugar de agregarlas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="1afc5e4454ca57a472753d975721911248348abc" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;em&gt;degToRad&lt;/em&gt; and &lt;em&gt;radToDeg&lt;/em&gt; provide conversion between radians and degrees.</source>
          <target state="translated">Tenga en cuenta que las funciones trigonom&amp;eacute;tricas operan naturalmente en radianes. Las funciones auxiliares &lt;em&gt;degToRad&lt;/em&gt; y &lt;em&gt;radToDeg&lt;/em&gt; proporcionan conversi&amp;oacute;n entre radianes y grados.</target>
        </trans-unit>
        <trans-unit id="b39e62dfdcac76acc3788b0504467d241681c022" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="translated">Tenga en cuenta que puede haber excepciones a estas reglas. Nim, siendo tan flexible como es, habr&amp;aacute; partes de esta gu&amp;iacute;a de estilo que no tienen sentido en ciertos contextos. Adem&amp;aacute;s, as&amp;iacute; como &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;la gu&amp;iacute;a de estilo de Python&lt;/a&gt; cambia con el tiempo, esta gu&amp;iacute;a de estilo tambi&amp;eacute;n lo har&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="0fed77603f9454dbdef2e75534af23ed17061d9e" translate="yes" xml:space="preserve">
          <source>Note that this is a &lt;em&gt;runtime&lt;/em&gt; call and using &lt;code&gt;quit&lt;/code&gt; inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; or &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; pragmas.</source>
          <target state="translated">Tenga en cuenta que esta es una llamada en &lt;em&gt;tiempo de ejecuci&amp;oacute;n&lt;/em&gt; y el uso de &lt;code&gt;quit&lt;/code&gt; dentro de una macro no tendr&amp;aacute; ning&amp;uacute;n efecto en el tiempo de compilaci&amp;oacute;n. Si necesita detener el compilador dentro de una macro, use los pragmas de &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; o &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04eea85d84506e2be9f7ff640da1764e6c3b0050" translate="yes" xml:space="preserve">
          <source>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</source>
          <target state="translated">Nótese que esta es básicamente la única forma de inferencia de tipo que existe en Nim:es un buen compromiso entre la brevedad y la legibilidad.</target>
        </trans-unit>
        <trans-unit id="ca57587cd09e4fd62d9d47bd97a7a8675351ea8c" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</source>
          <target state="translated">Tengan en cuenta que este pragmatismo es un nombre poco apropiado:Otros backends proporcionan la misma característica bajo el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="6aa0aaed3cc81e0439834c7c529aa1845e5383d7" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name. Also, if one is interfacing with C++ the &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; and interfacing with Objective-C the &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC pragma&lt;/a&gt; can be used.</source>
          <target state="translated">Tenga en cuenta que este pragma es un nombre poco apropiado: otros backends proporcionan la misma funci&amp;oacute;n con el mismo nombre. Adem&amp;aacute;s, si uno est&amp;aacute; interactuando con C ++, se puede &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;utilizar el pragma ImportCpp&lt;/a&gt; y con Objective-C, se puede utilizar el &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;pragma ImportObjC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5d063d7e7c89bcb1be31e9838c1418c3a823324" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">Tenga en cuenta que esto requiere que los tipos de entrada y salida sean los mismos, ya que se modifican en el lugar. La funci&amp;oacute;n de par&amp;aacute;metro toma un par&amp;aacute;metro de tipo &lt;code&gt;var T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd22634c739d8b9963ba6240e6f789a4901df14" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">Tenga en cuenta que esto requiere que los tipos de entrada y salida sean los mismos, ya que se modifican en el lugar. La funci&amp;oacute;n de par&amp;aacute;metro toma y devuelve una variable de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e73723c67698a4db4dbcdaa04c4f3387732c63" translate="yes" xml:space="preserve">
          <source>Note that this version of &lt;code&gt;map&lt;/code&gt; requires your input and output types to be the same, since they are modified in-place.</source>
          <target state="translated">Tenga en cuenta que esta versi&amp;oacute;n del &lt;code&gt;map&lt;/code&gt; a requiere que los tipos de entrada y salida sean los mismos, ya que se modifican en el lugar.</target>
        </trans-unit>
        <trans-unit id="35a43adebbe7d9517e28187d2c67478e70dbaf9e" translate="yes" xml:space="preserve">
          <source>Note that type inference works for parameters with default values; there is no need to write &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt;, for example.</source>
          <target state="translated">Tenga en cuenta que la inferencia de tipos funciona para par&amp;aacute;metros con valores predeterminados; no es necesario escribir &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">Obsérvese que,a menos que se defina un ancho de campo mínimo,el ancho de campo será siempre del mismo tamaño que los datos para rellenarlo,por lo que la opción de alineación no tiene sentido en este caso.</target>
        </trans-unit>
        <trans-unit id="a4f6df5cd8b79acdb0c70f5d30510d6e8cdfa162" translate="yes" xml:space="preserve">
          <source>Note that unordered or ordered choice operators (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) are not implemented.</source>
          <target state="translated">Tenga en cuenta que los operadores de elecci&amp;oacute;n ordenados o desordenados ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ) no est&amp;aacute;n implementados.</target>
        </trans-unit>
        <trans-unit id="1f37b4c7971dff9f25702efc2db169764ea60985" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;em&gt;31 October&lt;/em&gt; will result in &lt;em&gt;31 November&lt;/em&gt;, which will overflow and result in &lt;em&gt;1 December&lt;/em&gt;.</source>
          <target state="translated">Tenga en cuenta que al agregar meses, se permite el desbordamiento del d&amp;iacute;a del mes. Esto significa que si el mes resultante no tiene suficientes d&amp;iacute;as, el mes se incrementar&amp;aacute; y el d&amp;iacute;a del mes se establecer&amp;aacute; en el n&amp;uacute;mero de d&amp;iacute;as desbordados. Entonces, agregar un mes al &lt;em&gt;31 de octubre&lt;/em&gt; dar&amp;aacute; como resultado el &lt;em&gt;31 de noviembre&lt;/em&gt; , que se desbordar&amp;aacute; y dar&amp;aacute; como resultado el &lt;em&gt;1 de diciembre&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93f7073771e81c9dae2114aa3af0598ed46cf0ad" translate="yes" xml:space="preserve">
          <source>Note that with multiple infix operators, the command is parsed by operator precedence.</source>
          <target state="translated">Tenga en cuenta que con múltiples operadores de infijo,el comando es analizado por la precedencia del operador.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
