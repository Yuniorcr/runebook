<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="c4af36b03e871c9cae4428903b9bca8534e6953e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function is not safe for use.</source>
          <target state="translated">&lt;strong&gt;En desuso desde la versi&amp;oacute;n 0.9.2&lt;/strong&gt; : esta funci&amp;oacute;n no es segura para su uso.</target>
        </trans-unit>
        <trans-unit id="fface47b088c778a2f4e77c02bf19ee55d18a8e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;fromWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso:&lt;/strong&gt; use &lt;code&gt;fromWinTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="06ec99b3afe2ae2cbe0edda32125eccea758f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="3a884be761dae54201f8aa530278b417918acce3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;em&gt;hasKey&lt;/em&gt; instead.</source>
          <target state="translated">&lt;strong&gt;En desuso:&lt;/strong&gt; use &lt;em&gt;hasKey&lt;/em&gt; en &lt;em&gt;su&lt;/em&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="a22c0c29442195e4011e17d60edeee2f5d85fcea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</source>
          <target state="translated">&lt;strong&gt;Descargo de responsabilidad&lt;/strong&gt; : este c&amp;oacute;digo no est&amp;aacute; bien probado, puede ser muy inseguro y propenso a vulnerabilidades de seguridad.</target>
        </trans-unit>
        <trans-unit id="6ffe4dc5c4fc52ea3ea1e3a20dd64567380feece" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use this module for cryptographic purposes!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;No utilice este m&amp;oacute;dulo con fines criptogr&amp;aacute;ficos!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f928ed32bee5c29af52b00bc30f99ce156242335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Docstring&lt;/strong&gt; : siempre la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="d4209dbb40d9185067bcb8ce189cd1c6eed7f25e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: docstring if available.</source>
          <target state="translated">&lt;strong&gt;Docstring&lt;/strong&gt; : docstring si est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="c0dd9bb9e04f64f6f60578b64bf64464fec710d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error&lt;/strong&gt; - error conditions that the application can recover from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15f078e82171a8efcc97da8037079287adaefb70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fatal&lt;/strong&gt; - fatal errors that prevent the application from continuing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e5c6a20cafb8203519ae745e546e8bb3f10e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : siempre la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="160ef9d36bed422272b88e68bd931cde20c08000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: enum type grouping other enum fields.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : tipo de enumeraci&amp;oacute;n que agrupa otros campos de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="be7ebe20c5b6aef98f77a13140c9b09bb67359f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the iterator including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma del iterador incluido el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="c6c20f7dbb204753d2338c8585a984c7c7fa8c25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the macro including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma de la macro, incluido el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="b6771fb30bab96fd8cf5d95cfd5b7411f13b3c15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the method including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma del m&amp;eacute;todo, incluido el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="8779f27a30500300592c1fbc44c5a869259d7284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the proc including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma del proceso, incluido el tipo de devoluci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5b4c52d33a04c0f32a87d9b5783e815726a1d81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the template including return type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : firma de la plantilla, incluido el tipo de devoluci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4dfd102fd6fbe96ece65dd9c1d384e0f16912006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the const value.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de valor constante.</target>
        </trans-unit>
        <trans-unit id="63fb555122e12cadcd219b4c04854752ec0ed9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the let variable.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de la variable let.</target>
        </trans-unit>
        <trans-unit id="20edb7c031a399a27ff6ff092cecc38f0cd151a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the parameter.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="d1c0d7dfb4af3e8e26314132e3d53473279ebfe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the result.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="c558e48e401e6265a17ebeab90f8b20f1f7e1e47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the var.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo de var.</target>
        </trans-unit>
        <trans-unit id="9384cc6e440487319d842110001333299d831093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : el tipo.</target>
        </trans-unit>
        <trans-unit id="329b7e3326c98503c949ca9d39330b0e1c6794bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: type of the var.</source>
          <target state="translated">&lt;strong&gt;Cuarta columna&lt;/strong&gt; : tipo de var.</target>
        </trans-unit>
        <trans-unit id="978f10cfc82df92effeee967159555f49c21c819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unchecked arrays and there should be an explicit annotation of how the GC is to determine the runtime size of the array.</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : la memoria GC'ed debe permitirse en matrices no verificadas y debe haber una anotaci&amp;oacute;n expl&amp;iacute;cita de c&amp;oacute;mo la GC debe determinar el tama&amp;ntilde;o de tiempo de ejecuci&amp;oacute;n de la matriz.</target>
        </trans-unit>
        <trans-unit id="150871409dc1ef45a59e74d4be5900fd8cf45ddc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unions and the GC should scan unions conservatively.</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : la memoria de GC deber&amp;iacute;a permitirse en los sindicatos y el GC deber&amp;iacute;a escanear los sindicatos de manera conservadora.</target>
        </trans-unit>
        <trans-unit id="5f1330a349c9dedfd2b8b17d35746d232592d00d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: The &lt;code&gt;acyclic&lt;/code&gt; pragma may become a property of a &lt;code&gt;ref&lt;/code&gt; type:</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : el pragma &lt;code&gt;acyclic&lt;/code&gt; puede convertirse en una propiedad de un tipo de &lt;code&gt;ref&lt;/code&gt; erencia :</target>
        </trans-unit>
        <trans-unit id="9a4c8f25dfeefcc10f7c8b1211a9ccc00288df9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: Using GC'ed memory in packed pragma will result in a static error. Usage with inheritance should be defined and documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d19ae59ec3e06e328ace922bad09261db8a6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: Using GC'ed memory in packed pragma will result in compile-time error. Usage with inheritance should be defined and documented.</source>
          <target state="translated">&lt;strong&gt;Direcciones futuras&lt;/strong&gt; : el uso de memoria GC'ed en pragma empaquetado dar&amp;aacute; como resultado un error en tiempo de compilaci&amp;oacute;n. Se debe definir y documentar el uso con herencia.</target>
        </trans-unit>
        <trans-unit id="02ec565bd2b833f4e079a16ceaa88628a37485b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hint:&lt;/strong&gt; With &lt;code&gt;--hint[codeBegin]:on&lt;/code&gt; or &lt;code&gt;--verbosity:2&lt;/code&gt; (or higher) while compiling or &lt;code&gt;nim check&lt;/code&gt;, Nim lists the processed code after each filter application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59417140c3fc6f7e2c17f2c777a2f509360e62e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hint:&lt;/strong&gt; With &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (or higher) Nim lists the processed code after each filter application.</source>
          <target state="translated">&lt;strong&gt;Pista:&lt;/strong&gt; Con &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (o superior) Nim enumera el c&amp;oacute;digo procesado despu&amp;eacute;s de cada aplicaci&amp;oacute;n de filtro.</target>
        </trans-unit>
        <trans-unit id="b2b402acffec017e9e1d08158fe3bc6834d4ccb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If duplicate keys were added, this may need to be called multiple times.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3461ae9a0b84542c802ba567999b3faa5afdc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a3d06a2ac66b0299dc868e1e5f195e4b08f76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Info&lt;/strong&gt; - anything associated with normal operation and without any particular importance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00641ee780415a4fe5e346e4872088e6dc38287d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JS note:&lt;/strong&gt;&lt;code&gt;buffer&lt;/code&gt; is treated as a &lt;code&gt;ptr string&lt;/code&gt; and read between &lt;code&gt;0..&amp;lt;bufLen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0570a04d10f01c787204df1793c74a673b8d7e99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JS note:&lt;/strong&gt;&lt;code&gt;buffer&lt;/code&gt; is treated as a &lt;code&gt;ptr string&lt;/code&gt; and written to between &lt;code&gt;0..&amp;lt;bufLen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f555042911466061dac7f6fee69c396fc92108dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Known limitations:&lt;/strong&gt; In the JavaScript target, global variables using the &lt;code&gt;codegenDecl&lt;/code&gt; pragma will be re-initialized on each reload. Please guard the initialization with a &lt;em&gt;once&lt;/em&gt; block to work-around this.</source>
          <target state="translated">&lt;strong&gt;Limitaciones conocidas:&lt;/strong&gt; en el destino de JavaScript, las variables globales que utilizan el pragma &lt;code&gt;codegenDecl&lt;/code&gt; se reinicializar&amp;aacute;n en cada recarga. Por favor, guardar la inicializaci&amp;oacute;n de una &lt;em&gt;vez&lt;/em&gt; el bloque de trabajo en torno a esto.</target>
        </trans-unit>
        <trans-unit id="5911ff88eb68bebee7d71b3a0d7b01ad6e208cea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Nim currently does not detect these!</source>
          <target state="translated">&lt;strong&gt;NOTA&lt;/strong&gt; : &amp;iexcl;Nim actualmente no los detecta!</target>
        </trans-unit>
        <trans-unit id="3082097f9021d41c1a42dcf5d23ffc66ad1979a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The behaviour might change in future versions as it is not clear what &quot;&lt;em&gt;wild&lt;/em&gt; HTML the real world uses&quot; really implies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="140047e96ac4c58f01e73270812c9a51624feb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; At the moment hot code reloading is supported only in JavaScript projects.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Por el momento, la recarga de c&amp;oacute;digo activo solo se admite en proyectos JavaScript.</target>
        </trans-unit>
        <trans-unit id="16f3b81d60ef5438aad137b2307d09cc9f71b096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Breaking the &lt;code&gt;fastRows()&lt;/code&gt; iterator during a loop will cause the next database query to raise a &lt;code&gt;DbError&lt;/code&gt; exception &lt;code&gt;unable to close due to ...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e6136be66e5bf74c87880dc268f56f9861dc81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Channels are designed for the &lt;code&gt;Thread&lt;/code&gt; type. They are unstable when used with &lt;code&gt;spawn&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9dcf701f94adaa5a4d2bbfbd098d67fc7ddc8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Channels cannot be passed between threads. Use globals or pass them by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ae990ae2793f586640459d0853bfff28f07ff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Comment statement will be ignored.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Se ignorar&amp;aacute; la declaraci&amp;oacute;n de comentario.</target>
        </trans-unit>
        <trans-unit id="6c08afa96cbaa181efd240626cdc35ba72be35dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Does not work for NimScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b69032440a3760c06332bd2946743c6dc04769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Each delegate has a task associated with it. This gets called after each select() call, if you set timeout to &lt;code&gt;-1&lt;/code&gt; the tasks will only be executed after one or more file descriptors becomes readable or writeable.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Cada delegado tiene una tarea asociada. Esto se llama despu&amp;eacute;s de cada llamada select (), si establece el tiempo de espera en &lt;code&gt;-1&lt;/code&gt; , las tareas solo se ejecutar&amp;aacute;n despu&amp;eacute;s de que uno o m&amp;aacute;s descriptores de archivo se vuelvan legibles o escribibles.</target>
        </trans-unit>
        <trans-unit id="7f378938581797df4e574611774903888f75a977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For leap years, start date is assumed to be 1 AD. counts the number of leap years up to January 1st of a given year. Keep in mind that if specified year is a leap year, the leap day has not happened before January 1st of that year.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Para los a&amp;ntilde;os bisiestos, se supone que la fecha de inicio es 1 d.C. cuenta el n&amp;uacute;mero de a&amp;ntilde;os bisiestos hasta el 1 de enero de un a&amp;ntilde;o determinado. Tenga en cuenta que si el a&amp;ntilde;o especificado es bisiesto, el d&amp;iacute;a bisiesto no ocurri&amp;oacute; antes del 1 de enero de ese a&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="02ebb094e834ec378d8bae7a318f260891645141" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you need a version of &lt;code&gt;exec&lt;/code&gt; that returns the exit code and text output of the command, you can use &lt;a href=&quot;system#gorgeEx,string,string,string&quot;&gt;system.gorgeEx&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8234ec32d945f2b0f03239d1b0eaae84f70df2af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to provide async ability to your module please do not use the &lt;code&gt;Delegate&lt;/code&gt; object, instead use &lt;code&gt;AsyncSocket&lt;/code&gt;. It is possible that in the future this type's fields will not be exported therefore breaking your code.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Si desea proporcionar capacidad as&amp;iacute;ncrona a su m&amp;oacute;dulo, no use el objeto &lt;code&gt;Delegate&lt;/code&gt; , en su lugar use &lt;code&gt;AsyncSocket&lt;/code&gt; . Es posible que en el futuro los campos de este tipo no se exporten y por lo tanto se rompa el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e85ae0701fc3f9c17e3733cbce315301d09131af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/highlite&lt;/code&gt; to use this module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843c2b3ee7e629c2441a4dd24c956ffe976de720" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/rst&lt;/code&gt; to use this module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76b1b31d6a0fcc3a95e3171e746bb3a3ca3998e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/rstast&lt;/code&gt; to use this module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ab66a9d8c71c977571af7a1c3cae030aeb63a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/rstgen&lt;/code&gt; to use this module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2474d53657db59741f090272c72d5eb8c30f27da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;std/sha1&lt;/code&gt; to use this module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6066c5e1dbc1c07031004fde7afa16f36e8afe0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Most modules have tasks which need to be ran regularly, this is why you should not call &lt;code&gt;poll&lt;/code&gt; with a infinite timeout, or even a very long one. In most cases the default timeout is fine.</source>
          <target state="translated">&lt;strong&gt;Nota: la&lt;/strong&gt; mayor&amp;iacute;a de los m&amp;oacute;dulos tienen tareas que deben ejecutarse con regularidad, por eso no debe llamar a &lt;code&gt;poll&lt;/code&gt; con un tiempo de espera infinito, o incluso uno muy largo. En la mayor&amp;iacute;a de los casos, el tiempo de espera predeterminado est&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="197712af8474ad67fa3deb053cf4d10c7db7a328" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add59de22ea186db4c63840851e7cf0d92d2b537" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend. Use &lt;a href=&quot;#peekStr,Stream,int&quot;&gt;peekStr&lt;/a&gt; for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a295c2c96fbc8a7f45e187ef6bfaedb02e5b3937" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend. Use &lt;a href=&quot;#readStr,Stream,int&quot;&gt;readStr&lt;/a&gt; for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61879707f76ebc05d6254a26c8af524bb7cf85ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend. Use &lt;a href=&quot;#write,Stream,string&quot;&gt;write(Stream, string)&lt;/a&gt; for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5f90a42c28a76d9ac73c0f1962a68a45b56af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; On the JS backend this currently counts UTF-16 code points instead of bytes at runtime (not at compile time). For now, if you need the byte length of the UTF-8 encoding, convert to string with &lt;code&gt;$&lt;/code&gt; first then call &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f3a93e6b5389328dfe4d50a2a108b926a73e41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Only error and fatal messages will cause the output buffer to be flushed immediately. Use the &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; to flush the buffer manually if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed2d4766f9364afd4bd59bed6474d34be992a49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Only the &lt;code&gt;connection&lt;/code&gt; parameter is used for &lt;code&gt;sqlite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e05f6628a4d37e39425527e3fad105da1952478" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Starting from Nim 0.20, to use multi-methods one must explicitly pass &lt;code&gt;--multimethods:on&lt;/code&gt; when compiling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f92aa536204e6eaef641a2e69451b390e74e1bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;em&gt;project file name&lt;/em&gt; is the name of the &lt;code&gt;.nim&lt;/code&gt; file that is passed as a command line argument to the compiler.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; El &lt;em&gt;nombre del archivo del proyecto&lt;/em&gt; es el nombre del archivo &lt;code&gt;.nim&lt;/code&gt; que se pasa como argumento de l&amp;iacute;nea de comando al compilador.</target>
        </trans-unit>
        <trans-unit id="bde269deb8be545b32a64412683066eff50f652a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;em&gt;project file name&lt;/em&gt; is the name of the &lt;code&gt;.nim&lt;/code&gt; file that is passed as a command-line argument to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a72b0f5ef54ecdf16cb26a40bdbef5872800692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The API of FutureStream is still new and so has a higher likelihood of changing in the future.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; La API de FutureStream a&amp;uacute;n es nueva y, por lo tanto, tiene una mayor probabilidad de cambiar en el futuro.</target>
        </trans-unit>
        <trans-unit id="fe5b130db131453d8df37e590c01fe6f08bec9e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The behaviour of this procedure changed in version 0.14.0. To get a list of usages and to restore the old behaviour of this procedure, compile with the &lt;code&gt;-d:nimJsonGet&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; El comportamiento de este procedimiento cambi&amp;oacute; en la versi&amp;oacute;n 0.14.0. Para obtener una lista de usos y restaurar el antiguo comportamiento de este procedimiento, compile con el indicador &lt;code&gt;-d:nimJsonGet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b68055c0d51d611257c884fc1743a259d12fc766" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of message passing does not work with cyclic data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c072da5e00ce440c3b93018b2a1ef17e9ee5503c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of message passing does not work with cyclic data structures. &lt;strong&gt;Note:&lt;/strong&gt; Channels cannot be passed between threads. Use globals or pass them by &lt;em&gt;ptr&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; La implementaci&amp;oacute;n actual del paso de mensajes no funciona con estructuras de datos c&amp;iacute;clicas. &lt;strong&gt;Nota: los&lt;/strong&gt; canales no se pueden pasar entre hilos. Utilice globales o &lt;em&gt;p&amp;aacute;selos&lt;/em&gt; por &lt;em&gt;ptr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c053963c70f97a8b2121caf302c6833bc53f2f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b999dbe7ed39e219e124bd0949367e2e3d56fe13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The resulting &lt;code&gt;XmlNode&lt;/code&gt; already uses the &lt;code&gt;clientData&lt;/code&gt; field, so it cannot be used by clients of this library.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; El &lt;code&gt;XmlNode&lt;/code&gt; resultante ya usa el campo &lt;code&gt;clientData&lt;/code&gt; , por lo que los clientes de esta biblioteca no pueden usarlo.</target>
        </trans-unit>
        <trans-unit id="eb469a558a1fb80f9ffa7a37d87dd2f9adc314d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The server may return multiple lines of coded replies.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; el servidor puede devolver varias l&amp;iacute;neas de respuestas codificadas.</target>
        </trans-unit>
        <trans-unit id="0d1eacb2a91de8906a2993f50f4d1523095b2af2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; There are no postfix operators in Nim. However, the &lt;code&gt;nnkPostfix&lt;/code&gt; node is used for the &lt;em&gt;asterisk export marker&lt;/em&gt;&lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; No hay operadores de sufijo en Nim. Sin embargo, el nodo &lt;code&gt;nnkPostfix&lt;/code&gt; se utiliza para el &lt;em&gt;marcador de exportaci&amp;oacute;n de asterisco &lt;/em&gt; &lt;code&gt;*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f905a6d385133393b2c96347260edc54f46375a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This does not preserve the new line characters used in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esto no conserva los caracteres de nueva l&amp;iacute;nea utilizados en &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7811fa53cf7abdc675dfee2447ec973dd431ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is not supported on &lt;code&gt;Windows&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; esta funci&amp;oacute;n no es compatible con &lt;code&gt;Windows&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10e606a3da78b8e2b189b92aa03f1f5e54c1d549" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is supported only by BSD and MacOSX.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esta funci&amp;oacute;n solo es compatible con BSD y MacOSX.</target>
        </trans-unit>
        <trans-unit id="cc104a0e857b282ec998816c0f3e015bee2d1e8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is an experimental feature. It can be enabled with &lt;code&gt;{.experimental: &quot;notnil&quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a504100a18ce5297ff0a5435681c490ac8437f44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not very efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60296ba87e29cbb2d2d722997e0bc1d53551519" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This logger is not available for the JavaScript backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24c06d6eed7edbd4cef00490b4db7c0ca199c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module currently only supports select(), this is limited by FD_SETSIZE, which is usually 1024. So you may only be able to use 1024 sockets at a time.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Este m&amp;oacute;dulo actualmente solo admite select (), esto est&amp;aacute; limitado por FD_SETSIZE, que generalmente es 1024. Por lo tanto, es posible que solo pueda usar 1024 sockets a la vez.</target>
        </trans-unit>
        <trans-unit id="be757c0b40131a488a140d8d6a5f654644bde753" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available for SSL sockets.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; este proceso no est&amp;aacute; disponible para sockets SSL.</target>
        </trans-unit>
        <trans-unit id="bada7c4bc2eb5a9723fa1a4e5f0977c09eb2e93e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available for the JavaScript backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72097e11d6435758e6d11a17ddc9ef4aaa3827e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available in the JavaScript backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78137b9e08d95e0c1988f940939d1041367f9b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This uses different hashing algorithm than &lt;code&gt;hash(string)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b46072c825ede32e475a77de0b13f39275d7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This will allocate a new &lt;code&gt;Mimetypes&lt;/code&gt; database every time you call it, you can pass your own via the &lt;code&gt;mimeDb&lt;/code&gt; parameter to avoid this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8996a73c32006599330b4aacfeffcd8eabd847e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Under POSIX OS's, the returned time may actually be the time at which the file's attribute's were last modified. See &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; En el sistema operativo POSIX, la hora devuelta puede ser la hora en que se modificaron por &amp;uacute;ltima vez los atributos del archivo. Consulte &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;aqu&amp;iacute;&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="08f986989f7c1fa9c2cfa29fe4aab7353d67faf6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Use it only when you are &lt;strong&gt;absolutely sure&lt;/strong&gt; the value is present (e.g. after checking &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt;). Generally, using &lt;a href=&quot;#get,Option%5BT%5D&quot;&gt;get proc&lt;/a&gt; is preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4326e562047392c7a998b1d78e1b1453866d2345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You may wish to use the high-level version of this function which is defined below.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; es posible que desee utilizar la versi&amp;oacute;n de alto nivel de esta funci&amp;oacute;n que se define a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a987f98d420623ba5755baff3ce3a93970a01567" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You need to run asynchronous examples in an async proc otherwise you will get an &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f7852fedb7919a22f8ce639864908dfafb58b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You will need to run asynchronous examples in an async proc otherwise you will get an &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Deber&amp;aacute; ejecutar ejemplos asincr&amp;oacute;nicos en un proceso asincr&amp;oacute;nico; de lo contrario, obtendr&amp;aacute; un &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error &quot;aguardar&quot; .</target>
        </trans-unit>
        <trans-unit id="a7f5ae0bae2a97db2cc21e767ee5806933143eee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; to serialize &lt;code&gt;x&lt;/code&gt; to JSON use &lt;code&gt;$(%x)&lt;/code&gt; from the &lt;code&gt;json&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec8ba034600835b90eb455003ce0ac16f8f5171" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;getCurrentException()&lt;/code&gt; and &lt;code&gt;getCurrentExceptionMsg()&lt;/code&gt; are not available for imported exceptions from C++. One needs to use the &lt;code&gt;except ImportedException as x:&lt;/code&gt; syntax and rely on functionality of the &lt;code&gt;x&lt;/code&gt; object to get exception details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e153549d82bb0553e51565bc85af72f16648f194" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; can parse a large subset of C++ and knows about the &lt;code&gt;importcpp&lt;/code&gt; pragma pattern language. It is not necessary to know all the details described here.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; puede analizar un gran subconjunto de C ++ y conoce el lenguaje de patrones &lt;code&gt;importcpp&lt;/code&gt; pragma. No es necesario conocer todos los detalles aqu&amp;iacute; descritos.</target>
        </trans-unit>
        <trans-unit id="628a6cfa36ef34d2672ec1af4c7d21e0c80f03df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst&quot;&gt;c2nim&lt;/a&gt; can parse a large subset of C++ and knows about the &lt;code&gt;importcpp&lt;/code&gt; pragma pattern language. It is not necessary to know all the details described here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77e21e8d0104eaa0e42efbc8c62a054445fe5af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;manual#syntax-precedence&quot;&gt;Operator precedence&lt;/a&gt; is different than in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35a1cbcb5dda710b9a8fceaddc79fa8711972fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;--experimental:views&lt;/code&gt; is more effective with &lt;code&gt;--experimental:strictFuncs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2058773cc31994be378f849d22fa2b6e5de64f38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;=sink&lt;/code&gt; does not need to check for self-assignments. How self-assignments are handled is explained later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752ddb5d050c961f8013cbe90d4ad9d26a7ee13a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; must be initialised (with &lt;code&gt;new&lt;/code&gt;), this function makes no effort to initialise the &lt;code&gt;client&lt;/code&gt; variable.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : el &lt;code&gt;client&lt;/code&gt; e debe estar inicializado (con &lt;code&gt;new&lt;/code&gt; ), esta funci&amp;oacute;n no hace ning&amp;uacute;n esfuerzo por inicializar la variable del &lt;code&gt;client&lt;/code&gt; e .</target>
        </trans-unit>
        <trans-unit id="449eaada440261e910e8e598da9c4ed1cfb68e61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; needs to be initialised.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : el &lt;code&gt;client&lt;/code&gt; e debe inicializarse.</target>
        </trans-unit>
        <trans-unit id="ed6c907ecc726f3524b1431bfea1378d7d591f2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;data&lt;/code&gt; must be initialised.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : los &lt;code&gt;data&lt;/code&gt; deben inicializarse.</target>
        </trans-unit>
        <trans-unit id="64c21c25b25fb13a012539ce3d92a2f60ed66909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;typeof(x)&lt;/code&gt; can for historical reasons also be written as &lt;code&gt;type(x)&lt;/code&gt; but &lt;code&gt;type(x)&lt;/code&gt; is discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f23d79481e20b54cf233e31f8767bbf0d80411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;var&lt;/code&gt; parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : los par&amp;aacute;metros &lt;code&gt;var&lt;/code&gt; nunca son necesarios para un paso de par&amp;aacute;metros eficiente. Dado que los par&amp;aacute;metros no var no se pueden modificar, el compilador siempre tiene la libertad de pasar argumentos por referencia si considera que puede acelerar la ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="917b6bc95e7e2268d07e2f344f8fb05732bc1b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A &lt;code&gt;dynlib&lt;/code&gt; import can be overridden with the &lt;code&gt;--dynlibOverride:name&lt;/code&gt; command line option. The Compiler User Guide contains further information.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Una importaci&amp;oacute;n de &lt;code&gt;dynlib&lt;/code&gt; se puede anular con la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--dynlibOverride:name&lt;/code&gt; . La Gu&amp;iacute;a del usuario del compilador contiene m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aea57afb484ca3b2ae950510502c02d6d6d1b317" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A &lt;code&gt;dynlib&lt;/code&gt; import can be overridden with the &lt;code&gt;--dynlibOverride:name&lt;/code&gt; command-line option. The Compiler User Guide contains further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69e89fc6e4fabdd63d8a15033a0affd20ea60f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: According to HTTP/1.1 specification, the reason phrase is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c0c0109f9323e091c1b8f19f86e88886ea759e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: An &lt;span id=&quot;unresolved_1&quot;&gt;unresolved&lt;/span&gt; expression is an expression for which no symbol lookups and no type checking have been performed.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Una expresi&amp;oacute;n &lt;span id=&quot;unresolved_1&quot;&gt;sin resolver&lt;/span&gt; es una expresi&amp;oacute;n para la que no se han realizado b&amp;uacute;squedas de s&amp;iacute;mbolos ni verificaci&amp;oacute;n de tipos.</target>
        </trans-unit>
        <trans-unit id="19158a8ced28ef096d6d098faea99e938f8aea45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As a special syntactic extension if the whole PEG is only a single expression, identifiers are not interpreted as non-terminals, but are interpreted as verbatim string:</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Como extensi&amp;oacute;n sint&amp;aacute;ctica especial, si el PEG completo es solo una expresi&amp;oacute;n, los identificadores no se interpretan como no terminales, sino que se interpretan como una cadena literal:</target>
        </trans-unit>
        <trans-unit id="a646964958fc81cca21d1deac84d2ec91d7e8349" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Assignments, moves, and destruction are specified in the &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394b8821bf33b16092eceec91b4261c0182b2ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Code reordering is experimental and must be enabled via the &lt;code&gt;{.experimental.}&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : el reordenamiento del c&amp;oacute;digo es experimental y debe habilitarse mediante el &lt;code&gt;{.experimental.}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d3410cbe9aaa0f2ff2edaf757af2c7376b1329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compile time evaluation is not (yet) supported for methods.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : La evaluaci&amp;oacute;n del tiempo de compilaci&amp;oacute;n no es (todav&amp;iacute;a) compatible con los m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="1e9fb916a488d76befb6f270dcbc01bbe526c18b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compile-time execution is not (yet) supported for methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec4927b4c9fc829236a51cac7723591db8396a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Composition (&lt;em&gt;has-a&lt;/em&gt; relation) is often preferable to inheritance (&lt;em&gt;is-a&lt;/em&gt; relation) for simple code reuse. Since objects are value types in Nim, composition is as efficient as inheritance.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : La composici&amp;oacute;n ( &lt;em&gt;tiene una&lt;/em&gt; relaci&amp;oacute;n) es a menudo preferible a la herencia ( &lt;em&gt;es una&lt;/em&gt; relaci&amp;oacute;n) para la reutilizaci&amp;oacute;n de c&amp;oacute;digo simple. Dado que los objetos son tipos de valor en Nim, la composici&amp;oacute;n es tan eficiente como la herencia.</target>
        </trans-unit>
        <trans-unit id="0f588e4000ab499174937baf99ba9de907f81477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Concepts are still in development.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los conceptos a&amp;uacute;n est&amp;aacute;n en desarrollo.</target>
        </trans-unit>
        <trans-unit id="af0cb2698b6f62001c812557400b5666b24c541b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently exceptions are not propagated between &lt;code&gt;spawn&lt;/code&gt;'ed tasks!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : En la actualidad excepciones no se propagan entre &lt;code&gt;spawn&lt;/code&gt; 'ed tareas!</target>
        </trans-unit>
        <trans-unit id="d265fbeed3ef479118f8bab7a4ed8678ac73bc47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the assignment operator &lt;code&gt;=&lt;/code&gt; for &lt;code&gt;IntSet&lt;/code&gt; performs some rather meaningless shallow copy. Since Nim currently does not allow the assignment operator to be overloaded, use &lt;a href=&quot;#assign,IntSet,IntSet&quot;&gt;assign proc&lt;/a&gt; to get a deep copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e593de705b48a873244d353e72e0630bbbf7e8ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the compiler recognizes but ignores this pragma.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Actualmente, el compilador reconoce pero ignora este pragma.</target>
        </trans-unit>
        <trans-unit id="1b2d5b76dbe4b87b85248e2c9cb6a142ec8c770f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the creation of &lt;code&gt;nimrtl.dll&lt;/code&gt; with thread support has never been tested and is unlikely to work!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Actualmente, la creaci&amp;oacute;n de &lt;code&gt;nimrtl.dll&lt;/code&gt; con soporte para subprocesos nunca se ha probado y es poco probable que funcione.</target>
        </trans-unit>
        <trans-unit id="fb2822c93615d44b3b3cc5966ff533ff418b8724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Destructors are still experimental and the spec might change significantly in order to incorporate an escape analysis.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los destructores a&amp;uacute;n son experimentales y la especificaci&amp;oacute;n puede cambiar significativamente para incorporar un an&amp;aacute;lisis de escape.</target>
        </trans-unit>
        <trans-unit id="ee1ed6db845c184364f8097a01163d56d39e9c4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Dot operators are still experimental and so need to be enabled via &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los operadores de &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt; todav&amp;iacute;a son experimentales y, por lo tanto, deben habilitarse mediante {.experimental: &quot;dotOperators&quot;.} .</target>
        </trans-unit>
        <trans-unit id="d670368c6c2f5f22dc63498bef9e5233133587fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For Nim 1.0.x and older version, &lt;code&gt;zip&lt;/code&gt; returned a seq of named tuple with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. For Nim versions 1.1.x and newer, &lt;code&gt;zip&lt;/code&gt; returns a seq of unnamed tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76687951273781b82f6f05a64604534fc897b54a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For SSL sockets, the &lt;code&gt;handshake&lt;/code&gt; procedure must be called whenever the socket successfully connects to a server.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Para los sockets SSL, se debe llamar al procedimiento de &lt;code&gt;handshake&lt;/code&gt; siempre que el socket se conecte con &amp;eacute;xito a un servidor.</target>
        </trans-unit>
        <trans-unit id="91e3db899bae0bbfb9a7d3d39b2d7c168b6e2d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;stmt&lt;/code&gt; is an alias for &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;expr&lt;/code&gt; an alias for &lt;code&gt;untyped&lt;/code&gt;, but new code should use the newer, clearer names.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Por razones hist&amp;oacute;ricas, &lt;code&gt;stmt&lt;/code&gt; es un alias para &lt;code&gt;typed&lt;/code&gt; y &lt;code&gt;expr&lt;/code&gt; un alias para &lt;code&gt;untyped&lt;/code&gt; , pero el c&amp;oacute;digo nuevo debe usar los nombres m&amp;aacute;s nuevos y claros.</target>
        </trans-unit>
        <trans-unit id="c1eaf1a79f9ecb1c0d26ea4d5f7c22f8781d75d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;stmt&lt;/code&gt; was an alias for &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;expr&lt;/code&gt; was an alias for &lt;code&gt;untyped&lt;/code&gt;, but they are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35fa8c02b68bd348136724f65366d5d42363838f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;varargs[expr]&lt;/code&gt; is not equivalent to &lt;code&gt;varargs[untyped]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Por razones hist&amp;oacute;ricas, &lt;code&gt;varargs[expr]&lt;/code&gt; no es equivalente a &lt;code&gt;varargs[untyped]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4acf53db39aa60c86dd41398806d083a1a38011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Historically the operations were unchecked and the conversions were sometimes checked but starting with the revision 1.0.4 of this document and the language implementation the conversions too are now &lt;em&gt;always unchecked&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfadb62af1d09f91ea948f6071b29e23cceab2f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In general, the &lt;em&gt;define&lt;/em&gt; switches can also be set in NimScripts using &lt;code&gt;switch&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, as shown in above examples. Only the &lt;code&gt;release&lt;/code&gt; define (&lt;code&gt;-d:release&lt;/code&gt;) cannot be set in NimScripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6d221cb0526b5b0ecc418d504b0327381bfb9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Instead of &lt;code&gt;unittest.nim&lt;/code&gt;, please consider to use the &lt;code&gt;testament&lt;/code&gt; tool which offers process isolation for your tests. Also &lt;code&gt;when isMainModule: doAssert conditionHere&lt;/code&gt; is usually a much simpler solution for testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e02a608054219b27095b71a1aa9165e80b92873" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim computes a SHA1 checksum and only recompiles the file if it has changed. One can use the &lt;code&gt;-f&lt;/code&gt; command-line option to force the recompilation of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc5314fa7beb1755c498007976fd6bffd4a8741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim computes a SHA1 checksum and only recompiles the file if it has changed. You can use the &lt;code&gt;-f&lt;/code&gt; command line option to force recompilation of the file.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Nim calcula una suma de comprobaci&amp;oacute;n SHA1 y solo vuelve a compilar el archivo si ha cambiado. Puede usar la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;-f&lt;/code&gt; para forzar la recompilaci&amp;oacute;n del archivo.</target>
        </trans-unit>
        <trans-unit id="5388196ac73187f231ad39b82fb913ddc94a4bed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim currently does not detect these!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1271bb2722e7587eff37d0ec7806e796871dfb12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Openarrays can only be used for parameters.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Openarrays solo se puede utilizar para par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="69090e5eea8eeff4b4d6ed39bda4ed8ea1e00303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Passing variables to the &lt;code&gt;dynlib&lt;/code&gt; pragma will fail at runtime because of order of initialization problems.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : El paso de variables a &lt;code&gt;dynlib&lt;/code&gt; pragma fallar&amp;aacute; en tiempo de ejecuci&amp;oacute;n debido a problemas de orden de inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3d949419e5e8c75fc524d73127b46fd0d96b06e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Patterns like &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; are only supported in constant strings, because they are precompiled.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Patrones como &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; solo se admiten en cadenas constantes, porque est&amp;aacute;n precompilados.</target>
        </trans-unit>
        <trans-unit id="5c87c54173a7af7c54802abf0f3667ebc67c0bd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Read/write tracking is not yet implemented!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &amp;iexcl;El seguimiento de lectura / escritura a&amp;uacute;n no est&amp;aacute; implementado!</target>
        </trans-unit>
        <trans-unit id="2f5d2ff34eda59be2af772bbe3e60f574635b531" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Starting from Nim 0.20, generic methods are deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935e75468fab30bc8f181842cd16bcdfa062c5e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;.this&lt;/code&gt; pragma is deprecated and should not be used anymore.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &lt;code&gt;.this&lt;/code&gt; pragma est&amp;aacute; obsoleto y no deber&amp;iacute;a utilizarse m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="6bf5dca9c21d9d5aa4df461a3ff745da6884616f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;finalizer&lt;/code&gt; refers to the type &lt;code&gt;T&lt;/code&gt;, not to the object! This means that for each object of type &lt;code&gt;T&lt;/code&gt; the finalizer will be called!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111e86a91d15663eda5e4e58e22260484c13d8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; operations are available at compile-time!</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &amp;iexcl;Las operaciones &lt;code&gt;to&lt;/code&gt; y &lt;code&gt;$$&lt;/code&gt; est&amp;aacute;n disponibles en tiempo de compilaci&amp;oacute;n!</target>
        </trans-unit>
        <trans-unit id="03d9a64e63cab477a98b846aee1c6abff8cf07a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The Nim compiler prior to version 1 was more lenient about this requirement. Use the &lt;code&gt;--useVersion:0.19&lt;/code&gt; switch for a transition period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032415bc42f7c2c0c686c44717cb2657050a5b9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The aliasing restrictions are currently not enforced by the implementation and need to be fleshed out further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9fdb234ef8ab9ea0cd0ee243a725c77f4c3646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The asynchronous implementation is only asynchronous for long file transfers, calls to functions which use the command socket will block.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : La implementaci&amp;oacute;n as&amp;iacute;ncrona solo es as&amp;iacute;ncrona para transferencias de archivos largas, las llamadas a funciones que usan el comando socket se bloquear&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="21b5006b1c5b3e0551182aafd1ac04017eed31d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Los tipos de datos declarados aqu&amp;iacute; tienen &lt;em&gt;sem&amp;aacute;ntica de valor&lt;/em&gt; : esto significa que &lt;code&gt;=&lt;/code&gt; realiza una copia del conjunto.</target>
        </trans-unit>
        <trans-unit id="280898b023d47a8c9d92f2a9764ba5070e544d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example only works because the memory is initialized to zero (&lt;code&gt;alloc0&lt;/code&gt; instead of &lt;code&gt;alloc&lt;/code&gt; does this): &lt;code&gt;d.s&lt;/code&gt; is thus initialized to binary zero which the string assignment can handle. One needs to know low level details like this when mixing garbage collected data with unmanaged memory.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : El ejemplo solo funciona porque la memoria se inicializa a cero ( &lt;code&gt;alloc0&lt;/code&gt; en lugar de &lt;code&gt;alloc&lt;/code&gt; hace esto): as&amp;iacute;, &lt;code&gt;d.s&lt;/code&gt; se inicializa a cero binario que la asignaci&amp;oacute;n de cadena puede manejar. Es necesario conocer detalles de bajo nivel como este al mezclar datos recolectados de basura con memoria no administrada.</target>
        </trans-unit>
        <trans-unit id="0029ff03975d512a536084038b6c01735900bacd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example only works because the memory is initialized to zero (&lt;code&gt;alloc0&lt;/code&gt; instead of &lt;code&gt;alloc&lt;/code&gt; does this): &lt;code&gt;d.s&lt;/code&gt; is thus initialized to binary zero which the string assignment can handle. One needs to know low-level details like this when mixing garbage-collected data with unmanaged memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f70c58fd6b5bff5d5008569af769d29c9fc79ae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The experimental features of Nim are covered &lt;a href=&quot;manual_experimental&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc930249dbf7dab3ed38153c8153f17bf2fbf3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The precise result values depend on the used C runtime library and can differ between operating systems!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47964f4e63f9364071ab4aeb6d699ff7f8c08bcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--assumedef&lt;/code&gt; and &lt;code&gt;--assumendef&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay opciones de l&amp;iacute;nea de comando &lt;code&gt;--assumedef&lt;/code&gt; y &lt;code&gt;--assumendef&lt;/code&gt; que pueden usarse para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="beec5a850cfc6f7745e1b0ecb5a58d4d3717ffad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--prefix&lt;/code&gt; and &lt;code&gt;--suffix&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay opciones de l&amp;iacute;nea de comando &lt;code&gt;--prefix&lt;/code&gt; y &lt;code&gt;--suffix&lt;/code&gt; que se pueden usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="69ba15cf193dfbb62171a2742d239684c78daa69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--stdcall&lt;/code&gt; and &lt;code&gt;--cdecl&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay opciones de l&amp;iacute;nea de comando &lt;code&gt;--stdcall&lt;/code&gt; y &lt;code&gt;--cdecl&lt;/code&gt; que se pueden usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="6eae5a3b83fbed6b6c57ab8bbef30bd246b16faa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are two approaches to parameter substitution support by this module.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Hay dos enfoques para el soporte de sustituci&amp;oacute;n de par&amp;aacute;metros en este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="ee188be1bbae9b44b94cfc6f97f02261fdde6c36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are two different allowed implementation strategies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a42997a6733b871213621a8b95f824a807c7b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--dynlib&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--dynlib&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="7af996a9b1410d0551b826fcf6f31d2982be4597" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--header&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--header&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="0f6e6a5551e301a9206be409821f73e8efe724ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipcomments&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--skipcomments&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="24001770e3fa5f62c6de4221e4016da922b0b6b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipinclude&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--skipinclude&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="2a3d0067cf0a534d5914217a3b18410a03771aa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--typeprefixes&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Tambi&amp;eacute;n hay una opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--typeprefixes&lt;/code&gt; que se puede usar para el mismo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="e18e21cf48841adbc9777187ae8968f7fba53e98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This document is a draft! Several of Nim's features may need more precise wording. This manual is constantly evolving into a proper specification.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &amp;iexcl;Este documento es un borrador! Varias de las caracter&amp;iacute;sticas de Nim pueden necesitar una redacci&amp;oacute;n m&amp;aacute;s precisa. Este manual evoluciona constantemente hacia una especificaci&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="2aa2ab11076fb4ba0e0d90bade6f9b388734484a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This fails to count to &lt;code&gt;high(int)&lt;/code&gt; if T = int for efficiency reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567715e1f13e193fbfbf1198cf956b11412e00c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This fails to count to &lt;code&gt;low(int)&lt;/code&gt; if T = int for efficiency reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3533bf7103759fe5e503b595e40df4e4b28e6da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is &lt;strong&gt;not correct&lt;/strong&gt; for producing Ansi C code!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054e7ea2fe4b0d2089c5eb61f38663920957149a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level function, you may be interested in the higher level versions of this function which are also named &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esta es una funci&amp;oacute;n de bajo nivel, puede que le interesen las versiones de nivel superior de esta funci&amp;oacute;n que tambi&amp;eacute;n se denominan &lt;code&gt;recv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5282ba94e7660dfc3a29bcd1eed3c48d245d27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level version of &lt;code&gt;send&lt;/code&gt;. You likely should use the version below.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta es una versi&amp;oacute;n de bajo nivel de &lt;code&gt;send&lt;/code&gt; . Probablemente deber&amp;iacute;a utilizar la versi&amp;oacute;n siguiente.</target>
        </trans-unit>
        <trans-unit id="ed9daeb8e2aec5a4f06a14063ad786a38c80a1d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is dangerous to use as it encourages races. It's much better to use &lt;a href=&quot;#tryRecv,Channel%5BTMsg%5D&quot;&gt;tryRecv proc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3557f4c5da279c0358c73497195e9e969d921ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49259d4a9dac22acd343c8e255eecad4c524a642" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69e35e7b9f3081695456106f46697c03ffedd82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This module is deprecated since version 0.11.3. You should use the async version of this module &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este m&amp;oacute;dulo est&amp;aacute; obsoleto desde la versi&amp;oacute;n 0.11.3. Debe utilizar la versi&amp;oacute;n as&amp;iacute;ncrona de este m&amp;oacute;dulo &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2aa27f677d4a034cdeb59f9e8f5be392614db71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma should only be used by procs which consist solely of assembler statements.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este pragma solo debe ser utilizado por procesos que constan &amp;uacute;nicamente de declaraciones de ensamblador.</target>
        </trans-unit>
        <trans-unit id="c3942176661636505e686cd1e170c9c2c66c7838" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma will not exist for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : este pragma no existir&amp;aacute; para el backend LLVM.</target>
        </trans-unit>
        <trans-unit id="d247c6d12bb22bba349cec5690833cc3a153b0fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This proc is only occasionally useful, better use the &lt;a href=&quot;parseopt&quot;&gt;parseopt module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e370238e58db64e0d5e09298f252112f6df12b8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure is mostly used for testing. You likely want to use &lt;code&gt;asyncnet.recvLine&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : este procedimiento se utiliza principalmente para realizar pruebas. Es probable que desee utilizar &lt;code&gt;asyncnet.recvLine&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="322b2c09d6ee80b4e8d9ee5e387bb8ede9f8c9b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure will &lt;strong&gt;NOT&lt;/strong&gt; register &lt;code&gt;fd&lt;/code&gt; with the global async dispatcher. You need to do this manually. If you have used &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; to create &lt;code&gt;fd&lt;/code&gt; then it's already registered.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este procedimiento &lt;strong&gt;NO&lt;/strong&gt; registrar&amp;aacute; &lt;code&gt;fd&lt;/code&gt; con el despachador as&amp;iacute;ncrono global. Necesita hacer esto manualmente. Si ha utilizado &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; para crear &lt;code&gt;fd&lt;/code&gt; , entonces ya est&amp;aacute; registrado.</target>
        </trans-unit>
        <trans-unit id="69d44c4cf9df913ee690fbbedde86b19492609d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This results in non-deterministic behaviour and should be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518d5e4c7535845c8e9c442146b53d59a9b2f210" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section describes the current implementation. This part of the language specification will be changed. See &lt;a href=&quot;https://github.com/nim-lang/RFCs/issues/230&quot;&gt;https://github.com/nim-lang/RFCs/issues/230&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d932869f99df24b8242ec488c4a11db3770fcfc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will not work for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esto no funcionar&amp;aacute; para el backend LLVM.</target>
        </trans-unit>
        <trans-unit id="36372381e9ac840b308a26506bae63970c747486" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will set &lt;code&gt;sock&lt;/code&gt; to be non-blocking.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esto configurar&amp;aacute; el &lt;code&gt;sock&lt;/code&gt; para que no bloquee.</target>
        </trans-unit>
        <trans-unit id="d2b79b4545224be391a1d3f8ef925b80e4e045ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unless otherwise indicated, these features are not to be removed, but refined and overhauled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639f9874d8270608fdc7d69cf3882e85dfa3e245" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When you use it to write a wrapper for a C library, you should always check that the original library does never write to data behind the pointer that is returned from this procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8563457a94cb48f3c140f57c68dfa33fbbbe81a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: paths are not normalized to determine &lt;code&gt;isHidden&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1223df2703569d7a264f78da6a04381483fe3ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: static[T] is still in development.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : est&amp;aacute;tica [T] todav&amp;iacute;a est&amp;aacute; en desarrollo.</target>
        </trans-unit>
        <trans-unit id="cfc7fae090374e3f5581cc6d980013b1b5608dd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this proc does not exist while using the JS backend.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : este proceso no existe mientras se usa el backend JS.</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e42fbe4240560deae4f59c3edc3b41aa2d7beba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c903f2c52589e7acc68bf776349122058e049fc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice&lt;/strong&gt; - more important information that users should be notified about</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3999835082895c400051c08efff687fac9d5116a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance note&lt;/strong&gt;: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</source>
          <target state="translated">&lt;strong&gt;Nota de rendimiento&lt;/strong&gt; : Nim no produce una tabla de m&amp;eacute;todo virtual, pero genera &amp;aacute;rboles de despacho. Esto evita la costosa rama indirecta para las llamadas a m&amp;eacute;todos y permite la inserci&amp;oacute;n. Sin embargo, otras optimizaciones como la evaluaci&amp;oacute;n del tiempo de compilaci&amp;oacute;n o la eliminaci&amp;oacute;n de c&amp;oacute;digo muerto no funcionan con m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="264a251f5075a4fdc9f3139ede36b3cff78c8711" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please do not use this&lt;/strong&gt;: On Android, it currently returns &lt;code&gt;getHomeDir()&lt;/code&gt;, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; to your compiler invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e826b6b4ecba08efbc3138c61cefb888e1c674" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please do not use this&lt;/strong&gt;: On Android, it currently returns &lt;code&gt;getHomeDir()&lt;/code&gt;, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; to your compiler invokation.</source>
          <target state="translated">&lt;strong&gt;No utilice esto&lt;/strong&gt; : en Android, actualmente devuelve &lt;code&gt;getHomeDir()&lt;/code&gt; , y en otros sistemas basados ​​en Unix tambi&amp;eacute;n puede causar problemas de seguridad. Dicho esto, puede anular esta implementaci&amp;oacute;n agregando &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; a la invocaci&amp;oacute;n de su compilador.</target>
        </trans-unit>
        <trans-unit id="270d375af3bf0ef2adcd5f8fc2f75af783697ee1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restriction&lt;/strong&gt;: For objects their type is &lt;strong&gt;not&lt;/strong&gt; serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af53126db5be4c8aab90d27d5734b3708b192d3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restriction&lt;/strong&gt;: For objects their type is &lt;strong&gt;not&lt;/strong&gt; serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type:</source>
          <target state="translated">&lt;strong&gt;Restricci&amp;oacute;n&lt;/strong&gt; : para los objetos, su tipo &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; serializado. Esto significa esencialmente que no funciona si el objeto tiene alg&amp;uacute;n otro tipo de tiempo de ejecuci&amp;oacute;n que su tipo de tiempo de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7186d0046c17a6da25a9438f95b74f4eee397d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6c6b236d8abec1257912f6c53339b4b244db44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Since&lt;/strong&gt; version 1.2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca02299d53be025106a7089f4b7c5750dcd3dd98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Since&lt;/strong&gt;: Version 1.2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e0079e41a5b0f8de60d18697948189f4c07fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Style note&lt;/strong&gt;: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</source>
          <target state="translated">&lt;strong&gt;Nota de estilo&lt;/strong&gt; : para la legibilidad del c&amp;oacute;digo, es la mejor idea usar la construcci&amp;oacute;n de programaci&amp;oacute;n menos poderosa que a&amp;uacute;n sea suficiente. Entonces, la &quot;lista de verificaci&amp;oacute;n&quot; es:</target>
        </trans-unit>
        <trans-unit id="fe1515dd837d06ebdfb95963f4b433b9a9c3985a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + const name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre constante.</target>
        </trans-unit>
        <trans-unit id="89fa1ce97e4b1a8bbc8a7bdf79f0c84b5531d6c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + enum type + enum field name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + tipo de enumeraci&amp;oacute;n + nombre de campo de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="44cc69c566e0009f6ccc0fbac4d3567a0268b727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + iterator name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del iterador.</target>
        </trans-unit>
        <trans-unit id="821988216adbe7cd1954ec0da5648027ef8dc44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + let name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de let.</target>
        </trans-unit>
        <trans-unit id="57a25e461776b40d157a649de93257f5fe549d65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + macro name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de macro.</target>
        </trans-unit>
        <trans-unit id="3166d2d68e6f9702d538e16e0e365a37f0f31329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + method name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="061167cd91100dd105e9d11351199c7b83c16430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre.</target>
        </trans-unit>
        <trans-unit id="acf85825d2dfb7a2233737f8ada9679976415f1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + param name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="546e3a8202699c79b7b925592249d4072a1845aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + proc name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del proceso.</target>
        </trans-unit>
        <trans-unit id="e1aaee074e6af2e4ed1a60de85b378cc36322c99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + result.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + resultado.</target>
        </trans-unit>
        <trans-unit id="ca9583e48baa25b1239a744bd75804685b9425dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + template name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de plantilla.</target>
        </trans-unit>
        <trans-unit id="e445dd6209bef0d057963888553bf05a22332bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + type name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre del tipo.</target>
        </trans-unit>
        <trans-unit id="0e96cb006b66e97d61d546d8e4a627270ae7af33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + var name.</source>
          <target state="translated">&lt;strong&gt;Tercera columna&lt;/strong&gt; : m&amp;oacute;dulo + [n anidamiento de alcance] + nombre de var.</target>
        </trans-unit>
        <trans-unit id="b3006c2816bec11bab560e7a41a6685d7e93896b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This can introduce duplicate keys into the table!&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af56b1d80809997309a7af75799485c7602c39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This function returns nil in case of failure.&lt;/strong&gt; To prevent unexpected behavior and ensure proper error handling, use &lt;a href=&quot;#openFileStream,string,FileMode,int&quot;&gt;openFileStream proc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96622873fb587ed595611ae4d0e283ece6697a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is deprecated and should not be used&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Est&amp;aacute; en desuso y no debe utilizarse&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="10a71a1eac5a42f1dd6af4ba8a70a197d215c43e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is destructive! You must not modify `t` afterwards!&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a662d6054458a0060ff420609cf598e4d55cd58c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This proc is deprecated&lt;/strong&gt;, use this one instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf55f81e21c6bb396948994d75bed92009d6333c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This procedure is dangerous!&lt;/strong&gt; If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9df7eca11b12855add51f036ea9d3d1ea8ae1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage in JavaScript projects:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Uso en proyectos de JavaScript:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f768badd17da7a214c1ade1aa6c0fd2496dfda9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50465587dfd75b16c359e7f658dcbcaeabb41165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;https://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d394e5f72cbfd85f56d413e8a616ed5c6c4fe9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; This function uses &lt;code&gt;poEvalCommand&lt;/code&gt; by default for backwards compatibility. Make sure to pass options explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ebcd1c15404fdc059702927e729624fbd89690" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; This is destructive! Once sorted, you must not modify &lt;code&gt;t&lt;/code&gt; afterwards!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214cc33166124094f55a1446237ae8c582fe5355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Be careful when using &lt;code&gt;waitForExit&lt;/code&gt; for processes created without &lt;code&gt;poParentStreams&lt;/code&gt; because they may fill output buffers, causing deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec82fc02e8902673947cd6ed288467c5cc50a706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: The returned &lt;code&gt;FileHandle&lt;/code&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6de0d179490809d7ea1f625bb02e6fd588f97e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: The returned &lt;code&gt;Stream&lt;/code&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4316d6405c9f4c9d98f6e1f272b469fd25904ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Use it with caution. If &lt;code&gt;buf&lt;/code&gt; refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.</source>
          <target state="translated">&lt;strong&gt;ADVERTENCIA&lt;/strong&gt; : &amp;Uacute;selo con precauci&amp;oacute;n. Si &lt;code&gt;buf&lt;/code&gt; se refiere a un objeto GC'ed, debe usar llamadas GC_ref / GC_unref para evitar la liberaci&amp;oacute;n anticipada del b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="7f0c0c1f448cb428d097bb93a464a6218e766d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warn&lt;/strong&gt; - impending problems that require some attention</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251436bcf1a85c83d8711b39296fe259fc9d0256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f8f9514a22b55ff9c78136da9ef8a81f67b0108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; Si el proceso no ha terminado de ejecutarse, esto terminar&amp;aacute; forzosamente el proceso. Hacerlo puede resultar en procesos zombies y &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;fugas de pty&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7648a978c3c5b08aa7a942fe439314fcbbd9e17c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; It's not recommended to use &lt;code&gt;between&lt;/code&gt; for &lt;code&gt;DateTime's&lt;/code&gt; in different &lt;code&gt;TimeZone's&lt;/code&gt;. &lt;code&gt;a + between(a, b) == b&lt;/code&gt; is only guaranteed when &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in UTC.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; No se recomienda usar &lt;code&gt;between&lt;/code&gt; para &lt;code&gt;DateTime's&lt;/code&gt; en diferentes &lt;code&gt;TimeZone's&lt;/code&gt; . &lt;code&gt;a + between(a, b) == b&lt;/code&gt; solo se garantiza cuando &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; est&amp;aacute;n en UTC.</target>
        </trans-unit>
        <trans-unit id="d0a52c8fdc83d67244f36d1e45904b31b08be93b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since version 0.10.2 this module is deprecated. Use the &lt;a href=&quot;net&quot;&gt;net&lt;/a&gt; or the &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; Desde la versi&amp;oacute;n 0.10.2, este m&amp;oacute;dulo est&amp;aacute; obsoleto. En su lugar, utilice el m&amp;oacute;dulo &lt;a href=&quot;net&quot;&gt;net&lt;/a&gt; o &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9968b14e6044d19bea13d96a6048dbd5746bc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The &lt;code&gt;total&lt;/code&gt; reported by httpclient may be 0 in some cases.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; El &lt;code&gt;total&lt;/code&gt; informado por httpclient puede ser 0 en algunos casos.</target>
        </trans-unit>
        <trans-unit id="24b0c00e568f6b8e8da0f3bc2db0c76c857a200b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The API of this module is unstable, and therefore is subject to change.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; la API de este m&amp;oacute;dulo es inestable y, por lo tanto, est&amp;aacute; sujeta a cambios.</target>
        </trans-unit>
        <trans-unit id="70b2c2817205cf64dbba280341fa333ac9b060f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The buffer &lt;code&gt;a&lt;/code&gt; must be pre-allocated. This can be done using, for example, &lt;code&gt;newString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0af0517916216290aedd9e00253fb0aa629d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The buffer &lt;em&gt;a&lt;/em&gt; must be pre-allocated. This can be done using, for example, &lt;code&gt;newString&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; El b&amp;uacute;fer &lt;em&gt;a&lt;/em&gt; debe estar preasignado. Esto se puede hacer usando, por ejemplo, &lt;code&gt;newString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0520baa64a72e7ee0281b0ddd067f506549b20a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The global list of handlers is a thread var, this means that the handlers must be re-added in each thread. &lt;strong&gt;Warning:&lt;/strong&gt; When logging on disk or console, only error and fatal messages are flushed out immediately. Use flushFile() where needed.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; La lista global de controladores es una var de subproceso, esto significa que los controladores deben volver a agregarse en cada subproceso. &lt;strong&gt;Advertencia:&lt;/strong&gt; al iniciar sesi&amp;oacute;n en el disco o la consola, solo los mensajes de error y fatales se eliminan de inmediato. Utilice flushFile () donde sea necesario.</target>
        </trans-unit>
        <trans-unit id="f29b72a26be8d8706c4ec16fe1124964415b5b80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The global log filter is a thread-local variable. If logging is being performed in multiple threads, this proc should be called in each thread unless it is intended that different threads should log at different logging levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d380c8f716c8c691b16583d7c78a4ee17fba7411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The list of handlers is a thread-local variable. If the given handler will be used in multiple threads, this proc should be called in each of those threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de5e055501cd9543ed70f0688cbf30ac70cdc1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This function does not yet have a buffered implementation, so when &lt;code&gt;socket&lt;/code&gt; is buffered the non-buffered implementation will be used. Therefore if &lt;code&gt;socket&lt;/code&gt; contains something in its buffer this function will make no effort to return it.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; esta funci&amp;oacute;n a&amp;uacute;n no tiene una implementaci&amp;oacute;n en b&amp;uacute;fer, por lo que cuando el &lt;code&gt;socket&lt;/code&gt; est&amp;aacute; en b&amp;uacute;fer, se utilizar&amp;aacute; la implementaci&amp;oacute;n sin b&amp;uacute;fer. Por lo tanto, si &lt;code&gt;socket&lt;/code&gt; contiene algo en su b&amp;uacute;fer, esta funci&amp;oacute;n no har&amp;aacute; ning&amp;uacute;n esfuerzo por devolverlo.</target>
        </trans-unit>
        <trans-unit id="854f87e513637b6e9a5ac650c51cff41b8f768e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.10.2. Use the brand new &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; module together with the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo est&amp;aacute; obsoleto desde la versi&amp;oacute;n 0.10.2. Utilice el nuevo m&amp;oacute;dulo &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; junto con el m&amp;oacute;dulo &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0b3c2a66d1cb7f1d4a063b94c4ce6ca1f2543b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.14.0.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo est&amp;aacute; obsoleto desde la versi&amp;oacute;n 0.14.0.</target>
        </trans-unit>
        <trans-unit id="7eb0dfd155d4b6f3b53e214b0ecc3fdf13f08633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated, use the SSL procedures defined in the &lt;code&gt;net&lt;/code&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo est&amp;aacute; obsoleto, utilice los procedimientos SSL definidos en el m&amp;oacute;dulo de &lt;code&gt;net&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c5666a07ce3875934c4c4fc973b2a781936f5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module only supports the old asynchronous interface. You may wish to use the &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; instead for web applications.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; este m&amp;oacute;dulo solo es compatible con la antigua interfaz as&amp;iacute;ncrona. Es posible que desee utilizar &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; en su lugar para aplicaciones web.</target>
        </trans-unit>
        <trans-unit id="5cb55c6cefeda87fc389ece105c077ef731ae16e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This procedure appears to be broken for SSL connections as of Nim v1.0.2. Consider using the other &lt;code&gt;connect&lt;/code&gt; procedure. See &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/15215&quot;&gt;https://github.com/nim-lang/Nim/issues/15215&lt;/a&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53266ecbd11ce935a7868dc21f59beb46ccb3aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When using SSL with non-blocking sockets, it is best to use the acceptAddrSSL procedure as this procedure will most likely block.</source>
          <target state="translated">&lt;strong&gt;Advertencia:&lt;/strong&gt; Cuando utilice SSL con sockets sin bloqueo, es mejor utilizar el procedimiento acceptAddrSSL ya que es muy probable que este procedimiento bloquee.</target>
        </trans-unit>
        <trans-unit id="808a8a1028dc1fed134e205c55ec27d7dd5b23fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLine&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &lt;code&gt;recvLine&lt;/code&gt; en sockets sin b&amp;uacute;fer asume que el protocolo usa &lt;code&gt;\r\L&lt;/code&gt; para delimitar una nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="ac11ca7b54f8ac76331d539b39687d412032a370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLineInto&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &lt;code&gt;recvLineInto&lt;/code&gt; en sockets sin b&amp;uacute;fer asume que el protocolo usa &lt;code&gt;\r\L&lt;/code&gt; para delimitar una nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="5d163b20a95cadf02bed8abe7ed680f87b2b48bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : Tenga cuidado al usar waitForSalir para procesos creados sin poParentStreams porque pueden llenar b&amp;uacute;feres de salida, causando un punto muerto.</target>
        </trans-unit>
        <trans-unit id="0163b79bd484845ef77cdbb23264a20232b50266" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: If &lt;code&gt;state&lt;/code&gt; is set incorrectly the resulting &lt;code&gt;AsyncSocket&lt;/code&gt; object may not work properly.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : si el &lt;code&gt;state&lt;/code&gt; se establece incorrectamente, es &lt;code&gt;AsyncSocket&lt;/code&gt; objeto AsyncSocket resultante no funcione correctamente.</target>
        </trans-unit>
        <trans-unit id="a95d9701c19c6c0c221e25db304c7abf3d95c719" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Modifying the directory structure while the iterator is traversing may result in undefined behavior!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6766ee200b64744878c681dde8b968c6f670b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is currently supported.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : actualmente solo se admite el indicador &lt;code&gt;SafeDisconn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5179a287236e2707d51c8ae92986184ef63e00df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only use this if you know what you are doing.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : solo use esto si sabe lo que est&amp;aacute; haciendo.</target>
        </trans-unit>
        <trans-unit id="054c5e069a1dfb7566a7270fedaaf23823866854" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Ordinary application code should never set this hook! You better know what you do when setting this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ef80f1f143a1f7de2004bb4e9cee1fed78e787" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : algunos sistemas operativos (como Microsoft Windows) restringen la creaci&amp;oacute;n de enlaces simb&amp;oacute;licos a los usuarios root (administradores).</target>
        </trans-unit>
        <trans-unit id="1f61c1a4fea430f13537ed29d0765d587962a8f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's restrict the creation of hard links to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : algunos sistemas operativos restringen la creaci&amp;oacute;n de enlaces f&amp;iacute;sicos a usuarios root (administradores).</target>
        </trans-unit>
        <trans-unit id="f9012f1b5937f6027293c08f92583d61921af08c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; flag is not yet implemented.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : la bandera &lt;code&gt;Peek&lt;/code&gt; a&amp;uacute;n no est&amp;aacute; implementada.</target>
        </trans-unit>
        <trans-unit id="e86c259d83ff7290e4d751971a6fa6a8870f2e71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; socket flag is not supported on Windows.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : el indicador de socket &lt;code&gt;Peek&lt;/code&gt; no es compatible con Windows.</target>
        </trans-unit>
        <trans-unit id="b0d46006d11f4bceceb4d4e08b148768200fa533" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;tmpl&lt;/code&gt; argument is written to by &lt;code&gt;mkstemp&lt;/code&gt; and thus can't be a string literal. If in doubt make a copy of the cstring before passing it in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7cc1052b9ce8bdf39d06ce2f6b9a8915a89398" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;tmpl&lt;/code&gt; argument is written to by &lt;code&gt;mkstemps&lt;/code&gt; and thus can't be a string literal. If in doubt make a copy of the cstring before passing it in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b4583abc34f87fcf6eff4869eef2bfd28629d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;em&gt;tmpl&lt;/em&gt; argument is written to by &lt;em&gt;mkstemp&lt;/em&gt; and thus can't be a string literal. If in doubt copy the string before passing it.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &lt;em&gt;mkstemp escribe en el&lt;/em&gt; argumento &lt;em&gt;tmpl&lt;/em&gt; y, por lo tanto, no puede ser una cadena literal. En caso de duda, copie la cadena antes de pasarla.</target>
        </trans-unit>
        <trans-unit id="4f1192c1f109469e4dd7487e335279c8c6787f60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The behaviour of this procedure varies between Windows and POSIX systems. On Windows some OS calls can reset the error code to &lt;code&gt;0&lt;/code&gt; causing this procedure to return &lt;code&gt;0&lt;/code&gt;. It is therefore advised to call this procedure immediately after an OS call fails. On POSIX systems this is not a problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae8834fd1ff75f9c078051184e01727261e31cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The resulting &lt;code&gt;ptr AddrInfo&lt;/code&gt; must be freed using &lt;code&gt;freeAddrInfo&lt;/code&gt;!</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : &amp;iexcl;El &lt;code&gt;ptr AddrInfo&lt;/code&gt; resultante debe liberarse usando &lt;code&gt;freeAddrInfo&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="9e788c203930a853b492baa9fb790e0baaa6f689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;FileHandle&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : El &lt;em&gt;FileHandle&lt;/em&gt; devuelto no debe cerrarse manualmente ya que se cierra al cerrar el Proceso &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35816baa23c24b5f9e80530b286a99de07763458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;Stream&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : El &lt;em&gt;Stream&lt;/em&gt; devuelto no debe cerrarse manualmente ya que se cierra al cerrar el Proceso &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="070d8f77f83eff23785cd22229e7c7593a9f015a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This assumes that lines are delimited by &lt;code&gt;\r\L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : Esto supone que las l&amp;iacute;neas est&amp;aacute;n delimitados por &lt;code&gt;\r\L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9df6a23fa581b51ba2e0e996ce854f48568ec52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This function may give unexpected or completely wrong results on Windows.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : esta funci&amp;oacute;n puede dar resultados inesperados o completamente incorrectos en Windows.</target>
        </trans-unit>
        <trans-unit id="016fcff66b49f260c1c428fc4a770e9ba587d905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This module uses &lt;code&gt;immediate&lt;/code&gt; macros which are known to cause problems. Do yourself a favor and import the module as &lt;code&gt;from htmlgen import nil&lt;/code&gt; and then fully qualify the macros.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : este m&amp;oacute;dulo utiliza macros &lt;code&gt;immediate&lt;/code&gt; que se sabe que causan problemas. H&amp;aacute;gase un favor e importe el m&amp;oacute;dulo &lt;code&gt;from htmlgen import nil&lt;/code&gt; y luego califique completamente las macros.</target>
        </trans-unit>
        <trans-unit id="13fc508dd2164cb6be6b2b2f5043fed79efd1dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b71636d61a389fc8acb40152f2835585e38044" translate="yes" xml:space="preserve">
          <source>A &quot;move&quot; can be regarded as an optimized copy operation. If the source of the copy operation is not used afterward, the copy can be replaced by a move. This document uses the notation &lt;code&gt;lastReadOf(x)&lt;/code&gt; to describe that &lt;code&gt;x&lt;/code&gt; is not used afterwards. This property is computed by a static control flow analysis but can also be enforced by using &lt;code&gt;system.move&lt;/code&gt; explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee8bac63489b4b65f1d77d36e0156115bbf2067" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see &quot;Locale support&quot; in the pcreapi page). For example, in the &quot;fr_FR&quot; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by &lt;code&gt;\w&lt;/code&gt;.</source>
          <target state="translated">Un car&amp;aacute;cter de &quot;palabra&quot; es un gui&amp;oacute;n bajo o cualquier car&amp;aacute;cter menor de 256 que sea una letra o un d&amp;iacute;gito. La definici&amp;oacute;n de letras y d&amp;iacute;gitos est&amp;aacute; controlada por las tablas de caracteres de bajo valor de PCRE, y puede variar si se lleva a cabo una coincidencia espec&amp;iacute;fica de la configuraci&amp;oacute;n regional (consulte &quot;Soporte de configuraci&amp;oacute;n regional&quot; en la p&amp;aacute;gina de pcreapi). Por ejemplo, en la configuraci&amp;oacute;n regional &quot;fr_FR&quot; (franc&amp;eacute;s), algunos c&amp;oacute;digos de caracteres superiores a 128 se utilizan para letras acentuadas, y estos se corresponden con &lt;code&gt;\w&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f72d8972b6598297117d18b7db8ef83c968a530" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;$&lt;/code&gt; proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f987a9c7bda1ba368e820346dd66c8e5c89eaa6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=destroy&lt;/code&gt; hook frees the object's associated memory and releases other associated resources. Variables are destroyed via this hook when they go out of scope or when the routine they were declared in is about to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c295c049a3b9376266f8a5946db064e42c05591f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=sink&lt;/code&gt; hook moves an object around, the resources are stolen from the source and passed to the destination. It is ensured that the source's destructor does not free the resources afterward by setting the object to its default value (the value the object's state started in). Setting an object &lt;code&gt;x&lt;/code&gt; back to its default value is written as &lt;code&gt;wasMoved(x)&lt;/code&gt;. When not provided the compiler is using a combination of &lt;code&gt;=destroy&lt;/code&gt; and &lt;code&gt;copyMem&lt;/code&gt; instead. This is efficient hence users rarely need to implement their own &lt;code&gt;=sink&lt;/code&gt; operator, it is enough to provide &lt;code&gt;=destroy&lt;/code&gt; and &lt;code&gt;=copy&lt;/code&gt;, compiler will take care of the rest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade5cfc4633d231cd947fd6c046bf9c49c277b02" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; represents a duration of time stored as seconds and nanoseconds. A &lt;code&gt;Duration&lt;/code&gt; is always fully normalized, so &lt;code&gt;initDuration(hours = 1)&lt;/code&gt; and &lt;code&gt;initDuration(minutes = 60)&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaba2403682a17469ecab3c6f2cc502e7be26d2b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HttpRequestError&lt;/code&gt; will be raised if the server responds with a client error (status code 4xx) or a server error (status code 5xx).</source>
          <target state="translated">Se generar&amp;aacute; un error &lt;code&gt;HttpRequestError&lt;/code&gt; si el servidor responde con un error del cliente (c&amp;oacute;digo de estado 4xx) o un error del servidor (c&amp;oacute;digo de estado 5xx).</target>
        </trans-unit>
        <trans-unit id="9bb8bd75e1a9a8ff5a43663da64ab547afc1c568" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Source Code Filter (SCF)&lt;/code&gt; transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f2546ed8f58cd59935336003ee6db78fbf89d1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TimeInterval&lt;/code&gt; represents an amount of time expressed in calendar units, for example &quot;1 year and 2 days&quot;. Since some units cannot be normalized (the length of a year is different for leap years for example), the &lt;code&gt;TimeInterval&lt;/code&gt; type uses separate fields for every unit. The &lt;code&gt;TimeInterval&lt;/code&gt;'s returned from this module generally don't normalize &lt;strong&gt;anything&lt;/strong&gt;, so even units that could be normalized (like seconds, milliseconds and so on) are left untouched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81d68641d8bf3ceba1aef0cf067b5ab815956a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ValueError&lt;/code&gt; exception will be raised if the value is not an integer.</source>
          <target state="translated">Se &lt;code&gt;ValueError&lt;/code&gt; excepci&amp;oacute;n ValueError si el valor no es un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="ae6545e69126352cc398c36e028a5f279a82dab9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;block expression&lt;/code&gt; is almost like a block statement, but it is an expression that uses the last expression under the block as the value. It is similar to the statement list expression, but the statement list expression does not open a new block scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a6495aba25fcc0345009a64738a98f0c760abf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;block&lt;/code&gt; doesn't need an name, in which case &lt;code&gt;nnkEmpty&lt;/code&gt; is used.</source>
          <target state="translated">Un &lt;code&gt;block&lt;/code&gt; no necesita un nombre, en cuyo caso se usa &lt;code&gt;nnkEmpty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde4d27b77941b8a2e8d7b668c0d8b482525e40c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;closure&lt;/code&gt; proc var can call ordinary procs of the default Nim calling convention. But not the other way round! A closure is implemented as a &lt;code&gt;tuple[prc, env]&lt;/code&gt;. &lt;code&gt;env&lt;/code&gt; can be nil implying a call without a closure. This means that a call through a closure generates an &lt;code&gt;if&lt;/code&gt; but the interoperability is worth the cost of the &lt;code&gt;if&lt;/code&gt;. Thunk generation would be possible too, but it's slightly more effort to implement.</source>
          <target state="translated">Un proceso de &lt;code&gt;closure&lt;/code&gt; var puede llamar procesos ordinarios de la convenci&amp;oacute;n de llamada predeterminada de Nim. &amp;iexcl;Pero no al rev&amp;eacute;s! Un cierre se implementa como una &lt;code&gt;tuple[prc, env]&lt;/code&gt; . &lt;code&gt;env&lt;/code&gt; puede ser nil, lo que implica una llamada sin un cierre. Esto significa que una llamada a trav&amp;eacute;s de un cierre genera un &lt;code&gt;if&lt;/code&gt; pero la interoperabilidad vale el costo del &lt;code&gt;if&lt;/code&gt; . La generaci&amp;oacute;n de thunk tambi&amp;eacute;n ser&amp;iacute;a posible, pero su implementaci&amp;oacute;n requiere un poco m&amp;aacute;s de esfuerzo.</target>
        </trans-unit>
        <trans-unit id="46ca6bf4504c12b38f73b70158bd4cc5686ceec6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;continue&lt;/code&gt; statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:</source>
          <target state="translated">Una instrucci&amp;oacute;n &lt;code&gt;continue&lt;/code&gt; conduce a la siguiente iteraci&amp;oacute;n inmediata de la construcci&amp;oacute;n de bucle circundante. Solo est&amp;aacute; permitido dentro de un bucle. Una instrucci&amp;oacute;n continue es az&amp;uacute;car sint&amp;aacute;ctica para un bloque anidado:</target>
        </trans-unit>
        <trans-unit id="c715fe380645376748f587a6b825be1c5374aad4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;distinct&lt;/code&gt; type is a new type derived from a &lt;span id=&quot;base-type_1&quot;&gt;base type&lt;/span&gt; that is incompatible with its base type. In particular, it is an essential property of a distinct type that it &lt;strong&gt;does not&lt;/strong&gt; imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also &lt;code&gt;distinctBase&lt;/code&gt; to get the reverse operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa532fc8ce7dbe2864f24cd2a27ac73e6fc36afd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;distinct&lt;/code&gt; type is new type derived from a &lt;span id=&quot;base-type_1&quot;&gt;base type&lt;/span&gt; that is incompatible with its base type. In particular, it is an essential property of a distinct type that it &lt;strong&gt;does not&lt;/strong&gt; imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also &lt;code&gt;distinctBase&lt;/code&gt; to get the reverse operation.</source>
          <target state="translated">Un tipo &lt;code&gt;distinct&lt;/code&gt; es un tipo nuevo derivado de un &lt;span id=&quot;base-type_1&quot;&gt;tipo base&lt;/span&gt; que es incompatible con su tipo base. En particular, es una propiedad esencial de un tipo distinto que &lt;strong&gt;no&lt;/strong&gt; implica una relaci&amp;oacute;n de subtipo entre &amp;eacute;l y su tipo base. Se permiten las conversiones de tipo expl&amp;iacute;cito de un tipo diferenciado a su tipo base y viceversa. Consulte tambi&amp;eacute;n &lt;code&gt;distinctBase&lt;/code&gt; para obtener la operaci&amp;oacute;n inversa.</target>
        </trans-unit>
        <trans-unit id="e436402133516571641a8daf812bf61340c32403" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;flowVar&lt;/code&gt; only supports one call to &lt;code&gt;blockUntilAny&lt;/code&gt; at the same time. That means if you &lt;code&gt;blockUntilAny([a,b])&lt;/code&gt; and &lt;code&gt;blockUntilAny([b,c])&lt;/code&gt; the second call will only block until &lt;code&gt;c&lt;/code&gt;. If there is no &lt;code&gt;flowVar&lt;/code&gt; left to be able to wait on, -1 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec0b8e4f99548ff52eae3d0e8ec4be16fcde6a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; statement declares new local and global &lt;span id=&quot;single-assignment_1&quot;&gt;single assignment&lt;/span&gt; variables and binds a value to them. The syntax is the same as that of the &lt;code&gt;var&lt;/code&gt; statement, except that the keyword &lt;code&gt;var&lt;/code&gt; is replaced by the keyword &lt;code&gt;let&lt;/code&gt;. Let variables are not l-values and can thus not be passed to &lt;code&gt;var&lt;/code&gt; parameters nor can their address be taken. They cannot be assigned new values.</source>
          <target state="translated">Una instrucci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; declara nuevas variables de &lt;span id=&quot;single-assignment_1&quot;&gt;asignaci&amp;oacute;n &amp;uacute;nica&lt;/span&gt; locales y globales y les vincula un valor. La sintaxis es la misma que la de la instrucci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; , excepto que la palabra clave &lt;code&gt;var&lt;/code&gt; se reemplaza por la palabra clave &lt;code&gt;let&lt;/code&gt; . Dejemos que las variables no sean valores l y, por lo tanto, no se pueden pasar a par&amp;aacute;metros &lt;code&gt;var&lt;/code&gt; ni se puede tomar su direcci&amp;oacute;n. No se les pueden asignar nuevos valores.</target>
        </trans-unit>
        <trans-unit id="8fe78b3a2821fa1451c04e1ee9b03eb161700c9d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;raises&lt;/code&gt; list can also be attached to a proc type. This affects type compatibility:</source>
          <target state="translated">Una &lt;code&gt;raises&lt;/code&gt; lista tambi&amp;eacute;n se puede conectar a un tipo proc. Esto afecta la compatibilidad de tipos:</target>
        </trans-unit>
        <trans-unit id="c8cb08453579d0f15d45b19ab781ad1eab51f587" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is an openarray parameter that additionally allows to pass a variable number of arguments to a procedure. The compiler converts the list of arguments to an array implicitly:</source>
          <target state="translated">Un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; es un par&amp;aacute;metro openarray que adem&amp;aacute;s permite pasar un n&amp;uacute;mero variable de argumentos a un procedimiento. El compilador convierte la lista de argumentos en una matriz impl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="9932ed67f0c5e1f713b0339fd155b7567d8b4c9b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:</source>
          <target state="translated">Un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; es como un par&amp;aacute;metro openarray. Sin embargo, tambi&amp;eacute;n es un medio para implementar el paso de un n&amp;uacute;mero variable de argumentos a un procedimiento. El compilador convierte la lista de argumentos en una matriz autom&amp;aacute;ticamente:</target>
        </trans-unit>
        <trans-unit id="e982b06375e4d6cb9864cbab229ee93da8102df8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;$&lt;/em&gt; proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</source>
          <target state="translated">Se define un &lt;em&gt;$&lt;/em&gt; proc para cstrings que devuelve una cadena. Por lo tanto, para obtener una cadena nim de un cstring:</target>
        </trans-unit>
        <trans-unit id="4924981c6cf86467817a6848ae253feb1dd3d357" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Source Code Filter&lt;/em&gt; transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.</source>
          <target state="translated">Un &lt;em&gt;filtro de c&amp;oacute;digo fuente&lt;/em&gt; transforma el flujo de caracteres de entrada en un flujo de salida en memoria antes de analizar. Se puede utilizar un filtro para proporcionar sistemas de plantillas o preprocesadores.</target>
        </trans-unit>
        <trans-unit id="ffbb84a506b05cba8d617634fff9481c23abd0eb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutable&lt;/em&gt; view type is a type that is or contains a &lt;code&gt;var T&lt;/code&gt; type. An &lt;em&gt;immutable&lt;/em&gt; view type is a view type that is not a mutable view type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787f1149d9267dbcf887509536779010033aad01" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subex&lt;/em&gt; (&lt;em&gt;Substitution Expression&lt;/em&gt;) represents an advanced string substitution. In contrast to a &lt;span id=&quot;regex_1&quot;&gt;regex&lt;/span&gt; which deals with string analysis, a &lt;em&gt;subex&lt;/em&gt; deals with string synthesis.</source>
          <target state="translated">Un &lt;em&gt;subex&lt;/em&gt; ( &lt;em&gt;expresi&amp;oacute;n de sustituci&amp;oacute;n&lt;/em&gt; ) representa una sustituci&amp;oacute;n de cadena avanzada. A diferencia de una &lt;span id=&quot;regex_1&quot;&gt;expresi&amp;oacute;n regular&lt;/span&gt; que se ocupa del an&amp;aacute;lisis de cadenas, un &lt;em&gt;subex se&lt;/em&gt; ocupa de la s&amp;iacute;ntesis de cadenas.</target>
        </trans-unit>
        <trans-unit id="4f993e9d9aed0b9d20403070d843afd35df22c0c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view&lt;/em&gt; is a symbol (a let, var, const, etc.) that has a view type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889eb097f34d2cb2326af79e37dd19352cd4b767" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;checked-runtime-error_1&quot;&gt;checked runtime error&lt;/span&gt; is an error that the implementation detects and reports at runtime. The method for reporting such errors is via &lt;em&gt;raising exceptions&lt;/em&gt; or &lt;em&gt;dying with a fatal error&lt;/em&gt;. However, the implementation provides a means to disable these runtime checks. See the section &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; for details.</source>
          <target state="translated">Un &lt;span id=&quot;checked-runtime-error_1&quot;&gt;error de tiempo de ejecuci&amp;oacute;n verificado&lt;/span&gt; es un error que la implementaci&amp;oacute;n detecta y notifica durante el tiempo de ejecuci&amp;oacute;n. El m&amp;eacute;todo para informar tales errores es &lt;em&gt;generar excepciones&lt;/em&gt; o &lt;em&gt;morir con un error fatal&lt;/em&gt; . Sin embargo, la implementaci&amp;oacute;n proporciona un medio para desactivar estas comprobaciones en tiempo de ejecuci&amp;oacute;n. Consulte la secci&amp;oacute;n &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="3632d0ab374d6b5b4b41b8c40814ec08f6ffd800" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;constant-expression_1&quot;&gt;constant expression&lt;/span&gt; is an expression whose value can be computed during a semantic analysis of the code in which it appears. It is never an l-value and never has side effects. Constant expressions are not limited to the capabilities of semantic analysis, such as constant folding; they can use all Nim language features that are supported for compile-time execution. Since constant expressions can be used as an input to semantic analysis (such as for defining array bounds), this flexibility requires the compiler to interleave semantic analysis and compile-time code execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97460e671a1b963a40ec5d11fe647ad12dd7e11" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;constant_1&quot;&gt;constant&lt;/span&gt; is a symbol that is bound to the value of a constant expression. Constant expressions are restricted to depend only on the following categories of values and operations, because these are either built into the language or declared and evaluated before semantic analysis of the constant expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c99118ea561948c45f870ebd2c2cce4b7b646d" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;guard_1&quot;&gt;guard&lt;/span&gt; annotation is introduced to prevent data races.</source>
          <target state="translated">Se introduce una anotaci&amp;oacute;n de &lt;span id=&quot;guard_1&quot;&gt;guardia&lt;/span&gt; para evitar carreras de datos.</target>
        </trans-unit>
        <trans-unit id="386e659d1429b589f185720a9d5bf0ba95205db0" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;narrowing type conversion&lt;/span&gt; converts a larger to a smaller type (for example &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt;. A &lt;span id=&quot;widening-type-conversion_1&quot;&gt;widening type conversion&lt;/span&gt; converts a smaller type to a larger type (for example &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt;). In Nim only widening type conversions are &lt;em&gt;implicit&lt;/em&gt;:</source>
          <target state="translated">Una &lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;conversi&amp;oacute;n de&lt;/span&gt; tipo de &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt; convierte un tipo m&amp;aacute;s grande en uno m&amp;aacute;s peque&amp;ntilde;o (por ejemplo, int32 -&amp;gt; int16 . Una &lt;span id=&quot;widening-type-conversion_1&quot;&gt;conversi&amp;oacute;n de tipo de ampliaci&amp;oacute;n&lt;/span&gt; convierte un tipo m&amp;aacute;s peque&amp;ntilde;o en un tipo m&amp;aacute;s grande (por ejemplo, &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt; ). En Nim, solo las conversiones de tipo de ampliaci&amp;oacute;n son &lt;em&gt;impl&amp;iacute;citas&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="3955b81b785f4e1f5618c3fd25368b3b2f30c5e6" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;panic_1&quot;&gt;panic&lt;/span&gt; is an error that the implementation detects and reports at runtime. The method for reporting such errors is via &lt;em&gt;raising exceptions&lt;/em&gt; or &lt;em&gt;dying with a fatal error&lt;/em&gt;. However, the implementation provides a means to disable these &lt;span id=&quot;runtime-checks_1&quot;&gt;runtime checks&lt;/span&gt;. See the section &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387048b351545e7cdb57e945c46d2fba04806529" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt; is an error that the implementation detects before program execution. Unless explicitly classified, an error is a static error.</source>
          <target state="translated">Un &lt;span id=&quot;static-error_1&quot;&gt;error est&amp;aacute;tico&lt;/span&gt; es un error que la implementaci&amp;oacute;n detecta antes de la ejecuci&amp;oacute;n del programa. A menos que se clasifique expl&amp;iacute;citamente, un error es un error est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="130e98a36d1ad0d5fa779c624d02b3795704ff33" translate="yes" xml:space="preserve">
          <source>A Distinct type allows for the creation of new type that &quot;does not imply a subtype relationship between it and its base type&quot;. You must &lt;strong&gt;explicitly&lt;/strong&gt; define all behaviour for the distinct type. To help with this, both the distinct type and its base type can cast from one type to the other. Examples are provided in the &lt;a href=&quot;manual#types-distinct-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Un tipo Distinto permite la creaci&amp;oacute;n de un nuevo tipo que &quot;no implica una relaci&amp;oacute;n de subtipo entre &amp;eacute;l y su tipo base&quot;. Debe definir &lt;strong&gt;expl&amp;iacute;citamente&lt;/strong&gt; todo el comportamiento del tipo diferenciado. Para ayudar con esto, tanto el tipo diferenciado como su tipo base pueden pasar de un tipo a otro. En el &lt;a href=&quot;manual#types-distinct-type&quot;&gt;manual&lt;/a&gt; se proporcionan ejemplos .</target>
        </trans-unit>
        <trans-unit id="79b065193cd9e9953658e8235e333843b91d5cf1" translate="yes" xml:space="preserve">
          <source>A Nim &lt;code&gt;string&lt;/code&gt; is implicitly convertible to &lt;code&gt;cstring&lt;/code&gt; for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to &lt;code&gt;cstring&lt;/code&gt; too:</source>
          <target state="translated">Una &lt;code&gt;string&lt;/code&gt; Nim se puede convertir impl&amp;iacute;citamente en &lt;code&gt;cstring&lt;/code&gt; por conveniencia. Si una cadena Nim se pasa a un proceso variadic de estilo C, tambi&amp;eacute;n se convierte impl&amp;iacute;citamente en &lt;code&gt;cstring&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="065a0f8b65d9d6ed85af9b0b240cf7b0af451235" translate="yes" xml:space="preserve">
          <source>A Nim &lt;span id=&quot;program_1&quot;&gt;program&lt;/span&gt; consists of one or more text &lt;span id=&quot;source-files_1&quot;&gt;source files&lt;/span&gt; containing Nim code. It is processed by a Nim &lt;span id=&quot;compiler_1&quot;&gt;compiler&lt;/span&gt; into an &lt;span id=&quot;executable_1&quot;&gt;executable&lt;/span&gt;. The nature of this executable depends on the compiler implementation; it may, for example, be a native binary or JavaScript source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69460fedc7d49aa8bfd391ea3c8be3ae26318394" translate="yes" xml:space="preserve">
          <source>A Nim procedure is asynchronous when it includes the &lt;code&gt;{.async.}&lt;/code&gt; pragma. It should always have a &lt;code&gt;Future[T]&lt;/code&gt; return type or not have a return type at all. A &lt;code&gt;Future[void]&lt;/code&gt; return type is assumed by default.</source>
          <target state="translated">Un procedimiento de Nim es as&amp;iacute;ncrono cuando incluye el &lt;code&gt;{.async.}&lt;/code&gt; . Siempre debe tener un tipo de retorno &lt;code&gt;Future[T]&lt;/code&gt; o no tener ning&amp;uacute;n tipo de retorno. De forma predeterminada, se asume un tipo de retorno &lt;code&gt;Future[void]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd52730a119bb22be3969f6811e2133725811be" translate="yes" xml:space="preserve">
          <source>A Nim program specifies a computation that acts on a memory consisting of components called &lt;span id=&quot;locations_1&quot;&gt;locations&lt;/span&gt;. A variable is basically a name for a location. Each variable and location is of a certain &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. The variable's type is called &lt;span id=&quot;static-type_1&quot;&gt;static type&lt;/span&gt;, the location's type is called &lt;span id=&quot;dynamic-type_1&quot;&gt;dynamic type&lt;/span&gt;. If the static type is not the same as the dynamic type, it is a super-type or subtype of the dynamic type.</source>
          <target state="translated">Un programa de Nim especifica un c&amp;aacute;lculo que act&amp;uacute;a sobre una memoria que consta de componentes llamados &lt;span id=&quot;locations_1&quot;&gt;ubicaciones&lt;/span&gt; . Una variable es b&amp;aacute;sicamente el nombre de una ubicaci&amp;oacute;n. Cada variable y ubicaci&amp;oacute;n es de un &lt;span id=&quot;type_1&quot;&gt;tipo&lt;/span&gt; determinado . El tipo de la variable se llama &lt;span id=&quot;static-type_1&quot;&gt;tipo est&amp;aacute;tico&lt;/span&gt; , el &lt;span id=&quot;static-type_1&quot;&gt;tipo de&lt;/span&gt; la ubicaci&amp;oacute;n se llama &lt;span id=&quot;dynamic-type_1&quot;&gt;tipo din&amp;aacute;mico&lt;/span&gt; . Si el tipo est&amp;aacute;tico no es el mismo que el tipo din&amp;aacute;mico, es un supertipo o subtipo del tipo din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="4d649a9b73eb1b75df006205a78131f546ab13c9" translate="yes" xml:space="preserve">
          <source>A PEG (Parsing expression grammar) is a simple deterministic grammar, that can be directly used for parsing. The current implementation has been designed as a more powerful replacement for regular expressions. UTF-8 is supported.</source>
          <target state="translated">Una PEG (gramática de expresión de análisis)es una gramática determinista simple,que puede ser utilizada directamente para el análisis.La aplicación actual ha sido diseñada como un sustituto más poderoso de las expresiones regulares.Se admite el UTF-8.</target>
        </trans-unit>
        <trans-unit id="8f7d9cb77b19d82ede8da7ec5e4ab6a8a699b484" translate="yes" xml:space="preserve">
          <source>A Rune may be composed with other Runes to a character on the screen. &lt;code&gt;RuneImpl&lt;/code&gt; is the underlying type used to store Runes, currently &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97903ec287c9679803a5cf8de4f08e59be7ecca6" translate="yes" xml:space="preserve">
          <source>A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource. A URI can be further classified as a locator, a name, or both. The term &amp;ldquo;Uniform Resource Locator&amp;rdquo; (URL) refers to the subset of URIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b07af826ffc1642e9db6c9aa9ff6e43b9cc68a" translate="yes" xml:space="preserve">
          <source>A application-level error condition. For example, some user input generated an exception. The application will continue to run, but functionality or data was impacted, possibly visible to users.</source>
          <target state="translated">Una condición de error a nivel de aplicación.Por ejemplo,algunas entradas de usuario generaron una excepción.La aplicación seguirá funcionando,pero la funcionalidad o los datos se vieron afectados,posiblemente de forma visible para los usuarios.</target>
        </trans-unit>
        <trans-unit id="5d9beef18f6feec8ed926e501f6bc8ef50b29384" translate="yes" xml:space="preserve">
          <source>A application-level fatal condition. FATAL usually means that the application cannot go on and will exit (but this logging event will not do that for you).</source>
          <target state="translated">Una condición fatal a nivel de aplicación.FATAL normalmente significa que la aplicación no puede continuar y saldrá (pero este evento de registro no lo hará por usted).</target>
        </trans-unit>
        <trans-unit id="0bc66569c7f749a991c86255655ab99ac30e86d5" translate="yes" xml:space="preserve">
          <source>A backslash followed by a letter is a built-in macro, otherwise it is used for ordinary escaping:</source>
          <target state="translated">Una barra invertida seguida de una letra es una macro incorporada,de lo contrario se utiliza para la fuga ordinaria:</target>
        </trans-unit>
        <trans-unit id="519b373c181ee8d4be473dddf120c85a8c41428c" translate="yes" xml:space="preserve">
          <source>A block can be left prematurely with a &lt;code&gt;break&lt;/code&gt; statement. The break statement can leave a &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; statement. It leaves the innermost construct, unless a label of a block is given:</source>
          <target state="translated">Un bloque se puede dejar prematuramente con una declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; . La sentencia break puede dejar una sentencia &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; o &lt;code&gt;block&lt;/code&gt; . Deja la construcci&amp;oacute;n m&amp;aacute;s interna, a menos que se d&amp;eacute; una etiqueta de un bloque:</target>
        </trans-unit>
        <trans-unit id="2b2a65f3fbb55054c3c60c9c8e9467f1ea4b9e04" translate="yes" xml:space="preserve">
          <source>A bool is one byte long and it is &lt;code&gt;true&lt;/code&gt; for every non-zero (&lt;code&gt;0000_0000&lt;/code&gt;) value. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07808673548482e5392b9784984fdab8e702d49d" translate="yes" xml:space="preserve">
          <source>A borrow operation ends with the last usage of the view variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a07d2cefd27e89258e2ff6a670ec933e438f77" translate="yes" xml:space="preserve">
          <source>A borrow starts with one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8018e99c199800e7c1d485e8e8e1d2de44558695" translate="yes" xml:space="preserve">
          <source>A call to an asynchronous procedure usually needs &lt;code&gt;await&lt;/code&gt; to wait for the completion of the &lt;code&gt;Future&lt;/code&gt;.</source>
          <target state="translated">Una llamada a un procedimiento asincr&amp;oacute;nico generalmente necesita &lt;code&gt;await&lt;/code&gt; para esperar la finalizaci&amp;oacute;n del &lt;code&gt;Future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92b34eeb7a8a85759a8e5d4110adc50791d4f3f3" translate="yes" xml:space="preserve">
          <source>A cast expression &lt;code&gt;cast[T](e)&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c103f838d5fa5d3771bb4e300b47d90516af782" translate="yes" xml:space="preserve">
          <source>A character is not a Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;code&gt;Rune&lt;/code&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd1dcf8b598ce13fe780f11e538b4c3679116e3" translate="yes" xml:space="preserve">
          <source>A character is not an Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">Un car&amp;aacute;cter no es un car&amp;aacute;cter Unicode sino un solo byte. La raz&amp;oacute;n de esto es la eficiencia: para la gran mayor&amp;iacute;a de los casos de uso, los programas resultantes seguir&amp;aacute;n manejando UTF-8 correctamente, ya que UTF-8 fue dise&amp;ntilde;ado especialmente para esto. Otra raz&amp;oacute;n es que Nim puede, por tanto, admitir &lt;code&gt;array[char, int]&lt;/code&gt; o &lt;code&gt;set[char]&lt;/code&gt; eficiente, ya que muchos algoritmos se basan en esta caracter&amp;iacute;stica. El tipo &lt;em&gt;Rune&lt;/em&gt; se utiliza para caracteres Unicode, puede representar cualquier car&amp;aacute;cter Unicode. &lt;code&gt;Rune&lt;/code&gt; se declara en el &lt;a href=&quot;unicode&quot;&gt;m&amp;oacute;dulo Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02438431477b9f284f329a8125ca2c9ad9d3544e" translate="yes" xml:space="preserve">
          <source>A color stored as RGB, e.g. &lt;code&gt;0xff00cc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464ccfc3644339c90fe83b96ac6cc6d2ac6904e3" translate="yes" xml:space="preserve">
          <source>A command-line switch &lt;code&gt;--FOO&lt;/code&gt; is written as &lt;code&gt;switch(&quot;FOO&quot;)&lt;/code&gt; in NimScript. Similarly, command-line &lt;code&gt;--FOO:VAL&lt;/code&gt; translates to &lt;code&gt;switch(&quot;FOO&quot;, &quot;VAL&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a21ba557cb1102184eb887daf5fb2f0ee516b2" translate="yes" xml:space="preserve">
          <source>A compile-time error will be produced if the supplied type is not generic.</source>
          <target state="translated">Se producirá un error en tiempo de compilación si el tipo suministrado no es genérico.</target>
        </trans-unit>
        <trans-unit id="9e63142b740226a78a46d8a1af8bf22743ac95c8" translate="yes" xml:space="preserve">
          <source>A config file was loaded.</source>
          <target state="translated">Se cargó un archivo de configuración.</target>
        </trans-unit>
        <trans-unit id="4e0bfb8692e714161fc85476e6dc2bea3acca4aa" translate="yes" xml:space="preserve">
          <source>A const section declares constants whose values are constant expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b8c94d978f3588a0582bb78409af7deb66813e" translate="yes" xml:space="preserve">
          <source>A constant array/seq/object/tuple constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0064db9e288278b0376c2e5e320a96dacd41e609" translate="yes" xml:space="preserve">
          <source>A constant expression can contain code blocks that may internally use all Nim features supported at compile time (as detailed in the next section below). Within such a code block, it is possible to declare variables and then later read and update them, or declare variables and pass them to procedures that modify them. However, the code in such a block must still adhere to the restrictions listed above for referencing values and operations outside the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d676346fde6cb6856b2edfe8fcc862ca9818983" translate="yes" xml:space="preserve">
          <source>A contains element e</source>
          <target state="translated">A contiene el elemento e</target>
        </trans-unit>
        <trans-unit id="a97fa9396c800de48716801c7cc433f027d4fd9e" translate="yes" xml:space="preserve">
          <source>A convenience proc for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be06b381f65f6401540a9a933e32c54008aff8d5" translate="yes" xml:space="preserve">
          <source>A convenience proc that runs the &lt;code&gt;command&lt;/code&gt;, and returns its &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;exitCode&lt;/code&gt;. &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;workingDir&lt;/code&gt; params behave as for &lt;code&gt;startProcess&lt;/code&gt;. If &lt;code&gt;input.len &amp;gt; 0&lt;/code&gt;, it is passed as stdin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacfb1ec37d6c63df0aece0717105dfb5b1e961d" translate="yes" xml:space="preserve">
          <source>A convenience procedure that executes &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;startProcess&lt;/code&gt; and returns its output as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd669926d307684088d5ef478be7b22480b9a5f4" translate="yes" xml:space="preserve">
          <source>A convenience procedure that executes &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;startProcess&lt;/code&gt; and returns its output as a string. WARNING: this function uses poEvalCommand by default for backward compatibility. Make sure to pass options explicitly.</source>
          <target state="translated">Un procedimiento de conveniencia que ejecuta un &lt;code&gt;command&lt;/code&gt; con &lt;code&gt;startProcess&lt;/code&gt; y devuelve su salida como una cadena. ADVERTENCIA: esta funci&amp;oacute;n usa poEvalCommand por defecto para compatibilidad con versiones anteriores. Aseg&amp;uacute;rese de pasar las opciones expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="d5eda57047be93a6d8ede446c939b622a61fcad5" translate="yes" xml:space="preserve">
          <source>A convention is that exceptions should be raised in &lt;em&gt;exceptional&lt;/em&gt; cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).</source>
          <target state="translated">Una convenci&amp;oacute;n es que se deben generar excepciones en casos &lt;em&gt;excepcionales&lt;/em&gt; : por ejemplo, si un archivo no se puede abrir, esto no debe generar una excepci&amp;oacute;n ya que esto es bastante com&amp;uacute;n (el archivo puede no existir).</target>
        </trans-unit>
        <trans-unit id="9dc4e7e8a36779be1253db430e17a3ece42f97f6" translate="yes" xml:space="preserve">
          <source>A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided.</source>
          <target state="translated">También se puede invocar explícitamente un convertidor para mejorar la legibilidad.Obsérvese que no se admite el encadenamiento implícito de convertidores:Si hay un convertidor de tipo A a tipo B y de tipo B a tipo C,no se proporciona la conversión implícita de A a C.</target>
        </trans-unit>
        <trans-unit id="0fabf98da32833f2ac2d72c57027f686f2dbd28b" translate="yes" xml:space="preserve">
          <source>A converter is like an ordinary proc except that it enhances the &quot;implicitly convertible&quot; type relation (see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;):</source>
          <target state="translated">Un convertidor es como un proceso ordinario, excepto que mejora la relaci&amp;oacute;n de tipo &quot;impl&amp;iacute;citamente convertible&quot; (ver &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Relaci&amp;oacute;n convertible&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="ff0115af818672bc6f62e11d492d4642e32f4663" translate="yes" xml:space="preserve">
          <source>A converter is similar to a proc.</source>
          <target state="translated">Un convertidor es similar a un proc.</target>
        </trans-unit>
        <trans-unit id="95b68e940e0a6eefa4655d5db413050f4aee06c6" translate="yes" xml:space="preserve">
          <source>A curly expression with commas in it like &lt;code&gt;{x, argA, argB}&lt;/code&gt; could be transformed to &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</source>
          <target state="translated">Una expresi&amp;oacute;n rizada con comas como &lt;code&gt;{x, argA, argB}&lt;/code&gt; podr&amp;iacute;a transformarse a &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; para admitir formateadores que no necesitan analizar un idioma personalizado dentro de un idioma personalizado, sino que prefieren para utilizar la sintaxis existente de Nim. Esto tambi&amp;eacute;n ayuda a mejorar la legibilidad, ya que hay una cantidad limitada que puede incluir en DSL de una sola letra.</target>
        </trans-unit>
        <trans-unit id="dfc4ab3114e21dfe437697844b567a3fec4ddcb5" translate="yes" xml:space="preserve">
          <source>A curly expression with commas in it like &lt;code&gt;{x, argA, argB}&lt;/code&gt; could be transformed to &lt;code&gt;formatValue(result, x, argA, argB)&lt;/code&gt; in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fa03d2d9ca46b9edc2c32896fd2039415253ab" translate="yes" xml:space="preserve">
          <source>A data flow variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af339bf252ebc6686a22fa957452c6666fabae1d" translate="yes" xml:space="preserve">
          <source>A destructible context is currently only the following:</source>
          <target state="translated">Un contexto destructible es actualmente sólo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a4828b4e1e76af08cdc61d3da41001844c8e7647" translate="yes" xml:space="preserve">
          <source>A destructor is attached to the type it destructs; expressions of this type can then only be used in &lt;em&gt;destructible contexts&lt;/em&gt; and as parameters:</source>
          <target state="translated">Un destructor se adjunta al tipo que destruye; Las expresiones de este tipo solo se pueden usar en &lt;em&gt;contextos destructibles&lt;/em&gt; y como par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="5433f8711be01e7d00dc897cddea4967983783a7" translate="yes" xml:space="preserve">
          <source>A destructor must have a single parameter with a concrete type (the name of a generic type is allowed too). The name of the destructor has to be &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="translated">Un destructor debe tener un solo par&amp;aacute;metro con un tipo concreto (tambi&amp;eacute;n se permite el nombre de un tipo gen&amp;eacute;rico). El nombre del destructor tiene que ser &lt;code&gt;=destroy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b51be317d37d0d9e5679921ffa2c4f39470a9227" translate="yes" xml:space="preserve">
          <source>A directory can also be a so called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</source>
          <target state="translated">Un directorio también puede ser un llamado &quot;pseudo directorio&quot;.Se pueden utilizar para evitar la ambigüedad cuando hay varios módulos con la misma ruta.</target>
        </trans-unit>
        <trans-unit id="ba9a4b41df6580ad5e8acb6a3c21939ab2ed47ab" translate="yes" xml:space="preserve">
          <source>A directory can also be a so-called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e50b8a4c29848e0e58c481e1f4e2be74e28e1a" translate="yes" xml:space="preserve">
          <source>A distinct string type that is &lt;span id=&quot;tainted_1&quot;&gt;tainted&lt;/span&gt;, see &lt;a href=&quot;manual_experimental#taint-mode&quot;&gt;taint mode&lt;/a&gt; for details. It is an alias for &lt;code&gt;string&lt;/code&gt; if the taint mode is not turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2010acb176bc59e66e9596fccd16c6be234aa62b" translate="yes" xml:space="preserve">
          <source>A distinct type can be used to model different physical &lt;span id=&quot;units_1&quot;&gt;units&lt;/span&gt; with a numerical base type, for example. The following example models currencies.</source>
          <target state="translated">Se puede utilizar un tipo diferenciado para modelar diferentes &lt;span id=&quot;units_1&quot;&gt;unidades&lt;/span&gt; f&amp;iacute;sicas con un tipo de base num&amp;eacute;rica, por ejemplo. El siguiente ejemplo modela monedas.</target>
        </trans-unit>
        <trans-unit id="5b70baaf6a3c1cf02cffd9a4c12db14e78c7e2e0" translate="yes" xml:space="preserve">
          <source>A distinct type is an ordinal type if its base type is an ordinal type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcbf503ecd251b550b20573f306de222e9f6e39" translate="yes" xml:space="preserve">
          <source>A does not contain element e</source>
          <target state="translated">A no contiene el elemento e</target>
        </trans-unit>
        <trans-unit id="7339291827f4b694e439170ba77d07b22a6ba2d9" translate="yes" xml:space="preserve">
          <source>A dot following the hash &lt;code&gt;#.&lt;/code&gt; indicates that the call should use C++'s dot or arrow notation.</source>
          <target state="translated">Un punto que sigue al hash &lt;code&gt;#.&lt;/code&gt; indica que la llamada debe usar la notaci&amp;oacute;n de puntos o flechas de C ++.</target>
        </trans-unit>
        <trans-unit id="91daa2e8d1d787e2cb1cebec501d70a447fbdd47" translate="yes" xml:space="preserve">
          <source>A double quotation mark preceded by a backslash (&quot;) is interpreted as a literal double quotation mark character (&quot;).</source>
          <target state="translated">Una comilla doble precedida de una barra invertida (&quot;)se interpreta como una comilla doble literal (&quot;).</target>
        </trans-unit>
        <trans-unit id="5b983689cc856655c0945357d3fc5752f335fd52" translate="yes" xml:space="preserve">
          <source>A double-ended queue backed with a ringed seq buffer.</source>
          <target state="translated">Una cola de doble final respaldada con un buffer secuencial anillado.</target>
        </trans-unit>
        <trans-unit id="37b3c8d877a1796e2ce2b752a84672e2b698b73f" translate="yes" xml:space="preserve">
          <source>A doubly linked list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc610ca5779e2c4149fb2f04ff29af536258d4e9" translate="yes" xml:space="preserve">
          <source>A doubly linked ring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca1163da7023e239f0374687ad85cf02cf7bedd" translate="yes" xml:space="preserve">
          <source>A faster approach if you don't need to run the full bootstrapping implied by &lt;code&gt;koch boot&lt;/code&gt;, is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec95403df4da1203b32ec4a5895c4b2f97d7469" translate="yes" xml:space="preserve">
          <source>A file stream object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ed7c56b187204e313f1f9d97ebfebcc0fecee3" translate="yes" xml:space="preserve">
          <source>A for loop variable.</source>
          <target state="translated">A de variable de bucle.</target>
        </trans-unit>
        <trans-unit id="be05d01928ee989b51c293af8a8ced991ffc3f8b" translate="yes" xml:space="preserve">
          <source>A formal parameter of &lt;code&gt;p&lt;/code&gt;. Note that this does not cover parameters of inner procs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4530327f82b08f79eb5415f2f6266f23e82dea1" translate="yes" xml:space="preserve">
          <source>A friendlier version of &lt;code&gt;initRational&lt;/code&gt;. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d654b825945bd5f2a34963e2ce499f362a2a00c" translate="yes" xml:space="preserve">
          <source>A friendlier version of &lt;em&gt;initRational&lt;/em&gt;. Example usage:</source>
          <target state="translated">Una versi&amp;oacute;n m&amp;aacute;s amigable de &lt;em&gt;initRational&lt;/em&gt; . Uso de ejemplo:</target>
        </trans-unit>
        <trans-unit id="d411518da35d7d553e49043b1323d3beb87db97b" translate="yes" xml:space="preserve">
          <source>A generic hash set that remembers insertion order.</source>
          <target state="translated">Un juego de hachís genérico que recuerda el orden de inserción.</target>
        </trans-unit>
        <trans-unit id="e82bc7694d12c8d0a1eda93534f23d36363f6058" translate="yes" xml:space="preserve">
          <source>A generic hash set.</source>
          <target state="translated">Un juego de hachís genérico.</target>
        </trans-unit>
        <trans-unit id="bc808d927cb66e18ab41120dbc8ca9a77184e013" translate="yes" xml:space="preserve">
          <source>A global &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320cebf4d78ce3c1be14804824f001c260bf7a66" translate="yes" xml:space="preserve">
          <source>A global or thread local variable (or a location derived from such a location) can only passed to a parameter of a &lt;code&gt;.noSideEffect&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffca0b13c686c6b15efaaaca93d32f1c984c75c" translate="yes" xml:space="preserve">
          <source>A good start is to use the &lt;code&gt;any&lt;/code&gt; operating target together with the &lt;code&gt;malloc&lt;/code&gt; memory allocator and the &lt;code&gt;arc&lt;/code&gt; garbage collector. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81ac463f2bf0a449eb382ce5892e833e89db3c5" translate="yes" xml:space="preserve">
          <source>A handle that can be used to get a row's column text on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e98d244bf1a5c7aeeae52fd19acf41b5eb1f418" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;#&lt;/code&gt; symbol is replaced by the first or next argument.</source>
          <target state="translated">Un s&amp;iacute;mbolo de almohadilla &lt;code&gt;#&lt;/code&gt; se reemplaza por el primer argumento o el siguiente.</target>
        </trans-unit>
        <trans-unit id="9d4597dbb40515320cfb7ba4a5ab9fff9f4b8d6f" translate="yes" xml:space="preserve">
          <source>A hash value. Hash tables using these values should always have a size of a power of two and can use the &lt;code&gt;and&lt;/code&gt; operator instead of &lt;code&gt;mod&lt;/code&gt; for truncation of the hash value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149c44455ceb35c4ee96ca72b2281853444910fc" translate="yes" xml:space="preserve">
          <source>A heap queue, commonly known as a priority queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53f6ddc26d79601afed6742fbd39fc945dc2d24" translate="yes" xml:space="preserve">
          <source>A helper for wrapping callback-based functions into promises and async procedures</source>
          <target state="translated">Un ayudante para envolver las funciones basadas en la devolución de llamada en promesas y procedimientos de sincronización</target>
        </trans-unit>
        <trans-unit id="1cfeb2fc1a7aa8005e527ab8a5293d0f37aa50de" translate="yes" xml:space="preserve">
          <source>A higher level &lt;code&gt;ODBC&lt;/code&gt; database wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2cac0c1f19b93707af84e96c8e8344199be1d8" translate="yes" xml:space="preserve">
          <source>A higher level &lt;em&gt;ODBC&lt;/em&gt; database wrapper.</source>
          <target state="translated">Un contenedor de base de datos &lt;em&gt;ODBC de&lt;/em&gt; nivel superior .</target>
        </trans-unit>
        <trans-unit id="d7086b8bccfe459c43887557d6fccf6aaa7324be" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt; database wrapper. The same interface is implemented for other databases too.</source>
          <target state="translated">Un contenedor de base de datos &lt;span id=&quot;mysql_1&quot;&gt;mySQL de&lt;/span&gt; nivel superior . La misma interfaz tambi&amp;eacute;n se implementa para otras bases de datos.</target>
        </trans-unit>
        <trans-unit id="7ed449265b711e313a4301b54cee15ef550acdbf" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt; database wrapper. This interface is implemented for other databases also.</source>
          <target state="translated">Un contenedor de &lt;span id=&quot;postgresql_1&quot;&gt;base de&lt;/span&gt; datos &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL de&lt;/span&gt; nivel superior . Esta interfaz tambi&amp;eacute;n se implementa para otras bases de datos.</target>
        </trans-unit>
        <trans-unit id="18d9c046b2d8f8fc8c6daccb16db460900a01a66" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt; database wrapper. This interface is implemented for other databases too.</source>
          <target state="translated">Un contenedor de &lt;span id=&quot;sqlite_1&quot;&gt;base de&lt;/span&gt; datos &lt;span id=&quot;sqlite_1&quot;&gt;SQLite de&lt;/span&gt; nivel superior . Esta interfaz tambi&amp;eacute;n est&amp;aacute; implementada para otras bases de datos.</target>
        </trans-unit>
        <trans-unit id="17cc08bc05f9e3c22bbf4a01b73d4951016af63c" translate="yes" xml:space="preserve">
          <source>A label (used in &lt;code&gt;block&lt;/code&gt; statements).</source>
          <target state="translated">Una etiqueta (usada en declaraciones de &lt;code&gt;block&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="89265eb4f02e06930cfb5c35dd5f76b04d9c0a16" translate="yes" xml:space="preserve">
          <source>A last tip when writing a macro: if you are not sure the AST you are building looks ok, you may be tempted to use the &lt;code&gt;dumpTree&lt;/code&gt; macro. But you can't use it &lt;em&gt;inside&lt;/em&gt; the macro you are writting/debugging. Instead &lt;code&gt;echo&lt;/code&gt; the string generated by &lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr&lt;/a&gt;. If at the end of the this example you add &lt;code&gt;echo treeRepr(result)&lt;/code&gt; you should get the same output as using the &lt;code&gt;dumpTree&lt;/code&gt; macro, but of course you can call that at any point of the macro where you might be having troubles.</source>
          <target state="translated">Un &amp;uacute;ltimo consejo al escribir una macro: si no est&amp;aacute; seguro de que el AST que est&amp;aacute; construyendo se vea bien, puede tener la tentaci&amp;oacute;n de usar la macro &lt;code&gt;dumpTree&lt;/code&gt; . Pero no puede usarlo &lt;em&gt;dentro de&lt;/em&gt; la macro que est&amp;aacute; escribiendo / depurando. En su lugar, &lt;a href=&quot;macros#treeRepr&quot;&gt;haga &lt;/a&gt; &lt;code&gt;echo&lt;/code&gt; la cadena generada por treeRepr . Si al final de este ejemplo agrega &lt;code&gt;echo treeRepr(result)&lt;/code&gt; , deber&amp;iacute;a obtener el mismo resultado que usando la macro &lt;code&gt;dumpTree&lt;/code&gt; , pero por supuesto puede llamar a eso en cualquier punto de la macro donde podr&amp;iacute;a tener problemas.</target>
        </trans-unit>
        <trans-unit id="e62c0496669da44a5936805a3cdfee1fe957384a" translate="yes" xml:space="preserve">
          <source>A leaf of the AST often corresponds to a terminal symbol in the concrete syntax. Note that the default &lt;code&gt;float&lt;/code&gt; in Nim maps to &lt;code&gt;float64&lt;/code&gt; such that the default AST for a float is &lt;code&gt;nnkFloat64Lit&lt;/code&gt; as below.</source>
          <target state="translated">Una hoja del AST a menudo corresponde a un s&amp;iacute;mbolo de terminal en la sintaxis concreta. Tenga en cuenta que el &lt;code&gt;float&lt;/code&gt; predeterminado en Nim se asigna a &lt;code&gt;float64&lt;/code&gt; ,de modo que el AST predeterminado para un flotante es &lt;code&gt;nnkFloat64Lit&lt;/code&gt; como se muestra a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ca1d57971d26f802ed23be891e23648148c8e483" translate="yes" xml:space="preserve">
          <source>A line of text may be delimited by &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;LF&lt;/code&gt; or &lt;code&gt;CRLF&lt;/code&gt;. The newline character(s) are not part of the returned string. Returns &lt;code&gt;false&lt;/code&gt; if the end of the file has been reached, &lt;code&gt;true&lt;/code&gt; otherwise. If &lt;code&gt;false&lt;/code&gt; is returned &lt;code&gt;line&lt;/code&gt; contains no new data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581948684a5ccce62ab36b49581dc62c13de2828" translate="yes" xml:space="preserve">
          <source>A line of text may be delimited by &lt;code&gt;LF&lt;/code&gt; or &lt;code&gt;CRLF&lt;/code&gt;. The newline character(s) are not part of the returned string. Returns &lt;code&gt;false&lt;/code&gt; if the end of the file has been reached, &lt;code&gt;true&lt;/code&gt; otherwise. If &lt;code&gt;false&lt;/code&gt; is returned &lt;code&gt;line&lt;/code&gt; contains no new data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a5c4a0e6620a00360c556904f05a47c92cf341" translate="yes" xml:space="preserve">
          <source>A local &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt;. Note that this does not cover locals of inner procs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c3ae6180bd4456adc133775e78037d9dbc3bb3" translate="yes" xml:space="preserve">
          <source>A local variable of a view type &lt;em&gt;borrows&lt;/em&gt; from the locations and it is statically enforced that the view does not outlive the location it was borrowed from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4f1963c6d5c717eedc6061f40a2aad389a69ee" translate="yes" xml:space="preserve">
          <source>A local variable of a view type can borrow from a location derived from a parameter, another local variable, a global &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; symbol or a thread-local &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af284b25e3830a68d5e3016b0dc1d22187bec97a" translate="yes" xml:space="preserve">
          <source>A local variable shadows another local variable of an outer scope.</source>
          <target state="translated">Una variable local ensombrece otra variable local de un alcance exterior.</target>
        </trans-unit>
        <trans-unit id="de6bcdccdc5c7e0b1b4816e44fb7d53da0a609cf" translate="yes" xml:space="preserve">
          <source>A location derived from &lt;code&gt;source&lt;/code&gt; is then defined as a path expression that has &lt;code&gt;source&lt;/code&gt; as the owner. A path expression &lt;code&gt;e&lt;/code&gt; is defined recursively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967771f695ceb39091660c735188c9512c3f76d5" translate="yes" xml:space="preserve">
          <source>A logger that writes log messages to a file while performing log rotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a7205870823565c52ef4c52be7d4fff3d9573c" translate="yes" xml:space="preserve">
          <source>A logger that writes log messages to a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1885737ecb72a367c6c34335e96773c3da6a62" translate="yes" xml:space="preserve">
          <source>A logger that writes log messages to the console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fde29a5bcb0f41a42b7a89bca04718dd4f756c" translate="yes" xml:space="preserve">
          <source>A macro is a special function that is executed at compile time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. This can be used to add custom language features and implement &lt;span id=&quot;domainminusspecific-languages_1&quot;&gt;domain-specific languages&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15ac9d0ba716c535ed2ce2885c3b9d90285db47" translate="yes" xml:space="preserve">
          <source>A macro is a special function that is executed at compile-time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. The transformed AST is then passed to the compiler as if the macro invocation would have been replaced by its result in the source code. This can be used to implement &lt;span id=&quot;domain-specific-languages_1&quot;&gt;domain specific languages&lt;/span&gt;.</source>
          <target state="translated">Una macro es una funci&amp;oacute;n especial que se ejecuta en tiempo de compilaci&amp;oacute;n. Normalmente, la entrada para una macro es un &amp;aacute;rbol de sintaxis abstracta (AST) del c&amp;oacute;digo que se le pasa. La macro puede entonces hacer transformaciones en ella y devolver el AST transformado. El AST transformado luego se pasa al compilador como si la invocaci&amp;oacute;n de la macro hubiera sido reemplazada por su resultado en el c&amp;oacute;digo fuente. Esto se puede utilizar para implementar &lt;span id=&quot;domain-specific-languages_1&quot;&gt;lenguajes espec&amp;iacute;ficos de dominio&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="2320939f622f35d906ef2dffec7b8d388f8158e3" translate="yes" xml:space="preserve">
          <source>A macro that needs to be called &lt;span id=&quot;match_1&quot;&gt;match&lt;/span&gt; can be used to rewrite &lt;code&gt;case&lt;/code&gt; statements in order to implement &lt;span id=&quot;pattern-matching_1&quot;&gt;pattern matching&lt;/span&gt; for certain types. The following example implements a simplistic form of pattern matching for tuples, leveraging the existing equality operator for tuples (as provided in &lt;code&gt;system.==&lt;/code&gt;):</source>
          <target state="translated">Una macro que debe llamarse &lt;span id=&quot;match_1&quot;&gt;coincidencia&lt;/span&gt; se puede utilizar para reescribir declaraciones de &lt;code&gt;case&lt;/code&gt; a fin de implementar &lt;span id=&quot;pattern-matching_1&quot;&gt;la coincidencia de patrones&lt;/span&gt; para ciertos tipos. El siguiente ejemplo implementa una forma simplista de coincidencia de patrones para tuplas, aprovechando el operador de igualdad existente para tuplas (como se proporciona en &lt;code&gt;system.==&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c4a6d2ce7ae67ff08002aecf71f9b696f9005b38" translate="yes" xml:space="preserve">
          <source>A macro that takes as its only input parameter an expression of the special type &lt;code&gt;system.ForLoopStmt&lt;/code&gt; can rewrite the entirety of a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Una macro que toma como &amp;uacute;nico par&amp;aacute;metro de entrada una expresi&amp;oacute;n del tipo especial &lt;code&gt;system.ForLoopStmt&lt;/code&gt; puede reescribir la totalidad de un bucle &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d8df2d80cd89e184b1f75f28697093931c58d398" translate="yes" xml:space="preserve">
          <source>A module alias can be introduced via the &lt;code&gt;as&lt;/code&gt; keyword:</source>
          <target state="translated">Se puede introducir un alias de m&amp;oacute;dulo mediante la palabra clave &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4afefca445f32ee9a9bac5a6c407d25bf9bc289" translate="yes" xml:space="preserve">
          <source>A module's top-level statements are executed at the start of the program. This can be used to initialize complex data structures for example.</source>
          <target state="translated">Las declaraciones de alto nivel de un módulo se ejecutan al inicio del programa.Esto puede ser usado para inicializar estructuras de datos complejas,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="2b9f547cf5da6cf041f0968e82f074d18fced352" translate="yes" xml:space="preserve">
          <source>A more verbose format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e4a688e683942c8ad5fb732b7301d65e5d80ef" translate="yes" xml:space="preserve">
          <source>A mutable view can borrow from a mutable location, an immutable view can borrow from both a mutable or an immutable location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99c0a025e79be3ef687fadc0cc6086e9682f6fb" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;main&lt;/code&gt; async procedure must be declared to allow the use of the &lt;code&gt;await&lt;/code&gt; keyword. The connection will complete asynchronously and the client will be connected after the &lt;code&gt;await ftp.connect()&lt;/code&gt; call.</source>
          <target state="translated">Se debe declarar un nuevo procedimiento asincr&amp;oacute;nico &lt;code&gt;main&lt;/code&gt; para permitir el uso de la palabra clave &lt;code&gt;await&lt;/code&gt; . La conexi&amp;oacute;n se completar&amp;aacute; de forma asincr&amp;oacute;nica y el cliente se conectar&amp;aacute; despu&amp;eacute;s de la llamada &lt;code&gt;await ftp.connect()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e04b575e1abdecefebfd435f79a2eb878c9a4af" translate="yes" xml:space="preserve">
          <source>A new entry will be added to the index using the format &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt;. The file part will come from the &lt;code&gt;htmlFile&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f09c089b0b64dd84f87655d31d40b67c7f610c" translate="yes" xml:space="preserve">
          <source>A new entry will be added to the index using the format &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt;. The file part will come from the &lt;em&gt;htmlFile&lt;/em&gt; parameter.</source>
          <target state="translated">Se agregar&amp;aacute; una nueva entrada al &amp;iacute;ndice usando el &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt; formato &amp;lt;tab&amp;gt; file # id . La parte del archivo vendr&amp;aacute; del par&amp;aacute;metro &lt;em&gt;htmlFile&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="503fc2fb8da50eec2dc57fabea1722757a7c3f4b" translate="yes" xml:space="preserve">
          <source>A node a doubly linked list consists of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf45682c2b0a00aed4a954df976fbf3f14b1755" translate="yes" xml:space="preserve">
          <source>A node a singly linked list consists of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc67102da94ccd07b62bc7ef2e58c87c378eee76" translate="yes" xml:space="preserve">
          <source>A non-error message that may indicate a potential problem rising or impacted performance.</source>
          <target state="translated">Un mensaje no erróneo que puede indicar un posible problema de aumento o impacto en el rendimiento.</target>
        </trans-unit>
        <trans-unit id="25460adb88b704ee96f5be8babcbcef40eb101b1" translate="yes" xml:space="preserve">
          <source>A parallel section can be used to execute a block in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911a5ad83db128f4812253b45faa46d98027ca72" translate="yes" xml:space="preserve">
          <source>A parameter &lt;code&gt;p&lt;/code&gt; in a template is even substituted in the expression &lt;code&gt;x.p&lt;/code&gt;. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</source>
          <target state="translated">Un par&amp;aacute;metro &lt;code&gt;p&lt;/code&gt; en una plantilla incluso se sustituye en la expresi&amp;oacute;n &lt;code&gt;x.p&lt;/code&gt; . Por lo tanto, los argumentos de plantilla se pueden usar como nombres de campo y un s&amp;iacute;mbolo global se puede sombrear con el mismo nombre de argumento incluso cuando est&amp;aacute; completamente calificado:</target>
        </trans-unit>
        <trans-unit id="b19cf459adbb632e3345bc4ce82a5563aa028fe2" translate="yes" xml:space="preserve">
          <source>A parameter may be declared with a default value which is used if the caller does not provide a value for the argument.</source>
          <target state="translated">Se puede declarar un parámetro con un valor por defecto que se utiliza si el llamante no proporciona un valor para el argumento.</target>
        </trans-unit>
        <trans-unit id="ed0815dccd26d3ba56f0da6c46ce7039b02d5cc0" translate="yes" xml:space="preserve">
          <source>A parameter of type &lt;code&gt;typedesc&lt;/code&gt; is itself usable as a type. If it is used as a type, it's the underlying type. (In other words, one level of &quot;typedesc&quot;-ness is stripped off:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0e5a46bea204df5866abc8071f4ce20c751ed1" translate="yes" xml:space="preserve">
          <source>A parameter of type &lt;code&gt;untyped&lt;/code&gt; always matches any argument (as long as there is any argument passed to it).</source>
          <target state="translated">Un par&amp;aacute;metro de tipo sin &lt;code&gt;untyped&lt;/code&gt; siempre coincide con cualquier argumento (siempre que se le pase alg&amp;uacute;n argumento).</target>
        </trans-unit>
        <trans-unit id="dbc7adf040bff90855d92e494801c3ab8308d57e" translate="yes" xml:space="preserve">
          <source>A pattern expression can be bound to a pattern parameter via the &lt;code&gt;expr{param}&lt;/code&gt; notation:</source>
          <target state="translated">Una expresi&amp;oacute;n de patr&amp;oacute;n se puede vincular a un par&amp;aacute;metro de patr&amp;oacute;n mediante la notaci&amp;oacute;n &lt;code&gt;expr{param}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d9da87b86afb0dda3edfe16aedb515e092f61c8" translate="yes" xml:space="preserve">
          <source>A pattern like &lt;code&gt;v[] = value&lt;/code&gt; or &lt;code&gt;v.field = value&lt;/code&gt; marks &lt;code&gt;G(v)&lt;/code&gt; as mutated. After the second pass a set of disjoint graphs was computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7da0c1938417b6de5ea835934b0645328e2b773" translate="yes" xml:space="preserve">
          <source>A possible common use case for &lt;code&gt;rsplit&lt;/code&gt; is path manipulation, particularly on systems that don't use a common delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84dbef3c0526b967ebfd2aa664f1b6a0e87d7f54" translate="yes" xml:space="preserve">
          <source>A possible common use case for &lt;em&gt;rsplit&lt;/em&gt; is path manipulation, particularly on systems that don't use a common delimiter.</source>
          <target state="translated">Un posible caso de uso com&amp;uacute;n de &lt;em&gt;rsplit&lt;/em&gt; es la manipulaci&amp;oacute;n de rutas, particularmente en sistemas que no usan un delimitador com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="468ffea579d79393dcb2eb8fd23d5f70574b0406" translate="yes" xml:space="preserve">
          <source>A proc can be marked with the &lt;code&gt;asmNoStackFrame&lt;/code&gt; pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like &lt;code&gt;return result;&lt;/code&gt; generated and the generated C function is declared as &lt;code&gt;__declspec(naked)&lt;/code&gt; or &lt;code&gt;__attribute__((naked))&lt;/code&gt; (depending on the used C compiler).</source>
          <target state="translated">Un proc se puede marcar con el pragma &lt;code&gt;asmNoStackFrame&lt;/code&gt; para decirle al compilador que no debe generar un marco de pila para el proc. Tampoco hay declaraciones de salida como &lt;code&gt;return result;&lt;/code&gt; generado y la funci&amp;oacute;n de C generada se declara como &lt;code&gt;__declspec(naked)&lt;/code&gt; o &lt;code&gt;__attribute__((naked))&lt;/code&gt; (seg&amp;uacute;n el compilador de C utilizado).</target>
        </trans-unit>
        <trans-unit id="552722100e5b68806260a435d2f96223b24f84ed" translate="yes" xml:space="preserve">
          <source>A proc defined as &lt;code&gt;f=&lt;/code&gt; (with the trailing &lt;code&gt;=&lt;/code&gt;) is called a &lt;span id=&quot;setter_1&quot;&gt;setter&lt;/span&gt;. A setter can be called explicitly via the common backticks notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451fbc26f5ae1ee9316fb78b0e6ca76aa2f9e794" translate="yes" xml:space="preserve">
          <source>A proc that is executed as a new thread of execution should be marked by the &lt;code&gt;thread&lt;/code&gt; pragma for reasons of readability. The compiler checks for violations of the &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;no heap sharing restriction&lt;/span&gt;: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.</source>
          <target state="translated">Un proceso que se ejecuta como un nuevo subproceso de ejecuci&amp;oacute;n debe estar marcado por el &lt;code&gt;thread&lt;/code&gt; pragma por razones de legibilidad. El compilador comprueba si hay violaciones de la &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;restricci&amp;oacute;n de no compartir&lt;/span&gt; montones: esta restricci&amp;oacute;n implica que no es v&amp;aacute;lido construir una estructura de datos que consista en memoria asignada desde diferentes montones (subprocesos locales).</target>
        </trans-unit>
        <trans-unit id="31ee225123a881826db3daa3362c06b25bf61005" translate="yes" xml:space="preserve">
          <source>A proc that is executed as a new thread of execution should be marked by the &lt;code&gt;thread&lt;/code&gt; pragma for reasons of readability. The compiler checks for violations of the &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;no heap sharing restriction&lt;/span&gt;: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread-local) heaps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f7a283eb6acfde98dfa18ad4771346a71dcb69" translate="yes" xml:space="preserve">
          <source>A proc, converter or iterator may return a &lt;code&gt;var&lt;/code&gt; type which means that the returned value is an l-value and can be modified by the caller:</source>
          <target state="translated">Un proceso, convertidor o iterador puede devolver un tipo &lt;code&gt;var&lt;/code&gt; ,lo que significa que el valor devuelto es un valor l y puede ser modificado por la persona que llama:</target>
        </trans-unit>
        <trans-unit id="367fd0ee661d0f037657253ea1206098af391bb7" translate="yes" xml:space="preserve">
          <source>A proc, converter, or iterator may return a &lt;code&gt;var&lt;/code&gt; type which means that the returned value is an l-value and can be modified by the caller:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba9d6d1f4765955e60cabd2afda1cfb0cacfe70" translate="yes" xml:space="preserve">
          <source>A procedural type is a (somewhat abstract) pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">Un tipo de procedimiento es un puntero (algo abstracto) a un procedimiento. &lt;code&gt;nil&lt;/code&gt; es un valor permitido para una variable de tipo procedimental. Nim utiliza tipos de procedimiento para lograr t&amp;eacute;cnicas de programaci&amp;oacute;n &lt;span id=&quot;functional_1&quot;&gt;funcional&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="dbca622df4cb9e116b8115ae0a141864eed44cd7" translate="yes" xml:space="preserve">
          <source>A procedural type is internally a pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for variables of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">Un tipo de procedimiento es internamente un puntero a un procedimiento. &lt;code&gt;nil&lt;/code&gt; es un valor permitido para variables de tipo procedimental. Nim utiliza tipos de procedimiento para lograr t&amp;eacute;cnicas de programaci&amp;oacute;n &lt;span id=&quot;functional_1&quot;&gt;funcional&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="bf770f6e5979c1f778e9340dd0cdb848252fa2f0" translate="yes" xml:space="preserve">
          <source>A procedure may call itself recursively.</source>
          <target state="translated">Un procedimiento puede llamarse a sí mismo recursivamente.</target>
        </trans-unit>
        <trans-unit id="198d46da979417aa29b92d0cafdd5b26b6aa26bb" translate="yes" xml:space="preserve">
          <source>A procedure that returns a value has an implicit &lt;code&gt;result&lt;/code&gt; variable declared that represents the return value. A &lt;code&gt;return&lt;/code&gt; statement with no expression is a shorthand for &lt;code&gt;return result&lt;/code&gt;. The &lt;code&gt;result&lt;/code&gt; value is always returned automatically at the end of a procedure if there is no &lt;code&gt;return&lt;/code&gt; statement at the exit.</source>
          <target state="translated">Un procedimiento que devuelve un valor tiene una variable de &lt;code&gt;result&lt;/code&gt; ado impl&amp;iacute;cita declarada que representa el valor de retorno. Una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; sin expresi&amp;oacute;n es una forma abreviada de &lt;code&gt;return result&lt;/code&gt; . El valor del &lt;code&gt;result&lt;/code&gt; ado siempre se devuelve autom&amp;aacute;ticamente al final de un procedimiento si no hay una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; en la salida.</target>
        </trans-unit>
        <trans-unit id="4479e2a3631b65d0dd4c690b9db368a8f3b1652a" translate="yes" xml:space="preserve">
          <source>A project can also have a project specific configuration file named &lt;code&gt;$project.nim.cfg&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the &lt;code&gt;--skipProjCfg&lt;/code&gt; command line option.</source>
          <target state="translated">Un proyecto tambi&amp;eacute;n puede tener un archivo de configuraci&amp;oacute;n espec&amp;iacute;fico del proyecto llamado &lt;code&gt;$project.nim.cfg&lt;/code&gt; que reside en el mismo directorio que &lt;code&gt;$project.nim&lt;/code&gt; . Este archivo se puede omitir con la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--skipProjCfg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c839c97c3ceb25609fba06432f83144cef5a572e" translate="yes" xml:space="preserve">
          <source>A project can also have a project specific configuration file named &lt;code&gt;$project.nims&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the same &lt;code&gt;--skipProjCfg&lt;/code&gt; command line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75c52d2971823fc8165afd59430cb71ab2e4981" translate="yes" xml:space="preserve">
          <source>A project can also have a project-specific configuration file named &lt;code&gt;$project.nim.cfg&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the &lt;code&gt;--skipProjCfg&lt;/code&gt; command-line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60afd1721ef96b7c6739e2759b02cb38c2c2d8c" translate="yes" xml:space="preserve">
          <source>A proxy can be specified as a param to any of the procedures defined in this module. To do this, use the &lt;code&gt;newProxy&lt;/code&gt; constructor. Unfortunately, only basic authentication is supported at the moment.</source>
          <target state="translated">Se puede especificar un proxy como par&amp;aacute;metro para cualquiera de los procedimientos definidos en este m&amp;oacute;dulo. Para hacer esto, use el constructor &lt;code&gt;newProxy&lt;/code&gt; . Desafortunadamente, solo se admite la autenticaci&amp;oacute;n b&amp;aacute;sica en este momento.</target>
        </trans-unit>
        <trans-unit id="df4503ea30137e4c7e9a09a528fd25af20fa134a" translate="yes" xml:space="preserve">
          <source>A range with all bit positions for type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac1d47b4a0730fb9551845dd67bf5ea00259685" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:</source>
          <target state="translated">Una expresión regular es un patrón que se ajusta a una cadena de sujetos de izquierda a derecha.La mayoría de los caracteres se mantienen en un patrón,y coinciden con los caracteres correspondientes en el sujeto.Como un ejemplo trivial,el patrón:</target>
        </trans-unit>
        <trans-unit id="5df947512d73d9e3cb7375e44d4a39fd584e964d" translate="yes" xml:space="preserve">
          <source>A routine &lt;code&gt;p&lt;/code&gt; matches better than a routine &lt;code&gt;q&lt;/code&gt; if the following algorithm returns true:</source>
          <target state="translated">Una rutina &lt;code&gt;p&lt;/code&gt; coincide mejor que una rutina &lt;code&gt;q&lt;/code&gt; si el siguiente algoritmo devuelve verdadero:</target>
        </trans-unit>
        <trans-unit id="97aab15d52550bb71a657dbacc087e3c7b88fc5c" translate="yes" xml:space="preserve">
          <source>A row in a CSV file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbfe11a28e5b832e2b506efe04714f8406548dc" translate="yes" xml:space="preserve">
          <source>A row of a dataset. &lt;code&gt;NULL&lt;/code&gt; database values will be converted to an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdff97566890f772e04c8438a24bb2cbb00af4bb" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents::</source>
          <target state="translated">Un segundo uso de la barra invertida proporciona una forma de codificar los caracteres no impresos en patrones de manera visible.No existe ninguna restricción en cuanto a la apariencia de los caracteres no imprimibles,aparte del cero binario que termina un patrón,pero cuando se prepara un patrón mediante la edición de texto,suele ser más fácil utilizar una de las siguientes secuencias de escape que el carácter binario que representa::</target>
        </trans-unit>
        <trans-unit id="3eac564020abe821a021c684a0c7e182c5615b2f" translate="yes" xml:space="preserve">
          <source>A section you should use to mark &lt;span id=&quot;runnable-example_1&quot;&gt;runnable example&lt;/span&gt; code with.</source>
          <target state="translated">Una secci&amp;oacute;n que debe usar para marcar el c&amp;oacute;digo de &lt;span id=&quot;runnable-example_1&quot;&gt;ejemplo ejecutable&lt;/span&gt; con.</target>
        </trans-unit>
        <trans-unit id="d3b57f32de0396cba5ad9e9d00b3af349a475164" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to a parameter that is of type &lt;em&gt;open array&lt;/em&gt;.</source>
          <target state="translated">Se puede pasar una secuencia a un par&amp;aacute;metro que sea de tipo &lt;em&gt;matriz abierta&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="42f4d3d39137f32b8ca5b909c4ff4309a61d6eac" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to an openarray parameter.</source>
          <target state="translated">Se puede pasar una secuencia a un parámetro de red abierta.</target>
        </trans-unit>
        <trans-unit id="a1283ce9a305bc0127c452736c5aee8b37c6837f" translate="yes" xml:space="preserve">
          <source>A set of directories and files from the &lt;a href=&quot;ssl_certs&quot;&gt;ssl_certs&lt;/a&gt; module are scanned to locate CA certificates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7df348109f7ffdcfedc0d707be86ae26a07b32b" translate="yes" xml:space="preserve">
          <source>A set of helpers for the POSIX module. Raw interfaces are in the other posix*.nim files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9939043c42e4aaaff588930f28e3fb87a4c1d18" translate="yes" xml:space="preserve">
          <source>A set with all the possible characters.</source>
          <target state="translated">Un conjunto con todos los personajes posibles.</target>
        </trans-unit>
        <trans-unit id="13fa5f0ea96be473acaa7e27bc838b91426d27e9" translate="yes" xml:space="preserve">
          <source>A shared GC'ed heap might be provided.</source>
          <target state="translated">Se podría proporcionar un montón de GC'ed compartido.</target>
        </trans-unit>
        <trans-unit id="3cdd59cb6410981768f626d0dcabdc2c7390dce3" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;.. ^&lt;/code&gt; to avoid the common gotcha that a space between '..' and '^' is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2fa7060937552b7002d27f41621d3222ab840b" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;a .. pred(b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec47097465bebcf2aecd8163b65ad782e31f3d56" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;switch(astToStr(key), astToStr(val))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58bd32b1554568ba7e0b99deb8afcbae405c442" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;switch(astToStr(key)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14501c8e78d3950cf5ec56e87d1f764a6e487a66" translate="yes" xml:space="preserve">
          <source>A shortcut version to assign in let blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd308d11ae6fe6d7f3bfcc6857d7ef9411ab7fa" translate="yes" xml:space="preserve">
          <source>A shorthand for &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af38f1c5146159966de284e8a35e5d86d3ab12b9" translate="yes" xml:space="preserve">
          <source>A shorthand for:</source>
          <target state="translated">Una abreviatura de:</target>
        </trans-unit>
        <trans-unit id="dac4b4b7dce5d63bf65005785b5b8b3dd2313f8a" translate="yes" xml:space="preserve">
          <source>A similar thing happens with C code invoking Nim code which returns a &lt;code&gt;cstring&lt;/code&gt;. Consider the following proc:</source>
          <target state="translated">Algo similar sucede con el c&amp;oacute;digo C que invoca el c&amp;oacute;digo Nim que devuelve un &lt;code&gt;cstring&lt;/code&gt; . Considere el siguiente proceso:</target>
        </trans-unit>
        <trans-unit id="c9daeb78be195c0138e8f11066e2c9965268a883" translate="yes" xml:space="preserve">
          <source>A simple XML tree generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48f6996b6131883f1b9650bc68f70d8d02303fe" translate="yes" xml:space="preserve">
          <source>A simple XML tree. More efficient and simpler than the DOM.</source>
          <target state="translated">Un simple árbol XML.Más eficiente y simple que el DOM.</target>
        </trans-unit>
        <trans-unit id="d71dc8f8837a2ef4b3dfcb01d114a06fb9448305" translate="yes" xml:space="preserve">
          <source>A simple barrier to wait for all &lt;code&gt;spawn&lt;/code&gt;'ed tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b881695a1cfe6f9170c0ac327d2994cb87b8beb2" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;&quot;*&quot;&lt;/code&gt; can be used for globbing.</source>
          <target state="translated">Se puede utilizar un solo &lt;code&gt;&quot;*&quot;&lt;/code&gt; para el globbing.</target>
        </trans-unit>
        <trans-unit id="9113f6bde0396b300681395640f8679539962f2e" translate="yes" xml:space="preserve">
          <source>A singly linked list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e84aababe949578ad498d01fd5372a6a6b7c3c7" translate="yes" xml:space="preserve">
          <source>A singly linked ring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e14c42493cdbd0ec02152b489b1433c8bd84c95" translate="yes" xml:space="preserve">
          <source>A sink parameter &lt;em&gt;may&lt;/em&gt; be consumed once in the proc's body but doesn't have to be consumed at all. The reason for this is that signatures like &lt;code&gt;proc put(t: var Table; k: sink Key, v: sink Value)&lt;/code&gt; should be possible without any further overloads and &lt;code&gt;put&lt;/code&gt; might not take ownership of &lt;code&gt;k&lt;/code&gt; if &lt;code&gt;k&lt;/code&gt; already exists in the table. Sink parameters enable an affine type system, not a linear type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a46cd68f2f2846ae726246b12281b2435629226" translate="yes" xml:space="preserve">
          <source>A small example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b36d665dd33efefb1f4f6b8f221af140b9aa4bd" translate="yes" xml:space="preserve">
          <source>A special type that marks a macro as a &lt;span id=&quot;forminusloop-macro_1&quot;&gt;for-loop macro&lt;/span&gt;. See &lt;a href=&quot;manual#macros-for-loop-macro&quot;&gt;&quot;For Loop Macro&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17eb06b5b98ef723497f736d4beb2106d493fd2b" translate="yes" xml:space="preserve">
          <source>A static statement/expression can be used to enforce compile time evaluation explicitly. Enforced compile time evaluation can even evaluate code that has side effects:</source>
          <target state="translated">Se puede utilizar una declaración/expresión estática para hacer cumplir la evaluación del tiempo de compilación explícitamente.La evaluación del tiempo de compilación forzada puede incluso evaluar el código que tiene efectos secundarios:</target>
        </trans-unit>
        <trans-unit id="2ea07adf0c3c6173a16c7ff5ec0740d4e2076eed" translate="yes" xml:space="preserve">
          <source>A static statement/expression explicitly requires compile-time execution. Even some code that has side effects is permitted in a static block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba79287d30f6d88058ea5ca43075dd128b9c975" translate="yes" xml:space="preserve">
          <source>A stream that encapsulates a &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0e50485f55cced7b7f2403d6ad63028a5ecfa3" translate="yes" xml:space="preserve">
          <source>A stream that encapsulates a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae845c480c00f456835854fa492599a456d01a85" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;code&gt;s1&lt;/code&gt; has all of its elements in &lt;code&gt;s2&lt;/code&gt;, but &lt;code&gt;s2&lt;/code&gt; has more elements than &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07ac55f0c8dacc1a4b7bdbadb598be3ff7f8076" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;code&gt;s&lt;/code&gt; has all of its members in &lt;code&gt;t&lt;/code&gt; but &lt;code&gt;t&lt;/code&gt; has more elements than &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199e49a636b52dd8fc54e3a6e1efcead4078f2f5" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;code&gt;x&lt;/code&gt; has all of its members in &lt;code&gt;y&lt;/code&gt; but &lt;code&gt;y&lt;/code&gt; has more elements than &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793061e8f68073a7cc2b6e8e7cb7430e9cb435af" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; but &lt;em&gt;t&lt;/em&gt; has more elements than &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Un subconjunto estricto o propio &lt;em&gt;s&lt;/em&gt; tiene todos sus miembros en &lt;em&gt;t&lt;/em&gt; pero &lt;em&gt;t&lt;/em&gt; tiene m&amp;aacute;s elementos que &lt;em&gt;s&lt;/em&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="84bd2c736b9807ca808a9e28613b62ce10e34a6b" translate="yes" xml:space="preserve">
          <source>A string stream object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692f4550479e6001b1a436a04309e4819905d924" translate="yes" xml:space="preserve">
          <source>A string surrounded by double quotation marks (&quot;string&quot;) is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</source>
          <target state="translated">Una cadena rodeada de comillas dobles (&quot;cadena&quot;)se interpreta como un único argumento,independientemente del espacio en blanco que contenga.Una cadena entre comillas puede ser incrustada en un argumento.</target>
        </trans-unit>
        <trans-unit id="70d4dbc60f1b3759a9a0ebe1370ea93bf97755e2" translate="yes" xml:space="preserve">
          <source>A string that describes the application type. Possible values: &lt;code&gt;&quot;console&quot;&lt;/code&gt;, &lt;code&gt;&quot;gui&quot;&lt;/code&gt;, &lt;code&gt;&quot;lib&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149db672045eac6dc65b46c1ba2493351adf8191" translate="yes" xml:space="preserve">
          <source>A string that describes the host CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585e2446a22a413fa5de5778d298c8f86485b6f4" translate="yes" xml:space="preserve">
          <source>A string that describes the host operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebec3b61b900cc32aa099451f2c6e12dd07c334c" translate="yes" xml:space="preserve">
          <source>A string variable is initialized with the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Una variable de cadena se inicializa con la cadena vac&amp;iacute;a &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a00e56e1710bd679d0173c57dab6fbeebbe31b" translate="yes" xml:space="preserve">
          <source>A subrange type has the same size as its base type (&lt;code&gt;int&lt;/code&gt; in the Subrange example).</source>
          <target state="translated">Un tipo de subrango tiene el mismo tama&amp;ntilde;o que su tipo base ( &lt;code&gt;int&lt;/code&gt; en el ejemplo de subrango).</target>
        </trans-unit>
        <trans-unit id="7a08933979326f8850950a1173db1b99805f1785" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an integer or enumeration type (the base type). Example:</source>
          <target state="translated">Un tipo de subgama es un rango de valores de un tipo entero o de enumeración (el tipo base).Ejemplo:</target>
        </trans-unit>
        <trans-unit id="5216761dae1ae277a963814830873f1da9e08d5b" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an ordinal or floating point type (the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type:</source>
          <target state="translated">Un tipo de subgama es un rango de valores de un tipo ordinal o de punto flotante (el tipo base).Para definir un tipo de subrango,hay que especificar sus valores límite:el valor más bajo y el más alto del tipo:</target>
        </trans-unit>
        <trans-unit id="3f24fd7c42fe941770b40eb0bc219b80b82d9b14" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an ordinal or floating-point type (the base type). To define a subrange type, one must specify its limiting values -- the lowest and highest value of the type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa613e17f732dd0c25c531cfb02c7803d1c28c45" translate="yes" xml:space="preserve">
          <source>A subset &lt;code&gt;s1&lt;/code&gt; has all of its elements in &lt;code&gt;s2&lt;/code&gt;, and &lt;code&gt;s2&lt;/code&gt; doesn't necessarily have more elements than &lt;code&gt;s1&lt;/code&gt;. That is, &lt;code&gt;s1&lt;/code&gt; can be equal to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae915dc513f286fedae6cff5178a0c89a9f424a" translate="yes" xml:space="preserve">
          <source>A subset &lt;code&gt;s&lt;/code&gt; has all of its members in &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; doesn't necessarily have more members than &lt;code&gt;s&lt;/code&gt;. That is, &lt;code&gt;s&lt;/code&gt; can be equal to &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4105f2c4e0ac639778e46c5d4f3636e4328d553a" translate="yes" xml:space="preserve">
          <source>A subset &lt;code&gt;x&lt;/code&gt; has all of its members in &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; doesn't necessarily have more members than &lt;code&gt;x&lt;/code&gt;. That is, &lt;code&gt;x&lt;/code&gt; can be equal to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05319ab331bb8be9fb80a1ea2da5bff936f37a01" translate="yes" xml:space="preserve">
          <source>A subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; and &lt;em&gt;t&lt;/em&gt; doesn't necessarily have more members than &lt;em&gt;s&lt;/em&gt;. That is, &lt;em&gt;s&lt;/em&gt; can be equal to &lt;em&gt;t&lt;/em&gt;. Example:</source>
          <target state="translated">Un subconjunto &lt;em&gt;s&lt;/em&gt; tiene todos sus miembros en &lt;em&gt;t&lt;/em&gt; y &lt;em&gt;t&lt;/em&gt; no tiene necesariamente m&amp;aacute;s miembros que &lt;em&gt;s&lt;/em&gt; . Es decir, &lt;em&gt;s&lt;/em&gt; puede ser igual a &lt;em&gt;t&lt;/em&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="23fcaa56fd8e693a2e943e96baf6a166ee24925f" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. As a special extension, a procedure of the calling convention &lt;code&gt;nimcall&lt;/code&gt; can be passed to a parameter that expects a proc of the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">Un problema sutil con los tipos de procedimiento es que la convenci&amp;oacute;n de llamada del procedimiento influye en la compatibilidad de tipos: los tipos de procedimiento solo son compatibles si tienen la misma convenci&amp;oacute;n de llamada. Como extensi&amp;oacute;n especial, un procedimiento de la convenci&amp;oacute;n de llamada &lt;code&gt;nimcall&lt;/code&gt; puede pasarse a un par&amp;aacute;metro que espera un proceso del &lt;code&gt;closure&lt;/code&gt; convenci&amp;oacute;n de llamada .</target>
        </trans-unit>
        <trans-unit id="33ba9ca12af44d34318811768b34fc09edc238c4" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the &lt;a href=&quot;manual#types-procedural-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Un problema sutil con los tipos de procedimiento es que la convenci&amp;oacute;n de llamada del procedimiento influye en la compatibilidad de tipos: los tipos de procedimiento solo son compatibles si tienen la misma convenci&amp;oacute;n de llamada. Las diferentes convenciones de llamadas se enumeran en el &lt;a href=&quot;manual#types-procedural-type&quot;&gt;manual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1fea738d80cf9eb7066f6737496184c2e3dc962" translate="yes" xml:space="preserve">
          <source>A successful dereferencing operation &lt;code&gt;p[]&lt;/code&gt; implies that &lt;code&gt;p&lt;/code&gt; is not nil. This can be exploited by the implementation to optimize code like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98d0d55b4f56cd1973186508a85d670c67f313d" translate="yes" xml:space="preserve">
          <source>A symbol can be forced to be open by a &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; declaration:</source>
          <target state="translated">Se puede forzar la apertura de un s&amp;iacute;mbolo mediante una declaraci&amp;oacute;n &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="0462b1952d8449154ce73caf7ef4db9422926829" translate="yes" xml:space="preserve">
          <source>A symbol of a module &lt;em&gt;can&lt;/em&gt; be &lt;em&gt;qualified&lt;/em&gt; with the &lt;code&gt;module.symbol&lt;/code&gt; syntax. And if a symbol is ambiguous, it &lt;em&gt;must&lt;/em&gt; be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:</source>
          <target state="translated">Un s&amp;iacute;mbolo de un m&amp;oacute;dulo &lt;em&gt;se&lt;/em&gt; puede &lt;em&gt;calificar&lt;/em&gt; con la sintaxis &lt;code&gt;module.symbol&lt;/code&gt; . Y si un s&amp;iacute;mbolo es ambiguo, &lt;em&gt;debe&lt;/em&gt; calificarse. Un s&amp;iacute;mbolo es ambiguo si est&amp;aacute; definido en dos (o m&amp;aacute;s) m&amp;oacute;dulos diferentes y ambos m&amp;oacute;dulos son importados por un tercero:</target>
        </trans-unit>
        <trans-unit id="b3a7ad38688e4496bf760973d6609aeb8d3bfad8" translate="yes" xml:space="preserve">
          <source>A symbol which is a &lt;code&gt;let&lt;/code&gt; variable.</source>
          <target state="translated">Un s&amp;iacute;mbolo que es una variable &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25afae3a203b27eb5151fb8ba040656c33e3555a" translate="yes" xml:space="preserve">
          <source>A symbol which is a constant.</source>
          <target state="translated">Un símbolo que es una constante.</target>
        </trans-unit>
        <trans-unit id="18336a58e1597be288809ec54b26b76e902b5f18" translate="yes" xml:space="preserve">
          <source>A symbol which is a converter.</source>
          <target state="translated">Un símbolo que es un convertidor.</target>
        </trans-unit>
        <trans-unit id="34e5a133463d35676b1ce7b0d26dcb4084186353" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in a tuple or an object.</source>
          <target state="translated">Un símbolo que es un campo en una tupla o un objeto.</target>
        </trans-unit>
        <trans-unit id="dbc7ff0193694a8a6df3edaa4feafaf08a548d9c" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in an enumeration.</source>
          <target state="translated">Un símbolo que es un campo en una enumeración.</target>
        </trans-unit>
        <trans-unit id="b0f4c02b65e3aca97fa198aef1b1d7f8f50540e1" translate="yes" xml:space="preserve">
          <source>A symbol which is a generic parameter.</source>
          <target state="translated">Un símbolo que es un parámetro genérico.</target>
        </trans-unit>
        <trans-unit id="cee1e54f067d3a3df195ebd26b86fefccf9d512a" translate="yes" xml:space="preserve">
          <source>A symbol which is a macro.</source>
          <target state="translated">Un símbolo que es una macro.</target>
        </trans-unit>
        <trans-unit id="8ba65c84aa50b6b4fa8d3cfd3055d6bba8e59df2" translate="yes" xml:space="preserve">
          <source>A symbol which is a method.</source>
          <target state="translated">Un símbolo que es un método.</target>
        </trans-unit>
        <trans-unit id="397a59c937f508b55f4f508768e9f30b05e604a7" translate="yes" xml:space="preserve">
          <source>A symbol which is a module.</source>
          <target state="translated">Un símbolo que es un módulo.</target>
        </trans-unit>
        <trans-unit id="2ebe7a11b22366113570683c1b68d2ed707218ec" translate="yes" xml:space="preserve">
          <source>A symbol which is a parameter.</source>
          <target state="translated">Un símbolo que es un parámetro.</target>
        </trans-unit>
        <trans-unit id="28496412faf0d454dab9dc1a6af576954c0a1ed5" translate="yes" xml:space="preserve">
          <source>A symbol which is a proc.</source>
          <target state="translated">Un símbolo que es un proc.</target>
        </trans-unit>
        <trans-unit id="b83a50e7c38bef4fa30f012bba6b90bc90afc9ea" translate="yes" xml:space="preserve">
          <source>A symbol which is a template.</source>
          <target state="translated">Un símbolo que es una plantilla.</target>
        </trans-unit>
        <trans-unit id="3462dea1dd2d1f68df6439bcca6ca7bca98f2daf" translate="yes" xml:space="preserve">
          <source>A symbol which is a type.</source>
          <target state="translated">Un símbolo que es un tipo.</target>
        </trans-unit>
        <trans-unit id="2a1357b126b87914b1b6f8a549043e8db1b4ede2" translate="yes" xml:space="preserve">
          <source>A symbol which is a variable.</source>
          <target state="translated">Un símbolo que es una variable.</target>
        </trans-unit>
        <trans-unit id="2d0634ee6e934140b8250f79b8ba8901843ddbb9" translate="yes" xml:space="preserve">
          <source>A symbol which is an iterator.</source>
          <target state="translated">Un símbolo que es un iterador.</target>
        </trans-unit>
        <trans-unit id="4e393c2bf071d79fe321a01e0a6eea1010d9f40a" translate="yes" xml:space="preserve">
          <source>A system call for device-specific input/output operations and other operations which cannot be expressed by regular system calls</source>
          <target state="translated">Una llamada de sistema para operaciones de entrada/salida de dispositivos específicos y otras operaciones que no pueden ser expresadas por las llamadas regulares del sistema</target>
        </trans-unit>
        <trans-unit id="fc9ce8dd56e57484f7771a0858bc6ea64b79d22b" translate="yes" xml:space="preserve">
          <source>A table constructor is syntactic sugar for an array constructor:</source>
          <target state="translated">Un constructor de mesa es el azúcar sintáctico para un constructor de arreglos:</target>
        </trans-unit>
        <trans-unit id="4a7a5f8021ef6500926b1cb58e60a0f63620d3dd" translate="yes" xml:space="preserve">
          <source>A table literal can be put into a &lt;code&gt;const&lt;/code&gt; section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.</source>
          <target state="translated">Un literal de tabla puede colocarse en una secci&amp;oacute;n &lt;code&gt;const&lt;/code&gt; ante y el compilador puede colocarlo f&amp;aacute;cilmente en la secci&amp;oacute;n de datos del ejecutable, al igual que para las matrices y la secci&amp;oacute;n de datos generados requiere una cantidad m&amp;iacute;nima de memoria.</target>
        </trans-unit>
        <trans-unit id="cfef19ba2df017b1840fca787af14959a3b9fbf8" translate="yes" xml:space="preserve">
          <source>A tag has to be a type name. A &lt;code&gt;tags&lt;/code&gt; list - like a &lt;code&gt;raises&lt;/code&gt; list - can also be attached to a proc type. This affects type compatibility.</source>
          <target state="translated">Una etiqueta debe ser un nombre de tipo. Una lista de &lt;code&gt;tags&lt;/code&gt; , como una lista de &lt;code&gt;raises&lt;/code&gt; , tambi&amp;eacute;n se puede adjuntar a un tipo de proceso. Esto afecta la compatibilidad de tipos.</target>
        </trans-unit>
        <trans-unit id="c7c12a1bbcf06851adacdd13e78109f4548a353d" translate="yes" xml:space="preserve">
          <source>A template is a &lt;span id=&quot;hygienic_1&quot;&gt;hygienic&lt;/span&gt; macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</source>
          <target state="translated">Una plantilla es una macro &lt;span id=&quot;hygienic_1&quot;&gt;higi&amp;eacute;nica&lt;/span&gt; y, por lo tanto, abre un nuevo &amp;aacute;mbito. La mayor&amp;iacute;a de los s&amp;iacute;mbolos est&amp;aacute;n vinculados al &amp;aacute;mbito de definici&amp;oacute;n de la plantilla:</target>
        </trans-unit>
        <trans-unit id="3d0909aebdac7146ab483112e0cffc46ee0650d8" translate="yes" xml:space="preserve">
          <source>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</source>
          <target state="translated">Una plantilla es una forma simple de una macro:Es un simple mecanismo de sustitucion que opera en los arboles de sintaxis abstracta de Nim.Se procesa en el pase semántico del compilador.</target>
        </trans-unit>
        <trans-unit id="4957f2f98151d72020ad997ae5b0177dbfe8bd70" translate="yes" xml:space="preserve">
          <source>A template where every parameter is &lt;code&gt;untyped&lt;/code&gt; is called an &lt;span id=&quot;immediate_1&quot;&gt;immediate&lt;/span&gt; template. For historical reasons templates can be explicitly annotated with an &lt;code&gt;immediate&lt;/code&gt; pragma and then these templates do not take part in overloading resolution and the parameters' types are &lt;em&gt;ignored&lt;/em&gt; by the compiler. Explicit immediate templates are now deprecated.</source>
          <target state="translated">Una plantilla en la que cada par&amp;aacute;metro &lt;code&gt;untyped&lt;/code&gt; tiene tipo se denomina plantilla &lt;span id=&quot;immediate_1&quot;&gt;inmediata&lt;/span&gt; . Por razones hist&amp;oacute;ricas, las plantillas se pueden anotar expl&amp;iacute;citamente con un pragma &lt;code&gt;immediate&lt;/code&gt; y luego estas plantillas no participan en la resoluci&amp;oacute;n de sobrecarga y el compilador &lt;em&gt;ignora&lt;/em&gt; los tipos de par&amp;aacute;metros . Las plantillas inmediatas expl&amp;iacute;citas ahora est&amp;aacute;n en desuso.</target>
        </trans-unit>
        <trans-unit id="2c5c46bd6cd44a46ae88e10ca57070a21a6c5dbc" translate="yes" xml:space="preserve">
          <source>A test suite is a series of one or more related tests sharing a common fixture (&lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt;). The fixture is executed for EACH test.</source>
          <target state="translated">Un conjunto de pruebas es una serie de una o m&amp;aacute;s pruebas relacionadas que comparten un dispositivo com&amp;uacute;n ( &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;teardown&lt;/code&gt; ). El dispositivo se ejecuta para CADA prueba.</target>
        </trans-unit>
        <trans-unit id="f697950925359df8943281d389dcc452af1b91bb" translate="yes" xml:space="preserve">
          <source>A thread is destructed when the &lt;code&gt;.thread&lt;/code&gt; proc returns normally or when it raises an exception. Note that unhandled exceptions in a thread nevertheless cause the whole process to die.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bf8aebbb82c9b930fd2c075ab23a6c84bd7bab" translate="yes" xml:space="preserve">
          <source>A thread proc is passed to &lt;code&gt;createThread&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; and invoked indirectly; so the &lt;code&gt;thread&lt;/code&gt; pragma implies &lt;code&gt;procvar&lt;/code&gt;.</source>
          <target state="translated">Se pasa un proceso de &lt;code&gt;createThread&lt;/code&gt; a createThread o &lt;code&gt;spawn&lt;/code&gt; y se invoca indirectamente; por lo que el &lt;code&gt;thread&lt;/code&gt; pragma implica &lt;code&gt;procvar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0f8163c51d43eedc6caebe9eaa4ac659b3f787e" translate="yes" xml:space="preserve">
          <source>A thread-local &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bb5d8b499e01e5a1190386e45f8f1ab3dfd432" translate="yes" xml:space="preserve">
          <source>A thunk would need to call 'returnsDefaultCC[i]' somehow and that would require an &lt;em&gt;additional&lt;/em&gt; closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem which this solution is that it's not GC-safe to pass a proc pointer around via a generic &lt;code&gt;ref&lt;/code&gt; type.</source>
          <target state="translated">Un procesador necesitar&amp;iacute;a llamar a 'returnsDefaultCC [i]' de alguna manera y eso requerir&amp;iacute;a una generaci&amp;oacute;n de cierre &lt;em&gt;adicional&lt;/em&gt; ... Ok, no realmente, pero requiere pasar la funci&amp;oacute;n para llamar. Entonces terminar&amp;iacute;amos con 2 llamadas indirectas en lugar de una. Otro problema mucho m&amp;aacute;s grave al que se enfrenta esta soluci&amp;oacute;n es que no es seguro para GC pasar un puntero proc a trav&amp;eacute;s de un tipo de &lt;code&gt;ref&lt;/code&gt; erencia gen&amp;eacute;rico .</target>
        </trans-unit>
        <trans-unit id="a3b8fb864073dd8b8ee82885b71745cbd42bd751" translate="yes" xml:space="preserve">
          <source>A timeout can be specified in milliseconds, if data is not received within the specified time a TimeoutError exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71df16ade8aee765ef43a13e09747416cdfc482" translate="yes" xml:space="preserve">
          <source>A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.</source>
          <target state="translated">Se puede especificar un tiempo de espera en milisegundos,si los datos no se reciben dentro del tiempo especificado se planteará una excepción de ETimeout.</target>
        </trans-unit>
        <trans-unit id="43dcf2374a63395e293bd9039f8d75e19cabb5f4" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified a TimeoutError exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5284b25f36831bd8cd3b0848696b52af7ef955" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</source>
          <target state="translated">Se puede especificar un tiempo de espera en milisegundos,si no se reciben suficientes datos en el tiempo especificado se planteará una excepción de ETimeout.</target>
        </trans-unit>
        <trans-unit id="b206d5f711dced99df1aa8e9ea0d1479edc748b9" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an TimeoutError exception will be raised.</source>
          <target state="translated">El tiempo de espera puede especificarse en milisegundos,si no se reciben suficientes datos en el tiempo especificado se planteará una excepción de TimeoutError.</target>
        </trans-unit>
        <trans-unit id="5a5e0bec046a288f45da3539bee961bd4b7e1bc5" translate="yes" xml:space="preserve">
          <source>A tuple type defines various named &lt;em&gt;fields&lt;/em&gt; and an &lt;em&gt;order&lt;/em&gt; of the fields. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify fields of the same type and of the same name in the same order.</source>
          <target state="translated">Un tipo de tupla define varios &lt;em&gt;campos con&lt;/em&gt; nombre y un &lt;em&gt;orden&lt;/em&gt; de los campos. El constructor &lt;code&gt;()&lt;/code&gt; se puede utilizar para construir tuplas. El orden de los campos en el constructor debe coincidir con el orden en la definici&amp;oacute;n de la tupla. Diferentes tipos de tupla son &lt;em&gt;equivalentes&lt;/em&gt; si especifican campos del mismo tipo y del mismo nombre en el mismo orden.</target>
        </trans-unit>
        <trans-unit id="5e6444b3f99eb953e87888c66966bcbc524ea4f4" translate="yes" xml:space="preserve">
          <source>A tuple with one unnamed field can be constructed with the parentheses and a trailing comma:</source>
          <target state="translated">Se puede construir una tupla con un campo sin nombre con los paréntesis y una coma:</target>
        </trans-unit>
        <trans-unit id="14170c2ff1e7de54f4e2348d1e871df1403c7064" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;explicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">Un tipo &lt;code&gt;a&lt;/code&gt; es &lt;strong&gt;expl&amp;iacute;citamente&lt;/strong&gt; convertible en tipo &lt;code&gt;b&lt;/code&gt; si el siguiente algoritmo devuelve verdadero:</target>
        </trans-unit>
        <trans-unit id="0e266a33b4be68e2d75b658bf09d5fcd023a82b7" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;implicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">Un tipo &lt;code&gt;a&lt;/code&gt; es &lt;strong&gt;impl&amp;iacute;citamente&lt;/strong&gt; convertible en tipo &lt;code&gt;b&lt;/code&gt; si el siguiente algoritmo devuelve verdadero:</target>
        </trans-unit>
        <trans-unit id="7dc18dc1dcffe82a8fb4389b39ff6e417d37bfc5" translate="yes" xml:space="preserve">
          <source>A type class can be used directly as the parameter's type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506a88b6ff206893ad4b7e57e9c4e7e99b518ff4" translate="yes" xml:space="preserve">
          <source>A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the &lt;code&gt;is&lt;/code&gt; operator. Nim supports the following built-in type classes:</source>
          <target state="translated">Una clase de tipo es un pseudo-tipo especial que se puede utilizar para comparar tipos en el contexto de la resoluci&amp;oacute;n de sobrecarga o el operador &lt;code&gt;is&lt;/code&gt; . Nim admite las siguientes clases de tipos integradas:</target>
        </trans-unit>
        <trans-unit id="d889810de0813b3ec269aad080ce51f23f302bb5" translate="yes" xml:space="preserve">
          <source>A type conversion &lt;code&gt;T(e)&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e248a89a87db7e3a826b410d2791efe05a16bd" translate="yes" xml:space="preserve">
          <source>A type representing a directory stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2661446eb8287aeb52ad012da364775c3dbaac" translate="yes" xml:space="preserve">
          <source>A type section begins with the &lt;code&gt;type&lt;/code&gt; keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single &lt;code&gt;type&lt;/code&gt; section. Nominal types like &lt;code&gt;objects&lt;/code&gt; or &lt;code&gt;enums&lt;/code&gt; can only be defined in a &lt;code&gt;type&lt;/code&gt; section.</source>
          <target state="translated">Una secci&amp;oacute;n de tipo comienza con la palabra clave &lt;code&gt;type&lt;/code&gt; . Contiene m&amp;uacute;ltiples definiciones de tipos. Una definici&amp;oacute;n de tipo vincula un tipo a un nombre. Las definiciones de tipos pueden ser recursivas o incluso recursivas entre s&amp;iacute;. Los tipos recursivos mutuos solo son posibles dentro de una &amp;uacute;nica secci&amp;oacute;n de &lt;code&gt;type&lt;/code&gt; . Los tipos nominales como &lt;code&gt;objects&lt;/code&gt; o &lt;code&gt;enums&lt;/code&gt; solo se pueden definir en una secci&amp;oacute;n de &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be7a9f47604f0611af9fa5403b9d09653a88c565" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&amp;lt;&lt;/code&gt; for convenience so that mixing integer types works better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0511cf3cc72e09256f19cf736ca74f42546431bf" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&lt;/code&gt; for convenience so that mixing integer types work better.</source>
          <target state="translated">Una versi&amp;oacute;n especializada en tipos de &lt;code&gt;..&lt;/code&gt; por conveniencia para que la combinaci&amp;oacute;n de tipos enteros funcione mejor.</target>
        </trans-unit>
        <trans-unit id="9ebdff8f30923670788ff9aaae0394936cf6a032" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&lt;/code&gt; for convenience so that mixing integer types works better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104ce833879be4ffac814c9243c526f5122867af" translate="yes" xml:space="preserve">
          <source>A valid identifier starts with a character of the set &lt;code&gt;IdentStartChars&lt;/code&gt; and is followed by any number of characters of the set &lt;code&gt;IdentChars&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aca1ed394a97d0358e43ad02e64f2e9f0dad035" translate="yes" xml:space="preserve">
          <source>A valid identifier starts with a character of the set &lt;em&gt;IdentStartChars&lt;/em&gt; and is followed by any number of characters of the set &lt;em&gt;IdentChars&lt;/em&gt;.</source>
          <target state="translated">Un identificador v&amp;aacute;lido comienza con un car&amp;aacute;cter del conjunto &lt;em&gt;IdentStartChars&lt;/em&gt; y va seguido de cualquier n&amp;uacute;mero de caracteres del conjunto &lt;em&gt;IdentChars&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7e7d8bd354c4774606fc14c89770f32a756c621c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;Option[T]&lt;/code&gt; either contains a value &lt;code&gt;x&lt;/code&gt; (represented as &lt;code&gt;some(x)&lt;/code&gt;) or is empty (&lt;code&gt;none(T)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0abd94780a5ea8e9be893452be742a7ec90a256" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;Option[T]&lt;/code&gt; either contains a value &lt;em&gt;x&lt;/em&gt; (represented as &lt;code&gt;some(x)&lt;/code&gt;) or is empty (&lt;code&gt;none(T)&lt;/code&gt;).</source>
          <target state="translated">Un valor de tipo &lt;code&gt;Option[T]&lt;/code&gt; contiene un valor &lt;em&gt;x&lt;/em&gt; (representado como &lt;code&gt;some(x)&lt;/code&gt; ) o est&amp;aacute; vac&amp;iacute;o ( &lt;code&gt;none(T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="061691c897942e6f7639e5b9fc01836fcff953a0" translate="yes" xml:space="preserve">
          <source>A variable can be marked with the &lt;code&gt;threadvar&lt;/code&gt; pragma, which makes it a &lt;span id=&quot;threadminuslocal_1&quot;&gt;thread-local&lt;/span&gt; variable; Additionally, this implies all the effects of the &lt;code&gt;global&lt;/code&gt; pragma.</source>
          <target state="translated">Una variable se puede marcar con &lt;code&gt;threadvar&lt;/code&gt; pragma, lo que la convierte en una variable &lt;span id=&quot;threadminuslocal_1&quot;&gt;local de subproceso&lt;/span&gt; ; Adem&amp;aacute;s, esto implica todos los efectos del pragma &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c765eca0341d3fd35e0459d767a19482d988b83b" translate="yes" xml:space="preserve">
          <source>A variable length integer encoding implementation inspired by SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf2d03ae6a2d13d0af73951ec3e536467f5ec85" translate="yes" xml:space="preserve">
          <source>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects and sets belong to the structured types.</source>
          <target state="translated">Una variable de tipo estructurado puede contener múltiples valores al mismo tiempo.Los tipos estructurados pueden anidarse a niveles ilimitados.Los arreglos,secuencias,tuplas,objetos y conjuntos pertenecen a los tipos estructurados.</target>
        </trans-unit>
        <trans-unit id="615d13569c878522ca7102777ce66d9126a9f4e3" translate="yes" xml:space="preserve">
          <source>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects, and sets belong to the structured types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383eca27423209815099effeedb639e0e4c860fc" translate="yes" xml:space="preserve">
          <source>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named &lt;em&gt;fields&lt;/em&gt; of a type. A tuple also defines a lexicographic &lt;em&gt;order&lt;/em&gt; of the fields. Tuples are meant to be heterogeneous storage types with few abstractions. The &lt;code&gt;()&lt;/code&gt; syntax can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify the same fields of the same type in the same order. The &lt;em&gt;names&lt;/em&gt; of the fields also have to be identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f3d14f490e58bdf5285ce0bef4d7745002ec1a" translate="yes" xml:space="preserve">
          <source>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named &lt;em&gt;fields&lt;/em&gt; of a type. A tuple also defines an &lt;em&gt;order&lt;/em&gt; of the fields. Tuples are meant for heterogeneous storage types with no overhead and few abstraction possibilities. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify the same fields of the same type in the same order. The &lt;em&gt;names&lt;/em&gt; of the fields also have to be identical.</source>
          <target state="translated">Una variable de tupla o tipo de objeto es un contenedor de almacenamiento heterog&amp;eacute;neo. Una tupla u objeto define varios &lt;em&gt;campos con&lt;/em&gt; nombre de un tipo. Una tupla tambi&amp;eacute;n define un &lt;em&gt;orden&lt;/em&gt; de los campos. Las tuplas est&amp;aacute;n pensadas para tipos de almacenamiento heterog&amp;eacute;neos sin gastos generales y con pocas posibilidades de abstracci&amp;oacute;n. El constructor &lt;code&gt;()&lt;/code&gt; se puede utilizar para construir tuplas. El orden de los campos en el constructor debe coincidir con el orden de la definici&amp;oacute;n de la tupla. Diferentes tipos de tupla son &lt;em&gt;equivalentes&lt;/em&gt; si especifican los mismos campos del mismo tipo en el mismo orden. Los &lt;em&gt;nombres&lt;/em&gt; de los campos tambi&amp;eacute;n deben ser id&amp;eacute;nticos.</target>
        </trans-unit>
        <trans-unit id="7bdc1f89d378b40222906883361628b1181e0aa3" translate="yes" xml:space="preserve">
          <source>A variable of an enumeration type can only be assigned one of the enumeration's specified values. These values are a set of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1 and so on. For example:</source>
          <target state="translated">A una variable de un tipo de enumeración sólo se le puede asignar uno de los valores especificados de la enumeración.Estos valores son un conjunto de símbolos ordenados.Cada símbolo se asigna internamente a un valor entero.El primer símbolo se representa en tiempo de ejecución por 0,el segundo por 1 y así sucesivamente.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="03eb03003aebc272b7eb136b33ffcf55da04a588" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;connect&lt;/code&gt; for non-blocking sockets.</source>
          <target state="translated">Una variante de &lt;code&gt;connect&lt;/code&gt; para enchufes sin bloqueo.</target>
        </trans-unit>
        <trans-unit id="b2257c4803acf9cbae2e6013d672e5f7d0b8ca99" translate="yes" xml:space="preserve">
          <source>A view &lt;code&gt;v&lt;/code&gt; can borrow from multiple different locations. However, the borrow is always the full span of &lt;code&gt;v&lt;/code&gt;'s lifetime and every location that is borrowed from is sealed during &lt;code&gt;v&lt;/code&gt;'s lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7b23280919cdb8b9ed6ba03f16d8dec6e0d684" translate="yes" xml:space="preserve">
          <source>A view cannot be used for a read or a write access before it was assigned to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eaa38aea35d4e613cc0cdbe4d2bcd6d5ae28f65" translate="yes" xml:space="preserve">
          <source>A view type is a type that is or contains one of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16154a4c78506d48d05de09fc2c147e545ffe199" translate="yes" xml:space="preserve">
          <source>A warning is a non-error message that may indicate impending problems or degraded performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ed9093f7d2c5cbb9aa8a3933ec4cb522e39e48" translate="yes" xml:space="preserve">
          <source>A while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The &lt;code&gt;block&lt;/code&gt; statement can be used to open a new block explicitly:</source>
          <target state="translated">Una instrucci&amp;oacute;n while (for) introduce un bloque impl&amp;iacute;cito. Los identificadores solo son visibles dentro del bloque que han sido declarados. La declaraci&amp;oacute;n de &lt;code&gt;block&lt;/code&gt; se puede utilizar para abrir un nuevo bloque expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="bc56783853877b4342018f4f4752a7c166237a4d" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\W&lt;/code&gt; (i.e. one matches &lt;code&gt;\w&lt;/code&gt; and the other matches &lt;code&gt;\W&lt;/code&gt;), or the start or end of the string if the first or last character matches &lt;code&gt;\w&lt;/code&gt;, respectively.</source>
          <target state="translated">Un l&amp;iacute;mite de palabra es una posici&amp;oacute;n en la cadena de asunto donde el car&amp;aacute;cter actual y el car&amp;aacute;cter anterior no coinciden con &lt;code&gt;\w&lt;/code&gt; o &lt;code&gt;\W&lt;/code&gt; (es decir, uno coincide con &lt;code&gt;\w&lt;/code&gt; y el otro con &lt;code&gt;\W&lt;/code&gt; ), o el comienzo o el final de la cadena si el primer o &amp;uacute;ltimo car&amp;aacute;cter coincide con &lt;code&gt;\w&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="469aae2fa20a5b364724db93849620fbab87ad21" translate="yes" xml:space="preserve">
          <source>API naming design</source>
          <target state="translated">Diseño del nombre de la API</target>
        </trans-unit>
        <trans-unit id="36215f7f26fcbc8102d12ecfe6c77120c8396238" translate="yes" xml:space="preserve">
          <source>API symbols</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8257a9cef2fe7db39639531c88970335f2c53c77" translate="yes" xml:space="preserve">
          <source>ARC</source>
          <target state="translated">ARC</target>
        </trans-unit>
        <trans-unit id="6e86868dfa064831def0a9a32949fcd3f02c8b05" translate="yes" xml:space="preserve">
          <source>AST based overloading</source>
          <target state="translated">Sobrecarga basada en la AST</target>
        </trans-unit>
        <trans-unit id="b08670d9d509dc53f0d69a06ccafcdfc0680021a" translate="yes" xml:space="preserve">
          <source>AST:</source>
          <target state="translated">AST:</target>
        </trans-unit>
        <trans-unit id="ed89ae3b78e13637e55b85c4b03f6daaccfcbc6b" translate="yes" xml:space="preserve">
          <source>Abbreviated three-letter form of the month.</source>
          <target state="translated">Forma abreviada de tres letras del mes.</target>
        </trans-unit>
        <trans-unit id="02befbd420c9754ded8c9a688a174615ddafd2a6" translate="yes" xml:space="preserve">
          <source>About this document</source>
          <target state="translated">Sobre este documento</target>
        </trans-unit>
        <trans-unit id="82b42258d7c7bb21ed3bb91a405d2c8d359a3934" translate="yes" xml:space="preserve">
          <source>AbsoluteDir:</source>
          <target state="translated">AbsoluteDir:</target>
        </trans-unit>
        <trans-unit id="0bcb5dbfb40a4d52e65b989317809bb509a54006" translate="yes" xml:space="preserve">
          <source>AbsoluteFile:</source>
          <target state="translated">AbsoluteFile:</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="1b33443d15e91efce2e27797d2c769792a4be765" translate="yes" xml:space="preserve">
          <source>Abstract base class for all exceptions that Nim's runtime raises but that are strictly uncatchable as they can also be mapped to a &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; operation.</source>
          <target state="translated">Clase base abstracta para todas las excepciones de tiempo de ejecuci&amp;oacute;n que eleva de Nim, pero que son estrictamente inalcanzable, ya que tambi&amp;eacute;n se pueden asignar a un &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="07ade5cd2426cf2d96d9f115a542fdf23ea73fb2" translate="yes" xml:space="preserve">
          <source>Abstract class for all exceptions that are catchable.</source>
          <target state="translated">Clase abstracta para todas las excepciones que son capturables.</target>
        </trans-unit>
        <trans-unit id="3f4e6a4ec9f1c43c4563924339bce51ceb8eb0af" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;code&gt;astGenRepr&lt;/code&gt; proc. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09ba72f81ab5a839d563be4983123e765b18fc8" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;code&gt;lispRepr&lt;/code&gt; proc. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d87fb77e58949f4a3af1708d01b460d4e3d3dc1" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;code&gt;treeRepr&lt;/code&gt; proc. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf35ec1eeb0cdf41c798e53ae7c4bdbcf3c6e03" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;astGenRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Acepta un bloque de c&amp;oacute;digo nim e imprime el &amp;aacute;rbol de sintaxis abstracta analizado usando la funci&amp;oacute;n &lt;em&gt;astGenRepr&lt;/em&gt; . La impresi&amp;oacute;n se realiza &lt;em&gt;en tiempo de compilaci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6e301f36546045d51728adbff6b973b0918094" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;lispRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Acepta un bloque de c&amp;oacute;digo nim e imprime el &amp;aacute;rbol de sintaxis abstracta analizado usando la funci&amp;oacute;n &lt;em&gt;lispRepr&lt;/em&gt; . La impresi&amp;oacute;n se realiza &lt;em&gt;en tiempo de compilaci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7eb919c05e9f3591e4b18f0af2d7cce492e0545f" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;treeRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Acepta un bloque de c&amp;oacute;digo nim e imprime el &amp;aacute;rbol de sintaxis abstracta analizado mediante la funci&amp;oacute;n &lt;em&gt;treeRepr&lt;/em&gt; . La impresi&amp;oacute;n se realiza &lt;em&gt;en tiempo de compilaci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce207f0652d5a79c6fb92d9892844f64c3c7bc7f" translate="yes" xml:space="preserve">
          <source>Accepts a new client connection.</source>
          <target state="translated">Acepta una nueva conexión con el cliente.</target>
        </trans-unit>
        <trans-unit id="142256b8872d5b2f49b7b35629597dff2e50c2c2" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0612c97d4b20e5af1b9ee2e86992dd16c29c8cbf" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">Acepta una nueva conexión.Devuelve un futuro que contiene el enchufe del cliente correspondiente a esa conexión y la dirección remota del cliente.El futuro se completará cuando la conexión sea aceptada con éxito.</target>
        </trans-unit>
        <trans-unit id="de10becfb867ce7d8a57fe498147c24ce2fed31f" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2156945d294c5977e8484e2589d72a67377e8e" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection. If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the resulting client socket will not be inheritable by child processes. The future will complete when the connection is successfully accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb38da96bcf63ef07293cca8f7fae610327e435b" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">Acepta una nueva conexión.Devuelve un futuro que contiene el enchufe del cliente correspondiente a esa conexión.El futuro se completará cuando la conexión sea aceptada con éxito.</target>
        </trans-unit>
        <trans-unit id="deb7592ffcf1beaf11244155535faaf11982362b" translate="yes" xml:space="preserve">
          <source>Accepts a node of kind &lt;code&gt;nnkSym&lt;/code&gt; and returns its owner's symbol. The meaning of 'owner' depends on &lt;code&gt;sym&lt;/code&gt;'s &lt;code&gt;NimSymKind&lt;/code&gt; and declaration context. For top level declarations this is an &lt;code&gt;nskModule&lt;/code&gt; symbol, for proc local variables an &lt;code&gt;nskProc&lt;/code&gt; symbol, for enum/object fields an &lt;code&gt;nskType&lt;/code&gt; symbol, etc. For symbols without an owner, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33dc09425d5909c6371181a754cfc69bb0dffcb5" translate="yes" xml:space="preserve">
          <source>Accepts a single request. Write an explicit loop around this proc so that errors can be handled properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6813381cdc37c15725205e39fd4619d20653f02f" translate="yes" xml:space="preserve">
          <source>Accepts an instantiated generic type and returns its uninstantiated form.</source>
          <target state="translated">Acepta un tipo genérico instanciado y devuelve su forma no instanciada.</target>
        </trans-unit>
        <trans-unit id="faf4ef0e56229453f96a306fcf1a0f1923d413de" translate="yes" xml:space="preserve">
          <source>Acceses a specified &lt;em&gt;entry&lt;/em&gt; from the current row.</source>
          <target state="translated">Accede a una &lt;em&gt;entrada&lt;/em&gt; especificada de la fila actual.</target>
        </trans-unit>
        <trans-unit id="1af3cc3329098e5826bfbbeb60f9d9bd983e292a" translate="yes" xml:space="preserve">
          <source>Access URI item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e9dd7a48db03f7a1f9615c265496ab948af3da" translate="yes" xml:space="preserve">
          <source>Access the currently matched character</source>
          <target state="translated">Accede al personaje actualmente coincidente</target>
        </trans-unit>
        <trans-unit id="9e2f25bad75994a6d0402acd174ffe98487bb1e8" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; and returns a mutable reference to it.</source>
          <target state="translated">Accede al elemento i-&amp;eacute;simo de &lt;em&gt;deq&lt;/em&gt; y devuelve una referencia mutable a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="b235504e101d141812cbd31b5736348cbd949d54" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; by order from first to last. deq[0] is the first, deq[^1] is the last.</source>
          <target state="translated">Acceda al elemento i-&amp;eacute;simo de &lt;em&gt;deq&lt;/em&gt; por orden del primero al &amp;uacute;ltimo. deq [0] es el primero, deq [^ 1] es el &amp;uacute;ltimo.</target>
        </trans-unit>
        <trans-unit id="8b33d8dee700b0371d3e740bce3869834048d0ab" translate="yes" xml:space="preserve">
          <source>Accesses a specified &lt;code&gt;entry&lt;/code&gt; from the current row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bdd5381d9fed61828adf89a00b3a554f8c9b97" translate="yes" xml:space="preserve">
          <source>Accesses the backwards indexed i-th element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40814a4680dc13930b702b75b874a15a540cd44" translate="yes" xml:space="preserve">
          <source>Accesses the i-th element of &lt;code&gt;deq&lt;/code&gt; and return a mutable reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4224433220776a7cd401842ee32aaee48826f9f3" translate="yes" xml:space="preserve">
          <source>Accesses the i-th element of &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8383ecf2951ae26619d64ffe472323e3628beb48" translate="yes" xml:space="preserve">
          <source>Accesses the i-th element of &lt;code&gt;heap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9157430212e0fe0ab310f60c200c7494abe11f3" translate="yes" xml:space="preserve">
          <source>Accessor for an any &lt;code&gt;x&lt;/code&gt; that represents an array or a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47d1e40dccddf8bf9622ec7b3c9e44c4af97584" translate="yes" xml:space="preserve">
          <source>Accumulator</source>
          <target state="translated">Accumulator</target>
        </trans-unit>
        <trans-unit id="737a162e2ca0961109be76dcbc40928b7272da0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock and then executes the code.</source>
          <target state="translated">Adquiere la cerradura dada y luego ejecuta el código.</target>
        </trans-unit>
        <trans-unit id="e94c5bb8f50ed78a7cd750db454d2af3ae23df56" translate="yes" xml:space="preserve">
          <source>Acquires the given lock, executes the statements in body and releases the lock after the statements finish executing.</source>
          <target state="translated">Adquiere el candado dado,ejecuta las declaraciones en cuerpo y libera el candado después de que las declaraciones terminen de ejecutarse.</target>
        </trans-unit>
        <trans-unit id="1a3e3046bdb90198f8603411233d3c6451ca3f0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock.</source>
          <target state="translated">Adquiere la cerradura dada.</target>
        </trans-unit>
        <trans-unit id="d2f9d48fe60d96f7c86fe92fea51a30eef86ea2a" translate="yes" xml:space="preserve">
          <source>Acts in a similar fashion to the &lt;em&gt;recvLine&lt;/em&gt; in the sockets module. Returns false when no data is available to be read. &lt;em&gt;Line&lt;/em&gt; must be initialized and not nil!</source>
          <target state="translated">Act&amp;uacute;a de forma similar a &lt;em&gt;recvLine&lt;/em&gt; en el m&amp;oacute;dulo de sockets. Devuelve falso cuando no hay datos disponibles para leer. &lt;em&gt;&amp;iexcl;La l&amp;iacute;nea&lt;/em&gt; debe estar inicializada y no nula!</target>
        </trans-unit>
        <trans-unit id="05cb0e3d96a9a97e0426bf235a612402b2cea3d4" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ident&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt; if it is not present. This is intended for use with pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05779dfde7404de32c688c1c9a48959dd22bdd2" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;y&lt;/em&gt; a &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4feee750a058b68182288ba271fbda6845aca1fd" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;y&lt;/em&gt; al n&amp;uacute;mero complejo &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c680f465bd9dc1e03f6e6d6ea7255c81ff7a44a5" translate="yes" xml:space="preserve">
          <source>Add a duration of time to a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Agregue una duraci&amp;oacute;n de tiempo a un &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa2d1e935ee54d15d98822bf8df93e7a3580d69" translate="yes" xml:space="preserve">
          <source>Add a file to the multipart data &lt;code&gt;p&lt;/code&gt;, specifying filename, contentType and content manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0329e59f93f564c5dfc0e70569d15fb9e15a73e3" translate="yes" xml:space="preserve">
          <source>Add a file to the multipart data &lt;em&gt;p&lt;/em&gt;, specifying filename, contentType and content manually.</source>
          <target state="translated">Agregue un archivo a los datos de varias partes &lt;em&gt;p&lt;/em&gt; , especificando el nombre de archivo, contentType y content manualmente.</target>
        </trans-unit>
        <trans-unit id="08fdfd4c11aa155b46a85fcf36cf6b5ef01faf49" translate="yes" xml:space="preserve">
          <source>Add a list of multipart entries to the multipart data &lt;code&gt;p&lt;/code&gt;. All values are added without a filename and without a content type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec5847211247b4fd74ccdc819e2406c975b05b5" translate="yes" xml:space="preserve">
          <source>Add a list of multipart entries to the multipart data &lt;em&gt;p&lt;/em&gt;. All values are added without a filename and without a content type.</source>
          <target state="translated">Agregue una lista de entradas multiparte a los datos multiparte &lt;em&gt;p&lt;/em&gt; . Todos los valores se agregan sin un nombre de archivo y sin un tipo de contenido.</target>
        </trans-unit>
        <trans-unit id="8716036a11430485de8c4308a7013612cbed93c8" translate="yes" xml:space="preserve">
          <source>Add a multipart entry to the multipart data &lt;code&gt;p&lt;/code&gt;. The value is added without a filename and without a content type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798a336ba2abb70a55f061577e20dced31fde63c" translate="yes" xml:space="preserve">
          <source>Add a multipart entry to the multipart data &lt;em&gt;p&lt;/em&gt;. The value is added without a filename and without a content type.</source>
          <target state="translated">Agregue una entrada de varias partes a los datos de varias partes &lt;em&gt;p&lt;/em&gt; . El valor se agrega sin un nombre de archivo y sin un tipo de contenido.</target>
        </trans-unit>
        <trans-unit id="f905661c323f469aafe9d05538fcce090acb423d" translate="yes" xml:space="preserve">
          <source>Add a value to the multipart data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04550fc57e117bf8d9e7db6f83bdeafaba0d38d" translate="yes" xml:space="preserve">
          <source>Add a value to the multipart data. Raises a &lt;em&gt;ValueError&lt;/em&gt; exception if &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;filename&lt;/em&gt; or &lt;em&gt;contentType&lt;/em&gt; contain newline characters.</source>
          <target state="translated">Agregue un valor a los datos de varias partes. &lt;em&gt;Genera&lt;/em&gt; una excepci&amp;oacute;n &lt;em&gt;ValueError&lt;/em&gt; si el &lt;em&gt;nombre&lt;/em&gt; , el &lt;em&gt;nombre de &lt;/em&gt;&lt;em&gt;archivo&lt;/em&gt; o &lt;em&gt;contentType&lt;/em&gt; contienen caracteres de nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="772b15743a6941c602fc6966a8c9ad76de348c4b" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the beginning of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Agregue un &lt;em&gt;elemento&lt;/em&gt; al comienzo de la &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2f6d2bfa601515402b5cd9a27e6de27a42f1ae49" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the end of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Agregue un &lt;em&gt;elemento&lt;/em&gt; al final de la &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4795b951a509e1ad114b904fea7f85d924a8b442" translate="yes" xml:space="preserve">
          <source>Add an item to the sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07bbced7392ce2be35b14f1ec60bf9e70357bb9" translate="yes" xml:space="preserve">
          <source>Add character to the string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804dca14340f9191ea44cbc9a5b612d3b7b60531" translate="yes" xml:space="preserve">
          <source>Add complex &lt;em&gt;x&lt;/em&gt; to float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma el complejo &lt;em&gt;x&lt;/em&gt; para flotar &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91af401e69eb5db85492da365b587bfdcdd3c94f" translate="yes" xml:space="preserve">
          <source>Add files to a multipart data object. The file will be opened from your disk, read and sent with the automatically determined MIME type. Raises an &lt;em&gt;IOError&lt;/em&gt; if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use &lt;em&gt;[]=&lt;/em&gt; instead.</source>
          <target state="translated">Agregue archivos a un objeto de datos de varias partes. El archivo se abrir&amp;aacute; desde su disco, se leer&amp;aacute; y enviar&amp;aacute; con el tipo MIME determinado autom&amp;aacute;ticamente. Genera un &lt;em&gt;IOError&lt;/em&gt; si el archivo no se puede abrir o la lectura falla. Para especificar manualmente el contenido del archivo, el nombre del archivo y el tipo MIME, utilice &lt;em&gt;[] = en su&lt;/em&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="52402dfdf42abb7b53517707a59330538bafd910" translate="yes" xml:space="preserve">
          <source>Add files to a multipart data object. The files will be streamed from disk when the request is being made. When &lt;code&gt;stream&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the files are instead read into memory, but beware this is very memory ineffecient even for small files. The MIME types will automatically be determined. Raises an &lt;code&gt;IOError&lt;/code&gt; if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use &lt;code&gt;[]=&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406ccec3a46c7096b360cd3465737a8b535aea4c" translate="yes" xml:space="preserve">
          <source>Add float &lt;em&gt;x&lt;/em&gt; to complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma float &lt;em&gt;x&lt;/em&gt; al complejo &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="505c6693913fe1565ef1c731c3ebc737609d4c48" translate="yes" xml:space="preserve">
          <source>Add ident to dest if it is not present. This is intended for use with pragmas.</source>
          <target state="translated">Añade la identificación al destino si no está presente.Esto está destinado a ser usado con los pragmas.</target>
        </trans-unit>
        <trans-unit id="ed6a96e38077149fb1f9acfe217b88923300d176" translate="yes" xml:space="preserve">
          <source>Add int &lt;code&gt;x&lt;/code&gt; to rational &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f82f0fe426d7f18de6a09b1fee81b37ab4f8907" translate="yes" xml:space="preserve">
          <source>Add int &lt;code&gt;y&lt;/code&gt; to rational &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50017805b1b6fc4f451182d9127fec897f8b761" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;x&lt;/em&gt; to rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma int &lt;em&gt;x&lt;/em&gt; a &lt;em&gt;y&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="9fd52413273ba8dedf3c71352a83c577246c8699" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma int &lt;em&gt;y&lt;/em&gt; a &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="cfd9da0bd8b02d4be1a67e73526e14e1ec6c2189" translate="yes" xml:space="preserve">
          <source>Add rational &lt;code&gt;x&lt;/code&gt; to int &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52d3037755de98e3ad893c88823ad9c9de430f5" translate="yes" xml:space="preserve">
          <source>Add rational &lt;code&gt;y&lt;/code&gt; to rational &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18a8ab635db264a0fe3a0922ec6560932edcddf" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;x&lt;/em&gt; to int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;x&lt;/em&gt; racional a int &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa6c134ddb31344adb0018507fd22c268b0cb12" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Suma &lt;em&gt;y&lt;/em&gt; racional a &lt;em&gt;x&lt;/em&gt; racional .</target>
        </trans-unit>
        <trans-unit id="d1747c4bec3777bff15f92b0cac11995facbb754" translate="yes" xml:space="preserve">
          <source>Add two complex numbers.</source>
          <target state="translated">Sume dos números complejos.</target>
        </trans-unit>
        <trans-unit id="10e886ac53c1940ea63eb1399092efb3e0175be5" translate="yes" xml:space="preserve">
          <source>Add two durations together.</source>
          <target state="translated">Sume dos duraciones juntas.</target>
        </trans-unit>
        <trans-unit id="918bdd0b6e0ab8c7e512d1c14637656e65c676d4" translate="yes" xml:space="preserve">
          <source>Add two rational numbers.</source>
          <target state="translated">Sume dos números racionales.</target>
        </trans-unit>
        <trans-unit id="f9f4e2a4ee342e53c003797651594c460da995fd" translate="yes" xml:space="preserve">
          <source>Adding a method to a class the programmer has no control over is impossible or needs ugly workarounds.</source>
          <target state="translated">Añadir un método a una clase sobre la que el programador no tiene control es imposible o requiere de un feo trabajo.</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">Características adicionales</target>
        </trans-unit>
        <trans-unit id="050d53ae9db89d00328e7590301c21bc8b18552a" translate="yes" xml:space="preserve">
          <source>Additional compilation switches</source>
          <target state="translated">Interruptores de compilación adicionales</target>
        </trans-unit>
        <trans-unit id="40896bd1d7fb4e2d2b859f8c06ae9aa5ebd3ac5f" translate="yes" xml:space="preserve">
          <source>Additional documentation about Nim's GC and how to operate it in a</source>
          <target state="translated">Documentación adicional sobre el GC de Nim y cómo operarlo en un</target>
        </trans-unit>
        <trans-unit id="69fde59a7b9ef81d45e08f2d1fd9df14f9421393" translate="yes" xml:space="preserve">
          <source>Additional documentation about Nim's multi-paradigm memory management strategies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15fa56393dfeea6e8ddbb0e0c2a6f3cc24b93de" translate="yes" xml:space="preserve">
          <source>Additional resources</source>
          <target state="translated">Recursos adicionales</target>
        </trans-unit>
        <trans-unit id="fa4703ed512a421e9e9ab95be1747cd7af75bcd9" translate="yes" xml:space="preserve">
          <source>Additionally adds the enclosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="683593bbc9f4d0095e1a329b2a170a4f6b64749a" translate="yes" xml:space="preserve">
          <source>Additionally adds the encosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.</source>
          <target state="translated">Además añade el texto encapsulado al índice como un término.Dado que nos interesa que diferentes instancias del mismo término tengan diferentes entradas,se utiliza una tabla para llevar un registro de la cantidad de veces que un término ha aparecido anteriormente para dar un valor de identificación diferente para cada una.</target>
        </trans-unit>
        <trans-unit id="83025bdbec6a244fe913cb7d0ff67dac39e81e46" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass a value along with the symbol: &lt;code&gt;-d:x=y&lt;/code&gt; which may be used in conjunction with the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;compile time define pragmas&lt;/a&gt; to override symbols during build time.</source>
          <target state="translated">Adem&amp;aacute;s, puede pasar un valor junto con el s&amp;iacute;mbolo: &lt;code&gt;-d:x=y&lt;/code&gt; que puede usarse junto con los &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;pragmas de definici&amp;oacute;n de tiempo de compilaci&amp;oacute;n&lt;/a&gt; para anular los s&amp;iacute;mbolos durante el tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dad02ecd7c3a4cabf030c764e9da2c30f5fe41ab" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass a value along with the symbol: &lt;code&gt;-d:x=y&lt;/code&gt; which may be used in conjunction with the &lt;a href=&quot;manual#implementation-specific-pragmas-compileminustime-define-pragmas&quot;&gt;compile-time define pragmas&lt;/a&gt; to override symbols during build time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cc91072a9c61406bb688685c655da8fcf1e11e" translate="yes" xml:space="preserve">
          <source>Addr operator</source>
          <target state="translated">Operador de la dirección</target>
        </trans-unit>
        <trans-unit id="e6513e72133cdea4324350e6d4ade50552f0fa2a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;arg&lt;/code&gt; as a &lt;code&gt;Node&lt;/code&gt; to the &lt;code&gt;NList&lt;/code&gt; If a node with the same name is already present in this map, it is replaced by the new one.</source>
          <target state="translated">Agrega &lt;code&gt;arg&lt;/code&gt; como un &lt;code&gt;Node&lt;/code&gt; a &lt;code&gt;NList&lt;/code&gt; . Si un nodo con el mismo nombre ya est&amp;aacute; presente en este mapa, se reemplaza por el nuevo.</target>
        </trans-unit>
        <trans-unit id="3ccd506aab4757f17ef51ce2016ba1b428279190" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;b&lt;/code&gt; to the rope &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc159ea3eeee439600098843b572bf5bf9add55" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;child&lt;/code&gt; to a JArray node &lt;code&gt;father&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0973ea96bcd93e616194aea6ada7ee253f95770" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;handler&lt;/code&gt; to the list of handlers.</source>
          <target state="translated">Agrega &lt;code&gt;handler&lt;/code&gt; a la lista de controladores.</target>
        </trans-unit>
        <trans-unit id="09af7b91c6e7df51cd37d298bdc37f650d040831" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are added in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">Agrega &lt;code&gt;interval&lt;/code&gt; o a &lt;code&gt;dt&lt;/code&gt; . Los componentes del &lt;code&gt;interval&lt;/code&gt; o se agregan en el orden de su tama&amp;ntilde;o, es decir, primero el componente de &lt;code&gt;years&lt;/code&gt; , luego el componente de &lt;code&gt;months&lt;/code&gt; y as&amp;iacute; sucesivamente. El &lt;code&gt;DateTime&lt;/code&gt; devuelto tendr&amp;aacute; la misma zona horaria que la entrada.</target>
        </trans-unit>
        <trans-unit id="ba0aaaa96c74c1cea684996ea930d05d8a0077c9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are added in the order of their size, i.e. first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18926f976110c5ffe1e4f4c98001f1d15ef90526" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;time&lt;/code&gt;. If &lt;code&gt;interval&lt;/code&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3703e66f4731d1cd49994e51655ed816fcd0462" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;mimetype&lt;/code&gt; to the &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">Agrega &lt;code&gt;mimetype&lt;/code&gt; al &lt;code&gt;mimedb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68ab57cbe5dd2927ab80b8168f0ae9bf78358be1" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;mimetype&lt;/code&gt; to the &lt;code&gt;mimedb&lt;/code&gt;. &lt;code&gt;mimetype&lt;/code&gt; and &lt;code&gt;ext&lt;/code&gt; are lowercased before registering on &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55bd8510c4909907c3b0b1b51f22ef8bfe1dc23" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initalized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">Suma &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; a menos que &lt;code&gt;x&lt;/code&gt; no se haya iniciado todav&amp;iacute;a; en ese caso, &lt;code&gt;x&lt;/code&gt; se convierte en &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08dd7691271b1b3cf31cdaad9abf0dd1ed892c5b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initialized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;@[y]&lt;/code&gt;</source>
          <target state="translated">Suma &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; a menos que &lt;code&gt;x&lt;/code&gt; a&amp;uacute;n no se haya inicializado; en ese caso, &lt;code&gt;x&lt;/code&gt; se convierte en &lt;code&gt;@[y]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="627474e018ec81cf49c8143b28ab86561ce7ccef" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910ee17a6a799e67a937708e73b9aedb33f3b0aa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; it is initialized to &lt;code&gt;&quot;&quot;&lt;/code&gt;</source>
          <target state="translated">Suma &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;nil&lt;/code&gt; , se inicializa en &lt;code&gt;&quot;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4d013d42946fcbe3af0f01b7362386e1eb7f928" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a JArray node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">Agrega &lt;em&gt;hijo&lt;/em&gt; a un &lt;em&gt;padre de&lt;/em&gt; nodo JArray .</target>
        </trans-unit>
        <trans-unit id="277d7264e0b31954fb3f91658c21ef53fbc9f98b" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a SList node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">Agrega &lt;em&gt;hijo&lt;/em&gt; a un &lt;em&gt;padre de&lt;/em&gt; nodo SList .</target>
        </trans-unit>
        <trans-unit id="282a03494ac60232eca16c10011aa2a3e77244c0" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;interval&lt;/em&gt; to &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">Agrega &lt;em&gt;intervalo&lt;/em&gt; al &lt;em&gt;tiempo&lt;/em&gt; . Si el &lt;em&gt;intervalo&lt;/em&gt; contiene a&amp;ntilde;os, meses, semanas o d&amp;iacute;as, la operaci&amp;oacute;n se realiza en la zona horaria local.</target>
        </trans-unit>
        <trans-unit id="50a3a76c2750845cf7f87e40704907335f25674d" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;term&lt;/code&gt; to the index using the specified hyperlink identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168959e8e3da827112e6480f035af90769452610" translate="yes" xml:space="preserve">
          <source>Adds a &lt;em&gt;term&lt;/em&gt; to the index using the specified hyperlink identifier.</source>
          <target state="translated">Agrega un &lt;em&gt;t&amp;eacute;rmino&lt;/em&gt; al &amp;iacute;ndice utilizando el identificador de hiperv&amp;iacute;nculo especificado.</target>
        </trans-unit>
        <trans-unit id="8e1762576390fbc36fed4423af342fdafc7b01f4" translate="yes" xml:space="preserve">
          <source>Adds a char to string &lt;code&gt;s&lt;/code&gt; and applies the following escaping:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46517870669c98767730789efc1c2a63afe0fd37" translate="yes" xml:space="preserve">
          <source>Adds a char to string &lt;em&gt;s&lt;/em&gt; and applies the following escaping:</source>
          <target state="translated">Agrega un car&amp;aacute;cter a la cadena &lt;em&gt;sy&lt;/em&gt; aplica el siguiente escape:</target>
        </trans-unit>
        <trans-unit id="a165d6cb7b186d7181d788e17f736e5c34a3bc93" translate="yes" xml:space="preserve">
          <source>Adds a complex number to a real number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827e14fb735a5d5b595e3196ad328aaf6dce5348" translate="yes" xml:space="preserve">
          <source>Adds a logger to the list of registered handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8aac4240d0d2f3105af4d844dbcb2abbdecf97" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the localName and namespaceURI of &lt;code&gt;newAttr&lt;/code&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Agrega un nuevo nodo de atributo, si hay un atributo con localName y namespaceURI de &lt;code&gt;newAttr&lt;/code&gt; , se reemplaza por el nuevo y se devuelve el atributo reemplazado; de lo contrario, se devuelve &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49966f2ea34f557267d410935160fd5454f498db" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the same &lt;em&gt;nodeName&lt;/em&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Agrega un nuevo atributo nodo, si hay un atributo con el mismo &lt;em&gt;nodeName&lt;/em&gt; , se reemplaza por el nuevo y se devuelve el atributo reemplazado, de lo contrario se devuelve &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d941c7f90a962f0302be00a817bf48658be8c09" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; If an attribute with that name is already present in the element, its value is changed to be that of the value parameter Raises the EInvalidCharacterErr if the specified &lt;code&gt;name&lt;/code&gt; contains illegal characters</source>
          <target state="translated">Agrega un nuevo atributo, seg&amp;uacute;n lo especificado por el &lt;code&gt;name&lt;/code&gt; y el &lt;code&gt;value&lt;/code&gt; Si un atributo con ese nombre ya est&amp;aacute; presente en el elemento, su valor se cambia para que sea el del par&amp;aacute;metro de valor Eleva el EInvalidCharacterErr si el &lt;code&gt;name&lt;/code&gt; especificado contiene caracteres ilegales</target>
        </trans-unit>
        <trans-unit id="70b9921234cbd8dc467e865419512e1db5aa80e1" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;namespaceURI&lt;/code&gt;, &lt;code&gt;localName&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Agrega un nuevo atributo, seg&amp;uacute;n lo especificado por &lt;code&gt;namespaceURI&lt;/code&gt; , &lt;code&gt;localName&lt;/code&gt; y &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175780a3fa3d64a9dc7aa37e3d80ca0adc76b294" translate="yes" xml:space="preserve">
          <source>Adds a node using its &lt;code&gt;namespaceURI&lt;/code&gt; and &lt;code&gt;localName&lt;/code&gt;</source>
          <target state="translated">Agrega un nodo usando su &lt;code&gt;namespaceURI&lt;/code&gt; y &lt;code&gt;localName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445dea116e47b26077f13f1c8b729d6b93e3f403" translate="yes" xml:space="preserve">
          <source>Adds a real number to a complex number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd52d911dfccd80297cfd1bc6c1ca03cb53214c3" translate="yes" xml:space="preserve">
          <source>Adds a rune &lt;code&gt;c&lt;/code&gt; to a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25b62bec6486d33ddc3794772773f41d17aed10" translate="yes" xml:space="preserve">
          <source>Adds a separator to &lt;code&gt;dest&lt;/code&gt; only if its length is bigger than &lt;code&gt;startLen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b9366e5b895a616623ffad66668f7f54484c12" translate="yes" xml:space="preserve">
          <source>Adds a separator to &lt;em&gt;dest&lt;/em&gt; only if its length is bigger than &lt;em&gt;startLen&lt;/em&gt;.</source>
          <target state="translated">Agrega un separador a &lt;em&gt;dest&lt;/em&gt; solo si su longitud es mayor que &lt;em&gt;startLen&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9d30fd10baf4621b3f993d8f268f3318fa55aa89" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;item&lt;/code&gt; to the beginning of the &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7abee7fa26cb127bb76dc8029b992785bf6db7" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;item&lt;/code&gt; to the end of the &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4ae4071a72fe5abb9dd7a95222ae4b3f3aedff" translate="yes" xml:space="preserve">
          <source>Adds each child of &lt;code&gt;children&lt;/code&gt; to the &lt;code&gt;father&lt;/code&gt; node. Returns the &lt;code&gt;father&lt;/code&gt; node so that calls can be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719fea5dd090dc5f35241a78b628149a3f6e753c" translate="yes" xml:space="preserve">
          <source>Adds each child of &lt;em&gt;children&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the &lt;em&gt;father&lt;/em&gt; node so that calls can be nested.</source>
          <target state="translated">Agrega cada hijo de los &lt;em&gt;hijos&lt;/em&gt; al nodo &lt;em&gt;padre&lt;/em&gt; . Devuelve el nodo &lt;em&gt;padre&lt;/em&gt; para que las llamadas se puedan anidar.</target>
        </trans-unit>
        <trans-unit id="77594e2b861c1fa8f8e68498df51e03371d37a9b" translate="yes" xml:space="preserve">
          <source>Adds pragma to routine definition</source>
          <target state="translated">Añade pragmatismo a la definición de rutina</target>
        </trans-unit>
        <trans-unit id="22ef025c8852052c63014722234d4f7dac516082" translate="yes" xml:space="preserve">
          <source>Adds pragma to routine definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8d34a8c593fa5ef656e634dd29a0f526f1bbcb" translate="yes" xml:space="preserve">
          <source>Adds the &lt;code&gt;child&lt;/code&gt; to the &lt;code&gt;father&lt;/code&gt; node. Returns the father node so that calls can be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392b56977e8236b6698f4ca58ac6c2f28d25c68f" translate="yes" xml:space="preserve">
          <source>Adds the &lt;em&gt;child&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the father node so that calls can be nested.</source>
          <target state="translated">Agrega el &lt;em&gt;hijo&lt;/em&gt; al nodo &lt;em&gt;padre&lt;/em&gt; . Devuelve el nodo padre para que las llamadas se puedan anidar.</target>
        </trans-unit>
        <trans-unit id="4be1f166b02d308f1b99389ad08b9ecee806fca1" translate="yes" xml:space="preserve">
          <source>Adds the callbacks proc to be called when the future completes.</source>
          <target state="translated">Añade el procedimiento de devolución de llamadas que se llamará cuando el futuro se complete.</target>
        </trans-unit>
        <trans-unit id="b7b6993ff7221b5e90540fdce800099548168a68" translate="yes" xml:space="preserve">
          <source>Adds the child &lt;code&gt;son&lt;/code&gt; to &lt;code&gt;father&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc36a9f78ad151e4f4390f8743161fab423645f" translate="yes" xml:space="preserve">
          <source>Adds the file extension &lt;code&gt;ext&lt;/code&gt; to &lt;code&gt;filename&lt;/code&gt;, unless &lt;code&gt;filename&lt;/code&gt; already has an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087cbeb9fcc85f71b469524d8a7510230c6f6abc" translate="yes" xml:space="preserve">
          <source>Adds the file extension &lt;em&gt;ext&lt;/em&gt; to &lt;em&gt;filename&lt;/em&gt;, unless &lt;em&gt;filename&lt;/em&gt; already has an extension.</source>
          <target state="translated">Agrega la extensi&amp;oacute;n de archivo &lt;em&gt;ext&lt;/em&gt; al &lt;em&gt;nombre&lt;/em&gt; de &lt;em&gt;archivo&lt;/em&gt; , a menos que el &lt;em&gt;nombre de archivo&lt;/em&gt; ya tenga una extensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38e43d237023eab5acc2b848d42530e464a0a37f" translate="yes" xml:space="preserve">
          <source>Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.</source>
          <target state="translated">Añade el nodo newChild al final de la lista de hijos de este nodo.Si el newChild ya está en el árbol,primero se elimina.</target>
        </trans-unit>
        <trans-unit id="2a72a2ff357c75992d2d25db54f40e31c444189e" translate="yes" xml:space="preserve">
          <source>Adds the specified value to the specified key. Appends to any existing values associated with the key.</source>
          <target state="translated">Añade el valor especificado a la clave especificada.Añade a cualquier valor existente asociado a la clave.</target>
        </trans-unit>
        <trans-unit id="8dfc81b4ba54feaa93081bccdec5f9016c933c3e" translate="yes" xml:space="preserve">
          <source>Adds the textual representation of &lt;code&gt;n&lt;/code&gt; to string &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb76173f8b3f736f04cf7a85a76442e3061c9f2" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;TimeInterval&lt;/code&gt; objects together.</source>
          <target state="translated">Agrega dos objetos &lt;code&gt;TimeInterval&lt;/code&gt; juntos.</target>
        </trans-unit>
        <trans-unit id="f072b38e848ec11710252f90b744bfddeaabbd97" translate="yes" xml:space="preserve">
          <source>Adds two colors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c598fdad0049851912b65e101e0082a5d1544c" translate="yes" xml:space="preserve">
          <source>Adds two complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd028f03aa8100d6b3d714eae3d5348fe823a2f" translate="yes" xml:space="preserve">
          <source>Adds/registers a quit procedure.</source>
          <target state="translated">Añade/registra un procedimiento para dejar de fumar.</target>
        </trans-unit>
        <trans-unit id="a371aa854f23fe7005ac2c85dbb7004b42d9769b" translate="yes" xml:space="preserve">
          <source>Adds/registers a quit procedure. Each call to &lt;code&gt;addExitProc&lt;/code&gt; registers another quit procedure. They are executed on a last-in, first-out basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5090ef07df2944062324712ca6950298e056c7f1" translate="yes" xml:space="preserve">
          <source>Adopting type for gui inspector in a game engine:</source>
          <target state="translated">Adoptando el tipo para el inspector de guias en un motor de juego:</target>
        </trans-unit>
        <trans-unit id="cd58779782de2792380285200da5a98425f86d02" translate="yes" xml:space="preserve">
          <source>Advanced command line switches are:</source>
          <target state="translated">Los interruptores avanzados de la línea de mando son:</target>
        </trans-unit>
        <trans-unit id="b6c601805a77e86b61625eba41bd959b73c2bb59" translate="yes" xml:space="preserve">
          <source>Advanced command-line switches are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3a43835953e413f721f837036117df744dbd00" translate="yes" xml:space="preserve">
          <source>Advanced commands:</source>
          <target state="translated">Comandos avanzados:</target>
        </trans-unit>
        <trans-unit id="21604196a5b5f020863aebeb14786b98a2ec02e1" translate="yes" xml:space="preserve">
          <source>Advanced options:</source>
          <target state="translated">Opciones avanzadas:</target>
        </trans-unit>
        <trans-unit id="f1c748b61ceca05da788dea58f761592f09389bc" translate="yes" xml:space="preserve">
          <source>Advanced types</source>
          <target state="translated">Tipos avanzados</target>
        </trans-unit>
        <trans-unit id="4eaa54faaeebcdcf16ca6cecc39180523a7c29ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\0&lt;/code&gt; up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence &lt;code&gt;\0\x\07&lt;/code&gt; specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">Despu&amp;eacute;s de &lt;code&gt;\0&lt;/code&gt; se leen hasta dos d&amp;iacute;gitos octales m&amp;aacute;s. En ambos casos, si hay menos de dos d&amp;iacute;gitos, solo se utilizan los que est&amp;aacute;n presentes. As&amp;iacute;, la secuencia &lt;code&gt;\0\x\07&lt;/code&gt; especifica dos ceros binarios seguidos de un car&amp;aacute;cter BEL (valor de c&amp;oacute;digo 7). Aseg&amp;uacute;rese de proporcionar dos d&amp;iacute;gitos despu&amp;eacute;s del cero inicial si el car&amp;aacute;cter de patr&amp;oacute;n que sigue es en s&amp;iacute; mismo un d&amp;iacute;gito octal.</target>
        </trans-unit>
        <trans-unit id="c71390a639ed6627641b3cfd1f9a329a5cc9c625" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\x&lt;/code&gt;, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, or if there is no terminating &lt;code&gt;}&lt;/code&gt;, this form of escape is not recognized. Instead, the initial &lt;code&gt;\x&lt;/code&gt; will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.</source>
          <target state="translated">Despu&amp;eacute;s de &lt;code&gt;\x&lt;/code&gt; , se leen de cero a dos d&amp;iacute;gitos hexadecimales (las letras pueden estar en may&amp;uacute;sculas o min&amp;uacute;sculas). En el modo UTF-8, cualquier n&amp;uacute;mero de d&amp;iacute;gitos hexadecimales puede aparecer entre &lt;code&gt;\x{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; , pero el valor del c&amp;oacute;digo de car&amp;aacute;cter debe ser menor que 2 ** 31 (es decir, el valor hexadecimal m&amp;aacute;ximo es 7FFFFFFF). Si aparecen caracteres que no sean d&amp;iacute;gitos hexadecimales entre &lt;code&gt;\x{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; , o si no hay terminaci&amp;oacute;n &lt;code&gt;}&lt;/code&gt; , esta forma de escape no se reconoce. En cambio, la &lt;code&gt;\x&lt;/code&gt; inicial se interpretar&amp;aacute; como un escape hexadecimal b&amp;aacute;sico, sin d&amp;iacute;gitos siguientes, dando un car&amp;aacute;cter cuyo valor es cero.</target>
        </trans-unit>
        <trans-unit id="622cf30c89947b71767229b80f2f6c86dfa76768" translate="yes" xml:space="preserve">
          <source>After a connection is made you can use the &lt;code&gt;store&lt;/code&gt; procedure to upload a new file to the FTP server. Make sure to check you are in the correct working directory before you do so with the &lt;code&gt;pwd&lt;/code&gt; procedure, you can also instead specify an absolute path.</source>
          <target state="translated">Una vez realizada la conexi&amp;oacute;n, puede utilizar el procedimiento de &lt;code&gt;store&lt;/code&gt; para cargar un nuevo archivo en el servidor FTP. Aseg&amp;uacute;rese de verificar que est&amp;aacute; en el directorio de trabajo correcto antes de hacerlo con el procedimiento &lt;code&gt;pwd&lt;/code&gt; , tambi&amp;eacute;n puede especificar una ruta absoluta.</target>
        </trans-unit>
        <trans-unit id="7520b5bf7b6ddd9d8aee836c25d8c005e080b0bf" translate="yes" xml:space="preserve">
          <source>After an initial build via &lt;code&gt;sh build_all.sh&lt;/code&gt; on posix or &lt;code&gt;build_all.bat&lt;/code&gt; on windows, you can rebuild the compiler as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73d43ab167cd4ac21b418e91451904852662e79" translate="yes" xml:space="preserve">
          <source>After compilation is finished you will hopefully end up with the nim compiler in the &lt;code&gt;bin&lt;/code&gt; directory. You can add Nim's &lt;code&gt;bin&lt;/code&gt; directory to your &lt;code&gt;$PATH&lt;/code&gt; or use the &lt;a href=&quot;#install-command&quot;&gt;install command&lt;/a&gt; to place it where it will be found.</source>
          <target state="translated">Una vez finalizada la compilaci&amp;oacute;n, es de esperar que termine con el compilador nim en el directorio &lt;code&gt;bin&lt;/code&gt; . Puede agregar el directorio &lt;code&gt;bin&lt;/code&gt; de Nim a su &lt;code&gt;$PATH&lt;/code&gt; o usar el &lt;a href=&quot;#install-command&quot;&gt;comando de instalaci&amp;oacute;n&lt;/a&gt; para colocarlo donde se encontrar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="b98934419b5d22ede24344e6f44c8aa22099b672" translate="yes" xml:space="preserve">
          <source>After compilation is finished you will hopefully end up with the nim compiler in the &lt;code&gt;bin&lt;/code&gt; directory. You can add Nim's &lt;code&gt;bin&lt;/code&gt; directory to your &lt;code&gt;$PATH&lt;/code&gt; or use the install command to place it where it will be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b90d285522bd240c9268803fc6cb7830c0b81db" translate="yes" xml:space="preserve">
          <source>After doing this, use either the &lt;a href=&quot;#log.t,Level,varargs%5Bstring,%5D&quot;&gt;log template&lt;/a&gt; or one of the level-specific templates, such as the &lt;a href=&quot;#error.t,varargs%5Bstring,%5D&quot;&gt;error template&lt;/a&gt;, to log messages to all registered handlers at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e10a07a137ad912e35e4faef7ca70acb747eef5" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;from&lt;/code&gt; statement a module name follows followed by an &lt;code&gt;import&lt;/code&gt; to list the symbols one likes to use without explicit full qualification:</source>
          <target state="translated">Despu&amp;eacute;s de la instrucci&amp;oacute;n &lt;code&gt;from&lt;/code&gt; , sigue un nombre de m&amp;oacute;dulo seguido de una &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n para enumerar los s&amp;iacute;mbolos que a uno le gusta usar sin una calificaci&amp;oacute;n completa expl&amp;iacute;cita:</target>
        </trans-unit>
        <trans-unit id="cac28c3a1b2e93e9b8fde6caccc0941a6a14a30c" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;from&lt;/code&gt; statement, a module name follows followed by an &lt;code&gt;import&lt;/code&gt; to list the symbols one likes to use without explicit full qualification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f797b80df1f8d64852f55b778851d191514b53d" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;import&lt;/code&gt; statement a list of module names can follow or a single module name followed by an &lt;code&gt;except&lt;/code&gt; list to prevent some symbols to be imported:</source>
          <target state="translated">Despu&amp;eacute;s de la declaraci&amp;oacute;n de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n , puede seguir una lista de nombres de m&amp;oacute;dulo o un nombre de m&amp;oacute;dulo &amp;uacute;nico seguido de una lista de &lt;code&gt;except&lt;/code&gt; para evitar que se importen algunos s&amp;iacute;mbolos:</target>
        </trans-unit>
        <trans-unit id="ee8f6842719daac0ef2d06cdb2e7fa5bd3d11c84" translate="yes" xml:space="preserve">
          <source>After the execution of &lt;code&gt;handleRequest&lt;/code&gt; the client socket will be closed automatically unless it has already been closed.</source>
          <target state="translated">Despu&amp;eacute;s de la ejecuci&amp;oacute;n de &lt;code&gt;handleRequest&lt;/code&gt; , el socket del cliente se cerrar&amp;aacute; autom&amp;aacute;ticamente a menos que ya se haya cerrado.</target>
        </trans-unit>
        <trans-unit id="cf6dcadff9cc79e46d3555b76c916fb3ed022d34" translate="yes" xml:space="preserve">
          <source>After you add &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; for your custom type everything will work. Currently however &lt;code&gt;hash&lt;/code&gt; for objects is not defined, whereas &lt;code&gt;system.==&lt;/code&gt; for objects does exist and performs a &quot;deep&quot; comparison (every field is compared) which is usually what you want. So in the following example implementing only &lt;code&gt;hash&lt;/code&gt; suffices:</source>
          <target state="translated">Despu&amp;eacute;s de agregar &lt;code&gt;hash&lt;/code&gt; y &lt;code&gt;==&lt;/code&gt; para su tipo personalizado, todo funcionar&amp;aacute;. Sin embargo, actualmente el &lt;code&gt;hash&lt;/code&gt; para los objetos no est&amp;aacute; definido, mientras que &lt;code&gt;system.==&lt;/code&gt; para los objetos s&amp;iacute; existe y realiza una comparaci&amp;oacute;n &quot;profunda&quot; (se comparan todos los campos) que suele ser lo que usted desea. Entonces, en el siguiente ejemplo, la implementaci&amp;oacute;n solo de &lt;code&gt;hash&lt;/code&gt; es suficiente:</target>
        </trans-unit>
        <trans-unit id="8cc281a6f4ada76b68a3f2185149f5df48ef5084" translate="yes" xml:space="preserve">
          <source>After you add &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; for your custom type everything will work. Currently, however, &lt;code&gt;hash&lt;/code&gt; for objects is not defined, whereas &lt;code&gt;system.==&lt;/code&gt; for objects does exist and performs a &quot;deep&quot; comparison (every field is compared) which is usually what you want. So in the following example implementing only &lt;code&gt;hash&lt;/code&gt; suffices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ae9a42c0ef5d71d82ed6ff94ea44fa57d69eaa" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can create a TCP server by calling the &lt;code&gt;bindAddr&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; procedures.</source>
          <target state="translated">Despu&amp;eacute;s de crear un socket con el procedimiento &lt;code&gt;newSocket&lt;/code&gt; , puede crear un servidor TCP llamando a los procedimientos &lt;code&gt;bindAddr&lt;/code&gt; y &lt;code&gt;listen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f5c4359047c1c4029762b09cefac6ce55773f8" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can easily connect it to a server running at a known hostname (or IP address) and port. To do so over TCP, use the example below.</source>
          <target state="translated">Despu&amp;eacute;s de crear un socket con el procedimiento &lt;code&gt;newSocket&lt;/code&gt; , puede conectarlo f&amp;aacute;cilmente a un servidor que se ejecute en un nombre de host (o direcci&amp;oacute;n IP) y un puerto conocidos. Para hacerlo a trav&amp;eacute;s de TCP, use el siguiente ejemplo.</target>
        </trans-unit>
        <trans-unit id="5458c4cb0f05f3f6ed419b885d419d370bdf563e" translate="yes" xml:space="preserve">
          <source>Again, if you are wrapping a library which &lt;em&gt;mallocs&lt;/em&gt; and &lt;em&gt;frees&lt;/em&gt; data structures, you need to expose the appropriate &lt;em&gt;free&lt;/em&gt; function to Nim so you can clean it up. And of course, once cleaned you should avoid accessing it from Nim (or C for that matter). Typically C data structures have their own &lt;code&gt;malloc_structure&lt;/code&gt; and &lt;code&gt;free_structure&lt;/code&gt; specific functions, so wrapping these for the Nim side should be enough.</source>
          <target state="translated">Nuevamente, si est&amp;aacute; &lt;em&gt;encapsulando&lt;/em&gt; una biblioteca que &lt;em&gt;malloc&lt;/em&gt; y &lt;em&gt;libera&lt;/em&gt; estructuras de datos, necesita exponer la funci&amp;oacute;n &lt;em&gt;libre&lt;/em&gt; apropiada a Nim para que pueda limpiarla. Y, por supuesto, una vez limpio, debe evitar acceder a &amp;eacute;l desde Nim (o C para el caso). Normalmente, las estructuras de datos C tienen sus propias funciones espec&amp;iacute;ficas &lt;code&gt;malloc_structure&lt;/code&gt; y &lt;code&gt;free_structure&lt;/code&gt; , por lo que incluirlas en el lado de Nim deber&amp;iacute;a ser suficiente.</target>
        </trans-unit>
        <trans-unit id="70904e7446445a141b33be68742af96a43be4694" translate="yes" xml:space="preserve">
          <source>Again, it is important to remember that this module must &lt;strong&gt;not&lt;/strong&gt; be used for cryptographic applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="efc77c93e7dd9a47f78383fadbb6286c01811a32" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#contains,CritBitTree%5BT%5D,string&quot;&gt;contains&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2def8d1f86d78a731890a66e16deb2b5e1ea4254" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​para la &lt;a href=&quot;#difference&quot;&gt;diferencia (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="997fbf4291c46ae1426159d92973a99aacd62a7b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0fe019adf9a60e369fc1066982e05411ae595c" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference,IntSet,IntSet&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a02e1746a71e7fb0864cabf7b39376b3a63a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#intersection&quot;&gt;intersecci&amp;oacute;n (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0a9bed41fa9dc82d2411813ba4cd5aaf2c196c" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cd0398b440416c926e7804be57c89537c5981d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection,IntSet,IntSet&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d760c200e2de1ecfe11a45e3c9ba9e00d49b55" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,HashSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55ee14251fac7a554607f3d394b09fff77a9156" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,IntSet&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5157075fe8e50531bece1fec7fce7a27b73dc5c7" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,OrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2391f38322eb20263936b3bfa8fc3471e6b69b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d86fe62b7538063ec7bfae9f6c08a83088df2cff" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c369c41a51b721ffa0c36f0a38f36d5f3fe90653" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#none,typedesc&quot;&gt;none(T) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b739a23c6fc05ac36095d9dd959eb84d6a5a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​para &lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aec4506722e668f1f0e0f5f768a71ec370a8b5c" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#symmetricDifference,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;symmetricDifference(s1, s2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3db9334116c6d200d159599181aa97f7e9eee70" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Alias ​​de &lt;a href=&quot;#union&quot;&gt;uni&amp;oacute;n (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d05f525a9d5842ca8247f623c979e431534b00c1" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629615d6f5a705c8f7b1097b7a9400f5bd7a5892" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union,IntSet,IntSet&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdf5629aa63f19dadb3054a1faf88668b0ab6e7" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;console.error()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d508bd2bfc8a4302e90cc6be8d6bc7082ef911" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5be6f17bdfd8cbcd14d0c4aa54788e9e3d34a0" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;none(T)&lt;/code&gt;.</source>
          <target state="translated">Alias ​​para &lt;code&gt;none(T)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc3c3212c96ed5a75a219cf8a8294e101e81f4cb" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4bb070d318337002207d7bc63945ccae6f4f29" translate="yes" xml:space="preserve">
          <source>Alias for a pair of 32-bit floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453247eb19c6fe7d3343d1380efdd939f40a7501" translate="yes" xml:space="preserve">
          <source>Alias for a pair of 64-bit floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e270057d243cf6c2e5a8adbee3e84192193ba53" translate="yes" xml:space="preserve">
          <source>Alias for for &lt;a href=&quot;#countSetBits,SomeInteger&quot;&gt;countSetBits&lt;/a&gt;. (Hamming weight.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880b74f9b1a7d4cf4585f8c8f387bcb20192549a" translate="yes" xml:space="preserve">
          <source>Alias for for countSetBits (Hamming weight.)</source>
          <target state="translated">Alias para para countSetBits (Hamming weight.)</target>
        </trans-unit>
        <trans-unit id="0232e77b936af53c5f4048ee8a964113bbf4f364" translate="yes" xml:space="preserve">
          <source>Alias for system.`$`(t) since Nim v0.20.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9a23ac422f0e5443e01e349d57322e73288849" translate="yes" xml:space="preserve">
          <source>Alias for the operating system specific &lt;em&gt;&quot;open&quot;&lt;/em&gt; command, &lt;code&gt;&quot;open&quot;&lt;/code&gt; on OSX, MacOS and Windows, &lt;code&gt;&quot;xdg-open&quot;&lt;/code&gt; on Linux, BSD, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c9714cd11c037506385dd8c632916016f242a7" translate="yes" xml:space="preserve">
          <source>Alias for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568b052b7299aeec47ddd0e00e34376220e78ab0" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,CountTable%5BA%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d53854d9ed55920dfe9c1a5678e23d027f6249b" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,CountTableRef%5BA%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e959366fea593503a150254ae712bd5a394741" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,OrderedTable%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd1850ce1081e214177d4dcf503b3402bc74744" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,OrderedTableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1e8c7884ac872c79a473784dcb87beaaeb14a0" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,StringTableRef,string&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ca8c0e914d0f5f1ed59231302c5f6d54c04075" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,Table%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0102eabf21c6e45c1d28c47e4050dd577036f88" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,TableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff4b15fdc5cd6b2d3a14ee08df536409dc7010c" translate="yes" xml:space="preserve">
          <source>Alias to type less.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104cb8eefb7ba374e6a7fdf3bfea02d072081428" translate="yes" xml:space="preserve">
          <source>Aliasing restrictions in parameter passing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b284ccdbe19f7425cb58124eb1637a94d50595" translate="yes" xml:space="preserve">
          <source>Align pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2feaf49576ccc73f2b86d27faa6075fa943090f4" translate="yes" xml:space="preserve">
          <source>Aligns &lt;code&gt;s&lt;/code&gt; using &lt;code&gt;fill&lt;/code&gt; char. This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers.</source>
          <target state="translated">Alinea &lt;code&gt;s&lt;/code&gt; usando el car&amp;aacute;cter de &lt;code&gt;fill&lt;/code&gt; . Esto solo es de inter&amp;eacute;s si desea escribir un proceso de &lt;code&gt;format&lt;/code&gt; o personalizado que deba admitir los especificadores de formato est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="4bcede847bb2505de2a000f871a53d72f1a799bb" translate="yes" xml:space="preserve">
          <source>Aligns a string &lt;code&gt;s&lt;/code&gt; with &lt;code&gt;padding&lt;/code&gt;, so that it is of length &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a373b51ddb20415acc6f2cab49e7a886d4418f7" translate="yes" xml:space="preserve">
          <source>Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">Alinea una cadena &lt;em&gt;es&lt;/em&gt; con &lt;em&gt;el relleno&lt;/em&gt; , por lo que es de longitud &lt;em&gt;recuento&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6628bfc03620870ce42f4844ffc52e6eca7e2b68" translate="yes" xml:space="preserve">
          <source>Aligns a unicode string &lt;code&gt;s&lt;/code&gt; with &lt;code&gt;padding&lt;/code&gt;, so that it has a rune-length of &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f77fc6c5026c1d2d103f3b97daf7c1dbd054f5" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;db_*&lt;/code&gt; modules support the same form of parameter substitution. That is, using the &lt;code&gt;?&lt;/code&gt; (question mark) to signify the place where a value should be placed. For example:</source>
          <target state="translated">Todos los m&amp;oacute;dulos &lt;code&gt;db_*&lt;/code&gt; admiten la misma forma de sustituci&amp;oacute;n de par&amp;aacute;metros. Es decir, usando el &lt;code&gt;?&lt;/code&gt; (signo de interrogaci&amp;oacute;n) para indicar el lugar donde se debe colocar un valor. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9552063c6dac2a0b2b6f80dd47ebd5c82800945e" translate="yes" xml:space="preserve">
          <source>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform.</source>
          <target state="translated">Todos los archivos fuente de Nim están en la codificación UTF-8 (o su subconjunto ASCII).Otras codificaciones no son soportadas.Se puede utilizar cualquiera de las secuencias de terminación de línea de la plataforma estándar-la forma Unix que utiliza ASCII LF (salto de línea),la forma Windows que utiliza la secuencia ASCII CR LF (retorno seguido de salto de línea),o la antigua forma Macintosh que utiliza el carácter ASCII CR (retorno).Todas estas formas pueden ser utilizadas por igual,independientemente de la plataforma.</target>
        </trans-unit>
        <trans-unit id="53be8359eb31c3bb37cefb8008e50675ad0c6bce" translate="yes" xml:space="preserve">
          <source>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of the platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0abd1c94e3986f0fc217d43c9ce2e325e352e8" translate="yes" xml:space="preserve">
          <source>All asynchronous functions returning a &lt;code&gt;Future&lt;/code&gt; will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.</source>
          <target state="translated">Todas las funciones asincr&amp;oacute;nicas que devuelven un &lt;code&gt;Future&lt;/code&gt; no se bloquear&amp;aacute;n. Sin embargo, no regresar&amp;aacute;n de inmediato. Una funci&amp;oacute;n asincr&amp;oacute;nica tendr&amp;aacute; un c&amp;oacute;digo que se ejecutar&amp;aacute; antes de que se realice una solicitud asincr&amp;oacute;nica, en la mayor&amp;iacute;a de los casos este c&amp;oacute;digo configura la solicitud.</target>
        </trans-unit>
        <trans-unit id="00b074df2678b416192356b1a38a849d3da057dd" translate="yes" xml:space="preserve">
          <source>All expressions have a type that is known during semantic analysis. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987c15958bc12d3f55c911e8dc5fec4777c6bc5e" translate="yes" xml:space="preserve">
          <source>All expressions have a type which is known at compile time. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</source>
          <target state="translated">Todas las expresiones tienen un tipo que se conoce en tiempo de compilación.Nim esta estaticamente tipificado.Uno puede declarar nuevos tipos,lo cual es en esencia definir un identificador que puede ser usado para denotar este tipo personalizado.</target>
        </trans-unit>
        <trans-unit id="92809bea6792f7ae6e88db1176236402c1b49d41" translate="yes" xml:space="preserve">
          <source>All fields will have the same sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f984cab28f61b914c2bd533b03fae6756c4294ad" translate="yes" xml:space="preserve">
          <source>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are &lt;em&gt;not&lt;/em&gt; available. The &lt;span id=&quot;system_1&quot;&gt;system&lt;/span&gt; module is automatically imported in every module.</source>
          <target state="translated">Todos los identificadores de un m&amp;oacute;dulo son v&amp;aacute;lidos desde el punto de declaraci&amp;oacute;n hasta el final del m&amp;oacute;dulo. Los identificadores de m&amp;oacute;dulos indirectamente dependientes &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n disponibles. El m&amp;oacute;dulo del &lt;span id=&quot;system_1&quot;&gt;sistema&lt;/span&gt; se importa autom&amp;aacute;ticamente en cada m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="2b758e4da2df5099c4fcdcedcd68afb1e4873ff9" translate="yes" xml:space="preserve">
          <source>All macros and templates can also be used as pragmas. They can be attached to routines (procs, iterators, etc), type names, or type expressions. The compiler will perform the following simple syntactic transformations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cded9aa9ab6801c06f94e1f6e9e5425ed01952a5" translate="yes" xml:space="preserve">
          <source>All of the available idetools commands require you to specify a query location through the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--trackDirty&lt;/code&gt; switches. The general idetools invocations are:</source>
          <target state="translated">Todos los comandos de idetools disponibles requieren que especifique una ubicaci&amp;oacute;n de consulta a trav&amp;eacute;s de los interruptores &lt;code&gt;--track&lt;/code&gt; o &lt;code&gt;--trackDirty&lt;/code&gt; . Las invocaciones de idetools generales son:</target>
        </trans-unit>
        <trans-unit id="433f618d4804b96035339cf390e19dd47ccae945" translate="yes" xml:space="preserve">
          <source>All procedures of this module use this type. Procedures don't directly use &lt;a href=&quot;#StreamObj&quot;&gt;StreamObj&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cbbecb3e99c48c7b4fe7081d99be9e034325bf" translate="yes" xml:space="preserve">
          <source>All string literals are of the type &lt;code&gt;string&lt;/code&gt;. A string in Nim is very similar to a sequence of characters. However, strings in Nim are both zero-terminated and have a length field. One can retrieve the length with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero.</source>
          <target state="translated">Todos los literales de cadena son del tipo &lt;code&gt;string&lt;/code&gt; . Una cadena en Nim es muy similar a una secuencia de caracteres. Sin embargo, las cadenas en Nim terminan en cero y tienen un campo de longitud. Se puede recuperar la longitud con el procedimiento de &lt;code&gt;len&lt;/code&gt; incorporado ; la longitud nunca cuenta el cero final.</target>
        </trans-unit>
        <trans-unit id="c6b1a1f14d43339564b33e2a129f631ca1f3956e" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;tests/caas/*.txt&lt;/code&gt; files encode a session with the compiler:</source>
          <target state="translated">Todos los archivos &lt;code&gt;tests/caas/*.txt&lt;/code&gt; codifican una sesi&amp;oacute;n con el compilador:</target>
        </trans-unit>
        <trans-unit id="674be9ae4a283b604e5d55618b959feb8ee26d62" translate="yes" xml:space="preserve">
          <source>All the characters that count as whitespace (space, tab, vertical tab, carriage return, new line, form feed)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d265f3de6bf8deede109e19dc230beea86f266" translate="yes" xml:space="preserve">
          <source>All the characters that count as whitespace.</source>
          <target state="translated">Todos los personajes que cuentan como espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="0858ffb5249b4b454db4fc31e3311bb8f257c071" translate="yes" xml:space="preserve">
          <source>All the comparison operators can be used with enumeration types.</source>
          <target state="translated">Todos los operadores de comparación pueden utilizarse con los tipos de enumeración.</target>
        </trans-unit>
        <trans-unit id="6c891dcf4573456ce1e2da5262b50d0a08307027" translate="yes" xml:space="preserve">
          <source>All the operations have to perform efficiently. Because a Cellset can become huge a hash table alone is not suitable for this.</source>
          <target state="translated">Todas las operaciones deben realizarse de manera eficiente.Debido a que un Cellset puede llegar a ser enorme,una mesa de hachís por sí sola no es adecuada para esto.</target>
        </trans-unit>
        <trans-unit id="d7919c15f302a782639503db1ddcfd789a925698" translate="yes" xml:space="preserve">
          <source>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence &lt;code&gt;\b&lt;/code&gt; is interpreted as the backspace character (hex 08), and the sequence &lt;code&gt;\X&lt;/code&gt; is interpreted as the character &quot;X&quot;. Outside a character class, these sequences have different meanings (see below).</source>
          <target state="translated">Todas las secuencias que definen un valor de un solo byte o un solo car&amp;aacute;cter UTF-8 (en modo UTF-8) se pueden utilizar tanto dentro como fuera de las clases de caracteres. Adem&amp;aacute;s, dentro de una clase de car&amp;aacute;cter, la secuencia &lt;code&gt;\b&lt;/code&gt; se interpreta como el car&amp;aacute;cter de retroceso (hexadecimal 08) y la secuencia &lt;code&gt;\X&lt;/code&gt; se interpreta como el car&amp;aacute;cter &quot;X&quot;. Fuera de una clase de personaje, estas secuencias tienen diferentes significados (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="169951f4b6d1d7f1a4b31b9a082c85cf7bcb2136" translate="yes" xml:space="preserve">
          <source>All top level constants or types appearing within the concept body are accessible through the dot operator in procs where the concept was successfully matched to a concrete type:</source>
          <target state="translated">Todas las constantes o tipos de nivel superior que aparecen en el cuerpo del concepto son accesibles a través del operador de puntos en los procedimientos en los que el concepto se ha adaptado con éxito a un tipo concreto:</target>
        </trans-unit>
        <trans-unit id="3c975cb1e2ba6e75d38b206700dca326fdb354fc" translate="yes" xml:space="preserve">
          <source>All types for that &lt;code&gt;nil&lt;/code&gt; is a valid value can be annotated to exclude &lt;code&gt;nil&lt;/code&gt; as a valid value with the &lt;code&gt;not nil&lt;/code&gt; annotation:</source>
          <target state="translated">Todos los tipos para ese &lt;code&gt;nil&lt;/code&gt; es un valor v&amp;aacute;lido se pueden anotar para excluir &lt;code&gt;nil&lt;/code&gt; como un valor v&amp;aacute;lido con la anotaci&amp;oacute;n &lt;code&gt;not nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="92ecd37f4fed9b99ae21b4e468d434ca109d4a8c" translate="yes" xml:space="preserve">
          <source>All types for which &lt;code&gt;nil&lt;/code&gt; is a valid value can be annotated with the &lt;code&gt;not nil&lt;/code&gt; annotation to exclude &lt;code&gt;nil&lt;/code&gt; as a valid value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f502b4a3c8124f068d8f4c024865eb1ab5a1cf4" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b20fff58bbd0e44f2a2e2e6eb582620afd21c21" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block on the shared heap with at least &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f5a857e75063995215816821d0f1770f35f73c" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54289ede638acbe864667fd63428f7048731c3e6" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block with at least &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac79cefc92c75eb439b3995e551d8211d527174a" translate="yes" xml:space="preserve">
          <source>AllowCommonBase:</source>
          <target state="translated">AllowCommonBase:</target>
        </trans-unit>
        <trans-unit id="e1533f097a691960fb636e648fa3a6a10f49cb06" translate="yes" xml:space="preserve">
          <source>Allowed types for &lt;code&gt;T&lt;/code&gt; are integers, floats, and enums without holes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa2aa3af7fa08673515debab6b959324fc3ac7e" translate="yes" xml:space="preserve">
          <source>Allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712e713171e76aececc409bac7c3780f3eb452be" translate="yes" xml:space="preserve">
          <source>Also known as (in other languages)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3670407090c86340b7a0b2e617c282de436932" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;dumpAstGen&lt;/code&gt; and &lt;code&gt;dumpLisp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2407067910847be1a5da2135b6ce96e939f954b3" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;dumpAstGen&lt;/code&gt; and &lt;code&gt;dumpTree&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29cad5adcb6a93f7398629c014ec484347ea3bc" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;dumpTree&lt;/code&gt; and &lt;code&gt;dumpLisp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029f6357cfa5fa54f588a79c60e26072ee6dc04a" translate="yes" xml:space="preserve">
          <source>Also, you won't find raw &lt;code&gt;\n&lt;/code&gt; characters breaking the one answer per line format. Instead you will need to parse sequences in the form &lt;code&gt;\xHH&lt;/code&gt;, where &lt;em&gt;HH&lt;/em&gt; is a hexadecimal value (e.g. newlines generate the sequence &lt;code&gt;\x0A&lt;/code&gt;).</source>
          <target state="translated">Adem&amp;aacute;s, no encontrar&amp;aacute; caracteres &lt;code&gt;\n&lt;/code&gt; sin procesar que rompan el formato de una respuesta por l&amp;iacute;nea. En su lugar, necesitar&amp;aacute; analizar secuencias en la forma &lt;code&gt;\xHH&lt;/code&gt; , donde &lt;em&gt;HH&lt;/em&gt; es un valor hexadecimal (por ejemplo, las nuevas l&amp;iacute;neas generan la secuencia &lt;code&gt;\x0A&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4521b364cb9ce19f839632eb99d99bb31f52f57b" translate="yes" xml:space="preserve">
          <source>Alternate version of the above.</source>
          <target state="translated">Versión alternativa de lo anterior.</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="d29cbcd3570c897268db2aa03ceca37c4f9af02e" translate="yes" xml:space="preserve">
          <source>Alternatively, it is possible to use &lt;code&gt;getCurrentException&lt;/code&gt; to retrieve the exception that has been raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a6f9561b6fb31bcce22dd9eefb7cb23c8efb12" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;distinct&lt;/code&gt; type modifier can be applied to the type class to allow each param matching the type class to bind to a different type. Such type classes are called &lt;span id=&quot;bind-many_1&quot;&gt;bind many&lt;/span&gt; types.</source>
          <target state="translated">Alternativamente, el modificador de tipo &lt;code&gt;distinct&lt;/code&gt; se puede aplicar a la clase de tipo para permitir que cada par&amp;aacute;metro que coincida con la clase de tipo se vincule a un tipo diferente. Estas clases de tipos se denominan &lt;span id=&quot;bind-many_1&quot;&gt;unir muchos&lt;/span&gt; tipos.</target>
        </trans-unit>
        <trans-unit id="c5c9b8d75bae0a4e7883c1afe39fba029a2a402f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;em&gt;type&lt;/em&gt; operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</source>
          <target state="translated">Alternativamente, el operador de &lt;em&gt;tipo&lt;/em&gt; se puede usar sobre los par&amp;aacute;metros de proceso para un efecto similar cuando se usan clases de tipos an&amp;oacute;nimas o distintas.</target>
        </trans-unit>
        <trans-unit id="5b30b701e37924ad0c27b052555995c52f8814d1" translate="yes" xml:space="preserve">
          <source>Although Nim supports a variety of code and formatting styles, it is nevertheless beneficial that certain community efforts, such as the standard library, should follow a consistent set of style guidelines when suitable. This enhancement proposal aims to list a series of guidelines that the standard library should follow.</source>
          <target state="translated">Aunque Nim soporta una variedad de estilos de código y formato,es sin embargo beneficioso que ciertos esfuerzos de la comunidad,como la biblioteca estándar,sigan un conjunto consistente de pautas de estilo cuando sea apropiado.Esta propuesta de mejora tiene por objeto enumerar una serie de directrices que la biblioteca estándar debería seguir.</target>
        </trans-unit>
        <trans-unit id="cd0ad178d074aad3f70271e85d87e8380aa9e712" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;times&lt;/code&gt; module supports nanosecond time resolution, the resolution used by &lt;code&gt;getTime()&lt;/code&gt; depends on the platform and backend (JS is limited to millisecond precision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e818f14ba9bbedb672b0a658dcc233bb37218e4d" translate="yes" xml:space="preserve">
          <source>Although the types use nanosecond time resolution, the underlying resolution used by &lt;code&gt;getTime()&lt;/code&gt; depends on the platform and backend (JS is limited to millisecond precision).</source>
          <target state="translated">Aunque los tipos utilizan una resoluci&amp;oacute;n de tiempo de nanosegundos, la resoluci&amp;oacute;n subyacente utilizada por &lt;code&gt;getTime()&lt;/code&gt; depende de la plataforma y el backend (JS est&amp;aacute; limitado a una precisi&amp;oacute;n de milisegundos).</target>
        </trans-unit>
        <trans-unit id="a1980deb423f91e0ac3552e894ae9e6ff761680b" translate="yes" xml:space="preserve">
          <source>Although this module has &lt;code&gt;seq&lt;/code&gt; in its name, it implements operations not only for &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type, but for three built-in container types under the &lt;code&gt;openArray&lt;/code&gt; umbrella:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c0c9ff9b3e9a28a9649fc31261da1cd44edd57" translate="yes" xml:space="preserve">
          <source>Although use of whitespace for stylistic reasons other than the ones endorsed by this guide are allowed, careful thought should be put into such practices. Not all editors support automatic alignment of code sections, and re-aligning long sections of code by hand can quickly become tedious.</source>
          <target state="translated">Aunque se permite el uso de los espacios en blanco por razones estilísticas distintas de las aprobadas en esta guía,se debe pensar cuidadosamente en tales prácticas.No todos los editores apoyan la alineación automática de las secciones de código,y la realineación de largas secciones de código a mano puede resultar rápidamente tediosa.</target>
        </trans-unit>
        <trans-unit id="91fc7a21703d6509e49f44ea9f9faec24ea18eb4" translate="yes" xml:space="preserve">
          <source>Always spawns a new task on the worker thread with &lt;code&gt;id&lt;/code&gt;, so that the &lt;code&gt;call&lt;/code&gt; is &lt;strong&gt;always&lt;/strong&gt; executed on the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb3dbed99e04b239b1de48db1267c46da599c66" translate="yes" xml:space="preserve">
          <source>Always spawns a new task, so that the &lt;code&gt;call&lt;/code&gt; is never executed on the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614ddcbf931903423c230b8f0212d11059c5ec82" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ValueError&lt;/code&gt; exception will be thrown if no exception exists in the specified Future.</source>
          <target state="translated">Se &lt;code&gt;ValueError&lt;/code&gt; excepci&amp;oacute;n ValueError si no existe ninguna excepci&amp;oacute;n en el futuro especificado.</target>
        </trans-unit>
        <trans-unit id="ef24e3c1b8f7b901d42c45e46f29ceddb0745dc1" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;export&lt;/code&gt; statement can be used for symbol forwarding so that client modules don't need to import a module's dependencies:</source>
          <target state="translated">Se puede utilizar una declaraci&amp;oacute;n de &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n para el reenv&amp;iacute;o de s&amp;iacute;mbolos, de modo que los m&amp;oacute;dulos de cliente no necesiten importar las dependencias de un m&amp;oacute;dulo:</target>
        </trans-unit>
        <trans-unit id="f25fd35f79132b361f9e115a28ec0aeef24ee99a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if expression&lt;/code&gt; is almost like an if statement, but it is an expression. This feature is similar to &lt;code&gt;ternary operators&lt;/code&gt; in other languages. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a35d34d5220f34295669a5c8b933dc1ceedeca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;untyped&lt;/code&gt; parameter means that symbol lookups and type resolution is not performed before the expression is passed to the template. This means that for example &lt;em&gt;undeclared&lt;/em&gt; identifiers can be passed to the template:</source>
          <target state="translated">Un par&amp;aacute;metro sin &lt;code&gt;untyped&lt;/code&gt; significa que las b&amp;uacute;squedas de s&amp;iacute;mbolos y la resoluci&amp;oacute;n de tipos no se realizan antes de que la expresi&amp;oacute;n se pase a la plantilla. Esto significa que, por ejemplo, los identificadores &lt;em&gt;no declarados&lt;/em&gt; se pueden pasar a la plantilla:</target>
        </trans-unit>
        <trans-unit id="bae34c49da483225476ede34178ee0a4cd7dbb4e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;if expression&lt;/em&gt; is almost like an if statement, but it is an expression. Example:</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n if&lt;/em&gt; es casi como una declaraci&amp;oacute;n if, pero es una expresi&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="6913655373469dbc7b3bf423a90b3116ade5a64c" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;identifier_1&quot;&gt;identifier&lt;/span&gt; is a symbol declared as a name for a variable, type, procedure, etc. The region of the program over which a declaration applies is called the &lt;span id=&quot;scope_1&quot;&gt;scope&lt;/span&gt; of the declaration. Scopes can be nested. The meaning of an identifier is determined by the smallest enclosing scope in which the identifier is declared unless overloading resolution rules suggest otherwise.</source>
          <target state="translated">Un &lt;span id=&quot;identifier_1&quot;&gt;identificador&lt;/span&gt; es un s&amp;iacute;mbolo declarado como nombre de una variable, tipo, procedimiento, etc. La regi&amp;oacute;n del programa sobre la que se aplica una declaraci&amp;oacute;n se denomina &lt;span id=&quot;scope_1&quot;&gt;alcance&lt;/span&gt; de la declaraci&amp;oacute;n. Los &amp;aacute;mbitos se pueden anidar. El significado de un identificador est&amp;aacute; determinado por el &amp;aacute;mbito envolvente m&amp;aacute;s peque&amp;ntilde;o en el que se declara el identificador, a menos que las reglas de resoluci&amp;oacute;n de sobrecarga sugieran lo contrario.</target>
        </trans-unit>
        <trans-unit id="061ca26b5cf33352ffc7a1f211f8bce9704c6837" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;unchecked runtime error&lt;/span&gt; is an error that is not guaranteed to be detected and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only &lt;span id=&quot;safe_1&quot;&gt;safe&lt;/span&gt; language features are used and if no runtime checks are disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d850be93dc755d2b65d8e923239958da9648c2" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;unchecked runtime error&lt;/span&gt; is an error that is not guaranteed to be detected, and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only &lt;span id=&quot;safe_1&quot;&gt;safe&lt;/span&gt; language features are used.</source>
          <target state="translated">Un &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;error de tiempo de ejecuci&amp;oacute;n no verificado&lt;/span&gt; es un error que no se garantiza que se detecte y puede causar que el comportamiento posterior del c&amp;aacute;lculo sea arbitrario. No se pueden producir errores de tiempo de ejecuci&amp;oacute;n sin comprobar si solo se utilizan funciones de lenguaje &lt;span id=&quot;safe_1&quot;&gt;seguro&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="d086f48ed32221353a34e9e09e19fc50d2b08517" translate="yes" xml:space="preserve">
          <source>An EOS (or ESSL if socket is an SSL socket) exception is raised if an error occurs.</source>
          <target state="translated">Una excepción EOS (o ESSL si el zócalo es un zócalo SSL)se plantea si se produce un error.</target>
        </trans-unit>
        <trans-unit id="fad595a4ff6c034a05915aa77a9cf525f3217cd5" translate="yes" xml:space="preserve">
          <source>An EOS exception will be raised in the case of a socket error.</source>
          <target state="translated">Una excepción de EOS se planteará en el caso de un error en el enchufe.</target>
        </trans-unit>
        <trans-unit id="a41070b200aa0a43fc8f9636da9beacac7babdfd" translate="yes" xml:space="preserve">
          <source>An OS-dependent trailing slash is always present at the end of the returned string: &lt;code&gt;\&lt;/code&gt; on Windows and &lt;code&gt;/&lt;/code&gt; on all other OSs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3690729b1f993aa06abd14818e2a3ebd8ae6f4b1" translate="yes" xml:space="preserve">
          <source>An OS-dependent trailing slash is always present at the end of the returned string; &lt;em&gt;` on Windows and `/&lt;/em&gt; on all other OSs.</source>
          <target state="translated">Una barra diagonal dependiente del sistema operativo siempre est&amp;aacute; presente al final de la cadena devuelta; &lt;em&gt;`en Windows y` /&lt;/em&gt; en todos los dem&amp;aacute;s sistemas operativos.</target>
        </trans-unit>
        <trans-unit id="77a75598b28ac56217ca4e4f23642a8de53aad21" translate="yes" xml:space="preserve">
          <source>An OSError exception will be raised in the case of a socket error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcebf55778fdd55bc0aef73bf199c5931d349101" translate="yes" xml:space="preserve">
          <source>An OpenSSL-compatible list of secure ciphers for &lt;code&gt;intermediate&lt;/code&gt; compatibility per Mozilla's recommendations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18dbf60b64cda66a330d893f00943a347f1aec0" translate="yes" xml:space="preserve">
          <source>An OpenSSL-compatible list of secure ciphers for &lt;code&gt;modern&lt;/code&gt; compatibility per Mozilla's recommendations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e9fa120e4714aa850b21cb9c6254a6941df14a" translate="yes" xml:space="preserve">
          <source>An OpenSSL-compatible list of secure ciphers for &lt;code&gt;old&lt;/code&gt; compatibility per Mozilla's recommendations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3e1e808c3ac2cd8bce70c2071d873e2b0a45d7" translate="yes" xml:space="preserve">
          <source>An SQL statement that is passed from Nim to an SQL database might be modeled as a string. However, using string templates and filling in the values is vulnerable to the famous &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL injection attack&lt;/span&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3c7dd4ccfc76b560ed8bea7cb91f6e590b5de7" translate="yes" xml:space="preserve">
          <source>An SQL statement that is passed from Nim to an SQL database might be modelled as a string. However, using string templates and filling in the values is vulnerable to the famous &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL injection attack&lt;/span&gt;:</source>
          <target state="translated">Una sentencia SQL que se pasa de Nim a una base de datos SQL puede modelarse como una cadena. Sin embargo, usar plantillas de cadenas y completar los valores es vulnerable al famoso &lt;span id=&quot;sql-injection-attack_1&quot;&gt;ataque de inyecci&amp;oacute;n SQL&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="5abe3bd69e1de1da07178a2dcf83b8a0e9e325db" translate="yes" xml:space="preserve">
          <source>An XML tree consisting of XML nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd2fa1e084904d43296b92e52e48ff7123e1dd7" translate="yes" xml:space="preserve">
          <source>An address &lt;code&gt;addr e&lt;/code&gt;, &lt;code&gt;unsafeAddr e&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7795a2e689db190d98598b1e86b20a8411fd21d9" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#copyNimTree,NimNode&quot;&gt;copyNimTree&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9093985afcfa2beb7d11ea5796b36f8e9f0e1e" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#toUTF8,Rune&quot;&gt;toUTF8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b5b2a52bea6b4b6255ab33c977d4534669e142" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Un alias para &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f00085e2b37649dce2a25cb412e211917fdc7f3a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;HSlice[T, T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aafd9574ef1f09f128ef8bee0667f414aed2e4d" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;card(x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959b4a587a6c12a87ac5b29c9adffb9fc202ff33" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;countup(a, b, 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f8477f1f960888a217819d2f42f5938ea92f4e" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0d0c1d9f0d46bf4db307164d8c963a24877861" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f71273341163aba9e8123c101abbac1d7b95268" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ce91b4a997d2fb64eebe61b0642c3424992e0b" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544692451d460228f4efd605a86e7c0dab8a35ee" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;countup(a, b, 1)&lt;/em&gt;.</source>
          <target state="translated">Un alias para &lt;em&gt;countup (a, b, 1)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="936583901537efa6474af706c7cbc7258cf9502a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">Un alias para el &lt;em&gt;nombre&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b1a1ef6cada9bfa0dc5126e5bf955852c7a8cf" translate="yes" xml:space="preserve">
          <source>An alias for a string to string mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96ad4829046669ed22f88ed72333f46e46f422a" translate="yes" xml:space="preserve">
          <source>An alias for copyNimTree().</source>
          <target state="translated">Un alias para copyNimTree().</target>
        </trans-unit>
        <trans-unit id="002f21bee61c35000fab0c465633c7a8f89a5b1a" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or the same as &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt; if only one separator character exists. This is set to &lt;code&gt;'/'&lt;/code&gt; on Windows systems where &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt; is a backslash (&lt;code&gt;'\'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb4f7d6ba1dc1ca472b28bc42274504e162f7f7" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or the same as &lt;em&gt;DirSep&lt;/em&gt; if only one separator character exists. This is set to '/' on Windows systems where &lt;em&gt;DirSep&lt;/em&gt; is a backslash.</source>
          <target state="translated">Un car&amp;aacute;cter alternativo utilizado por el sistema operativo para separar los componentes del nombre de ruta, o el mismo que &lt;em&gt;DirSep&lt;/em&gt; si solo existe un car&amp;aacute;cter separador. Se establece en '/' en sistemas Windows donde &lt;em&gt;DirSep&lt;/em&gt; es una barra invertida.</target>
        </trans-unit>
        <trans-unit id="b10f9786df0315b28bef975ab41acecfb36800af" translate="yes" xml:space="preserve">
          <source>An apostrophe &lt;code&gt;'&lt;/code&gt; followed by an integer &lt;code&gt;i&lt;/code&gt; in the range 0..9 is replaced by the i'th parameter &lt;em&gt;type&lt;/em&gt;. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the &lt;code&gt;'&lt;/code&gt; and the digit an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; &lt;code&gt;T*&lt;/code&gt; becomes &lt;code&gt;T&lt;/code&gt;.) Two stars can be used to get to the element type of the element type etc.</source>
          <target state="translated">Un ap&amp;oacute;strofo &lt;code&gt;'&lt;/code&gt; seguido de un entero &lt;code&gt;i&lt;/code&gt; en el rango 0..9 se reemplaza por el &lt;em&gt;tipo de&lt;/em&gt; par&amp;aacute;metro i'th . La posici&amp;oacute;n 0 es el tipo de resultado. Esto se puede utilizar para pasar tipos a las plantillas de funciones de C ++. Entre el &lt;code&gt;'&lt;/code&gt; y el d&amp;iacute;gito se puede usar un asterisco para llegar al tipo base del tipo. (Por lo tanto, &quot;quita una estrella&quot; del tipo; &lt;code&gt;T*&lt;/code&gt; se convierte en &lt;code&gt;T&lt;/code&gt; . ) Se pueden usar dos estrellas para llegar al tipo de elemento del tipo de elemento, etc.</target>
        </trans-unit>
        <trans-unit id="c03a36e70e10adf9514f0958ccf602427aab976e" translate="yes" xml:space="preserve">
          <source>An apostrophe &lt;code&gt;'&lt;/code&gt; followed by an integer &lt;code&gt;i&lt;/code&gt; in the range 0..9 is replaced by the i'th parameter &lt;em&gt;type&lt;/em&gt;. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the &lt;code&gt;'&lt;/code&gt; and the digit, an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; &lt;code&gt;T*&lt;/code&gt; becomes &lt;code&gt;T&lt;/code&gt;.) Two stars can be used to get to the element type of the element type etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb824cc35be0f255f85608320e99c712d9187e72" translate="yes" xml:space="preserve">
          <source>An array constructor can have explicit indexes for readability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf4f417901eafdc569fc787f5454f9027073421" translate="yes" xml:space="preserve">
          <source>An array is a simple fixed length container. Each element in an array has the same type. The array's index type can be any ordinal type.</source>
          <target state="translated">Un array es un simple contenedor de longitud fija.Cada elemento de una matriz tiene el mismo tipo.El tipo de índice de la matriz puede ser cualquier tipo ordinal.</target>
        </trans-unit>
        <trans-unit id="2bb0838f1de59fe1b1009e5516379cb480056e4d" translate="yes" xml:space="preserve">
          <source>An array type can be defined using the &lt;code&gt;array[size, T]&lt;/code&gt; syntax, or using &lt;code&gt;array[lo..hi, T]&lt;/code&gt; for arrays that start at an index other than zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d1d57ff3f35fb4d74599ef1b920f45e23521b6" translate="yes" xml:space="preserve">
          <source>An asynchronous procedure is marked using the &lt;code&gt;{.async.}&lt;/code&gt; pragma. When marking a procedure with the &lt;code&gt;{.async.}&lt;/code&gt; pragma it must have a &lt;code&gt;Future[T]&lt;/code&gt; return type or no return type at all. If you do not specify a return type then &lt;code&gt;Future[void]&lt;/code&gt; is assumed.</source>
          <target state="translated">Un procedimiento asincr&amp;oacute;nico se marca mediante el &lt;code&gt;{.async.}&lt;/code&gt; . Cuando se marca un procedimiento con el &lt;code&gt;{.async.}&lt;/code&gt; , Debe tener un tipo de retorno &lt;code&gt;Future[T]&lt;/code&gt; o ning&amp;uacute;n tipo de retorno. Si no especifica un tipo de retorno &lt;code&gt;Future[void]&lt;/code&gt; se asume Future [void] .</target>
        </trans-unit>
        <trans-unit id="00cfb3b823850859ac087c9650335459fba3693e" translate="yes" xml:space="preserve">
          <source>An at symbol &lt;code&gt;@&lt;/code&gt; is replaced by the remaining arguments, separated by commas.</source>
          <target state="translated">Un s&amp;iacute;mbolo &lt;code&gt;@&lt;/code&gt; se reemplaza por los argumentos restantes, separados por comas.</target>
        </trans-unit>
        <trans-unit id="c7fb5b882232e37ef9e5f09cc9c28ae067b4a127" translate="yes" xml:space="preserve">
          <source>An efficient set of &lt;code&gt;int&lt;/code&gt; implemented as a sparse bit set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2e033ba877aaf8286b45d11a814ea58fa8eced" translate="yes" xml:space="preserve">
          <source>An efficient string substitution operator &lt;a href=&quot;#%25,string,StringTableRef,set%5BFormatFlag%5D&quot;&gt;%&lt;/a&gt; for the string table is also provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a7ceb8146505e07f088182b71243011ca4cc3a" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;discard&lt;/code&gt; statement is often used as a null statement:</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;discard&lt;/code&gt; vac&amp;iacute;a se usa a menudo como una declaraci&amp;oacute;n nula:</target>
        </trans-unit>
        <trans-unit id="63b984f97355b1726a5cf0fa4b3612ccc2253bdc" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;raises&lt;/code&gt; list (&lt;code&gt;raises: []&lt;/code&gt;) means that no exception may be raised:</source>
          <target state="translated">Una lista de &lt;code&gt;raises&lt;/code&gt; vac&amp;iacute;a ( &lt;code&gt;raises: []&lt;/code&gt; ) significa que no se puede generar ninguna excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="3d47e32abe2e2402012d539378c2021368794e6d" translate="yes" xml:space="preserve">
          <source>An empty subscript &lt;code&gt;[]&lt;/code&gt; notation can be used to de-refer a reference, the &lt;code&gt;addr&lt;/code&gt; procedure returns the address of an item. An address is always an untraced reference. Thus the usage of &lt;code&gt;addr&lt;/code&gt; is an &lt;em&gt;unsafe&lt;/em&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f5c98cab13364c0bdb7873271e1f3fbcb787f2" translate="yes" xml:space="preserve">
          <source>An empty subscript &lt;code&gt;[]&lt;/code&gt; notation can be used to derefer a reference, the &lt;code&gt;addr&lt;/code&gt; procedure returns the address of an item. An address is always an untraced reference. Thus the usage of &lt;code&gt;addr&lt;/code&gt; is an &lt;em&gt;unsafe&lt;/em&gt; feature.</source>
          <target state="translated">Se puede usar una notaci&amp;oacute;n de sub&amp;iacute;ndice &lt;code&gt;[]&lt;/code&gt; vac&amp;iacute;a para eliminar una referencia, el procedimiento &lt;code&gt;addr&lt;/code&gt; devuelve la direcci&amp;oacute;n de un elemento. Una direcci&amp;oacute;n es siempre una referencia sin rastrear. Por tanto, el uso de &lt;code&gt;addr&lt;/code&gt; es una caracter&amp;iacute;stica &lt;em&gt;peligrosa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fd0163ff197f89984c82c49af75d8bfe8b3b9a66" translate="yes" xml:space="preserve">
          <source>An enum can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that it's fields are added to a special module specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as &lt;code&gt;MyEnum.value&lt;/code&gt;:</source>
          <target state="translated">Una enumeraci&amp;oacute;n se puede marcar con el pragma &lt;code&gt;pure&lt;/code&gt; para que sus campos se agreguen a un &amp;aacute;mbito oculto espec&amp;iacute;fico del m&amp;oacute;dulo especial que solo se consulta como &amp;uacute;ltimo intento. Solo se agregan a este alcance s&amp;iacute;mbolos no ambiguos. Pero siempre se puede acceder a estos a trav&amp;eacute;s de la calificaci&amp;oacute;n de tipo escrita como &lt;code&gt;MyEnum.value&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eaad6be6b078620419d11201c663302e39f56608" translate="yes" xml:space="preserve">
          <source>An enum can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that its fields are added to a special module-specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as &lt;code&gt;MyEnum.value&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390d5ff2cbaae78dc0fa4290b4e9610666cc8fdf" translate="yes" xml:space="preserve">
          <source>An enum type can be marked as &lt;code&gt;pure&lt;/code&gt;. Then access of its fields always requires full qualification.</source>
          <target state="translated">Un tipo de enumeraci&amp;oacute;n se puede marcar como &lt;code&gt;pure&lt;/code&gt; . Entonces, el acceso a sus campos siempre requiere una calificaci&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="367c78270c2f231073a0357927182872afdf0f63" translate="yes" xml:space="preserve">
          <source>An enum which hold event types</source>
          <target state="translated">Una lista que contiene los tipos de eventos</target>
        </trans-unit>
        <trans-unit id="4dcfd8f767ff68c968ba90d84fa6dca78b2ac575" translate="yes" xml:space="preserve">
          <source>An enumeration's symbol can be qualified to avoid ambiguities: &lt;code&gt;Direction.south&lt;/code&gt;.</source>
          <target state="translated">El s&amp;iacute;mbolo de una enumeraci&amp;oacute;n se puede calificar para evitar ambig&amp;uuml;edades: &lt;code&gt;Direction.south&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83a58494419b1a3e524ebfb95e03913553034371" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;handleAccept&lt;/code&gt; follows:</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo de &lt;code&gt;handleAccept&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e19bbd77ddbc01db0ebc7ba2f0156d47d7b3cf8a" translate="yes" xml:space="preserve">
          <source>An example of a third party NimScript that can be used as a project-agnostic tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="e9998341fd216c991313f370f4227cc960a0fb79" translate="yes" xml:space="preserve">
          <source>An exception that is raised if a parsing error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993744896fbb24a8143d61db93a5b797f2af5f88" translate="yes" xml:space="preserve">
          <source>An explicit ordered enum can have &lt;em&gt;holes&lt;/em&gt;:</source>
          <target state="translated">Una enumeraci&amp;oacute;n ordenada expl&amp;iacute;cita puede tener &lt;em&gt;agujeros&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a5f3c80df868038bd59209ddaecef0136b0eb492" translate="yes" xml:space="preserve">
          <source>An exported helper proc that parses the &quot;standard format specifiers&quot;, as specified by the grammar:</source>
          <target state="translated">Un procedimiento de ayuda exportado que analiza los &quot;especificadores de formato estándar&quot;,según lo especificado por la gramática:</target>
        </trans-unit>
        <trans-unit id="1740d5d24639d030a6825021bc6785735bbaf14c" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;b&lt;/code&gt; can be assigned to an expression &lt;code&gt;a&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is an &lt;code&gt;l-value&lt;/code&gt; and &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; holds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129cc9980afbc0b6d02dd90e59a7e2eac8eb8d2f" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;b&lt;/code&gt; can be assigned to an expression &lt;code&gt;a&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is an &lt;em&gt;l-value&lt;/em&gt; and &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; holds.</source>
          <target state="translated">Se puede asignar una expresi&amp;oacute;n &lt;code&gt;b&lt;/code&gt; a una expresi&amp;oacute;n &lt;code&gt;a&lt;/code&gt; si &lt;code&gt;a&lt;/code&gt; es un &lt;em&gt;valor l&lt;/em&gt; y se &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d2a0ca1f92482471cb1498e046b1a61df5075bd" translate="yes" xml:space="preserve">
          <source>An expression like &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; is transformed into:</source>
          <target state="translated">Una expresi&amp;oacute;n como &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; se transforma en:</target>
        </trans-unit>
        <trans-unit id="76b9af7a299b61f177bed7560a19266b0bd700fc" translate="yes" xml:space="preserve">
          <source>An expression specifies a computation that produces a value or location. Expressions that produce locations are called &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt;. An l-value can denote either a location or the value the location contains, depending on the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf1e65690ce8b0321d174674e5faf95e0f45bd9" translate="yes" xml:space="preserve">
          <source>An expression specifies a computation that produces a value or location. Expressions that produce locations are called &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt;. An l-value can denote either a location or the value the location contains, depending on the context. Expressions whose values can be determined statically are called &lt;span id=&quot;constant-expressions_1&quot;&gt;constant expressions&lt;/span&gt;; they are never l-values.</source>
          <target state="translated">Una expresi&amp;oacute;n especifica un c&amp;aacute;lculo que produce un valor o una ubicaci&amp;oacute;n. Las expresiones que producen ubicaciones se denominan &lt;span id=&quot;lminusvalues_1&quot;&gt;valores l&lt;/span&gt; . Un valor l puede denotar una ubicaci&amp;oacute;n o el valor que contiene la ubicaci&amp;oacute;n, seg&amp;uacute;n el contexto. Las expresiones cuyos valores pueden determinarse est&amp;aacute;ticamente se denominan &lt;span id=&quot;constant-expressions_1&quot;&gt;expresiones constantes&lt;/span&gt; ; nunca son valores l.</target>
        </trans-unit>
        <trans-unit id="1e306939f1b61ed5f05365a4a82b6e0e9f803e5d" translate="yes" xml:space="preserve">
          <source>An if expression always results in a value, so the &lt;code&gt;else&lt;/code&gt; part is required. &lt;code&gt;Elif&lt;/code&gt; parts are also allowed.</source>
          <target state="translated">Una expresi&amp;oacute;n if siempre da como resultado un valor, por lo &lt;code&gt;else&lt;/code&gt; se requiere la parte else . Tambi&amp;eacute;n se permiten piezas &lt;code&gt;Elif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52bb3e3582fbbd15c8e7dfa59ed8c1522b97dbbb" translate="yes" xml:space="preserve">
          <source>An implementation is allowed, but not required to implement even more move optimizations (and the current implementation does not).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f00c59e69693d5b27bf05aeea67c1b5656b713" translate="yes" xml:space="preserve">
          <source>An implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; are true.</source>
          <target state="translated">Una implementaci&amp;oacute;n siempre debe usar la m&amp;aacute;xima precisi&amp;oacute;n disponible para evaluar los valores de puntero flotante en tiempo de compilaci&amp;oacute;n; esto significa que expresiones como &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; son verdaderas.</target>
        </trans-unit>
        <trans-unit id="d6942353b7235c1c4c99f2905af32ba03130a9b6" translate="yes" xml:space="preserve">
          <source>An implementation should always use the maximum precision available to evaluate floating pointer values during semantic analysis; this means expressions like &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; that are evaluating during constant folding are true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ea9795e8ce3c7c45d40d4ccbcfe9496b8bf2f5" translate="yes" xml:space="preserve">
          <source>An input and an output parameter should not be aliased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e0a9097c3ec985d934476c81741a7015f09640" translate="yes" xml:space="preserve">
          <source>An input parameter should not be aliased with a global or thread local variable updated by the called proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faf8ef86d99d8f87188a85418d2cafbed7c672a" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at &lt;strong&gt;0&lt;/strong&gt;.</source>
          <target state="translated">Un n&amp;uacute;mero entero con la columna que vas a consultar. Para el compilador, las columnas comienzan en &lt;strong&gt;0&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7140df7bbe5e3e07dff6576529cef23b438e6cf3" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at zero, so the first column will be &lt;strong&gt;0&lt;/strong&gt; and the last in an 80 column terminal will be &lt;strong&gt;79&lt;/strong&gt;.</source>
          <target state="translated">Un n&amp;uacute;mero entero con la columna que vas a consultar. Para las columnas del compilador comienzan en cero, por lo que la primera columna ser&amp;aacute; &lt;strong&gt;0&lt;/strong&gt; y la &amp;uacute;ltima en una terminal de 80 columnas ser&amp;aacute; &lt;strong&gt;79&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="58c18cab7c4720f0e3aa95f69ca0b844006c41f0" translate="yes" xml:space="preserve">
          <source>An integer with the line you are going to query. For the compiler lines start at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">Un n&amp;uacute;mero entero con la l&amp;iacute;nea que vas a consultar. Para las l&amp;iacute;neas del compilador, comience en &lt;strong&gt;1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fd63b4dca2c3b56a63f528ea8506804126dab43c" translate="yes" xml:space="preserve">
          <source>An iterator is similar to a procedure, except that it can be called in the context of a &lt;code&gt;for&lt;/code&gt; loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a &lt;code&gt;for&lt;/code&gt; loop plays the &lt;code&gt;yield&lt;/code&gt; statement in the called iterator. Whenever a &lt;code&gt;yield&lt;/code&gt; statement is reached the data is bound to the &lt;code&gt;for&lt;/code&gt; loop variables and control continues in the body of the &lt;code&gt;for&lt;/code&gt; loop. The iterator's local variables and execution state are automatically saved between calls. Example:</source>
          <target state="translated">Un iterador es similar a un procedimiento, excepto que se puede llamar en el contexto de un bucle &lt;code&gt;for&lt;/code&gt; . Los iteradores proporcionan una forma de especificar la iteraci&amp;oacute;n sobre un tipo abstracto. Un papel clave en la ejecuci&amp;oacute;n de un bucle &lt;code&gt;for&lt;/code&gt; es la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; en el iterador llamado. Siempre que se alcanza una declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; , los datos est&amp;aacute;n vinculados a las variables del ciclo &lt;code&gt;for&lt;/code&gt; y el control contin&amp;uacute;a en el cuerpo del ciclo &lt;code&gt;for&lt;/code&gt; . Las variables locales del iterador y el estado de ejecuci&amp;oacute;n se guardan autom&amp;aacute;ticamente entre llamadas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="24cf8c2497716b71cb65c781ec360d22d18214d5" translate="yes" xml:space="preserve">
          <source>An l-value matches &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;out T&lt;/code&gt; equally well, hence the following is ambiguous:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5ff3abd757e3cba00a39f18b56b5fb6446a8c0" translate="yes" xml:space="preserve">
          <source>An object type can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</source>
          <target state="translated">Un tipo de objeto se puede marcar con el pragma &lt;code&gt;pure&lt;/code&gt; modo que se omita su campo de tipo que se utiliza para la identificaci&amp;oacute;n del tipo en tiempo de ejecuci&amp;oacute;n. Esto sol&amp;iacute;a ser necesario para la compatibilidad binaria con otros lenguajes compilados.</target>
        </trans-unit>
        <trans-unit id="2e8278ca51d6d95aa64a5e6c057a546e2ca28c42" translate="yes" xml:space="preserve">
          <source>An object which holds descriptors to be checked for read/write status</source>
          <target state="translated">Un objeto que contiene descriptores que deben ser comprobados para el estado de lectura/escritura</target>
        </trans-unit>
        <trans-unit id="3274465cde86ef19fbd6e85a8dde25fac63bf653" translate="yes" xml:space="preserve">
          <source>An object which holds result for descriptor</source>
          <target state="translated">Un objeto que contiene el resultado para el descriptor</target>
        </trans-unit>
        <trans-unit id="e62ca354a533c308819dea987dbbf454b1323735" translate="yes" xml:space="preserve">
          <source>An object which holds user defined event</source>
          <target state="translated">Un objeto que contiene un evento definido por el usuario</target>
        </trans-unit>
        <trans-unit id="004526c446f1ac6d78516b74ee9cfa40b5941993" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if reading from the</source>
          <target state="translated">Se puede especificar un tiempo de espera opcional en milisegundos,si la lectura del</target>
        </trans-unit>
        <trans-unit id="aa761af15969e50c3fbec49ad3e2f8409cbdbbc6" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified a TimeoutError exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0cf6034a987ab54cdc28a91621a1407148ad61" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</source>
          <target state="translated">Se puede especificar un tiempo de espera opcional en milisegundos,si el salto de los bytes toma más tiempo que el especificado se elevará una excepción de ETimeout.</target>
        </trans-unit>
        <trans-unit id="1436ea667171f8c043927d94a1771aba02c31130" translate="yes" xml:space="preserve">
          <source>An optional type that stores its value and state separately in a boolean.</source>
          <target state="translated">Un tipo opcional que almacena su valor y estado por separado en un booleano.</target>
        </trans-unit>
        <trans-unit id="b067be400ecce95bf0995a66c8c39a2c3b939878" translate="yes" xml:space="preserve">
          <source>An output parameter should never be aliased with a global or thread local variable referenced by the called proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1492892ce7573ee3544c47d10217feac9a1ffe27" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the end of the input. No character is consumed. Same as &lt;code&gt;!.&lt;/code&gt;.</source>
          <target state="translated">Anchor: coincide con el final de la entrada. No se consume ning&amp;uacute;n personaje. Igual que &lt;code&gt;!.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28501d5ba1b7346ee45610593888631bf0f75364" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the start of the input. No character is consumed.</source>
          <target state="translated">Ancla:Coincide al principio de la entrada.No se consume ningún personaje.</target>
        </trans-unit>
        <trans-unit id="d5b80e8f8af7973d49e632e415ee520559b6880c" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;main&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;foo/x&lt;/code&gt; is imported. If &lt;code&gt;other&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt; then both &lt;code&gt;$lib/x.nim&lt;/code&gt; and &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; match and so the compiler should reject it. Currently however this check is not implemented and instead the first matching file is used.</source>
          <target state="translated">Y las &lt;code&gt;main&lt;/code&gt; importaciones &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;foo/x&lt;/code&gt; se importan. Si &lt;code&gt;other&lt;/code&gt; importaciones &lt;code&gt;x&lt;/code&gt; , tanto &lt;code&gt;$lib/x.nim&lt;/code&gt; como &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; coinciden, por lo que el compilador deber&amp;iacute;a rechazarlo. Sin embargo, actualmente esta verificaci&amp;oacute;n no est&amp;aacute; implementada y en su lugar se usa el primer archivo coincidente.</target>
        </trans-unit>
        <trans-unit id="6086412d7affac9b3c25d84027f831a4864be34b" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;main&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;foo/x&lt;/code&gt; is imported. If &lt;code&gt;other&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt; then both &lt;code&gt;$lib/x.nim&lt;/code&gt; and &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; match but &lt;code&gt;$lib/x.nim&lt;/code&gt; is used as it is the first match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242f34bf16bfc5e83d5742e55f63b87c019f679a" translate="yes" xml:space="preserve">
          <source>And copy the executable somewhere in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">Y copie el ejecutable en alg&amp;uacute;n lugar de su &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83dda4bc1c55dc87decca365a7ad42665d8106b1" translate="yes" xml:space="preserve">
          <source>And for a debug version compatible with GDB:</source>
          <target state="translated">Y para una versión de depuración compatible con GDB:</target>
        </trans-unit>
        <trans-unit id="514cf3e6609f00e815263ec4ce18e84d001f501a" translate="yes" xml:space="preserve">
          <source>And predicate: Indicate success if expression &lt;code&gt;E&lt;/code&gt; matches the text ahead; otherwise indicate failure. Do not consume any text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8296500ed287ca2f86dd1c2fab187b68fe5d29" translate="yes" xml:space="preserve">
          <source>And predicate: Indicate success if expression &lt;em&gt;E&lt;/em&gt; matches the text ahead; otherwise indicate failure. Do not consume any text.</source>
          <target state="translated">Y predicado: indica el &amp;eacute;xito si la expresi&amp;oacute;n &lt;em&gt;E&lt;/em&gt; coincide con el texto anterior; de lo contrario, indique falla. No consumas ning&amp;uacute;n texto.</target>
        </trans-unit>
        <trans-unit id="47b8afc9ca38e34f60b039e58bc4522a4fe464da" translate="yes" xml:space="preserve">
          <source>And so is::</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd21179e471067255e31c8a35037ea42bc51b5d1" translate="yes" xml:space="preserve">
          <source>And the following code:</source>
          <target state="translated">Y el siguiente código:</target>
        </trans-unit>
        <trans-unit id="13074a21c761f8c2e18dbd0487b69e0b1f687b80" translate="yes" xml:space="preserve">
          <source>Android 10.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bced9cc08c3939a0e0d679456c7b2c96155e69fa" translate="yes" xml:space="preserve">
          <source>Android 2.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab464014c26dbdf5f702390fa9ab23c39f0578d" translate="yes" xml:space="preserve">
          <source>Android 4.4.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529975d2ca1b9c8b1f9dc8715723302d776e3685" translate="yes" xml:space="preserve">
          <source>Annotating procs with raised exceptions</source>
          <target state="translated">Anotando los procedimientos con excepciones planteadas</target>
        </trans-unit>
        <trans-unit id="1372df72c3414caae306a6854fbd73da2739c232" translate="yes" xml:space="preserve">
          <source>Anonymous Procs</source>
          <target state="translated">Protestas anónimas...</target>
        </trans-unit>
        <trans-unit id="fc69ddcac99b9b9a8d29c74edd5dd97109c0f888" translate="yes" xml:space="preserve">
          <source>Another common example is this:</source>
          <target state="translated">Otro ejemplo común es este:</target>
        </trans-unit>
        <trans-unit id="46de23dafaa5135d298c4e6932bfd58f0a55fcd3" translate="yes" xml:space="preserve">
          <source>Another way is to make Nim invoke a cross compiler toolchain:</source>
          <target state="translated">Otra forma es hacer que Nim invoque una cadena de herramientas de compilación cruzada:</target>
        </trans-unit>
        <trans-unit id="220b3fd15cb7730c1f91330b6bd071c4acf9137b" translate="yes" xml:space="preserve">
          <source>Another way to branch is provided by the case statement. A case statement is a multi-branch:</source>
          <target state="translated">Otra forma de ramificación es la declaración del caso.La declaración de un caso es una rama múltiple:</target>
        </trans-unit>
        <trans-unit id="b109a7f72d501d6581c64b2e20010ee624b143d1" translate="yes" xml:space="preserve">
          <source>Another way to do the same without &lt;code&gt;when&lt;/code&gt; is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the &lt;em&gt;value&lt;/em&gt; to.</source>
          <target state="translated">Otra forma de hacer lo mismo sin &lt;code&gt;when&lt;/code&gt; es dejar la tarea de elegir el c&amp;oacute;digo apropiado a un proceso secundario al que sobrecargas para cada tipo de campo y le pasas el &lt;em&gt;valor&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cdcc64fe4174864c656f8d5ecbd49e1c1178af4e" translate="yes" xml:space="preserve">
          <source>Another way to look at the method call syntax is that it provides the missing postfix notation.</source>
          <target state="translated">Otra forma de ver el método llamado sintaxis es que proporciona la notación postfija que falta.</target>
        </trans-unit>
        <trans-unit id="a741689c8b0db1dc353a46642a34688e7e01c9fe" translate="yes" xml:space="preserve">
          <source>Any Unicode character: If there is an UTF-8 character ahead, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Cualquier personaje de Unicode:Si hay un personaje UTF-8 adelante,consumirlo e indicar el éxito.De lo contrario,indica fracaso.</target>
        </trans-unit>
        <trans-unit id="5778ef8422665afffa8cd59a1ebfe6af7a70d367" translate="yes" xml:space="preserve">
          <source>Any character: If there is a character ahead, consume it and indicate success. Otherwise (that is, at the end of input) indicate failure.</source>
          <target state="translated">Cualquier personaje:Si hay un personaje por delante,consumirlo e indicar el éxito.De lo contrario (es decir,al final de la entrada)indica fracaso.</target>
        </trans-unit>
        <trans-unit id="7358bbc6ca3777f85150f64affeb40b274702a17" translate="yes" xml:space="preserve">
          <source>Any comments which are preceded by a double-hash (##), are interpreted as documentation. Comments are parsed as RST (see &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;reference&lt;/a&gt;), providing Nim module authors the ability to easily generate richly formatted documentation with only their well-documented code.</source>
          <target state="translated">Cualquier comentario que est&amp;eacute; precedido por un doble hash (##), se interpretar&amp;aacute; como documentaci&amp;oacute;n. Los comentarios se analizan como RST (consulte la &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;referencia&lt;/a&gt; ), lo que brinda a los autores de m&amp;oacute;dulos de Nim la capacidad de generar f&amp;aacute;cilmente documentaci&amp;oacute;n con un gran formato con solo su c&amp;oacute;digo bien documentado.</target>
        </trans-unit>
        <trans-unit id="7a0e7fbfcaa080ee5b3ea5abcdb110b3936f6cd0" translate="yes" xml:space="preserve">
          <source>Any mutation to an object does count as a side effect if that object is reachable via a parameter that is not declared as a &lt;code&gt;var&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e859eb61aa46455ae8439cc09bd7c3fb497c718" translate="yes" xml:space="preserve">
          <source>Any operator can be called like an ordinary proc with the '&lt;code&gt;opr&lt;/code&gt;' notation. (Thus an operator can have more than two parameters):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e820fd709a7f87728034af624c9132692282ae" translate="yes" xml:space="preserve">
          <source>Any operator can be called like an ordinary proc with the '&lt;em&gt;opr&lt;/em&gt;' notation. (Thus an operator can have more than two parameters):</source>
          <target state="translated">Cualquier operador puede llamarse como un proceso ordinario con la notaci&amp;oacute;n ' &lt;em&gt;opr&lt;/em&gt; '. (Por lo tanto, un operador puede tener m&amp;aacute;s de dos par&amp;aacute;metros):</target>
        </trans-unit>
        <trans-unit id="28a8d44708b00ee5f8ab5f8950f4590e672372e9" translate="yes" xml:space="preserve">
          <source>Any previously stored value will be overwritten.</source>
          <target state="translated">Cualquier valor almacenado previamente será sobrescrito.</target>
        </trans-unit>
        <trans-unit id="85cdc7b1f239ca6691d5ad4bd7ee32149be2368a" translate="yes" xml:space="preserve">
          <source>Any statements following the &lt;code&gt;defer&lt;/code&gt; in the current block will be considered to be in an implicit try block:</source>
          <target state="translated">Cualquier declaraci&amp;oacute;n que siga al &lt;code&gt;defer&lt;/code&gt; en el bloque actual se considerar&amp;aacute; en un bloque try impl&amp;iacute;cito:</target>
        </trans-unit>
        <trans-unit id="f6cede9c40103cfeb38206a514d0e207b6286657" translate="yes" xml:space="preserve">
          <source>Any user defined destructors</source>
          <target state="translated">Cualquier destructor definido por el usuario</target>
        </trans-unit>
        <trans-unit id="e21dc240e738fabd5754c4089fede48b262d0589" translate="yes" xml:space="preserve">
          <source>AnyPath:</source>
          <target state="translated">AnyPath:</target>
        </trans-unit>
        <trans-unit id="474bae604f6e9971bd49456c68cefe4610021141" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;spawn&lt;/code&gt; and &lt;code&gt;parallel&lt;/code&gt; Nim also provides all the common low level concurrency mechanisms like locks, atomic intrinsics or condition variables.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;code&gt;spawn&lt;/code&gt; y &lt;code&gt;parallel&lt;/code&gt; Nim tambi&amp;eacute;n proporciona todos los mecanismos comunes de concurrencia de bajo nivel como bloqueos, intr&amp;iacute;nsecos at&amp;oacute;micos o variables de condici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="562f1ef0862bc54a9d91c121544eee328c801e91" translate="yes" xml:space="preserve">
          <source>Apart from a few built-in keyword operators such as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, operators always consist of these characters: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</source>
          <target state="translated">Aparte de unos cuantos incorporado operadores de palabras clave tales como &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , los operadores siempre constan de los siguientes caracteres: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfe80b93d1b3cc277c929cdfd0838f7556135094" translate="yes" xml:space="preserve">
          <source>Apart from built-in operations like array indexing, memory allocation, etc. the &lt;code&gt;raise&lt;/code&gt; statement is the only way to raise an exception.</source>
          <target state="translated">Aparte de las operaciones integradas como indexaci&amp;oacute;n de matrices, asignaci&amp;oacute;n de memoria, etc., la declaraci&amp;oacute;n de &lt;code&gt;raise&lt;/code&gt; es la &amp;uacute;nica forma de generar una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7dc1626458ca624671bbd7eb79e937465433fdf8" translate="yes" xml:space="preserve">
          <source>Apart from strings you can also encode lists of integers or characters:</source>
          <target state="translated">Además de las cadenas,también puedes codificar listas de enteros o caracteres:</target>
        </trans-unit>
        <trans-unit id="aafd7f63cf0cf31a35bff642569ecbe5c87f627c" translate="yes" xml:space="preserve">
          <source>Apart from the minimal syntactic sugar the language core does not need to know about tables.</source>
          <target state="translated">Aparte del mínimo azúcar sintáctico,el núcleo del lenguaje no necesita saber sobre tablas.</target>
        </trans-unit>
        <trans-unit id="e3b1dd548816f4827df0bad613bad688c2eb8bbe" translate="yes" xml:space="preserve">
          <source>Apo:</source>
          <target state="translated">Apo:</target>
        </trans-unit>
        <trans-unit id="16fba008b8a30cf646cf2acebb7e1cdfbd153d1f" translate="yes" xml:space="preserve">
          <source>Appends (adds to the end) a node &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e000dd9fba3be7dd379ffde7cc907cf28fd4ddd2" translate="yes" xml:space="preserve">
          <source>Appends (adds to the end) a value to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb580856272ad85df8745f41fd2d502b274c0be" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to string &lt;code&gt;s&lt;/code&gt; in place, applying quoting and escaping if &lt;code&gt;x&lt;/code&gt; is a string or char.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c406699971968f882acde68ff17c4b9e61930126" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d0496a927c4a27939c0fe3200738c8416afc23" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;x&lt;/em&gt; to string &lt;em&gt;s&lt;/em&gt; in place, applying quoting and escaping if &lt;em&gt;x&lt;/em&gt; is a string or char. See &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; for the escaping scheme. When &lt;em&gt;x&lt;/em&gt; is a string, characters in the range &lt;code&gt;{\128..\255}&lt;/code&gt; are never escaped so that multibyte UTF-8 characters are untouched (note that this behavior is different from &lt;code&gt;addEscapedChar&lt;/code&gt;).</source>
          <target state="translated">Agrega &lt;em&gt;x&lt;/em&gt; a la cadena &lt;em&gt;s&lt;/em&gt; en su lugar, aplicando comillas y escapando si &lt;em&gt;x&lt;/em&gt; es una cadena o un car&amp;aacute;cter. Consulte &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; para conocer el esquema de escape. Cuando &lt;em&gt;x&lt;/em&gt; es una cadena, los caracteres en el rango &lt;code&gt;{\128..\255}&lt;/code&gt; nunca se escapan, por lo que los caracteres UTF-8 multibyte no se modifican (tenga en cuenta que este comportamiento es diferente de &lt;code&gt;addEscapedChar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="646ba0c86d2da62ac809b41c7876c8d4d437f4fd" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt; in place</source>
          <target state="translated">Anexa &lt;em&gt;y&lt;/em&gt; a &lt;em&gt;x&lt;/em&gt; en lugar</target>
        </trans-unit>
        <trans-unit id="5a44cb6e95afb57a187dfd7f616458540348a25f" translate="yes" xml:space="preserve">
          <source>Appends element y to the end of the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621c0cff6d7cb368d8e84f223d0bb258c1851898" translate="yes" xml:space="preserve">
          <source>Appends element y to the end of the sequence. Requires copying of the sequence</source>
          <target state="translated">Añade el elemento y al final de la secuencia.Requiere la copia de la secuencia</target>
        </trans-unit>
        <trans-unit id="b911c2df77e9ea1d563e4a7ebb6593fb8d45a3d3" translate="yes" xml:space="preserve">
          <source>Appends in place to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b93e2750d5e019c95354307daa55b9ae9ae1eb1" translate="yes" xml:space="preserve">
          <source>Appends url to url.</source>
          <target state="translated">Añade url a url.</target>
        </trans-unit>
        <trans-unit id="41334dc65163a83119249bdd2d0725382bf90b0b" translate="yes" xml:space="preserve">
          <source>Applies &lt;code&gt;op&lt;/code&gt; to each of the &lt;strong&gt;atomic&lt;/strong&gt; literals like &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;&quot;abc&quot;&lt;/code&gt; in the specified &lt;code&gt;constructor&lt;/code&gt; AST. This can be used to map every array element to some target type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427ab152044cf1b6551f68794438b07d3820483" translate="yes" xml:space="preserve">
          <source>Applies &lt;code&gt;op&lt;/code&gt; to every item in &lt;code&gt;s&lt;/code&gt; modifying it directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b39b7cf4b0a60e8defe6d54cb8868dcdb0f1e4b" translate="yes" xml:space="preserve">
          <source>Applies &lt;em&gt;op&lt;/em&gt; to every item in &lt;em&gt;s&lt;/em&gt; modifying it directly.</source>
          <target state="translated">Se aplica &lt;em&gt;op&lt;/em&gt; a cada elemento de &lt;em&gt;s&lt;/em&gt; modific&amp;aacute;ndolo directamente.</target>
        </trans-unit>
        <trans-unit id="f7f98f61e331b2c9c311f3be85b2d106e23d53da" translate="yes" xml:space="preserve">
          <source>Applies a &lt;code&gt;callback&lt;/code&gt; function to the value of the &lt;code&gt;Option&lt;/code&gt; and returns an &lt;code&gt;Option&lt;/code&gt; containing the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e08e73f7d5cf1f2868300bfffc38afeef31e63" translate="yes" xml:space="preserve">
          <source>Applies a &lt;code&gt;callback&lt;/code&gt; function to the value of the &lt;code&gt;Option&lt;/code&gt;, if it has one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2070a04b99b90c4dbdf3f880dc817f26a106e8a6" translate="yes" xml:space="preserve">
          <source>Applies a &lt;code&gt;callback&lt;/code&gt; to the value of the &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c68a697222d8231db69fecdc76aa3f8118fca0" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option</source>
          <target state="translated">Aplica una llamada de retorno al valor en esta opción</target>
        </trans-unit>
        <trans-unit id="1f6c6510cdda5cd1b191679d2ebcc3574091831b" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned</source>
          <target state="translated">Aplica una llamada al valor de esta opción y devuelve una opción que contiene el nuevo valor.Si esta opción es Ninguna,se devolverá Ninguna</target>
        </trans-unit>
        <trans-unit id="4405334856a221170be55f8b9f5688d6a0be9c57" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned. Similar to &lt;code&gt;map&lt;/code&gt;, with the difference that the callback returns an Option, not a raw value. This allows multiple procs with a signature of &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (including A = B) to be chained together.</source>
          <target state="translated">Aplica una devoluci&amp;oacute;n de llamada al valor de esta opci&amp;oacute;n y devuelve una opci&amp;oacute;n que contiene el nuevo valor. Si esta opci&amp;oacute;n es Ninguno, se devolver&amp;aacute; Ninguno. Similar al &lt;code&gt;map&lt;/code&gt; a , con la diferencia de que la devoluci&amp;oacute;n de llamada devuelve una opci&amp;oacute;n, no un valor sin procesar. Esto permite que m&amp;uacute;ltiples procesos con una firma de &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (incluyendo A = B) sean encadenados.</target>
        </trans-unit>
        <trans-unit id="465dd40623dd93f42a5f03dcd0c6972a66643b81" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option. If the callback returns &lt;em&gt;true&lt;/em&gt;, the option is returned as a Some. If it returns false, it is returned as a None.</source>
          <target state="translated">Aplica una devoluci&amp;oacute;n de llamada al valor de esta opci&amp;oacute;n. Si la devoluci&amp;oacute;n de llamada devuelve &lt;em&gt;verdadero&lt;/em&gt; , la opci&amp;oacute;n se devuelve como Some. Si devuelve falso, se devuelve como Ninguno.</target>
        </trans-unit>
        <trans-unit id="31b8834506fb3b7c5be5a3ce85e8e0c3db7c0b3f" translate="yes" xml:space="preserve">
          <source>Arguments are delimited by white space, which is either a space or a tab.</source>
          <target state="translated">Los argumentos están delimitados por un espacio en blanco,que es un espacio o una pestaña.</target>
        </trans-unit>
        <trans-unit id="401bb179f3db6b973c284e019e2540619d382218" translate="yes" xml:space="preserve">
          <source>Arguments that are passed to a &lt;code&gt;varargs&lt;/code&gt; parameter are wrapped in an array constructor expression. This is why &lt;code&gt;debug&lt;/code&gt; iterates over all of &lt;code&gt;n&lt;/code&gt;'s children.</source>
          <target state="translated">Los argumentos que se pasan a un par&amp;aacute;metro &lt;code&gt;varargs&lt;/code&gt; se envuelven en una expresi&amp;oacute;n de constructor de matriz. Esta es la raz&amp;oacute;n por la que la &lt;code&gt;debug&lt;/code&gt; itera sobre todos los hijos de &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="b52ce1191681712b4198292245b2069cf1dabb8f" translate="yes" xml:space="preserve">
          <source>Arguments: arguments are passed to the program being run (if --run option is selected)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e74f9d45593e231dbfcd8bbedd9ba97fed0f07" translate="yes" xml:space="preserve">
          <source>Arguments: everything that does not start with a &lt;code&gt;-&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d45cd50bdc4c8b3af4b806662501ca8c8c618d" translate="yes" xml:space="preserve">
          <source>Arithmetic shift right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee11c97923cbdc76a30506f7fe7c019daafaf0b" translate="yes" xml:space="preserve">
          <source>Arithmetic with a &lt;code&gt;Duration&lt;/code&gt; is very fast, especially when used with the &lt;code&gt;Time&lt;/code&gt; type, since it only involves basic arithmetic. Because &lt;code&gt;Duration&lt;/code&gt; is more performant and easier to understand it should generally preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11cd140e4798311075ab97986a6059d3cb376d6c" translate="yes" xml:space="preserve">
          <source>Arithmetic with a &lt;code&gt;TimeInterval&lt;/code&gt; can be very slow, because it requires timezone information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bae2349fbad4ef35978d796cfe4b7d32461d9e" translate="yes" xml:space="preserve">
          <source>Array access operator &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">Operador de acceso a la matriz &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="935c34e59be520dab8667587be24775c6b59c8e5" translate="yes" xml:space="preserve">
          <source>Array and sequence types</source>
          <target state="translated">Tipos de arreglos y secuencias</target>
        </trans-unit>
        <trans-unit id="021b6564b992d622f4a204a912f2a5e5c8fe3e98" translate="yes" xml:space="preserve">
          <source>Array of strings representing each logging level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66b4ebd826229d404911b2c9ca9b59007c74879" translate="yes" xml:space="preserve">
          <source>Array with no bounds checking</source>
          <target state="translated">La matriz sin límites de control...</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="163d5347d88f0665232159d0fcd2e115c3d58bb8" translate="yes" xml:space="preserve">
          <source>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length specified as a constant expression (except for open arrays). They can be indexed by any ordinal type. A parameter &lt;code&gt;A&lt;/code&gt; may be an &lt;em&gt;open array&lt;/em&gt;, in which case it is indexed by integers from 0 to &lt;code&gt;len(A)-1&lt;/code&gt;. An array expression may be constructed by the array constructor &lt;code&gt;[]&lt;/code&gt;. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertible to this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c78840740ada4caee391a3c7d72b96b3524a2c8" translate="yes" xml:space="preserve">
          <source>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length which is specified at compile time (except for open arrays). They can be indexed by any ordinal type. A parameter &lt;code&gt;A&lt;/code&gt; may be an &lt;em&gt;open array&lt;/em&gt;, in which case it is indexed by integers from 0 to &lt;code&gt;len(A)-1&lt;/code&gt;. An array expression may be constructed by the array constructor &lt;code&gt;[]&lt;/code&gt;. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertable to this type.</source>
          <target state="translated">Las matrices son un tipo homog&amp;eacute;neo, lo que significa que cada elemento de la matriz tiene el mismo tipo. Las matrices siempre tienen una longitud fija que se especifica en tiempo de compilaci&amp;oacute;n (excepto para matrices abiertas). Se pueden indexar por cualquier tipo ordinal. Un par&amp;aacute;metro &lt;code&gt;A&lt;/code&gt; puede ser una &lt;em&gt;matriz abierta&lt;/em&gt; , en cuyo caso est&amp;aacute; indexado por n&amp;uacute;meros enteros de 0 a &lt;code&gt;len(A)-1&lt;/code&gt; . Una expresi&amp;oacute;n de matriz puede ser construida por el constructor de matriz &lt;code&gt;[]&lt;/code&gt; . El tipo de elemento de esta expresi&amp;oacute;n de matriz se infiere del tipo del primer elemento. Todos los dem&amp;aacute;s elementos deben ser convertibles impl&amp;iacute;citamente a este tipo.</target>
        </trans-unit>
        <trans-unit id="07316b5238311cac8e4fe1961ee02c15801cb68e" translate="yes" xml:space="preserve">
          <source>Arrays are always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--boundChecks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">Las matrices siempre se comprueban por l&amp;iacute;mites (en tiempo de compilaci&amp;oacute;n o en tiempo de ejecuci&amp;oacute;n). Estas comprobaciones pueden desactivarse mediante pragmas o invocando el compilador con el &lt;code&gt;--boundChecks:off&lt;/code&gt; l&amp;iacute;nea de comando --boundChecks: off .</target>
        </trans-unit>
        <trans-unit id="0b249479bb7b274c06e387f76a3026cd4f886624" translate="yes" xml:space="preserve">
          <source>Arrays are always bounds checked (statically or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--boundChecks:off&lt;/code&gt; command-line switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5ec03ff46845d078f8cf64b1238f79972295a5" translate="yes" xml:space="preserve">
          <source>Arrays are value types, like any other Nim type. The assignment operator copies the whole array contents.</source>
          <target state="translated">Los arreglos son tipos de valores,como cualquier otro tipo de Nim.El operador de asignación copia todo el contenido del arreglo.</target>
        </trans-unit>
        <trans-unit id="025a9e98dcb0da2dd59c51da809f12fce4980b2a" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed using &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">Las matrices se pueden construir usando &lt;code&gt;[]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c735544485e105956e388f5a452d2502051ca6e1" translate="yes" xml:space="preserve">
          <source>Artifact being compiled.</source>
          <target state="translated">El artefacto está siendo compilado.</target>
        </trans-unit>
        <trans-unit id="b17b6441237c52d21208d5d89f06d445715567fb" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;let&lt;/code&gt; statements are immutable after creation they need to define a value when they are declared. The only exception to this is if the &lt;code&gt;{.importc.}&lt;/code&gt; pragma (or any of the other &lt;code&gt;importX&lt;/code&gt; pragmas) is applied, in this case the value is expected to come from native code, typically a C/C++ &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2681d14f693853cb31e8a490d26bf55ce9311d0e" translate="yes" xml:space="preserve">
          <source>As a regular expression &lt;code&gt;\[.*\]&lt;/code&gt; matches the longest possible text between &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;. As a PEG it never matches anything, because a PEG is deterministic: &lt;code&gt;.*&lt;/code&gt; consumes the rest of the input, so &lt;code&gt;\]&lt;/code&gt; never matches. As a PEG this needs to be written as: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (or &lt;code&gt;\[ @ \]&lt;/code&gt;).</source>
          <target state="translated">Como expresi&amp;oacute;n regular &lt;code&gt;\[.*\]&lt;/code&gt; Coincide con el texto m&amp;aacute;s largo posible entre &lt;code&gt;'['&lt;/code&gt; y &lt;code&gt;']'&lt;/code&gt; . Como PEG, nunca coincide con nada, porque un PEG es determinista:. &lt;code&gt;.*&lt;/code&gt; Consume el resto de la entrada, por lo que &lt;code&gt;\]&lt;/code&gt; nunca coincide. Como PEG, esto debe escribirse como: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (O &lt;code&gt;\[ @ \]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7df1f297110a6ac1f59d3ba4423b992aff7687da" translate="yes" xml:space="preserve">
          <source>As a result of using optimized function/intrinsics some functions can return undefined results if the input is invalid. You can use the flag &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; to force predictable behaviour for all input, causing a small performance hit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d98662c0a3a8c4fd899d63977fd61a1ce489676" translate="yes" xml:space="preserve">
          <source>As a result of using optimized function/intrinsics some functions can return undefined results if the input is invalid. You can use the flag &lt;em&gt;noUndefinedBitOpts&lt;/em&gt; to force predictable behaviour for all input, causing a small performance hit.</source>
          <target state="translated">Como resultado del uso de funciones / intr&amp;iacute;nsecas optimizadas, algunas funciones pueden devolver resultados indefinidos si la entrada no es v&amp;aacute;lida. Puede usar la &lt;em&gt;marca noUndefinedBitOpts&lt;/em&gt; para forzar un comportamiento predecible para todas las entradas, lo que provoca un peque&amp;ntilde;o impacto en el rendimiento.</target>
        </trans-unit>
        <trans-unit id="1664c8e0b3003ab199f6ca491156febd8a7827ee" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.</source>
          <target state="translated">Como regla general,se permite la indentación dentro de las expresiones después de los operadores,un paréntesis abierto y después de las comas.</target>
        </trans-unit>
        <trans-unit id="cb2355cab9186efd1c7ad2a36b7f8184f95dac01" translate="yes" xml:space="preserve">
          <source>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a &lt;a href=&quot;#callsslashexpressions-call-with&quot;&gt;parenthetical function call&lt;/a&gt; with &lt;code&gt;nnkAccQuoted&lt;/code&gt;, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbf2a9820bf41bcc3ae860ff3066a54791d55a8" translate="yes" xml:space="preserve">
          <source>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a [parenthetical function call](./macros.html#calls-expressions-call-with) with &lt;code&gt;nnkAccQuoted&lt;/code&gt;, as follows:</source>
          <target state="translated">Como nota al margen, si eliges usar operadores infijos en forma de prefijo, el AST se comporta como una [llamada a funci&amp;oacute;n entre par&amp;eacute;ntesis] (./ macros.html # llamadas-expresiones-llamada-con) con &lt;code&gt;nnkAccQuoted&lt;/code&gt; , de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="15211f47465417179a8c67c3321dc2d1d401fb39" translate="yes" xml:space="preserve">
          <source>As a special more convenient notation, proc expressions involved in procedure calls can use the &lt;code&gt;do&lt;/code&gt; keyword:</source>
          <target state="translated">Como una notaci&amp;oacute;n especial m&amp;aacute;s conveniente, las expresiones proc involucradas en llamadas a procedimientos pueden usar la palabra clave &lt;code&gt;do&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dd6443d8544f4bb56ab3cab6062600d72a758fbe" translate="yes" xml:space="preserve">
          <source>As a special rule to keep backward compatibility with older versions of the &lt;code&gt;importcpp&lt;/code&gt; pragma, if there is no special pattern character (any of &lt;code&gt;# ' @&lt;/code&gt;) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce683dd181064064b72fd86d9d3e2b66acc2d7ce" translate="yes" xml:space="preserve">
          <source>As a special rule to keep backwards compatibility with older versions of the &lt;code&gt;importcpp&lt;/code&gt; pragma, if there is no special pattern character (any of &lt;code&gt;# ' @&lt;/code&gt;) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</source>
          <target state="translated">Como regla especial para mantener la compatibilidad con versiones anteriores del pragma &lt;code&gt;importcpp&lt;/code&gt; , si no hay ning&amp;uacute;n car&amp;aacute;cter de patr&amp;oacute;n especial (cualquiera de &lt;code&gt;# ' @&lt;/code&gt; ), se asume la notaci&amp;oacute;n de punto o flecha de C ++, por lo que el ejemplo anterior tambi&amp;eacute;n se puede escribir como :</target>
        </trans-unit>
        <trans-unit id="ab91135276bb9fc3a4864b2e8e2281ee4c12f22b" translate="yes" xml:space="preserve">
          <source>As a special rule, the discriminator kind can also be bounded using a &lt;code&gt;case&lt;/code&gt; statement. If possible values of the discriminator variable in a &lt;code&gt;case&lt;/code&gt; statement branch are a subset of discriminator values for the selected object branch, the initialization is considered valid. This analysis only works for immutable discriminators of an ordinal type and disregards &lt;code&gt;elif&lt;/code&gt; branches. For discriminator values with a &lt;code&gt;range&lt;/code&gt; type, the compiler checks if the entire range of possible values for the discriminator value is valid for the chosen object branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa79fbae0eabebb420b9fe3f09c01088cf66351" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;decodePlus&lt;/code&gt; is true, &lt;code&gt;'+'&lt;/code&gt; characters are converted to a space.</source>
          <target state="translated">Como regla especial, cuando el valor de &lt;code&gt;decodePlus&lt;/code&gt; es verdadero, &lt;code&gt;'+'&lt;/code&gt; caracteres '+' se convierten en un espacio.</target>
        </trans-unit>
        <trans-unit id="06f5de0278a73571ad2478819c0ab63c92da4626" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;decodePlus&lt;/code&gt; is true, &lt;code&gt;+&lt;/code&gt; characters are converted to a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b120a7d9f07026a29d56a412d87eb19ed8fa37b" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;usePlus&lt;/code&gt; is true, spaces are encoded as &lt;code&gt;'+'&lt;/code&gt; instead of &lt;code&gt;'%20'&lt;/code&gt;.</source>
          <target state="translated">Como regla especial, cuando el valor de &lt;code&gt;usePlus&lt;/code&gt; es verdadero, los espacios se codifican como &lt;code&gt;'+'&lt;/code&gt; en lugar de &lt;code&gt;'%20'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ee4923f840cd34187586ac353af674c377642d5" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;usePlus&lt;/code&gt; is true, spaces are encoded as &lt;code&gt;+&lt;/code&gt; instead of &lt;code&gt;%20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babff93920d51965108f37a93de33ae42b21d0fb" translate="yes" xml:space="preserve">
          <source>As a special semantic extension, an expression in an &lt;code&gt;of&lt;/code&gt; branch of a case statement may evaluate to a set or array constructor; the set or array is then expanded into a list of its elements:</source>
          <target state="translated">Como una extensi&amp;oacute;n sem&amp;aacute;ntica especial, una expresi&amp;oacute;n en una &lt;code&gt;of&lt;/code&gt; ramas de una declaraci&amp;oacute;n de caso puede evaluar a un conjunto o matriz constructora; el conjunto o matriz se expande luego en una lista de sus elementos:</target>
        </trans-unit>
        <trans-unit id="c8b38ae2d66cb902bbb85a37572813974cd63162" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, &lt;code&gt;x&lt;/code&gt; may also be a type identifier (&lt;code&gt;sizeof(int)&lt;/code&gt; is valid).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5091f848f3ac37cf5086fc6521ba43800396a9" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, &lt;code&gt;x&lt;/code&gt; may also be a type identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d6a828142c8108ac0deb4cc6c8484c64faae27" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, the built-in &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt; pretends to be free of side effects, so that it can be used for debugging routines marked as &lt;code&gt;noSideEffect&lt;/code&gt;.</source>
          <target state="translated">Como regla sem&amp;aacute;ntica especial, el &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho integrado&lt;/a&gt; pretende estar libre de efectos secundarios, por lo que se puede usar para depurar rutinas marcadas como &lt;code&gt;noSideEffect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="849da20fcec3e5d33e7eb20a85880af3bc7ff686" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, the built-in &lt;a href=&quot;system#debugEcho,varargs%5Btyped,%5D&quot;&gt;debugEcho&lt;/a&gt; pretends to be free of side effects, so that it can be used for debugging routines marked as &lt;code&gt;noSideEffect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71489e93932a05f2ea411285eaceb3bbe24614d1" translate="yes" xml:space="preserve">
          <source>As a syntactical extension &lt;code&gt;object&lt;/code&gt; types can be anonymous if declared in a type section via the &lt;code&gt;ref object&lt;/code&gt; or &lt;code&gt;ptr object&lt;/code&gt; notations. This feature is useful if an object should only gain reference semantics:</source>
          <target state="translated">Como extensi&amp;oacute;n sint&amp;aacute;ctica, los tipos de &lt;code&gt;object&lt;/code&gt; pueden ser an&amp;oacute;nimos si se declaran en una secci&amp;oacute;n de tipos a trav&amp;eacute;s de las &lt;code&gt;ptr object&lt;/code&gt; &lt;code&gt;ref object&lt;/code&gt; o ptr . Esta funci&amp;oacute;n es &amp;uacute;til si un objeto solo debe obtener sem&amp;aacute;ntica de referencia:</target>
        </trans-unit>
        <trans-unit id="7859c8bf7a7bf8df21005d62f29109f1c4a9707d" translate="yes" xml:space="preserve">
          <source>As a top level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently these usages have to be put into a &lt;code&gt;.push/pop&lt;/code&gt; environment:</source>
          <target state="translated">Como declaraci&amp;oacute;n de nivel superior, el pragma experimental habilita una caracter&amp;iacute;stica para el resto del m&amp;oacute;dulo en el que est&amp;aacute; habilitado. Esto es problem&amp;aacute;tico para las instancias macro y gen&amp;eacute;ricas que cruzan el alcance de un m&amp;oacute;dulo. Actualmente, estos usos deben colocarse en un &lt;code&gt;.push/pop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d8025bfa9773e094890bd5bb7bb9e170916e809b" translate="yes" xml:space="preserve">
          <source>As a top-level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently, these usages have to be put into a &lt;code&gt;.push/pop&lt;/code&gt; environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc9ba3f444ef5f2a70c370287d23a7b3c9d81c8" translate="yes" xml:space="preserve">
          <source>As an example,</source>
          <target state="translated">Como ejemplo,</target>
        </trans-unit>
        <trans-unit id="7e62fd99966b92a3fd4bf5d979b50660343f0f5e" translate="yes" xml:space="preserve">
          <source>As an example, consider the amount of time between these two timestamps, both in the same timezone:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0458d772e5450c5837302b3171366024dd5c0f" translate="yes" xml:space="preserve">
          <source>As an example, the following would not compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b935a3e149eeb28ead79ccda5acf74a96cba2bc" translate="yes" xml:space="preserve">
          <source>As can be manually verified, this transformation is correct for self-assignments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faf2cad17e66616bc46eb370913033cba7d7ffe" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, C's macros with parameters are mapped to Nim's templates. This mapping is the best one can do, but it is of course not accurate: Nim's templates operate on syntax trees whereas C's macros work on the token level. c2nim cannot translate any macro that contains the &lt;code&gt;##&lt;/code&gt; token concatenation operator.</source>
          <target state="translated">Como puede verse en el ejemplo, las macros de C con par&amp;aacute;metros se asignan a las plantillas de Nim. Este mapeo es lo mejor que se puede hacer, pero por supuesto no es exacto: las plantillas de Nim operan en &amp;aacute;rboles de sintaxis mientras que las macros de C funcionan a nivel de token. c2nim no puede traducir ninguna macro que contenga el operador de concatenaci&amp;oacute;n de tokens &lt;code&gt;##&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdca03b57c9a9c02d929b545595c9b2375041559" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033710d5a2d1054844b9448ca63a783fde847ed0" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, it is possible to both specify a field's ordinal value and its string value by using a tuple. It is also possible to only specify one of them.</source>
          <target state="translated">Como puede verse en el ejemplo,es posible especificar tanto el valor ordinal de un campo como su valor de cadena utilizando una tupla.También es posible especificar sólo uno de ellos.</target>
        </trans-unit>
        <trans-unit id="f2059474be6954912aa2a1f6469b45737b7e11f5" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, this solution is hardly sufficient and should eventually be replaced by a better solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33db679c8421cd1a5bcfed816339b58d55a90cf0" translate="yes" xml:space="preserve">
          <source>As can be seen from the examples, strings are matched verbatim except for substrings starting with &lt;code&gt;$&lt;/code&gt;. These constructions are available:</source>
          <target state="translated">Como se puede ver en los ejemplos, las cadenas coinciden literalmente, excepto las subcadenas que comienzan con &lt;code&gt;$&lt;/code&gt; . Estas construcciones est&amp;aacute;n disponibles:</target>
        </trans-unit>
        <trans-unit id="3690ed0de51a088f748c4a5d9756e00f903b6456" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, base methods have to be annotated with the &lt;span id=&quot;base_1&quot;&gt;base&lt;/span&gt; pragma. The &lt;code&gt;base&lt;/code&gt; pragma also acts as a reminder for the programmer that a base method &lt;code&gt;m&lt;/code&gt; is used as the foundation to determine all the effects that a call to &lt;code&gt;m&lt;/code&gt; might cause.</source>
          <target state="translated">Como se puede ver en el ejemplo, los m&amp;eacute;todos base deben anotarse con el pragma &lt;span id=&quot;base_1&quot;&gt;base&lt;/span&gt; . El pragma &lt;code&gt;base&lt;/code&gt; tambi&amp;eacute;n act&amp;uacute;a como un recordatorio para el programador de que se usa un m&amp;eacute;todo base &lt;code&gt;m&lt;/code&gt; como base para determinar todos los efectos que una llamada a &lt;code&gt;m&lt;/code&gt; podr&amp;iacute;a causar.</target>
        </trans-unit>
        <trans-unit id="46e0fb06d3ebb9d87d99780ce68838895081e9f4" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, this new variant allows for custom flags that are passed to the C compiler when the file is recompiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a364bd18b5eaef7b5722d6cd78c85c92bfa5dd" translate="yes" xml:space="preserve">
          <source>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating point literals may be given in decimal (no prefix), binary (prefix &lt;code&gt;0b&lt;/code&gt;), octal (prefix &lt;code&gt;0o&lt;/code&gt;) and hexadecimal (prefix &lt;code&gt;0x&lt;/code&gt;) notation.</source>
          <target state="translated">Como se puede ver en las producciones, las constantes num&amp;eacute;ricas pueden contener guiones bajos para facilitar la lectura. Los literales enteros y de coma flotante se pueden dar en notaci&amp;oacute;n decimal (sin prefijo), binario (prefijo &lt;code&gt;0b&lt;/code&gt; ), octal (prefijo &lt;code&gt;0o&lt;/code&gt; ) y hexadecimal (prefijo &lt;code&gt;0x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c68ceacc6a8938d2e2de6c4f8059959bc6ce1693" translate="yes" xml:space="preserve">
          <source>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating-point literals may be given in decimal (no prefix), binary (prefix &lt;code&gt;0b&lt;/code&gt;), octal (prefix &lt;code&gt;0o&lt;/code&gt;), and hexadecimal (prefix &lt;code&gt;0x&lt;/code&gt;) notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dad921df2b5a3cd443f8e5461c7a9ccced2c050" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">Como se puede ver en el ejemplo,una ventaja de una jerarquía de objetos es que no se necesita un reparto entre los diferentes tipos de objetos.Sin embargo,el acceso a campos de objetos no válidos plantea una excepción.</target>
        </trans-unit>
        <trans-unit id="86acee0719e4df42b833d89f9ce00671880b3bee" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">Como se puede ver en el ejemplo,una ventaja de una jerarquía de objetos es que no se necesita una conversión entre los diferentes tipos de objetos.Sin embargo,el acceso a campos de objetos no válidos plantea una excepción.</target>
        </trans-unit>
        <trans-unit id="8bd2dc16961a30c8b20a5aa5ef6562993b9d9ea9" translate="yes" xml:space="preserve">
          <source>As case statements perform compile-time exhaustiveness checks, the value in every &lt;code&gt;of&lt;/code&gt; branch must be known at compile time. This fact is also exploited to generate more performant code.</source>
          <target state="translated">Como las declaraciones de casos realizan comprobaciones de exhaustividad en tiempo de compilaci&amp;oacute;n, el valor en todos los &lt;code&gt;of&lt;/code&gt; rama debe ser conocido en tiempo de compilaci&amp;oacute;n. Este hecho tambi&amp;eacute;n se aprovecha para generar un c&amp;oacute;digo m&amp;aacute;s eficaz.</target>
        </trans-unit>
        <trans-unit id="a3cf4fdd8a46537cb17ba2fc74bca88aa30a4384" translate="yes" xml:space="preserve">
          <source>As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.</source>
          <target state="translated">Como convención,este procedimiento dividirá los archivos de índice en dos categorías:documentación y API.Los índices API se unirán en un único gran índice clasificado,haciendo el grueso del índice final.Esto es bueno para la documentación de la API porque muchos símbolos se repiten en diferentes módulos.Por otra parte,los índices de la documentación son esencialmente tablas de contenido más algunos marcadores especiales.Estos documentos se presentarán en una sección separada que trata de mantener el orden y la jerarquía de los símbolos en el archivo de índice.</target>
        </trans-unit>
        <trans-unit id="c36898bdeea6eb9e3e341ac71004ffc85ade807c" translate="yes" xml:space="preserve">
          <source>As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repeated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e35fce15f7b6d0e8ddfe4a222398b9462fecc9a2" translate="yes" xml:space="preserve">
          <source>As in generics symbol binding can be influenced via &lt;code&gt;mixin&lt;/code&gt; or &lt;code&gt;bind&lt;/code&gt; statements.</source>
          <target state="translated">Al igual que en los gen&amp;eacute;ricos, la vinculaci&amp;oacute;n de s&amp;iacute;mbolos se puede influir mediante declaraciones &lt;code&gt;mixin&lt;/code&gt; o &lt;code&gt;bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0887bf802c49a565d93917f60c9350172010518c" translate="yes" xml:space="preserve">
          <source>As it can be seen, for an &lt;code&gt;of&lt;/code&gt; branch a comma separated list of values is also allowed.</source>
          <target state="translated">Como se puede ver, para una &lt;code&gt;of&lt;/code&gt; rama una coma separ&amp;oacute; la lista de valores tambi&amp;eacute;n est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="026e19060b7027adb0d7fdc31274d77b9a547e42" translate="yes" xml:space="preserve">
          <source>As long as a type &lt;code&gt;T&lt;/code&gt; is incomplete &lt;code&gt;sizeof(T)&lt;/code&gt; or &quot;runtime type information&quot; for &lt;code&gt;T&lt;/code&gt; is not available.</source>
          <target state="translated">Siempre que un tipo &lt;code&gt;T&lt;/code&gt; sea ​​incompleto, el &lt;code&gt;sizeof(T)&lt;/code&gt; o la &quot;informaci&amp;oacute;n del tipo de tiempo de ejecuci&amp;oacute;n&quot; para &lt;code&gt;T&lt;/code&gt; no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="abcbb5924227bd04c281ecaaed135860652d02cc" translate="yes" xml:space="preserve">
          <source>As long as a type &lt;code&gt;T&lt;/code&gt; is incomplete, neither &lt;code&gt;sizeof(T)&lt;/code&gt; nor runtime type information for &lt;code&gt;T&lt;/code&gt; is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dca63b7a6f1fd2e2ca6e65f781d803b65614773" translate="yes" xml:space="preserve">
          <source>As long as you don't use the threadvar emulation Nim uses native thread variables, of which you get a fresh version whenever you create a thread. You can then attach a GC to this thread via</source>
          <target state="translated">Mientras no uses la emulación de threadvar Nim usa variables de hilos nativos,de los cuales obtienes una versión fresca cada vez que creas un hilo.Puedes entonces adjuntar un GC a este hilo a través de</target>
        </trans-unit>
        <trans-unit id="26a74fa3cef27390dd0524bd6f48c70bfa5b9b01" translate="yes" xml:space="preserve">
          <source>As many &lt;code&gt;nnkIdent&lt;/code&gt; appear as there are pragmas between &lt;code&gt;{..}&lt;/code&gt;. Note that the declaration of new pragmas is essentially the same:</source>
          <target state="translated">&lt;code&gt;nnkIdent&lt;/code&gt; tantos nnkIdent como pragmas hay entre &lt;code&gt;{..}&lt;/code&gt; . Tenga en cuenta que la declaraci&amp;oacute;n de nuevos pragmas es esencialmente la misma:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
