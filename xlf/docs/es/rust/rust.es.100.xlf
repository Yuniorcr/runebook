<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="800e827a6bd80027fcc168148b39b2bc4798dafa" translate="yes" xml:space="preserve">
          <source>TakeWhile::partial_cmp</source>
          <target state="translated">TakeWhile::partial_cmp</target>
        </trans-unit>
        <trans-unit id="756f2fd59afc727df9fab561f13734ed10cc1035" translate="yes" xml:space="preserve">
          <source>TakeWhile::partition</source>
          <target state="translated">TakeWhile::partition</target>
        </trans-unit>
        <trans-unit id="b3708fa6ef243ab03b8f0e01148054537baba7c2" translate="yes" xml:space="preserve">
          <source>TakeWhile::peekable</source>
          <target state="translated">TakeWhile::peekable</target>
        </trans-unit>
        <trans-unit id="3ddf00384fd53b19d286b7ce9f31e5c8e130add2" translate="yes" xml:space="preserve">
          <source>TakeWhile::position</source>
          <target state="translated">TakeWhile::position</target>
        </trans-unit>
        <trans-unit id="103103944a1d96c94fd7efea8dc3417e1dcec47e" translate="yes" xml:space="preserve">
          <source>TakeWhile::product</source>
          <target state="translated">TakeWhile::product</target>
        </trans-unit>
        <trans-unit id="9db7de0140db3938f59bf212e7c6b8c4ab1a5b22" translate="yes" xml:space="preserve">
          <source>TakeWhile::rev</source>
          <target state="translated">TakeWhile::rev</target>
        </trans-unit>
        <trans-unit id="aa7afa9cbae96b3a55ad383eb829e62995e9d3b0" translate="yes" xml:space="preserve">
          <source>TakeWhile::rposition</source>
          <target state="translated">TakeWhile::rposition</target>
        </trans-unit>
        <trans-unit id="aad375a583a0085240c857eb42a8dfb87e2e4e1c" translate="yes" xml:space="preserve">
          <source>TakeWhile::scan</source>
          <target state="translated">TakeWhile::scan</target>
        </trans-unit>
        <trans-unit id="cd86cfe53884486177c23f0ff823be46500dc9e1" translate="yes" xml:space="preserve">
          <source>TakeWhile::size_hint</source>
          <target state="translated">TakeWhile::size_hint</target>
        </trans-unit>
        <trans-unit id="5e176c9b3bf37b02aef10f7907a61a6ac9a47da8" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip</source>
          <target state="translated">TakeWhile::skip</target>
        </trans-unit>
        <trans-unit id="64e54491abe005b30c8d866999d58ab787b271b2" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip_while</source>
          <target state="translated">TakeWhile::skip_while</target>
        </trans-unit>
        <trans-unit id="ba9f9f10db1b73ab0c564edb9c28453e72ee8d7c" translate="yes" xml:space="preserve">
          <source>TakeWhile::step_by</source>
          <target state="translated">TakeWhile::step_by</target>
        </trans-unit>
        <trans-unit id="9d9273a97581b55606d39ff31ae4fc4bd97d0343" translate="yes" xml:space="preserve">
          <source>TakeWhile::sum</source>
          <target state="translated">TakeWhile::sum</target>
        </trans-unit>
        <trans-unit id="c679b6dec55380d66c68043added100d9b1e3e12" translate="yes" xml:space="preserve">
          <source>TakeWhile::take</source>
          <target state="translated">TakeWhile::take</target>
        </trans-unit>
        <trans-unit id="98bc022ab936f48f4c132862157a433b58b1ed1d" translate="yes" xml:space="preserve">
          <source>TakeWhile::take_while</source>
          <target state="translated">TakeWhile::take_while</target>
        </trans-unit>
        <trans-unit id="b57cfb71237e7ec5ab624251b87030d240a46226" translate="yes" xml:space="preserve">
          <source>TakeWhile::to_owned</source>
          <target state="translated">TakeWhile::to_owned</target>
        </trans-unit>
        <trans-unit id="37e399f48eff7903115e7d86661abdf8e05fd4b1" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_fold</source>
          <target state="translated">TakeWhile::try_fold</target>
        </trans-unit>
        <trans-unit id="759bc51854e6a28a5380a5f6b7a415cd0f555f0f" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_for_each</source>
          <target state="translated">TakeWhile::try_for_each</target>
        </trans-unit>
        <trans-unit id="7fb911b85cc860ff38f3b721f59503e01735b148" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_from</source>
          <target state="translated">TakeWhile::try_from</target>
        </trans-unit>
        <trans-unit id="5de7c55a9b68a872ef23f0276b88d1c9ecf0fc8a" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_into</source>
          <target state="translated">TakeWhile::try_into</target>
        </trans-unit>
        <trans-unit id="87c136784211d463521272370803a4f358f45d54" translate="yes" xml:space="preserve">
          <source>TakeWhile::type_id</source>
          <target state="translated">TakeWhile::type_id</target>
        </trans-unit>
        <trans-unit id="2c32f5c719493f4a777e4c32b66c95f758c27273" translate="yes" xml:space="preserve">
          <source>TakeWhile::unzip</source>
          <target state="translated">TakeWhile::unzip</target>
        </trans-unit>
        <trans-unit id="d4376e438d96018f64f5876aa47fe4d14ae53315" translate="yes" xml:space="preserve">
          <source>TakeWhile::zip</source>
          <target state="translated">TakeWhile::zip</target>
        </trans-unit>
        <trans-unit id="686ef3911209faeb469101adcbd7e6e7d810ef4c" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;*O*(min(k, len() - k))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ef4edffae6c9317836493dc9e695ad35618a15" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;*O*(min(mid, len() - mid))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a3fbbd6670f1404e88f845d8e70bb6e1310ad2" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(k, len() - k))&lt;/code&gt; time and no extra space.</source>
          <target state="translated">Toma &lt;code&gt;O(min(k, len() - k))&lt;/code&gt; tiempo y sin espacio extra.</target>
        </trans-unit>
        <trans-unit id="2675fff809feea07b6b8e81b85ffeea6cb2ff42a" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(mid, len() - mid))&lt;/code&gt; time and no extra space.</source>
          <target state="translated">Toma &lt;code&gt;O(min(mid, len() - mid))&lt;/code&gt; tiempo y sin espacio adicional.</target>
        </trans-unit>
        <trans-unit id="cd9e4e1ce47cfbb22bdd9618d61401a9a4bbe1ab" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element.</source>
          <target state="translated">Toma un cierre y crea un iterador que llama a ese cierre en cada elemento.</target>
        </trans-unit>
        <trans-unit id="9d3b7aa7666b1bb97d700268dbfed96edd954290" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma un cierre y crea un iterador que llama a ese cierre en cada elemento. &lt;a href=&quot;../../../iter/trait.iterator#method.map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15197bb083d7273e4a694b7c5e032b5e1c0781f3" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma un cierre y crea un iterador que llama a ese cierre en cada elemento. &lt;a href=&quot;../../iter/trait.iterator#method.map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4434c8dd599ef23b0c9ba44e32c1fa55b943ae82" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma un cierre y crea un iterador que llama a ese cierre en cada elemento. &lt;a href=&quot;../iter/trait.iterator#method.map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6257eea37e0de73bcadd8777f056a323db82c336" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma un cierre y crea un iterador que llama a ese cierre en cada elemento. &lt;a href=&quot;iter/trait.iterator#method.map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1ad1d9466847f0b48f38483a158304137e697a6" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma un cierre y crea un iterador que llama a ese cierre en cada elemento. &lt;a href=&quot;trait.iterator#method.map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b67dad0714b16a4867cfc86c2882827f4a196a85" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Toma cada elemento del &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; : si es &lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , no se toman m&amp;aacute;s elementos y se devuelve &lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Si no ocurre &lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , se devuelve un contenedor con los valores de cada &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d108a90f72b979216289a1535302bae686a314" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae2387e48cfe171ba07e4b4b0225bc9c8162619" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc47bd052a8b6d5124696117910cb85d1a433ca" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa16ae10062698ed9b295ae08170d14623d7392d" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b254b78336a4f1d88a19a88b9cd87eebc4af74" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e929c2f84b980189b0ca395f9fd1ebf18d6a9b2" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Toma cada elemento del &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; : si es &lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , no se toman m&amp;aacute;s elementos y se devuelve &lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Si no ocurre &lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , se devuelve un contenedor con los valores de cada &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70a9e6b588aac0e816346721c7b37888db944102" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7590beabf441bb63691e8eea48b72c9c8f6a403" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc7f913ad909dfc000ef9eb96b0c827728188e0" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1c7f91156f7afd567ca4e08a2abfd735e16c17" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ccdebe9d4ccf3b0664327970602a14b42c1657" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39228003dfd9a65d31657d9ccd88aa95394f718" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt; and collects it into an &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80659447eb965dd52f894d84ba633d8bce5db96" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt; and collects it into an &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217627f67f88406b5f9f17a93f1493e04a1a8227" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="translated">Toma cada elemento del &lt;code&gt;Iterator&lt;/code&gt; : si es &lt;code&gt;None&lt;/code&gt; , no se toman m&amp;aacute;s elementos y se devuelve &lt;code&gt;None&lt;/code&gt; . Si no ocurre &lt;code&gt;None&lt;/code&gt; , se devuelve el producto de todos los elementos.</target>
        </trans-unit>
        <trans-unit id="e4aa0fd801953cd40a086ec1d2ff51bb44eb736e" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="translated">Toma cada elemento del &lt;code&gt;Iterator&lt;/code&gt; : si es &lt;code&gt;None&lt;/code&gt; , no se toman m&amp;aacute;s elementos y se devuelve &lt;code&gt;None&lt;/code&gt; . Si no ocurre &lt;code&gt;None&lt;/code&gt; , se devuelve la suma de todos los elementos.</target>
        </trans-unit>
        <trans-unit id="c1fb0a7041f8cb3602712be575a96b71a9c34edb" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, a container with the values of each &lt;code&gt;Result&lt;/code&gt; is returned.</source>
          <target state="translated">Toma cada elemento en el &lt;code&gt;Iterator&lt;/code&gt; : si es un &lt;code&gt;Err&lt;/code&gt; , no se toman m&amp;aacute;s elementos y se devuelve &lt;code&gt;Err&lt;/code&gt; . Si no ocurre ning&amp;uacute;n &lt;code&gt;Err&lt;/code&gt; , se devuelve un contenedor con los valores de cada &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42c26fa2ecac3de7729494a9359458db2460cecc" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="translated">Toma cada elemento en el &lt;code&gt;Iterator&lt;/code&gt; : si es un &lt;code&gt;Err&lt;/code&gt; , no se toman m&amp;aacute;s elementos y se devuelve &lt;code&gt;Err&lt;/code&gt; . Si no se produce &lt;code&gt;Err&lt;/code&gt; , se devuelve el producto de todos los elementos.</target>
        </trans-unit>
        <trans-unit id="c82330496098a00243d3f411105f0f70776be883" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="translated">Toma cada elemento en el &lt;code&gt;Iterator&lt;/code&gt; : si es un &lt;code&gt;Err&lt;/code&gt; , no se toman m&amp;aacute;s elementos y se devuelve &lt;code&gt;Err&lt;/code&gt; . Si no ocurre &lt;code&gt;Err&lt;/code&gt; , se devuelve la suma de todos los elementos.</target>
        </trans-unit>
        <trans-unit id="01d5fda76710ca0641abcbb3e4cbb1bb6e17f736" translate="yes" xml:space="preserve">
          <source>Takes each element, adds them together, and returns the result.</source>
          <target state="translated">Toma cada elemento,los suma y devuelve el resultado.</target>
        </trans-unit>
        <trans-unit id="6776e27751852b377b68c46a8017d15dd715c595" translate="yes" xml:space="preserve">
          <source>Takes linear (in &lt;code&gt;self.len()&lt;/code&gt;) time.</source>
          <target state="translated">Toma tiempo lineal (en &lt;code&gt;self.len()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fdca1895a18c3a298f6533b4c2e334951c66b62c" translate="yes" xml:space="preserve">
          <source>Takes ownership and &quot;forgets&quot; about the value &lt;strong&gt;without running its destructor&lt;/strong&gt;.</source>
          <target state="translated">Toma propiedad y &quot;olvida&quot; el valor &lt;strong&gt;sin ejecutar su destructor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b8fa769819072fbe610e5e9c85934d3a05171939" translate="yes" xml:space="preserve">
          <source>Takes the contained value out.</source>
          <target state="translated">Saca el valor contenido.</target>
        </trans-unit>
        <trans-unit id="4aec823974aa072f464dcb5cc764f9240e0f60dd" translate="yes" xml:space="preserve">
          <source>Takes the cubic root of a number.</source>
          <target state="translated">Toma la raíz cúbica de un número.</target>
        </trans-unit>
        <trans-unit id="f045194d706e7e41fabb862c8032ea26f5f950f2" translate="yes" xml:space="preserve">
          <source>Takes the reciprocal (inverse) of a number, &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">Toma el rec&amp;iacute;proco (inverso) de un n&amp;uacute;mero, &lt;code&gt;1/x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a48b57259f94b360feec04d91e3f646f9cba125" translate="yes" xml:space="preserve">
          <source>Takes the square root of a number.</source>
          <target state="translated">Toma la raíz cuadrada de un número.</target>
        </trans-unit>
        <trans-unit id="29583c6b4f13f8e1828da3f713db57dac29990e1" translate="yes" xml:space="preserve">
          <source>Takes the value from the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; container out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc799efc0b882851473c22ca2ca5ccf94ddabfe1" translate="yes" xml:space="preserve">
          <source>Takes the value of the cell, leaving &lt;code&gt;Default::default()&lt;/code&gt; in its place.</source>
          <target state="translated">Toma el valor de la celda, dejando &lt;code&gt;Default::default()&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="21859ca86840d9216ef1aca0008b5877f29f5e68" translate="yes" xml:space="preserve">
          <source>Takes the value of the entry out of the map, and returns it.</source>
          <target state="translated">Saca el valor de la entrada del mapa y lo devuelve.</target>
        </trans-unit>
        <trans-unit id="e353877ad2ec8473ab467885d9861796b98bdada" translate="yes" xml:space="preserve">
          <source>Takes the value out of the entry, and returns it.</source>
          <target state="translated">Toma el valor de la entrada y lo devuelve.</target>
        </trans-unit>
        <trans-unit id="761daab64ee172552a57dae50c6f8a92c4d9c366" translate="yes" xml:space="preserve">
          <source>Takes the value out of the option, leaving a &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in its place.</source>
          <target state="translated">Elimina el valor de la opci&amp;oacute;n, dejando &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="b7c52a2ee2d265275374b5c1f093b7a06a9428c4" translate="yes" xml:space="preserve">
          <source>Takes the value out of the option, leaving a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba923f497880c808c6be64ea728bee38b782b657" translate="yes" xml:space="preserve">
          <source>Takes the wrapped value, leaving &lt;code&gt;Default::default()&lt;/code&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f95b9cdf9802bc6e9feca2c7b307fe24034be8d" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence.</source>
          <target state="translated">Toma dos iteradores y crea un nuevo iterador sobre ambos en secuencia.</target>
        </trans-unit>
        <trans-unit id="787908ffef98464dc332707d755e2c4f129a3015" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma dos iteradores y crea un nuevo iterador sobre ambos en secuencia. &lt;a href=&quot;../../../iter/trait.iterator#method.chain&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96c4c94db35b0a5de2fc876c74307d69f4d1f941" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma dos iteradores y crea un nuevo iterador sobre ambos en secuencia. &lt;a href=&quot;../../iter/trait.iterator#method.chain&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09c1398fa07d7872f8f96945eceb77ea195aaf9f" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma dos iteradores y crea un nuevo iterador sobre ambos en secuencia. &lt;a href=&quot;../iter/trait.iterator#method.chain&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e8033a8a0d88d9c00564885e5bd3facaba3011b" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma dos iteradores y crea un nuevo iterador sobre ambos en secuencia. &lt;a href=&quot;iter/trait.iterator#method.chain&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="772b77fdfc8e9968126bb233f7891ef8441c5352" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma dos iteradores y crea un nuevo iterador sobre ambos en secuencia. &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e48610b94d0c8b865914c76042a0dd63c8ace3fb" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">Tomando una &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="4f62d9e379567856d558f8df128e53e7eeda59a9" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">Tomando un &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="acf17a2c9691dbabd08f8be26e62792363680f2f" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">Tomando un &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="9b593af3c7f2108f31456b5ab2cb3574e71f3b6e" translate="yes" xml:space="preserve">
          <source>Taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It&amp;rsquo;s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.</source>
          <target state="translated">Tomar posesi&amp;oacute;n y luego devolver la propiedad con cada funci&amp;oacute;n es un poco tedioso. &amp;iquest;Qu&amp;eacute; pasa si queremos permitir que una funci&amp;oacute;n use un valor pero no se apropie? Es bastante molesto que cualquier cosa que pasemos tambi&amp;eacute;n deba devolverse si queremos usarla nuevamente, adem&amp;aacute;s de cualquier dato resultante del cuerpo de la funci&amp;oacute;n que tambi&amp;eacute;n podr&amp;iacute;amos querer devolver.</target>
        </trans-unit>
        <trans-unit id="4aa5a6c5b61f9a1ca73ba483f7a4a44ead615a2c" translate="yes" xml:space="preserve">
          <source>Targets which do not support switching between linkage of the C runtime will ignore this flag. It's recommended to inspect the resulting binary to ensure that it's linked as you would expect after the compiler succeeds.</source>
          <target state="translated">Los objetivos que no soporten el cambio de conexión del tiempo de ejecución C ignorarán esta bandera.Se recomienda inspeccionar el binario resultante para asegurarse de que está enlazado como se espera después de que el compilador tenga éxito.</target>
        </trans-unit>
        <trans-unit id="9ad8024a2c7b1265fb5e22250fc7a31283cdbd36" translate="yes" xml:space="preserve">
          <source>TcpListener</source>
          <target state="translated">TcpListener</target>
        </trans-unit>
        <trans-unit id="ece7cdbc23c076f1d64f752343ef7aec8eec539f" translate="yes" xml:space="preserve">
          <source>TcpListener::accept</source>
          <target state="translated">TcpListener::accept</target>
        </trans-unit>
        <trans-unit id="a2a291bb7ab19718d31f7478d18104e4158a939c" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_fd</source>
          <target state="translated">TcpListener::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="49f5fe2427c190a7f8a472e06e6d569a7ff427c4" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_socket</source>
          <target state="translated">TcpListener::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="2e2338f796fa51dd367f2f2c91e316fe98afe3a0" translate="yes" xml:space="preserve">
          <source>TcpListener::bind</source>
          <target state="translated">TcpListener::bind</target>
        </trans-unit>
        <trans-unit id="bc75d22ad0ef01f38f6f564c0448b514f01f2b1e" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow</source>
          <target state="translated">TcpListener::borrow</target>
        </trans-unit>
        <trans-unit id="b7bf89d05dc43863ce7b237f1c9339841b44d828" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow_mut</source>
          <target state="translated">TcpListener::borrow_mut</target>
        </trans-unit>
        <trans-unit id="67148bab8cc6c3ad3159fa098deca2df5084c5bc" translate="yes" xml:space="preserve">
          <source>TcpListener::fmt</source>
          <target state="translated">TcpListener::fmt</target>
        </trans-unit>
        <trans-unit id="e2222d5e97ec906a2d58760a4b094c72e792239f" translate="yes" xml:space="preserve">
          <source>TcpListener::from</source>
          <target state="translated">TcpListener::from</target>
        </trans-unit>
        <trans-unit id="965dc7a632243e984a2b9e894788c6c21d7eb5d8" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_fd</source>
          <target state="translated">TcpListener::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="482dc849c70cec776e4f8a473271ccf0cb6cf277" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_socket</source>
          <target state="translated">TcpListener::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="1934b5e7d2fb2d8224b23b4ad0d2399a5cb3b873" translate="yes" xml:space="preserve">
          <source>TcpListener::incoming</source>
          <target state="translated">TcpListener::incoming</target>
        </trans-unit>
        <trans-unit id="428c642a4eaf5906beb8fe4edf0ac026bb70054c" translate="yes" xml:space="preserve">
          <source>TcpListener::into</source>
          <target state="translated">TcpListener::into</target>
        </trans-unit>
        <trans-unit id="ecf165a93c2c3a51f657446508db4792cbb31eef" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_fd</source>
          <target state="translated">TcpListener::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="171dba66a0881e83fbf754117718cae198277962" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_socket</source>
          <target state="translated">TcpListener::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2275a3d2aa672ca4311b697b11d81ca54319cd4f" translate="yes" xml:space="preserve">
          <source>TcpListener::local_addr</source>
          <target state="translated">TcpListener::local_addr</target>
        </trans-unit>
        <trans-unit id="ec11714ec8bf6a942994646bb7ec40f6ec987004" translate="yes" xml:space="preserve">
          <source>TcpListener::only_v6</source>
          <target state="translated">TcpListener::only_v6</target>
        </trans-unit>
        <trans-unit id="8f9762884937dfa70d1e7429478f09a0cb47d310" translate="yes" xml:space="preserve">
          <source>TcpListener::set_nonblocking</source>
          <target state="translated">TcpListener::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="226f648e250e40bcc471fd5a673bff010846e472" translate="yes" xml:space="preserve">
          <source>TcpListener::set_only_v6</source>
          <target state="translated">TcpListener::set_only_v6</target>
        </trans-unit>
        <trans-unit id="4715bf3aa73135001a12ace3fe29f1f7e2fa4701" translate="yes" xml:space="preserve">
          <source>TcpListener::set_ttl</source>
          <target state="translated">TcpListener::set_ttl</target>
        </trans-unit>
        <trans-unit id="52dd134154d36dce171d232dad1f997d4a86ef76" translate="yes" xml:space="preserve">
          <source>TcpListener::take_error</source>
          <target state="translated">TcpListener::take_error</target>
        </trans-unit>
        <trans-unit id="346a3319242ccfb5f2d382bc3687dc41f26c3692" translate="yes" xml:space="preserve">
          <source>TcpListener::try_clone</source>
          <target state="translated">TcpListener::try_clone</target>
        </trans-unit>
        <trans-unit id="8774def23dc815607fb5f6d621a655e6351d76ed" translate="yes" xml:space="preserve">
          <source>TcpListener::try_from</source>
          <target state="translated">TcpListener::try_from</target>
        </trans-unit>
        <trans-unit id="4d964782d52d7cadd1d535988a4c17142f01c956" translate="yes" xml:space="preserve">
          <source>TcpListener::try_into</source>
          <target state="translated">TcpListener::try_into</target>
        </trans-unit>
        <trans-unit id="720c95f141c0826fd5fca57448ce533672b87275" translate="yes" xml:space="preserve">
          <source>TcpListener::ttl</source>
          <target state="translated">TcpListener::ttl</target>
        </trans-unit>
        <trans-unit id="8b5ab82dcc35d3a2cd49204d3a4a7a3449b42f85" translate="yes" xml:space="preserve">
          <source>TcpListener::type_id</source>
          <target state="translated">TcpListener::type_id</target>
        </trans-unit>
        <trans-unit id="35342d32149945519f7e31daff4e30855fbeba49" translate="yes" xml:space="preserve">
          <source>TcpStream</source>
          <target state="translated">TcpStream</target>
        </trans-unit>
        <trans-unit id="9eafc6b129d5efa5c4b0a83e50a95e30344816f3" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_fd</source>
          <target state="translated">TcpStream::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="09ec2aef24015b31ab23113ac683d2f8346c1f39" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_socket</source>
          <target state="translated">TcpStream::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="12e762e3cfe2aa9d71a2a757abb3507e964d1881" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow</source>
          <target state="translated">TcpStream::borrow</target>
        </trans-unit>
        <trans-unit id="d91a58f6ef21ac04bf7fb8b19bbc87b6dbe9fb4c" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow_mut</source>
          <target state="translated">TcpStream::borrow_mut</target>
        </trans-unit>
        <trans-unit id="11f8dcda0e1ccab974f38cf496de4e39b14b25cb" translate="yes" xml:space="preserve">
          <source>TcpStream::by_ref</source>
          <target state="translated">TcpStream::by_ref</target>
        </trans-unit>
        <trans-unit id="bfbef109c2e4f33f2aedd0c714f14f49404d152c" translate="yes" xml:space="preserve">
          <source>TcpStream::bytes</source>
          <target state="translated">TcpStream::bytes</target>
        </trans-unit>
        <trans-unit id="e1fe899d60189a16135ede51a667e0fdef40fd00" translate="yes" xml:space="preserve">
          <source>TcpStream::chain</source>
          <target state="translated">TcpStream::chain</target>
        </trans-unit>
        <trans-unit id="9b075e5500b6c35efe89a7d4bf0762c653e6221c" translate="yes" xml:space="preserve">
          <source>TcpStream::connect</source>
          <target state="translated">TcpStream::connect</target>
        </trans-unit>
        <trans-unit id="7c9bc4cc7e00f6a9f012c5c2f74296bd08fb3cd9" translate="yes" xml:space="preserve">
          <source>TcpStream::connect_timeout</source>
          <target state="translated">TcpStream::connect_timeout</target>
        </trans-unit>
        <trans-unit id="7e82ba30a964300fd5401b21bdde38ef8892a264" translate="yes" xml:space="preserve">
          <source>TcpStream::flush</source>
          <target state="translated">TcpStream::flush</target>
        </trans-unit>
        <trans-unit id="5e2f83b6ef3a2fd9f5722070fe250aef910cb0f5" translate="yes" xml:space="preserve">
          <source>TcpStream::fmt</source>
          <target state="translated">TcpStream::fmt</target>
        </trans-unit>
        <trans-unit id="3a3304a1471ecd9e54075022592709e4164425d3" translate="yes" xml:space="preserve">
          <source>TcpStream::from</source>
          <target state="translated">TcpStream::from</target>
        </trans-unit>
        <trans-unit id="0c544151d800149c130a2b4e5fa0242d2c6c5fe2" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_fd</source>
          <target state="translated">TcpStream::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f33ab52a5f61c4e532d24e2b9d448a864ab588ef" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_socket</source>
          <target state="translated">TcpStream::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="ac8cf31a8273795291384f9b9a189065f0e4ddda" translate="yes" xml:space="preserve">
          <source>TcpStream::initializer</source>
          <target state="translated">TcpStream::initializer</target>
        </trans-unit>
        <trans-unit id="bb02adb8fb5756c502d5d11c517f31b37848f5b3" translate="yes" xml:space="preserve">
          <source>TcpStream::into</source>
          <target state="translated">TcpStream::into</target>
        </trans-unit>
        <trans-unit id="8b62d5f9b1506a6417ce6b1e7abc2fe81f1a512b" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_fd</source>
          <target state="translated">TcpStream::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="2d62e49030fac395488f03a44bc65385d791c4a1" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_socket</source>
          <target state="translated">TcpStream::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2f15c295f6cbee27e4704ba77400c3f9cdb74347" translate="yes" xml:space="preserve">
          <source>TcpStream::local_addr</source>
          <target state="translated">TcpStream::local_addr</target>
        </trans-unit>
        <trans-unit id="3e41769cd3c7bc5fe0ffd071decfac8538fce3c8" translate="yes" xml:space="preserve">
          <source>TcpStream::nodelay</source>
          <target state="translated">TcpStream::nodelay</target>
        </trans-unit>
        <trans-unit id="b1c4ef3a856c377290ba0effe22fa456b4c5d618" translate="yes" xml:space="preserve">
          <source>TcpStream::peek</source>
          <target state="translated">TcpStream::peek</target>
        </trans-unit>
        <trans-unit id="02b5be94fe4bd3a77f45294ce309a022defb0142" translate="yes" xml:space="preserve">
          <source>TcpStream::peer_addr</source>
          <target state="translated">TcpStream::peer_addr</target>
        </trans-unit>
        <trans-unit id="168308bcf15754b94b3cd0ff91dc84d727c89085" translate="yes" xml:space="preserve">
          <source>TcpStream::read</source>
          <target state="translated">TcpStream::read</target>
        </trans-unit>
        <trans-unit id="a51f803ec2bc3d6b94f3630947f31e7b2bee3ed5" translate="yes" xml:space="preserve">
          <source>TcpStream::read_exact</source>
          <target state="translated">TcpStream::read_exact</target>
        </trans-unit>
        <trans-unit id="cddced3b85b2ead651c93e97a2f622b9f49035db" translate="yes" xml:space="preserve">
          <source>TcpStream::read_timeout</source>
          <target state="translated">TcpStream::read_timeout</target>
        </trans-unit>
        <trans-unit id="1957796c8b2bd9a577cc9018f30d0a2d1c2fe241" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_end</source>
          <target state="translated">TcpStream::read_to_end</target>
        </trans-unit>
        <trans-unit id="9f494c5d56be921420520740cf0cbafa75a20b7b" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_string</source>
          <target state="translated">TcpStream::read_to_string</target>
        </trans-unit>
        <trans-unit id="c6fa288859680339e04670a33f1a14f57af1e652" translate="yes" xml:space="preserve">
          <source>TcpStream::read_vectored</source>
          <target state="translated">TcpStream::read_vectored</target>
        </trans-unit>
        <trans-unit id="e83138e7f219d526516674b5550a795c09cf97fa" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nodelay</source>
          <target state="translated">TcpStream::set_nodelay</target>
        </trans-unit>
        <trans-unit id="6f3db10df76b321eadb9c9c65b440fd1e62d4157" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nonblocking</source>
          <target state="translated">TcpStream::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="0ef1754192987fd2a71c4d09d1363328c40af9e8" translate="yes" xml:space="preserve">
          <source>TcpStream::set_read_timeout</source>
          <target state="translated">TcpStream::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="1c0d37734b35b5aaae88202ef8744780ebadf163" translate="yes" xml:space="preserve">
          <source>TcpStream::set_ttl</source>
          <target state="translated">TcpStream::set_ttl</target>
        </trans-unit>
        <trans-unit id="cf06a99e15825f5af0170343a971d82291a1bb70" translate="yes" xml:space="preserve">
          <source>TcpStream::set_write_timeout</source>
          <target state="translated">TcpStream::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="de9f03e4aaf65b0dacf8a1a510098378140fbad7" translate="yes" xml:space="preserve">
          <source>TcpStream::shutdown</source>
          <target state="translated">TcpStream::shutdown</target>
        </trans-unit>
        <trans-unit id="f729ec43f0af2f4768020c3c186531540aa6fe75" translate="yes" xml:space="preserve">
          <source>TcpStream::take</source>
          <target state="translated">TcpStream::take</target>
        </trans-unit>
        <trans-unit id="07ca37092d4865ff34b3da8842e6f13eb4a33726" translate="yes" xml:space="preserve">
          <source>TcpStream::take_error</source>
          <target state="translated">TcpStream::take_error</target>
        </trans-unit>
        <trans-unit id="3f33672645be4d6e5bd0541f33a42009a106b1ad" translate="yes" xml:space="preserve">
          <source>TcpStream::try_clone</source>
          <target state="translated">TcpStream::try_clone</target>
        </trans-unit>
        <trans-unit id="0e120d19ada990068a0b20ff52db32daba2c74d5" translate="yes" xml:space="preserve">
          <source>TcpStream::try_from</source>
          <target state="translated">TcpStream::try_from</target>
        </trans-unit>
        <trans-unit id="0b039d724a73bfa4d009fb758a03fb779a56b987" translate="yes" xml:space="preserve">
          <source>TcpStream::try_into</source>
          <target state="translated">TcpStream::try_into</target>
        </trans-unit>
        <trans-unit id="833adb6a3443ef8c2bc774bcc30192c98f27094a" translate="yes" xml:space="preserve">
          <source>TcpStream::ttl</source>
          <target state="translated">TcpStream::ttl</target>
        </trans-unit>
        <trans-unit id="ad00f68ee2a21774a182c99f9b2a83cd6f6f89e9" translate="yes" xml:space="preserve">
          <source>TcpStream::type_id</source>
          <target state="translated">TcpStream::type_id</target>
        </trans-unit>
        <trans-unit id="accd5bacb0184a5ab554a0ca248574c5b5ddbbcb" translate="yes" xml:space="preserve">
          <source>TcpStream::write</source>
          <target state="translated">TcpStream::write</target>
        </trans-unit>
        <trans-unit id="0058eeee13c9051b5e0a752af3087b29d7b02d7b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_all</source>
          <target state="translated">TcpStream::write_all</target>
        </trans-unit>
        <trans-unit id="cb06fd9c7d1d55fc4b3f3e15dc0163521ac1465b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_fmt</source>
          <target state="translated">TcpStream::write_fmt</target>
        </trans-unit>
        <trans-unit id="a5e3f17e3264af59b558a0fdcba770ba3c28fa37" translate="yes" xml:space="preserve">
          <source>TcpStream::write_timeout</source>
          <target state="translated">TcpStream::write_timeout</target>
        </trans-unit>
        <trans-unit id="6e74581726f107bfc541797c5b9030282bc56e97" translate="yes" xml:space="preserve">
          <source>TcpStream::write_vectored</source>
          <target state="translated">TcpStream::write_vectored</target>
        </trans-unit>
        <trans-unit id="b6eac90e1928ad9ea4411f97ebcf59a5c7e10ed0" translate="yes" xml:space="preserve">
          <source>Teams of Developers</source>
          <target state="translated">Equipos de desarrolladores</target>
        </trans-unit>
        <trans-unit id="260e040b381f220359095e13ffb45be2fbc63287" translate="yes" xml:space="preserve">
          <source>Tells LLVM that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">Le dice a LLVM que este punto en el código no es alcanzable,lo que permite mayores optimizaciones.</target>
        </trans-unit>
        <trans-unit id="a946abf59c33631dd9c09fe026f5fda52ecefd51" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">Le dice a este b&amp;uacute;fer que se han consumido &lt;code&gt;amt&lt;/code&gt; bytes del b&amp;uacute;fer, por lo que ya no deber&amp;iacute;an devolverse en llamadas a &lt;code&gt;read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="092a16374b222f88ad28cf25d43d7648234ed176" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Le dice a este b&amp;uacute;fer que se han consumido &lt;code&gt;amt&lt;/code&gt; bytes del b&amp;uacute;fer, por lo que ya no deber&amp;iacute;an devolverse en llamadas a &lt;code&gt;read&lt;/code&gt; . &lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="027be37242a148e84d0572e0cc986124d9c751bc" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Le dice a este b&amp;uacute;fer que se han consumido &lt;code&gt;amt&lt;/code&gt; bytes del b&amp;uacute;fer, por lo que ya no deber&amp;iacute;an devolverse en llamadas a &lt;code&gt;read&lt;/code&gt; . &lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea3b911565206879ae5d6cb4146bc834dfb6a7f3" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Le dice a este b&amp;uacute;fer que se han consumido &lt;code&gt;amt&lt;/code&gt; bytes del b&amp;uacute;fer, por lo que ya no deber&amp;iacute;an devolverse en llamadas a &lt;code&gt;read&lt;/code&gt; . &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68f4c5ea285ef679416734518ea1144f7f9f2cf1" translate="yes" xml:space="preserve">
          <source>Temporal quantification.</source>
          <target state="translated">Cuantificación temporal.</target>
        </trans-unit>
        <trans-unit id="be80baca9006a4100bd6b71127149a07eb502503" translate="yes" xml:space="preserve">
          <source>Temporaries</source>
          <target state="translated">Temporaries</target>
        </trans-unit>
        <trans-unit id="b1380bff4b98c3f3b1a409ce860a8bd5d4ce8c7b" translate="yes" xml:space="preserve">
          <source>Temporaries are also created to hold the result of operands to an expression while the other operands are evaluated. The temporaries are associated to the scope of the expression with that operand. Since the temporaries are moved from once the expression is evaluated, dropping them has no effect unless one of the operands to an expression breaks out of the expression, returns, or panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121a6beed14a5f45c5406020e211d50eaf732ff" translate="yes" xml:space="preserve">
          <source>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the &lt;code&gt;&amp;amp;&lt;/code&gt; expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; and not &lt;code&gt;let tmp = foo()&lt;/code&gt;:</source>
          <target state="translated">Los temporales no siempre se eliminan al final de la declaraci&amp;oacute;n adjunta. En casos simples donde la expresi&amp;oacute;n &lt;code&gt;&amp;amp;&lt;/code&gt; se almacena inmediatamente en una variable, el compilador extender&amp;aacute; autom&amp;aacute;ticamente la vida &amp;uacute;til del temporal hasta el final del bloque adjunto. Por lo tanto, una forma alternativa de arreglar el programa original es escribir &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; y no &lt;code&gt;let tmp = foo()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff4686225d8fb1e953162a00f63d6b94d5a386fd" translate="yes" xml:space="preserve">
          <source>Temporaries that are created in the final expression of a function body are dropped &lt;em&gt;after&lt;/em&gt; any named variables bound in the function body, as there is no smaller enclosing temporary scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae8496ab0d5e20c300ea07a6c87645fbefee013" translate="yes" xml:space="preserve">
          <source>Temporary lifetime extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237179150c9f45b00df9097591b1d7f10ef2038" translate="yes" xml:space="preserve">
          <source>Temporary lifetimes</source>
          <target state="translated">Vidas temporales</target>
        </trans-unit>
        <trans-unit id="ace2219c94d381961a79fb4617905c5cfbbacbf7" translate="yes" xml:space="preserve">
          <source>Temporary scopes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc9ea018278b216d5b6d6db9b73a7c2a6e7a8c8" translate="yes" xml:space="preserve">
          <source>Terminates the current process with the specified exit code.</source>
          <target state="translated">Termina el proceso actual con el código de salida especificado.</target>
        </trans-unit>
        <trans-unit id="4abcdd83ee3f3bce743cbed96b2ad9f965bea36e" translate="yes" xml:space="preserve">
          <source>Terminates the process in an abnormal fashion.</source>
          <target state="translated">Termina el proceso de forma anormal.</target>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="4d00170cd71cecfb46cdbb7ebdf05a4a02fee721" translate="yes" xml:space="preserve">
          <source>Termination::report</source>
          <target state="translated">Termination::report</target>
        </trans-unit>
        <trans-unit id="00f441aa04210533cf8168c3d0baeda960edac55" translate="yes" xml:space="preserve">
          <source>Terminator for various items and statements, &lt;a href=&quot;types/array&quot;&gt;Array types&lt;/a&gt;</source>
          <target state="translated">Terminator para varios elementos y declaraciones, &lt;a href=&quot;types/array&quot;&gt;tipos de matriz&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94aaabf5a007f6525e86dbe783c284fccc74a25c" translate="yes" xml:space="preserve">
          <source>Test Organization</source>
          <target state="translated">Organización de la prueba</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="da7894cbcc38e877e01ccb02e3c5e98f656c5624" translate="yes" xml:space="preserve">
          <source>Testing Equality with the &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; Macros</source>
          <target state="translated">Prueba de igualdad con &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; y &lt;code&gt;assert_ne!&lt;/code&gt; Macros</target>
        </trans-unit>
        <trans-unit id="117ea1d14f7b6fbe5fa90955d52644403f513522" translate="yes" xml:space="preserve">
          <source>Testing Private Functions</source>
          <target state="translated">Probando las funciones privadas</target>
        </trans-unit>
        <trans-unit id="932c5d1d0f6f5178e61a3f6e97a669a7ad5fc25b" translate="yes" xml:space="preserve">
          <source>Testing attributes</source>
          <target state="translated">Atributos de la prueba</target>
        </trans-unit>
        <trans-unit id="6966e45073f574893b66ceb3ad6d45bb2ced06e0" translate="yes" xml:space="preserve">
          <source>Testing is a complex skill: although we can&amp;rsquo;t cover every detail about how to write good tests in one chapter, we&amp;rsquo;ll discuss the mechanics of Rust&amp;rsquo;s testing facilities. We&amp;rsquo;ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</source>
          <target state="translated">La prueba es una habilidad compleja: aunque no podemos cubrir todos los detalles sobre c&amp;oacute;mo escribir buenas pruebas en un cap&amp;iacute;tulo, discutiremos la mec&amp;aacute;nica de las instalaciones de prueba de Rust. Hablaremos sobre las anotaciones y macros disponibles para usted al escribir sus pruebas, el comportamiento predeterminado y las opciones proporcionadas para ejecutar sus pruebas y c&amp;oacute;mo organizar las pruebas en pruebas unitarias y pruebas de integraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f7c988b9b3e507c053615421186791199dc1b08e" translate="yes" xml:space="preserve">
          <source>Testing the First Part</source>
          <target state="translated">Probando la primera parte</target>
        </trans-unit>
        <trans-unit id="833858d67cb9edd86a232319e147507d73e766ab" translate="yes" xml:space="preserve">
          <source>Tests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</source>
          <target state="translated">Las pruebas son funciones de oxidación que verifican que el código no de prueba funciona de la manera esperada.Los cuerpos de las funciones de prueba suelen realizar estas tres acciones:</target>
        </trans-unit>
        <trans-unit id="9557b92aa71fea3ff4e10ad5c651a01d327198f2" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;person&lt;/code&gt; has the &lt;code&gt;car&lt;/code&gt; field filled with something.</source>
          <target state="translated">Prueba si la &lt;code&gt;person&lt;/code&gt; a tiene el campo del &lt;code&gt;car&lt;/code&gt; lleno con algo.</target>
        </trans-unit>
        <trans-unit id="21b62ab2004ca1232d413d8d665d134b12791482" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate.</source>
          <target state="translated">Comprueba si algún elemento del iterador coincide con un predicado.</target>
        </trans-unit>
        <trans-unit id="10d2dce236b59fb61d9321a2651527964d17f562" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si alg&amp;uacute;n elemento del iterador coincide con un predicado. &lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="209ac04cb187d92f123ce6700c9444025e5580b3" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si alg&amp;uacute;n elemento del iterador coincide con un predicado. &lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80ec10f423a5beaec1ab62efd9e4031e5aaa4a11" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si alg&amp;uacute;n elemento del iterador coincide con un predicado. &lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ae5105c89912ab7a036138a76c59ddfecc44b" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si alg&amp;uacute;n elemento del iterador coincide con un predicado. &lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df440409ef320551129c77bcadb79c6c4ba84e37" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si alg&amp;uacute;n elemento del iterador coincide con un predicado. &lt;a href=&quot;trait.iterator#method.any&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42f540ef5575b87eda1bc58cc8c893cf2e3e2964" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate.</source>
          <target state="translated">Comprueba si cada elemento del iterador coincide con un predicado.</target>
        </trans-unit>
        <trans-unit id="52e69927724e46dd631e47a69a4f2cdc74a668ca" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si cada elemento del iterador coincide con un predicado. &lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c572c6f114e3b7b0e63531ab8e78116f0d5ac5de" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si cada elemento del iterador coincide con un predicado. &lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a987e1ebbc5dd44d57ed09974bfdcc0f02c47b55" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si cada elemento del iterador coincide con un predicado. &lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74b456b0054dd24ca1a515d72ae7f4e5367d4633" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si cada elemento del iterador coincide con un predicado. &lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92be4e62f1c703e57b0a705c84b8aca1511558d2" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Prueba si cada elemento del iterador coincide con un predicado. &lt;a href=&quot;trait.iterator#method.all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ebc400fe5bb7d000d0d73f12e63cdedd3140090" translate="yes" xml:space="preserve">
          <source>Tests if the person's &lt;code&gt;age&lt;/code&gt; field is between 13 and 19, and binds its value to the &lt;code&gt;person_age&lt;/code&gt; variable.</source>
          <target state="translated">Comprueba si el campo de &lt;code&gt;age&lt;/code&gt; la persona est&amp;aacute; entre 13 y 19 y vincula su valor a la variable &lt;code&gt;person_age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13e062493861ff1e884762affb6f292d7aaa95d6" translate="yes" xml:space="preserve">
          <source>Tests that return &lt;code&gt;()&lt;/code&gt; pass as long as they terminate and do not panic. Tests that return a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; pass as long as they return &lt;code&gt;Ok(())&lt;/code&gt;. Tests that do not terminate neither pass nor fail.</source>
          <target state="translated">Las pruebas que devuelven &lt;code&gt;()&lt;/code&gt; pasan siempre que terminen y no entren en p&amp;aacute;nico. Las pruebas que devuelven un &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; pasan siempre que devuelvan &lt;code&gt;Ok(())&lt;/code&gt; . Las pruebas que no terminan ni pasan ni fracasan.</target>
        </trans-unit>
        <trans-unit id="240e8d8b35fd6dbae3889295d03396f4179097df" translate="yes" xml:space="preserve">
          <source>Tests that use &lt;code&gt;should_panic&lt;/code&gt; can be imprecise because they only indicate that the code has caused some panic. A &lt;code&gt;should_panic&lt;/code&gt; test would pass even if the test panics for a different reason from the one we were expecting to happen. To make &lt;code&gt;should_panic&lt;/code&gt; tests more precise, we can add an optional &lt;code&gt;expected&lt;/code&gt; parameter to the &lt;code&gt;should_panic&lt;/code&gt; attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for &lt;code&gt;Guess&lt;/code&gt; in Listing 11-9 where the &lt;code&gt;new&lt;/code&gt; function panics with different messages depending on whether the value is too small or too large.</source>
          <target state="translated">Las pruebas que usan &lt;code&gt;should_panic&lt;/code&gt; pueden ser imprecisas porque solo indican que el c&amp;oacute;digo ha causado algo de p&amp;aacute;nico. Una prueba &lt;code&gt;should_panic&lt;/code&gt; pasar&amp;iacute;a incluso si la prueba entra en p&amp;aacute;nico por una raz&amp;oacute;n diferente a la que esper&amp;aacute;bamos que ocurriera. Para que &lt;code&gt;should_panic&lt;/code&gt; pruebas should_panic sean m&amp;aacute;s precisas, podemos agregar un par&amp;aacute;metro &lt;code&gt;expected&lt;/code&gt; opcional al atributo &lt;code&gt;should_panic&lt;/code&gt; . El arn&amp;eacute;s de prueba se asegurar&amp;aacute; de que el mensaje de falla contenga el texto proporcionado. Por ejemplo, considere el c&amp;oacute;digo modificado para &lt;code&gt;Guess&lt;/code&gt; en el Listado 11-9 donde la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n entra en p&amp;aacute;nico con diferentes mensajes dependiendo de si el valor es demasiado peque&amp;ntilde;o o demasiado grande.</target>
        </trans-unit>
        <trans-unit id="6bb384831446531aa67968092446024f5dcdae5e" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a directory. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">Comprueba si este tipo de archivo representa un directorio. El resultado es mutuamente excluyente de los resultados de &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt; ; s&amp;oacute;lo puede pasar ninguna o una de estas pruebas.</target>
        </trans-unit>
        <trans-unit id="47c7f108fa56b78dae837cfbc2c1b6e6d82a8892" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a regular file. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">Comprueba si este tipo de archivo representa un archivo normal. El resultado es mutuamente exclusivo de los resultados de &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt; ; s&amp;oacute;lo puede pasar ninguna o una de estas pruebas.</target>
        </trans-unit>
        <trans-unit id="8e2618283b789dcbc952fac3457682ad9646a29b" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a symbolic link. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">Comprueba si este tipo de archivo representa un enlace simb&amp;oacute;lico. El resultado es mutuamente exclusivo de los resultados de &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt; ; s&amp;oacute;lo puede pasar ninguna o una de estas pruebas.</target>
        </trans-unit>
        <trans-unit id="24e8ed91cce37f2bfddb7d0a6e1b5b5dd3e13c8b" translate="yes" xml:space="preserve">
          <source>Text directionality</source>
          <target state="translated">La direccionalidad del texto</target>
        </trans-unit>
        <trans-unit id="ece7c96ceb6b3c2888b8a50e4cc0084fdd3cc5ad" translate="yes" xml:space="preserve">
          <source>Textual Scope</source>
          <target state="translated">Ámbito de aplicación del texto</target>
        </trans-unit>
        <trans-unit id="f351ed281e01f153c5130339693bdde4a4318e5b" translate="yes" xml:space="preserve">
          <source>Textual representation</source>
          <target state="translated">Representación textual</target>
        </trans-unit>
        <trans-unit id="50a53707975aa4e011ef0d8fc19d6a0815b5a0af" translate="yes" xml:space="preserve">
          <source>Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with &lt;code&gt;let&lt;/code&gt; except it also applies at the module level. When &lt;code&gt;macro_rules!&lt;/code&gt; is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</source>
          <target state="translated">El alcance textual se basa en gran medida en el orden en que aparecen las cosas en los archivos fuente y funciona de manera similar al alcance de las variables locales declaradas con &lt;code&gt;let&lt;/code&gt; , excepto que tambi&amp;eacute;n se aplica a nivel de m&amp;oacute;dulo. Cuando &lt;code&gt;macro_rules!&lt;/code&gt; se usa para definir una macro, la macro ingresa al alcance despu&amp;eacute;s de la definici&amp;oacute;n (tenga en cuenta que a&amp;uacute;n se puede usar de forma recursiva, ya que los nombres se buscan en el sitio de invocaci&amp;oacute;n), hasta que se cierra su alcance circundante, generalmente un m&amp;oacute;dulo. Esto puede ingresar m&amp;oacute;dulos secundarios e incluso abarcar varios archivos:</target>
        </trans-unit>
        <trans-unit id="3250cb346f89521461c9526f4b4c9e22ab7dec1d" translate="yes" xml:space="preserve">
          <source>Textual types</source>
          <target state="translated">Tipos de texto</target>
        </trans-unit>
        <trans-unit id="43b22d6c26a5be334da039abbdd3a863691ba7f8" translate="yes" xml:space="preserve">
          <source>Thankfully, you won't need to worry about upholding this property when deriving both &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.</source>
          <target state="translated">Afortunadamente, no tendr&amp;aacute; que preocuparse por mantener esta propiedad al derivar tanto &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;Hash&lt;/code&gt; con &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d87603b9cd3744161580179aa52163b0ef139449" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use 'static:</source>
          <target state="translated">Gracias a la elisión de la vida estática,normalmente no tienes que usar explícitamente &quot;estática&quot;:</target>
        </trans-unit>
        <trans-unit id="ccd80fa4141d21f8d736b44824bc5d805727e80f" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdae0de8a5a5798d4caf783e96f237ed5528f2b" translate="yes" xml:space="preserve">
          <source>Thanks to this process, you can always check out the next build of Rust and verify for yourself that it&amp;rsquo;s easy to upgrade to: if a beta release doesn&amp;rsquo;t work as expected, you can report it to the team and get it fixed before the next stable release happens! Breakage in a beta release is relatively rare, but &lt;code&gt;rustc&lt;/code&gt; is still a piece of software, and bugs do exist.</source>
          <target state="translated">Gracias a este proceso, siempre puedes consultar la siguiente versi&amp;oacute;n de Rust y verificar por ti mismo que es f&amp;aacute;cil de actualizar: si una versi&amp;oacute;n beta no funciona como se esperaba, puedes informarlo al equipo y arreglarlo antes del &amp;iexcl;Sucede la pr&amp;oacute;xima versi&amp;oacute;n estable! La rotura en una versi&amp;oacute;n beta es relativamente rara, pero &lt;code&gt;rustc&lt;/code&gt; sigue siendo una pieza de software y existen errores.</target>
        </trans-unit>
        <trans-unit id="93b38f3306b86b6513f0666ee48835c2b21219b2" translate="yes" xml:space="preserve">
          <source>That first part is done by us: when we call &lt;code&gt;String::from&lt;/code&gt;, its implementation requests the memory it needs. This is pretty much universal in programming languages.</source>
          <target state="translated">Esa primera parte la hacemos nosotros: cuando llamamos a &lt;code&gt;String::from&lt;/code&gt; , su implementaci&amp;oacute;n solicita la memoria que necesita. Esto es bastante universal en los lenguajes de programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1348e5b21c821f227473000afcbce413f66d2f49" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the iterator yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">Es decir, para cada elemento de &lt;code&gt;a&lt;/code&gt; y su elemento siguiente &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a &amp;lt;= b&lt;/code&gt; debe mantener. Si el iterador produce exactamente cero o un elemento, se devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf20cf0a5a4308c50df24aa720ae0a415bab9777" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the slice yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">Es decir, para cada elemento de &lt;code&gt;a&lt;/code&gt; y su elemento siguiente &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a &amp;lt;= b&lt;/code&gt; debe mantener. Si el segmento produce exactamente cero o un elemento, se devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6141d9d942518cd742366c4e9a373eaeca5ba99a" translate="yes" xml:space="preserve">
          <source>That number of bytes is always between 1 and 4, inclusive.</source>
          <target state="translated">Ese número de bytes siempre está entre 1 y 4,inclusive.</target>
        </trans-unit>
        <trans-unit id="5636ef2e6fa0c7ceabc2956a6a83de732290f283" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable, so &lt;code&gt;forget&lt;/code&gt; is only recommended for specialized use cases like those shown below.</source>
          <target state="translated">Dicho esto, la p&amp;eacute;rdida de recursos como la memoria o los objetos de E / S generalmente no es deseable, por lo que solo se recomienda &lt;code&gt;forget&lt;/code&gt; para casos de uso especializados como los que se muestran a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bb0090f499faa8dbbaeb7f14d05f8e092483990d" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable. The need comes up in some specialized use cases for FFI or unsafe code, but even then, &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; is typically preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e204c683273a7064bf611cb21bf25b6a58ab5e" translate="yes" xml:space="preserve">
          <source>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait's protocol.</source>
          <target state="translated">Dicho esto,la aplicación debe proporcionar una estimación correcta,porque de lo contrario sería una violación del protocolo del rasgo.</target>
        </trans-unit>
        <trans-unit id="7bf3790580feeb3b9968c1d5ee569f07fe6dc889" translate="yes" xml:space="preserve">
          <source>That said, there is no wrong way to read this book. Read it however you feel helps you best.</source>
          <target state="translated">Dicho esto,no hay una forma incorrecta de leer este libro.Léelo como creas que te ayude mejor.</target>
        </trans-unit>
        <trans-unit id="947746e61ef4047bc2347841bf565d094e7bdec0" translate="yes" xml:space="preserve">
          <source>That solves our problem! With only &lt;code&gt;s2&lt;/code&gt; valid, when it goes out of scope, it alone will free the memory, and we&amp;rsquo;re done.</source>
          <target state="translated">&amp;iexcl;Eso resuelve nuestro problema! Con solo &lt;code&gt;s2&lt;/code&gt; v&amp;aacute;lido, cuando sale del alcance, solo liberar&amp;aacute; la memoria, y listo.</target>
        </trans-unit>
        <trans-unit id="9ce801650086879dbc3fc82fa6315949a2552c96" translate="yes" xml:space="preserve">
          <source>That was a bit of a whirlwind tour of unwind safety, but for more information about unwind safety and how it applies to Rust, see an &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;associated RFC&lt;/a&gt;.</source>
          <target state="translated">Ese fue un viaje rel&amp;aacute;mpago de seguridad para relajarse, pero para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la seguridad para relajarse y c&amp;oacute;mo se aplica a Rust, consulte un &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;RFC asociado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92b56514bc3604cf70d965940d81ed28035240b2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust&amp;rsquo;s &lt;code&gt;char&lt;/code&gt; type is, those bytes look like this:</source>
          <target state="translated">Eso es 18 bytes y es la forma en que las computadoras almacenan estos datos en &amp;uacute;ltima instancia. Si los miramos como valores escalares Unicode, que son el tipo de &lt;code&gt;char&lt;/code&gt; de Rust , esos bytes se ven as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="9fac4c3e9f71b06878dbbb47f3ce2814227f227f" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of &lt;code&gt;match&lt;/code&gt;! The &lt;code&gt;match&lt;/code&gt; expression is very useful but also very much a primitive. In Chapter 13, you&amp;rsquo;ll learn about closures; the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many methods that accept a closure and are implemented using &lt;code&gt;match&lt;/code&gt; expressions. Using those methods will make your code more concise. A more seasoned Rustacean might write this code instead of Listing 9-5:</source>
          <target state="translated">&amp;iexcl;Eso es mucho &lt;code&gt;match&lt;/code&gt; ! La expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; es muy &amp;uacute;til pero tambi&amp;eacute;n muy primitiva. En el Cap&amp;iacute;tulo 13, aprender&amp;aacute; sobre cierres; el tipo &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; tiene muchos m&amp;eacute;todos que aceptan un cierre y se implementan usando expresiones de &lt;code&gt;match&lt;/code&gt; . El uso de esos m&amp;eacute;todos har&amp;aacute; que su c&amp;oacute;digo sea m&amp;aacute;s conciso. Un rust&amp;aacute;ceo m&amp;aacute;s experimentado podr&amp;iacute;a escribir este c&amp;oacute;digo en lugar del Listado 9-5:</target>
        </trans-unit>
        <trans-unit id="ef238338d4e12acdba68729fda27f2648f9a373c" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of output! The exact output you see might be different depending on your operating system and Rust version. In order to get backtraces with this information, debug symbols must be enabled. Debug symbols are enabled by default when using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo run&lt;/code&gt; without the &lt;code&gt;--release&lt;/code&gt; flag, as we have here.</source>
          <target state="translated">&amp;iexcl;Eso es mucho rendimiento! La salida exacta que ve puede ser diferente seg&amp;uacute;n su sistema operativo y la versi&amp;oacute;n de Rust. Para obtener trazas con esta informaci&amp;oacute;n, los s&amp;iacute;mbolos de depuraci&amp;oacute;n deben estar habilitados. Los s&amp;iacute;mbolos de depuraci&amp;oacute;n est&amp;aacute;n habilitados de forma predeterminada cuando se usa &lt;code&gt;cargo build&lt;/code&gt; o &lt;code&gt;cargo run&lt;/code&gt; sin la bandera &lt;code&gt;--release&lt;/code&gt; , como tenemos aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="1b9244a451d65d27f90f013b616e273e2c23a8a2" translate="yes" xml:space="preserve">
          <source>That's it! Let's dig into iterators.</source>
          <target state="translated">¡Eso es! Excavemos en los iteradores.</target>
        </trans-unit>
        <trans-unit id="061168032f743f39ddf71cf9c7a9d9f5d6f181f3" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="translated">El uso &quot;predeterminado&quot; de este tipo como cola es usar &lt;a href=&quot;#method.push_back&quot;&gt; &lt;code&gt;push_back&lt;/code&gt; &lt;/a&gt; para agregar a la cola y &lt;a href=&quot;#method.pop_front&quot;&gt; &lt;code&gt;pop_front&lt;/code&gt; &lt;/a&gt; para eliminar de la cola. &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; er&lt;/a&gt; y &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; push en la parte posterior de esta manera, y la iteraci&amp;oacute;n sobre &lt;code&gt;VecDeque&lt;/code&gt; va de adelante hacia atr&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="e1996b7a38e8030e5ba09e25339c72996ff81148" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;../struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;../struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;../struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8660a906a07f3cb76ce3714efc3b35a643f54a" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cb9e838bce9598fdfd4c3684f101808c1294f8" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section in Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f389fc23a4edc2c2a963efce47f9899bcc8519" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section of Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="translated">La secci&amp;oacute;n &quot;Tiempos de vida avanzados&quot; del Cap&amp;iacute;tulo 19 se elimin&amp;oacute; porque las mejoras del compilador han hecho que las construcciones en esa secci&amp;oacute;n sean a&amp;uacute;n m&amp;aacute;s raras.</target>
        </trans-unit>
        <trans-unit id="f99557dc0a8fdf7a63f0792d647f548b4ff6f7ab" translate="yes" xml:space="preserve">
          <source>The 128-bit signed integer type.</source>
          <target state="translated">El tipo entero firmado de 128 bits.</target>
        </trans-unit>
        <trans-unit id="2ecb830f3b64176d279185c7c171382698dc346b" translate="yes" xml:space="preserve">
          <source>The 128-bit unsigned integer type.</source>
          <target state="translated">El tipo entero sin signo de 128 bits.</target>
        </trans-unit>
        <trans-unit id="024e734140c83218cfd913643692a04c708db5ec" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer type.</source>
          <target state="translated">El tipo entero firmado de 16 bits.</target>
        </trans-unit>
        <trans-unit id="c45d15aa8a84f450baba97f342935672e6fa7c43" translate="yes" xml:space="preserve">
          <source>The 16-bit unsigned integer type.</source>
          <target state="translated">El tipo entero de 16 bits sin signo.</target>
        </trans-unit>
        <trans-unit id="fca5433f25a52ee7287767b1930704d918391065" translate="yes" xml:space="preserve">
          <source>The 2015 edition does not allow use declarations to reference the &lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;extern prelude&lt;/a&gt;. Thus &lt;a href=&quot;extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; declarations are still required in 2015 to reference an external crate in a use declaration. Beginning with the 2018 edition, use declarations can specify an external crate dependency the same way &lt;code&gt;extern crate&lt;/code&gt; can.</source>
          <target state="translated">La edici&amp;oacute;n de 2015 no permite que las declaraciones de uso hagan referencia al &lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;preludio externo&lt;/a&gt; . Por lo tanto, en 2015 todav&amp;iacute;a se requieren declaraciones de &lt;a href=&quot;extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt; externa para hacer referencia a una caja externa en una declaraci&amp;oacute;n de uso. A partir de la edici&amp;oacute;n 2018, las declaraciones de uso pueden especificar una dependencia de caja externa de la misma manera que puede &lt;code&gt;extern crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6d857578ac6c78bfa58339fa5a83d29b7a47348" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This iteration of the book contains a number of changes to reflect those improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b6de1c048ad3b08c5d50eb1e62ebf661747fc3" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This printing of the book contains a number of changes to reflect those improvements:</source>
          <target state="translated">La edición 2018 del lenguaje Rust incluye una serie de mejoras que hacen que Rust sea más ergonómico y fácil de aprender.Esta impresión del libro contiene una serie de cambios para reflejar esas mejoras:</target>
        </trans-unit>
        <trans-unit id="2c35b45536addab0f127b7ef2a73381bf5aab740" translate="yes" xml:space="preserve">
          <source>The 32-bit floating point type.</source>
          <target state="translated">El tipo de punto flotante de 32 bits.</target>
        </trans-unit>
        <trans-unit id="ede6acb001e744d94e80e43f20515bed53288286" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer type.</source>
          <target state="translated">El tipo entero firmado de 32 bits.</target>
        </trans-unit>
        <trans-unit id="a9e99a82ec2d26441031e5f8781a5ebb65a83e0e" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer type.</source>
          <target state="translated">El tipo entero de 32 bits sin signo.</target>
        </trans-unit>
        <trans-unit id="13cb697c6b75c7757e9c51749eb9c614ddc9a70f" translate="yes" xml:space="preserve">
          <source>The 64-bit floating point type.</source>
          <target state="translated">El tipo de punto flotante de 64 bits.</target>
        </trans-unit>
        <trans-unit id="748e7d28f53e7a36937bb25af3f1a76e6a491ad6" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer type.</source>
          <target state="translated">El tipo entero firmado de 64 bits.</target>
        </trans-unit>
        <trans-unit id="25aeddd62dc36790a2166200538648d83779c0d0" translate="yes" xml:space="preserve">
          <source>The 64-bit unsigned integer type.</source>
          <target state="translated">El tipo entero sin signo de 64 bits.</target>
        </trans-unit>
        <trans-unit id="0825a8c90a6add467ca53950b645a26af9033007" translate="yes" xml:space="preserve">
          <source>The 8-bit signed integer type.</source>
          <target state="translated">El tipo entero de 8 bits firmado.</target>
        </trans-unit>
        <trans-unit id="6d1f46b751b47e95357a0c40c6e78729c3531e1e" translate="yes" xml:space="preserve">
          <source>The 8-bit unsigned integer type.</source>
          <target state="translated">El tipo entero de 8 bits sin signo.</target>
        </trans-unit>
        <trans-unit id="b568b58db2fe5b477d28998d21858de250eecb32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.clone&quot;&gt;&lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt;&lt;/a&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">La sintaxis &lt;a href=&quot;#method.clone&quot;&gt; &lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt; &lt;/a&gt; es la m&amp;aacute;s idiom&amp;aacute;tica porque transmite m&amp;aacute;s expl&amp;iacute;citamente el significado del c&amp;oacute;digo. En el ejemplo anterior, esta sintaxis facilita ver que este c&amp;oacute;digo est&amp;aacute; creando una nueva referencia en lugar de copiar todo el contenido de foo.</target>
        </trans-unit>
        <trans-unit id="fd0354b8e891bd703f8ef8a8ce8547a17dc2e4cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="translated">La &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo se conectar&amp;aacute; el z&amp;oacute;calo para un par.</target>
        </trans-unit>
        <trans-unit id="de66ae551d77056e5d10cff2c3fd9dbcc9b63e6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect this socket to a remote address. This method will fail if the socket is not connected.</source>
          <target state="translated">La &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo conectar este conector a una direcci&amp;oacute;n remota. Este m&amp;eacute;todo fallar&amp;aacute; si el enchufe no est&amp;aacute; conectado.</target>
        </trans-unit>
        <trans-unit id="3822ea1855bf914e5a814986732fc459619fc61c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; puede emular &lt;code&gt;truncate&lt;/code&gt; , pero hace que los elementos en exceso se devuelvan en lugar de eliminarlos.</target>
        </trans-unit>
        <trans-unit id="a9d6dbd0eeefdb718b7113fea8088d62bd58b0d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; tiene una implementaci&amp;oacute;n predeterminada, por lo que normalmente no deber&amp;iacute;a implementarlo. Sin embargo, es posible que pueda proporcionar una implementaci&amp;oacute;n de mayor rendimiento que la predeterminada, por lo que en este caso tiene sentido anularla.</target>
        </trans-unit>
        <trans-unit id="dade93dc3cf6b97db5474305c3207f7c692d153c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="translated">El adaptador de &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; a&lt;/a&gt; es muy &amp;uacute;til, pero solo cuando el argumento de cierre produce valores. Si en su lugar produce un iterador, hay una capa adicional de indirecci&amp;oacute;n. &lt;code&gt;flat_map()&lt;/code&gt; eliminar&amp;aacute; esta capa adicional por s&amp;iacute; solo.</target>
        </trans-unit>
        <trans-unit id="7a52c1262c15b7898ef7ba52e5c11aa28470cc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="translated">El &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo realmente comprobar&amp;aacute; que el &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; no tenga 0 bytes en el medio y devolver&amp;aacute; un error si encuentra uno.</target>
        </trans-unit>
        <trans-unit id="156348d96d775ff156fee076f0f98b0084e3469d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; se puede utilizar para enviar datos a la direcci&amp;oacute;n especificada. &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; solo recibir&amp;aacute;n datos de esa direcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1ad11576c65e9334d7573beaf36142b4de74e09c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b3d78fe45feec8a5741e2a3ac93f1ed3a19d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; es &amp;uacute;til para adaptadores y b&amp;uacute;feres expl&amp;iacute;citos para garantizar que todos los datos almacenados en b&amp;uacute;fer se hayan enviado al 'sumidero verdadero'.</target>
        </trans-unit>
        <trans-unit id="8a62cb575b08d38c732e1bba9328976a264fdb19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; intentar&amp;aacute; escribir algunos datos en el objeto y devolver&amp;aacute; cu&amp;aacute;ntos bytes se escribieron correctamente.</target>
        </trans-unit>
        <trans-unit id="8fcdedc3c9e84c7fa96e2530650c1bc070bc790b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt;&lt;code&gt;async move&lt;/code&gt; block&lt;/a&gt; in the body captures all function parameters, including those that are unused or bound to a &lt;code&gt;_&lt;/code&gt; pattern. This ensures that function parameters are dropped in the same order as they would be if the function were not async, except that the drop occurs when the returned future has been fully awaited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78f52a30365dea52628c4ade488db0345ffa3ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; macros are identical to &lt;a href=&quot;../macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, respectively, except they emit their output to stderr.</source>
          <target state="translated">&amp;iexcl;El &lt;a href=&quot;../macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt;y &lt;a href=&quot;../macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt;&amp;iexcl;las macros son id&amp;eacute;nticas a las de &lt;a href=&quot;../macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;y &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;, respectivamente, excepto que emiten su salida a stderr.</target>
        </trans-unit>
        <trans-unit id="15b30e899910805c24344f039598ed4f0cfd76f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; macro is intended to be familiar to those coming from C's &lt;code&gt;printf&lt;/code&gt;/&lt;code&gt;fprintf&lt;/code&gt; functions or Python's &lt;code&gt;str.format&lt;/code&gt; function.</source>
          <target state="translated">&amp;iexcl;El &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;macro est&amp;aacute; destinada a ser familiar para los que vienen de de C &lt;code&gt;printf&lt;/code&gt; / &lt;code&gt;fprintf&lt;/code&gt; funciones o de Python &lt;code&gt;str.format&lt;/code&gt; funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5d076b83cf0704732b7b9eb8c03c4bfbdeaffd03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da9aedd3913426ccb3cbeae460a449f6f18fc2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="translated">El &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;macro crear&amp;aacute; de forma segura una instancia de esta estructura. La macro valida la cadena de formato en tiempo de compilaci&amp;oacute;n para que el uso de las funciones de &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; o se&lt;/a&gt; pueda realizar de forma segura.</target>
        </trans-unit>
        <trans-unit id="d6220f58fc37e6b8b0afc01735948c86469d85de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec!&lt;/code&gt;&lt;/a&gt; macro is provided to make initialization more convenient:</source>
          <target state="translated">&amp;iexcl;El &lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec!&lt;/code&gt; &lt;/a&gt;Se proporciona una macro para que la inicializaci&amp;oacute;n sea m&amp;aacute;s conveniente:</target>
        </trans-unit>
        <trans-unit id="d6015eed300b7de406449e79cfdc1aa2f387182e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/a&gt; works as usual and import the macro names into the macro-use prelude.</source>
          <target state="translated">El &lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;macro_use&lt;/code&gt; funciona como de costumbre e importa los nombres de las macros en el preludio del uso de macros.</target>
        </trans-unit>
        <trans-unit id="3ee79a0bb859db06f06e2ddc850e161230b3ef29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; constraint is because the closure will need to be passed &lt;em&gt;by value&lt;/em&gt; from the thread where it is spawned to the new thread. Its return value will need to be passed from the new thread to the thread where it is &lt;code&gt;join&lt;/code&gt;ed. As a reminder, the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; marker trait expresses that it is safe to be passed from thread to thread. &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; expresses that it is safe to have a reference be passed from thread to thread.</source>
          <target state="translated">La restricci&amp;oacute;n de &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; se debe a que el cierre deber&amp;aacute; pasarse &lt;em&gt;por valor&lt;/em&gt; desde el hilo donde se genera al nuevo hilo. Su valor de retorno deber&amp;aacute; pasarse del nuevo hilo al hilo donde se &lt;code&gt;join&lt;/code&gt; . Como recordatorio, el rasgo &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; marcador expresa que es seguro pasar de un hilo a otro. &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; expresa que es seguro que se pase una referencia de un hilo a otro.</target>
        </trans-unit>
        <trans-unit id="9c69caf5cbc6ae5668ac370ea6aa28c0348ce679" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; to an associated item is any path to the implementing type, followed by the associated item's identifier as the final path component.</source>
          <target state="translated">La &lt;a href=&quot;../paths&quot;&gt;ruta&lt;/a&gt; a un elemento asociado es cualquier ruta al tipo de implementaci&amp;oacute;n, seguida por el identificador del elemento asociado como el componente de ruta final.</target>
        </trans-unit>
        <trans-unit id="1dedee4df1c883aa9e7db0132fc24154a02120fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt; type is used instead to prevent moves through the type system. Pointers &lt;code&gt;P&amp;lt;T&amp;gt;&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper can't be moved out of. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin&lt;/code&gt; module&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c6d762c492370e5bdcdefde3e4fc5cf31a9b6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/items/unions&quot;&gt;Rust equivalent of a C-style union&lt;/a&gt;.</source>
          <target state="translated">El &lt;a href=&quot;../reference/items/unions&quot;&gt;equivalente del moho de una uni&amp;oacute;n C-estilo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86cbe7690d77cc63e21bdfee9a1e9528110648c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/types/trait-object&quot;&gt;Reference&lt;/a&gt; has more information about trait objects, their limitations and the differences between editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6f479476a4a73b474dd9bb423ce981f3c3f329" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of this result indicates that the primitive was not poisoned, and the &lt;code&gt;Guard&lt;/code&gt; is contained within. The &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant indicates that the primitive was poisoned. Note that the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant &lt;em&gt;also&lt;/em&gt; carries the associated guard, and it can be acquired through the &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">La variante &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; de este resultado indica que el primitivo no fue envenenado y la &lt;code&gt;Guard&lt;/code&gt; ia est&amp;aacute; contenida dentro. La variante &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; indica que el primitivo fue envenenado. Tenga en cuenta que la variante &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;&lt;em&gt; tambi&amp;eacute;n&lt;/em&gt; lleva la protecci&amp;oacute;n asociada y se puede adquirir a trav&amp;eacute;s del m&amp;eacute;todo &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79df059e358a4241ab821f0fe6e918cdbba9f208" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait is a supertrait of &lt;code&gt;Copy&lt;/code&gt;, so it also needs compiler generated implementations. It is implemented by the compiler for the following types:</source>
          <target state="translated">El rasgo de &lt;a href=&quot;../std/clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; es un superretrato de &lt;code&gt;Copy&lt;/code&gt; , por lo que tambi&amp;eacute;n necesita implementaciones generadas por el compilador. Lo implementa el compilador para los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="90ba5aefe61d573b28b76d88a60eabe0413d5c63" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeefbcb93aa9d7429fc3ba4a3a1ce956f75d5cfc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment. &lt;code&gt;Copy&lt;/code&gt; cannot be implemented for types which implement &lt;code&gt;Drop&lt;/code&gt;, or which have fields that are not &lt;code&gt;Copy&lt;/code&gt;. &lt;code&gt;Copy&lt;/code&gt; is implemented by the compiler for</source>
          <target state="translated">El rasgo &lt;a href=&quot;../std/marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; cambia la sem&amp;aacute;ntica de un tipo que lo implementa. Los valores cuyo tipo implementa &lt;code&gt;Copy&lt;/code&gt; se copian en lugar de moverse en la asignaci&amp;oacute;n. &lt;code&gt;Copy&lt;/code&gt; no se puede implementar para tipos que implementan &lt;code&gt;Drop&lt;/code&gt; o que tienen campos que no son &lt;code&gt;Copy&lt;/code&gt; . &lt;code&gt;Copy&lt;/code&gt; compilador implementa la copia para</target>
        </trans-unit>
        <trans-unit id="0e14c3a80117b6ea49358dfdccbdf20f1c51a89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to send from one thread to another.</source>
          <target state="translated">El rasgo &lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; indica que un valor de este tipo es seguro para enviar de un hilo a otro.</target>
        </trans-unit>
        <trans-unit id="974ae2ba65e9e772d3c59ca8b9d11adff4f54e38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd79bdd63f1cb15136ac63579db2daa51f56797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="translated">Los rasgos &lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt; &lt;code&gt;RefUnwindSafe&lt;/code&gt; &lt;/a&gt; son &lt;em&gt;rasgos autom&amp;aacute;ticos&lt;/em&gt; . Los rasgos autom&amp;aacute;ticos tienen propiedades especiales.</target>
        </trans-unit>
        <trans-unit id="292a56639a943e7a95497bb0cf72fbedd7460764" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait indicates that the size of this type is known at compile-time; that is, it's not a &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;. &lt;a href=&quot;types/parameters&quot;&gt;Type parameters&lt;/a&gt; are &lt;code&gt;Sized&lt;/code&gt; by default. &lt;code&gt;Sized&lt;/code&gt; is always implemented automatically by the compiler, not by &lt;a href=&quot;items/implementations&quot;&gt;implementation items&lt;/a&gt;.</source>
          <target state="translated">El rasgo &lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; indica que el tama&amp;ntilde;o de este tipo se conoce en tiempo de compilaci&amp;oacute;n; es decir, no es un &lt;a href=&quot;dynamically-sized-types&quot;&gt;tipo de tama&amp;ntilde;o din&amp;aacute;mico&lt;/a&gt; . &lt;a href=&quot;types/parameters&quot;&gt;Los par&amp;aacute;metros de tipo&lt;/a&gt; tienen un &lt;code&gt;Sized&lt;/code&gt; predeterminado. &lt;code&gt;Sized&lt;/code&gt; siempre es implementado autom&amp;aacute;ticamente por el compilador, no por &lt;a href=&quot;items/implementations&quot;&gt;elementos de implementaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbed2a3ef9298a62094e0bee99c5f47d5609e39c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to share between multiple threads. This trait must be implemented for all types used in immutable &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;.</source>
          <target state="translated">El rasgo de &lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; indica que un valor de este tipo es seguro para compartir entre varios subprocesos. Este rasgo debe implementarse para todos los tipos utilizados en &lt;a href=&quot;items/static-items&quot;&gt;elementos &lt;/a&gt; &lt;code&gt;static&lt;/code&gt; inmutables .</target>
        </trans-unit>
        <trans-unit id="0bd4f0026aa17cd077440ff412c90263cb35c5bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; trait provides a &lt;a href=&quot;destructors&quot;&gt;destructor&lt;/a&gt;, to be run whenever a value of this type is to be destroyed.</source>
          <target state="translated">El rasgo &lt;a href=&quot;../std/ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; proporciona un &lt;a href=&quot;destructors&quot;&gt;destructor&lt;/a&gt; , que se ejecutar&amp;aacute; siempre que se destruya un valor de este tipo.</target>
        </trans-unit>
        <trans-unit id="767089bdc12afceff4b8eaec0f0a325f5d336e5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt; method on strings&lt;/a&gt; parses a string into some kind of number. Because this method can parse a variety of number types, we need to tell Rust the exact number type we want by using &lt;code&gt;let guess: u32&lt;/code&gt;. The colon (&lt;code&gt;:&lt;/code&gt;) after &lt;code&gt;guess&lt;/code&gt; tells Rust we&amp;rsquo;ll annotate the variable&amp;rsquo;s type. Rust has a few built-in number types; the &lt;code&gt;u32&lt;/code&gt; seen here is an unsigned, 32-bit integer. It&amp;rsquo;s a good default choice for a small positive number. You&amp;rsquo;ll learn about other number types in Chapter 3. Additionally, the &lt;code&gt;u32&lt;/code&gt; annotation in this example program and the comparison with &lt;code&gt;secret_number&lt;/code&gt; means that Rust will infer that &lt;code&gt;secret_number&lt;/code&gt; should be a &lt;code&gt;u32&lt;/code&gt; as well. So now the comparison will be between two values of the same type!</source>
          <target state="translated">El &lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;m&amp;eacute;todo de &lt;/a&gt; &lt;code&gt;parse&lt;/code&gt; en cadenas analiza una cadena en alg&amp;uacute;n tipo de n&amp;uacute;mero. Debido a que este m&amp;eacute;todo puede analizar una variedad de tipos de n&amp;uacute;meros, necesitamos decirle a Rust el tipo de n&amp;uacute;mero exacto que queremos usando &lt;code&gt;let guess: u32&lt;/code&gt; . Los dos puntos ( &lt;code&gt;:&lt;/code&gt; ) despu&amp;eacute;s &lt;code&gt;guess&lt;/code&gt; dice Rust vamos a anotamos tipo de la variable. Rust tiene algunos tipos de n&amp;uacute;meros integrados; el &lt;code&gt;u32&lt;/code&gt; que se ve aqu&amp;iacute; es un entero de 32 bits sin signo. Es una buena opci&amp;oacute;n predeterminada para un n&amp;uacute;mero positivo peque&amp;ntilde;o. Aprender&amp;aacute; sobre otros tipos de n&amp;uacute;meros en el Cap&amp;iacute;tulo 3. Adem&amp;aacute;s, la anotaci&amp;oacute;n &lt;code&gt;u32&lt;/code&gt; en este programa de ejemplo y la comparaci&amp;oacute;n con &lt;code&gt;secret_number&lt;/code&gt; significa que Rust &lt;code&gt;secret_number&lt;/code&gt; que n&amp;uacute;mero_secreto debe ser un &lt;code&gt;u32&lt;/code&gt; tambi&amp;eacute;n. &amp;iexcl;As&amp;iacute; que ahora la comparaci&amp;oacute;n ser&amp;aacute; entre dos valores del mismo tipo!</target>
        </trans-unit>
        <trans-unit id="c4baaa152505c4dd10d0a8afc8811ba9994e6d24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a13bea0cade14eaae143cc58b002085ddc4bf19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac19fe7126085cad17eb0b418fa395ae25fa16f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">El tipo &lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; &lt;/a&gt; proporcionado por &lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt; representa un error que puede ocurrir al convertir un segmento de &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; sa un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; . En este sentido, es an&amp;aacute;logo a &lt;code&gt;FromUtf8Error&lt;/code&gt; , y puede obtener uno de &lt;code&gt;FromUtf8Error&lt;/code&gt; a trav&amp;eacute;s del m&amp;eacute;todo &lt;a href=&quot;#method.utf8_error&quot;&gt; &lt;code&gt;utf8_error&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb67cacdd201c958a0c7d558837d2a8082fe699" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="translated">El tipo &lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; &lt;/a&gt; proporcionado por &lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt; representa un error que puede ocurrir al convertir un segmento de &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; sa un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; . En este sentido, es an&amp;aacute;logo a &lt;code&gt;FromUtf8Error&lt;/code&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s detalles sobre su uso.</target>
        </trans-unit>
        <trans-unit id="239e6c53cbac59da452aab2dc0d25e7124ea430b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;struct.fromutf8error#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d50f09079feb56741d3701cde3c9928a1a6e9ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddda8120a353c19c1143b9fe623d73b4dcc57ac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; function consumes a box and returns the raw pointer. It doesn't destroy &lt;code&gt;T&lt;/code&gt; or deallocate any memory.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; consume un cuadro y devuelve el puntero sin procesar. No destruye &lt;code&gt;T&lt;/code&gt; ni desasigna ning&amp;uacute;n recuerdo.</target>
        </trans-unit>
        <trans-unit id="f8812873ebf26389aa2891235cb5791e408b7568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;collections/index&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other typical collection types, including the common &lt;a href=&quot;collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;a href=&quot;collections/index&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; define mapas, conjuntos, listas vinculadas y otros tipos de colecciones t&amp;iacute;picas, incluido el &lt;a href=&quot;collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt; com&amp;uacute;n .</target>
        </trans-unit>
        <trans-unit id="a000df2416eeaceaee8b63bcc4f4d96683535efe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt; attributes are active. The &lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; attribute is inert when compiling for tests and active otherwise. &lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;Attribute macros&lt;/a&gt; are active. All other attributes are inert.</source>
          <target state="translated">Los atributos &lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt; &lt;code&gt;cfg_attr&lt;/code&gt; &lt;/a&gt; est&amp;aacute;n activos. El atributo de &lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; es inerte cuando se compila para pruebas y activo en caso contrario. &lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;Las macros de atributos&lt;/a&gt; est&amp;aacute;n activas. Todos los dem&amp;aacute;s atributos son inertes.</target>
        </trans-unit>
        <trans-unit id="6870dee47d3fe5b85f2f338b73c3f7cce4094df6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; except for raw pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a453b12ad8603a837d27104bf0cf09312a2b66" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; produces a place which can be moved from. This means that the &lt;code&gt;*&lt;/code&gt; operator and the destructor of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; are built-in to the language.</source>
          <target state="translated">El &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;operador de desreferencia&lt;/a&gt; para &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; produce un lugar desde el que se puede mover. Esto significa que el operador &lt;code&gt;*&lt;/code&gt; y el destructor de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute;n integrados en el idioma.</target>
        </trans-unit>
        <trans-unit id="69b248ba9e2f044518c42fe197df63cfa4b2abff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt;.</source>
          <target state="translated">El &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;operador de desreferencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecbb9300a5b716ea6923d97c4a33bcc05beabca8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function is available even for threads not spawned by the APIs of this module.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;fn.current&quot;&gt; &lt;code&gt;thread::current&lt;/code&gt; &lt;/a&gt; est&amp;aacute; disponible incluso para los subprocesos no generados por las API de este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="83c879af00d7b8c642fb06e560ce31570f391a07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function provides an iterator over the bytes of an escaped version of the character given.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;fn.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt; proporciona un iterador sobre los bytes de una versi&amp;oacute;n de escape del car&amp;aacute;cter dado.</target>
        </trans-unit>
        <trans-unit id="04034ef7d1f4bac81675e414f3f0f4340588ab73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;thread::park&lt;/code&gt;&lt;/a&gt; function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return &lt;em&gt;spuriously&lt;/em&gt;, without consuming the token. &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;thread::park_timeout&lt;/code&gt;&lt;/a&gt; does the same, but allows specifying a maximum time to block the thread for.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;thread::park&lt;/code&gt; &lt;/a&gt; bloquea el hilo actual a menos que o hasta que el token est&amp;eacute; disponible para su identificador de hilo, momento en el que consume at&amp;oacute;micamente el token. Tambi&amp;eacute;n puede volver de forma &lt;em&gt;falsa&lt;/em&gt; , sin consumir el token. &lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;thread::park_timeout&lt;/code&gt; &lt;/a&gt; hace lo mismo, pero permite especificar un tiempo m&amp;aacute;ximo para bloquear el hilo.</target>
        </trans-unit>
        <trans-unit id="010183e81cf43fb24dc3ff708d62a66ab46d9a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; free function uses a &lt;code&gt;Builder&lt;/code&gt; with default configuration and &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;s its return value.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; free usa un &lt;code&gt;Builder&lt;/code&gt; con configuraci&amp;oacute;n predeterminada y &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; su valor de retorno.</target>
        </trans-unit>
        <trans-unit id="29d01ae14bfbd0d95900d7de260d830e6b2aebdb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of a &lt;code&gt;match&lt;/code&gt; expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the &lt;code&gt;match&lt;/code&gt; expression. For example, the temporary for &lt;code&gt;1&lt;/code&gt; in &lt;code&gt;match 1 { ref mut z =&amp;gt; z };&lt;/code&gt; lives until the end of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d631316da22e8f49a59e622d46e415aca63cb44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of an &lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="translated">El &lt;a href=&quot;glossary#scrutinee&quot;&gt;escrutinio&lt;/a&gt; de una expresi&amp;oacute;n &lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;expressions/match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f60d04280a375c73571ef4d8073dd6fd2b866e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomicon&lt;/a&gt; has additional documentation.</source>
          <target state="translated">El &lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomicon&lt;/a&gt; tiene documentaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="234fa73a8f6dcc88ca3eeed24db16797666a2694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt; contains motivations and more details.</source>
          <target state="translated">El &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt; contiene motivaciones y m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="b6a13e231d1887805079fed3345d62d70fa98ffc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute can be used on a module to disable prelude lookups within that module.</source>
          <target state="translated">El atributo &lt;a href=&quot;modules#prelude-items&quot;&gt; &lt;code&gt;no_implicit_prelude&lt;/code&gt; &lt;/a&gt; se puede utilizar en un m&amp;oacute;dulo para deshabilitar las b&amp;uacute;squedas de preludio dentro de ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="2d090eed4aa4b11f0c7d0fffa892207e5f74b95a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;option/index&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/index&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling types, &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;iter/index&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines Rust's iterator trait, &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to access collections.</source>
          <target state="translated">Los m&amp;oacute;dulos de &lt;a href=&quot;option/index&quot;&gt; &lt;code&gt;option&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;result/index&quot;&gt; &lt;code&gt;result&lt;/code&gt; ado&lt;/a&gt; definen tipos opcionales y de manejo de errores, &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; . El m&amp;oacute;dulo &lt;a href=&quot;iter/index&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; define el rasgo iterador de Rust, &lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , que trabaja con el bucle &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; para acceder a las colecciones.</target>
        </trans-unit>
        <trans-unit id="a5d9a354e8b0f07a3115dc9b0844a83e58a8610e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9260d9d3256bee11715c7bab554254f578e52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bee548c1faeb9c0868a59d1b0359e0916d54967" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt; se puede utilizar para crear un puntero &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; no sea propietario . Un puntero &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; se puede &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; a un &lt;code&gt;Arc&lt;/code&gt; o , pero esto devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; si el valor ya se ha eliminado.</target>
        </trans-unit>
        <trans-unit id="74bc0ed50e554fb672c29105c76cd20026688a4b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the value) alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c3ecdf0be1261908d0f10ca942b75ee9286aef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; instance can be created with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">La instancia de &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt; se puede crear con &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;macro.</target>
        </trans-unit>
        <trans-unit id="fa75ef55ee98f7d19f2ace1042e87faf9ee8ae65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt; struct wraps a writer and buffers its output. But it only does this batched write when it goes out of scope, or when the internal buffer is full. Sometimes, you'd prefer to write each line as it's completed, rather than the entire buffer at once. Enter &lt;code&gt;LineWriter&lt;/code&gt;. It does exactly that.</source>
          <target state="translated">La estructura &lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt; envuelve un escritor y almacena en b&amp;uacute;fer su salida. Pero solo hace esta escritura por lotes cuando sale del alcance o cuando el b&amp;uacute;fer interno est&amp;aacute; lleno. A veces, preferir&amp;iacute;a escribir cada l&amp;iacute;nea a medida que se completa, en lugar de escribir todo el b&amp;uacute;fer a la vez. Ingrese &lt;code&gt;LineWriter&lt;/code&gt; . Hace exactamente eso.</target>
        </trans-unit>
        <trans-unit id="a07405d582facf4ae9638d6c46ccf83d378ca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; method will take ownership of the builder and create an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to the thread handle with the given configuration.</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; tomar&amp;aacute; posesi&amp;oacute;n del constructor y crear&amp;aacute; un &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; en el identificador del hilo con la configuraci&amp;oacute;n dada.</target>
        </trans-unit>
        <trans-unit id="8461a34249fb23d4197f5b2441105518f99e167b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct is used to configure and spawn processes:</source>
          <target state="translated">La estructura &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; se utiliza para configurar y generar procesos:</target>
        </trans-unit>
        <trans-unit id="c0f682c8845fc1182cef69275c8073a32be2d0f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command#method.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; of a child process can be configured by passing an &lt;a href=&quot;struct.stdio&quot;&gt;&lt;code&gt;Stdio&lt;/code&gt;&lt;/a&gt; to the corresponding method on &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;. Once spawned, they can be accessed from the &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;. For example, piping output from one command into another command can be done like so:</source>
          <target state="translated">El &lt;a href=&quot;struct.command#method.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.command#method.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.command#method.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; de un proceso hijo se pueden configurar pasando un &lt;a href=&quot;struct.stdio&quot;&gt; &lt;code&gt;Stdio&lt;/code&gt; &lt;/a&gt; al m&amp;eacute;todo correspondiente en &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; . Una vez engendrados, se puede acceder a ellos desde el &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; . Por ejemplo, canalizar la salida de un comando a otro comando se puede hacer as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f9ad904c74c4288c252921bb9ae74bd23e865305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979c5c1602643a6a3cebe7ffbfac71410fb43889" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;thread::Result&lt;/code&gt;&lt;/a&gt; containing &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; of the final value produced by the child thread, or &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; of the value given to a call to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if the child panicked.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; devuelve un &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;thread::Result&lt;/code&gt; &lt;/a&gt; contiene &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; del valor final producido por el hilo hijo, o &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; del valor dado a una llamada al &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;si el ni&amp;ntilde;o entr&amp;oacute; en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="d70df5ac1306fbf7451739c8b7b5cbb316412dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method yields a reference to the contained value which cannot be sent across threads or escape the given closure.</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; produce una referencia al valor contenido que no se puede enviar a trav&amp;eacute;s de subprocesos o escapar del cierre dado.</target>
        </trans-unit>
        <trans-unit id="4cdf73c1055626ea58f2e6c5956631d7c37626c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt; se puede utilizar para crear un puntero &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; no sea propietario . Un puntero &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; se puede &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; a un &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; , pero esto devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; si el valor ya se ha eliminado.</target>
        </trans-unit>
        <trans-unit id="bcfdea4875bc006b185727ffa377cb6c800ff1eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the inner value) alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673675ebe57e0604b8f52dd76cd89f3cf84af682" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; operation can only fail if the sending half of a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) is disconnected, implying that no further messages will ever be received.</source>
          <target state="translated">La operaci&amp;oacute;n &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; solo puede fallar si la mitad de env&amp;iacute;o de un &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; (o &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; desconectada, lo que implica que no se recibir&amp;aacute;n m&amp;aacute;s mensajes.</target>
        </trans-unit>
        <trans-unit id="2096b737ddfebc05d46f568e296a81f0a3d0197e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">El &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; se puede clonar para &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; al mismo canal varias veces, pero solo se admite un &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d38fd997ec90eab994427a1fbc1ca66e988ed96b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">El &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; se puede clonar para &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; al mismo canal varias veces, pero solo se admite un &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7001293def1e95a9d6c40ad63bf180d03eb64fd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; atomically makes the token available if it wasn't already. Because the token is initially absent, &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; will result in the second call returning immediately.</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; en un &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; hace que el token est&amp;eacute; disponible de forma at&amp;oacute;mica si a&amp;uacute;n no lo estaba. Debido a que el token est&amp;aacute; inicialmente ausente, &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; seguido de &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; dar&amp;aacute; como resultado que la segunda llamada regrese inmediatamente.</target>
        </trans-unit>
        <trans-unit id="3b63b1ad0bef3b06d878599f3be015ecfe5404bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1599d30320e03334b98613759c0cb03ef5b8af44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53484ac76a42814fdd6d0152dc58d8216dd587e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6d0b5a4d7abf2551cbce00a21d08c3b9b0ea9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;thread/index&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;sync/index&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; contains further primitive shared memory types, including &lt;a href=&quot;sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sync/mpsc/index&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;a href=&quot;thread/index&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt; contiene las abstracciones de subprocesos de Rust. &lt;a href=&quot;sync/index&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt; contiene otros tipos primitivos de memoria compartida, incluidos &lt;a href=&quot;sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;sync/mpsc/index&quot;&gt; &lt;code&gt;mpsc&lt;/code&gt; &lt;/a&gt; , que contiene los tipos de canal para el paso de mensajes.</target>
        </trans-unit>
        <trans-unit id="49a461a4d2bf3262db6f2402e2172259bf56947f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.asciiext&quot;&gt;&lt;code&gt;AsciiExt&lt;/code&gt;&lt;/a&gt; trait provides methods that allow for character operations that only act on the ASCII subset and leave non-ASCII characters alone.</source>
          <target state="translated">El rasgo &lt;a href=&quot;trait.asciiext&quot;&gt; &lt;code&gt;AsciiExt&lt;/code&gt; &lt;/a&gt; proporciona m&amp;eacute;todos que permiten operaciones de caracteres que solo act&amp;uacute;an en el subconjunto ASCII y dejan los caracteres no ASCII solos.</target>
        </trans-unit>
        <trans-unit id="1a4c8cc0a085c3df1289a22cd8aaec879c0c1b9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.doubleendediterator&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">Los documentos de &lt;a href=&quot;trait.doubleendediterator&quot;&gt;nivel de rasgo&lt;/a&gt; contienen m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="a9baa3ad4d7314655f1af4e53b409fbc088f4b8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method is generally used when errors cross &quot;abstraction boundaries&quot;. If one module must report an error that is caused by an error from a lower-level module, it can allow access to that error via the &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method. This makes it possible for the high-level module to provide its own errors while also revealing some of the implementation for debugging via &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; chains.</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; se utiliza generalmente cuando los errores cruzan los &quot;l&amp;iacute;mites de abstracci&amp;oacute;n&quot;. Si un m&amp;oacute;dulo debe informar un error causado por un error de un m&amp;oacute;dulo de nivel inferior, puede permitir el acceso a ese error a trav&amp;eacute;s del m&amp;eacute;todo de &lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; . Esto hace posible que el m&amp;oacute;dulo de alto nivel proporcione sus propios errores al tiempo que revela parte de la implementaci&amp;oacute;n para la depuraci&amp;oacute;n a trav&amp;eacute;s de cadenas de &lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb97ac2277aef1f78113f1e75546370dbbdba9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8960e05e681fd3c863585eb072cff67079ae758" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; traits are implemented by types that can be invoked like functions. Note that &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt; and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;self&lt;/code&gt;. These correspond to the three kinds of methods that can be invoked on an instance: call-by-reference, call-by-mutable-reference, and call-by-value. The most common use of these traits is to act as bounds to higher-level functions that take functions or closures as arguments.</source>
          <target state="translated">Los rasgos &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; se implementan mediante tipos que se pueden invocar como funciones. Tenga en cuenta que &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; toma &lt;code&gt;&amp;amp;self&lt;/code&gt; , &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; toma &lt;code&gt;&amp;amp;mut self&lt;/code&gt; y &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; toma &lt;code&gt;self&lt;/code&gt; . Estos corresponden a los tres tipos de m&amp;eacute;todos que se pueden invocar en una instancia: llamada por referencia, llamada por referencia mutable y llamada por valor. El uso m&amp;aacute;s com&amp;uacute;n de estos rasgos es actuar como l&amp;iacute;mites a funciones de nivel superior que toman funciones o cierres como argumentos.</target>
        </trans-unit>
        <trans-unit id="c33bacd306c2aa86080fee643cadd9fa3a5a922c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af84d72464a620d276e568d18222de12da4b2fde" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; iterator implements &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;, meaning that you can also &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; backwards:</source>
          <target state="translated">El iterador de &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; a&lt;/a&gt; implementa &lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; , lo que significa que tambi&amp;eacute;n puede &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; ear&lt;/a&gt; hacia atr&amp;aacute;s:</target>
        </trans-unit>
        <trans-unit id="a0672d71e250ee0ec8fcc8dfa66640aade0f2d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits behave like &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, but should be implemented when the conversion can fail.</source>
          <target state="translated">Los rasgos &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; se comportan como &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; , pero deben implementarse cuando la conversi&amp;oacute;n puede fallar.</target>
        </trans-unit>
        <trans-unit id="e376c9d77b7276078629a96e3397aaf50b87d100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa424efe4823f7e6a6edaf5a49990756704380f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75436aa22cb5f73032a0aa74018fe133c992dee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;type-layout#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="translated">Las &lt;a href=&quot;type-layout#primitive-representations&quot;&gt;representaciones primitivas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76a754ff1ade7a85d17901c16d28f4fc1a0ec281" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/inferred&quot;&gt;inferred type&lt;/a&gt; which asks the compiler to determine the type.</source>
          <target state="translated">El &lt;a href=&quot;types/inferred&quot;&gt;tipo inferido&lt;/a&gt; que pide al compilador que determine el tipo.</target>
        </trans-unit>
        <trans-unit id="bbc904b6676167d928a315d71b571002efe99186" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/never&quot;&gt;never&lt;/a&gt; type.</source>
          <target state="translated">El tipo &lt;a href=&quot;types/never&quot;&gt;nunca&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2be3f45b2596938280efdad2e1e3c487cd3dd502" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dac89caf1fb6bb25d3f0271f01c85dae090eff" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Only Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="translated">El &lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; El operador solo se puede utilizar en funciones que devuelven &lt;code&gt;Result&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf416e54f0f3d3a2ee8340cdce3195c04f0662bc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; Placeholder</source>
          <target state="translated">El &lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; marcador de posici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="7d36ad4c51a4dc937d643fbbbf54439f451168f2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; Function and Invalid Unicode</source>
          <target state="translated">La funci&amp;oacute;n &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; y Unicode no v&amp;aacute;lido</target>
        </trans-unit>
        <trans-unit id="43afa187f9cf6582feca58fbbf7f12992daae6dc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-automatically_derived-attribute&quot;&gt;automatically_derived&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae32b9d596051c5f8a6c5be151de5b2bd58f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-c-representation&quot;&gt;C&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe7f8f8cbbf771865519c2bb3d21bb5f521d891" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-attribute&quot;&gt;cfg&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572d131266eef7422234c8cd8f4bf975d532a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-macro&quot;&gt;cfg&lt;/code&gt; macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff73ca7cbd9ceded9b08042dee3a7e44286d5879" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg_attr-attribute&quot;&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab454a301e64c91054b75436344fb463ed4e31a" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cold-attribute&quot;&gt;cold&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3918f7c748b8a6de02591e90a158be55e179161" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-crate_name-attribute&quot;&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56779e684809e370ff842b9fd00e8e8533305b15" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-deprecated-attribute&quot;&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d264c9c886b4e7e93efe14011caf84a4cb0f8edc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-export_name-attribute&quot;&gt;export_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64953382ec25ebff3523c686f871b6cac0e50ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-global_allocator-attribute&quot;&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71beea8a8240cee1b864ee8a097da9cb395a0451" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-ignore-attribute&quot;&gt;ignore&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e444fdfbdbbdaea724f409a0908c1ddaf47280" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-inline-attribute&quot;&gt;inline&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f91b9733dfb285998974fd7a3ed63a6997485d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">El rasgo del &lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; y el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo</target>
        </trans-unit>
        <trans-unit id="289229034807d95c3121d3bcf9cb7e25c1ac9ef2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link-attribute&quot;&gt;link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf19b8ac8c37c88b76bf5924f5303e2d1b3cbfc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_name-attribute&quot;&gt;link_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fca57741dda84795b52faabc81edaee2bb29077" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_section-attribute&quot;&gt;link_section&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b70af9354cb75b7660a9b63a471bca4708883" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-macro_use-attribute&quot;&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479b4a692bc6c43f38d4737f51dec06b4e143a16" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; Control Flow Operator</source>
          <target state="translated">El operador de flujo de control de &lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3764cbd865c70d966aece7af300dfa7f637fe423" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-must_use-attribute&quot;&gt;must_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f1e16c1f0bc3e100253f9a6db177a6d4101ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_builtins-attribute&quot;&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc45c323650c2f34949e4b642c8e1bc1d4214794" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_link-attribute&quot;&gt;no_link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12971ae998085805bad575f162d256452bcc1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_main-attribute&quot;&gt;no_main&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f55be277b4754e64848202241f85fe626641b3d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_mangle-attribute&quot;&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5417fc07a4925f25ebbeb5f618a1275243378ced" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; Enum and Its Advantages Over Null Values</source>
          <target state="translated">La &lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; Enum y sus ventajas sobre los valores nulos</target>
        </trans-unit>
        <trans-unit id="456d9c623e0db72560e9d4ff7d18d6a3d51bb4a0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-panic_handler-attribute&quot;&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f2fa5a516f880089540c2827decd01d5a6e7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-path-attribute&quot;&gt;path&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272c0059788508ea23a5913dedfc781999a4329c" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-proc_macro-crate&quot;&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1850ba5995c1ec62eca62cf6b54da74c57b2f08" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-recursion_limit-attribute&quot;&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7debe8457b97e78697481f2ab2a13b2dce10763" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-should_panic-attribute&quot;&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93213a38ad3b67a68894b916ca83c68efaaa5823" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; Type</source>
          <target state="translated">El tipo de &lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fa123d3091c3f529b13b66733146b6cc074b9ee" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-target_feature-attribute&quot;&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec1dda37a4f697fee6a707ed0b667ec2bc1a23e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-test-attribute&quot;&gt;test&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf59ceebdbbaa090bce70ec65f673058503cd1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-track_caller-attribute&quot;&gt;track_caller&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad072e3ed2e5bdacb782947af3c6085d2383d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-transparent-representation&quot;&gt;transparent&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222c253464f70dc2d46508fef9bded38b979180e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-type_length_limit-attribute&quot;&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b350e27ebb9ddb5535abd7bc5f0b158500f6c7ea" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-used-attribute&quot;&gt;used&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b55666424bcbda4791627f5d3c1a25c9fd2797" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-windows_subsystem-attribute&quot;&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844971eb58988950f234035bf3b738d18df15983" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!&lt;/code&gt; type, also called &quot;never&quot;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; El ! tipo, tambi&amp;eacute;n llamado &quot;nunca&quot;.</target>
        </trans-unit>
        <trans-unit id="1959101a4f878a742e6d622df58125da3c9ee8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#![feature]&lt;/code&gt; attribute specified an unknown feature.</source>
          <target state="translated">El atributo &lt;code&gt;#![feature]&lt;/code&gt; especificaba una caracter&amp;iacute;stica desconocida.</target>
        </trans-unit>
        <trans-unit id="6772d2ae0b060a250746d33cd174746c466f1400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation on the tests module tells Rust to compile and run the test code only when you run &lt;code&gt;cargo test&lt;/code&gt;, not when you run &lt;code&gt;cargo build&lt;/code&gt;. This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You&amp;rsquo;ll see that because integration tests go in a different directory, they don&amp;rsquo;t need the &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation. However, because unit tests go in the same files as the code, you&amp;rsquo;ll use &lt;code&gt;#[cfg(test)]&lt;/code&gt; to specify that they shouldn&amp;rsquo;t be included in the compiled result.</source>
          <target state="translated">La anotaci&amp;oacute;n &lt;code&gt;#[cfg(test)]&lt;/code&gt; en el m&amp;oacute;dulo de pruebas le dice a Rust que compile y ejecute el c&amp;oacute;digo de prueba solo cuando ejecute &lt;code&gt;cargo test&lt;/code&gt; , no cuando ejecute &lt;code&gt;cargo build&lt;/code&gt; . Esto ahorra tiempo de compilaci&amp;oacute;n cuando solo desea construir la biblioteca y ahorra espacio en el artefacto compilado resultante porque las pruebas no est&amp;aacute;n incluidas. Ver&amp;aacute; que debido a que las pruebas de integraci&amp;oacute;n van en un directorio diferente, no necesitan la anotaci&amp;oacute;n &lt;code&gt;#[cfg(test)]&lt;/code&gt; . Sin embargo, debido a que las pruebas unitarias van en los mismos archivos que el c&amp;oacute;digo, usar&amp;aacute; &lt;code&gt;#[cfg(test)]&lt;/code&gt; para especificar que no deben incluirse en el resultado compilado.</target>
        </trans-unit>
        <trans-unit id="519f31417527ab16777c33990a8b19270d90ed97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;#[global_allocator]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e73c0e75e8ab048b307c0488b5dbff0af69bd767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; can only be used once in a crate or its recursive dependencies.</source>
          <target state="translated">El &lt;code&gt;#[global_allocator]&lt;/code&gt; solo se puede usar una vez en una caja o sus dependencias recursivas.</target>
        </trans-unit>
        <trans-unit id="672159bbb94aa0ec135859c99523eca0ebc397f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[macro_export]&lt;/code&gt; annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can&amp;rsquo;t be brought into scope.</source>
          <target state="translated">La anotaci&amp;oacute;n &lt;code&gt;#[macro_export]&lt;/code&gt; indica que esta macro debe estar disponible siempre que la caja en la que se define la macro entre en el alcance. Sin esta anotaci&amp;oacute;n, la macro no se puede poner dentro del alcance.</target>
        </trans-unit>
        <trans-unit id="859ec264725730980afa9483dd83d3f313613cc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(C)]&lt;/code&gt; attribute can only be placed on structs and enums.</source>
          <target state="translated">El atributo &lt;code&gt;#[repr(C)]&lt;/code&gt; solo se puede colocar en estructuras y enumeraciones.</target>
        </trans-unit>
        <trans-unit id="20ce08781d178cc7ecc1d0ee2405f13954a27792" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(packed)]&lt;/code&gt; and &lt;code&gt;#[repr(simd)]&lt;/code&gt; attributes only work on structs.</source>
          <target state="translated">Los atributos &lt;code&gt;#[repr(packed)]&lt;/code&gt; y &lt;code&gt;#[repr(simd)]&lt;/code&gt; solo funcionan en estructuras.</target>
        </trans-unit>
        <trans-unit id="37e64d7cdeff0fe84feb89e7cacb8aa07bcc4dd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(u8)]&lt;/code&gt;, &lt;code&gt;#[repr(i16)]&lt;/code&gt;, etc attributes only work on enums.</source>
          <target state="translated">Los &lt;code&gt;#[repr(u8)]&lt;/code&gt; , &lt;code&gt;#[repr(i16)]&lt;/code&gt; , etc. s&amp;oacute;lo funcionan en enumeraciones.</target>
        </trans-unit>
        <trans-unit id="c9b512964c382c5f5d5e0080e7203c876528ceb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</source>
          <target state="translated">El atributo &lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; le permite especificar un mensaje de error personalizado para cuando un rasgo en particular no se implementa en un tipo colocado en una posici&amp;oacute;n que necesita ese rasgo. Por ejemplo, cuando se compila el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="910d7829ddf09eb2fc4a2ff115280a7e351c19be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[simd]&lt;/code&gt; attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</source>
          <target state="translated">El atributo &lt;code&gt;#[simd]&lt;/code&gt; solo se puede aplicar a estructuras de tuplas no vac&amp;iacute;as, porque no tiene sentido intentar usar operaciones SIMD cuando no hay valores sobre los que operar.</target>
        </trans-unit>
        <trans-unit id="20a3879322df478a4cc556128e471d1c66adae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[unwind]&lt;/code&gt; attribute should be used as follows:</source>
          <target state="translated">El atributo &lt;code&gt;#[unwind]&lt;/code&gt; debe usarse de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="98359d44655df527d34cb1e33db3c37a01e294d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0afa92240bade4867a8d2b0fc7bc387cff228f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="translated">Los operadores &lt;code&gt;&amp;amp;&lt;/code&gt; (pr&amp;eacute;stamo compartido) y &lt;code&gt;&amp;amp;mut&lt;/code&gt; (pr&amp;eacute;stamo mutable) son operadores de prefijo unario. Cuando se aplica a una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar&lt;/a&gt; , esta expresi&amp;oacute;n produce una referencia (puntero) a la ubicaci&amp;oacute;n a la que se refiere el valor. La ubicaci&amp;oacute;n de la memoria tambi&amp;eacute;n se coloca en un estado prestado durante la duraci&amp;oacute;n de la referencia. Para un pr&amp;eacute;stamo compartido ( &lt;code&gt;&amp;amp;&lt;/code&gt; ), esto implica que el lugar no puede ser mutado, pero puede ser le&amp;iacute;do o compartido nuevamente. Para un pr&amp;eacute;stamo mutable ( &lt;code&gt;&amp;amp;mut&lt;/code&gt; ), no se puede acceder al lugar de ninguna manera hasta que expire el pr&amp;eacute;stamo. &lt;code&gt;&amp;amp;mut&lt;/code&gt; eval&amp;uacute;a su operando en un contexto de expresi&amp;oacute;n de lugar mutable. Si los operadores &lt;code&gt;&amp;amp;&lt;/code&gt; o &lt;code&gt;&amp;amp;mut&lt;/code&gt; se aplican a un&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de valor&lt;/a&gt; , luego se crea un &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;valor temporal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="289f7ac6e65862e6021cefdfd8637885846add32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; indicates that this argument is a &lt;em&gt;reference&lt;/em&gt;, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust&amp;rsquo;s major advantages is how safe and easy it is to use references. You don&amp;rsquo;t need to know a lot of those details to finish this program. For now, all you need to know is that like variables, references are immutable by default. Hence, you need to write &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; rather than &lt;code&gt;&amp;amp;guess&lt;/code&gt; to make it mutable. (Chapter 4 will explain references more thoroughly.)</source>
          <target state="translated">El &lt;code&gt;&amp;amp;&lt;/code&gt; indica que este argumento es una &lt;em&gt;referencia&lt;/em&gt; , lo que le brinda una forma de permitir que varias partes de su c&amp;oacute;digo accedan a un dato sin necesidad de copiar esos datos en la memoria varias veces. Las referencias son una caracter&amp;iacute;stica compleja y una de las principales ventajas de Rust es lo seguro y f&amp;aacute;cil que es utilizar las referencias. No necesita conocer muchos de esos detalles para terminar este programa. Por ahora, todo lo que necesita saber es que, al igual que las variables, las referencias son inmutables de forma predeterminada. Por lo tanto, debe escribir &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; lugar de &lt;code&gt;&amp;amp;guess&lt;/code&gt; para que sea mutable. (El Cap&amp;iacute;tulo 4 explicar&amp;aacute; las referencias con m&amp;aacute;s detalle).</target>
        </trans-unit>
        <trans-unit id="0ba71ec6a87d61177d25877a820fc83d9405b11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;s1&lt;/code&gt; syntax lets us create a reference that &lt;em&gt;refers&lt;/em&gt; to the value of &lt;code&gt;s1&lt;/code&gt; but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.</source>
          <target state="translated">La sintaxis &lt;code&gt;&amp;amp;s1&lt;/code&gt; nos permite crear una referencia que se &lt;em&gt;refiere&lt;/em&gt; al valor de &lt;code&gt;s1&lt;/code&gt; pero que no lo posee. Debido a que no lo posee, el valor al que apunta no se eliminar&amp;aacute; cuando la referencia quede fuera de alcance.</target>
        </trans-unit>
        <trans-unit id="ac2092b7195c0e20492c6630d5e4fa162bb49bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type guarantees that its contents are UTF-8, and so we can compare the length it would take if each code point was represented as a &lt;code&gt;char&lt;/code&gt; vs in the &lt;code&gt;&amp;amp;str&lt;/code&gt; itself:</source>
          <target state="translated">El tipo &lt;code&gt;&amp;amp;str&lt;/code&gt; garantiza que su contenido es UTF-8, por lo que podemos comparar la longitud que tomar&amp;iacute;a si cada punto de c&amp;oacute;digo se representara como un &lt;code&gt;char&lt;/code&gt; vs en el mismo &lt;code&gt;&amp;amp;str&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9573f9c210e855e348b2b66cefde61b52fa3eea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type is one of the two main string types, the other being &lt;code&gt;String&lt;/code&gt;. Unlike its &lt;code&gt;String&lt;/code&gt; counterpart, its contents are borrowed.</source>
          <target state="translated">El tipo &lt;code&gt;&amp;amp;str&lt;/code&gt; es uno de los dos tipos de cadenas principales, siendo el otro &lt;code&gt;String&lt;/code&gt; . A diferencia de su contraparte &lt;code&gt;String&lt;/code&gt; , su contenido se toma prestado.</target>
        </trans-unit>
        <trans-unit id="9dd45416e37868ecd085972d08ce3b564e5e5995" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; syntax tells the shell to write the contents of standard output to &lt;em&gt;output.txt&lt;/em&gt; instead of the screen. We didn&amp;rsquo;t see the error message we were expecting printed to the screen, so that means it must have ended up in the file. This is what &lt;em&gt;output.txt&lt;/em&gt; contains:</source>
          <target state="translated">La sintaxis &lt;code&gt;&amp;gt;&lt;/code&gt; le dice al shell que escriba el contenido de la salida est&amp;aacute;ndar en &lt;em&gt;output.txt en&lt;/em&gt; lugar de la pantalla. No vimos el mensaje de error que esper&amp;aacute;bamos impreso en la pantalla, por lo que eso significa que debe haber terminado en el archivo. Esto es lo que contiene &lt;em&gt;output.txt&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b005addd17171fe396053ec0c62812c2c97cade4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; syntax is a feature of Rust we haven&amp;rsquo;t talked about yet. It&amp;rsquo;s a generic type parameter, and we&amp;rsquo;ll cover generics in more detail in Chapter 10. For now, all you need to know is that &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; means the &lt;code&gt;Some&lt;/code&gt; variant of the &lt;code&gt;Option&lt;/code&gt; enum can hold one piece of data of any type. Here are some examples of using &lt;code&gt;Option&lt;/code&gt; values to hold number types and string types:</source>
          <target state="translated">La sintaxis &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; es una caracter&amp;iacute;stica de Rust de la que no hemos hablado todav&amp;iacute;a. Es un par&amp;aacute;metro de tipo gen&amp;eacute;rico, y cubriremos los gen&amp;eacute;ricos con m&amp;aacute;s detalle en el Cap&amp;iacute;tulo 10. Por ahora, todo lo que necesita saber es que &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; significa que la variante &lt;code&gt;Some&lt;/code&gt; de &lt;code&gt;Option&lt;/code&gt; enum puede contener un dato de cualquier tipo. A continuaci&amp;oacute;n, se muestran algunos ejemplos del uso de valores de &lt;code&gt;Option&lt;/code&gt; para contener tipos de n&amp;uacute;meros y tipos de cadenas:</target>
        </trans-unit>
        <trans-unit id="0e8f2a70b6f25c55e2febf941fcc1166aa49e75b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'static&lt;/code&gt; constraint means that the closure and its return value must have a lifetime of the whole program execution. The reason for this is that threads can &lt;code&gt;detach&lt;/code&gt; and outlive the lifetime they have been created in. Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we &lt;em&gt;can't&lt;/em&gt; know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the &lt;code&gt;'static&lt;/code&gt; lifetime.</source>
          <target state="translated">La &lt;code&gt;'static&lt;/code&gt; restricci&amp;oacute;n est&amp;aacute;tica significa que el cierre y su valor de retorno deben tener una duraci&amp;oacute;n de toda la ejecuci&amp;oacute;n del programa. La raz&amp;oacute;n de esto es que los subprocesos pueden &lt;code&gt;detach&lt;/code&gt; y sobrevivir a la vida &amp;uacute;til en la que se crearon. De hecho, si el subproceso y, por extensi&amp;oacute;n, su valor de retorno, puede sobrevivir a su llamador, debemos asegurarnos de que ser&amp;aacute;n v&amp;aacute;lidos despu&amp;eacute;s, y dado que no &lt;em&gt;podemos&lt;/em&gt; saber cu&amp;aacute;ndo volver&amp;aacute;, necesitamos que sean v&amp;aacute;lidos el mayor tiempo posible, es decir, hasta el final del programa, de ah&amp;iacute; el &lt;code&gt;'static&lt;/code&gt; tiempo de vida est&amp;aacute;tico' .</target>
        </trans-unit>
        <trans-unit id="d507c32a06112cec989a75204d96602b968865dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type has exactly one value &lt;code&gt;()&lt;/code&gt;, and is used when there is no other meaningful value that could be returned. &lt;code&gt;()&lt;/code&gt; is most commonly seen implicitly: functions without a &lt;code&gt;-&amp;gt; ...&lt;/code&gt; implicitly have return type &lt;code&gt;()&lt;/code&gt;, that is, these are equivalent:</source>
          <target state="translated">El tipo &lt;code&gt;()&lt;/code&gt; tiene exactamente un valor &lt;code&gt;()&lt;/code&gt; y se usa cuando no hay otro valor significativo que pueda devolverse. &lt;code&gt;()&lt;/code&gt; se ve m&amp;aacute;s com&amp;uacute;nmente de forma impl&amp;iacute;cita: las funciones sin un &lt;code&gt;-&amp;gt; ...&lt;/code&gt; impl&amp;iacute;citamente tienen un tipo de retorno &lt;code&gt;()&lt;/code&gt; , es decir, son equivalentes:</target>
        </trans-unit>
        <trans-unit id="e3861dba93432d9d5236ce5338f7751eb3d446a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, also called &quot;unit&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7f39bcbd9c29a0b11698eda466dd66f20fff6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, sometimes called &quot;unit&quot; or &quot;nil&quot;.</source>
          <target state="translated">El tipo &lt;code&gt;()&lt;/code&gt; , a veces llamado &quot;unidad&quot; o &quot;nulo&quot;.</target>
        </trans-unit>
        <trans-unit id="918cd095e0c314aaf612bef93955c593d22df666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(*m)&lt;/code&gt; dereferences the &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into a &lt;code&gt;String&lt;/code&gt;. Then the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[..]&lt;/code&gt; take a string slice of the &lt;code&gt;String&lt;/code&gt; that is equal to the whole string to match the signature of &lt;code&gt;hello&lt;/code&gt;. The code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</source>
          <target state="translated">El &lt;code&gt;(*m)&lt;/code&gt; elimina la referencia de &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; en una &lt;code&gt;String&lt;/code&gt; . Luego, &lt;code&gt;&amp;amp;&lt;/code&gt; y &lt;code&gt;[..]&lt;/code&gt; toman una porci&amp;oacute;n de cadena de la &lt;code&gt;String&lt;/code&gt; que es igual a toda la cadena para que coincida con la firma de &lt;code&gt;hello&lt;/code&gt; . El c&amp;oacute;digo sin coacciones deref es m&amp;aacute;s dif&amp;iacute;cil de leer, escribir y comprender con todos estos s&amp;iacute;mbolos involucrados. Deref coercion permite a Rust manejar estas conversiones autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="dceab58b2710b9293ff102afe19580771458da84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; (dereference) operator is also a unary prefix operator. When applied to a &lt;a href=&quot;../types/pointer&quot;&gt;pointer&lt;/a&gt; it denotes the pointed-to location. If the expression is of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, and is either a local variable, a (nested) field of a local variable or is a mutable &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, then the resulting memory location can be assigned to. Dereferencing a raw pointer requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">El operador &lt;code&gt;*&lt;/code&gt; (desreferencia) tambi&amp;eacute;n es un operador de prefijo unario. Cuando se aplica a un &lt;a href=&quot;../types/pointer&quot;&gt;puntero&lt;/a&gt; , denota la ubicaci&amp;oacute;n apuntada. Si la expresi&amp;oacute;n es de tipo &lt;code&gt;&amp;amp;mut T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; , y es una variable local, un campo (anidado) de una variable local o es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar&lt;/a&gt; mutable , entonces se puede asignar la ubicaci&amp;oacute;n de memoria resultante. Desreferenciar un puntero sin formato requiere &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9081a0fc77deca2ae1677facd10e7e74970f88a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; syntax is also valid with trait bounds on generic types:</source>
          <target state="translated">La sintaxis &lt;code&gt;+&lt;/code&gt; tambi&amp;eacute;n es v&amp;aacute;lida con l&amp;iacute;mites de rasgos en tipos gen&amp;eacute;ricos:</target>
        </trans-unit>
        <trans-unit id="afa4c918a009f5cfb91d99e9fea97354edfccd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; type operator was used in an ambiguous context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7d56124b7814800cfa939450d0c6d38a399da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operators may be composed with the &lt;code&gt;=&lt;/code&gt; operator. The expression &lt;code&gt;place_exp OP= value&lt;/code&gt; is equivalent to &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt;. For example, &lt;code&gt;x = x + 1&lt;/code&gt; may be written as &lt;code&gt;x += 1&lt;/code&gt;. Any such expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;. These operators can all be overloaded using the trait with the same name as for the normal operation followed by 'Assign', for example, &lt;code&gt;std::ops::AddAssign&lt;/code&gt; is used to overload &lt;code&gt;+=&lt;/code&gt;. As with &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;place_expr&lt;/code&gt; must be a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;.</source>
          <target state="translated">El &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; Los operadores , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; se pueden componer con el operador &lt;code&gt;=&lt;/code&gt; . La expresi&amp;oacute;n &lt;code&gt;place_exp OP= value&lt;/code&gt; es equivalente a &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt; . Por ejemplo, &lt;code&gt;x = x + 1&lt;/code&gt; puede escribirse como &lt;code&gt;x += 1&lt;/code&gt; . Cualquier expresi&amp;oacute;n de este tipo siempre tiene el &lt;a href=&quot;../types/tuple&quot;&gt;tipo de &lt;/a&gt; &lt;code&gt;unit&lt;/code&gt; . Todos estos operadores pueden sobrecargarse usando el rasgo con el mismo nombre que para la operaci&amp;oacute;n normal seguido de 'Asignar', por ejemplo, &lt;code&gt;std::ops::AddAssign&lt;/code&gt; se usa para sobrecargar &lt;code&gt;+=&lt;/code&gt; . Como con &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;place_expr&lt;/code&gt; debe ser una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a770a23638a823405304b5862ae9b043051acefe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8565fcc01087bd00c830a709f76c89a8bec0ee11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="translated">La sintaxis &lt;code&gt;...&lt;/code&gt; nos permite hacer coincidir con un rango inclusivo de valores. En el siguiente c&amp;oacute;digo, cuando un patr&amp;oacute;n coincide con cualquiera de los valores dentro del rango, ese brazo se ejecutar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="a4afeb6b704f2eeee4511dc907c8b58744889e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax is kept for backwards compatibility.</source>
          <target state="translated">La sintaxis &lt;code&gt;...&lt;/code&gt; se mantiene por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="e2e1f03ffc70a6a254885658fe3c94afc796ca12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;..=&lt;/code&gt; operators will construct an object of one of the &lt;code&gt;std::ops::Range&lt;/code&gt; (or &lt;code&gt;core::ops::Range&lt;/code&gt;) variants, according to the following table:</source>
          <target state="translated">Los operadores &lt;code&gt;..&lt;/code&gt; y &lt;code&gt;..=&lt;/code&gt; construir&amp;aacute;n un objeto de una de las variantes &lt;code&gt;std::ops::Range&lt;/code&gt; (o &lt;code&gt;core::ops::Range&lt;/code&gt; ), de acuerdo con la siguiente tabla:</target>
        </trans-unit>
        <trans-unit id="92e96dedbdbf92f3e2e6464ed4a171437558a608" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; syntax is a &lt;code&gt;RangeFull&lt;/code&gt;:</source>
          <target state="translated">La sintaxis &lt;code&gt;..&lt;/code&gt; es &lt;code&gt;RangeFull&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e498b96e1f982900a97ac68d2121f886fa57f814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc028c330bc0f9500e9f59b98e8ba94a546679b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeToInclusive&lt;/code&gt;:</source>
          <target state="translated">La sintaxis &lt;code&gt;..=end&lt;/code&gt; es un &lt;code&gt;RangeToInclusive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="06bff2e76574f65224a2d8263399ed02a85a5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..end&lt;/code&gt; syntax is a &lt;code&gt;RangeTo&lt;/code&gt;:</source>
          <target state="translated">La sintaxis &lt;code&gt;..end&lt;/code&gt; es &lt;code&gt;RangeTo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e2942c55d614162c6590171ee52a6786d9039b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0 measured&lt;/code&gt; statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;the documentation about benchmark tests&lt;/a&gt; to learn more.</source>
          <target state="translated">La estad&amp;iacute;stica &lt;code&gt;0 measured&lt;/code&gt; es para pruebas de referencia que miden el rendimiento. Las pruebas de referencia est&amp;aacute;n, al momento de escribir este art&amp;iacute;culo, solo disponibles en Rust nocturno. Consulte &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;la documentaci&amp;oacute;n sobre las pruebas comparativas&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="79584c510d0bdac6b79741ca275d743c77143fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="translated">El &lt;code&gt;3&lt;/code&gt; ya no est&amp;aacute; all&amp;iacute;, porque se consumi&amp;oacute; para ver si la iteraci&amp;oacute;n deber&amp;iacute;a detenerse, pero no se volvi&amp;oacute; a colocar en el iterador.</target>
        </trans-unit>
        <trans-unit id="e721998eb3ac8ff36164c3da054ad164e33f55c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;five&lt;/code&gt; is the function&amp;rsquo;s return value, which is why the return type is &lt;code&gt;i32&lt;/code&gt;. Let&amp;rsquo;s examine this in more detail. There are two important bits: first, the line &lt;code&gt;let x = five();&lt;/code&gt; shows that we&amp;rsquo;re using the return value of a function to initialize a variable. Because the function &lt;code&gt;five&lt;/code&gt; returns a &lt;code&gt;5&lt;/code&gt;, that line is the same as the following:</source>
          <target state="translated">El &lt;code&gt;5&lt;/code&gt; de &lt;code&gt;five&lt;/code&gt; es el valor de retorno de la funci&amp;oacute;n, por lo que el tipo de retorno es &lt;code&gt;i32&lt;/code&gt; . Examinemos esto con m&amp;aacute;s detalle. Hay dos bits importantes: primero, la l&amp;iacute;nea &lt;code&gt;let x = five();&lt;/code&gt; muestra que estamos usando el valor de retorno de una funci&amp;oacute;n para inicializar una variable. Debido a que la funci&amp;oacute;n &lt;code&gt;five&lt;/code&gt; devuelve un &lt;code&gt;5&lt;/code&gt; , esa l&amp;iacute;nea es la siguiente:</target>
        </trans-unit>
        <trans-unit id="f64d85c43f38ffb1d9f69e7f8ec2961df3c8d6da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; syntax in the &lt;code&gt;::new&lt;/code&gt; line indicates that &lt;code&gt;new&lt;/code&gt; is an &lt;em&gt;associated function&lt;/em&gt; of the &lt;code&gt;String&lt;/code&gt; type. An associated function is implemented on a type, in this case &lt;code&gt;String&lt;/code&gt;, rather than on a particular instance of a &lt;code&gt;String&lt;/code&gt;. Some languages call this a &lt;em&gt;static method&lt;/em&gt;.</source>
          <target state="translated">La &lt;code&gt;::&lt;/code&gt; sintaxis en la &lt;code&gt;::new&lt;/code&gt; l&amp;iacute;nea indica que &lt;code&gt;new&lt;/code&gt; es una &lt;em&gt;funci&amp;oacute;n asociada&lt;/em&gt; del tipo &lt;code&gt;String&lt;/code&gt; . Una funci&amp;oacute;n asociada se implementa en un tipo, en este caso &lt;code&gt;String&lt;/code&gt; , en lugar de en una instancia particular de &lt;code&gt;String&lt;/code&gt; . Algunos lenguajes llaman a esto un &lt;em&gt;m&amp;eacute;todo est&amp;aacute;tico&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6c666ec2c7e67dbab00bbae26838dd52620a7c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; token is required before the opening &lt;code&gt;&amp;lt;&lt;/code&gt; for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as &quot;turbofish&quot; syntax.</source>
          <target state="translated">El &lt;code&gt;::&lt;/code&gt; token es necesario antes de la apertura &lt;code&gt;&amp;lt;&lt;/code&gt; para argumentos gen&amp;eacute;ricos para evitar la ambig&amp;uuml;edad con el operador menor que. Esto se conoce coloquialmente como sintaxis &quot;turbofish&quot;.</target>
        </trans-unit>
        <trans-unit id="973f4c6b5b84dfca6c5a6d4e2198053b9adfe1f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function can be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec4c0c2491bd5a54898bf44aa756701f4e9b5fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can only be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function must be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;?&lt;/code&gt; El operador solo se puede usar en funciones que tienen un tipo de retorno de &lt;code&gt;Result&lt;/code&gt; ado , porque est&amp;aacute; definido para funcionar de la misma manera que la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; que definimos en el Listado 9-6. La parte de la &lt;code&gt;match&lt;/code&gt; que requiere un tipo de retorno de &lt;code&gt;Result&lt;/code&gt; ado es &lt;code&gt;return Err(e)&lt;/code&gt; , por lo que el tipo de retorno de la funci&amp;oacute;n debe ser un &lt;code&gt;Result&lt;/code&gt; ado para ser compatible con este &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd74ffef5a8c90c3fd4d6d76e29ea8086760c062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator eliminates a lot of boilerplate and makes this function&amp;rsquo;s implementation simpler. We could even shorten this code further by chaining method calls immediately after the &lt;code&gt;?&lt;/code&gt;, as shown in Listing 9-8.</source>
          <target state="translated">El &lt;code&gt;?&lt;/code&gt; operator elimina una gran cantidad de texto est&amp;aacute;ndar y simplifica la implementaci&amp;oacute;n de esta funci&amp;oacute;n. Incluso podr&amp;iacute;amos acortar m&amp;aacute;s este c&amp;oacute;digo encadenando llamadas a m&amp;eacute;todos inmediatamente despu&amp;eacute;s de &lt;code&gt;?&lt;/code&gt; , como se muestra en el Listado 9-8.</target>
        </trans-unit>
        <trans-unit id="69d45072228b4f483bc2426682521ed37346faf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator was added to replace &lt;code&gt;try!&lt;/code&gt; and should be used instead. Furthermore, &lt;code&gt;try&lt;/code&gt; is a reserved word in Rust 2018, so if you must use it, you will need to use the &lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw-identifier syntax&lt;/a&gt;: &lt;code&gt;r#try&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;?&lt;/code&gt; Se agreg&amp;oacute; el operador para reemplazar &lt;code&gt;try!&lt;/code&gt; y deber&amp;iacute;a utilizarse en su lugar. Adem&amp;aacute;s, &lt;code&gt;try&lt;/code&gt; es una palabra reservada en Rust 2018, por lo que si debe usarla, deber&amp;aacute; usar la &lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;sintaxis del identificador sin procesar&lt;/a&gt; : &lt;code&gt;r#try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02b9d3c4349fb0a9b0da69a54ee8f956959e334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; placed after a &lt;code&gt;Result&lt;/code&gt; value is defined to work in almost the same way as the &lt;code&gt;match&lt;/code&gt; expressions we defined to handle the &lt;code&gt;Result&lt;/code&gt; values in Listing 9-6. If the value of the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt;, the value inside the &lt;code&gt;Ok&lt;/code&gt; will get returned from this expression, and the program will continue. If the value is an &lt;code&gt;Err&lt;/code&gt;, the &lt;code&gt;Err&lt;/code&gt; will be returned from the whole function as if we had used the &lt;code&gt;return&lt;/code&gt; keyword so the error value gets propagated to the calling code.</source>
          <target state="translated">El &lt;code&gt;?&lt;/code&gt; colocado despu&amp;eacute;s de que se define un valor de &lt;code&gt;Result&lt;/code&gt; para que funcione casi de la misma manera que las expresiones de &lt;code&gt;match&lt;/code&gt; que definimos para manejar los valores de &lt;code&gt;Result&lt;/code&gt; en el Listado 9-6. Si el valor del &lt;code&gt;Result&lt;/code&gt; ado es &lt;code&gt;Ok&lt;/code&gt; , el valor dentro de &lt;code&gt;Ok&lt;/code&gt; se devolver&amp;aacute; de esta expresi&amp;oacute;n y el programa continuar&amp;aacute;. Si el valor es un &lt;code&gt;Err&lt;/code&gt; , el &lt;code&gt;Err&lt;/code&gt; ser&amp;aacute; devuelto por toda la funci&amp;oacute;n como si hubi&amp;eacute;ramos usado la palabra clave &lt;code&gt;return&lt;/code&gt; , por lo que el valor de error se propaga al c&amp;oacute;digo de llamada.</target>
        </trans-unit>
        <trans-unit id="1dcf74da2de6e2e77e988e297d47588fe8eb0ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">El rasgo &lt;code&gt;Alloc&lt;/code&gt; es un rasgo &lt;code&gt;unsafe&lt;/code&gt; por varias razones, y los implementadores deben asegurarse de cumplir con estos contratos:</target>
        </trans-unit>
        <trans-unit id="98e48446e54082f0c926a4f9b0d797094660f773" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocErr&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="translated">El error &lt;code&gt;AllocErr&lt;/code&gt; indica una falla en la asignaci&amp;oacute;n que puede deberse al agotamiento de los recursos oa algo incorrecto al combinar los argumentos de entrada dados con este asignador.</target>
        </trans-unit>
        <trans-unit id="40c7890578f6b7272b5ec64894b3d7a1fbafa432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocError&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15f84d510941143cdca2ea70c5b85337d8cfce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Binary&lt;/code&gt; trait should format its output as a number in binary.</source>
          <target state="translated">El rasgo &lt;code&gt;Binary&lt;/code&gt; debe formatear su salida como un n&amp;uacute;mero en binario.</target>
        </trans-unit>
        <trans-unit id="379b6b1f35d3ee950871663ac9c0d0834cb49cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;...&amp;gt;&lt;/code&gt; ensures that the result is of known size, and the pin is required to keep it in the same place in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e3077926ddb39580746ea9c9fb509f4ede0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is a smart pointer because it implements the &lt;code&gt;Deref&lt;/code&gt; trait, which allows &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; values to be treated like references. When a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the &lt;code&gt;Drop&lt;/code&gt; trait implementation. Let&amp;rsquo;s explore these two traits in more detail. These two traits will be even more important to the functionality provided by the other smart pointer types we&amp;rsquo;ll discuss in the rest of this chapter.</source>
          <target state="translated">El tipo &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; es un puntero inteligente porque implementa el rasgo &lt;code&gt;Deref&lt;/code&gt; , que permite que los valores &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; sean tratados como referencias. Cuando un valor de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; sale del alcance, los datos del mont&amp;oacute;n a los que apunta el cuadro tambi&amp;eacute;n se limpian debido a la implementaci&amp;oacute;n del rasgo &lt;code&gt;Drop&lt;/code&gt; . Exploremos estos dos rasgos con m&amp;aacute;s detalle. Estos dos rasgos ser&amp;aacute;n a&amp;uacute;n m&amp;aacute;s importantes para la funcionalidad proporcionada por los otros tipos de punteros inteligentes que discutiremos en el resto de este cap&amp;iacute;tulo.</target>
        </trans-unit>
        <trans-unit id="66f94ad31e24eabd73aee0f8f7b4d3256d1ad7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type in the same way. We&amp;rsquo;ll also define a &lt;code&gt;new&lt;/code&gt; function to match the &lt;code&gt;new&lt;/code&gt; function defined on &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; se define en &amp;uacute;ltima instancia como una estructura de tupla con un elemento, por lo que el Listado 15-8 define un tipo &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; de la misma manera. Tambi&amp;eacute;n definiremos una &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n para que coincida con la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n definida en &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf6505b6927d963f13c67732403dd5931ac1ed9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a &lt;em&gt;trait object&lt;/em&gt;, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="translated">El tipo &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; se denomina &lt;em&gt;objeto de rasgo&lt;/em&gt; , del que hablaremos en la secci&amp;oacute;n &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&quot;Uso de objetos de rasgo que permiten valores de diferentes tipos&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 17. Por ahora, puede leer &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; para significa &quot;cualquier tipo de error&quot;. Usando &lt;code&gt;?&lt;/code&gt; en una funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; con este tipo de retorno est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="f421012dfbbefb54564368d8001a12741e0df3e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a trait object, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da298387c32437955972d3bd8b7791a6a295347" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1691172593fd486c5eabaf315f65ace8dbf6dcde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="translated">La estructura &lt;code&gt;BufReader&lt;/code&gt; agrega almacenamiento en b&amp;uacute;fer a cualquier lector.</target>
        </trans-unit>
        <trans-unit id="258a1854757eccfe175a683df1ba477ca28eb2bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; Representation</source>
          <target state="translated">La Representaci&amp;oacute;n &lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13bde6b705c6f0c548e0105a8252725ac6ce4d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation for items has a defined layout. With this layout, the size of items is also stable as long as all fields have a stable size.</source>
          <target state="translated">La representaci&amp;oacute;n en &lt;code&gt;C&lt;/code&gt; de los elementos tiene un dise&amp;ntilde;o definido. Con este dise&amp;ntilde;o, el tama&amp;ntilde;o de los elementos tambi&amp;eacute;n es estable siempre que todos los campos tengan un tama&amp;ntilde;o estable.</target>
        </trans-unit>
        <trans-unit id="51da5ab6258546c0e07e79893a79989cd376412d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.</source>
          <target state="translated">La representaci&amp;oacute;n &lt;code&gt;C&lt;/code&gt; est&amp;aacute; dise&amp;ntilde;ada para dos prop&amp;oacute;sitos. Uno de los prop&amp;oacute;sitos es crear tipos que sean interoperables con el lenguaje C. El segundo prop&amp;oacute;sito es crear tipos en los que pueda realizar operaciones s&amp;oacute;lidamente que se basen en el dise&amp;ntilde;o de datos, como reinterpretar valores como un tipo diferente.</target>
        </trans-unit>
        <trans-unit id="d3b29c11032bb6739237ad8f95e6e66861078b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher::new&lt;/code&gt; function takes a generic parameter &lt;code&gt;T&lt;/code&gt;, which we&amp;rsquo;ve defined as having the same trait bound as the &lt;code&gt;Cacher&lt;/code&gt; struct. Then &lt;code&gt;Cacher::new&lt;/code&gt; returns a &lt;code&gt;Cacher&lt;/code&gt; instance that holds the closure specified in the &lt;code&gt;calculation&lt;/code&gt; field and a &lt;code&gt;None&lt;/code&gt; value in the &lt;code&gt;value&lt;/code&gt; field, because we haven&amp;rsquo;t executed the closure yet.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Cacher::new&lt;/code&gt; toma un par&amp;aacute;metro gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; , que hemos definido con el mismo rasgo enlazado que la estructura &lt;code&gt;Cacher&lt;/code&gt; . Entonces &lt;code&gt;Cacher::new&lt;/code&gt; devuelve una instancia de &lt;code&gt;Cacher&lt;/code&gt; que contiene el cierre especificado en el campo de &lt;code&gt;calculation&lt;/code&gt; y un valor &lt;code&gt;None&lt;/code&gt; en el campo de &lt;code&gt;value&lt;/code&gt; , porque a&amp;uacute;n no hemos ejecutado el cierre.</target>
        </trans-unit>
        <trans-unit id="b4813a8ce2e935eef24c8392e81d63c3906c4494" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher&lt;/code&gt; struct has a &lt;code&gt;calculation&lt;/code&gt; field of the generic type &lt;code&gt;T&lt;/code&gt;. The trait bounds on &lt;code&gt;T&lt;/code&gt; specify that it&amp;rsquo;s a closure by using the &lt;code&gt;Fn&lt;/code&gt; trait. Any closure we want to store in the &lt;code&gt;calculation&lt;/code&gt; field must have one &lt;code&gt;u32&lt;/code&gt; parameter (specified within the parentheses after &lt;code&gt;Fn&lt;/code&gt;) and must return a &lt;code&gt;u32&lt;/code&gt; (specified after the &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">El &lt;code&gt;Cacher&lt;/code&gt; estructura tiene un &lt;code&gt;calculation&lt;/code&gt; campo del tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; . Los l&amp;iacute;mites del rasgo en &lt;code&gt;T&lt;/code&gt; especifican que es un cierre mediante el uso del rasgo &lt;code&gt;Fn&lt;/code&gt; . Cualquier cierre que queramos almacenar en el campo de &lt;code&gt;calculation&lt;/code&gt; debe tener un par&amp;aacute;metro &lt;code&gt;u32&lt;/code&gt; (especificado entre par&amp;eacute;ntesis despu&amp;eacute;s de &lt;code&gt;Fn&lt;/code&gt; ) y debe devolver un &lt;code&gt;u32&lt;/code&gt; (especificado despu&amp;eacute;s de &lt;code&gt;-&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2611487755ed0f487d8741cbb5ae43a528fa050" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CannotReallocInPlace&lt;/code&gt; error is used when &lt;code&gt;grow_in_place&lt;/code&gt; or &lt;code&gt;shrink_in_place&lt;/code&gt; were unable to reuse the given memory block for a requested layout.</source>
          <target state="translated">El error &lt;code&gt;CannotReallocInPlace&lt;/code&gt; se usa cuando &lt;code&gt;grow_in_place&lt;/code&gt; o &lt;code&gt;shrink_in_place&lt;/code&gt; no pudieron reutilizar el bloque de memoria dado para un dise&amp;ntilde;o solicitado.</target>
        </trans-unit>
        <trans-unit id="66ff318ae517f73cd3f13be64857852133418c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data. See the &lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&amp;ldquo;Ways Variables and Data Interact: Clone&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Clone&lt;/code&gt; permite crear expl&amp;iacute;citamente una copia profunda de un valor, y el proceso de duplicaci&amp;oacute;n puede implicar ejecutar c&amp;oacute;digo arbitrario y copiar datos del mont&amp;oacute;n. Consulte la secci&amp;oacute;n &lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&quot;Formas de interacci&amp;oacute;n de las variables y los datos: Clonar&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 4 para obtener m&amp;aacute;s informaci&amp;oacute;n sobre &lt;code&gt;Clone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad03569cf96b66590827b19ede2029d2fc0e960d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait for types that cannot be 'implicitly copied'.</source>
          <target state="translated">El rasgo &lt;code&gt;Clone&lt;/code&gt; para tipos que no se pueden 'copiar impl&amp;iacute;citamente'.</target>
        </trans-unit>
        <trans-unit id="18eff9d7482bec9f52eb9a085d95c11254b36933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CoerceUnsized&lt;/code&gt; trait takes a struct type. Make sure the type you are providing to &lt;code&gt;CoerceUnsized&lt;/code&gt; is a struct with only the last field containing an unsized type.</source>
          <target state="translated">El rasgo &lt;code&gt;CoerceUnsized&lt;/code&gt; toma un tipo de estructura. Aseg&amp;uacute;rese de que el tipo que est&amp;aacute; proporcionando a &lt;code&gt;CoerceUnsized&lt;/code&gt; sea ​​una estructura con solo el &amp;uacute;ltimo campo que contenga un tipo sin tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="e548ae9701e88686017ab152887ae716380c763e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config::new&lt;/code&gt; function definition</source>
          <target state="translated">La &lt;code&gt;Config::new&lt;/code&gt; definici&amp;oacute;n de funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="501a0b9d21e10f396777e5d2959bafbe25f146ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variant will need the size of an &lt;code&gt;i32&lt;/code&gt; plus the space to store the box&amp;rsquo;s pointer data. The &lt;code&gt;Nil&lt;/code&gt; variant stores no values, so it needs less space than the &lt;code&gt;Cons&lt;/code&gt; variant. We now know that any &lt;code&gt;List&lt;/code&gt; value will take up the size of an &lt;code&gt;i32&lt;/code&gt; plus the size of a box&amp;rsquo;s pointer data. By using a box, we&amp;rsquo;ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a &lt;code&gt;List&lt;/code&gt; value. Figure 15-2 shows what the &lt;code&gt;Cons&lt;/code&gt; variant looks like now.</source>
          <target state="translated">La variante &lt;code&gt;Cons&lt;/code&gt; necesitar&amp;aacute; el tama&amp;ntilde;o de un &lt;code&gt;i32&lt;/code&gt; m&amp;aacute;s el espacio para almacenar los datos del puntero de la caja. La variante &lt;code&gt;Nil&lt;/code&gt; no almacena valores, por lo que necesita menos espacio que la variante &lt;code&gt;Cons&lt;/code&gt; . Ahora sabemos que cualquier valor de &lt;code&gt;List&lt;/code&gt; a ocupar&amp;aacute; el tama&amp;ntilde;o de un &lt;code&gt;i32&lt;/code&gt; m&amp;aacute;s el tama&amp;ntilde;o de los datos del puntero de un cuadro. Al usar una caja, hemos roto la cadena recursiva infinita, por lo que el compilador puede calcular el tama&amp;ntilde;o que necesita para almacenar un valor de &lt;code&gt;List&lt;/code&gt; . La figura 15-2 muestra c&amp;oacute;mo se ve ahora la variante &lt;code&gt;Cons&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a626d0216123ae4ac45161a1bdf7e2c4de5ee23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variants own the data they hold, so when we create the &lt;code&gt;b&lt;/code&gt; list, &lt;code&gt;a&lt;/code&gt; is moved into &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; owns &lt;code&gt;a&lt;/code&gt;. Then, when we try to use &lt;code&gt;a&lt;/code&gt; again when creating &lt;code&gt;c&lt;/code&gt;, we&amp;rsquo;re not allowed to because &lt;code&gt;a&lt;/code&gt; has been moved.</source>
          <target state="translated">Los &lt;code&gt;Cons&lt;/code&gt; variantes poseer los datos que poseen, por lo que cuando creamos el &lt;code&gt;b&lt;/code&gt; lista, &lt;code&gt;a&lt;/code&gt; se mueve hacia &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; posee &lt;code&gt;a&lt;/code&gt; . Entonces, cuando tratamos de utilizar &lt;code&gt;a&lt;/code&gt; vez m&amp;aacute;s al crear &lt;code&gt;c&lt;/code&gt; , no estamos autorizados a causa &lt;code&gt;a&lt;/code&gt; se ha movido.</target>
        </trans-unit>
        <trans-unit id="0ddcf60586798598b647a102cf947282e0f109f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Context&lt;/code&gt; of an asynchronous task.</source>
          <target state="translated">El &lt;code&gt;Context&lt;/code&gt; de una tarea asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="d2f260e119bb2a2221aaead7149c78bb8d75b87a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait allows you to duplicate a value by only copying bits stored on the stack; no arbitrary code is necessary. See the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Copy&lt;/code&gt; permite duplicar un valor copiando solo los bits almacenados en la pila; no es necesario ning&amp;uacute;n c&amp;oacute;digo arbitrario. Consulte la secci&amp;oacute;n &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Datos solo apilados: Copiar&amp;rdquo;&lt;/a&gt; en el Cap&amp;iacute;tulo 4 para obtener m&amp;aacute;s informaci&amp;oacute;n sobre &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6af89e2c9cf5d947b4b736850c9a97076811fab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait doesn&amp;rsquo;t define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run. That way, all programmers can assume that copying a value will be very fast.</source>
          <target state="translated">El rasgo &lt;code&gt;Copy&lt;/code&gt; no define ning&amp;uacute;n m&amp;eacute;todo para evitar que los programadores sobrecarguen esos m&amp;eacute;todos y violen la suposici&amp;oacute;n de que no se est&amp;aacute; ejecutando c&amp;oacute;digo arbitrario. De esa forma, todos los programadores pueden asumir que copiar un valor ser&amp;aacute; muy r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="d9a9d9ddc02bc50daec8b0c1f2146daf65e918a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is implemented by default only on primitive types. If your type only contains primitive types, you'll be able to implement &lt;code&gt;Copy&lt;/code&gt; on it. Otherwise, it won't be possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">La &lt;code&gt;Copy&lt;/code&gt; rasgo rara vez se requiere; los tipos que implementan &lt;code&gt;Copy&lt;/code&gt; tienen optimizaciones disponibles, lo que significa que no tiene que llamar a &lt;code&gt;clone&lt;/code&gt; , lo que hace que el c&amp;oacute;digo sea m&amp;aacute;s conciso.</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">La estructura &lt;code&gt;Counter&lt;/code&gt; tiene un campo llamado &lt;code&gt;count&lt;/code&gt; . Este campo tiene un valor &lt;code&gt;u32&lt;/code&gt; que har&amp;aacute; un seguimiento de d&amp;oacute;nde estamos en el proceso de iterar de 1 a 5. El campo de &lt;code&gt;count&lt;/code&gt; es privado porque queremos que la implementaci&amp;oacute;n de &lt;code&gt;Counter&lt;/code&gt; administre su valor. La &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n impone el comportamiento de iniciar siempre nuevas instancias con un valor de 0 en el campo de &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">El rasgo &lt;code&gt;Debug&lt;/code&gt; le permite imprimir instancias de un tipo con fines de depuraci&amp;oacute;n, por lo que usted y otros programadores que usan su tipo pueden inspeccionar una instancia en un punto particular de la ejecuci&amp;oacute;n de un programa.</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">El rasgo &lt;code&gt;Debug&lt;/code&gt; habilita el formato de depuraci&amp;oacute;n en cadenas de formato, que indica agregando &lt;code&gt;:?&lt;/code&gt; dentro de &lt;code&gt;{}&lt;/code&gt; marcadores de posici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">El rasgo &lt;code&gt;Debug&lt;/code&gt; es necesario, por ejemplo, en el uso de &lt;code&gt;assert_eq!&lt;/code&gt; macro. Esta macro imprime los valores de las instancias dadas como argumentos si falla la aserci&amp;oacute;n de igualdad para que los programadores puedan ver por qu&amp;eacute; las dos instancias no eran iguales.</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Default::default&lt;/code&gt; se usa com&amp;uacute;nmente en combinaci&amp;oacute;n con la sintaxis de actualizaci&amp;oacute;n de estructura discutida en la secci&amp;oacute;n &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&quot;Creaci&amp;oacute;n de instancias a partir de otras instancias con sintaxis de actualizaci&amp;oacute;n de estructura&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 5. Puede personalizar algunos campos de una estructura y luego establecer y usar una valor predeterminado para el resto de los campos utilizando &lt;code&gt;..Default::default()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Default&lt;/code&gt; permite crear un valor predeterminado para un tipo. Deriving &lt;code&gt;Default&lt;/code&gt; implementa la funci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; . La implementaci&amp;oacute;n derivada de la funci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; llama a la funci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; en cada parte del tipo, lo que significa que todos los campos o valores del tipo tambi&amp;eacute;n deben implementar &lt;code&gt;Default&lt;/code&gt; para derivar &lt;code&gt;Default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">El rasgo &lt;code&gt;Default&lt;/code&gt; para los tipos que pueden tener valores predeterminados significativos.</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Default&lt;/code&gt; es necesario cuando se usa el m&amp;eacute;todo &lt;code&gt;unwrap_or_default&lt;/code&gt; en instancias de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , por ejemplo. Si la &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , el m&amp;eacute;todo &lt;code&gt;unwrap_or_default&lt;/code&gt; devolver&amp;aacute; el resultado de &lt;code&gt;Default::default&lt;/code&gt; para el tipo &lt;code&gt;T&lt;/code&gt; almacenado en la &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;DispatchFromDyn&lt;/code&gt; Rasgo actualmente s&amp;oacute;lo se puede aplicar para este tipo de orden interna de puntero y estructuras que son envoltorios de Newtype alrededor de ellos - es decir, la estructura debe tener s&amp;oacute;lo un campo (excepto para &lt;code&gt;PhantomData&lt;/code&gt; ), y que en s&amp;iacute; campo debe aplicar &lt;code&gt;DispatchFromDyn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">La estructura &lt;code&gt;DraftPost&lt;/code&gt; tiene un m&amp;eacute;todo &lt;code&gt;add_text&lt;/code&gt; , por lo que podemos agregar texto al &lt;code&gt;content&lt;/code&gt; como antes, pero tenga en cuenta que &lt;code&gt;DraftPost&lt;/code&gt; no tiene un m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; definido. Por lo tanto, ahora el programa garantiza que todas las publicaciones comiencen como publicaciones preliminares y que las publicaciones preliminares no tengan su contenido disponible para mostrar. Cualquier intento de eludir estas limitaciones resultar&amp;aacute; en un error del compilador.</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Drop&lt;/code&gt; est&amp;aacute; incluido en el preludio, por lo que no es necesario que lo llevemos al alcance. Implementamos el rasgo &lt;code&gt;Drop&lt;/code&gt; en &lt;code&gt;CustomSmartPointer&lt;/code&gt; y proporcionamos una implementaci&amp;oacute;n para el m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; que llama a &lt;code&gt;println!&lt;/code&gt; . El cuerpo de la &lt;code&gt;drop&lt;/code&gt; la funci&amp;oacute;n es donde se coloque ninguna l&amp;oacute;gica que quer&amp;iacute;a correr cuando una instancia de su tipo fuera de &amp;aacute;mbito. Estamos imprimiendo un texto aqu&amp;iacute; para demostrar cuando Rust llamar&amp;aacute; a &lt;code&gt;drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">El rasgo &lt;code&gt;Eq&lt;/code&gt; no tiene m&amp;eacute;todos. Su prop&amp;oacute;sito es se&amp;ntilde;alar que para cada valor del tipo anotado, el valor es igual a s&amp;iacute; mismo. El rasgo &lt;code&gt;Eq&lt;/code&gt; solo se puede aplicar a tipos que tambi&amp;eacute;n implementan &lt;code&gt;PartialEq&lt;/code&gt; , aunque no todos los tipos que implementan &lt;code&gt;PartialEq&lt;/code&gt; pueden implementar &lt;code&gt;Eq&lt;/code&gt; . Un ejemplo de esto son los tipos de n&amp;uacute;meros de punto flotante: la implementaci&amp;oacute;n de n&amp;uacute;meros de punto flotante establece que dos instancias del valor de no un n&amp;uacute;mero ( &lt;code&gt;NaN&lt;/code&gt; ) no son iguales entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">El par&amp;aacute;metro de tipo &lt;code&gt;F&lt;/code&gt; tambi&amp;eacute;n tiene el atributo &lt;code&gt;Send&lt;/code&gt; y el l&amp;iacute;mite de por vida &lt;code&gt;'static&lt;/code&gt; , que son &amp;uacute;tiles en nuestra situaci&amp;oacute;n: necesitamos &lt;code&gt;Send&lt;/code&gt; para transferir el cierre de un hilo a otro y &lt;code&gt;'static&lt;/code&gt; porque no sabemos cu&amp;aacute;nto tiempo durar&amp;aacute; el hilo tomar para ejecutar. &lt;code&gt;ThreadPool&lt;/code&gt; un m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; en ThreadPool que tomar&amp;aacute; un par&amp;aacute;metro gen&amp;eacute;rico de tipo &lt;code&gt;F&lt;/code&gt; con estos l&amp;iacute;mites:</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro de tipo &lt;code&gt;F&lt;/code&gt; es el que nos interesa aqu&amp;iacute;; el par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; est&amp;aacute; relacionado con el valor de retorno, y eso no nos preocupa. Podemos ver que &lt;code&gt;spawn&lt;/code&gt; utiliza &lt;code&gt;FnOnce&lt;/code&gt; como el rasgo cota &lt;code&gt;F&lt;/code&gt; . Esto es probablemente lo que tambi&amp;eacute;n queremos, porque eventualmente pasaremos el argumento que obtenemos en &lt;code&gt;execute&lt;/code&gt; para &lt;code&gt;spawn&lt;/code&gt; . Podemos estar m&amp;aacute;s seguros de que &lt;code&gt;FnOnce&lt;/code&gt; es el rasgo que queremos usar porque el hilo para ejecutar una solicitud solo ejecutar&amp;aacute; el cierre de esa solicitud una vez, lo que coincide con &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">Los rasgos &lt;code&gt;Fn&lt;/code&gt; los proporciona la biblioteca est&amp;aacute;ndar. Todos los cierres implementan al menos uno de los rasgos: &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; o &lt;code&gt;FnOnce&lt;/code&gt; . Discutiremos la diferencia entre estos rasgos en la secci&amp;oacute;n &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&quot;Capturar el medio ambiente con cierres&quot;&lt;/a&gt; ; en este ejemplo, podemos usar el rasgo &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">El &lt;code&gt;From&lt;/code&gt; tambi&amp;eacute;n es muy &amp;uacute;til al realizar el manejo de errores. Cuando se construye una funci&amp;oacute;n que puede fallar, el tipo de retorno generalmente ser&amp;aacute; de la forma &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . El rasgo &lt;code&gt;From&lt;/code&gt; simplifica el manejo de errores al permitir que una funci&amp;oacute;n devuelva un solo tipo de error que encapsula m&amp;uacute;ltiples tipos de error. Consulte la secci&amp;oacute;n &quot;Ejemplos&quot; y &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;el libro&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">La enumeraci&amp;oacute;n &lt;code&gt;GeneratorState&lt;/code&gt; devuelta por esta funci&amp;oacute;n indica en qu&amp;eacute; estado se encuentra el generador al regresar. Si se devuelve la variante &lt;code&gt;Yielded&lt;/code&gt; , el generador ha alcanzado un punto de suspensi&amp;oacute;n y se ha obtenido un valor. Los generadores en este estado est&amp;aacute;n disponibles para reanudarse en un momento posterior.</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">El rasgo &lt;code&gt;GlobalAlloc&lt;/code&gt; es un rasgo &lt;code&gt;unsafe&lt;/code&gt; por varias razones, y los implementadores deben asegurarse de cumplir con estos contratos:</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Hash&lt;/code&gt; le permite tomar una instancia de un tipo de tama&amp;ntilde;o arbitrario y asignar esa instancia a un valor de tama&amp;ntilde;o fijo usando una funci&amp;oacute;n hash. Deriving &lt;code&gt;Hash&lt;/code&gt; implementa el m&amp;eacute;todo &lt;code&gt;hash&lt;/code&gt; . La implementaci&amp;oacute;n derivada del m&amp;eacute;todo &lt;code&gt;hash&lt;/code&gt; combina el resultado de llamar a &lt;code&gt;hash&lt;/code&gt; en cada una de las partes del tipo, lo que significa que todos los campos o valores tambi&amp;eacute;n deben implementar &lt;code&gt;Hash&lt;/code&gt; para derivar &lt;code&gt;Hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">El rasgo &lt;code&gt;Iterator&lt;/code&gt; tiene varios m&amp;eacute;todos diferentes con implementaciones predeterminadas proporcionadas por la biblioteca est&amp;aacute;ndar; puede obtener informaci&amp;oacute;n sobre estos m&amp;eacute;todos buscando en la documentaci&amp;oacute;n API de la biblioteca est&amp;aacute;ndar el rasgo &lt;code&gt;Iterator&lt;/code&gt; . Algunos de estos m&amp;eacute;todos llaman &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo siguiente en su definici&amp;oacute;n, por lo que debe implementar el m&amp;eacute;todo &lt;code&gt;next&lt;/code&gt; al implementar el rasgo &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Iterator&lt;/code&gt; solo requiere que los implementadores definan un m&amp;eacute;todo: el m&amp;eacute;todo &lt;code&gt;next&lt;/code&gt; , que devuelve un elemento del iterador a la vez envuelto en &lt;code&gt;Some&lt;/code&gt; y, cuando finaliza la iteraci&amp;oacute;n, devuelve &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">El &lt;code&gt;LinkedList&lt;/code&gt; permite empujar y hacer estallar los elementos en cada extremo en tiempo constante.</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;LowerExp&lt;/code&gt; debe formatear su salida en notaci&amp;oacute;n cient&amp;iacute;fica con una &lt;code&gt;e&lt;/code&gt; min&amp;uacute;scula .</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">El rasgo &lt;code&gt;LowerHex&lt;/code&gt; debe formatear su salida como un n&amp;uacute;mero en hexadecimal, con &lt;code&gt;a&lt;/code&gt; hasta una &lt;code&gt;f&lt;/code&gt; en min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">El rasgo &lt;code&gt;Octal&lt;/code&gt; debe formatear su salida como un n&amp;uacute;mero en base 8.</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La enumeraci&amp;oacute;n &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; es tan &amp;uacute;til que incluso se incluye en el preludio; no es necesario incluirlo en el &amp;aacute;mbito de forma expl&amp;iacute;cita. Adem&amp;aacute;s, tambi&amp;eacute;n lo son sus variantes: puede usar &lt;code&gt;Some&lt;/code&gt; y &lt;code&gt;None&lt;/code&gt; directamente sin el prefijo &lt;code&gt;Option::&lt;/code&gt; . La enumeraci&amp;oacute;n &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; sigue siendo solo una enumeraci&amp;oacute;n regular, y &lt;code&gt;Some(T)&lt;/code&gt; y &lt;code&gt;None&lt;/code&gt; siguen siendo variantes del tipo &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">El tipo de &lt;code&gt;Option&lt;/code&gt; . Consulte &lt;a href=&quot;index&quot;&gt;la documentaci&amp;oacute;n de nivel de m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Ord&lt;/code&gt; le permite saber que para dos valores cualesquiera del tipo anotado, existir&amp;aacute; un orden v&amp;aacute;lido. El rasgo &lt;code&gt;Ord&lt;/code&gt; implementa el m&amp;eacute;todo &lt;code&gt;cmp&lt;/code&gt; , que devuelve un &lt;code&gt;Ordering&lt;/code&gt; en lugar de una &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; porque siempre ser&amp;aacute; posible un pedido v&amp;aacute;lido. Solo puede aplicar el rasgo &lt;code&gt;Ord&lt;/code&gt; a tipos que tambi&amp;eacute;n implementan &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Eq&lt;/code&gt; (y &lt;code&gt;Eq&lt;/code&gt; requiere &lt;code&gt;PartialEq&lt;/code&gt; ). Cuando se deriva de estructuras y enumeraciones, &lt;code&gt;cmp&lt;/code&gt; se comporta de la misma manera que la implementaci&amp;oacute;n derivada de &lt;code&gt;partial_cmp&lt;/code&gt; con &lt;code&gt;PartialOrd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">Los &lt;code&gt;Orphan Check&lt;/code&gt; estados que cada rasgo aplicaci&amp;oacute;n debe cumplir alguna de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialEq&lt;/code&gt; le permite comparar instancias de un tipo para verificar la igualdad y habilita el uso de los operadores &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialEq&lt;/code&gt; es necesario, por ejemplo, con el uso de &lt;code&gt;assert_eq!&lt;/code&gt; macro, que debe poder comparar dos instancias de un tipo para determinar la igualdad.</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialOrd&lt;/code&gt; le permite comparar instancias de un tipo con fines de clasificaci&amp;oacute;n. Un tipo que implementa &lt;code&gt;PartialOrd&lt;/code&gt; se puede usar con los operadores &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; y &lt;code&gt;&amp;gt;=&lt;/code&gt; . Solo puede aplicar el rasgo &lt;code&gt;PartialOrd&lt;/code&gt; a tipos que tambi&amp;eacute;n implementan &lt;code&gt;PartialEq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialOrd&lt;/code&gt; es necesario, por ejemplo, para el m&amp;eacute;todo &lt;code&gt;gen_range&lt;/code&gt; de la caja &lt;code&gt;rand&lt;/code&gt; que genera un valor aleatorio en el rango especificado por un valor bajo y un valor alto.</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">El rasgo &lt;code&gt;Pointer&lt;/code&gt; debe formatear su salida como una ubicaci&amp;oacute;n de memoria. Esto se presenta com&amp;uacute;nmente como hexadecimal.</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;gt;= start&lt;/code&gt; y &lt;code&gt;x &amp;lt; end&lt;/code&gt; . Est&amp;aacute; vac&amp;iacute;o a menos que &lt;code&gt;start &amp;lt; end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;RangeFrom&lt;/code&gt; &lt;code&gt;start..&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;gt;= start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;start..=end&lt;/code&gt; &lt;code&gt;RangeInclusive&lt;/code&gt; .. = end contiene todos los valores con &lt;code&gt;x &amp;gt;= start&lt;/code&gt; y &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . Est&amp;aacute; vac&amp;iacute;o a menos que &lt;code&gt;start &amp;lt;= end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">El &lt;code&gt;RangeTo&lt;/code&gt; &lt;code&gt;..end&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;lt; end&lt;/code&gt; . No puede servir como &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; porque no tiene un punto de partida.</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">El &lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . No puede servir como &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; porque no tiene un punto de partida.</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">La sintaxis &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; es la m&amp;aacute;s idiom&amp;aacute;tica porque transmite m&amp;aacute;s expl&amp;iacute;citamente el significado del c&amp;oacute;digo. En el ejemplo anterior, esta sintaxis facilita ver que este c&amp;oacute;digo est&amp;aacute; creando una nueva referencia en lugar de copiar todo el contenido de foo.</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">El &lt;code&gt;Read&lt;/code&gt; rasgo permite la lectura de bytes de una fuente.</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">El &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; mantiene un registro de cu&amp;aacute;ntas &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; punteros inteligentes son actualmente activo. Cada vez que llamamos a &lt;code&gt;borrow&lt;/code&gt; , &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; aumenta su recuento de cu&amp;aacute;ntos pr&amp;eacute;stamos inmutables est&amp;aacute;n activos. Cuando un valor de &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; sale de su alcance, el recuento de pr&amp;eacute;stamos inmutables se reduce en uno. Al igual que las reglas de pr&amp;eacute;stamos en tiempo de compilaci&amp;oacute;n, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; nos permite tener muchos pr&amp;eacute;stamos inmutables o un pr&amp;eacute;stamo mutable en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">El &lt;code&gt;RefCell&lt;/code&gt; ya ha sido tomada de manera inmutable, por lo que este no puede fallar.</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">El &lt;code&gt;RefCell&lt;/code&gt; ya est&amp;aacute; tomada mutably, as&amp;iacute; que esto no puede fallar.</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">El &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; se repite mucho. Como tal, &lt;code&gt;std::io&lt;/code&gt; tiene este tipo de declaraci&amp;oacute;n de alias:</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">El &lt;code&gt;Result&lt;/code&gt; de enumeraci&amp;oacute;n es gen&amp;eacute;rico m&amp;aacute;s de dos tipos, &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;E&lt;/code&gt; , y tiene dos variantes: &lt;code&gt;Ok&lt;/code&gt; , que tiene un valor de tipo &lt;code&gt;T&lt;/code&gt; , y &lt;code&gt;Err&lt;/code&gt; , que tiene un valor de tipo &lt;code&gt;E&lt;/code&gt; . Esta definici&amp;oacute;n hace que sea conveniente usar la enumeraci&amp;oacute;n &lt;code&gt;Result&lt;/code&gt; en cualquier lugar donde tengamos una operaci&amp;oacute;n que podr&amp;iacute;a tener &amp;eacute;xito (devolver un valor de alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; ) o fallar (devolver un error de alg&amp;uacute;n tipo &lt;code&gt;E&lt;/code&gt; ). De hecho, esto es lo que usamos para abrir un archivo en el Listado 9-3, donde &lt;code&gt;T&lt;/code&gt; se complet&amp;oacute; con el tipo &lt;code&gt;std::fs::File&lt;/code&gt; cuando el archivo se abri&amp;oacute; correctamente y &lt;code&gt;E&lt;/code&gt; se complet&amp;oacute; con el tipo &lt;code&gt;std::io::Error&lt;/code&gt; cuando hubo problemas para abrir el archivo.</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">Los tipos de &lt;code&gt;Result&lt;/code&gt; son &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumeraciones&lt;/em&gt;&lt;/a&gt; , a menudo denominadas &lt;em&gt;enumeraciones&lt;/em&gt; . Una enumeraci&amp;oacute;n es un tipo que puede tener un conjunto fijo de valores, y esos valores se denominan &lt;em&gt;variantes de&lt;/em&gt; la enumeraci&amp;oacute;n . El cap&amp;iacute;tulo 6 cubrir&amp;aacute; las enumeraciones con m&amp;aacute;s detalle.</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">El rasgo de &lt;code&gt;Seek&lt;/code&gt; proporciona un cursor que se puede mover dentro de una secuencia de bytes.</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">La palabra clave &lt;code&gt;Self&lt;/code&gt; es un alias para el tipo en el que estamos implementando los rasgos o m&amp;eacute;todos. Los objetos de rasgo deben ser seguros para objetos porque una vez que ha usado un objeto de rasgo, Rust ya no sabe el tipo concreto que est&amp;aacute; implementando ese rasgo. Si un m&amp;eacute;todo de rasgo devuelve el tipo &lt;code&gt;Self&lt;/code&gt; concreto , pero un objeto rasgo olvida el tipo exacto que es &lt;code&gt;Self&lt;/code&gt; , no hay forma de que el m&amp;eacute;todo pueda usar el tipo concreto original. Lo mismo ocurre con los par&amp;aacute;metros de tipo gen&amp;eacute;rico que se completan con par&amp;aacute;metros de tipo concreto cuando se utiliza el rasgo: los tipos concretos pasan a formar parte del tipo que implementa el rasgo. Cuando el tipo se olvida mediante el uso de un objeto de rasgo, no hay forma de saber con qu&amp;eacute; tipos completar los par&amp;aacute;metros de tipo gen&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">La palabra clave &lt;code&gt;Self&lt;/code&gt; representa el tipo actual, lo que explica por qu&amp;eacute; solo se puede usar dentro de una definici&amp;oacute;n de impl, rasgo o tipo. Da acceso a los elementos asociados de un tipo:</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">La palabra clave &lt;code&gt;Self&lt;/code&gt; se us&amp;oacute; fuera de una definici&amp;oacute;n impl&amp;iacute;cita, de rasgo o de tipo.</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">El t&amp;eacute;rmino &lt;code&gt;Self&lt;/code&gt; se puede reemplazar con el tipo que se est&amp;aacute; implementando.</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">El rasgo de marcador de &lt;code&gt;Send&lt;/code&gt; indica que la propiedad del tipo que implementa el &lt;code&gt;Send&lt;/code&gt; se puede transferir entre subprocesos. Casi todos los tipos de Rust son &lt;code&gt;Send&lt;/code&gt; , pero hay algunas excepciones, incluido &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; : esto no puede ser &lt;code&gt;Send&lt;/code&gt; porque si clon&amp;oacute; un valor &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; e intent&amp;oacute; transferir la propiedad del clon a otro hilo, ambos hilos podr&amp;iacute;an actualizar el recuento de referencias al mismo tiempo. Por esta raz&amp;oacute;n, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute; implementado para su uso en situaciones de un solo subproceso en las que no desea pagar la penalizaci&amp;oacute;n de rendimiento seguro para subprocesos.</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">El rasgo &lt;code&gt;Sized&lt;/code&gt; es un rasgo especial incorporado al compilador para tipos con un tama&amp;ntilde;o constante conocido en tiempo de compilaci&amp;oacute;n. Este rasgo se implementa autom&amp;aacute;ticamente para los tipos seg&amp;uacute;n lo necesite el compilador, y actualmente no est&amp;aacute; permitido implementarlo expl&amp;iacute;citamente para un tipo.</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">El valor &lt;code&gt;Some(5)&lt;/code&gt; no coincide con el patr&amp;oacute;n &lt;code&gt;None&lt;/code&gt; , as&amp;iacute; que continuamos con el siguiente brazo.</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">El rasgo de &lt;code&gt;State&lt;/code&gt; define el comportamiento compartido por diferentes estados de publicaci&amp;oacute;n, y los estados &lt;code&gt;Draft&lt;/code&gt; , &lt;code&gt;PendingReview&lt;/code&gt; y &lt;code&gt;Published&lt;/code&gt; implementar&amp;aacute;n el rasgo de &lt;code&gt;State&lt;/code&gt; . Por ahora, el rasgo no tiene ning&amp;uacute;n m&amp;eacute;todo, y comenzaremos definiendo solo el estado &lt;code&gt;Draft&lt;/code&gt; porque ese es el estado en el que queremos que comience una publicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">El tipo &lt;code&gt;String&lt;/code&gt; implementa el rasgo &lt;code&gt;Clone&lt;/code&gt; , y cuando llamamos al m&amp;eacute;todo &lt;code&gt;clone&lt;/code&gt; en una instancia de &lt;code&gt;String&lt;/code&gt; , obtenemos una instancia de &lt;code&gt;String&lt;/code&gt; . De manera similar, si llamamos a &lt;code&gt;clone&lt;/code&gt; en una instancia de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , obtenemos una instancia de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . La firma del &lt;code&gt;clone&lt;/code&gt; necesita saber qu&amp;eacute; tipo sustituir&amp;aacute; a &lt;code&gt;Self&lt;/code&gt; , porque ese es el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de &lt;code&gt;String&lt;/code&gt; es el tipo de cadena m&amp;aacute;s com&amp;uacute;n que tiene propiedad sobre el contenido de la cadena. Tiene una estrecha relaci&amp;oacute;n con su contraparte prestada, la &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; primitiva .</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">El tipo de &lt;code&gt;String&lt;/code&gt; , que es proporcionado por la biblioteca est&amp;aacute;ndar de Rust en lugar de codificado en el lenguaje principal, es un tipo de cadena codificada en UTF-8, de propiedad, que puede crecer, mutable. Cuando los rust&amp;aacute;ceos se refieren a &quot;cadenas&quot; en Rust, por lo general se refieren a los tipos &lt;code&gt;String&lt;/code&gt; y slice &lt;code&gt;&amp;amp;str&lt;/code&gt; , no solo a uno de esos tipos. Aunque esta secci&amp;oacute;n trata principalmente sobre &lt;code&gt;String&lt;/code&gt; , ambos tipos se utilizan mucho en la biblioteca est&amp;aacute;ndar de Rust, y tanto &lt;code&gt;String&lt;/code&gt; como los cortes de cadena est&amp;aacute;n codificados en UTF-8.</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">Los rasgos de &lt;code&gt;Sync&lt;/code&gt; y &lt;code&gt;Send&lt;/code&gt; , que ampl&amp;iacute;an las garant&amp;iacute;as de concurrencia de Rust a los tipos definidos por el usuario, as&amp;iacute; como a los tipos proporcionados por la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">El rasgo del marcador de &lt;code&gt;Sync&lt;/code&gt; indica que es seguro que el tipo que implementa la &lt;code&gt;Sync&lt;/code&gt; sea ​​referenciado desde varios subprocesos. En otras palabras, cualquier tipo &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; si &lt;code&gt;&amp;amp;T&lt;/code&gt; (una referencia a &lt;code&gt;T&lt;/code&gt; ) es &lt;code&gt;Send&lt;/code&gt; , lo que significa que la referencia se puede enviar de forma segura a otro hilo. Al igual que en &lt;code&gt;Send&lt;/code&gt; , los tipos primitivos son &lt;code&gt;Sync&lt;/code&gt; y los tipos compuestos en su totalidad por tipos que son &lt;code&gt;Sync&lt;/code&gt; tambi&amp;eacute;n son &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">La &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;E&lt;/code&gt; son par&amp;aacute;metros de tipo gen&amp;eacute;rico: hablaremos de los gen&amp;eacute;ricos en m&amp;aacute;s detalle en el cap&amp;iacute;tulo 10. Lo que hay que saber en este momento es que &lt;code&gt;T&lt;/code&gt; representa el tipo del valor que ser&amp;aacute; devuelto en un caso de &amp;eacute;xito dentro de la &lt;code&gt;Ok&lt;/code&gt; variante, y &lt;code&gt;E&lt;/code&gt; representa el tipo de error que se devolver&amp;aacute; en caso de falla dentro de la variante &lt;code&gt;Err&lt;/code&gt; . Debido a que &lt;code&gt;Result&lt;/code&gt; tiene estos par&amp;aacute;metros de tipo gen&amp;eacute;rico, podemos usar el tipo &lt;code&gt;Result&lt;/code&gt; y las funciones que la biblioteca est&amp;aacute;ndar ha definido en &amp;eacute;l en muchas situaciones diferentes donde el valor exitoso y el valor de error que queremos devolver pueden diferir.</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">El tipo de &lt;code&gt;Thread&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">El &lt;code&gt;ThreadPool&lt;/code&gt; crear&amp;aacute; un canal y mantenerse en el lado emisor del canal.</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">La API de &lt;code&gt;UnsafeCell&lt;/code&gt; en s&amp;iacute; es t&amp;eacute;cnicamente muy simple: le da un puntero &lt;code&gt;*mut T&lt;/code&gt; sin formato a su contenido. Depende de &lt;em&gt;usted,&lt;/em&gt; como dise&amp;ntilde;ador de abstracci&amp;oacute;n, utilizar correctamente ese puntero sin procesar.</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;UpperExp&lt;/code&gt; debe formatear su salida en notaci&amp;oacute;n cient&amp;iacute;fica con una &lt;code&gt;E&lt;/code&gt; may&amp;uacute;scula .</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">El rasgo &lt;code&gt;UpperHex&lt;/code&gt; debe formatear su salida como un n&amp;uacute;mero en hexadecimal, con &lt;code&gt;A&lt;/code&gt; a &lt;code&gt;F&lt;/code&gt; en may&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">El tipo &lt;code&gt;Vec&lt;/code&gt; permite acceder a valores por &amp;iacute;ndice, ya que implementa el rasgo &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; . Un ejemplo ser&amp;aacute; m&amp;aacute;s expl&amp;iacute;cito:</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">El patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; coincidir&amp;aacute; con cualquier valor. Al ponerlo despu&amp;eacute;s de nuestros otros brazos, &lt;code&gt;_&lt;/code&gt; coincidir&amp;aacute; con todos los casos posibles que no se hayan especificado antes. El &lt;code&gt;()&lt;/code&gt; es solo el valor unitario, por lo que no suceder&amp;aacute; nada en el caso &lt;code&gt;_&lt;/code&gt; . Como resultado, podemos decir que no queremos hacer nada para todos los valores posibles que no enumeramos antes del marcador de posici&amp;oacute;n &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;abort&lt;/code&gt; o finaliza el proceso, por lo que el destructor no se ejecutar&amp;aacute; en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">El &lt;code&gt;add&lt;/code&gt; m&amp;eacute;todo agrega los &lt;code&gt;x&lt;/code&gt; valores de dos &lt;code&gt;Point&lt;/code&gt; instancias y las &lt;code&gt;y&lt;/code&gt; valores de dos &lt;code&gt;Point&lt;/code&gt; casos para crear un nuevo &lt;code&gt;Point&lt;/code&gt; . El rasgo &lt;code&gt;Add&lt;/code&gt; tiene un tipo asociado llamado &lt;code&gt;Output&lt;/code&gt; que determina el tipo devuelto por el m&amp;eacute;todo &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;add_text&lt;/code&gt; toma una referencia mutable a &lt;code&gt;self&lt;/code&gt; , porque estamos cambiando la instancia de &lt;code&gt;Post&lt;/code&gt; en la que llamamos &lt;code&gt;add_text&lt;/code&gt; . Luego llamamos &lt;code&gt;push_str&lt;/code&gt; en la &lt;code&gt;String&lt;/code&gt; en el &lt;code&gt;content&lt;/code&gt; y pasamos el argumento de &lt;code&gt;text&lt;/code&gt; o para agregarlo al &lt;code&gt;content&lt;/code&gt; guardado . Este comportamiento no depende del estado en el que se encuentre la publicaci&amp;oacute;n, por lo que no forma parte del patr&amp;oacute;n de estado. El m&amp;eacute;todo &lt;code&gt;add_text&lt;/code&gt; no interact&amp;uacute;a en absoluto con el campo de &lt;code&gt;state&lt;/code&gt; , pero es parte del comportamiento que queremos apoyar.</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">Los modificadores de &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; se pueden usar para aumentar o disminuir respectivamente la alineaci&amp;oacute;n de &lt;code&gt;struct&lt;/code&gt; y &lt;code&gt;union&lt;/code&gt; es . &lt;code&gt;packed&lt;/code&gt; tambi&amp;eacute;n puede alterar el relleno entre campos.</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">Los modificadores de &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; no se pueden aplicar al mismo tipo y un tipo &lt;code&gt;packed&lt;/code&gt; no puede contener transitivamente otro tipo de &lt;code&gt;align&lt;/code&gt; . &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; solo se pueden aplicar a las representaciones &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;predeterminadas&lt;/a&gt; y en &lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">El modificador de &lt;code&gt;align&lt;/code&gt; tambi&amp;eacute;n se puede aplicar en una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n . Cuando es as&amp;iacute;, el efecto sobre la alineaci&amp;oacute;n de la &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n es el mismo que si la &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n estuviera envuelta en una &lt;code&gt;struct&lt;/code&gt; newtype con el mismo modificador de &lt;code&gt;align&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El &lt;code&gt;amt&lt;/code&gt; debe ser &lt;code&gt;&amp;lt;=&lt;/code&gt; el n&amp;uacute;mero de bytes en el b&amp;uacute;fer devuelto por &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;approve&lt;/code&gt; ser&amp;aacute; similar al m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; : establecer&amp;aacute; el &lt;code&gt;state&lt;/code&gt; en el valor que el estado actual dice que deber&amp;iacute;a tener cuando se apruebe ese estado, como se muestra en el Listado 17-16:</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;area&lt;/code&gt; accede a los campos de &lt;code&gt;width&lt;/code&gt; y &lt;code&gt;height&lt;/code&gt; de la instancia de &lt;code&gt;Rectangle&lt;/code&gt; . Nuestra firma de funci&amp;oacute;n para el &lt;code&gt;area&lt;/code&gt; ahora dice exactamente lo que queremos decir: calcular el &amp;aacute;rea de &lt;code&gt;Rectangle&lt;/code&gt; , usando sus campos de &lt;code&gt;width&lt;/code&gt; y &lt;code&gt;height&lt;/code&gt; . Esto transmite que el ancho y el alto est&amp;aacute;n relacionados entre s&amp;iacute;, y da nombres descriptivos a los valores en lugar de utilizar los valores de &amp;iacute;ndice de tupla de &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; . Esta es una victoria por claridad.</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">El &lt;code&gt;area&lt;/code&gt; funci&amp;oacute;n debe calcular el &amp;aacute;rea de un rect&amp;aacute;ngulo, pero la funci&amp;oacute;n que escribimos tiene dos par&amp;aacute;metros. Los par&amp;aacute;metros est&amp;aacute;n relacionados, pero eso no se expresa en ninguna parte de nuestro programa. Ser&amp;iacute;a m&amp;aacute;s legible y manejable agrupar el ancho y el alto. Ya hemos discutido una forma en que podr&amp;iacute;amos hacer eso en la secci&amp;oacute;n &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&quot;El tipo de tupla&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 3: usando tuplas.</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">Los usuarios de cajas de &lt;code&gt;art&lt;/code&gt; e a&amp;uacute;n pueden ver y usar la estructura interna del Listado 14-3 como se muestra en el Listado 14-4, o pueden usar la estructura m&amp;aacute;s conveniente en el Listado 14-5, como se muestra en el Listado 14-6:</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">La palabra clave &lt;code&gt;as&lt;/code&gt; se puede utilizar para cambiar el nombre de la caja en su proyecto. Si un nombre de caja incluye un gui&amp;oacute;n, se importa impl&amp;iacute;citamente y los guiones se reemplazan por guiones bajos.</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;assert!&lt;/code&gt; La macro, proporcionada por la biblioteca est&amp;aacute;ndar, es &amp;uacute;til cuando desea asegurarse de que alguna condici&amp;oacute;n en una prueba se eval&amp;uacute;e como &lt;code&gt;true&lt;/code&gt; . &amp;iexcl;Damos el &lt;code&gt;assert!&lt;/code&gt; macro un argumento que se eval&amp;uacute;a como un booleano. Si el valor es &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; no hace nada y pasa la prueba. Si el valor es &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; macro llama al &lt;code&gt;panic!&lt;/code&gt; macro, que hace que la prueba falle. &amp;iexcl;Usando la &lt;code&gt;assert!&lt;/code&gt; macro nos ayuda a comprobar que nuestro c&amp;oacute;digo funciona de la manera que pretendemos.</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">El &lt;code&gt;assert_ne!&lt;/code&gt; La macro pasar&amp;aacute; si los dos valores que le damos no son iguales y fallar&amp;aacute;n si son iguales. Esta macro es m&amp;aacute;s &amp;uacute;til para los casos en los que no estamos seguros de cu&amp;aacute;l &lt;em&gt;ser&amp;aacute;&lt;/em&gt; un valor , pero sabemos cu&amp;aacute;l &lt;em&gt;ser&amp;aacute;&lt;/em&gt; el valor definitivamente si nuestro c&amp;oacute;digo funciona como pretendemos. Por ejemplo, si estamos probando una funci&amp;oacute;n que est&amp;aacute; garantizada para cambiar su entrada de alguna manera, pero la forma en que se cambia la entrada depende del d&amp;iacute;a de la semana en que ejecutamos nuestras pruebas, lo mejor para afirmar podr&amp;iacute;a ser que la salida de la funci&amp;oacute;n no es igual a la entrada.</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;bind&lt;/code&gt; en este escenario funciona como la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n en el sentido de que devolver&amp;aacute; una nueva instancia de &lt;code&gt;TcpListener&lt;/code&gt; . La raz&amp;oacute;n por la que la funci&amp;oacute;n se llama &lt;code&gt;bind&lt;/code&gt; es que en las redes, conectarse a un puerto para escuchar se conoce como &quot;vinculaci&amp;oacute;n a un puerto&quot;.</target>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">El &lt;code&gt;bind&lt;/code&gt; funci&amp;oacute;n devuelve un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , lo que indica que la uni&amp;oacute;n puede fallar. Por ejemplo, conectarse al puerto 80 requiere privilegios de administrador (los no administradores pueden escuchar solo en puertos superiores a 1024), por lo que si intent&amp;aacute;ramos conectarnos al puerto 80 sin ser un administrador, la vinculaci&amp;oacute;n no funcionar&amp;iacute;a. Como otro ejemplo, el enlace no funcionar&amp;iacute;a si ejecut&amp;aacute;ramos dos instancias de nuestro programa y, por lo tanto, tuvi&amp;eacute;ramos dos programas escuchando el mismo puerto. Debido a que estamos escribiendo un servidor b&amp;aacute;sico solo con fines de aprendizaje, no nos preocuparemos por manejar este tipo de errores; en su lugar, usamos &lt;code&gt;unwrap&lt;/code&gt; para detener el programa si ocurren errores.</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">El &lt;code&gt;bool&lt;/code&gt; representa un valor, que solo puede ser &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . Si convierte un &lt;code&gt;bool&lt;/code&gt; en un n&amp;uacute;mero entero, &lt;code&gt;true&lt;/code&gt; ser&amp;aacute; 1 y &lt;code&gt;false&lt;/code&gt; ser&amp;aacute; 0.</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;bool&lt;/code&gt; es un tipo de datos que puede ser &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . El tipo booleano usa un byte de memoria. Se utiliza en comparaciones y operaciones bit a bit como &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; y &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;break&lt;/code&gt; puede tomar un argumento (que ser&amp;aacute; el valor de la expresi&amp;oacute;n de bucle si se ejecuta la instrucci&amp;oacute;n &lt;code&gt;break&lt;/code&gt; ) en bucles de &lt;code&gt;loop&lt;/code&gt; , pero no &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; o &lt;code&gt;while let&lt;/code&gt; bucles.</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;bytes&lt;/code&gt; devuelve cada byte sin procesar, que podr&amp;iacute;a ser apropiado para su dominio:</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; devuelve un booleano, lo que significa que es un caso de uso perfecto para la &lt;code&gt;assert!&lt;/code&gt; macro. En el Listado 11-6, escribimos una prueba que ejercita el m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; creando una instancia de &lt;code&gt;Rectangle&lt;/code&gt; que tiene un ancho de 8 y una altura de 7 y afirmando que puede contener otra instancia de &lt;code&gt;Rectangle&lt;/code&gt; que tiene un ancho de 5 y una altura de 1.</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">El comando de &lt;code&gt;cargo install&lt;/code&gt; permite instalar y usar cajas binarias localmente. Esto no pretende reemplazar los paquetes del sistema; est&amp;aacute; destinado a ser una forma conveniente para que los desarrolladores de Rust instalen herramientas que otros han compartido en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; . Tenga en cuenta que solo puede instalar paquetes que tengan destinos binarios. Un &lt;em&gt;destino binario&lt;/em&gt; es el programa ejecutable que se crea si la caja tiene un archivo &lt;em&gt;src / main.rs&lt;/em&gt; u otro archivo especificado como binario, a diferencia de un destino de biblioteca que no se puede ejecutar por s&amp;iacute; solo pero es adecuado para incluirlo en otros programas. Por lo general, las cajas tienen informaci&amp;oacute;n en el archivo &lt;em&gt;README&lt;/em&gt; sobre si una caja es una biblioteca, tiene un objetivo binario o ambos.</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">El comando de &lt;code&gt;cargo test&lt;/code&gt; ejecuta todas las pruebas en nuestro proyecto, como se muestra en el Listado 11-2.</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;cfg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">El atributo &lt;code&gt;cfg&lt;/code&gt; est&amp;aacute; permitido en cualquier lugar donde se permitan atributos.</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">El atributo &lt;code&gt;cfg&lt;/code&gt; admite solo tres tipos de predicados:</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">La macro &lt;code&gt;cfg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">El &lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;cfg&lt;/code&gt; incluye condicionalmente el elemento al que est&amp;aacute; asociado en funci&amp;oacute;n de un predicado de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;cfg_attr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">El atributo &lt;code&gt;cfg_attr&lt;/code&gt; est&amp;aacute; permitido en cualquier lugar donde se permitan atributos.</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">El &lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;cfg_attr&lt;/code&gt; incluye condicionalmente &lt;a href=&quot;attributes&quot;&gt;atributos&lt;/a&gt; basados ​​en un predicado de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">El tipo &lt;code&gt;char&lt;/code&gt; representa un solo car&amp;aacute;cter. M&amp;aacute;s espec&amp;iacute;ficamente, dado que 'car&amp;aacute;cter' no es un concepto bien definido en Unicode, &lt;code&gt;char&lt;/code&gt; es un ' &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;valor escalar Unicode&lt;/a&gt; ', que es similar, pero no lo mismo, a un ' &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;punto de c&amp;oacute;digo Unicode&lt;/a&gt; '.</target>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">Los &lt;a href=&quot;../attributes&quot;&gt;atributos &lt;/a&gt; &lt;code&gt;cold&lt;/code&gt; e &lt;code&gt;inline&lt;/code&gt; brindan sugerencias para generar c&amp;oacute;digo de una manera que puede ser m&amp;aacute;s r&amp;aacute;pida de lo que har&amp;iacute;a sin la pista. Los atributos son solo sugerencias y pueden ignorarse.</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;cold&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">La &lt;code&gt;const&lt;/code&gt; palabra clave se utiliza tambi&amp;eacute;n en punteros primas en combinaci&amp;oacute;n con &lt;code&gt;mut&lt;/code&gt; , como se ve en &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; . Se puede leer m&amp;aacute;s sobre eso en la parte primitiva del &lt;a href=&quot;primitive.pointer&quot;&gt;puntero&lt;/a&gt; de los documentos de Rust.</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">La caja del &lt;code&gt;core&lt;/code&gt; siempre se agrega al preludio externo. El &lt;code&gt;std&lt;/code&gt; caj&amp;oacute;n se a&amp;ntilde;ade siempre y cuando el &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt; atributo no se especifica en la ra&amp;iacute;z del caj&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;crate_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">El puntero de &lt;code&gt;data&lt;/code&gt; se puede utilizar para almacenar datos arbitrarios seg&amp;uacute;n lo requiera el ejecutor. Esto podr&amp;iacute;a ser, por ejemplo, un puntero borrado a un &lt;code&gt;Arc&lt;/code&gt; que est&amp;aacute; asociado con la tarea. El valor de este puntero se pasar&amp;aacute; a todas las funciones que forman parte de &lt;code&gt;vtable&lt;/code&gt; como primer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">La macro &lt;code&gt;dbg!(..)&lt;/code&gt; mueve la entrada:</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">El &lt;code&gt;dbg!&lt;/code&gt; La macro funciona exactamente igual en las versiones de lanzamiento. Esto es &amp;uacute;til cuando se depuran problemas que solo ocurren en compilaciones de lanzamiento o cuando la depuraci&amp;oacute;n en modo de lanzamiento es significativamente m&amp;aacute;s r&amp;aacute;pida.</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">El atributo &lt;code&gt;deprecated&lt;/code&gt; tiene varias formas:</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">El atributo &lt;code&gt;deprecated&lt;/code&gt; se puede aplicar a cualquier &lt;a href=&quot;../items&quot;&gt;elemento&lt;/a&gt; , elemento de &lt;a href=&quot;../items/traits&quot;&gt;rasgo&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt;variante de enumeraci&amp;oacute;n&lt;/a&gt; , &lt;a href=&quot;../items/structs&quot;&gt;campo de estructura&lt;/a&gt; o &lt;a href=&quot;../items/external-blocks&quot;&gt;elemento de bloque externo&lt;/a&gt; . No se puede aplicar a &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;elementos de implementaci&amp;oacute;n de rasgos&lt;/a&gt; . Cuando se aplica a un elemento que contiene otros elementos, como un &lt;a href=&quot;../items/modules&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; o una &lt;a href=&quot;../items/implementations&quot;&gt;implementaci&amp;oacute;n&lt;/a&gt; , todos los elementos secundarios heredan el atributo de obsolescencia.</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">El &lt;code&gt;dev&lt;/code&gt; y &lt;code&gt;release&lt;/code&gt; se muestra en esta salida acumulaci&amp;oacute;n indican que el compilador est&amp;aacute; utilizando diferentes perfiles.</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;drop&lt;/code&gt; se llama cuando &lt;code&gt;_x&lt;/code&gt; sale del alcance y, por lo tanto, las impresiones &lt;code&gt;main&lt;/code&gt; &lt;code&gt;Dropping!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico de directorio que apunta a la ruta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico de archivo que apunta a la ruta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace que apunta a la ruta &lt;code&gt;src&lt;/code&gt; . Tenga en cuenta que los sistemas a menudo requieren que estas dos rutas est&amp;eacute;n ubicadas en el mismo sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico que apunta a la ruta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico que apunta a la ruta &lt;code&gt;src&lt;/code&gt; . En Windows, ser&amp;aacute; un enlace simb&amp;oacute;lico de archivo, no un enlace simb&amp;oacute;lico de directorio; por esta raz&amp;oacute;n, el &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt;espec&amp;iacute;ficos de la plataforma deben usarse en su lugar para hacer expl&amp;iacute;cita la intenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">La clave de &lt;code&gt;edition&lt;/code&gt; en &lt;em&gt;Cargo.toml&lt;/em&gt; indica qu&amp;eacute; edici&amp;oacute;n debe usar el compilador para su c&amp;oacute;digo. Si la clave no existe, Rust usa &lt;code&gt;2015&lt;/code&gt; como valor de edici&amp;oacute;n por razones de compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">La API de &lt;code&gt;entry&lt;/code&gt; est&amp;aacute; destinada a proporcionar un mecanismo eficiente para manipular el contenido de un mapa condicionalmente en la presencia de una clave o no. El principal caso de uso motivador para esto es proporcionar mapas acumuladores eficientes. Por ejemplo, si uno desea mantener un recuento del n&amp;uacute;mero de veces que se ha visto cada clave, tendr&amp;aacute; que realizar alguna l&amp;oacute;gica condicional sobre si esta es la primera vez que se ha visto la clave o no. Normalmente, esto requerir&amp;iacute;a una &lt;code&gt;find&lt;/code&gt; seguida de una &lt;code&gt;insert&lt;/code&gt; , duplicando efectivamente el esfuerzo de b&amp;uacute;squeda en cada inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">El tipo &lt;code&gt;enum&lt;/code&gt; es an&amp;aacute;logo a una declaraci&amp;oacute;n de constructor de &lt;code&gt;data&lt;/code&gt; en ML, o un &lt;em&gt;ADT pick&lt;/em&gt; en Limbo.</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">&amp;iexcl;La funci&amp;oacute;n &lt;code&gt;env::args&lt;/code&gt; devuelve un iterador! En lugar de recopilar los valores del iterador en un vector y luego pasar un segmento a &lt;code&gt;Config::new&lt;/code&gt; , ahora estamos pasando la propiedad del iterador devuelto desde &lt;code&gt;env::args&lt;/code&gt; a &lt;code&gt;Config::new&lt;/code&gt; directamente.</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; enviar&amp;aacute; el trabajo que desea ejecutar por el lado de env&amp;iacute;o del canal.</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;expensive_test&lt;/code&gt; aparece como &lt;code&gt;ignored&lt;/code&gt; . Si queremos ejecutar solo las pruebas ignoradas, podemos usar &lt;code&gt;cargo test -- --ignored&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;export_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">La palabra clave &lt;code&gt;extern&lt;/code&gt; se usa en dos lugares en Rust. Uno est&amp;aacute; en conjunto con la palabra clave &lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt; para hacer que su c&amp;oacute;digo de Rust sea consciente de otras cajas de Rust en su proyecto, es decir, &lt;code&gt;extern crate lazy_static;&lt;/code&gt; . El otro uso es en interfaces de funciones externas (FFI).</target>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;fix_incorrect_order&lt;/code&gt; est&amp;aacute; en el m&amp;oacute;dulo &lt;code&gt;back_of_house&lt;/code&gt; , por lo que podemos usar &lt;code&gt;super&lt;/code&gt; para ir al m&amp;oacute;dulo principal de &lt;code&gt;back_of_house&lt;/code&gt; , que en este caso es &lt;code&gt;crate&lt;/code&gt; , la ra&amp;iacute;z. A partir de ah&amp;iacute;, buscamos &lt;code&gt;serve_order&lt;/code&gt; y lo encontramos. &amp;iexcl;&amp;Eacute;xito! Creemos que es probable que el m&amp;oacute;dulo &lt;code&gt;back_of_house&lt;/code&gt; y la funci&amp;oacute;n &lt;code&gt;serve_order&lt;/code&gt; mantengan la misma relaci&amp;oacute;n entre s&amp;iacute; y se muevan juntos si decidimos reorganizar el &amp;aacute;rbol de m&amp;oacute;dulos de la caja. Por lo tanto, usamos &lt;code&gt;super&lt;/code&gt; , por lo que tendremos menos lugares para actualizar el c&amp;oacute;digo en el futuro si este c&amp;oacute;digo se mueve a un m&amp;oacute;dulo diferente.</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">La sintaxis &lt;code&gt;fn&lt;/code&gt; declara una nueva funci&amp;oacute;n, los par&amp;eacute;ntesis, &lt;code&gt;()&lt;/code&gt; , indican que no hay par&amp;aacute;metros, y el corchete, &lt;code&gt;{&lt;/code&gt; , inicia el cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">La palabra clave &lt;code&gt;for&lt;/code&gt; se utiliza en muchas ubicaciones sint&amp;aacute;cticas:</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">La variable de bucle &lt;code&gt;for&lt;/code&gt; ahora se llama &lt;code&gt;_i&lt;/code&gt; y la advertencia ya no aparece.</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">La configuraci&amp;oacute;n de &lt;code&gt;forbid&lt;/code&gt; lint, como &lt;code&gt;deny&lt;/code&gt; , convierte la advertencia del compilador correspondiente en un error grave. A diferencia de &lt;code&gt;deny&lt;/code&gt; , &lt;code&gt;forbid&lt;/code&gt; evita que los atributos internos lo anulen.</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;format&lt;/code&gt; o toma una estructura &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt; y devuelve la cadena formateada resultante.</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">El &lt;code&gt;from&lt;/code&gt; archivo no existe.</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">El &lt;code&gt;from&lt;/code&gt; camino no es un archivo.</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;global_allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;hello_macro_derive&lt;/code&gt; primero convierte la &lt;code&gt;input&lt;/code&gt; de un &lt;code&gt;TokenStream&lt;/code&gt; en una estructura de datos que luego podemos interpretar y realizar operaciones. Aqu&amp;iacute; es donde entra en juego la &lt;code&gt;syn&lt;/code&gt; . El &lt;code&gt;parse&lt;/code&gt; funci&amp;oacute;n en &lt;code&gt;syn&lt;/code&gt; realiza un &lt;code&gt;TokenStream&lt;/code&gt; y devuelve un &lt;code&gt;DeriveInput&lt;/code&gt; struct que representa el c&amp;oacute;digo Rust analizada. El Listado 19-32 muestra las partes relevantes de la estructura &lt;code&gt;DeriveInput&lt;/code&gt; que obtenemos al analizar la &lt;code&gt;struct Pancakes;&lt;/code&gt; cuerda:</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;hello_macro_derive&lt;/code&gt; se llamar&amp;aacute; cuando un usuario de nuestra biblioteca especifique &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; en un tipo. Esto es posible porque hemos anotado la funci&amp;oacute;n &lt;code&gt;hello_macro_derive&lt;/code&gt; aqu&amp;iacute; con &lt;code&gt;proc_macro_derive&lt;/code&gt; y hemos especificado el nombre, &lt;code&gt;HelloMacro&lt;/code&gt; , que coincide con nuestro nombre de rasgo; esta es la convenci&amp;oacute;n que siguen la mayor&amp;iacute;a de las macros de procedimiento.</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">La sintaxis &lt;code&gt;if let&lt;/code&gt; le permite combinar &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;let&lt;/code&gt; en una forma menos detallada de manejar valores que coinciden con un patr&amp;oacute;n mientras ignora el resto. Considere el programa del Listado 6-6 que coincide con un valor de &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; pero solo quiere ejecutar c&amp;oacute;digo si el valor es 3.</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">La condici&amp;oacute;n &lt;code&gt;if&lt;/code&gt; se eval&amp;uacute;a con un valor de &lt;code&gt;3&lt;/code&gt; esta vez, y Rust arroja un error:</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">La expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; comprueba si nuestro valor est&amp;aacute; fuera de rango, le informa al usuario sobre el problema y las llamadas &lt;code&gt;continue&lt;/code&gt; para iniciar la siguiente iteraci&amp;oacute;n del ciclo y solicitar otra conjetura. Despu&amp;eacute;s de la expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; , podemos continuar con las comparaciones entre la &lt;code&gt;guess&lt;/code&gt; y el n&amp;uacute;mero secreto sabiendo que la &lt;code&gt;guess&lt;/code&gt; est&amp;aacute; entre 1 y 100.</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">La palabra clave &lt;code&gt;if&lt;/code&gt; se usa en otro lugar en Rust, es decir, como parte de la coincidencia de patrones en s&amp;iacute;, lo que permite que se usen patrones como &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;ignore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">El atributo &lt;code&gt;ignore&lt;/code&gt; se puede escribir opcionalmente con la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar una raz&amp;oacute;n por la que se ignora la prueba.</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">El tipo de retorno &lt;code&gt;impl Trait&lt;/code&gt; captura par&amp;aacute;metros de por vida que no aparecen dentro del propio &lt;code&gt;impl Trait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">La sintaxis &lt;code&gt;impl Trait&lt;/code&gt; es conveniente y permite un c&amp;oacute;digo m&amp;aacute;s conciso en casos simples. La sintaxis ligada a rasgos puede expresar m&amp;aacute;s complejidad en otros casos. Por ejemplo, podemos tener dos par&amp;aacute;metros que implementen &lt;code&gt;Summary&lt;/code&gt; . El uso de la sintaxis &lt;code&gt;impl Trait&lt;/code&gt; se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">La sintaxis &lt;code&gt;impl Trait&lt;/code&gt; funciona para casos sencillos, pero en realidad es az&amp;uacute;car sint&amp;aacute;ctica para una forma m&amp;aacute;s larga, que se denomina &lt;em&gt;l&amp;iacute;mite de caracter&amp;iacute;stica&lt;/em&gt; ; se parece a esto:</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">La palabra clave &lt;code&gt;impl&lt;/code&gt; se usa principalmente para definir implementaciones en tipos. Las implementaciones inherentes son independientes, mientras que las implementaciones de rasgos se utilizan para implementar rasgos para tipos u otros rasgos.</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;incoming&lt;/code&gt; en &lt;code&gt;TcpListener&lt;/code&gt; devuelve un iterador que nos da una secuencia de flujos (m&amp;aacute;s espec&amp;iacute;ficamente, flujos de tipo &lt;code&gt;TcpStream&lt;/code&gt; ). Un solo &lt;em&gt;flujo&lt;/em&gt; representa una conexi&amp;oacute;n abierta entre el cliente y el servidor. Una &lt;em&gt;conexi&amp;oacute;n&lt;/em&gt; es el nombre del proceso completo de solicitud y respuesta en el que un cliente se conecta al servidor, el servidor genera una respuesta y el servidor cierra la conexi&amp;oacute;n. Como tal, &lt;code&gt;TcpStream&lt;/code&gt; leer&amp;aacute; de s&amp;iacute; mismo para ver lo que envi&amp;oacute; el cliente y luego nos permitir&amp;aacute; escribir nuestra respuesta en la transmisi&amp;oacute;n. En general, este bucle &lt;code&gt;for&lt;/code&gt; procesar&amp;aacute; cada conexi&amp;oacute;n a su vez y producir&amp;aacute; una serie de flujos para que los manejemos.</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">El atributo en &lt;code&gt;inline&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">El atributo en &lt;code&gt;inline&lt;/code&gt; solo admite dos argumentos:</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">El atributo en &lt;code&gt;inline&lt;/code&gt; estaba mal formado.</target>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">El tipo &lt;code&gt;isize&lt;/code&gt; es un tipo entero con signo con el mismo n&amp;uacute;mero de bits que el tipo de puntero de la plataforma. El l&amp;iacute;mite superior te&amp;oacute;rico en objeto y tama&amp;ntilde;o de la matriz es el m&amp;aacute;ximo &lt;code&gt;isize&lt;/code&gt; valor. Esto asegura que &lt;code&gt;isize&lt;/code&gt; pueda usarse para calcular diferencias entre punteros en un objeto o matriz y pueda direccionar cada byte dentro de un objeto junto con un byte m&amp;aacute;s all&amp;aacute; del final.</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;it_works&lt;/code&gt; ahora tiene un tipo de retorno, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; . En el cuerpo de la funci&amp;oacute;n, en lugar de llamar a &lt;code&gt;assert_eq!&lt;/code&gt; macro, devolvemos &lt;code&gt;Ok(())&lt;/code&gt; cuando pasa la prueba y un &lt;code&gt;Err&lt;/code&gt; con una &lt;code&gt;String&lt;/code&gt; adentro cuando falla la prueba.</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; tiene un par&amp;aacute;metro llamado &lt;code&gt;list&lt;/code&gt; a , que representa cualquier porci&amp;oacute;n concreta de valores &lt;code&gt;i32&lt;/code&gt; que podamos pasar a la funci&amp;oacute;n. Como resultado, cuando llamamos a la funci&amp;oacute;n, el c&amp;oacute;digo se ejecuta en los valores espec&amp;iacute;ficos que pasamos.</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;largest_i32&lt;/code&gt; es la que extrajimos en el Listado 10-3 que encuentra el &lt;code&gt;i32&lt;/code&gt; m&amp;aacute;s grande en un segmento. La funci&amp;oacute;n &lt;code&gt;largest_char&lt;/code&gt; encuentra el &lt;code&gt;char&lt;/code&gt; m&amp;aacute;s grande en un segmento. Los cuerpos de las funciones tienen el mismo c&amp;oacute;digo, as&amp;iacute; que eliminemos la duplicaci&amp;oacute;n introduciendo un par&amp;aacute;metro de tipo gen&amp;eacute;rico en una sola funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">El argumento &lt;code&gt;len&lt;/code&gt; es el n&amp;uacute;mero de &lt;strong&gt;elementos&lt;/strong&gt; , no el n&amp;uacute;mero de bytes.</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;let y = 6&lt;/code&gt; no devuelve un valor, por lo que no hay nada a lo que &lt;code&gt;x&lt;/code&gt; pueda vincularse. Esto es diferente de lo que sucede en otros lenguajes, como C y Ruby, donde la asignaci&amp;oacute;n devuelve el valor de la asignaci&amp;oacute;n. En esos idiomas, puede escribir &lt;code&gt;x = y = 6&lt;/code&gt; y hacer que tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; tengan el valor &lt;code&gt;6&lt;/code&gt; ; ese no es el caso en Rust.</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;lines&lt;/code&gt; devuelve un iterador. Hablaremos sobre los iteradores en profundidad en el [Cap&amp;iacute;tulo 13] [ch13], pero recuerde que vio esta forma de usar un iterador en el &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listado 3-5&lt;/a&gt; , donde usamos un bucle &lt;code&gt;for&lt;/code&gt; con un iterador para ejecutar c&amp;oacute;digo en cada elemento. en una colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">El atributo de &lt;code&gt;link&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;link_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">El atributo &lt;code&gt;link_name&lt;/code&gt; se puede especificar en declaraciones dentro de un bloque &lt;code&gt;extern&lt;/code&gt; o para indicar el s&amp;iacute;mbolo a importar para la funci&amp;oacute;n dada o est&amp;aacute;tica. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el nombre del s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;link_section&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">El argumento de &lt;code&gt;locality&lt;/code&gt; debe ser un entero constante y es un especificador de localidad temporal que va desde (0) - sin localidad, a (3) - extremadamente local mantener en cach&amp;eacute;</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">La palabra clave &lt;code&gt;loop&lt;/code&gt; crea un ciclo infinito. Agregaremos eso ahora para brindar a los usuarios m&amp;aacute;s oportunidades de adivinar el n&amp;uacute;mero:</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">La palabra clave &lt;code&gt;loop&lt;/code&gt; le dice a Rust que ejecute un bloque de c&amp;oacute;digo una y otra vez para siempre o hasta que le digas expl&amp;iacute;citamente que se detenga.</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;macro_use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; aqu&amp;iacute; crea una instancia de la estructura &lt;code&gt;ImportantExcerpt&lt;/code&gt; que contiene una referencia a la primera oraci&amp;oacute;n de &lt;code&gt;String&lt;/code&gt; propiedad de la variable &lt;code&gt;novel&lt;/code&gt; . Los datos en &lt;code&gt;novel&lt;/code&gt; existen antes de que se cree la instancia de &lt;code&gt;ImportantExcerpt&lt;/code&gt; . Adem&amp;aacute;s, &lt;code&gt;novel&lt;/code&gt; no sale del alcance hasta que el &lt;code&gt;ImportantExcerpt&lt;/code&gt; sale del alcance, por lo que la referencia en la instancia de &lt;code&gt;ImportantExcerpt&lt;/code&gt; es v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; es especial y existen restricciones sobre cu&amp;aacute;l debe ser su tipo de retorno. Un tipo de retorno v&amp;aacute;lido para main es &lt;code&gt;()&lt;/code&gt; y, convenientemente, otro tipo de retorno v&amp;aacute;lido es &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">El prototipo de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; nunca deber&amp;iacute;a aceptar argumentos. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; se declar&amp;oacute; incorrectamente.</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">El cierre de &lt;code&gt;move&lt;/code&gt; se usa a menudo junto con &lt;code&gt;thread::spawn&lt;/code&gt; porque le permite usar datos de un hilo en otro hilo.</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;mpsc::channel&lt;/code&gt; devuelve una tupla, cuyo primer elemento es el extremo de env&amp;iacute;o y el segundo elemento es el extremo de recepci&amp;oacute;n. Las abreviaturas &lt;code&gt;tx&lt;/code&gt; y &lt;code&gt;rx&lt;/code&gt; se utilizan tradicionalmente en muchos campos para &lt;em&gt;transmisor&lt;/em&gt; y &lt;em&gt;receptor&lt;/em&gt; respectivamente, por lo que nombramos nuestras variables como tales para indicar cada extremo. Estamos usando una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; con un patr&amp;oacute;n que desestructura las tuplas; discutiremos el uso de patrones en las sentencias &lt;code&gt;let&lt;/code&gt; y la desestructuraci&amp;oacute;n en el Cap&amp;iacute;tulo 18. Usar una sentencia &lt;code&gt;let&lt;/code&gt; de esta manera es un enfoque conveniente para extraer las partes de la tupla devueltas por &lt;code&gt;mpsc::channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;must_use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">El atributo &lt;code&gt;must_use&lt;/code&gt; puede incluir un mensaje utilizando la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; como &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; . El mensaje se dar&amp;aacute; junto a la advertencia.</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">La clave del &lt;code&gt;name&lt;/code&gt; debe incluirse si se especifica &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_builtins&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_link&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_mangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">El predicado &lt;code&gt;not&lt;/code&gt; cfg estaba mal formado.</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">El predicado &lt;code&gt;not&lt;/code&gt; espera un patr&amp;oacute;n cfg. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">La variable &lt;code&gt;number&lt;/code&gt; estar&amp;aacute; vinculada a un valor basado en el resultado de la expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; . Ejecute este c&amp;oacute;digo para ver qu&amp;eacute; sucede:</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">El enlace &lt;code&gt;op_string_ref&lt;/code&gt; tiene el tipo &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; en ambos casos.</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">La configuraci&amp;oacute;n de &lt;code&gt;opt-level&lt;/code&gt; controla la cantidad de optimizaciones que Rust aplicar&amp;aacute; a su c&amp;oacute;digo, con un rango de 0 a 3. La aplicaci&amp;oacute;n de m&amp;aacute;s optimizaciones extiende el tiempo de compilaci&amp;oacute;n, por lo que si est&amp;aacute; en desarrollo y compila su c&amp;oacute;digo con frecuencia, querr&amp;aacute; m&amp;aacute;s r&amp;aacute;pido compilando incluso si el c&amp;oacute;digo resultante se ejecuta m&amp;aacute;s lento. Esa es la raz&amp;oacute;n por la que el &lt;code&gt;opt-level&lt;/code&gt; de opci&amp;oacute;n predeterminado para &lt;code&gt;dev&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; . Cuando est&amp;eacute; listo para publicar su c&amp;oacute;digo, es mejor dedicar m&amp;aacute;s tiempo a compilar. Solo compilar&amp;aacute; en modo de lanzamiento una vez, pero ejecutar&amp;aacute; el programa compilado muchas veces, por lo que el modo de lanzamiento intercambia un tiempo de compilaci&amp;oacute;n m&amp;aacute;s largo por un c&amp;oacute;digo que se ejecuta m&amp;aacute;s r&amp;aacute;pido. Es por eso que el &lt;code&gt;opt-level&lt;/code&gt; de opci&amp;oacute;n predeterminado para el perfil de &lt;code&gt;release&lt;/code&gt; es &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;or_insert&lt;/code&gt; en &lt;code&gt;Entry&lt;/code&gt; se define para devolver una referencia mutable al valor de la clave &lt;code&gt;Entry&lt;/code&gt; correspondiente si esa clave existe, y si no, inserta el par&amp;aacute;metro como el nuevo valor para esta clave y devuelve una referencia mutable al nuevo valor. Esta t&amp;eacute;cnica es mucho m&amp;aacute;s limpia que escribir la l&amp;oacute;gica nosotros mismos y, adem&amp;aacute;s, funciona mejor con el comprobador de pr&amp;eacute;stamos.</target>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;panic_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">El atributo de &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">La &lt;code&gt;path&lt;/code&gt; apunta a un archivo que no es de directorio.</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;poll&lt;/code&gt; no se llama repetidamente en un bucle cerrado; en cambio, solo debe llamarse cuando el futuro indique que est&amp;aacute; lista para progresar (llamando a &lt;code&gt;wake()&lt;/code&gt; ). Si est&amp;aacute; familiarizado con la &lt;code&gt;poll(2)&lt;/code&gt; o &lt;code&gt;select(2)&lt;/code&gt; llamadas al sistema en Unix, vale la pena se&amp;ntilde;alar que los futuros normalmente &lt;em&gt;no&lt;/em&gt; sufren los mismos problemas de &quot;todas las activaciones deben sondear todos los eventos&quot;; son m&amp;aacute;s como &lt;code&gt;epoll(4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;poll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">El intr&amp;iacute;nseco de &lt;code&gt;prefetch&lt;/code&gt; previa es una sugerencia para que el generador de c&amp;oacute;digo inserte una instrucci&amp;oacute;n de captaci&amp;oacute;n previa si es compatible; de lo contrario, no es una operaci&amp;oacute;n. Las captaciones previas no tienen ning&amp;uacute;n efecto sobre el comportamiento del programa, pero pueden cambiar sus caracter&amp;iacute;sticas de rendimiento.</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; La funci&amp;oacute;n solo es capaz de imprimir en salida est&amp;aacute;ndar, por lo que tenemos que usar algo m&amp;aacute;s para imprimir en error est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; La macro puede hacer muchos tipos de formato y, de forma predeterminada, las llaves indican &lt;code&gt;println!&lt;/code&gt; utilizar el formato conocido como &lt;code&gt;Display&lt;/code&gt; : salida destinada al consumo directo del usuario final. Los tipos primitivos que hemos visto hasta ahora implementan &lt;code&gt;Display&lt;/code&gt; de forma predeterminada, porque solo hay una forma en la que le gustar&amp;iacute;a mostrar un &lt;code&gt;1&lt;/code&gt; o cualquier otro tipo primitivo a un usuario. Pero con estructuras, la forma en que &lt;code&gt;println!&lt;/code&gt; Deber&amp;iacute;a formatear la salida es menos clara porque hay m&amp;aacute;s posibilidades de visualizaci&amp;oacute;n: &amp;iquest;Quieres comas o no? &amp;iquest;Quieres imprimir las llaves? &amp;iquest;Deber&amp;iacute;an mostrarse todos los campos? Debido a esta ambig&amp;uuml;edad, Rust no intenta adivinar lo que queremos, y las estructuras no tienen una implementaci&amp;oacute;n proporcionada de &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">La caja &lt;code&gt;proc_macro&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">La palabra clave &lt;code&gt;pub&lt;/code&gt; se utiliz&amp;oacute; dentro de una funci&amp;oacute;n. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">La palabra clave &lt;code&gt;pub&lt;/code&gt; se utiliz&amp;oacute; dentro de una enumeraci&amp;oacute;n p&amp;uacute;blica. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;push&lt;/code&gt; toma un solo car&amp;aacute;cter como par&amp;aacute;metro y lo agrega a &lt;code&gt;String&lt;/code&gt; . El listado 8-17 muestra el c&amp;oacute;digo que agrega la letra &lt;em&gt;l&lt;/em&gt; a una &lt;code&gt;String&lt;/code&gt; usando el m&amp;eacute;todo &lt;code&gt;push&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;quote!&lt;/code&gt; macro tambi&amp;eacute;n proporciona algunas mec&amp;aacute;nicas de plantillas muy interesantes: &amp;iexcl;podemos ingresar &lt;code&gt;#name&lt;/code&gt; y &lt;code&gt;quote!&lt;/code&gt; lo reemplazar&amp;aacute; con el valor en el &lt;code&gt;name&lt;/code&gt; la variable . Incluso puede hacer una repetici&amp;oacute;n similar a la forma en que funcionan las macros normales. Consulte &lt;a href=&quot;https://docs.rs/quote&quot;&gt;los documentos de la caja de &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt; para obtener una introducci&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;quote!&lt;/code&gt; macro nos permite definir el c&amp;oacute;digo de Rust que queremos devolver. &amp;iexcl;El compilador espera algo diferente al resultado directo de la &lt;code&gt;quote!&lt;/code&gt; ejecuci&amp;oacute;n de la macro, por lo que debemos convertirla en un &lt;code&gt;TokenStream&lt;/code&gt; . Hacemos esto llamando &lt;code&gt;into&lt;/code&gt; m&amp;eacute;todo into , que consume esta representaci&amp;oacute;n intermedia y devuelve un valor del tipo &lt;code&gt;TokenStream&lt;/code&gt; requerido .</target>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;recursion_limit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">La sintaxis &lt;code&gt;ref&lt;/code&gt; y / o &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;IDENTIFIER&lt;/em&gt; coincide con cualquier valor y lo vincula a una variable con el mismo nombre que el campo dado.</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;repeat()&lt;/code&gt; repite un solo valor una y otra vez.</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;repeat_with()&lt;/code&gt; llama al repetidor una y otra vez.</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">El &lt;code&gt;request_review&lt;/code&gt; y &lt;code&gt;approve&lt;/code&gt; m&amp;eacute;todos toman la propiedad de &lt;code&gt;self&lt;/code&gt; , consumiendo de este modo los &lt;code&gt;DraftPost&lt;/code&gt; y &lt;code&gt;PendingReviewPost&lt;/code&gt; casos y transformarlas en una &lt;code&gt;PendingReviewPost&lt;/code&gt; y un publicado &lt;code&gt;Post&lt;/code&gt; , respectivamente. De esta manera, no &lt;code&gt;DraftPost&lt;/code&gt; instancias de DraftPost persistentes despu&amp;eacute;s de haber llamado a &lt;code&gt;request_review&lt;/code&gt; en ellas, y as&amp;iacute; sucesivamente. La estructura &lt;code&gt;PendingReviewPost&lt;/code&gt; no tiene un m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; definido, por lo que intentar leer su contenido da como resultado un error del compilador, como con &lt;code&gt;DraftPost&lt;/code&gt; . Porque la &amp;uacute;nica forma de conseguir un &lt;code&gt;Post&lt;/code&gt; publicadoinstancia que tiene un &lt;code&gt;content&lt;/code&gt; m&amp;eacute;todo definido es llamar al &lt;code&gt;approve&lt;/code&gt; m&amp;eacute;todo en un &lt;code&gt;PendingReviewPost&lt;/code&gt; , y la &amp;uacute;nica manera de conseguir un &lt;code&gt;PendingReviewPost&lt;/code&gt; es llamar a la &lt;code&gt;request_review&lt;/code&gt; m&amp;eacute;todo en un &lt;code&gt;DraftPost&lt;/code&gt; , ahora hemos codificaba el flujo de trabajo de post blog en el sistema de tipos.</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; en &lt;code&gt;Draft&lt;/code&gt; necesita devolver una nueva instancia en caja de una nueva estructura &lt;code&gt;PendingReview&lt;/code&gt; , que representa el estado cuando una publicaci&amp;oacute;n est&amp;aacute; esperando una revisi&amp;oacute;n. La estructura &lt;code&gt;PendingReview&lt;/code&gt; tambi&amp;eacute;n implementa el m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; pero no realiza ninguna transformaci&amp;oacute;n. M&amp;aacute;s bien, se devuelve solo, porque cuando solicitamos una revisi&amp;oacute;n de una publicaci&amp;oacute;n que ya se encuentra en el estado &lt;code&gt;PendingReview&lt;/code&gt; , debe permanecer en el estado &lt;code&gt;PendingReview&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">El comando de &lt;code&gt;run&lt;/code&gt; es &amp;uacute;til cuando necesita iterar r&amp;aacute;pidamente en un proyecto, como lo haremos en este juego, probando r&amp;aacute;pidamente cada iteraci&amp;oacute;n antes de pasar a la siguiente.</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">La definici&amp;oacute;n de la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; ahora contiene toda la l&amp;oacute;gica restante de &lt;code&gt;main&lt;/code&gt; , comenzando por leer el archivo. La funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; toma la instancia de &lt;code&gt;Config&lt;/code&gt; como argumento.</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">La herramienta &lt;code&gt;rustfmt&lt;/code&gt; reformatea su c&amp;oacute;digo de acuerdo con el estilo del c&amp;oacute;digo de la comunidad. Muchos proyectos colaborativos usan &lt;code&gt;rustfmt&lt;/code&gt; para evitar discusiones sobre qu&amp;eacute; estilo usar al escribir Rust: todos formatean su c&amp;oacute;digo usando la herramienta.</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">A la funci&amp;oacute;n &lt;code&gt;same_bucket&lt;/code&gt; se le pasan referencias a dos elementos del segmento y debe determinar si los elementos se comparan igual. Los elementos se pasan en orden opuesto a su orden en el segmento, por lo que si &lt;code&gt;same_bucket(a, b)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; se mueve al final del segmento.</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">A la funci&amp;oacute;n &lt;code&gt;same_bucket&lt;/code&gt; se le pasan referencias a dos elementos del vector y debe determinar si los elementos se comparan igual. Los elementos se pasan en orden opuesto a su orden en el segmento, por lo que si &lt;code&gt;same_bucket(a, b)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; se elimina.</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;search_case_insensitive&lt;/code&gt; , que se muestra en el Listado 12-21, ser&amp;aacute; casi la misma que la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; . La &amp;uacute;nica diferencia es que pondremos en min&amp;uacute;sculas la &lt;code&gt;query&lt;/code&gt; y cada &lt;code&gt;line&lt;/code&gt; por lo que cualquiera que sea el caso de los argumentos de entrada, ser&amp;aacute;n el mismo caso cuando verifiquemos si la l&amp;iacute;nea contiene la consulta.</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">La caja &lt;code&gt;self&lt;/code&gt; se puede importar, lo que crea un v&amp;iacute;nculo con la caja actual. En este caso &lt;code&gt;as&lt;/code&gt; debe utilizar la cl&amp;aacute;usula as para especificar el nombre al que enlazar.</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">La &lt;code&gt;self&lt;/code&gt; aparece m&amp;aacute;s de una vez en la lista.</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">La palabra clave &lt;code&gt;self&lt;/code&gt; no puede aparecer sola como &amp;uacute;ltimo segmento en una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">La palabra clave &lt;code&gt;self&lt;/code&gt; se utiliz&amp;oacute; en un m&amp;eacute;todo est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">El campo &lt;code&gt;sent_messages&lt;/code&gt; ahora es de tipo &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; lugar de &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; . En la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n, creamos una nueva &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; alrededor del vector vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;shoes_in_my_size&lt;/code&gt; toma posesi&amp;oacute;n de un vector de zapatos y un tama&amp;ntilde;o de zapato como par&amp;aacute;metros. Devuelve un vector que contiene solo zapatos del tama&amp;ntilde;o especificado.</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;should_panic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">El atributo &lt;code&gt;should_panic&lt;/code&gt; puede tomar opcionalmente una cadena de entrada que debe aparecer dentro del mensaje de p&amp;aacute;nico. Si la cadena no se encuentra en el mensaje, la prueba fallar&amp;aacute;. La cadena se puede pasar usando la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; o la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; con un campo &lt;code&gt;expected&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;simd_shuffle&lt;/code&gt; necesita la longitud de la matriz pasada como &amp;uacute;ltimo par&amp;aacute;metro en su nombre. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Los &lt;code&gt;spawn&lt;/code&gt; funci&amp;oacute;n devuelve un &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; , en donde &lt;code&gt;T&lt;/code&gt; es el tipo que los rendimientos de cierre. Intentemos usar &lt;code&gt;JoinHandle&lt;/code&gt; tambi&amp;eacute;n y veamos qu&amp;eacute; sucede. En nuestro caso, los cierres que estamos pasando al grupo de subprocesos manejar&amp;aacute;n la conexi&amp;oacute;n y no devolver&amp;aacute;n nada, por lo que &lt;code&gt;T&lt;/code&gt; ser&amp;aacute; el tipo de unidad &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">La ruta &lt;code&gt;src&lt;/code&gt; no es un archivo o no existe.</target>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">La palabra clave &lt;code&gt;static&lt;/code&gt; , por otro lado, garantiza una ubicaci&amp;oacute;n fija en la memoria. Esto no siempre significa que el valor sea constante. Por ejemplo, un mutex global tambi&amp;eacute;n puede declararse &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;std::env&lt;/code&gt; contiene muchas m&amp;aacute;s funciones &amp;uacute;tiles para tratar con variables de entorno: consulte su documentaci&amp;oacute;n para ver qu&amp;eacute; hay disponible.</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;std::io&lt;/code&gt; contiene una serie de cosas comunes que necesitar&amp;aacute; al hacer entrada y salida. La parte fundamental de este m&amp;oacute;dulo son las caracter&amp;iacute;sticas de &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , que proporcionan la interfaz m&amp;aacute;s general para la lectura y escritura de entrada y salida.</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;std::mem::drop&lt;/code&gt; es diferente del m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; en el rasgo &lt;code&gt;Drop&lt;/code&gt; . Lo llamamos pasando el valor que queremos forzar para que se elimine antes como argumento. La funci&amp;oacute;n est&amp;aacute; en el preludio, por lo que podemos modificar &lt;code&gt;main&lt;/code&gt; en el Listado 15-15 para llamar a la funci&amp;oacute;n &lt;code&gt;drop&lt;/code&gt; , como se muestra en el Listado 15-16:</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;steps_between&lt;/code&gt; proporciona una forma de comparar eficientemente dos objetos &lt;code&gt;Step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;str&lt;/code&gt; , tambi&amp;eacute;n llamado 'segmento de cadena', es el tipo de cadena m&amp;aacute;s primitivo. Suele verse en su forma prestada, &lt;code&gt;&amp;amp;str&lt;/code&gt; . Tambi&amp;eacute;n es el tipo de cadenas literales, &lt;code&gt;&amp;amp;'static str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;stringify!&lt;/code&gt; La macro utilizada aqu&amp;iacute; est&amp;aacute; integrada en Rust. Toma una expresi&amp;oacute;n de Rust, como &lt;code&gt;1 + 2&lt;/code&gt; , y en tiempo de compilaci&amp;oacute;n convierte la expresi&amp;oacute;n en una cadena literal, como &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; . &amp;iexcl;Esto es diferente al &lt;code&gt;format!&lt;/code&gt; o &lt;code&gt;println!&lt;/code&gt; , macros que eval&amp;uacute;an la expresi&amp;oacute;n y luego convierten el resultado en una &lt;code&gt;String&lt;/code&gt; . Existe la posibilidad de que la entrada &lt;code&gt;#name&lt;/code&gt; sea ​​una expresi&amp;oacute;n para imprimir literalmente, &amp;iexcl;as&amp;iacute; que usamos &lt;code&gt;stringify!&lt;/code&gt; . Usando &lt;code&gt;stringify!&lt;/code&gt; tambi&amp;eacute;n guarda una asignaci&amp;oacute;n al convertir &lt;code&gt;#name&lt;/code&gt; en una cadena literal en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">La &lt;code&gt;syn&lt;/code&gt; analiza el c&amp;oacute;digo Rust de una cadena en una estructura de datos en la que podemos realizar operaciones. La caja de &lt;code&gt;quote&lt;/code&gt; convierte las estructuras de datos de &lt;code&gt;syn&lt;/code&gt; en c&amp;oacute;digo Rust. Estas cajas hacen que sea mucho m&amp;aacute;s sencillo analizar cualquier tipo de c&amp;oacute;digo Rust que queramos manejar: escribir un analizador completo para el c&amp;oacute;digo Rust no es una tarea sencilla.</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;take&lt;/code&gt; se define en el rasgo &lt;code&gt;Iterator&lt;/code&gt; y limita la iteraci&amp;oacute;n a los dos primeros elementos como m&amp;aacute;ximo. El &lt;code&gt;ThreadPool&lt;/code&gt; ir&amp;aacute; fuera de alcance al final del &lt;code&gt;main&lt;/code&gt; , y la &lt;code&gt;drop&lt;/code&gt; la aplicaci&amp;oacute;n se ejecutar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;target_feature&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">El atributo de &lt;code&gt;test&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">La Representaci&amp;oacute;n &lt;code&gt;transparent&lt;/code&gt; e</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La representaci&amp;oacute;n &lt;code&gt;transparent&lt;/code&gt; e solo se puede usar en &lt;code&gt;struct&lt;/code&gt; que tienen un solo campo de tama&amp;ntilde;o distinto de cero y cualquier n&amp;uacute;mero de campos de tama&amp;ntilde;o cero, incluido &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;try_recv&lt;/code&gt; no bloquea, sino que devolver&amp;aacute; un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; inmediatamente: un valor &lt;code&gt;Ok&lt;/code&gt; que contiene un mensaje si hay uno disponible y un valor &lt;code&gt;Err&lt;/code&gt; si no hay ning&amp;uacute;n mensaje esta vez. Usar &lt;code&gt;try_recv&lt;/code&gt; es &amp;uacute;til si este hilo tiene otro trabajo que hacer mientras espera mensajes: podr&amp;iacute;amos escribir un bucle que llame a &lt;code&gt;try_recv&lt;/code&gt; de vez en cuando, maneje un mensaje si hay uno disponible y, de lo contrario, hace otro trabajo por un tiempo hasta que vuelva a verificar.</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">El &lt;code&gt;type Target = T;&lt;/code&gt; la sintaxis define un tipo asociado para el &lt;code&gt;Deref&lt;/code&gt; rasgo Deref . Los tipos asociados son una forma ligeramente diferente de declarar un par&amp;aacute;metro gen&amp;eacute;rico, pero no necesita preocuparse por ellos por ahora; los cubriremos con m&amp;aacute;s detalle en el Cap&amp;iacute;tulo 19.</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;type_length_limit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">La &lt;code&gt;typeof&lt;/code&gt; clave typeof est&amp;aacute; actualmente reservada pero no implementada. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">El calificador &lt;code&gt;unsafe&lt;/code&gt; indica que el valor del tipo es una &lt;a href=&quot;../unsafe-functions&quot;&gt;funci&amp;oacute;n insegura&lt;/a&gt; y el calificador &lt;code&gt;extern&lt;/code&gt; o indica que es una &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;funci&amp;oacute;n externa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">El atributo de &lt;code&gt;unwind&lt;/code&gt; estaba mal formado.</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;used&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">El tipo &lt;code&gt;usize&lt;/code&gt; es un tipo entero sin signo con el mismo n&amp;uacute;mero de bits que el tipo de puntero de la plataforma. Puede representar cada direcci&amp;oacute;n de memoria en el proceso.</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">El campo de &lt;code&gt;value&lt;/code&gt; es de tipo &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; . Antes de ejecutar el cierre, el &lt;code&gt;value&lt;/code&gt; ser&amp;aacute; &lt;code&gt;None&lt;/code&gt; . Cuando el c&amp;oacute;digo que usa un &lt;code&gt;Cacher&lt;/code&gt; solicita el &lt;em&gt;resultado&lt;/em&gt; del cierre, el &lt;code&gt;Cacher&lt;/code&gt; ejecutar&amp;aacute; el cierre en ese momento y almacenar&amp;aacute; el resultado dentro de una variante &lt;code&gt;Some&lt;/code&gt; en el campo de &lt;code&gt;value&lt;/code&gt; . Luego, si el c&amp;oacute;digo solicita el resultado del cierre nuevamente, en lugar de ejecutar el cierre nuevamente, el &lt;code&gt;Cacher&lt;/code&gt; devolver&amp;aacute; el resultado contenido en la variante &lt;code&gt;Some&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">La &lt;code&gt;vtable&lt;/code&gt; personaliza el comportamiento de un &lt;code&gt;Waker&lt;/code&gt; que se crea a partir de un &lt;code&gt;RawWaker&lt;/code&gt; . Para cada operaci&amp;oacute;n en el &lt;code&gt;Waker&lt;/code&gt; , se llamar&amp;aacute; a la funci&amp;oacute;n asociada en la &lt;code&gt;vtable&lt;/code&gt; del &lt;code&gt;RawWaker&lt;/code&gt; subyacente .</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">La clave &lt;code&gt;wasm_import_module&lt;/code&gt; se puede utilizar para especificar el nombre del &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;m&amp;oacute;dulo WebAssembly&lt;/a&gt; para los elementos dentro de un bloque &lt;code&gt;extern&lt;/code&gt; o al importar s&amp;iacute;mbolos del entorno host. El nombre del m&amp;oacute;dulo predeterminado es &lt;code&gt;env&lt;/code&gt; si no se especifica &lt;code&gt;wasm_import_module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">Los campos de &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; y &lt;code&gt;label&lt;/code&gt; en &lt;code&gt;Button&lt;/code&gt; ser&amp;aacute;n diferentes de los campos en otros componentes, como un tipo &lt;code&gt;TextField&lt;/code&gt; , que podr&amp;iacute;an tener esos campos m&amp;aacute;s un campo de &lt;code&gt;placeholder&lt;/code&gt; lugar. Cada uno de los tipos que queremos dibujar en la pantalla implementar&amp;aacute; el rasgo &lt;code&gt;Draw&lt;/code&gt; , pero usar&amp;aacute; un c&amp;oacute;digo diferente en el m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; para definir c&amp;oacute;mo dibujar ese tipo en particular, como &lt;code&gt;Button&lt;/code&gt; tiene aqu&amp;iacute; (sin el c&amp;oacute;digo GUI real, que est&amp;aacute; m&amp;aacute;s all&amp;aacute; del alcance de este cap&amp;iacute;tulo). El tipo de &lt;code&gt;Button&lt;/code&gt; , por ejemplo, puede tener una &lt;code&gt;impl&lt;/code&gt; icaci&amp;oacute;n adicionalbloque que contiene m&amp;eacute;todos relacionados con lo que sucede cuando un usuario hace clic en el bot&amp;oacute;n. Este tipo de m&amp;eacute;todos no se aplicar&amp;aacute; a tipos como &lt;code&gt;TextField&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;windows_subsystem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;write&lt;/code&gt; toma un flujo de salida y una estructura &lt;code&gt;Arguments&lt;/code&gt; que se puede precompilar con &lt;code&gt;format_args!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">&amp;iexcl;La parte &lt;code&gt;x&lt;/code&gt; es un patr&amp;oacute;n! Como hicimos con &lt;code&gt;let&lt;/code&gt; , podr&amp;iacute;amos hacer coincidir una tupla en los argumentos de una funci&amp;oacute;n con el patr&amp;oacute;n. El listado 18-7 divide los valores de una tupla a medida que la pasamos a una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">El valor &lt;code&gt;x&lt;/code&gt; se mueve al cierre cuando se define el cierre, porque agregamos la palabra clave &lt;code&gt;move&lt;/code&gt; . El cierre entonces tiene propiedad de &lt;code&gt;x&lt;/code&gt; , &amp;iexcl;y &lt;code&gt;main&lt;/code&gt; ya no puede usar &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;println!&lt;/code&gt; declaraci&amp;oacute;n. Eliminando &lt;code&gt;println!&lt;/code&gt; arreglar&amp;aacute; este ejemplo.</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">El directorio de &lt;em id=&quot;the-tests-directory&quot;&gt;pruebas&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;/em&gt; sugiere que es poco probable que se llame a la funci&amp;oacute;n atribuida.</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; &lt;/em&gt; se puede aplicar al nivel de la caja para especificar el nombre de la caja con la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/em&gt; marca un art&amp;iacute;culo como obsoleto. &lt;code&gt;rustc&lt;/code&gt; emitir&amp;aacute; advertencias sobre el uso de &lt;code&gt;#[deprecated]&lt;/code&gt; . &lt;code&gt;rustdoc&lt;/code&gt; mostrar&amp;aacute; el art&amp;iacute;culo en desuso, incluida la versi&amp;oacute;n &lt;code&gt;since&lt;/code&gt; y la &lt;code&gt;note&lt;/code&gt; , si est&amp;aacute;n disponibles.</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; &lt;/em&gt; permite generar autom&amp;aacute;ticamente nuevos &lt;a href=&quot;../items&quot;&gt;elementos&lt;/a&gt; para las estructuras de datos. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; para especificar una lista de rasgos para implementar o rutas para &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derivar macros&lt;/a&gt; para procesar.</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/em&gt; especifica el nombre del s&amp;iacute;mbolo que se exportar&amp;aacute; en una &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n&lt;/a&gt; o &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;tica&lt;/a&gt; . Utiliza la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el nombre del s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; &lt;/em&gt; se utiliza en un &lt;a href=&quot;items/static-items&quot;&gt;elemento est&amp;aacute;tico que&lt;/a&gt; implementa el rasgo &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; para establecer el asignador global.</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo en &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/em&gt; sugiere que se debe colocar una copia de la funci&amp;oacute;n atribuida en el llamador, en lugar de generar c&amp;oacute;digo para llamar a la funci&amp;oacute;n donde est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">El &lt;em&gt;atributo de &lt;/em&gt;&lt;em&gt; &lt;code&gt;link&lt;/code&gt; &lt;/em&gt; especifica el nombre de una biblioteca nativa con la que el compilador debe enlazar para los elementos dentro de un bloque &lt;code&gt;extern&lt;/code&gt; o . Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar sus entradas. La clave de &lt;code&gt;name&lt;/code&gt; es el nombre de la biblioteca nativa a vincular. La clave &lt;code&gt;kind&lt;/code&gt; es un valor opcional que especifica el tipo de biblioteca con los siguientes valores posibles:</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/em&gt; especifica la secci&amp;oacute;n del archivo de objeto en la que se colocar&amp;aacute; una &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n&lt;/a&gt; o contenido &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;tico&lt;/a&gt; . Utiliza la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el nombre de la secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; &lt;/em&gt; tiene dos prop&amp;oacute;sitos. Primero, se puede usar para hacer que el alcance de la macro de un m&amp;oacute;dulo no termine cuando el m&amp;oacute;dulo est&amp;aacute; cerrado, aplic&amp;aacute;ndolo a un m&amp;oacute;dulo:</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/em&gt; se utiliza para emitir una advertencia de diagn&amp;oacute;stico cuando un valor no se &quot;utiliza&quot;. Se puede aplicar a los tipos definidos por el usuario compuestos ( &lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; s&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; s&lt;/a&gt; , y &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; s&lt;/a&gt; ), &lt;a href=&quot;../items/functions&quot;&gt;funciones&lt;/a&gt; , y &lt;a href=&quot;../items/traits&quot;&gt;rasgos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de caja para deshabilitar la optimizaci&amp;oacute;n de ciertos patrones de c&amp;oacute;digo para invocaciones de funciones de biblioteca que se supone que existen.</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; &lt;/em&gt; puede especificarse en un elemento de &lt;code&gt;extern crate&lt;/code&gt; para evitar vincular la caja a la salida. Esto se usa com&amp;uacute;nmente para cargar una caja para acceder solo a sus macros.</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de caja para inhabilitar la emisi&amp;oacute;n del s&amp;iacute;mbolo &lt;code&gt;main&lt;/code&gt; para un binario ejecutable. Esto es &amp;uacute;til cuando alg&amp;uacute;n otro objeto vinculado define &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/em&gt; se puede utilizar en cualquier &lt;a href=&quot;items&quot;&gt;elemento&lt;/a&gt; para deshabilitar el cambio de nombre de s&amp;iacute;mbolo est&amp;aacute;ndar. El s&amp;iacute;mbolo del art&amp;iacute;culo ser&amp;aacute; el identificador del nombre del art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; &lt;/em&gt; solo se puede aplicar a una funci&amp;oacute;n con la firma &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; . La funci&amp;oacute;n marcada con este &lt;a href=&quot;attributes&quot;&gt;atributo&lt;/a&gt; define el comportamiento de p&amp;aacute;nico. La estructura &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; contiene informaci&amp;oacute;n sobre la ubicaci&amp;oacute;n del p&amp;aacute;nico. Debe haber una &amp;uacute;nica funci&amp;oacute;n &lt;code&gt;panic_handler&lt;/code&gt; en el gr&amp;aacute;fico de dependencia de una caja binaria, dylib o cdylib.</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de &lt;a href=&quot;../crates-and-source-files&quot;&gt;caja&lt;/a&gt; para establecer la profundidad m&amp;aacute;xima para operaciones en tiempo de compilaci&amp;oacute;n potencialmente infinitamente recursivas como la expansi&amp;oacute;n de macros o la desreferencia autom&amp;aacute;tica. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar la profundidad de recursividad.</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; &lt;/em&gt; se puede aplicar a una &lt;a href=&quot;../unsafe-functions&quot;&gt;funci&amp;oacute;n insegura&lt;/a&gt; para permitir la generaci&amp;oacute;n de c&amp;oacute;digo de esa funci&amp;oacute;n para caracter&amp;iacute;sticas de arquitectura de plataforma espec&amp;iacute;ficas. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; con una &amp;uacute;nica clave de &lt;code&gt;enable&lt;/code&gt; cuyo valor es una cadena de nombres de funciones separados por comas para habilitar.</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">El &lt;em&gt;atributo de &lt;/em&gt;&lt;em&gt; &lt;code&gt;test&lt;/code&gt; &lt;/em&gt; marca una funci&amp;oacute;n que se ejecutar&amp;aacute; como prueba. Estas funciones solo se compilan en el modo de prueba. Las funciones de prueba deben ser funciones monom&amp;oacute;rficas libres que no tengan argumentos, y el tipo de retorno debe ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; &lt;/em&gt; limita el n&amp;uacute;mero m&amp;aacute;ximo de sustituciones de tipos realizadas al construir un tipo concreto durante la monomorfizaci&amp;oacute;n. Se aplica a nivel de &lt;a href=&quot;../crates-and-source-files&quot;&gt;caja&lt;/a&gt; y utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para establecer el l&amp;iacute;mite en funci&amp;oacute;n del n&amp;uacute;mero de sustituciones de tipos.</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;used&lt;/code&gt; &lt;/em&gt; solo se puede aplicar a &lt;a href=&quot;items/static-items&quot;&gt;elementos &lt;/a&gt; &lt;code&gt;static&lt;/code&gt; . Este &lt;a href=&quot;attributes&quot;&gt;atributo&lt;/a&gt; obliga al compilador a mantener la variable en el archivo del objeto de salida (.o, .rlib, etc.) incluso si la variable no es utilizada o referenciada por ning&amp;uacute;n otro elemento de la caja.</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de caja para configurar el &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsistema&lt;/a&gt; cuando se vincula en un destino de Windows. Utiliza la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el subsistema con un valor de &lt;code&gt;console&lt;/code&gt; o &lt;code&gt;windows&lt;/code&gt; . Este atributo se ignora en los destinos que no son de Windows y para los &lt;a href=&quot;linkage&quot;&gt;tipos de cajas que&lt;/a&gt; no son &lt;code&gt;bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">La &lt;em&gt;alineaci&amp;oacute;n&lt;/em&gt; de un valor especifica en qu&amp;eacute; direcciones son v&amp;aacute;lidas para almacenar el valor. Un valor de alineaci&amp;oacute;n &lt;code&gt;n&lt;/code&gt; solo debe almacenarse en una direcci&amp;oacute;n que sea m&amp;uacute;ltiplo de n. Por ejemplo, un valor con una alineaci&amp;oacute;n de 2 debe almacenarse en una direcci&amp;oacute;n par, mientras que un valor con una alineaci&amp;oacute;n de 1 se puede almacenar en cualquier direcci&amp;oacute;n. La alineaci&amp;oacute;n se mide en bytes, y debe ser al menos 1, y siempre una potencia de 2. La alineaci&amp;oacute;n de un valor se puede verificar con la funci&amp;oacute;n &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">El &lt;em&gt;al&lt;/em&gt; operador ( &lt;code&gt;@&lt;/code&gt; ) nos permite crear una variable que contiene un valor, al mismo tiempo que estamos probando que el valor para ver si coincide con un patr&amp;oacute;n. El Listado 18-29 muestra un ejemplo en el que queremos probar que un campo &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; est&amp;aacute; dentro del rango &lt;code&gt;3...7&lt;/code&gt; . Pero tambi&amp;eacute;n queremos vincular el valor a la variable &lt;code&gt;id_variable&lt;/code&gt; para poder usarlo en el c&amp;oacute;digo asociado con el brazo. Podr&amp;iacute;amos nombrar esta variable &lt;code&gt;id&lt;/code&gt; , igual que el campo, pero para este ejemplo usaremos un nombre diferente.</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">El &lt;em&gt;escape de barra invertida&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) que debe escaparse para denotar su codificaci&amp;oacute;n ASCII &lt;code&gt;0x5C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">El &lt;em&gt;escape de barra invertida&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) que debe escaparse para denotarse a s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">El &lt;em&gt;mont&amp;oacute;n&lt;/em&gt; es un t&amp;eacute;rmino general que describe cajas. La duraci&amp;oacute;n de una asignaci&amp;oacute;n en el mont&amp;oacute;n depende de la duraci&amp;oacute;n de los valores de caja que apuntan a ella. Dado que los valores de las cajas pueden pasarse dentro y fuera de las tramas, o almacenarse en el mont&amp;oacute;n, las asignaciones de la pila pueden sobrevivir a la trama en la que est&amp;aacute;n asignadas. Se garantiza que una asignaci&amp;oacute;n en el mont&amp;oacute;n residir&amp;aacute; en una &amp;uacute;nica ubicaci&amp;oacute;n en el mont&amp;oacute;n durante toda la vida &amp;uacute;til de la asignaci&amp;oacute;n; nunca se reubicar&amp;aacute; como resultado de mover un valor de caja.</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">Los &lt;em&gt;elementos&lt;/em&gt; de un programa son aquellas funciones, m&amp;oacute;dulos y tipos que tienen su valor calculado en tiempo de compilaci&amp;oacute;n y almacenado &amp;uacute;nicamente en la imagen de memoria del proceso de oxidaci&amp;oacute;n. Los art&amp;iacute;culos no se asignan ni se liberan din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">El &lt;em&gt;escape nulo&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) y denota el valor Unicode &lt;code&gt;U+0000&lt;/code&gt; (NUL).</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">El &lt;em&gt;escape nulo&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) y denota el valor de byte &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">El &lt;em&gt;preludio&lt;/em&gt; es la lista de cosas que Rust importa autom&amp;aacute;ticamente en cada programa de Rust. Se mantiene lo m&amp;aacute;s peque&amp;ntilde;o posible y se centra en las cosas, en particular los rasgos, que se utilizan en casi todos los programas de Rust.</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Las &lt;em&gt;representaciones primitivas&lt;/em&gt; son las representaciones con los mismos nombres que los tipos enteros primitivos. Es decir: &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;u16&lt;/code&gt; , &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , &lt;code&gt;u128&lt;/code&gt; , &lt;code&gt;usize&lt;/code&gt; , &lt;code&gt;i8&lt;/code&gt; , &lt;code&gt;i16&lt;/code&gt; , &lt;code&gt;i32&lt;/code&gt; , &lt;code&gt;i64&lt;/code&gt; , &lt;code&gt;i128&lt;/code&gt; , y &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">El &lt;em&gt;tama&amp;ntilde;o&lt;/em&gt; de un valor es el desplazamiento en bytes entre elementos sucesivos en una matriz con ese tipo de elemento incluido el relleno de alineaci&amp;oacute;n. El tama&amp;ntilde;o de un valor es siempre un m&amp;uacute;ltiplo de su alineaci&amp;oacute;n. El tama&amp;ntilde;o de un valor se puede verificar con la funci&amp;oacute;n &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">El &lt;em&gt;patr&amp;oacute;n de estado&lt;/em&gt; es un patr&amp;oacute;n de dise&amp;ntilde;o orientado a objetos. El quid del patr&amp;oacute;n es que un valor tiene alg&amp;uacute;n estado interno, que est&amp;aacute; representado por un conjunto de &lt;em&gt;objetos&lt;/em&gt; de &lt;em&gt;estado&lt;/em&gt; , y el comportamiento del valor cambia seg&amp;uacute;n el estado interno. Los objetos de estado comparten funcionalidad: en Rust, por supuesto, usamos estructuras y rasgos en lugar de objetos y herencia. Cada objeto de estado es responsable de su propio comportamiento y de gobernar cu&amp;aacute;ndo deber&amp;iacute;a cambiar a otro estado. El valor que tiene un objeto de estado no sabe nada sobre el comportamiento diferente de los estados o cu&amp;aacute;ndo hacer la transici&amp;oacute;n entre estados.</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">El &lt;em&gt;patr&amp;oacute;n de comod&amp;iacute;n&lt;/em&gt; coincide con cualquier valor. Se utiliza para ignorar valores cuando no importan. Dentro de otros patrones, coincide con un solo campo de datos (a diferencia del &lt;code&gt;..&lt;/code&gt; que coincide con los campos restantes). A diferencia de los patrones de identificaci&amp;oacute;n, no copia, mueve ni toma prestado el valor que coincide.</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">La mitad de env&amp;iacute;o del &lt;strong&gt;canal se&lt;/strong&gt; ha desconectado y nunca se recibir&amp;aacute;n m&amp;aacute;s datos en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">Las instrucciones de reordenamiento del &lt;strong&gt;compilador&lt;/strong&gt; : si el compilador puede emitir una instrucci&amp;oacute;n en un punto anterior, intentar&amp;aacute; hacerlo. Por ejemplo, podr&amp;iacute;a izar cargas de memoria en la parte superior de un bloque de c&amp;oacute;digo, de modo que la CPU puede comenzar &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;la obtenci&amp;oacute;n previa de&lt;/a&gt; los valores de la memoria.</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">La documentaci&amp;oacute;n API que genera &lt;code&gt;cargo doc&lt;/code&gt; para esta caja ahora enumerar&amp;aacute; y vincular&amp;aacute; las reexportaciones en la p&amp;aacute;gina principal, como se muestra en la Figura 14-4, lo que &lt;code&gt;PrimaryColor&lt;/code&gt; &lt;code&gt;SecondaryColor&lt;/code&gt; tipos PrimaryColor y SecondaryColor y la funci&amp;oacute;n de &lt;code&gt;mix&lt;/code&gt; m&amp;aacute;s f&amp;aacute;ciles de encontrar.</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">La API se usa t&amp;iacute;picamente adquiriendo un identificador para el hilo actual, colocando ese identificador en una estructura de datos compartida para que otros hilos puedan encontrarlo y luego &lt;code&gt;park&lt;/code&gt; en un bucle. Cuando se cumple alguna condici&amp;oacute;n deseada, otro hilo llama a &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; en el identificador.</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">La API de &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">La anatomía de una función de prueba</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">El tipo de arreglo...</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">El tipo booleano</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">El tipo booleano, &lt;code&gt;bool&lt;/code&gt; , con valores &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">El Borrow Checker</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">El tipo de personaje</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">La herramienta Clippy es una colección de pistas para analizar tu código y así poder detectar errores comunes y mejorar tu código Rust.</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">La representación por defecto</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">La diferencia entre macros y funciones</target>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">El operador del globo</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">El formato HTML est&amp;aacute; disponible en l&amp;iacute;nea en &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; y fuera de l&amp;iacute;nea con instalaciones de Rust hechas con &lt;code&gt;rustup&lt;/code&gt; ; ejecute &lt;code&gt;rustup docs --book&lt;/code&gt; para abrir.</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">El preludio de I/O</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">El tiempo de espera de la operación de E/S expiró,causando su cancelación.</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">El IEEE 754-2008 &quot;binary32&quot; y &quot;binary64&quot; tipos de coma flotante son &lt;code&gt;f32&lt;/code&gt; y &lt;code&gt;f64&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">Las Invariantes de la Pareja</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">El tipo de nunca que nunca regresa</target>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">El proceso y los equipos de la RFC</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">El Reglamento de Referencias</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">El Servidor de Lenguaje de Óxido potencia la integración del Entorno de Desarrollo Integrado (IDE)para la finalización del código y los mensajes de error en línea.</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">El preludio del óxido</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">El preludio del óxido.</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">El lenguaje de programación del óxido</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">La Biblioteca de Estándares de Óxido</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar de Rust es la base del software Rust port&amp;aacute;til, un conjunto de abstracciones compartidas m&amp;iacute;nimas y probadas en batalla para el &lt;a href=&quot;https://crates.io&quot;&gt;ecosistema Rust m&amp;aacute;s amplio&lt;/a&gt; . Ofrece tipos de n&amp;uacute;cleo, como &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#primitives&quot;&gt;operaciones&lt;/a&gt; definidas por bibliotecas en primitivas de lenguaje , &lt;a href=&quot;#macros&quot;&gt;macros est&amp;aacute;ndar&lt;/a&gt; , &lt;a href=&quot;io/index&quot;&gt;E / S&lt;/a&gt; y &lt;a href=&quot;thread/index&quot;&gt;subprocesos &lt;/a&gt;&lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;m&amp;uacute;ltiples&lt;/a&gt; , entre muchas otras cosas .</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">El compilador de Rust no considera &lt;em&gt;inseguros&lt;/em&gt; los siguientes comportamientos , aunque un programador puede (deber&amp;iacute;a) encontrarlos indeseables, inesperados o err&amp;oacute;neos.</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">El compilador de Rust tiene un &lt;em&gt;verificador de pr&amp;eacute;stamos&lt;/em&gt; que compara los alcances para determinar si todos los pr&amp;eacute;stamos son v&amp;aacute;lidos. El Listado 10-18 muestra el mismo c&amp;oacute;digo que el Listado 10-17 pero con anotaciones que muestran la vida &amp;uacute;til de las variables.</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">El compilador de Rust siempre se invoca con un &amp;uacute;nico archivo fuente como entrada y siempre produce una &amp;uacute;nica caja de salida. El procesamiento de ese archivo fuente puede resultar en la carga de otros archivos fuente como m&amp;oacute;dulos. Los archivos de origen tienen la extensi&amp;oacute;n &lt;code&gt;.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">El lenguaje y el compilador de Rust tienen un ciclo de lanzamiento de seis semanas, lo que significa que los usuarios obtienen un flujo constante de nuevas funciones. Otros lenguajes de programaci&amp;oacute;n lanzan cambios m&amp;aacute;s importantes con menos frecuencia; Rust lanza actualizaciones m&amp;aacute;s peque&amp;ntilde;as con mayor frecuencia. Despu&amp;eacute;s de un tiempo, todos estos peque&amp;ntilde;os cambios se suman. Pero de un lanzamiento a otro, puede ser dif&amp;iacute;cil mirar atr&amp;aacute;s y decir: &quot;&amp;iexcl;Vaya, entre Rust 1.10 y Rust 1.31, Rust ha cambiado mucho!&quot;</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">El lenguaje Rust tiene un conjunto de &lt;em&gt;palabras clave&lt;/em&gt; que est&amp;aacute;n reservadas para ser utilizadas &amp;uacute;nicamente por el idioma, al igual que en otros idiomas. Tenga en cuenta que no puede usar estas palabras como nombres de variables o funciones. La mayor&amp;iacute;a de las palabras clave tienen significados especiales y las utilizar&amp;aacute; para realizar diversas tareas en sus programas de Rust; algunos no tienen una funcionalidad actual asociada con ellos, pero se han reservado para funciones que podr&amp;iacute;an agregarse a Rust en el futuro. Puede encontrar una lista de las palabras clave en el Ap&amp;eacute;ndice A.</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">El lenguaje Rust espera ser compatible con muchos otros usuarios tambi&amp;eacute;n; los mencionados aqu&amp;iacute; son simplemente algunos de los principales interesados. En general, la mayor ambici&amp;oacute;n de Rust es eliminar las compensaciones que los programadores han aceptado durante d&amp;eacute;cadas al brindar seguridad &lt;em&gt;y&lt;/em&gt; productividad, velocidad &lt;em&gt;y&lt;/em&gt; ergonom&amp;iacute;a. Prueba Rust y comprueba si sus opciones funcionan para ti.</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">El tiempo de ejecución de Rust</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar de Rust proporciona canales para el paso de mensajes y tipos de punteros inteligentes, como &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; , que son seguros de usar en contextos concurrentes. El sistema de tipos y el verificador de pr&amp;eacute;stamos garantizan que el c&amp;oacute;digo que utiliza estas soluciones no terminar&amp;aacute; con carreras de datos o referencias no v&amp;aacute;lidas. Una vez que obtenga su c&amp;oacute;digo para compilar, puede estar seguro de que se ejecutar&amp;aacute; felizmente en m&amp;uacute;ltiples subprocesos sin los tipos de errores dif&amp;iacute;ciles de rastrear comunes en otros idiomas. La programaci&amp;oacute;n concurrente ya no es un concepto al que temer: avance y haga que sus programas sean concurrentes, &amp;iexcl;sin miedo!</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">El sistema de tipo Rust tiene algunas caracter&amp;iacute;sticas que hemos mencionado en este libro pero que a&amp;uacute;n no hemos comentado. Comenzaremos discutiendo los nuevos tipos en general mientras examinamos por qu&amp;eacute; los nuevos tipos son &amp;uacute;tiles como tipos. Luego pasaremos a los alias de tipo, una caracter&amp;iacute;stica similar a los nuevos tipos pero con una sem&amp;aacute;ntica ligeramente diferente. &amp;iexcl;Tambi&amp;eacute;n discutiremos el &lt;code&gt;!&lt;/code&gt; type y tipos de tama&amp;ntilde;o din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">El tipo de rebanada</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">La pila y el montón</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">La vida estática</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">El m&amp;oacute;dulo de pruebas y &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">Las ventajas y desventajas de usar &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">El Protocolo de control de transmisi&amp;oacute;n se especifica en &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">El tipo de tupla</target>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">El rasgo Unsize no debe aplicarse directamente.Todas las implementaciones de Unsize son proporcionadas automáticamente por el compilador.</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">La capacidad de devolver un tipo que solo est&amp;aacute; especificado por el rasgo que implementa es especialmente &amp;uacute;til en el contexto de cierres e iteradores, que cubrimos en el Cap&amp;iacute;tulo 13. Los cierres e iteradores crean tipos que solo el compilador conoce o tipos que son muy largos para especificar. La sintaxis &lt;code&gt;impl Trait&lt;/code&gt; le permite especificar de manera concisa que una funci&amp;oacute;n devuelve alg&amp;uacute;n tipo que implementa el rasgo &lt;code&gt;Iterator&lt;/code&gt; sin necesidad de escribir un tipo muy largo.</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i128::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i128&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i128::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i16::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i16&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i16::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i32::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i32&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i32::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i64::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i64&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i64::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i8::min_value()&lt;/code&gt; no se puede representar como &lt;code&gt;i8&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i8::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;isize::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;isize&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;isize::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">El tamaño real de la pila puede ser mayor que este valor si la plataforma especifica un tamaño mínimo de pila.</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de suma &lt;code&gt;+=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">El operador de suma &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">El tipo de direcci&amp;oacute;n puede ser cualquier implementador del rasgo &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para ver ejemplos concretos.</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">La ventaja de comprobar las reglas de préstamo en tiempo de ejecución es que se permiten ciertos escenarios seguros para la memoria,mientras que las comprobaciones en tiempo de compilación no los permiten.El análisis estático,como el compilador Rust,es inherentemente conservador.Algunas propiedades del código son imposibles de detectar analizando el código:el ejemplo más famoso es el Problema de Detención,que está fuera del alcance de este libro pero es un tema interesante de investigación.</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">La ventaja de usar objetos de rasgo y el sistema de tipos de Rust para escribir c&amp;oacute;digo similar al c&amp;oacute;digo usando el tipo pato es que nunca tenemos que verificar si un valor implementa un m&amp;eacute;todo en particular en tiempo de ejecuci&amp;oacute;n o preocuparnos por obtener errores si un valor no implementa un m&amp;eacute;todo pero lo llamamos de todos modos. Rust no compilar&amp;aacute; nuestro c&amp;oacute;digo si los valores no implementan las caracter&amp;iacute;sticas que necesitan los objetos de caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">Las ventajas de comprobar las reglas de pr&amp;eacute;stamo en tiempo de compilaci&amp;oacute;n son que los errores se detectar&amp;aacute;n antes en el proceso de desarrollo y no hay impacto en el rendimiento en tiempo de ejecuci&amp;oacute;n porque todo el an&amp;aacute;lisis se completa de antemano. Por esas razones, verificar las reglas de pr&amp;eacute;stamos en el momento de la compilaci&amp;oacute;n es la mejor opci&amp;oacute;n en la mayor&amp;iacute;a de los casos, raz&amp;oacute;n por la cual esta es la opci&amp;oacute;n predeterminada de Rust.</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">La alineaci&amp;oacute;n se especifica como un par&amp;aacute;metro entero en la forma de &lt;code&gt;#[repr(align(x))]&lt;/code&gt; o &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; . El valor de alineaci&amp;oacute;n debe ser una potencia de dos desde 1 hasta 2 &lt;sup&gt;29&lt;/sup&gt; . Para &lt;code&gt;packed&lt;/code&gt; , si no se proporciona ning&amp;uacute;n valor, como en &lt;code&gt;#[repr(packed)]&lt;/code&gt; , entonces el valor es 1.</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">La alineaci&amp;oacute;n se puede subir o bajar con los modificadores de &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; respectivamente. Alteran la representaci&amp;oacute;n especificada en el atributo. Si no se especifica ninguna representaci&amp;oacute;n, se modifica la predeterminada.</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">Los modificadores de alineación</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">La alineaci&amp;oacute;n de un valor especifica en qu&amp;eacute; direcciones se prefiere comenzar con los valores. Siempre una potencia de dos. Las referencias a un valor deben estar alineadas. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;M&amp;aacute;s&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">La alineación de la estructura es la alineación del campo más alineado en ella.</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">El bloque de memoria asignado puede o no ser inicializado.</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">El gancho de error de asignación es un recurso global.</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">El gancho de error de asignaci&amp;oacute;n se invoca cuando falla una asignaci&amp;oacute;n de memoria infalible, antes de que se cancele el tiempo de ejecuci&amp;oacute;n. El gancho predeterminado imprime un mensaje de error est&amp;aacute;ndar, pero este comportamiento se puede personalizar con las funciones &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">La bandera alternativa, &lt;code&gt;#&lt;/code&gt; , agrega un &lt;code&gt;0b&lt;/code&gt; delante de la salida.</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">La bandera alternativa, &lt;code&gt;#&lt;/code&gt; , agrega un &lt;code&gt;0o&lt;/code&gt; al frente de la salida.</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">La bandera alternativa, &lt;code&gt;#&lt;/code&gt; , agrega un &lt;code&gt;0x&lt;/code&gt; delante de la salida.</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">La respuesta a este problema es el archivo &lt;em&gt;Cargo.lock&lt;/em&gt; , que se cre&amp;oacute; la primera vez que ejecut&amp;oacute; &lt;code&gt;cargo build&lt;/code&gt; y ahora est&amp;aacute; en su directorio de &lt;em&gt;adivinanzas_juegos&lt;/em&gt; . Cuando construye un proyecto por primera vez, Cargo determina todas las versiones de las dependencias que se ajustan a los criterios y luego las escribe en el archivo &lt;em&gt;Cargo.lock&lt;/em&gt; . Cuando construya su proyecto en el futuro, Cargo ver&amp;aacute; que el archivo &lt;em&gt;Cargo.lock&lt;/em&gt; existe y usar&amp;aacute; las versiones especificadas all&amp;iacute; en lugar de hacer todo el trabajo de averiguar las versiones nuevamente. Esto le permite tener una compilaci&amp;oacute;n reproducible autom&amp;aacute;ticamente. En otras palabras, su proyecto permanecer&amp;aacute; en &lt;code&gt;0.3.14&lt;/code&gt; hasta que actualice expl&amp;iacute;citamente, gracias a &lt;em&gt;Cargo.lock&lt;/em&gt; expediente.</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">El argumento, &lt;code&gt;mid&lt;/code&gt; , debe ser un desplazamiento de bytes desde el inicio de la cadena. Tambi&amp;eacute;n debe estar en el l&amp;iacute;mite de un punto de c&amp;oacute;digo UTF-8.</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">Los argumentos se formatearán de acuerdo con la cadena de formato especificada en el flujo de salida proporcionado.</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">La expresi&amp;oacute;n de &amp;iacute;ndice de matriz se puede implementar para tipos distintos de matrices y cortes mediante la implementaci&amp;oacute;n de los rasgos &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; e &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">La matriz denominada &lt;code&gt;a&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;5&lt;/code&gt; elementos que se establecer&amp;aacute;n inicialmente en el valor &lt;code&gt;3&lt;/code&gt; . Esto es lo mismo que escribir &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; pero de una manera m&amp;aacute;s concisa.</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">El error asociado que puede ser devuelto del análisis.</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">La vida &amp;uacute;til asumida de las referencias mantenidas por un &lt;a href=&quot;types/trait-object&quot;&gt;objeto de rasgo&lt;/a&gt; se denomina &lt;em&gt;l&amp;iacute;mite de vida &amp;uacute;til del objeto predeterminado&lt;/em&gt; . Estos se definieron en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; y se modificaron en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">Los intr&amp;iacute;nsecos at&amp;oacute;micos proporcionan operaciones at&amp;oacute;micas comunes en palabras de m&amp;aacute;quina, con m&amp;uacute;ltiples ordenaciones de memoria posibles. Obedecen la misma sem&amp;aacute;ntica que C ++ 11. Consulte la documentaci&amp;oacute;n de LLVM sobre [ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">Es posible que los tipos atómicos de este módulo no estén disponibles en todas las plataformas.Sin embargo,los tipos atómicos aquí están ampliamente disponibles y,en general,se puede confiar en que existen.Algunas excepciones notables son:</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">El atributo consta de una ruta al atributo, seguida de un &amp;aacute;rbol de tokens delimitado opcional cuya interpretaci&amp;oacute;n est&amp;aacute; definida por el atributo. Los atributos distintos de los atributos macro tambi&amp;eacute;n permiten que la entrada sea un signo igual ( &lt;code&gt;=&lt;/code&gt; ) seguido de una expresi&amp;oacute;n literal. Consulte la &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;sintaxis&lt;/a&gt; del meta elemento a continuaci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">El atributo se utiliza en un elemento &lt;code&gt;static&lt;/code&gt; cuyo tipo implementa el rasgo &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; . Este tipo puede ser proporcionado por una biblioteca externa:</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">Los atributos que tienen significado en una expresi&amp;oacute;n de bloque son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos de comprobaci&amp;oacute;n de pelusa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">Los atributos que tienen significado en una funci&amp;oacute;n son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos de verificaci&amp;oacute;n de pelusa&lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../procedural-macros&quot;&gt;los atributos de macro de procedimiento&lt;/a&gt; , &lt;a href=&quot;../attributes/testing&quot;&gt;los atributos de prueba&lt;/a&gt; y &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;los atributos de sugerencia de optimizaci&amp;oacute;n&lt;/a&gt; . Las funciones tambi&amp;eacute;n aceptan macros de atributos.</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">El autor del c&amp;oacute;digo del Listado 14-4, que usa la caja de &lt;code&gt;art&lt;/code&gt; e , tuvo que darse cuenta de que &lt;code&gt;PrimaryColor&lt;/code&gt; est&amp;aacute; en el m&amp;oacute;dulo de &lt;code&gt;kinds&lt;/code&gt; y la &lt;code&gt;mix&lt;/code&gt; est&amp;aacute; en el m&amp;oacute;dulo de &lt;code&gt;utils&lt;/code&gt; . La estructura del m&amp;oacute;dulo de la caja de &lt;code&gt;art&lt;/code&gt; e es m&amp;aacute;s relevante para los desarrolladores que trabajan en la caja de &lt;code&gt;art&lt;/code&gt; e que para los desarrolladores que utilizan la caja de &lt;code&gt;art&lt;/code&gt; e . La estructura interna que organiza partes de la caja en los &lt;code&gt;kinds&lt;/code&gt; de m&amp;oacute;dulo y el &lt;code&gt;utils&lt;/code&gt; m&amp;oacute;dulo no contiene ninguna informaci&amp;oacute;n &amp;uacute;til para alguien que trata de entender c&amp;oacute;mo utilizar el &lt;code&gt;art&lt;/code&gt; e del caj&amp;oacute;n. En cambio, el &lt;code&gt;art&lt;/code&gt; eLa estructura del m&amp;oacute;dulo de crate causa confusi&amp;oacute;n porque los desarrolladores tienen que averiguar d&amp;oacute;nde buscar, y la estructura es inconveniente porque los desarrolladores deben especificar los nombres de los m&amp;oacute;dulos en las declaraciones de &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">El autor de este c&amp;oacute;digo probablemente quiera que &lt;code&gt;collect()&lt;/code&gt; devuelva un &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; , pero el compilador no puede estar seguro de que no haya otro tipo &lt;code&gt;T&lt;/code&gt; implementando &lt;code&gt;Try&lt;/code&gt; y &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; en un alcance tal que &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; . Por lo tanto, este c&amp;oacute;digo es ambiguo y se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">El mal estado no es algo que se &lt;em&gt;espera&lt;/em&gt; que suceda ocasionalmente.</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">La base de una expresi&amp;oacute;n de estructura de &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;actualizaci&amp;oacute;n funcional&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">El comportamiento del &lt;code&gt;Waker&lt;/code&gt; devuelto no est&amp;aacute; definido si el contrato definido en la &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; de RawWaker y &lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; &lt;/a&gt; no se mantiene. Por tanto, este m&amp;eacute;todo no es seguro.</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">El comportamiento de este m&amp;eacute;todo debe ser independiente del estado de la &lt;code&gt;Read&lt;/code&gt; er - el m&amp;eacute;todo s&amp;oacute;lo toma &lt;code&gt;&amp;amp;self&lt;/code&gt; para que pueda ser utilizado a trav&amp;eacute;s rasgo objetos.</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">El beneficio de tener esta restricci&amp;oacute;n es que Rust puede evitar carreras de datos en tiempo de compilaci&amp;oacute;n. Una &lt;em&gt;carrera de datos&lt;/em&gt; es similar a una condici&amp;oacute;n de carrera y ocurre cuando ocurren estos tres comportamientos:</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">Los bits que definen el modo de acceso est&amp;aacute;n enmascarados con &lt;code&gt;O_ACCMODE&lt;/code&gt; , para garantizar que no interfieran con el modo de acceso establecido por las opciones de Rusts.</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n AND bit a bit &lt;code&gt;&amp;amp;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">El operador AND bit a bit &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n OR bit a bit &lt;code&gt;|=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">El operador OR bit a bit &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n XOR bit a bit &lt;code&gt;^=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">El operador XOR bit a bit &lt;code&gt;^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">El bloque de una funci&amp;oacute;n est&amp;aacute; conceptualmente envuelto en un bloque que une los patrones de argumento y luego &lt;code&gt;return&lt;/code&gt; el valor del bloque de la funci&amp;oacute;n. Esto significa que la expresi&amp;oacute;n de cola del bloque, si se eval&amp;uacute;a, termina devolvi&amp;eacute;ndose al llamador. Como de costumbre, una expresi&amp;oacute;n de retorno expl&amp;iacute;cita dentro del cuerpo de la funci&amp;oacute;n acortar&amp;aacute; ese retorno impl&amp;iacute;cito, si se alcanza.</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">El tama&amp;ntilde;o del bloque debe estar en el rango &lt;code&gt;[use_min, use_max]&lt;/code&gt; , donde:</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">La direcci&amp;oacute;n de inicio del bloque debe estar alineada con &lt;code&gt;layout.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">Los cuerpos de las funciones &lt;code&gt;if let&lt;/code&gt; y &lt;code&gt;unwrap_or_else&lt;/code&gt; son los mismos en ambos casos: imprimimos el error y salimos.</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">El cuerpo de la funci&amp;oacute;n comienza llamando a la funci&amp;oacute;n &lt;code&gt;File::open&lt;/code&gt; . Luego manejamos el valor de &lt;code&gt;Result&lt;/code&gt; ado devuelto con una &lt;code&gt;match&lt;/code&gt; similar a la &lt;code&gt;match&lt;/code&gt; Listado 9-4, &amp;iexcl;solo que en lugar de llamar al &lt;code&gt;panic!&lt;/code&gt; en el caso de &lt;code&gt;Err&lt;/code&gt; , regresamos antes de esta funci&amp;oacute;n y pasamos el valor de error de &lt;code&gt;File::open&lt;/code&gt; al c&amp;oacute;digo de llamada como el valor de error de esta funci&amp;oacute;n. Si &lt;code&gt;File::open&lt;/code&gt; tiene &amp;eacute;xito, almacenamos el identificador del archivo en la variable &lt;code&gt;f&lt;/code&gt; y continuamos.</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">El cuerpo del m&amp;eacute;todo usar&amp;iacute;a &lt;code&gt;self&lt;/code&gt; para obtener el valor en el que llamamos al m&amp;eacute;todo. En este ejemplo, hemos creado una variable &lt;code&gt;m&lt;/code&gt; que tiene el valor &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; , y eso es lo que &lt;code&gt;self&lt;/code&gt; estar&amp;aacute; en el cuerpo del m&amp;eacute;todo de &lt;code&gt;call&lt;/code&gt; cuando &lt;code&gt;m.call()&lt;/code&gt; corre.</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">El libro &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; de Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides (Addison-Wesley Professional, 1994), conocido coloquialmente como &lt;em&gt;The Gang of Four&lt;/em&gt; , es un cat&amp;aacute;logo de libros orientados a objetos. patrones de dise&amp;ntilde;o. Define OOP de esta manera:</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">El tipo booleano.</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">El pr&amp;eacute;stamo dura hasta que la &lt;code&gt;Ref&lt;/code&gt; devuelta sale del alcance. Se pueden tomar varios pr&amp;eacute;stamos inmutables al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">El pr&amp;eacute;stamo dura hasta que &lt;code&gt;RefMut&lt;/code&gt; devuelto o todos los &lt;code&gt;RefMut&lt;/code&gt; derivados de su alcance de salida. El valor no se puede tomar prestado mientras este pr&amp;eacute;stamo est&amp;eacute; activo.</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">La memoria intermedia se escribe antes de devolver al escritor.</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">La memoria intermedia especificada tenía una longitud de 0 bytes.</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">La macro &lt;code&gt;cfg&lt;/code&gt; incorporada toma un &amp;uacute;nico predicado de configuraci&amp;oacute;n y eval&amp;uacute;a el literal &lt;code&gt;true&lt;/code&gt; cuando el predicado es verdadero y el literal &lt;code&gt;false&lt;/code&gt; cuando es falso.</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">Los atributos integrados que tienen significado en una funci&amp;oacute;n son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos de comprobaci&amp;oacute;n de pelusa&lt;/a&gt; , &lt;code&gt;path&lt;/code&gt; y &lt;code&gt;no_implicit_prelude&lt;/code&gt; . Los m&amp;oacute;dulos tambi&amp;eacute;n aceptan atributos de macro.</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">Los rasgos de la funci&amp;oacute;n incorporados son gen&amp;eacute;ricos sobre una tupla de los argumentos de la funci&amp;oacute;n. Si se usa la notaci&amp;oacute;n entre corchetes angulares ( &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; ) en lugar de par&amp;eacute;ntesis ( &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ) para denotar el rasgo de la funci&amp;oacute;n, el par&amp;aacute;metro de tipo debe ser una tupla. De lo contrario, no se puede utilizar la notaci&amp;oacute;n de llamada a funci&amp;oacute;n y los cierres no implementar&amp;aacute;n el rasgo.</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">La funci&amp;oacute;n c-main solo admite la devoluci&amp;oacute;n de enteros como tipo de retorno. Por lo tanto, cada tipo que implemente el rasgo de &lt;code&gt;Termination&lt;/code&gt; debe convertirse en un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">La llamada a &lt;code&gt;lock&lt;/code&gt; fallar&amp;iacute;a si otro hilo que sostiene el bloqueo entrara en p&amp;aacute;nico. En ese caso, nadie podr&amp;iacute;a obtener el candado, por lo que hemos optado por &lt;code&gt;unwrap&lt;/code&gt; y este hilo entra en p&amp;aacute;nico si estamos en esa situaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">&amp;iexcl;La llamada al &lt;code&gt;panic!&lt;/code&gt; provoca el mensaje de error contenido en las dos &amp;uacute;ltimas l&amp;iacute;neas. La primera l&amp;iacute;nea muestra nuestro mensaje de p&amp;aacute;nico y el lugar en nuestro c&amp;oacute;digo fuente donde ocurri&amp;oacute; el p&amp;aacute;nico: &lt;em&gt;src / main.rs: 2: 5&lt;/em&gt; indica que es la segunda l&amp;iacute;nea, el quinto car&amp;aacute;cter de nuestro archivo &lt;em&gt;src / main.rs.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">La llamada a &lt;code&gt;parse&lt;/code&gt; f&amp;aacute;cilmente podr&amp;iacute;a provocar un error. Si, por ejemplo, la cadena contuviera &lt;code&gt;A👍%&lt;/code&gt; , no habr&amp;iacute;a forma de convertir eso en un n&amp;uacute;mero. Debido a que puede fallar, el m&amp;eacute;todo de &lt;code&gt;parse&lt;/code&gt; devuelve un tipo de &lt;code&gt;Result&lt;/code&gt; , al igual que lo &lt;code&gt;read_line&lt;/code&gt; m&amp;eacute;todo read_line (discutido anteriormente en &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Manejo de fallas potenciales con el tipo de &lt;code&gt;Result&lt;/code&gt; &amp;rdquo;&lt;/a&gt; ). Trataremos este &lt;code&gt;Result&lt;/code&gt; la misma manera usando el m&amp;eacute;todo de &lt;code&gt;expect&lt;/code&gt; nuevamente. Si &lt;code&gt;parse&lt;/code&gt; devuelve una llamada &lt;code&gt;Err&lt;/code&gt; bloquear&amp;aacute; el juego e imprimir&amp;aacute; el mensaje que le damos. Si &lt;code&gt;parse&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; variante Result porque no pudo crear un n&amp;uacute;mero a partir de la cadena, se &lt;code&gt;expect&lt;/code&gt; puede convertir correctamente la cadena en un n&amp;uacute;mero, devolver&amp;aacute; la variante &lt;code&gt;Ok&lt;/code&gt; de &lt;code&gt;Result&lt;/code&gt; , y &lt;code&gt;expect&lt;/code&gt; que devuelva el n&amp;uacute;mero que queremos del valor &lt;code&gt;Ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">La llamada a &lt;code&gt;recv&lt;/code&gt; bloquea, por lo que si a&amp;uacute;n no hay ning&amp;uacute;n trabajo, el hilo actual esperar&amp;aacute; hasta que haya un trabajo disponible. El &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; asegura que s&amp;oacute;lo un &lt;code&gt;Worker&lt;/code&gt; hilo a la vez est&amp;aacute; tratando de solicitar un puesto de trabajo.</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">La persona que llama tiene que asegurarse de que ninguna referencia en el cierre del hilo suministrado o su tipo de devolución pueda sobrevivir a la vida del hilo engendrado.Esto se puede garantizar de dos maneras:</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La persona que llama tambi&amp;eacute;n debe asegurarse de que la memoria a la que apunta el puntero (no transitivamente) nunca se escriba (excepto dentro de una &lt;code&gt;UnsafeCell&lt;/code&gt; ) utilizando este puntero o cualquier puntero derivado de &amp;eacute;l. Si necesita mutar el contenido del segmento, use&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La persona que llama debe asegurarse de que nunca se escriba en el puntero devuelto. Si necesita mutar el contenido del segmento de cadena, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">La persona que llama debe asegurarse de que la rebanada sobreviva al puntero que esta función devuelve,o de lo contrario terminará apuntando a la basura.</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">El llamador debe asegurarse de que el vector sobreviva al puntero que esta función devuelve,o de lo contrario terminará apuntando a la basura.Modificar el vector puede causar que su búfer sea reasignado,lo que también haría que cualquier puntero hacia él sea inválido.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">El hilo de llamada se bloqueará hasta que no haya más escritores que mantengan el bloqueo.Puede que haya otros lectores actualmente dentro del candado cuando este método regrese.Este método no ofrece ninguna garantía con respecto al orden de si los lectores o escritores contenciosos adquirirán primero el candado.</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">Las llamadas a &lt;code&gt;thread::sleep&lt;/code&gt; obligan a un hilo a detener su ejecuci&amp;oacute;n durante un breve per&amp;iacute;odo, lo que permite que se ejecute un hilo diferente. Los hilos probablemente se turnar&amp;aacute;n, pero eso no est&amp;aacute; garantizado: depende de c&amp;oacute;mo su sistema operativo programe los hilos. En esta ejecuci&amp;oacute;n, el hilo principal se imprimi&amp;oacute; primero, aunque la declaraci&amp;oacute;n de impresi&amp;oacute;n del hilo generado aparece primero en el c&amp;oacute;digo. Y aunque le dijimos al hilo generado que imprimiera hasta &lt;code&gt;i&lt;/code&gt; sea ​​9, solo lleg&amp;oacute; a 5 antes de que el hilo principal se apagara.</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">El código de salida canónico para la terminación exitosa en esta plataforma.</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">El código de salida canónico para la terminación sin éxito en esta plataforma.</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">El camino canónico sólo tiene sentido dentro de una caja determinada.No hay un espacio de nombres global a través de los cajones;el camino canónico de un artículo sólo lo identifica dentro del cajón.</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">La capacidad puede aumentarse en m&amp;aacute;s de &lt;code&gt;additional&lt;/code&gt; bytes si lo desea, para evitar que las reasignaciones frecuentes.</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">La capacidad de un vector es la cantidad de espacio asignada para cualquier elemento futuro que se agregar&amp;aacute; al vector. Esto no debe confundirse con el&lt;em&gt; longitud&lt;/em&gt; de un vector, que especifica el n&amp;uacute;mero de elementos reales dentro del vector. Si la longitud de un vector excede su capacidad, su capacidad aumentar&amp;aacute; autom&amp;aacute;ticamente, pero sus elementos deber&amp;aacute;n reasignarse.</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">La capacidad seguirá siendo al menos tan grande como la longitud y el valor suministrado.</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">Los valores capturados de un &lt;a href=&quot;types/closure&quot;&gt;cierre&lt;/a&gt; se eliminan en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">Los cambios que necesit&amp;aacute;bamos hacer en &lt;code&gt;main&lt;/code&gt; para reasignar la &lt;code&gt;post&lt;/code&gt; significan que esta implementaci&amp;oacute;n ya no sigue el patr&amp;oacute;n de estado orientado a objetos: las transformaciones entre los estados ya no est&amp;aacute;n encapsuladas por completo dentro de la &lt;code&gt;Post&lt;/code&gt; implementaci&amp;oacute;n de . Sin embargo, nuestro beneficio es que los estados inv&amp;aacute;lidos ahora son imposibles debido al sistema de tipos y la verificaci&amp;oacute;n de tipos que ocurre en el momento de la compilaci&amp;oacute;n. Esto asegura que ciertos errores, como la visualizaci&amp;oacute;n del contenido de una publicaci&amp;oacute;n no publicada, ser&amp;aacute;n descubiertos antes de que lleguen a producci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">El personaje representado por esta fuga</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">El tipo de car&amp;aacute;cter, &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">El hijo hereda del padre descriptor correspondiente.</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Los trozos son cortes mutables y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, entonces el &amp;uacute;ltimo trozo no tendr&amp;aacute; la longitud &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Los trozos son cortes mutables y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, los &amp;uacute;ltimos elementos hasta &lt;code&gt;chunk_size-1&lt;/code&gt; se omitir&amp;aacute;n y se podr&amp;aacute;n recuperar de la funci&amp;oacute;n &lt;code&gt;into_remainder&lt;/code&gt; del iterador.</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Los trozos son rodajas y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, el &amp;uacute;ltimo trozo no tendr&amp;aacute; la longitud &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Los trozos son rodajas y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, los &amp;uacute;ltimos elementos hasta &lt;code&gt;chunk_size-1&lt;/code&gt; se omitir&amp;aacute;n y se podr&amp;aacute;n recuperar del &lt;code&gt;remainder&lt;/code&gt; funci&amp;oacute;n del iterador.</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">El cierre &lt;code&gt;f&lt;/code&gt; produce una estructura &lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt; que se puede utilizar para consultar el estado de envenenamiento de &lt;code&gt;Once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">El cierre &lt;code&gt;f&lt;/code&gt; solo se ejecutar&amp;aacute; una vez si se llama simult&amp;aacute;neamente entre muchos subprocesos. Sin embargo, si ese cierre entra en p&amp;aacute;nico, &lt;em&gt;envenenar&amp;aacute;&lt;/em&gt; esta instancia &lt;code&gt;Once&lt;/code&gt; , lo que provocar&amp;aacute; que todas las invocaciones futuras de &lt;code&gt;call_once&lt;/code&gt; tambi&amp;eacute;n entren en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">El cierre puede usar capturas y su entorno para rastrear el estado en las iteraciones. Dependiendo de c&amp;oacute;mo se use el iterador, esto puede requerir especificar el &lt;code&gt;move&lt;/code&gt; palabra clave en el cierre.</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">El cierre captura el par&amp;aacute;metro &lt;code&gt;shoe_size&lt;/code&gt; del entorno y compara el valor con el tama&amp;ntilde;o de cada zapato, manteniendo solo zapatos del tama&amp;ntilde;o especificado. Finalmente, llamar a &lt;code&gt;collect&lt;/code&gt; re&amp;uacute;ne los valores devueltos por el iterador adaptado en un vector que devuelve la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">La definici&amp;oacute;n de cierre viene despu&amp;eacute;s de &lt;code&gt;=&lt;/code&gt; para asignarla a la variable &lt;code&gt;expensive_closure&lt;/code&gt; . Para definir un cierre, partimos de un par de tubos verticales ( &lt;code&gt;|&lt;/code&gt; ), dentro de los cuales especificamos los par&amp;aacute;metros del cierre; se eligi&amp;oacute; esta sintaxis debido a su similitud con las definiciones de cierre en Smalltalk y Ruby. Este cierre tiene un par&amp;aacute;metro llamado &lt;code&gt;num&lt;/code&gt; : si tuvi&amp;eacute;ramos m&amp;aacute;s de un par&amp;aacute;metro, los separar&amp;iacute;amos con comas, como &lt;code&gt;|param1, param2|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">El cierre se permite para devolver un error de E/S cuyo código de error del SO se comunicará al padre y se devolverá como un error de cuando se solicitó el desove.</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">El cierre debe devolver &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;filter()&lt;/code&gt; crea un iterador que llama a este cierre en cada elemento. Si el cierre devuelve &lt;code&gt;true&lt;/code&gt; , se devuelve el elemento. Si el cierre vuelve &lt;code&gt;false&lt;/code&gt; , lo intentar&amp;aacute; de nuevo y llamar&amp;aacute; al cierre en el siguiente elemento, viendo si pasa la prueba.</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El cierre debe devolver una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;filter_map&lt;/code&gt; crea un iterador que llama a este cierre en cada elemento. Si el cierre devuelve &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; , ese elemento se devuelve. Si el cierre devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , lo intentar&amp;aacute; de nuevo y llamar&amp;aacute; al cierre del siguiente elemento, viendo si devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">Se requiere que el cierre provisto se adhiera al rasgo &lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt; para garantizar que todas las variables capturadas sean seguras para cruzar este l&amp;iacute;mite. El prop&amp;oacute;sito de este l&amp;iacute;mite es codificar el concepto de &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;seguridad&lt;/a&gt; de excepci&amp;oacute;n en el sistema de tipos. La mayor parte del uso de esta funci&amp;oacute;n no deber&amp;iacute;a tener que preocuparse por este enlace, ya que los programas se desenrollan naturalmente de forma segura sin c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; . Si se convierte en un problema, la &lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt; contenedora AssertUnwindSafe se puede usar para afirmar r&amp;aacute;pidamente que el uso aqu&amp;iacute; es realmente seguro.</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">El cierre usa &lt;code&gt;v&lt;/code&gt; , por lo que capturar&amp;aacute; &lt;code&gt;v&lt;/code&gt; y lo har&amp;aacute; parte del entorno del cierre. Debido a que &lt;code&gt;thread::spawn&lt;/code&gt; ejecuta este cierre en un nuevo hilo, deber&amp;iacute;amos poder acceder a &lt;code&gt;v&lt;/code&gt; dentro de ese nuevo hilo. Pero cuando compilamos este ejemplo, obtenemos el siguiente error:</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">El c&amp;oacute;digo asociado con cada brazo es una expresi&amp;oacute;n, y el valor resultante de la expresi&amp;oacute;n en el brazo coincidente es el valor que se devuelve para toda la expresi&amp;oacute;n &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 13-17 no hace nada; el cierre que hemos especificado nunca se llama. La advertencia nos recuerda por qu&amp;eacute;: los adaptadores de iterador son perezosos y necesitamos consumir el iterador aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 13-3 tiene m&amp;uacute;ltiples llamadas a la funci&amp;oacute;n de c&amp;aacute;lculo lento. El primer bloque &lt;code&gt;if&lt;/code&gt; llama a &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; dos veces, el &lt;code&gt;if&lt;/code&gt; dentro del exterior &lt;code&gt;else&lt;/code&gt; no lo llama en absoluto, y el c&amp;oacute;digo dentro del segundo &lt;code&gt;else&lt;/code&gt; caso llama una vez.</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">El c&amp;oacute;digo del Listado 16-1 no solo detiene el subproceso generado prematuramente la mayor parte del tiempo debido a la finalizaci&amp;oacute;n del subproceso principal, sino que tampoco puede garantizar que el subproceso generado se ejecute en absoluto. La raz&amp;oacute;n es que no hay garant&amp;iacute;a sobre el orden en que se ejecutan los hilos.</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 16-8 se compil&amp;oacute; y ejecut&amp;oacute;, pero no nos mostr&amp;oacute; claramente que dos hilos separados se comunicaban entre s&amp;iacute; a trav&amp;eacute;s del canal. En el Listado 16-10 hemos realizado algunas modificaciones que probar&amp;aacute;n que el c&amp;oacute;digo del Listado 16-8 se est&amp;aacute; ejecutando simult&amp;aacute;neamente: el hilo generado ahora enviar&amp;aacute; varios mensajes y se detendr&amp;aacute; por un segundo entre cada mensaje.</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 18-1 muestra una serie de comprobaciones para varias condiciones que deciden cu&amp;aacute;l debe ser el color de fondo. Para este ejemplo, hemos creado variables con valores codificados que un programa real podr&amp;iacute;a recibir de la entrada del usuario.</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">El código de la lista 18-3 imprimirá lo siguiente:</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 20-14 se compilar&amp;aacute; pero a&amp;uacute;n no crea ning&amp;uacute;n hilo. Hemos cambiado la definici&amp;oacute;n de &lt;code&gt;ThreadPool&lt;/code&gt; para contener un vector de &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; , inicializamos el vector con una capacidad de &lt;code&gt;size&lt;/code&gt; , configuramos un bucle &lt;code&gt;for&lt;/code&gt; que ejecutar&amp;aacute; alg&amp;uacute;n c&amp;oacute;digo para crear los hilos y devolvi&amp;oacute; un Instancia de &lt;code&gt;ThreadPool&lt;/code&gt; que los contiene.</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 20-21 responde a las solicitudes de forma asincr&amp;oacute;nica mediante el uso de un grupo de subprocesos, como pretend&amp;iacute;amos. Recibimos algunas advertencias sobre los campos de los &lt;code&gt;workers&lt;/code&gt; , la &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n y el &lt;code&gt;thread&lt;/code&gt; que no estamos usando de manera directa que nos recuerdan que no estamos limpiando nada. Cuando usamos el m&amp;eacute;todo ctrl-c menos elegante para detener el subproceso principal, todos los dem&amp;aacute;s subprocesos tambi&amp;eacute;n se detienen inmediatamente, incluso si est&amp;aacute;n en el medio de atender una solicitud.</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 5-7 tambi&amp;eacute;n crea una instancia en &lt;code&gt;user2&lt;/code&gt; que tiene un valor diferente para el &lt;code&gt;email&lt;/code&gt; y el &lt;code&gt;username&lt;/code&gt; pero tiene los mismos valores para los campos &lt;code&gt;active&lt;/code&gt; y &lt;code&gt;sign_in_count&lt;/code&gt; de &lt;code&gt;user1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 8-7 podr&amp;iacute;a parecer que deber&amp;iacute;a funcionar: &amp;iquest;por qu&amp;eacute; una referencia al primer elemento deber&amp;iacute;a preocuparse por los cambios al final del vector? Este error se debe a la forma en que funcionan los vectores: agregar un nuevo elemento al final del vector puede requerir asignar nueva memoria y copiar los elementos antiguos al nuevo espacio, si no hay suficiente espacio para poner todos los elementos al lado de cada uno otro donde est&amp;aacute; el vector actualmente. En ese caso, la referencia al primer elemento estar&amp;iacute;a apuntando a la memoria desasignada. Las reglas de endeudamiento evitan que los programas terminen en esa situaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">&amp;iexcl;El c&amp;oacute;digo del Listado 9-4 entrar&amp;aacute; en &lt;code&gt;panic!&lt;/code&gt; no importa por qu&amp;eacute; &lt;code&gt;File::open&lt;/code&gt; fall&amp;oacute;. Lo que queremos hacer en cambio es tomar diferentes acciones por diferentes razones de falla: si &lt;code&gt;File::open&lt;/code&gt; fall&amp;oacute; porque el archivo no existe, queremos crear el archivo y devolver el identificador al nuevo archivo. Si &lt;code&gt;File::open&lt;/code&gt; fall&amp;oacute; por cualquier otro motivo, por ejemplo, porque no ten&amp;iacute;amos permiso para abrir el archivo, &amp;iexcl;a&amp;uacute;n queremos que el c&amp;oacute;digo entre en &lt;code&gt;panic!&lt;/code&gt; de la misma manera que lo hizo en el Listado 9-4. Mire el Listado 9-5, que agrega una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; interna .</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">El c&amp;oacute;digo intenta pasar el &lt;code&gt;receiver&lt;/code&gt; a varias instancias de &lt;code&gt;Worker&lt;/code&gt; . Esto no funcionar&amp;aacute;, como recordar&amp;aacute; del Cap&amp;iacute;tulo 16: la implementaci&amp;oacute;n de canal que proporciona Rust es de m&amp;uacute;ltiples &lt;em&gt;productores&lt;/em&gt; y de un solo &lt;em&gt;consumidor&lt;/em&gt; . Esto significa que no podemos simplemente clonar el extremo consumidor del canal para corregir este c&amp;oacute;digo. Incluso si pudi&amp;eacute;ramos, esa no es la t&amp;eacute;cnica que nos gustar&amp;iacute;a usar; en su lugar, queremos distribuir los trabajos a trav&amp;eacute;s de subprocesos compartiendo el &lt;code&gt;receiver&lt;/code&gt; &amp;uacute;nico entre todos los trabajadores.</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">El código se refiere a un rasgo que no está en el ámbito de aplicación.</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">El c&amp;oacute;digo que llama a este c&amp;oacute;digo se encargar&amp;aacute; de obtener un valor &lt;code&gt;Ok&lt;/code&gt; que contiene un nombre de usuario o un valor &lt;code&gt;Err&lt;/code&gt; que contiene un &lt;code&gt;io::Error&lt;/code&gt; . No sabemos qu&amp;eacute; har&amp;aacute; el c&amp;oacute;digo de llamada con esos valores. Si el c&amp;oacute;digo de llamada obtiene un valor &lt;code&gt;Err&lt;/code&gt; , &amp;iexcl;podr&amp;iacute;a llamar al &lt;code&gt;panic!&lt;/code&gt; y bloquear el programa, usar un nombre de usuario predeterminado o buscar el nombre de usuario en alg&amp;uacute;n lugar que no sea un archivo, por ejemplo. No tenemos suficiente informaci&amp;oacute;n sobre lo que realmente intenta hacer el c&amp;oacute;digo de llamada, por lo que propagamos toda la informaci&amp;oacute;n de &amp;eacute;xito o error hacia arriba para que la maneje adecuadamente.</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">La colección puede reservar más espacio para evitar reasignaciones frecuentes.</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">La coma que sigue a &lt;code&gt;$()&lt;/code&gt; indica que un car&amp;aacute;cter separador de coma literal podr&amp;iacute;a aparecer opcionalmente despu&amp;eacute;s del c&amp;oacute;digo que coincide con el c&amp;oacute;digo en &lt;code&gt;$()&lt;/code&gt; . El &lt;code&gt;*&lt;/code&gt; especifica que el patr&amp;oacute;n coincide con cero o m&amp;aacute;s de lo que precede al &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">El comando descarga un script e inicia la instalaci&amp;oacute;n de la herramienta &lt;code&gt;rustup&lt;/code&gt; , que instala la &amp;uacute;ltima versi&amp;oacute;n estable de Rust. Es posible que se le solicite su contrase&amp;ntilde;a. Si la instalaci&amp;oacute;n es exitosa, aparecer&amp;aacute; la siguiente l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">La parte com&amp;uacute;n de estas dos rutas es &lt;code&gt;std::io&lt;/code&gt; , y esa es la primera ruta completa. Para fusionar estas dos rutas en una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; , podemos usar &lt;code&gt;self&lt;/code&gt; en la ruta anidada, como se muestra en el Listado 7-20.</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">La funci&amp;oacute;n de comparador debe definir un orden total para los elementos del sector. Si el orden no es total, el orden de los elementos no se especifica. Una orden es una orden total si es (para todos &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">La función de comparación debe definir un orden total para los elementos de la rebanada.Si el orden no es total,el orden de los elementos no está especificado.Un orden es un orden total si lo es (para todos los a,b y c):</target>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">La funci&amp;oacute;n de comparaci&amp;oacute;n debe implementar un orden consistente con el orden de clasificaci&amp;oacute;n del segmento subyacente, devolviendo un c&amp;oacute;digo de orden que indique si su argumento es &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Equal&lt;/code&gt; o &lt;code&gt;Greater&lt;/code&gt; el objetivo deseado.</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">La comparaci&amp;oacute;n debe satisfacer, por todo &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">La compilaci&amp;oacute;n no produjo ning&amp;uacute;n error, pero el programa dio como resultado un error de &lt;em&gt;tiempo de ejecuci&amp;oacute;n&lt;/em&gt; y no se cerr&amp;oacute; correctamente. Cuando intentas acceder a un elemento usando la indexaci&amp;oacute;n, Rust verificar&amp;aacute; que el &amp;iacute;ndice que hayas especificado sea menor que la longitud de la matriz. Si el &amp;iacute;ndice es mayor o igual que la longitud de la matriz, Rust entrar&amp;aacute; en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">El modelo de compilaci&amp;oacute;n se centra en artefactos llamados &lt;em&gt;cajas&lt;/em&gt; . Cada compilaci&amp;oacute;n procesa una sola caja en forma de c&amp;oacute;digo fuente y, si tiene &amp;eacute;xito, produce una sola caja en forma binaria: ya sea un ejecutable o alg&amp;uacute;n tipo de biblioteca. &lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
