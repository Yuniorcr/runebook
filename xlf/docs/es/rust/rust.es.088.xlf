<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="fe6abd0552b2b40662057338eb474072bfd467ab" translate="yes" xml:space="preserve">
          <source>It can be implemented very efficiently on many platforms.</source>
          <target state="translated">Puede ser implementado muy eficientemente en muchas plataformas.</target>
        </trans-unit>
        <trans-unit id="1742a20f108d58ed46034272510180c651908ea6" translate="yes" xml:space="preserve">
          <source>It can be more efficient to read the contents of a file with a buffered &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;er. This can be accomplished with &lt;a href=&quot;../io/struct.bufreader&quot;&gt;&lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Puede ser m&amp;aacute;s eficiente para leer el contenido de un archivo con un tamp&amp;oacute;n &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; er. Esto se puede lograr con &lt;a href=&quot;../io/struct.bufreader&quot;&gt; &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="66395a368b8513422e9376d626f808ed1f8bf32e" translate="yes" xml:space="preserve">
          <source>It can be used to drop &lt;a href=&quot;../pin/index&quot;&gt;pinned&lt;/a&gt; data when &lt;code&gt;T&lt;/code&gt; is not &lt;code&gt;repr(packed)&lt;/code&gt; (pinned data must not be moved before it is dropped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a115494bb139f55de5b0b3f70529477957a7f61" translate="yes" xml:space="preserve">
          <source>It can occur, for example, when giving ill-formed UTF-8 bytes to &lt;a href=&quot;../string/struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;String::from_utf8_lossy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Puede ocurrir, por ejemplo, al dar bytes UTF-8 mal formados a &lt;a href=&quot;../string/struct.string#method.from_utf8_lossy&quot;&gt; &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99e2bcf85c866fbb510069805b1b10aa2dbd5078" translate="yes" xml:space="preserve">
          <source>It can occur, for example, when giving ill-formed UTF-8 bytes to &lt;a href=&quot;string/struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;String::from_utf8_lossy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865ab19a4feb80b70039c9bd315636afdebb41d4" translate="yes" xml:space="preserve">
          <source>It compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fe0776828801d6e4d2d0000fdfe545e88338bd" translate="yes" xml:space="preserve">
          <source>It consists of a data pointer and a &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;virtual function pointer table (vtable)&lt;/a&gt; that customizes the behavior of the &lt;code&gt;RawWaker&lt;/code&gt;.</source>
          <target state="translated">Consiste en un puntero de datos y una &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;tabla de puntero de funci&amp;oacute;n virtual (vtable)&lt;/a&gt; que personaliza el comportamiento del &lt;code&gt;RawWaker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="304308a190fdf4f0822058e40b620979e500ac31" translate="yes" xml:space="preserve">
          <source>It could also be that the browser is trying to connect to the server multiple times because the server isn&amp;rsquo;t responding with any data. When &lt;code&gt;stream&lt;/code&gt; goes out of scope and is dropped at the end of the loop, the connection is closed as part of the &lt;code&gt;drop&lt;/code&gt; implementation. Browsers sometimes deal with closed connections by retrying, because the problem might be temporary. The important factor is that we&amp;rsquo;ve successfully gotten a handle to a TCP connection!</source>
          <target state="translated">Tambi&amp;eacute;n podr&amp;iacute;a ser que el navegador est&amp;eacute; intentando conectarse al servidor varias veces porque el servidor no responde con ning&amp;uacute;n dato. Cuando la &lt;code&gt;stream&lt;/code&gt; sale del alcance y se descarta al final del bucle, la conexi&amp;oacute;n se cierra como parte de la implementaci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; . Los navegadores a veces tratan con conexiones cerradas volviendo a intentarlo, porque el problema puede ser temporal. &amp;iexcl;El factor importante es que hemos logrado manejar una conexi&amp;oacute;n TCP!</target>
        </trans-unit>
        <trans-unit id="ade427f6a9f3a1335d386816dffbf2fdc2034717" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; give you:</source>
          <target state="translated">No &lt;em&gt;te&lt;/em&gt; da:</target>
        </trans-unit>
        <trans-unit id="794a6ddebef5a3a25c88c1d2d823ee0600bddf9c" translate="yes" xml:space="preserve">
          <source>It does not have an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation, so you can't use it in a &lt;code&gt;for&lt;/code&gt; loop directly. This won't compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb73bdc252e7f6e26b2827c67cb797c04a45c79" translate="yes" xml:space="preserve">
          <source>It does not have an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation, so you can't use it in a &lt;code&gt;for&lt;/code&gt; loop directly. This won't compile:</source>
          <target state="translated">No tiene una implementaci&amp;oacute;n de &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , por lo que no puede usarlo en un bucle &lt;code&gt;for&lt;/code&gt; directamente. Esto no compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="74bec73f805593fee91ebe017ac47c318ef63b70" translate="yes" xml:space="preserve">
          <source>It does pass! Let&amp;rsquo;s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:</source>
          <target state="translated">&amp;iexcl;Pasa! Agreguemos otra prueba, esta vez afirmando que un rect&amp;aacute;ngulo m&amp;aacute;s peque&amp;ntilde;o no puede contener un rect&amp;aacute;ngulo m&amp;aacute;s grande:</target>
        </trans-unit>
        <trans-unit id="e2bf564d4c76feec85879b21bc874b8175ee437c" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t matter if we mix up width and height for the area calculation, but if we want to draw the rectangle on the screen, it would matter! We would have to keep in mind that &lt;code&gt;width&lt;/code&gt; is the tuple index &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is the tuple index &lt;code&gt;1&lt;/code&gt;. If someone else worked on this code, they would have to figure this out and keep it in mind as well. It would be easy to forget or mix up these values and cause errors, because we haven&amp;rsquo;t conveyed the meaning of our data in our code.</source>
          <target state="translated">No importa si mezclamos ancho y alto para el c&amp;aacute;lculo del &amp;aacute;rea, pero si queremos dibujar el rect&amp;aacute;ngulo en la pantalla, &amp;iexcl;importar&amp;iacute;a! Tendr&amp;iacute;amos que tener en cuenta que el &lt;code&gt;width&lt;/code&gt; es el &amp;iacute;ndice de tupla &lt;code&gt;0&lt;/code&gt; y la &lt;code&gt;height&lt;/code&gt; es el &amp;iacute;ndice de tupla &lt;code&gt;1&lt;/code&gt; . Si alguien m&amp;aacute;s trabajara en este c&amp;oacute;digo, tendr&amp;iacute;a que resolverlo y tenerlo en cuenta tambi&amp;eacute;n. Ser&amp;iacute;a f&amp;aacute;cil olvidar o mezclar estos valores y causar errores, porque no hemos transmitido el significado de nuestros datos en nuestro c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="d52b4ba1c15e44e888e3928ea17d62d2f1924cb8" translate="yes" xml:space="preserve">
          <source>It exposes more ways to deal with platform-specific strings (&lt;code&gt;OsStr&lt;/code&gt;, &lt;code&gt;OsString&lt;/code&gt;), allows to set permissions more granularly, extract low-level file descriptors from files and sockets, and has platform-specific helpers for spawning processes.</source>
          <target state="translated">Expone m&amp;aacute;s formas de lidiar con cadenas espec&amp;iacute;ficas de la plataforma ( &lt;code&gt;OsStr&lt;/code&gt; , &lt;code&gt;OsString&lt;/code&gt; ), permite establecer permisos de manera m&amp;aacute;s granular, extraer descriptores de archivos de bajo nivel de archivos y sockets, y tiene ayudantes espec&amp;iacute;ficos de la plataforma para los procesos de generaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7b00fd960002cfd9909fc9bce365f904914da1b7" translate="yes" xml:space="preserve">
          <source>It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file. Git files won&amp;rsquo;t be generated if you run &lt;code&gt;cargo new&lt;/code&gt; within an existing Git repository; you can override this behavior by using &lt;code&gt;cargo new --vcs=git&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11abb8c04f2668a58f566442bd95936d3058b5af" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; to call a function that is compiled with a feature that is not supported on the current platform the code is running on.</source>
          <target state="translated">Es &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;un comportamiento indefinido&lt;/a&gt; llamar a una funci&amp;oacute;n que est&amp;aacute; compilada con una caracter&amp;iacute;stica que no es compatible con la plataforma actual en la que se ejecuta el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="14b8fe5823c3e0b4ead46dab65d150ba97815143" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;unsafe&lt;/code&gt; to access a static item declared in an extern block, whether or not it's mutable.</source>
          <target state="translated">No es &lt;code&gt;unsafe&lt;/code&gt; acceder a un elemento est&amp;aacute;tico declarado en un bloque externo, sea o no mutable.</target>
        </trans-unit>
        <trans-unit id="789a56605a4c0fc94024c04229e1954360379606" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;required&lt;/em&gt; to use &lt;code&gt;drop_in_place&lt;/code&gt; to drop unsized types like trait objects, because they can't be read out onto the stack and dropped normally.</source>
          <target state="translated">Es &lt;em&gt;necesario&lt;/em&gt; usar &lt;code&gt;drop_in_place&lt;/code&gt; para colocar tipos sin tama&amp;ntilde;o como objetos de rasgo, porque no se pueden leer en la pila y soltar normalmente.</target>
        </trans-unit>
        <trans-unit id="122d47e267f58dbf245d83bbd151c9d835be4c42" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; considered an error if the entire buffer could not be written to this writer.</source>
          <target state="translated">Se &lt;strong&gt;no se&lt;/strong&gt; considera un error si toda la memoria intermedia no se puede escribir a este escritor.</target>
        </trans-unit>
        <trans-unit id="bf8bf34a5d274735d5f3f6b75aeb9079259905f3" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; recommended to use this function for a general try/catch mechanism. The &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type is more appropriate to use for functions that can fail on a regular basis. Additionally, this function is not guaranteed to catch all panics, see the &quot;Notes&quot; section below.</source>
          <target state="translated">Se &lt;strong&gt;no se&lt;/strong&gt; recomienda utilizar esta funci&amp;oacute;n para un mecanismo general try / catch. El tipo de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; es m&amp;aacute;s apropiado para usar con funciones que pueden fallar de forma regular. Adem&amp;aacute;s, no se garantiza que esta funci&amp;oacute;n detecte todos los p&amp;aacute;nicos, consulte la secci&amp;oacute;n &quot;Notas&quot; a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b1a810a5051116223295807560408c5af68cd37c" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; recommended to use this function for a general try/catch mechanism. The &lt;a href=&quot;../thread/type.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type is more appropriate to use for functions that can fail on a regular basis. Additionally, this function is not guaranteed to catch all panics, see the &quot;Notes&quot; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44c0918ab46b70725b0bcd2ecf83b8a768d4eb5" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que una clave se modifique de tal manera que el hash de la clave, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; , o su igualdad, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el mapa. Normalmente, esto solo es posible mediante &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="d5c36c17020650b28936fe4d1b2ab87233144be8" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que una clave se modifique de tal manera que el hash de la clave, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; , o su igualdad, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el mapa. Normalmente, esto solo es posible mediante &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="46331dafb0153e4395d3531f25654f92dc26340b" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the &lt;a href=&quot;../../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que una clave se modifique de tal manera que el orden de la clave en relaci&amp;oacute;n con cualquier otra clave, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el mapa. Normalmente, esto solo es posible mediante &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="85493dfb2b8e297a25b008cf35e5fe74ede0c214" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que una clave se modifique de tal manera que el orden de la clave en relaci&amp;oacute;n con cualquier otra clave, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el mapa. Normalmente, esto solo es posible mediante &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="3a06bdad2097a07f5094016d13cc933d3f72af47" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's hash, as determined by the &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que un elemento se modifique de tal manera que el hash del elemento, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; , o su igualdad, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el conjunto. Normalmente, esto solo es posible mediante &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="d42ef3a74bef90b249465c06d2f032ccefb653f1" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's hash, as determined by the &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que un elemento se modifique de tal manera que el hash del elemento, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; , o su igualdad, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el conjunto. Normalmente, esto solo es posible mediante &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="3ab5c67b79a448ca7bc9aba52ab29aac6f49d326" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;a href=&quot;../../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que un elemento se modifique de tal manera que el orden del elemento en relaci&amp;oacute;n con cualquier otro elemento, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el conjunto. Normalmente, esto solo es posible mediante &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="81558e504ca17a10e655e3f35b43a6c2e19151af" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que un elemento se modifique de tal manera que el orden del elemento en relaci&amp;oacute;n con cualquier otro elemento, seg&amp;uacute;n lo determinado por el rasgo &lt;a href=&quot;../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; , cambie mientras est&amp;aacute; en el conjunto. Normalmente, esto solo es posible mediante &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="5e476b6f2887551b48a3be2ee9ea6d582ce86836" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;code&gt;Ord&lt;/code&gt; trait, changes while it is in the heap. This is normally only possible through &lt;code&gt;Cell&lt;/code&gt;, &lt;code&gt;RefCell&lt;/code&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">Es un error l&amp;oacute;gico que un elemento se modifique de tal manera que el orden del elemento en relaci&amp;oacute;n con cualquier otro elemento, seg&amp;uacute;n lo determinado por el rasgo &lt;code&gt;Ord&lt;/code&gt; , cambie mientras est&amp;aacute; en el mont&amp;oacute;n. Normalmente, esto solo es posible mediante &lt;code&gt;Cell&lt;/code&gt; , &lt;code&gt;RefCell&lt;/code&gt; , estado global, E / S o c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="a1fecc95182812f5ebb362d1bac59ac94dc2f98d" translate="yes" xml:space="preserve">
          <source>It is a multiple of the alignment, including zero. The size can change depending on compiler version (as new optimizations are made) and target platform (similar to how &lt;code&gt;usize&lt;/code&gt; varies per-platform).</source>
          <target state="translated">Es un m&amp;uacute;ltiplo de la alineaci&amp;oacute;n, incluido el cero. El tama&amp;ntilde;o puede cambiar seg&amp;uacute;n la versi&amp;oacute;n del compilador (a medida que se realizan nuevas optimizaciones) y la plataforma de destino (similar a c&amp;oacute;mo el &lt;code&gt;usize&lt;/code&gt; var&amp;iacute;a seg&amp;uacute;n la plataforma).</target>
        </trans-unit>
        <trans-unit id="78d00f7fd123a3c3fdf75cbae3233ae2e6e3470e" translate="yes" xml:space="preserve">
          <source>It is allowed for the strong count to be 0 at the time of calling this. Nevertheless, this takes ownership of one weak reference currently represented as a raw pointer (the weak count is not modified by this operation) and therefore it must be paired with a previous call to &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f9d3e3312ad57e5a6d3bcdd50a937a22f832b6" translate="yes" xml:space="preserve">
          <source>It is also an error to have an unspecified discriminant where the previous discriminant is the maximum value for the size of the discriminant.</source>
          <target state="translated">También es un error tener un discriminante no especificado cuando el discriminante anterior es el valor máximo para el tamaño del discriminante.</target>
        </trans-unit>
        <trans-unit id="2aaa72db942d7c7ea290053204f195dee9198e63" translate="yes" xml:space="preserve">
          <source>It is also possible that immediately after &lt;code&gt;is_completed&lt;/code&gt; returns false, some other thread finishes executing &lt;code&gt;call_once&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n es posible que inmediatamente despu&amp;eacute;s de que &lt;code&gt;is_completed&lt;/code&gt; devuelva falso, alg&amp;uacute;n otro hilo termine de ejecutar &lt;code&gt;call_once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ceccce9e9543f68e6cf0b82b34ef37c7f04824" translate="yes" xml:space="preserve">
          <source>It is also possible to manually transmute:</source>
          <target state="translated">También es posible transmutar manualmente:</target>
        </trans-unit>
        <trans-unit id="b9152c587c216123563f72b60e624fb7b37150c7" translate="yes" xml:space="preserve">
          <source>It is also possible to overload most operators for your own type by implementing the &lt;code&gt;[OP]Assign&lt;/code&gt; traits from &lt;code&gt;std::ops&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n es posible sobrecargar la mayor&amp;iacute;a de los operadores para su propio tipo implementando &lt;code&gt;[OP]Assign&lt;/code&gt; traits de &lt;code&gt;std::ops&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c720012a3e805c9d62f2435d313e2b4c97a82fa" translate="yes" xml:space="preserve">
          <source>It is also possible to overload most operators for your own type by implementing traits from &lt;code&gt;std::ops&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n es posible sobrecargar la mayor&amp;iacute;a de los operadores para su propio tipo implementando rasgos de &lt;code&gt;std::ops&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="665d59482618a683a851550ec2845d9aceb97fe9" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;code&gt;super&lt;/code&gt; multiple times: &lt;code&gt;super::super::foo&lt;/code&gt;, going up the ancestor chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a0c387e81a8235a99c7d165954f2002b18f388" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enumerations&lt;/a&gt; to have a primitive representation.</source>
          <target state="translated">Es un error que &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;las enumeraciones&lt;/a&gt; con variantes cero tengan una representaci&amp;oacute;n primitiva.</target>
        </trans-unit>
        <trans-unit id="8b8784e54718e2a6d91bae7b9a9deae29e0d7cb7" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enumerations&lt;/a&gt; to have the &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">Es un error que &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;las enumeraciones&lt;/a&gt; con variantes cero tengan la representaci&amp;oacute;n en &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5e73da35c291d17423e4b430565c57bff241da2" translate="yes" xml:space="preserve">
          <source>It is an error to define two associated items (like methods, associated types, associated functions, etc.) with the same identifier.</source>
          <target state="translated">Es un error definir dos elementos asociados (como métodos,tipos asociados,funciones asociadas,etc.)con el mismo identificador.</target>
        </trans-unit>
        <trans-unit id="1ecd71d2b66919da6bca2d4ca4f7a151af58acc5" translate="yes" xml:space="preserve">
          <source>It is an error to pass a zero &lt;code&gt;Duration&lt;/code&gt; to this function.</source>
          <target state="translated">Es un error pasar una &lt;code&gt;Duration&lt;/code&gt; cero a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c705f9525d896b896f63b638e17d43664425dcf5" translate="yes" xml:space="preserve">
          <source>It is an error when two variants share the same discriminant.</source>
          <target state="translated">Es un error cuando dos variantes comparten el mismo discriminante.</target>
        </trans-unit>
        <trans-unit id="2f90cd6ec421d6e869d99b74e53a91895af9c5d9" translate="yes" xml:space="preserve">
          <source>It is available for use in stable rust from version 1.39 onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e066ad57d2ce7768c716de2f11bbba9cfbc5ef3" translate="yes" xml:space="preserve">
          <source>It is common to forget the trailing &lt;code&gt;!&lt;/code&gt; on macro invocations, which would also yield this error:</source>
          <target state="translated">&amp;iexcl;Es com&amp;uacute;n olvidar el final &lt;code&gt;!&lt;/code&gt; en las invocaciones de macros, lo que tambi&amp;eacute;n producir&amp;iacute;a este error:</target>
        </trans-unit>
        <trans-unit id="ab682946a2c7b0a4e860227b119766dc69c7e1ad" translate="yes" xml:space="preserve">
          <source>It is common to use &lt;code&gt;IntoIterator&lt;/code&gt; as a trait bound. This allows the input collection type to change, so long as it is still an iterator. Additional bounds can be specified by restricting on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">Es com&amp;uacute;n usar &lt;code&gt;IntoIterator&lt;/code&gt; como un l&amp;iacute;mite de rasgo. Esto permite que cambie el tipo de colecci&amp;oacute;n de entrada, siempre que siga siendo un iterador. Se pueden especificar l&amp;iacute;mites adicionales restringiendo el &lt;code&gt;Item&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="24d52c7dd0ec99d9a6af7862341acee02c183bdc" translate="yes" xml:space="preserve">
          <source>It is common to use the &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; iterator adapter to turn an infinite iterator into a finite one:</source>
          <target state="translated">Es com&amp;uacute;n usar el adaptador de iterador de &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; para convertir un iterador infinito en uno finito:</target>
        </trans-unit>
        <trans-unit id="c95bb9f004735a87f727f19d983aa3691d7d3210" translate="yes" xml:space="preserve">
          <source>It is considered an error if not all bytes could be written due to I/O errors or EOF being reached.</source>
          <target state="translated">Se considera un error si no se pueden escribir todos los bytes debido a errores de E/S o EOF.</target>
        </trans-unit>
        <trans-unit id="3bd73943cb17deb4f2b3ccabad843f693f98447d" translate="yes" xml:space="preserve">
          <source>It is considered an error if the directory already exists unless recursive mode is enabled.</source>
          <target state="translated">Se considera un error si el directorio ya existe,a menos que se active el modo recursivo.</target>
        </trans-unit>
        <trans-unit id="537243f1f25a0d4711910325fd3d083b4262a463" translate="yes" xml:space="preserve">
          <source>It is critical to call &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; is dropped. Though dropping will attempt to flush the contents of the buffer, any errors that happen in the process of dropping will be ignored. Calling &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; ensures that the buffer is empty and thus dropping will not even attempt file operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b8c7a920e8c6cdcbcebde2d4eda5f284d3bbea" translate="yes" xml:space="preserve">
          <source>It is currently impossible to create raw pointers to unaligned fields of a packed struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c36c5e7602baf3c3616b07cef1f3665caf1d22" translate="yes" xml:space="preserve">
          <source>It is currently undefined behavior to unwind from Rust code into foreign code, so this function is particularly useful when Rust is called from another language (normally C). This can run arbitrary Rust code, capturing a panic and allowing a graceful handling of the error.</source>
          <target state="translated">Actualmente,es un comportamiento indefinido el pasar del código de Rust a un código extranjero,por lo que esta función es particularmente útil cuando se llama a Rust desde otro idioma (normalmente C).Esto puede ejecutar un código Rust arbitrario,capturando el pánico y permitiendo un manejo elegante del error.</target>
        </trans-unit>
        <trans-unit id="5c66ccca042f9b01dffd3651727dd1995756e7b3" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;OpenOptions::new()&lt;/code&gt; but allows you to write more readable code. Instead of &lt;code&gt;OpenOptions::new().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt; you can write &lt;code&gt;File::with_options().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt;. This also avoids the need to import &lt;code&gt;OpenOptions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae5ff64ed07894b48692747efd0c02dda81558f" translate="yes" xml:space="preserve">
          <source>It is fine only if you put something back. &lt;code&gt;mem::replace&lt;/code&gt; can be used for that:</source>
          <target state="translated">Est&amp;aacute; bien solo si devuelve algo. &lt;code&gt;mem::replace&lt;/code&gt; se puede usar para eso:</target>
        </trans-unit>
        <trans-unit id="c557fd6825bdb89ba5f031ec165be0dd6a26ff58" translate="yes" xml:space="preserve">
          <source>It is friendlier to the optimizer to do this over &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; when dropping manually allocated memory (e.g., when writing Box/Rc/Vec), as the compiler doesn't need to prove that it's sound to elide the copy.</source>
          <target state="translated">Es m&amp;aacute;s amigable para el optimizador hacer esto sobre &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; cuando suelta memoria asignada manualmente (por ejemplo, al escribir Box / Rc / Vec), ya que el compilador no necesita demostrar que es correcto eludir la copia.</target>
        </trans-unit>
        <trans-unit id="98cf066d0eeb6931da37108448f70da379f6d2ff" translate="yes" xml:space="preserve">
          <source>It is friendlier to the optimizer to do this over &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; when dropping manually allocated memory (e.g., when writing Box/Rc/Vec), as the compiler doesn't need to prove that it's sound to elide the copy.</source>
          <target state="translated">Es m&amp;aacute;s amigable para el optimizador hacer esto sobre &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; cuando suelta memoria asignada manualmente (por ejemplo, al escribir Box / Rc / Vec), ya que el compilador no necesita demostrar que es correcto eludir la copia.</target>
        </trans-unit>
        <trans-unit id="ed685795cf4962708592336505a9a35be53c890e" translate="yes" xml:space="preserve">
          <source>It is further guaranteed that, for the cases above, one can &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; from all valid values of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and from &lt;code&gt;Some::&amp;lt;T&amp;gt;(_)&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt; (but transmuting &lt;code&gt;None::&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt; is undefined behaviour).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a482eb06332931aa49748cd7170635733f6d060d" translate="yes" xml:space="preserve">
          <source>It is important to note that although the returned vector has the &lt;em&gt;capacity&lt;/em&gt; specified, the vector will have a zero &lt;em&gt;length&lt;/em&gt;. For an explanation of the difference between length and capacity, see &lt;em&gt;&lt;a href=&quot;#capacity-and-reallocation&quot;&gt;Capacity and reallocation&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Es importante tener en cuenta que aunque el vector devuelto tiene la &lt;em&gt;capacidad&lt;/em&gt; especificada, el vector tendr&amp;aacute; una &lt;em&gt;longitud&lt;/em&gt; cero . Para obtener una explicaci&amp;oacute;n de la diferencia entre longitud y capacidad, consulte &lt;em&gt;&lt;a href=&quot;#capacity-and-reallocation&quot;&gt;Capacidad y reasignaci&amp;oacute;n&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c3de289a473969bb492d7f49323becca72758c15" translate="yes" xml:space="preserve">
          <source>It is important to note that both back and forth work on the same range, and do not cross: iteration is over when they meet in the middle.</source>
          <target state="translated">Es importante señalar que tanto la ida como la vuelta trabajan en el mismo rango,y no se cruzan:la iteración se termina cuando se encuentran en el medio.</target>
        </trans-unit>
        <trans-unit id="688443f49dee6c57698fbe38d0a4fd0c6b98badb" translate="yes" xml:space="preserve">
          <source>It is important to understand that &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; does not provide a &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; implementation (as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; does with &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;). Therefore, you should always try to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and then fall back to &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; can't be implemented.</source>
          <target state="translated">Es importante comprender que &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; no proporciona una implementaci&amp;oacute;n &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; (como lo hace &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; con &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; ). Por lo tanto, siempre debe intentar implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; y luego volver a &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; si no se puede implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b60eba4804f29ceedf6d48ba368778e00e21367" translate="yes" xml:space="preserve">
          <source>It is impossible to define an integer type to be used to represent zero-variant enum values because there are no zero-variant enum values. There is no way to construct an instance of the following type using only safe code. So you have two solutions. Either you add variants in your enum:</source>
          <target state="translated">Es imposible definir un tipo entero que se utilice para representar valores enumerativos de variante cero porque no hay valores enumerativos de variante cero.No hay forma de construir una instancia del siguiente tipo usando sólo código seguro.Así que tienes dos soluciones.O bien añades variantes en tu enum:</target>
        </trans-unit>
        <trans-unit id="4d5291d52684a5eab8a4aab9333d7cc4b2cb958b" translate="yes" xml:space="preserve">
          <source>It is inadvisable to directly read from the underlying reader.</source>
          <target state="translated">No es aconsejable leer directamente del lector subyacente.</target>
        </trans-unit>
        <trans-unit id="f3c4bfe06953b97ae05b73dab70d1d3859db96ce" translate="yes" xml:space="preserve">
          <source>It is inadvisable to directly write to the underlying writer.</source>
          <target state="translated">No es aconsejable escribir directamente al escritor subyacente.</target>
        </trans-unit>
        <trans-unit id="8ec3e32d91034e8ec262cdcaaa5495ade82532d3" translate="yes" xml:space="preserve">
          <source>It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an &lt;code&gt;unsafe&lt;/code&gt; context is not required to &quot;await&quot; it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dbb1246b199ac521c8acb1693aa5061246652a" translate="yes" xml:space="preserve">
          <source>It is not a compile-time error if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have different sizes, but it is highly encouraged to only invoke this function where &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size. This function triggers &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; if &lt;code&gt;U&lt;/code&gt; is larger than &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">No es un error en tiempo de compilaci&amp;oacute;n si &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; tienen diferentes tama&amp;ntilde;os, pero se recomienda encarecidamente invocar esta funci&amp;oacute;n solo cuando &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; tengan el mismo tama&amp;ntilde;o. Esta funci&amp;oacute;n activa &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;indefinido comportamiento&lt;/a&gt; si &lt;code&gt;U&lt;/code&gt; es mayor que &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8633689304bc80e12157956bafdee7aa5571ef8" translate="yes" xml:space="preserve">
          <source>It is not allowed to cast to a bool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804904553c24d5c3119a2a373f46ee3afe1e1bcf" translate="yes" xml:space="preserve">
          <source>It is not allowed to cast to a bool. If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">No está permitido lanzar a un bool.Si estás tratando de lanzar un tipo numérico a un bolo,puedes compararlo con el cero en su lugar:</target>
        </trans-unit>
        <trans-unit id="3fc97c498b6845f6dd515270a06b8fc333df6ada" translate="yes" xml:space="preserve">
          <source>It is not allowed to manually call destructors in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c9437daa5a5b2d54fcaf5cf82931c13dd48503" translate="yes" xml:space="preserve">
          <source>It is not allowed to manually call destructors in Rust. It is also not necessary to do this since &lt;code&gt;drop&lt;/code&gt; is called automatically whenever a value goes out of scope.</source>
          <target state="translated">No est&amp;aacute; permitido llamar manualmente a destructores en Rust. Tampoco es necesario hacer esto ya que &lt;code&gt;drop&lt;/code&gt; se llama autom&amp;aacute;ticamente cada vez que un valor sale del alcance.</target>
        </trans-unit>
        <trans-unit id="0af3651d21c13332936be1aeb070069427b04863" translate="yes" xml:space="preserve">
          <source>It is not allowed to use or capture an uninitialized variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7767b89b540932cb942c6e1844049703b82b847b" translate="yes" xml:space="preserve">
          <source>It is not allowed to use or capture an uninitialized variable. For example:</source>
          <target state="translated">No se permite utilizar o capturar una variable no inicializada.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9ec565a6be063138e105edece3d9609dbd23ba59" translate="yes" xml:space="preserve">
          <source>It is not always equivalent to a closure like &lt;code&gt;|x| x&lt;/code&gt; since the closure may coerce &lt;code&gt;x&lt;/code&gt; into a different type.</source>
          <target state="translated">No siempre es equivalente a un cierre como &lt;code&gt;|x| x&lt;/code&gt; ya que el cierre puede coaccionar a &lt;code&gt;x&lt;/code&gt; en un tipo diferente.</target>
        </trans-unit>
        <trans-unit id="d85afe6ee8d10535dc66c9e1b7be7b3cdd688a64" translate="yes" xml:space="preserve">
          <source>It is not always equivalent to a closure like &lt;code&gt;|x| x&lt;/code&gt;, since the closure may coerce &lt;code&gt;x&lt;/code&gt; into a different type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1671d6fa1d906f29299a5bc6eb309657467bdad" translate="yes" xml:space="preserve">
          <source>It is not an error if the returned value &lt;code&gt;n&lt;/code&gt; is smaller than the buffer size, even when the reader is not at the end of the stream yet. This may happen for example because fewer bytes are actually available right now (e. g. being close to end-of-file) or because read() was interrupted by a signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7dcfb4170b72e2facf78d57d95eed97b2a6250" translate="yes" xml:space="preserve">
          <source>It is not an error to define a macro multiple times; the most recent declaration will shadow the previous one unless it has gone out of scope.</source>
          <target state="translated">No es un error definir una macro varias veces;la declaración más reciente ensombrecerá la anterior a menos que se haya salido del ámbito de aplicación.</target>
        </trans-unit>
        <trans-unit id="fe10caafa0ee23dcebc8469f9e22713be6e1455c" translate="yes" xml:space="preserve">
          <source>It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.</source>
          <target state="translated">No se exige que la aplicación de un iterador produzca el número de elementos declarados.Un iterador de buggy puede rendir menos que el límite inferior o más que el límite superior de elementos.</target>
        </trans-unit>
        <trans-unit id="b8f822d10fd7f248875122ae295429f7075d08d7" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that the memory pointed by &lt;code&gt;ptr&lt;/code&gt; won't change before the &lt;code&gt;CStr&lt;/code&gt; has been destroyed.</source>
          <target state="translated">No se garantiza que la memoria se&amp;ntilde;alada por &lt;code&gt;ptr&lt;/code&gt; no cambie antes de que se haya destruido &lt;code&gt;CStr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63ef7dab9cc8c89ff48dae3884d5439039407f4c" translate="yes" xml:space="preserve">
          <source>It is not intended that most types or functions need to worry about this trait. It is only used as a bound on the &lt;code&gt;catch_unwind&lt;/code&gt; function and as mentioned above, the lack of &lt;code&gt;unsafe&lt;/code&gt; means it is mostly an advisory. The &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to force this trait to be implemented for any closed over variables passed to &lt;code&gt;catch_unwind&lt;/code&gt;.</source>
          <target state="translated">No se pretende que la mayor&amp;iacute;a de los tipos o funciones deban preocuparse por este rasgo. Solo se usa como un l&amp;iacute;mite en la funci&amp;oacute;n &lt;code&gt;catch_unwind&lt;/code&gt; y, como se mencion&amp;oacute; anteriormente, la falta de &lt;code&gt;unsafe&lt;/code&gt; significa que es principalmente un aviso. La &lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt; envoltura AssertUnwindSafe se puede usar para forzar la implementaci&amp;oacute;n de este rasgo para cualquier variable cerrada que se pase a &lt;code&gt;catch_unwind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f3040279fd242d13257751040f971829001939" translate="yes" xml:space="preserve">
          <source>It is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</source>
          <target state="translated">No es necesario anotar el tipo completo.Una vez resuelta la ambigüedad,el compilador puede inferir el resto:</target>
        </trans-unit>
        <trans-unit id="79ac203d9d8f6d2d15f792ef9b54266d902c1bf2" translate="yes" xml:space="preserve">
          <source>It is not possible to declare type parameters on a function that has the &lt;code&gt;start&lt;/code&gt; attribute. Such a function must have the following type signature (for more information, view &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib&quot;&gt;the unstable book&lt;/a&gt;):</source>
          <target state="translated">No es posible declarar par&amp;aacute;metros de tipo en una funci&amp;oacute;n que tiene el atributo de &lt;code&gt;start&lt;/code&gt; . Dicha funci&amp;oacute;n debe tener la siguiente firma de tipo (para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib&quot;&gt;el libro inestable&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="de00175d000048a3ab2db1da305a9746730281d2" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with a where clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5f5303b9508d3572ecb0aabe587d9c97215e2a" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with a where clause. Erroneous code example:</source>
          <target state="translated">No es posible definir &lt;code&gt;main&lt;/code&gt; con una cl&amp;aacute;usula where. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="d0b1c5c12eac01beb248497b03a0ab70e561e5a5" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with generic parameters. When &lt;code&gt;main&lt;/code&gt; is present, it must take no arguments and return &lt;code&gt;()&lt;/code&gt;. Erroneous code example:</source>
          <target state="translated">No es posible definir &lt;code&gt;main&lt;/code&gt; con par&amp;aacute;metros gen&amp;eacute;ricos. Cuando &lt;code&gt;main&lt;/code&gt; est&amp;aacute; presente, no debe tomar argumentos y devolver &lt;code&gt;()&lt;/code&gt; . Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="dac867cdafaa004a57591e1391a5068dc6cc6e4a" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;start&lt;/code&gt; with a where clause. Erroneous code example:</source>
          <target state="translated">No es posible definir &lt;code&gt;start&lt;/code&gt; con una cl&amp;aacute;usula where. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="77edaee193e2b26f0dc132c04fc983d7a3f09123" translate="yes" xml:space="preserve">
          <source>It is not possible to define the &lt;code&gt;main&lt;/code&gt; function with generic parameters. It must not take any arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4484b8793e84f3d96cf9d91150a25ddc1b027" translate="yes" xml:space="preserve">
          <source>It is not possible to use stability attributes outside of the standard library. Also, for now, it is not possible to write deprecation messages either.</source>
          <target state="translated">No es posible utilizar atributos de estabilidad fuera de la biblioteca estándar.Además,por ahora,tampoco es posible escribir mensajes de depreciación.</target>
        </trans-unit>
        <trans-unit id="a4bacc3cad49d167308e0fdf3be52c1450a1de33" translate="yes" xml:space="preserve">
          <source>It is not valid to put positional parameters (those without names) after arguments that have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babf4563d827f22cdca258081ab4debae3695f91" translate="yes" xml:space="preserve">
          <source>It is not valid to put positional parameters (those without names) after arguments which have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.</source>
          <target state="translated">No es válido poner parámetros posicionales (los que no tienen nombre)después de los argumentos que tienen nombre.Al igual que con los parámetros posicionales,no es válido proporcionar parámetros con nombre que no sean utilizados por la cadena de formato.</target>
        </trans-unit>
        <trans-unit id="d3ba3f42fb0bf8686407f3cf8b99f8a8d970d5d7" translate="yes" xml:space="preserve">
          <source>It is often seen in its borrowed forms, either mutable or shared. The shared slice type is &lt;code&gt;&amp;amp;[T]&lt;/code&gt;, while the mutable slice type is &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; represents the element type.</source>
          <target state="translated">A menudo se ve en sus formas prestadas, ya sea mutable o compartida. El tipo de sector compartido es &lt;code&gt;&amp;amp;[T]&lt;/code&gt; , mientras que el tipo de sector mutable es &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; representa el tipo de elemento.</target>
        </trans-unit>
        <trans-unit id="2fab516d94cc4b051eccfa289cd47f35b51a6906" translate="yes" xml:space="preserve">
          <source>It is possible for &lt;code&gt;addr&lt;/code&gt; to yield multiple addresses, but &lt;code&gt;send_to&lt;/code&gt; will only send data to the first address yielded by &lt;code&gt;addr&lt;/code&gt;.</source>
          <target state="translated">Es posible que &lt;code&gt;addr&lt;/code&gt; produzca varias direcciones, pero &lt;code&gt;send_to&lt;/code&gt; solo enviar&amp;aacute; datos a la primera direcci&amp;oacute;n proporcionada por &lt;code&gt;addr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6369907ebe6b468b9a2ca85d26bcb0993424305d" translate="yes" xml:space="preserve">
          <source>It is possible to seek beyond the end of an object, but it's an error to seek before byte 0.</source>
          <target state="translated">Es posible buscar más allá del final de un objeto,pero es un error buscar antes del byte 0.</target>
        </trans-unit>
        <trans-unit id="fdaed3dad08dda198d1195920589e6980812bcbd" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;ManuallyDrop&lt;/code&gt; to control the drop order, but this requires unsafe code and is hard to do correctly in the presence of unwinding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2042bff8db30718f4be68e6828fc24e384458a" translate="yes" xml:space="preserve">
          <source>It is possible to use pattern matching on &lt;code&gt;union&lt;/code&gt;s. A single field name must be used and it must match the name of one of the &lt;code&gt;union&lt;/code&gt;'s field. Like reading from a &lt;code&gt;union&lt;/code&gt;, pattern matching on a &lt;code&gt;union&lt;/code&gt; requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecc5cbf610b50fb9b85dc5d9562253999d191e2" translate="yes" xml:space="preserve">
          <source>It is possible, however, for &lt;strong&gt;logical&lt;/strong&gt; invariants to be broken in Rust, which can end up causing behavioral bugs. Another key aspect of unwind safety in Rust is that, in the absence of &lt;code&gt;unsafe&lt;/code&gt; code, a panic cannot lead to memory unsafety.</source>
          <target state="translated">Sin embargo, es posible que &lt;strong&gt;las&lt;/strong&gt; invariantes &lt;strong&gt;l&amp;oacute;gicas&lt;/strong&gt; se rompan en Rust, lo que puede terminar provocando errores de comportamiento. Otro aspecto clave de la seguridad de desconexi&amp;oacute;n en Rust es que, en ausencia de &lt;code&gt;unsafe&lt;/code&gt; c&amp;oacute;digo inseguro , el p&amp;aacute;nico no puede conducir a la inseguridad de la memoria.</target>
        </trans-unit>
        <trans-unit id="da80bba13418a2462cda990927908d8ad7892c41" translate="yes" xml:space="preserve">
          <source>It is recommended that you look for a &lt;code&gt;new&lt;/code&gt; function or equivalent in the crate's documentation.</source>
          <target state="translated">Se recomienda que busque una funci&amp;oacute;n &lt;code&gt;new&lt;/code&gt; o equivalente en la documentaci&amp;oacute;n de la caja.</target>
        </trans-unit>
        <trans-unit id="158d82d49dddadcae62bf58b7e9d48850c1ba3f3" translate="yes" xml:space="preserve">
          <source>It is required that the keys implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">Se requiere que las claves implementen los rasgos &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; , aunque esto se puede lograr frecuentemente usando &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; . Si los implementa usted mismo, es importante que se mantenga la siguiente propiedad:</target>
        </trans-unit>
        <trans-unit id="1c5f8488f4eecd7c3ca6dd6e0c4ceb285589eb45" translate="yes" xml:space="preserve">
          <source>It is required that the keys implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">Se requiere que las claves implementen los rasgos &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; , aunque esto se puede lograr frecuentemente usando &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; . Si los implementa usted mismo, es importante que se mantenga la siguiente propiedad:</target>
        </trans-unit>
        <trans-unit id="9e65409691544dfbd0d6482536ef748a0086ee53" translate="yes" xml:space="preserve">
          <source>It is returned by the &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Es devuelto por el m&amp;eacute;todo &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43f6a5e55fbbfc805831e83b9b3a4f775c58ea12" translate="yes" xml:space="preserve">
          <source>It is roughly equal to a duration of 584,942,417,355 years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e22d2249ea3cf1183d26c8fb6b0c9e7619f06c9" translate="yes" xml:space="preserve">
          <source>It is semantically a wrapper around an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, but is guaranteed to be ABI compatible with the &lt;code&gt;iovec&lt;/code&gt; type on Unix platforms and &lt;code&gt;WSABUF&lt;/code&gt; on Windows.</source>
          <target state="translated">Es sem&amp;aacute;nticamente un envoltorio alrededor de un &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; , pero se garantiza que es compatible con ABI con el tipo &lt;code&gt;iovec&lt;/code&gt; en plataformas Unix y &lt;code&gt;WSABUF&lt;/code&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="310066900f319893888448530eda337cc1113b35" translate="yes" xml:space="preserve">
          <source>It is semantically a wrapper around an &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;, but is guaranteed to be ABI compatible with the &lt;code&gt;iovec&lt;/code&gt; type on Unix platforms and &lt;code&gt;WSABUF&lt;/code&gt; on Windows.</source>
          <target state="translated">Es sem&amp;aacute;nticamente un envoltorio alrededor de &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; , pero se garantiza que es compatible con ABI con el tipo &lt;code&gt;iovec&lt;/code&gt; en plataformas Unix y &lt;code&gt;WSABUF&lt;/code&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="d5c70546718e8bec6af4968356db7e36252be3a4" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to manually drop the mutex guard to unlock it sooner than the end of the enclosing scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e8beb4413ce9188f6c9ea8439432ef5b9611d2" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to have objects that are guaranteed not to move, in the sense that their placement in memory does not change, and can thus be relied upon. A prime example of such a scenario would be building self-referential structs, as moving an object with pointers to itself will invalidate them, which could cause undefined behavior.</source>
          <target state="translated">A veces es útil tener objetos que estén garantizados para no moverse,en el sentido de que su colocación en la memoria no cambia,y por lo tanto se puede confiar en ellos.Un buen ejemplo de este tipo de escenario sería la construcción de estructuras autorreferenciales,ya que mover un objeto con punteros hacia sí mismo los invalidaría,lo que podría causar un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="4371e8f3f7450e76f6a242238c801628a1cbf06b" translate="yes" xml:space="preserve">
          <source>It is the declarations that make up the contract of traits and what is available on generic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37c9a79672120af34904e218ec499be2dd86aef" translate="yes" xml:space="preserve">
          <source>It is the declarations that make up the contract of traits and what it available on generic types.</source>
          <target state="translated">Son las declaraciones las que conforman el contrato de los rasgos y lo que está disponible en los tipos genéricos.</target>
        </trans-unit>
        <trans-unit id="0b7557ddb14fd9cccc6582df092ab6f10becd5d9" translate="yes" xml:space="preserve">
          <source>It is the maximum index such that &lt;code&gt;from_utf8(&amp;amp;input[..index])&lt;/code&gt; would return &lt;code&gt;Ok(_)&lt;/code&gt;.</source>
          <target state="translated">Es el &amp;iacute;ndice m&amp;aacute;ximo tal que &lt;code&gt;from_utf8(&amp;amp;input[..index])&lt;/code&gt; devolver&amp;iacute;a &lt;code&gt;Ok(_)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b264294fdd4a01382c3aea7e168cfb7358441c48" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility when writing &lt;code&gt;unsafe&lt;/code&gt; code to ensure that any safe code interacting with the &lt;code&gt;unsafe&lt;/code&gt; code cannot trigger these behaviors. &lt;code&gt;unsafe&lt;/code&gt; code that satisfies this property for any safe client is called &lt;em&gt;sound&lt;/em&gt;; if &lt;code&gt;unsafe&lt;/code&gt; code can be misused by safe code to exhibit undefined behavior, it is &lt;em&gt;unsound&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ade12a490d1fb2caaede62e82d953ed5a36f49" translate="yes" xml:space="preserve">
          <source>It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated sorted sequences.</source>
          <target state="translated">Suele ser más rápido que la clasificación estable,salvo en algunos casos especiales,por ejemplo,cuando la rebanada consta de varias secuencias clasificadas concatenadas.</target>
        </trans-unit>
        <trans-unit id="a75ff90de5ca8eff04b8583b7bb1f33e14e7d147" translate="yes" xml:space="preserve">
          <source>It is undefined behavior for this operation to overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;. If you cannot guarantee that this will not overflow, use &lt;code&gt;backward&lt;/code&gt; or &lt;code&gt;backward_checked&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8054d51290c5e837766cf36b3dc8b91cb98821" translate="yes" xml:space="preserve">
          <source>It is undefined behavior for this operation to overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;. If you cannot guarantee that this will not overflow, use &lt;code&gt;forward&lt;/code&gt; or &lt;code&gt;forward_checked&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acc32d24d7d6395cf0c7d59cd524a48233ae10a" translate="yes" xml:space="preserve">
          <source>It is unnecessary to do this since &lt;code&gt;drop&lt;/code&gt; is called automatically whenever a value goes out of scope. However, if you really need to drop a value by hand, you can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e547b1d483f3958a2447866fe3c4d46a3e009d" translate="yes" xml:space="preserve">
          <source>It is unspecified how many elements are removed from the vector if the &lt;code&gt;Splice&lt;/code&gt; value is leaked.</source>
          <target state="translated">No se especifica cu&amp;aacute;ntos elementos se eliminan del vector si se filtra el valor de &lt;code&gt;Splice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="295705b2fa436290d781c9b500c921db48521039" translate="yes" xml:space="preserve">
          <source>It is unspecified how many more elements will be subjected to the closure if a panic occurs in the closure, or a panic occurs while dropping an element, or if the &lt;code&gt;DrainFilter&lt;/code&gt; value is leaked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e979093f4634e70883c1e6b5d99af22f995783" translate="yes" xml:space="preserve">
          <source>It is unspecified how many more values will be subjected to the closure if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the &lt;code&gt;DrainFilter&lt;/code&gt; itself is leaked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cad4b99027fa4acf9843034ac2fdd309a68ec9" translate="yes" xml:space="preserve">
          <source>It is up to the caller to ensure that the object is still alive when accessing it through the pointer.</source>
          <target state="translated">Depende de la persona que llama asegurarse de que el objeto sigue vivo cuando se accede a él a través del puntero.</target>
        </trans-unit>
        <trans-unit id="98956152124bb7bc80eb86d315a85b9b45c037d0" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; elements really are in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa61fcbe3608674ea2f0e3a8facadbaeb00b9db0" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior. The &lt;a href=&quot;#initialization-invariant&quot;&gt;type-level documentation&lt;/a&gt; contains more information about this initialization invariant.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; la persona que llama garantizar que el MaybeUninit &amp;lt;T&amp;gt; realmente se encuentra en un estado inicializado. Llamar a esto cuando el contenido a&amp;uacute;n no est&amp;aacute; completamente inicializado provoca un comportamiento indefinido inmediato. La &lt;a href=&quot;#initialization-invariant&quot;&gt;documentaci&amp;oacute;n a nivel de tipo&lt;/a&gt; contiene m&amp;aacute;s informaci&amp;oacute;n sobre este invariante de inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e90618210aeb35b7fbf1d0dce959c7d288e195c5" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; la persona que llama garantizar que el MaybeUninit &amp;lt;T&amp;gt; realmente se encuentra en un estado inicializado. Llamar a esto cuando el contenido a&amp;uacute;n no est&amp;aacute; completamente inicializado provoca un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="1cc21693b6059e6e8119cffad058e61a70eeecf5" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior. The &lt;a href=&quot;#initialization-invariant&quot;&gt;type-level documentation&lt;/a&gt; contains more information about this initialization invariant.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; la persona que llama garantizar que el MaybeUninit &amp;lt;T&amp;gt; realmente se encuentra en un estado inicializado. Llamar a esto cuando el contenido a&amp;uacute;n no est&amp;aacute; completamente inicializado provoca un comportamiento indefinido. La &lt;a href=&quot;#initialization-invariant&quot;&gt;documentaci&amp;oacute;n a nivel de tipo&lt;/a&gt; contiene m&amp;aacute;s informaci&amp;oacute;n sobre este invariante de inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ea0a0e4346d92e82b2088690613099c2bf07dc7c" translate="yes" xml:space="preserve">
          <source>It is used by the &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Es utilizado por el rasgo de &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76aa244bb958db0a4b9e995026430044d057625c" translate="yes" xml:space="preserve">
          <source>It is used with the &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Se usa con el tipo &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1ece6b57f7a1f8dc31198244f231a713dd3042" translate="yes" xml:space="preserve">
          <source>It is valid to add the &lt;code&gt;link&lt;/code&gt; attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.</source>
          <target state="translated">Es v&amp;aacute;lido agregar el atributo de &lt;code&gt;link&lt;/code&gt; en un bloque externo vac&amp;iacute;o. Puede usar esto para satisfacer los requisitos de vinculaci&amp;oacute;n de bloques externos en otras partes de su c&amp;oacute;digo (incluidas las cajas ascendentes) en lugar de agregar el atributo a cada bloque externo.</target>
        </trans-unit>
        <trans-unit id="d3e90c3943be0d42f62f18b3f27da88ff78617f2" translate="yes" xml:space="preserve">
          <source>It is worth reiterating that &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; change the fact that a Rust compiler considers all types movable. &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; remains callable for any &lt;code&gt;T&lt;/code&gt;. Instead, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; prevents certain &lt;em&gt;values&lt;/em&gt; (pointed to by pointers wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;) from being moved by making it impossible to call methods that require &lt;code&gt;&amp;amp;mut T&lt;/code&gt; on them (like &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6738e5c58c6dd95792620faa63b8d5cc231a8b6d" translate="yes" xml:space="preserve">
          <source>It is worth reiterating that &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; change the fact that a Rust compiler considers all types movable. &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; remains callable for any &lt;code&gt;T&lt;/code&gt;. Instead, &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; prevents certain &lt;em&gt;values&lt;/em&gt; (pointed to by pointers wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;) from being moved by making it impossible to call methods that require &lt;code&gt;&amp;amp;mut T&lt;/code&gt; on them (like &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Vale la pena reiterar que &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; Qu&amp;eacute; &lt;em&gt;no&lt;/em&gt; cambia el hecho de que un compilador Rust considera todos los tipos m&amp;oacute;viles. &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; sigue siendo exigible para cualquier &lt;code&gt;T&lt;/code&gt; . En cambio, &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; evita que ciertos &lt;em&gt;valores&lt;/em&gt; (se&amp;ntilde;alados por punteros envueltos en &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; ) se muevan al hacer imposible llamar a m&amp;eacute;todos que requieren &lt;code&gt;&amp;amp;mut T&lt;/code&gt; en ellos (como&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0497668f013a73ed21db051aa84713bf2b2c56fa" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;cfg&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, a configuration predicate, and finally &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">Est&amp;aacute; escrito como &lt;code&gt;cfg&lt;/code&gt; , &lt;code&gt;(&lt;/code&gt; , un predicado de configuraci&amp;oacute;n, y finalmente &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff3c5f08953486f2ebadb5983fbdd75f91d8e664" translate="yes" xml:space="preserve">
          <source>It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.</source>
          <target state="translated">Es tu responsabilidad asegurarte de que el trozo de cuerda sólo se modifique de manera que siga siendo válido UTF-8.</target>
        </trans-unit>
        <trans-unit id="e9c82e577605ff32cb90a4cd85e5d6c96aa90577" translate="yes" xml:space="preserve">
          <source>It is your responsibility to make sure that the underlying memory is not freed too early. For example, the following code will cause undefined behavior when &lt;code&gt;ptr&lt;/code&gt; is used inside the &lt;code&gt;unsafe&lt;/code&gt; block:</source>
          <target state="translated">Es su responsabilidad asegurarse de que la memoria subyacente no se libere demasiado pronto. Por ejemplo, el siguiente c&amp;oacute;digo provocar&amp;aacute; un comportamiento indefinido cuando se use &lt;code&gt;ptr&lt;/code&gt; dentro del bloque &lt;code&gt;unsafe&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e3a6e91bbdb9a45516082a07a40a29592b3f0cb" translate="yes" xml:space="preserve">
          <source>It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there&amp;rsquo;s a convenient shorthand!</source>
          <target state="translated">Tiene sentido nombrar los par&amp;aacute;metros de la funci&amp;oacute;n con el mismo nombre que los campos de estructura, pero tener que repetir los nombres y variables de los campos de &lt;code&gt;email&lt;/code&gt; y &lt;code&gt;username&lt;/code&gt; es un poco tedioso. Si la estructura tuviera m&amp;aacute;s campos, repetir cada nombre se volver&amp;iacute;a a&amp;uacute;n m&amp;aacute;s molesto. Afortunadamente, &amp;iexcl;hay una abreviatura conveniente!</target>
        </trans-unit>
        <trans-unit id="d6943ba68e7fe9f38375bc9f4ece082b476fd104" translate="yes" xml:space="preserve">
          <source>It matches! There&amp;rsquo;s no value to add to, so the program stops and returns the &lt;code&gt;None&lt;/code&gt; value on the right side of &lt;code&gt;=&amp;gt;&lt;/code&gt;. Because the first arm matched, no other arms are compared.</source>
          <target state="translated">&amp;iexcl;Concuerda! No hay ning&amp;uacute;n valor para agregar, por lo que el programa se detiene y devuelve el valor &lt;code&gt;None&lt;/code&gt; en el lado derecho de &lt;code&gt;=&amp;gt;&lt;/code&gt; . Debido a que el primer brazo coincidi&amp;oacute;, no se comparan otros brazos.</target>
        </trans-unit>
        <trans-unit id="843b41eaa3d5b0c22ed8a08ff3f89c4230955bbd" translate="yes" xml:space="preserve">
          <source>It may be possible to define the closure later:</source>
          <target state="translated">Puede ser posible definir el cierre más adelante:</target>
        </trans-unit>
        <trans-unit id="37366d1499bbe80dc60f80cfc9ff38beb421f588" translate="yes" xml:space="preserve">
          <source>It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; is never created, nothing can go wrong! So, if you decide that some field does not have structural pinning, all you have to ensure is that you never create a pinned reference to that field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7626a2cf86a0ef32fb36f30c95b230833af23f10" translate="yes" xml:space="preserve">
          <source>It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; is never created, nothing can go wrong! So, if you decide that some field does not have structural pinning, all you have to ensure is that you never create a pinned reference to that field.</source>
          <target state="translated">Puede parecer contrario a la intuici&amp;oacute;n que el campo de una estructura anclada no est&amp;eacute; anclada, pero esa es en realidad la opci&amp;oacute;n m&amp;aacute;s f&amp;aacute;cil: si un &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; nunca se crea Pin &amp;lt;&amp;amp; mut Field&amp;gt; , &amp;iexcl;nada puede salir mal! Por lo tanto, si decide que alg&amp;uacute;n campo no tiene fijaci&amp;oacute;n estructural, todo lo que tiene que asegurarse es que nunca cree una referencia fija a ese campo.</target>
        </trans-unit>
        <trans-unit id="1bb0d24f6b4149955502e6e8ad32374412376163" translate="yes" xml:space="preserve">
          <source>It might seem like the paths we&amp;rsquo;ve written to call functions so far are inconveniently long and repetitive. For example, in Listing 7-7, whether we chose the absolute or relative path to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, every time we wanted to call &lt;code&gt;add_to_waitlist&lt;/code&gt; we had to specify &lt;code&gt;front_of_house&lt;/code&gt; and &lt;code&gt;hosting&lt;/code&gt; too. Fortunately, there&amp;rsquo;s a way to simplify this process. We can bring a path into a scope once and then call the items in that path as if they&amp;rsquo;re local items with the &lt;code&gt;use&lt;/code&gt; keyword.</source>
          <target state="translated">Puede parecer que las rutas que hemos escrito para llamar a funciones hasta ahora son inconvenientemente largas y repetitivas. Por ejemplo, en el Listado 7-7, ya sea que elegimos la ruta absoluta o relativa a la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; , cada vez que quer&amp;iacute;amos llamar a &lt;code&gt;add_to_waitlist&lt;/code&gt; ten&amp;iacute;amos que especificar &lt;code&gt;front_of_house&lt;/code&gt; y &lt;code&gt;hosting&lt;/code&gt; tambi&amp;eacute;n. Afortunadamente, existe una forma de simplificar este proceso. Podemos traer una ruta a un alcance una vez y luego llamar a los elementos en esa ruta como si fueran elementos locales con la palabra clave &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="805aa02c515eaa318de6b78a094bce98b8c53d4d" translate="yes" xml:space="preserve">
          <source>It moves the input &lt;code&gt;x&lt;/code&gt; passed to the function.</source>
          <target state="translated">Mueve la entrada &lt;code&gt;x&lt;/code&gt; pasada a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5eebbaa7bc3cdd0a56ef1daa1103d4c78b76f258" translate="yes" xml:space="preserve">
          <source>It must be &quot;dereferencable&quot; in the sense defined in &lt;a href=&quot;index#safety&quot;&gt;the module documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a5c10c251d6c8327aa492d2913739597d4a71f" translate="yes" xml:space="preserve">
          <source>It must be &quot;dereferencable&quot; in the sense defined in &lt;a href=&quot;ptr/index#safety&quot;&gt;the module documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e5a16652e3acc5312ad5ba06a9e285d4162164" translate="yes" xml:space="preserve">
          <source>It must not have any associated constants.</source>
          <target state="translated">No debe tener ninguna constante asociada.</target>
        </trans-unit>
        <trans-unit id="2ed9fe4f614f6746c16c9c39cbffbf6f903c7ae2" translate="yes" xml:space="preserve">
          <source>It must not require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">No debe requerir &lt;code&gt;Self: Sized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f3447254df95470f3130af039bc15cf58155424" translate="yes" xml:space="preserve">
          <source>It operates on raw pointers instead of references. When references are available, &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; should be preferred.</source>
          <target state="translated">Opera en punteros sin procesar en lugar de referencias. Cuando las referencias est&amp;aacute;n disponibles, &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; debe preferir .</target>
        </trans-unit>
        <trans-unit id="15a360bcd6063536513f56852862c8efa63c2070" translate="yes" xml:space="preserve">
          <source>It remains valid until it goes &lt;em&gt;out of scope&lt;/em&gt;.</source>
          <target state="translated">Sigue siendo v&amp;aacute;lido hasta que se &lt;em&gt;sale de su alcance&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="28129f615360627e84e6c1c9dbfcb777498ce57b" translate="yes" xml:space="preserve">
          <source>It replaces this:</source>
          <target state="translated">Reemplaza a esto:</target>
        </trans-unit>
        <trans-unit id="a96e5b042b30c122375f53b68b92a35b6c66cd8b" translate="yes" xml:space="preserve">
          <source>It represents a separator that designates that a path starts from root.</source>
          <target state="translated">Representa un separador que designa que un camino comienza desde la raíz.</target>
        </trans-unit>
        <trans-unit id="813494512097c4629c56611a8d3205233aba9f55" translate="yes" xml:space="preserve">
          <source>It should be noted that the length isn't just &quot;recomputed,&quot; but that the recomputed length must match the original length from the &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt; call. This means the &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;from_raw&lt;/code&gt; methods should not be used when passing the string to C functions that can modify the string's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110275e5135057ece97674a5c23f292001714824" translate="yes" xml:space="preserve">
          <source>It sometimes happens that you have unused type parameters which indicate what type of data a struct is &quot;tied&quot; to, even though that data is not actually found in the struct itself. Here is an example where this arises with &lt;a href=&quot;../../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;FFI&lt;/a&gt;. The foreign interface uses handles of type &lt;code&gt;*mut ()&lt;/code&gt; to refer to Rust values of different types. We track the Rust type using a phantom type parameter on the struct &lt;code&gt;ExternalResource&lt;/code&gt; which wraps a handle.</source>
          <target state="translated">A veces sucede que tiene par&amp;aacute;metros de tipo no utilizados que indican a qu&amp;eacute; tipo de datos est&amp;aacute; &quot;vinculada&quot; una estructura, aunque esos datos no se encuentran realmente en la estructura misma. Aqu&amp;iacute; hay un ejemplo en el que esto surge con &lt;a href=&quot;../../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;FFI&lt;/a&gt; . La interfaz externa usa identificadores de tipo &lt;code&gt;*mut ()&lt;/code&gt; para referirse a valores de Rust de diferentes tipos. Realizamos un seguimiento del tipo de Rust utilizando un par&amp;aacute;metro de tipo fantasma en la estructura &lt;code&gt;ExternalResource&lt;/code&gt; que envuelve un identificador.</target>
        </trans-unit>
        <trans-unit id="c8a5407ac4250c5a13730093f7af0747e49f3547" translate="yes" xml:space="preserve">
          <source>It takes ownership of one weak count. In case a &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; is passed, a dangling &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Toma posesi&amp;oacute;n de un recuento d&amp;eacute;bil. En caso de que se pase un &lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; , un &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; colgante se devuelve .</target>
        </trans-unit>
        <trans-unit id="cc57f2847f6e3b461b4b48ae401fd449efb6afda" translate="yes" xml:space="preserve">
          <source>It takes ownership of one weak reference (with the exception of pointers created by &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;, as these don't own anything; the method still works on them).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556eed10e4ddb25bae7da43fa1a61a57fb93be86" translate="yes" xml:space="preserve">
          <source>It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;. There are some constraints though, and the most important constraint is &lt;em&gt;consistency&lt;/em&gt;: every field can be &lt;em&gt;either&lt;/em&gt; projected to a pinned reference, &lt;em&gt;or&lt;/em&gt; have pinning removed as part of the projection. If both are done for the same field, that will likely be unsound!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e869ff63d6d4b946c2cdd219b436de253a41746" translate="yes" xml:space="preserve">
          <source>It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;. There are some constraints though, and the most important constraint is &lt;em&gt;consistency&lt;/em&gt;: every field can be &lt;em&gt;either&lt;/em&gt; projected to a pinned reference, &lt;em&gt;or&lt;/em&gt; have pinning removed as part of the projection. If both are done for the same field, that will likely be unsound!</source>
          <target state="translated">Resulta que en realidad depende del autor de la estructura de datos decidir si la proyecci&amp;oacute;n fijada para un campo en particular convierte &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; en &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; . Hay algunas limitaciones embargo, y la limitaci&amp;oacute;n m&amp;aacute;s importante es &lt;em&gt;la consistencia&lt;/em&gt; : cada campo puede ser &lt;em&gt;ya sea&lt;/em&gt; proyectado a una referencia fijado, &lt;em&gt;o&lt;/em&gt; han eliminado de colocaci&amp;oacute;n de clavos como parte de la proyecci&amp;oacute;n. Si ambos se hacen para el mismo campo, &amp;iexcl;probablemente no sea correcto!</target>
        </trans-unit>
        <trans-unit id="43f35f0c065fabfd41f89d1318ce0f42a18d0c80" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t always so clear, but the Rust programming language is fundamentally about &lt;em&gt;empowerment&lt;/em&gt;: no matter what kind of code you are writing now, Rust empowers you to reach farther, to program with confidence in a wider variety of domains than you did before.</source>
          <target state="translated">No siempre fue tan claro, pero el lenguaje de programaci&amp;oacute;n Rust se trata fundamentalmente de &lt;em&gt;empoderamiento&lt;/em&gt; : no importa qu&amp;eacute; tipo de c&amp;oacute;digo est&amp;eacute; escribiendo ahora, Rust le permite llegar m&amp;aacute;s lejos, programar con confianza en una variedad m&amp;aacute;s amplia de dominios que antes. .</target>
        </trans-unit>
        <trans-unit id="e5c52d18214990d951c10878c00ac04808b86559" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;, or if the contents of the file are not valid UTF-8.</source>
          <target state="translated">Tambi&amp;eacute;n devolver&amp;aacute; un error si encuentra al leer un error de un tipo que no sea &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; , o si el contenido del archivo no es v&amp;aacute;lido UTF-8.</target>
        </trans-unit>
        <trans-unit id="88d7df68d5037684c00152095cea66d62196594d" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n devolver&amp;aacute; un error si encuentra al leer un error de un tipo que no sea &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b634d15305e7f67a78aa8cca8e62aa2565532e97" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;, or if the contents of the file are not valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94bfac984e5cdabffa566b75c8486ad84a9f63a" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4977950c4a1247296e8ff0c58adfe3a8ef825061" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; types of the &lt;a href=&quot;trait.pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; trait if the pattern supports searching for it from the back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c79069ef32a54734e3b8b3c591b459a403a4fa" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;a href=&quot;trait.pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8e67a12d7988664bc05e18e9798989cd3eb135" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;code&gt;Pattern&lt;/code&gt; trait if the pattern supports searching for it from the back.</source>
          <target state="translated">Ser&amp;aacute; implementado por los tipos de &lt;code&gt;Searcher&lt;/code&gt; asociados del &lt;code&gt;Pattern&lt;/code&gt; rasgo si los soportes de patrones en busca de ella desde la parte posterior.</target>
        </trans-unit>
        <trans-unit id="9f81a8ca5067c3c3b4399b6129a830805c0cc0ff" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;code&gt;Pattern&lt;/code&gt; trait.</source>
          <target state="translated">Ser&amp;aacute; implementado por los tipos de &lt;code&gt;Searcher&lt;/code&gt; asociados del &lt;code&gt;Pattern&lt;/code&gt; rasgo de .</target>
        </trans-unit>
        <trans-unit id="6ec53dce211a7944d162428d571097183435ce6f" translate="yes" xml:space="preserve">
          <source>It will drop down as close as possible to the length but the allocator may still inform the &lt;code&gt;VecDeque&lt;/code&gt; that there is space for a few more elements.</source>
          <target state="translated">Se desplegar&amp;aacute; lo m&amp;aacute;s cerca posible de la longitud, pero el asignador a&amp;uacute;n puede informar al &lt;code&gt;VecDeque&lt;/code&gt; que hay espacio para algunos elementos m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="5d0e16f9adb2110bbd3e927ea4577168391e9b74" translate="yes" xml:space="preserve">
          <source>It will drop down as close as possible to the length but the allocator may still inform the vector that there is space for a few more elements.</source>
          <target state="translated">Descenderá lo más cerca posible de la longitud,pero el asignador todavía puede informar al vector de que hay espacio para unos pocos elementos más.</target>
        </trans-unit>
        <trans-unit id="583613916c43b1fe106e05c39ca4ce6da47ce68b" translate="yes" xml:space="preserve">
          <source>It will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Nunca volver&amp;aacute; &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38d1d8fbd49b71b116c5d704cf7c49ee955c939a" translate="yes" xml:space="preserve">
          <source>It would also be appropriate to call &lt;code&gt;unwrap&lt;/code&gt; when you have some other logic that ensures the &lt;code&gt;Result&lt;/code&gt; will have an &lt;code&gt;Ok&lt;/code&gt; value, but the logic isn&amp;rsquo;t something the compiler understands. You&amp;rsquo;ll still have a &lt;code&gt;Result&lt;/code&gt; value that you need to handle: whatever operation you&amp;rsquo;re calling still has the possibility of failing in general, even though it&amp;rsquo;s logically impossible in your particular situation. If you can ensure by manually inspecting the code that you&amp;rsquo;ll never have an &lt;code&gt;Err&lt;/code&gt; variant, it&amp;rsquo;s perfectly acceptable to call &lt;code&gt;unwrap&lt;/code&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">Tambi&amp;eacute;n ser&amp;iacute;a apropiado llamar a &lt;code&gt;unwrap&lt;/code&gt; cuando tenga alguna otra l&amp;oacute;gica que garantice que el &lt;code&gt;Result&lt;/code&gt; tendr&amp;aacute; un valor &lt;code&gt;Ok&lt;/code&gt; , pero la l&amp;oacute;gica no es algo que el compilador comprenda. A&amp;uacute;n tendr&amp;aacute; un valor de &lt;code&gt;Result&lt;/code&gt; ado que debe manejar: cualquier operaci&amp;oacute;n que est&amp;eacute; llamando todav&amp;iacute;a tiene la posibilidad de fallar en general, aunque sea l&amp;oacute;gicamente imposible en su situaci&amp;oacute;n particular. Si puede asegurarse al inspeccionar manualmente el c&amp;oacute;digo que nunca tendr&amp;aacute; una variante &lt;code&gt;Err&lt;/code&gt; , es perfectamente aceptable llamar a &lt;code&gt;unwrap&lt;/code&gt; . He aqu&amp;iacute; un ejemplo:</target>
        </trans-unit>
        <trans-unit id="281e22ba57501fc7d3d70b8f1f8f4bfbc5dcf1a5" translate="yes" xml:space="preserve">
          <source>It would make it more difficult for unsafe code to correctly manipulate a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had actually allocated memory.</source>
          <target state="translated">Har&amp;iacute;a m&amp;aacute;s dif&amp;iacute;cil que el c&amp;oacute;digo inseguro manipulara correctamente un &lt;code&gt;Vec&lt;/code&gt; . El contenido de un &lt;code&gt;Vec&lt;/code&gt; no tendr&amp;iacute;a una direcci&amp;oacute;n estable si solo se moviera, y ser&amp;iacute;a m&amp;aacute;s dif&amp;iacute;cil determinar si un &lt;code&gt;Vec&lt;/code&gt; realmente hab&amp;iacute;a asignado memoria.</target>
        </trans-unit>
        <trans-unit id="8927c51bfbab721165d17b97848a237b8ec4da60" translate="yes" xml:space="preserve">
          <source>It would penalize the general case, incurring an additional branch on every access.</source>
          <target state="translated">Se penalizaría el caso general,incurriendo en una sucursal adicional en cada acceso.</target>
        </trans-unit>
        <trans-unit id="0a1ec3ed4f97e53ed39cbe77eeb33099668d0775" translate="yes" xml:space="preserve">
          <source>It wouldn't work. This is because the size of a &lt;code&gt;List&lt;/code&gt; depends on how many elements are in the list, and so we don't know how much memory to allocate for a &lt;code&gt;Cons&lt;/code&gt;. By introducing a &lt;a href=&quot;struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, which has a defined size, we know how big &lt;code&gt;Cons&lt;/code&gt; needs to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6be8378a582020df10360545b9470cc00244ca7" translate="yes" xml:space="preserve">
          <source>It wouldn't work. This is because the size of a &lt;code&gt;List&lt;/code&gt; depends on how many elements are in the list, and so we don't know how much memory to allocate for a &lt;code&gt;Cons&lt;/code&gt;. By introducing a &lt;code&gt;Box&lt;/code&gt;, which has a defined size, we know how big &lt;code&gt;Cons&lt;/code&gt; needs to be.</source>
          <target state="translated">No funcionar&amp;iacute;a. Esto se debe a que el tama&amp;ntilde;o de una &lt;code&gt;List&lt;/code&gt; a depende de cu&amp;aacute;ntos elementos hay en la lista, por lo que no sabemos cu&amp;aacute;nta memoria asignar para una &lt;code&gt;Cons&lt;/code&gt; . Al introducir una &lt;code&gt;Box&lt;/code&gt; , que tiene un tama&amp;ntilde;o definido, sabemos qu&amp;eacute; tan grandes deben ser las &lt;code&gt;Cons&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4998da21c6a9914c8ce4ea9184bccf6c0873e7d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;d be nice to be able to print an instance of &lt;code&gt;Rectangle&lt;/code&gt; while we&amp;rsquo;re debugging our program and see the values for all its fields. Listing 5-11 tries using the &lt;code&gt;println!&lt;/code&gt; macro as we have used in previous chapters. This won&amp;rsquo;t work, however.</source>
          <target state="translated">Ser&amp;iacute;a bueno poder imprimir una instancia de &lt;code&gt;Rectangle&lt;/code&gt; mientras depuramos nuestro programa y ver los valores de todos sus campos. Listado 5-11 intenta usar &lt;code&gt;println!&lt;/code&gt; macro como hemos utilizado en cap&amp;iacute;tulos anteriores. Sin embargo, esto no funcionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9fd4ff89cd3ed9767f9bb50021655606612821c0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a panoply of Rust features with something for everyone! Let&amp;rsquo;s dive in!</source>
          <target state="translated">&amp;iexcl;Es una panoplia de caracter&amp;iacute;sticas de Rust con algo para todos! &amp;iexcl;Vamos a sumergirnos!</target>
        </trans-unit>
        <trans-unit id="2f4a91582fca2b4ddf611bb05db0236c35e6a95d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s advisable to have your code panic when it&amp;rsquo;s possible that your code could end up in a bad state. In this context, a &lt;em&gt;bad state&lt;/em&gt; is when some assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code&amp;mdash;plus one or more of the following:</source>
          <target state="translated">Es recomendable que su c&amp;oacute;digo entre en p&amp;aacute;nico cuando es posible que su c&amp;oacute;digo termine en mal estado. En este contexto, un &lt;em&gt;mal estado&lt;/em&gt; es cuando se ha roto alguna suposici&amp;oacute;n, garant&amp;iacute;a, contrato o invariante, como cuando se pasan valores no v&amp;aacute;lidos, valores contradictorios o valores faltantes a su c&amp;oacute;digo, m&amp;aacute;s uno o m&amp;aacute;s de los siguientes:</target>
        </trans-unit>
        <trans-unit id="1d4af836f0cd460a3ac351996453b851549fe52a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also worth noting that the condition in this code &lt;em&gt;must&lt;/em&gt; be a &lt;code&gt;bool&lt;/code&gt;. If the condition isn&amp;rsquo;t a &lt;code&gt;bool&lt;/code&gt;, we&amp;rsquo;ll get an error. For example, try running the following code:</source>
          <target state="translated">Tambi&amp;eacute;n vale la pena se&amp;ntilde;alar que la condici&amp;oacute;n en este c&amp;oacute;digo &lt;em&gt;debe&lt;/em&gt; ser &lt;code&gt;bool&lt;/code&gt; . Si la condici&amp;oacute;n no es &lt;code&gt;bool&lt;/code&gt; , obtendremos un error. Por ejemplo, intente ejecutar el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="d52fc1028632f974c83efdc9f4200e35b249610e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s been a long journey, but we&amp;rsquo;ve reached the end of the book. In this chapter, we&amp;rsquo;ll build one more project together to demonstrate some of the concepts we covered in the final chapters, as well as recap some earlier lessons.</source>
          <target state="translated">Ha sido un largo viaje, pero hemos llegado al final del libro. En este cap&amp;iacute;tulo, construiremos un proyecto m&amp;aacute;s juntos para demostrar algunos de los conceptos que cubrimos en los cap&amp;iacute;tulos finales, as&amp;iacute; como tambi&amp;eacute;n recapitular algunas lecciones anteriores.</target>
        </trans-unit>
        <trans-unit id="1024ef58107465d0b2d166ab80e88f189d22f3a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to check whether a particular key has a value and, if it doesn&amp;rsquo;t, insert a value for it. Hash maps have a special API for this called &lt;code&gt;entry&lt;/code&gt; that takes the key you want to check as a parameter. The return value of the &lt;code&gt;entry&lt;/code&gt; method is an enum called &lt;code&gt;Entry&lt;/code&gt; that represents a value that might or might not exist. Let&amp;rsquo;s say we want to check whether the key for the Yellow team has a value associated with it. If it doesn&amp;rsquo;t, we want to insert the value 50, and the same for the Blue team. Using the &lt;code&gt;entry&lt;/code&gt; API, the code looks like Listing 8-25.</source>
          <target state="translated">Es com&amp;uacute;n verificar si una clave en particular tiene un valor y, si no lo tiene, insertar un valor para ella. Los mapas hash tienen una API especial para esta &lt;code&gt;entry&lt;/code&gt; llamada que toma la clave que desea verificar como par&amp;aacute;metro. El valor de retorno del m&amp;eacute;todo de &lt;code&gt;entry&lt;/code&gt; es una enumeraci&amp;oacute;n llamada &lt;code&gt;Entry&lt;/code&gt; que representa un valor que podr&amp;iacute;a existir o no. Digamos que queremos comprobar si la clave del equipo amarillo tiene un valor asociado. Si no es as&amp;iacute;, queremos insertar el valor 50, y lo mismo para el equipo Azul. Usando la API de &lt;code&gt;entry&lt;/code&gt; , el c&amp;oacute;digo se parece al Listado 8-25.</target>
        </trans-unit>
        <trans-unit id="b254f401bbc453696a95036f25cc6c8b9f205677" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important that we get compile-time errors when we attempt to change a value that we previously designated as immutable because this very situation can lead to bugs. If one part of our code operates on the assumption that a value will never change and another part of our code changes that value, it&amp;rsquo;s possible that the first part of the code won&amp;rsquo;t do what it was designed to do. The cause of this kind of bug can be difficult to track down after the fact, especially when the second piece of code changes the value only &lt;em&gt;sometimes&lt;/em&gt;.</source>
          <target state="translated">Es importante que obtengamos errores en tiempo de compilaci&amp;oacute;n cuando intentamos cambiar un valor que previamente designamos como inmutable porque esta misma situaci&amp;oacute;n puede dar lugar a errores. Si una parte de nuestro c&amp;oacute;digo opera bajo el supuesto de que un valor nunca cambiar&amp;aacute; y otra parte de nuestro c&amp;oacute;digo cambia ese valor, es posible que la primera parte del c&amp;oacute;digo no haga lo que fue dise&amp;ntilde;ado para hacer. La causa de este tipo de error puede ser dif&amp;iacute;cil de rastrear despu&amp;eacute;s del hecho, especialmente cuando la segunda parte del c&amp;oacute;digo cambia el valor solo &lt;em&gt;algunas veces&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9ed2c9ced3e236750c87d43ad1072d6e0ed07bbb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that &lt;code&gt;unsafe&lt;/code&gt; doesn&amp;rsquo;t turn off the borrow checker or disable any other of Rust&amp;rsquo;s safety checks: if you use a reference in unsafe code, it will still be checked. The &lt;code&gt;unsafe&lt;/code&gt; keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You&amp;rsquo;ll still get some degree of safety inside of an unsafe block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cdb0b8313d7ae007e7e125bdfd991a30a8e291c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that &lt;code&gt;unsafe&lt;/code&gt; doesn&amp;rsquo;t turn off the borrow checker or disable any other of Rust&amp;rsquo;s safety checks: if you use a reference in unsafe code, it will still be checked. The &lt;code&gt;unsafe&lt;/code&gt; keyword only gives you access to these four features that are then not checked by the compiler for memory safety. You&amp;rsquo;ll still get some degree of safety inside of an unsafe block.</source>
          <target state="translated">Es importante comprender que &lt;code&gt;unsafe&lt;/code&gt; no apaga el verificador de pr&amp;eacute;stamos ni deshabilita cualquier otro control de seguridad de Rust: si usa una referencia en un c&amp;oacute;digo inseguro, a&amp;uacute;n se verificar&amp;aacute;. La palabra clave &lt;code&gt;unsafe&lt;/code&gt; solo le da acceso a estas cuatro caracter&amp;iacute;sticas que luego el compilador no verifica para la seguridad de la memoria. A&amp;uacute;n obtendr&amp;aacute; cierto grado de seguridad dentro de un bloque inseguro.</target>
        </trans-unit>
        <trans-unit id="8deea23b26cb7cf37f9d9061e806bcfc7feaa092" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible for Rust to determine how many values in the tuple to ignore before matching a value with &lt;code&gt;second&lt;/code&gt; and then how many further values to ignore thereafter. This code could mean that we want to ignore &lt;code&gt;2&lt;/code&gt;, bind &lt;code&gt;second&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;, and then ignore &lt;code&gt;8&lt;/code&gt;, &lt;code&gt;16&lt;/code&gt;, and &lt;code&gt;32&lt;/code&gt;; or that we want to ignore &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, bind &lt;code&gt;second&lt;/code&gt; to &lt;code&gt;8&lt;/code&gt;, and then ignore &lt;code&gt;16&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt;; and so forth. The variable name &lt;code&gt;second&lt;/code&gt; doesn&amp;rsquo;t mean anything special to Rust, so we get a compiler error because using &lt;code&gt;..&lt;/code&gt; in two places like this is ambiguous.</source>
          <target state="translated">Es imposible para Rust determinar cu&amp;aacute;ntos valores en la tupla ignorar antes de hacer coincidir un valor con el &lt;code&gt;second&lt;/code&gt; y luego cu&amp;aacute;ntos valores m&amp;aacute;s ignorar a partir de entonces. Este c&amp;oacute;digo podr&amp;iacute;a significar que queremos ignorar &lt;code&gt;2&lt;/code&gt; , vincular el &lt;code&gt;second&lt;/code&gt; a &lt;code&gt;4&lt;/code&gt; y luego ignorar &lt;code&gt;8&lt;/code&gt; , &lt;code&gt;16&lt;/code&gt; y &lt;code&gt;32&lt;/code&gt; ; o que queremos ignorar &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;4&lt;/code&gt; , unir el &lt;code&gt;second&lt;/code&gt; a &lt;code&gt;8&lt;/code&gt; y luego ignorar &lt;code&gt;16&lt;/code&gt; y &lt;code&gt;32&lt;/code&gt; ; Etc&amp;eacute;tera. El nombre de la variable en &lt;code&gt;second&lt;/code&gt; no significa nada especial para Rust, por lo que obtenemos un error de compilador porque al usar &lt;code&gt;..&lt;/code&gt; en dos lugares como este es ambiguo.</target>
        </trans-unit>
        <trans-unit id="b30b0ad80edd47c563a2e1776ed2c849ecd649e3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful for a program to evaluate a condition within a loop. While the condition is true, the loop runs. When the condition ceases to be true, the program calls &lt;code&gt;break&lt;/code&gt;, stopping the loop. This loop type could be implemented using a combination of &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;; you could try that now in a program, if you&amp;rsquo;d like.</source>
          <target state="translated">A menudo, es &amp;uacute;til que un programa eval&amp;uacute;e una condici&amp;oacute;n dentro de un ciclo. Si bien la condici&amp;oacute;n es verdadera, el ciclo se ejecuta. Cuando la condici&amp;oacute;n deja de ser verdadera, las llamadas al programa se &lt;code&gt;break&lt;/code&gt; , deteniendo el ciclo. Este tipo de bucle se podr&amp;iacute;a implementar mediante una combinaci&amp;oacute;n de &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , si &lt;code&gt;else&lt;/code&gt; y &lt;code&gt;break&lt;/code&gt; ; puede intentarlo ahora en un programa, si lo desea.</target>
        </trans-unit>
        <trans-unit id="2a4b6828f8495332d03de5c3d6e1db7c761b6380" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful to create a new instance of a struct that uses most of an old instance&amp;rsquo;s values but changes some. You&amp;rsquo;ll do this using &lt;em&gt;struct update syntax&lt;/em&gt;.</source>
          <target state="translated">A menudo es &amp;uacute;til crear una nueva instancia de una estructura que usa la mayor&amp;iacute;a de los valores de una instancia anterior, pero cambia algunos. Har&amp;aacute; esto usando la &lt;em&gt;sintaxis de actualizaci&amp;oacute;n de la estructura&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="723b901f30cea9edf0e74e2f7413d0b6d6d9f846" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful to execute a block of code more than once. For this task, Rust provides several &lt;em&gt;loops&lt;/em&gt;. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning. To experiment with loops, let&amp;rsquo;s make a new project called &lt;em&gt;loops&lt;/em&gt;.</source>
          <target state="translated">Suele ser &amp;uacute;til ejecutar un bloque de c&amp;oacute;digo m&amp;aacute;s de una vez. Para esta tarea, Rust proporciona varios &lt;em&gt;bucles&lt;/em&gt; . Un bucle recorre el c&amp;oacute;digo dentro del cuerpo del bucle hasta el final y luego comienza inmediatamente desde el principio. Para experimentar con los bucles, creemos un nuevo proyecto llamado &lt;em&gt;bucles&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="753665469cbfa717250694f7de09ac1968d71cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible for structs to store references to data owned by something else, but to do so requires the use of &lt;em&gt;lifetimes&lt;/em&gt;, a Rust feature that we&amp;rsquo;ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Let&amp;rsquo;s say you try to store a reference in a struct without specifying lifetimes, like this, which won&amp;rsquo;t work:</source>
          <target state="translated">Es posible que las estructuras almacenen referencias a datos que pertenecen a otra cosa, pero hacerlo requiere el uso de &lt;em&gt;tiempos&lt;/em&gt; de &lt;em&gt;vida&lt;/em&gt; , una caracter&amp;iacute;stica de Rust que discutiremos en el Cap&amp;iacute;tulo 10. Los tiempos de vida aseguran que los datos a los que hace referencia una estructura sean v&amp;aacute;lidos durante tanto tiempo como es la estructura. Digamos que intenta almacenar una referencia en una estructura sin especificar tiempos de vida, como este, que no funcionar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="1330d73ba4baef219cde7c8056164e7a0d0b3b12" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to return multiple values using a tuple, as shown in Listing 4-5.</source>
          <target state="translated">Es posible devolver m&amp;uacute;ltiples valores usando una tupla, como se muestra en el Listado 4-5.</target>
        </trans-unit>
        <trans-unit id="dd54062a6d4a18f88f50f4130b2d691d87e7c906" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s useful to discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text. In this section, we&amp;rsquo;ll talk about the operations on &lt;code&gt;String&lt;/code&gt; that every collection type has, such as creating, updating, and reading. We&amp;rsquo;ll also discuss the ways in which &lt;code&gt;String&lt;/code&gt; is different from the other collections, namely how indexing into a &lt;code&gt;String&lt;/code&gt; is complicated by the differences between how people and computers interpret &lt;code&gt;String&lt;/code&gt; data.</source>
          <target state="translated">Es &amp;uacute;til discutir cadenas en el contexto de colecciones porque las cadenas se implementan como una colecci&amp;oacute;n de bytes, adem&amp;aacute;s de algunos m&amp;eacute;todos para proporcionar una funcionalidad &amp;uacute;til cuando esos bytes se interpretan como texto. En esta secci&amp;oacute;n, hablaremos sobre las operaciones en &lt;code&gt;String&lt;/code&gt; que tiene cada tipo de colecci&amp;oacute;n, como crear, actualizar y leer. Tambi&amp;eacute;n discutiremos las formas en las que &lt;code&gt;String&lt;/code&gt; es diferente de las otras colecciones, es decir, c&amp;oacute;mo la indexaci&amp;oacute;n en &lt;code&gt;String&lt;/code&gt; se complica por las diferencias entre c&amp;oacute;mo las personas y las computadoras interpretan los datos de &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08a5c61453f5e990492626e9bb6d14bf2f43a9aa" translate="yes" xml:space="preserve">
          <source>It's also important to note that the Rust compiler can generally determine the lifetime by itself. Example:</source>
          <target state="translated">También es importante señalar que el compilador de óxido generalmente puede determinar la vida útil por sí mismo.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="33ba7241cc90a10e5fee095fa049c987fe61e308" translate="yes" xml:space="preserve">
          <source>It's common for people who haven't used iterators a lot to use a &lt;code&gt;for&lt;/code&gt; loop with a list of things to build up a result. Those can be turned into &lt;code&gt;fold()&lt;/code&gt;s:</source>
          <target state="translated">Es com&amp;uacute;n que las personas que no han usado muchos iteradores usen un bucle &lt;code&gt;for&lt;/code&gt; con una lista de cosas para generar un resultado. Esos se pueden convertir en &lt;code&gt;fold()&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="ba017d93d6349943ce3ed0d06f842a0f9c987ffa" translate="yes" xml:space="preserve">
          <source>It's common to instead use destructuring on the argument to strip away one:</source>
          <target state="translated">Es común usar la desestructuración en el argumento para despojar a uno:</target>
        </trans-unit>
        <trans-unit id="686ffc7f644232912f8eff3ec52197d230c78db4" translate="yes" xml:space="preserve">
          <source>It's important to note that in these two examples, the only difference is whether you are allowed to access &lt;code&gt;x&lt;/code&gt; after the assignment. Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away.</source>
          <target state="translated">Es importante tener en cuenta que en estos dos ejemplos, la &amp;uacute;nica diferencia es si se le permite acceder a &lt;code&gt;x&lt;/code&gt; despu&amp;eacute;s de la asignaci&amp;oacute;n. Bajo el cap&amp;oacute;, tanto una copia como un movimiento pueden resultar en la copia de bits en la memoria, aunque esto a veces se optimiza.</target>
        </trans-unit>
        <trans-unit id="bf0d2bc6515048c1222c1faf89f4b7dfbf926400" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</source>
          <target state="translated">Es importante recordar que &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; representa un valor escalar Unicode y puede no coincidir con su idea de lo que es un 'car&amp;aacute;cter'. La iteraci&amp;oacute;n sobre los grupos de grafemas puede ser lo que realmente desee.</target>
        </trans-unit>
        <trans-unit id="a89bf255278a9fcad7529f6bfd4c6a49b45cb147" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust's standard library, check crates.io instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4da28ef521125e0c1be74a0e5b5fccf5a9444a6" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</source>
          <target state="translated">Es importante recordar que &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; representa un valor escalar Unicode y puede no coincidir con su idea de lo que es un 'car&amp;aacute;cter'. La iteraci&amp;oacute;n sobre los grupos de grafemas puede ser lo que realmente desee.</target>
        </trans-unit>
        <trans-unit id="21dabe83c3c9b91d37de871b20d8a3fe9aea8d87" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust's standard library, check crates.io instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34560c82a9fb0dc71d1acee3f7d70c175383bc7b" translate="yes" xml:space="preserve">
          <source>It's invalid to directly import methods belonging to a trait or concrete type.</source>
          <target state="translated">No es válido importar directamente métodos pertenecientes a un rasgo o tipo concreto.</target>
        </trans-unit>
        <trans-unit id="c4ea1a04986d9525398a48411915463d79b08630" translate="yes" xml:space="preserve">
          <source>It's more common for &lt;code&gt;inspect()&lt;/code&gt; to be used as a debugging tool than to exist in your final code, but applications may find it useful in certain situations when errors need to be logged before being discarded.</source>
          <target state="translated">Es m&amp;aacute;s com&amp;uacute;n que &lt;code&gt;inspect()&lt;/code&gt; se use como una herramienta de depuraci&amp;oacute;n que que exista en su c&amp;oacute;digo final, pero las aplicaciones pueden encontrarlo &amp;uacute;til en ciertas situaciones cuando los errores deben registrarse antes de descartarse.</target>
        </trans-unit>
        <trans-unit id="2f6fd4d024f3a27229b0326aaec954fc7e7267f9" translate="yes" xml:space="preserve">
          <source>It's only possible to directly instantiate a struct using struct literal syntax when all of its fields are visible to you.</source>
          <target state="translated">Sólo es posible instanciar directamente una estructura usando la sintaxis literal de la estructura cuando todos sus campos son visibles para usted.</target>
        </trans-unit>
        <trans-unit id="bc2a391a320094b486e218290333929f21b82924" translate="yes" xml:space="preserve">
          <source>It's undefined behavior if global allocators unwind. This restriction may be lifted in the future, but currently a panic from any of these functions may lead to memory unsafety.</source>
          <target state="translated">Es un comportamiento indefinido si los asignadores globales se desenvuelven.Esta restricción puede ser levantada en el futuro,pero actualmente el pánico de cualquiera de estas funciones puede llevar a la inseguridad de la memoria.</target>
        </trans-unit>
        <trans-unit id="90d66c69bdab0c4f62a7abada1a3e2fdee354d75" translate="yes" xml:space="preserve">
          <source>It's very common then to put a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; inside shared pointer types to reintroduce mutability:</source>
          <target state="translated">Entonces, es muy com&amp;uacute;n colocar un &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; dentro de tipos de punteros compartidos para reintroducir la mutabilidad:</target>
        </trans-unit>
        <trans-unit id="21df73947a06d77d2ad5fe166c8ddfcdc53a6fdb" translate="yes" xml:space="preserve">
          <source>Italiano</source>
          <target state="translated">Italiano</target>
        </trans-unit>
        <trans-unit id="1927b99b7203a5d61bb78b1a858edbf1a4446227" translate="yes" xml:space="preserve">
          <source>Item declarations</source>
          <target state="translated">Declaraciones de artículos</target>
        </trans-unit>
        <trans-unit id="052ff2f8a72886a3883816a6bea2ff5da9ae8dcc" translate="yes" xml:space="preserve">
          <source>Item visibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="e94f4a33f00d601e0668e3316c1f5baec10b371b" translate="yes" xml:space="preserve">
          <source>Items are entirely determined at compile-time, generally remain fixed during execution, and may reside in read-only memory.</source>
          <target state="translated">Los elementos se determinan enteramente en tiempo de compilación,generalmente permanecen fijos durante la ejecución y pueden residir en la memoria de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="d65bc9662d384da5396d0c23266596b91dc5d76b" translate="yes" xml:space="preserve">
          <source>Items are missing in a trait implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf93f2b738152017441b72f8223700a6c86d570" translate="yes" xml:space="preserve">
          <source>Items are missing in a trait implementation. Erroneous code example:</source>
          <target state="translated">Faltan elementos en la implementación de un rasgo.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="e8b3f0ebaa39e2f70c17e1cb57e9f0ef34b2a7cd" translate="yes" xml:space="preserve">
          <source>Items associated with a trait do not need to be defined in the trait, but they may be. If the trait provides a definition, then this definition acts as a default for any implementation which does not override it. If it does not, then any implementation must provide a definition.</source>
          <target state="translated">Los elementos asociados a un rasgo no necesitan ser definidos en el rasgo,pero pueden serlo.Si el rasgo proporciona una definición,entonces esta definición actúa como un defecto para cualquier implementación que no lo anule.Si no lo hace,entonces cualquier implementación debe proporcionar una definición.</target>
        </trans-unit>
        <trans-unit id="d525f8eb402a25c60f5c5ba9759986177ee5a851" translate="yes" xml:space="preserve">
          <source>Items can be imported without binding to a name by using an underscore with the form &lt;code&gt;use path as _&lt;/code&gt;. This is particularly useful to import a trait so that its methods may be used without importing the trait's symbol, for example if the trait's symbol may conflict with another symbol. Another example is to link an external crate without importing its name.</source>
          <target state="translated">Los elementos se pueden importar sin vincularlos a un nombre utilizando un gui&amp;oacute;n bajo con la &lt;code&gt;use path as _&lt;/code&gt; del formulario como _ . Esto es particularmente &amp;uacute;til para importar un rasgo de modo que sus m&amp;eacute;todos puedan usarse sin importar el s&amp;iacute;mbolo del rasgo, por ejemplo, si el s&amp;iacute;mbolo del rasgo puede entrar en conflicto con otro s&amp;iacute;mbolo. Otro ejemplo es vincular una caja externa sin importar su nombre.</target>
        </trans-unit>
        <trans-unit id="d80427c3d2c84e1095c0f47d752a2b536590da04" translate="yes" xml:space="preserve">
          <source>Items defined in a module or implementation have a &lt;em&gt;canonical path&lt;/em&gt; that corresponds to where within its crate it is defined. All other paths to these items are aliases. The canonical path is defined as a &lt;em&gt;path prefix&lt;/em&gt; appended by the path segment the item itself defines.</source>
          <target state="translated">Los elementos definidos en un m&amp;oacute;dulo o implementaci&amp;oacute;n tienen una &lt;em&gt;ruta can&amp;oacute;nica&lt;/em&gt; que corresponde al lugar dentro de su caja donde est&amp;aacute; definido. Todas las dem&amp;aacute;s rutas a estos elementos son alias. La ruta can&amp;oacute;nica se define como un &lt;em&gt;prefijo de ruta&lt;/em&gt; agregado por el segmento de ruta que el propio elemento define.</target>
        </trans-unit>
        <trans-unit id="dff50658b0fc9891bf43ec3aa222a12df699a4f5" translate="yes" xml:space="preserve">
          <source>Items inside functions are basically just like top-level items, except that they can only be used from the function they are in.</source>
          <target state="translated">Los artículos dentro de las funciones son básicamente como los artículos de nivel superior,excepto que sólo pueden ser utilizados desde la función en la que están.</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="562356f4191fd96292159c9a51f1502a656a766d" translate="yes" xml:space="preserve">
          <source>Iter::all</source>
          <target state="translated">Iter::all</target>
        </trans-unit>
        <trans-unit id="598e9d1442d2d90b30d41f52dc9f35d312a9ea85" translate="yes" xml:space="preserve">
          <source>Iter::any</source>
          <target state="translated">Iter::any</target>
        </trans-unit>
        <trans-unit id="11c24b7b71f44b4c32bd475993cf94651f69ef7b" translate="yes" xml:space="preserve">
          <source>Iter::as_path</source>
          <target state="translated">Iter::as_path</target>
        </trans-unit>
        <trans-unit id="b00470be46e8b1319d806bf1fedc19612d599118" translate="yes" xml:space="preserve">
          <source>Iter::as_ref</source>
          <target state="translated">Iter::as_ref</target>
        </trans-unit>
        <trans-unit id="1c4a85c9060fc0533851d2ebb18b0944dec20504" translate="yes" xml:space="preserve">
          <source>Iter::as_slice</source>
          <target state="translated">Iter::as_slice</target>
        </trans-unit>
        <trans-unit id="cd753ac2ff5d2f5e373d6da3f28eb6cc4f4a12da" translate="yes" xml:space="preserve">
          <source>Iter::borrow</source>
          <target state="translated">Iter::borrow</target>
        </trans-unit>
        <trans-unit id="ccae721db6c0b80ead456e39e15a574d91f05503" translate="yes" xml:space="preserve">
          <source>Iter::borrow_mut</source>
          <target state="translated">Iter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="9e9e1cc006a1a0c230f182d60dc3ae25867fa96b" translate="yes" xml:space="preserve">
          <source>Iter::by_ref</source>
          <target state="translated">Iter::by_ref</target>
        </trans-unit>
        <trans-unit id="40958308a6a00b30f0186ac470a90b4263782276" translate="yes" xml:space="preserve">
          <source>Iter::chain</source>
          <target state="translated">Iter::chain</target>
        </trans-unit>
        <trans-unit id="a16e2afb6a204e2c61484cc43715d2838e449cea" translate="yes" xml:space="preserve">
          <source>Iter::clone</source>
          <target state="translated">Iter::clone</target>
        </trans-unit>
        <trans-unit id="d33632634125b5bfb914d7696031de5e4050211f" translate="yes" xml:space="preserve">
          <source>Iter::clone_from</source>
          <target state="translated">Iter::clone_from</target>
        </trans-unit>
        <trans-unit id="c521a7d4341dba591b54fa4bc0805ada3d50f399" translate="yes" xml:space="preserve">
          <source>Iter::clone_into</source>
          <target state="translated">Iter::clone_into</target>
        </trans-unit>
        <trans-unit id="566bebbe7d115865fba84687df984d4d09e626cd" translate="yes" xml:space="preserve">
          <source>Iter::cloned</source>
          <target state="translated">Iter::cloned</target>
        </trans-unit>
        <trans-unit id="49fa3b568d34193bae851426004f13121d5dfbf5" translate="yes" xml:space="preserve">
          <source>Iter::cmp</source>
          <target state="translated">Iter::cmp</target>
        </trans-unit>
        <trans-unit id="8a894f2ab589ed2151abc86111334156ce8c99e0" translate="yes" xml:space="preserve">
          <source>Iter::collect</source>
          <target state="translated">Iter::collect</target>
        </trans-unit>
        <trans-unit id="d84a1dc76269ab42456219572352b77058751d5b" translate="yes" xml:space="preserve">
          <source>Iter::copied</source>
          <target state="translated">Iter::copied</target>
        </trans-unit>
        <trans-unit id="e3337214a7610ab020e239ae370944a464cce517" translate="yes" xml:space="preserve">
          <source>Iter::count</source>
          <target state="translated">Iter::count</target>
        </trans-unit>
        <trans-unit id="e2ed51e9cb2227202dee5fc9ebaab5c5c44fe8c9" translate="yes" xml:space="preserve">
          <source>Iter::cycle</source>
          <target state="translated">Iter::cycle</target>
        </trans-unit>
        <trans-unit id="b1eb95f6c453fe7f1cf4909e898eaf13d79e9e40" translate="yes" xml:space="preserve">
          <source>Iter::enumerate</source>
          <target state="translated">Iter::enumerate</target>
        </trans-unit>
        <trans-unit id="f2edb3630485a9830839e0b2bd5394c408a64499" translate="yes" xml:space="preserve">
          <source>Iter::eq</source>
          <target state="translated">Iter::eq</target>
        </trans-unit>
        <trans-unit id="f27a886f8dd8072bf872054aa4fa798de4583d5b" translate="yes" xml:space="preserve">
          <source>Iter::filter</source>
          <target state="translated">Iter::filter</target>
        </trans-unit>
        <trans-unit id="9f085b504d73e51e20340f0c14d7d3ec20d8c09e" translate="yes" xml:space="preserve">
          <source>Iter::filter_map</source>
          <target state="translated">Iter::filter_map</target>
        </trans-unit>
        <trans-unit id="482d391704ccfc6551b38406a5c7e4a07c0b7dc9" translate="yes" xml:space="preserve">
          <source>Iter::find</source>
          <target state="translated">Iter::find</target>
        </trans-unit>
        <trans-unit id="cf9a0662f2645651e697db323db99571753cf8fe" translate="yes" xml:space="preserve">
          <source>Iter::find_map</source>
          <target state="translated">Iter::find_map</target>
        </trans-unit>
        <trans-unit id="1afb3fc5d230f5ed3a998d62e9235b71e0c70e53" translate="yes" xml:space="preserve">
          <source>Iter::flat_map</source>
          <target state="translated">Iter::flat_map</target>
        </trans-unit>
        <trans-unit id="233b4826a12d699f0512cb0d95df19aaab9dd4ca" translate="yes" xml:space="preserve">
          <source>Iter::flatten</source>
          <target state="translated">Iter::flatten</target>
        </trans-unit>
        <trans-unit id="7f47a4f5f722efa8de94b21b465ada55ddfa53c5" translate="yes" xml:space="preserve">
          <source>Iter::fmt</source>
          <target state="translated">Iter::fmt</target>
        </trans-unit>
        <trans-unit id="2d150a20937e50aeb5fc3c33739f77c30ca57b98" translate="yes" xml:space="preserve">
          <source>Iter::fold</source>
          <target state="translated">Iter::fold</target>
        </trans-unit>
        <trans-unit id="9ee0b5e31b874c88b499b0f63ac35f2da29dcbb1" translate="yes" xml:space="preserve">
          <source>Iter::for_each</source>
          <target state="translated">Iter::for_each</target>
        </trans-unit>
        <trans-unit id="fb5570128f1baf2cde42d918eac6ebeb0e442ac8" translate="yes" xml:space="preserve">
          <source>Iter::from</source>
          <target state="translated">Iter::from</target>
        </trans-unit>
        <trans-unit id="840450e607dae83abf8fa2b370c6fb1be77c898b" translate="yes" xml:space="preserve">
          <source>Iter::fuse</source>
          <target state="translated">Iter::fuse</target>
        </trans-unit>
        <trans-unit id="23bdea91405b4acdaeed6b4d07b8c58d93cbd9ee" translate="yes" xml:space="preserve">
          <source>Iter::ge</source>
          <target state="translated">Iter::ge</target>
        </trans-unit>
        <trans-unit id="47e26389513b5fb9c312c18d98dfcb98e224fec9" translate="yes" xml:space="preserve">
          <source>Iter::gt</source>
          <target state="translated">Iter::gt</target>
        </trans-unit>
        <trans-unit id="ce4e0788e86ba75e4d44e53b0367cc1f2f04da63" translate="yes" xml:space="preserve">
          <source>Iter::inspect</source>
          <target state="translated">Iter::inspect</target>
        </trans-unit>
        <trans-unit id="84b381fb810d521e23ba1af41b818ce7d2699ac5" translate="yes" xml:space="preserve">
          <source>Iter::into</source>
          <target state="translated">Iter::into</target>
        </trans-unit>
        <trans-unit id="0ec8b2c7e9866e4932264828ae5ae53473579659" translate="yes" xml:space="preserve">
          <source>Iter::into_iter</source>
          <target state="translated">Iter::into_iter</target>
        </trans-unit>
        <trans-unit id="fef12e1b5037aa29137e1d32a9384c2c3b1a9d46" translate="yes" xml:space="preserve">
          <source>Iter::is_empty</source>
          <target state="translated">Iter::is_empty</target>
        </trans-unit>
        <trans-unit id="c845a405850165bfe2d3ee71bdc1256c40185ebf" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted</source>
          <target state="translated">Iter::is_sorted</target>
        </trans-unit>
        <trans-unit id="12877f076c9cd1f4b18bb0043ef86e4ecaae9828" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted_by</source>
          <target state="translated">Iter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="20997a51f1e8798fb3f3c383fb60434b3e8cb926" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted_by_key</source>
          <target state="translated">Iter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b86d7151989059491e48352d38e9c3a298578cd1" translate="yes" xml:space="preserve">
          <source>Iter::last</source>
          <target state="translated">Iter::last</target>
        </trans-unit>
        <trans-unit id="be8b408760eecdbf28c58c97d461c17d4700ffae" translate="yes" xml:space="preserve">
          <source>Iter::le</source>
          <target state="translated">Iter::le</target>
        </trans-unit>
        <trans-unit id="0c6655f000bb8d852e4c2ebc7d52bd9826150f55" translate="yes" xml:space="preserve">
          <source>Iter::len</source>
          <target state="translated">Iter::len</target>
        </trans-unit>
        <trans-unit id="f5f969c8865a706d946ba8d9640ca2c5a0bcf40e" translate="yes" xml:space="preserve">
          <source>Iter::lt</source>
          <target state="translated">Iter::lt</target>
        </trans-unit>
        <trans-unit id="bc0be7886235deb5cb7d836720591efa37538450" translate="yes" xml:space="preserve">
          <source>Iter::map</source>
          <target state="translated">Iter::map</target>
        </trans-unit>
        <trans-unit id="d7746cc600a78a4b80fd8b858ffaf0fe418f31a5" translate="yes" xml:space="preserve">
          <source>Iter::max</source>
          <target state="translated">Iter::max</target>
        </trans-unit>
        <trans-unit id="bdd59dfbd93f93e5159fb6bb4b959f6208971864" translate="yes" xml:space="preserve">
          <source>Iter::max_by</source>
          <target state="translated">Iter::max_by</target>
        </trans-unit>
        <trans-unit id="f2c43a9070f91fd7b274911cb1767f64abad6d73" translate="yes" xml:space="preserve">
          <source>Iter::max_by_key</source>
          <target state="translated">Iter::max_by_key</target>
        </trans-unit>
        <trans-unit id="4953889b3e4b5985acf4e330c37581c731343efb" translate="yes" xml:space="preserve">
          <source>Iter::min</source>
          <target state="translated">Iter::min</target>
        </trans-unit>
        <trans-unit id="a4a384bc464b64ebda76930693b161019c57569b" translate="yes" xml:space="preserve">
          <source>Iter::min_by</source>
          <target state="translated">Iter::min_by</target>
        </trans-unit>
        <trans-unit id="c1b4af4d4490229831ed89e5d2564fd1a077b311" translate="yes" xml:space="preserve">
          <source>Iter::min_by_key</source>
          <target state="translated">Iter::min_by_key</target>
        </trans-unit>
        <trans-unit id="16cc992c33d00ce5220249a5220c02b65f8e4e1b" translate="yes" xml:space="preserve">
          <source>Iter::ne</source>
          <target state="translated">Iter::ne</target>
        </trans-unit>
        <trans-unit id="5726d1319a6927ed8641e6153ccd76700e05b49d" translate="yes" xml:space="preserve">
          <source>Iter::next</source>
          <target state="translated">Iter::next</target>
        </trans-unit>
        <trans-unit id="73c0a4abe0cf04469092e41f4f2fe0440e2dba4e" translate="yes" xml:space="preserve">
          <source>Iter::next_back</source>
          <target state="translated">Iter::next_back</target>
        </trans-unit>
        <trans-unit id="71ecfc9eea70a0501cbf73f369a815090a015495" translate="yes" xml:space="preserve">
          <source>Iter::nth</source>
          <target state="translated">Iter::nth</target>
        </trans-unit>
        <trans-unit id="c585764b69dade897771dda3b24e4c7fa05c8894" translate="yes" xml:space="preserve">
          <source>Iter::nth_back</source>
          <target state="translated">Iter::nth_back</target>
        </trans-unit>
        <trans-unit id="f0d7a323f948a119f8ad33ad48acc983a8d68fd3" translate="yes" xml:space="preserve">
          <source>Iter::partial_cmp</source>
          <target state="translated">Iter::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d508da27672fef4e1401a3134f511ffdb76349df" translate="yes" xml:space="preserve">
          <source>Iter::partition</source>
          <target state="translated">Iter::partition</target>
        </trans-unit>
        <trans-unit id="b7e23f6eab45233e924f47870e7155a7d93ac461" translate="yes" xml:space="preserve">
          <source>Iter::peekable</source>
          <target state="translated">Iter::peekable</target>
        </trans-unit>
        <trans-unit id="c6069463aa7c4524fc50e7f8524606571f2479a2" translate="yes" xml:space="preserve">
          <source>Iter::position</source>
          <target state="translated">Iter::position</target>
        </trans-unit>
        <trans-unit id="49a5d1c1b47f8042ecc9f92065cab6ee7c7e1cc2" translate="yes" xml:space="preserve">
          <source>Iter::product</source>
          <target state="translated">Iter::product</target>
        </trans-unit>
        <trans-unit id="226d371b07f791bdc3b75f6182aa99ed768f3c2f" translate="yes" xml:space="preserve">
          <source>Iter::rev</source>
          <target state="translated">Iter::rev</target>
        </trans-unit>
        <trans-unit id="0e61327392e92ba0988cedb744e914baec8d327a" translate="yes" xml:space="preserve">
          <source>Iter::rfind</source>
          <target state="translated">Iter::rfind</target>
        </trans-unit>
        <trans-unit id="436b05314063cdc717e75ffae43d2197b71db43d" translate="yes" xml:space="preserve">
          <source>Iter::rfold</source>
          <target state="translated">Iter::rfold</target>
        </trans-unit>
        <trans-unit id="ff90d1def598911fc5bfcb191f5cc4a07e4d1561" translate="yes" xml:space="preserve">
          <source>Iter::rposition</source>
          <target state="translated">Iter::rposition</target>
        </trans-unit>
        <trans-unit id="e85d8810cc5f5069c23f9a8039d15b9337b41c52" translate="yes" xml:space="preserve">
          <source>Iter::scan</source>
          <target state="translated">Iter::scan</target>
        </trans-unit>
        <trans-unit id="02418ffbb8d48f42372da15dae730f8a6afc35b5" translate="yes" xml:space="preserve">
          <source>Iter::size_hint</source>
          <target state="translated">Iter::size_hint</target>
        </trans-unit>
        <trans-unit id="4369939a1ce2e9f84ffb9bdab8e42a905e51bdaa" translate="yes" xml:space="preserve">
          <source>Iter::skip</source>
          <target state="translated">Iter::skip</target>
        </trans-unit>
        <trans-unit id="366d06ce202700d06e1162480b372fb9fe5f9f48" translate="yes" xml:space="preserve">
          <source>Iter::skip_while</source>
          <target state="translated">Iter::skip_while</target>
        </trans-unit>
        <trans-unit id="32cde76eb29f240c9e4df839757b9c8dee038962" translate="yes" xml:space="preserve">
          <source>Iter::step_by</source>
          <target state="translated">Iter::step_by</target>
        </trans-unit>
        <trans-unit id="17f9c830155902444763f7911cd38ce5759e0af8" translate="yes" xml:space="preserve">
          <source>Iter::sum</source>
          <target state="translated">Iter::sum</target>
        </trans-unit>
        <trans-unit id="dcb50b3349dc76f0b288cc8da46262ff9851d3ff" translate="yes" xml:space="preserve">
          <source>Iter::take</source>
          <target state="translated">Iter::take</target>
        </trans-unit>
        <trans-unit id="cde2481711540ccdcb763463f9a8e48ead5b8c11" translate="yes" xml:space="preserve">
          <source>Iter::take_while</source>
          <target state="translated">Iter::take_while</target>
        </trans-unit>
        <trans-unit id="7be8f868236c0bacde7fa60a245f689dbd73f4b1" translate="yes" xml:space="preserve">
          <source>Iter::to_owned</source>
          <target state="translated">Iter::to_owned</target>
        </trans-unit>
        <trans-unit id="a61b9bdc8bf2d65e849104ea9f9ddb34b2e438f1" translate="yes" xml:space="preserve">
          <source>Iter::try_fold</source>
          <target state="translated">Iter::try_fold</target>
        </trans-unit>
        <trans-unit id="a376d6605801d1f94fdc5bc8378bfb7d3bf0f291" translate="yes" xml:space="preserve">
          <source>Iter::try_for_each</source>
          <target state="translated">Iter::try_for_each</target>
        </trans-unit>
        <trans-unit id="4742b7e7ce2dc63b3cde1feac9ff7841b386d97b" translate="yes" xml:space="preserve">
          <source>Iter::try_from</source>
          <target state="translated">Iter::try_from</target>
        </trans-unit>
        <trans-unit id="305f66fe9d6f3bd4da9108c4fb964e6d3d7ae558" translate="yes" xml:space="preserve">
          <source>Iter::try_into</source>
          <target state="translated">Iter::try_into</target>
        </trans-unit>
        <trans-unit id="28e819d5eb5da6c1ca2f6898d2a9682f6bd3113c" translate="yes" xml:space="preserve">
          <source>Iter::try_rfold</source>
          <target state="translated">Iter::try_rfold</target>
        </trans-unit>
        <trans-unit id="5431b8f7a2f8d57a1b9712ca70970d17da1898b4" translate="yes" xml:space="preserve">
          <source>Iter::type_id</source>
          <target state="translated">Iter::type_id</target>
        </trans-unit>
        <trans-unit id="ba93aa487eb63805115eee9259cd946bbcc81dc7" translate="yes" xml:space="preserve">
          <source>Iter::unzip</source>
          <target state="translated">Iter::unzip</target>
        </trans-unit>
        <trans-unit id="2eb63393ea4d4a003b71033749175816e8e34fdf" translate="yes" xml:space="preserve">
          <source>Iter::zip</source>
          <target state="translated">Iter::zip</target>
        </trans-unit>
        <trans-unit id="685f18edffd1064c20f2b29242001a402ffdb3fc" translate="yes" xml:space="preserve">
          <source>IterMut</source>
          <target state="translated">IterMut</target>
        </trans-unit>
        <trans-unit id="d15ac12246998b60e4436683e1d97cc9ae701e03" translate="yes" xml:space="preserve">
          <source>IterMut::all</source>
          <target state="translated">IterMut::all</target>
        </trans-unit>
        <trans-unit id="c1e555b3dfd69f8056e360cb14a2a01feb0013e6" translate="yes" xml:space="preserve">
          <source>IterMut::any</source>
          <target state="translated">IterMut::any</target>
        </trans-unit>
        <trans-unit id="fbe3dac2bb3b890d1d56cbc2f3fa0126fa2d43e8" translate="yes" xml:space="preserve">
          <source>IterMut::as_slice</source>
          <target state="translated">IterMut::as_slice</target>
        </trans-unit>
        <trans-unit id="0a947d1a8be02e41fa37714da075d627e9a6d6da" translate="yes" xml:space="preserve">
          <source>IterMut::borrow</source>
          <target state="translated">IterMut::borrow</target>
        </trans-unit>
        <trans-unit id="f88bb4554293b88f8dc1c8bb69415e923325b965" translate="yes" xml:space="preserve">
          <source>IterMut::borrow_mut</source>
          <target state="translated">IterMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="48fa60a837a6bc036bd0c7d9497e19c4f719ec84" translate="yes" xml:space="preserve">
          <source>IterMut::by_ref</source>
          <target state="translated">IterMut::by_ref</target>
        </trans-unit>
        <trans-unit id="f5d9bc35cc15ce8be47292ce1998b21d7b90f454" translate="yes" xml:space="preserve">
          <source>IterMut::chain</source>
          <target state="translated">IterMut::chain</target>
        </trans-unit>
        <trans-unit id="4859f67bc45d1cfa5be5d41026dcf3b89772eceb" translate="yes" xml:space="preserve">
          <source>IterMut::cloned</source>
          <target state="translated">IterMut::cloned</target>
        </trans-unit>
        <trans-unit id="0680e13c44f187b2e2903bd2e1023ab5334923ea" translate="yes" xml:space="preserve">
          <source>IterMut::cmp</source>
          <target state="translated">IterMut::cmp</target>
        </trans-unit>
        <trans-unit id="a0e64fc534b3756ecdc15f5f8acaf539397a5145" translate="yes" xml:space="preserve">
          <source>IterMut::collect</source>
          <target state="translated">IterMut::collect</target>
        </trans-unit>
        <trans-unit id="95a4dd4c3dfd61737eaad683762b0bc7a7f9e7fc" translate="yes" xml:space="preserve">
          <source>IterMut::copied</source>
          <target state="translated">IterMut::copied</target>
        </trans-unit>
        <trans-unit id="5766f26143f5bcf6f3046a585e17bcfe339aad1e" translate="yes" xml:space="preserve">
          <source>IterMut::count</source>
          <target state="translated">IterMut::count</target>
        </trans-unit>
        <trans-unit id="b687092d76c8cc05745b7269130d0abfdaca355d" translate="yes" xml:space="preserve">
          <source>IterMut::cycle</source>
          <target state="translated">IterMut::cycle</target>
        </trans-unit>
        <trans-unit id="6d2db6ed0889c67bb6b498f2b3f67091fe29b968" translate="yes" xml:space="preserve">
          <source>IterMut::enumerate</source>
          <target state="translated">IterMut::enumerate</target>
        </trans-unit>
        <trans-unit id="fb228b5c55ad8378b706b298cb18e19a8d1b92e0" translate="yes" xml:space="preserve">
          <source>IterMut::eq</source>
          <target state="translated">IterMut::eq</target>
        </trans-unit>
        <trans-unit id="10b9735610da183bc0904cfcdc41b325717c5fa4" translate="yes" xml:space="preserve">
          <source>IterMut::filter</source>
          <target state="translated">IterMut::filter</target>
        </trans-unit>
        <trans-unit id="50b5344a605daa6db154682749d39063c82b3aa3" translate="yes" xml:space="preserve">
          <source>IterMut::filter_map</source>
          <target state="translated">IterMut::filter_map</target>
        </trans-unit>
        <trans-unit id="bc7ee8167e059bacfd966b6012e519970cd73008" translate="yes" xml:space="preserve">
          <source>IterMut::find</source>
          <target state="translated">IterMut::find</target>
        </trans-unit>
        <trans-unit id="410d4ebdc94090e744fedb731647c7ec0d8578cc" translate="yes" xml:space="preserve">
          <source>IterMut::find_map</source>
          <target state="translated">IterMut::find_map</target>
        </trans-unit>
        <trans-unit id="65e5eda673bd31f19324431c366d3dfedb17fb01" translate="yes" xml:space="preserve">
          <source>IterMut::flat_map</source>
          <target state="translated">IterMut::flat_map</target>
        </trans-unit>
        <trans-unit id="b284560776dd5bb1ff4273557604dbb2553c7c07" translate="yes" xml:space="preserve">
          <source>IterMut::flatten</source>
          <target state="translated">IterMut::flatten</target>
        </trans-unit>
        <trans-unit id="ab0f6e0b99bf1433157d69dc73b614b9ae6780fe" translate="yes" xml:space="preserve">
          <source>IterMut::fmt</source>
          <target state="translated">IterMut::fmt</target>
        </trans-unit>
        <trans-unit id="4b759c2db23677552fe4a6582ff9535f267cf416" translate="yes" xml:space="preserve">
          <source>IterMut::fold</source>
          <target state="translated">IterMut::fold</target>
        </trans-unit>
        <trans-unit id="ff2b68bb585bc2eef74e222255298430657bd568" translate="yes" xml:space="preserve">
          <source>IterMut::for_each</source>
          <target state="translated">IterMut::for_each</target>
        </trans-unit>
        <trans-unit id="a33e41fe818af66e485ef7d3667b7d969b562154" translate="yes" xml:space="preserve">
          <source>IterMut::from</source>
          <target state="translated">IterMut::from</target>
        </trans-unit>
        <trans-unit id="b0e6a8de88a1b4c1f800636e965b45722312ad0f" translate="yes" xml:space="preserve">
          <source>IterMut::fuse</source>
          <target state="translated">IterMut::fuse</target>
        </trans-unit>
        <trans-unit id="664fd7bab24c7daac348bb72a1609830e80d691b" translate="yes" xml:space="preserve">
          <source>IterMut::ge</source>
          <target state="translated">IterMut::ge</target>
        </trans-unit>
        <trans-unit id="6bfb9c74b746559572b1cb3b3a42167374cd95d6" translate="yes" xml:space="preserve">
          <source>IterMut::gt</source>
          <target state="translated">IterMut::gt</target>
        </trans-unit>
        <trans-unit id="661eb528c55fa69d49ca565e9e26cfd5ddfff9bb" translate="yes" xml:space="preserve">
          <source>IterMut::inspect</source>
          <target state="translated">IterMut::inspect</target>
        </trans-unit>
        <trans-unit id="0085a0c4d6891c0fa655511a1f17f0c6798fffe3" translate="yes" xml:space="preserve">
          <source>IterMut::into</source>
          <target state="translated">IterMut::into</target>
        </trans-unit>
        <trans-unit id="f9d872a7753c37096516c695a54e36bf555e681e" translate="yes" xml:space="preserve">
          <source>IterMut::into_iter</source>
          <target state="translated">IterMut::into_iter</target>
        </trans-unit>
        <trans-unit id="56c9e9ebed846a8f50f7cd23275cf61e51741490" translate="yes" xml:space="preserve">
          <source>IterMut::into_slice</source>
          <target state="translated">IterMut::into_slice</target>
        </trans-unit>
        <trans-unit id="85db2b71d3d95945de22fd6957284758e551f164" translate="yes" xml:space="preserve">
          <source>IterMut::is_empty</source>
          <target state="translated">IterMut::is_empty</target>
        </trans-unit>
        <trans-unit id="057c3534bd6c2db79908fbeb1a2667df6a91093f" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted</source>
          <target state="translated">IterMut::is_sorted</target>
        </trans-unit>
        <trans-unit id="f6db0e52cbdd1cc2839465c01104f6e07b7e10a1" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted_by</source>
          <target state="translated">IterMut::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="946b50eea7f94363f84f06fd925cc2268637ae6d" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted_by_key</source>
          <target state="translated">IterMut::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="65af3e32ba1cf5aa400435aa3fc4596f2e5a4e39" translate="yes" xml:space="preserve">
          <source>IterMut::last</source>
          <target state="translated">IterMut::last</target>
        </trans-unit>
        <trans-unit id="7443e3959cb51f380b4aef241caca0a305e10720" translate="yes" xml:space="preserve">
          <source>IterMut::le</source>
          <target state="translated">IterMut::le</target>
        </trans-unit>
        <trans-unit id="1762aa132da5d0386a5ab5fa889856d0873e884a" translate="yes" xml:space="preserve">
          <source>IterMut::len</source>
          <target state="translated">IterMut::len</target>
        </trans-unit>
        <trans-unit id="e9d8a70597f6275813f3185cc0aa3025f469551a" translate="yes" xml:space="preserve">
          <source>IterMut::lt</source>
          <target state="translated">IterMut::lt</target>
        </trans-unit>
        <trans-unit id="a21d9b76e7d9ffcd6558423c0bce4cbb10973697" translate="yes" xml:space="preserve">
          <source>IterMut::map</source>
          <target state="translated">IterMut::map</target>
        </trans-unit>
        <trans-unit id="c3e262249b1040974db8d46e55cbdb196ff35924" translate="yes" xml:space="preserve">
          <source>IterMut::max</source>
          <target state="translated">IterMut::max</target>
        </trans-unit>
        <trans-unit id="45f2597a4580057864afc9b38782024b25dbed8f" translate="yes" xml:space="preserve">
          <source>IterMut::max_by</source>
          <target state="translated">IterMut::max_by</target>
        </trans-unit>
        <trans-unit id="4cfc9346f59180a900cadc955b42333b50460424" translate="yes" xml:space="preserve">
          <source>IterMut::max_by_key</source>
          <target state="translated">IterMut::max_by_key</target>
        </trans-unit>
        <trans-unit id="ae960d89241a17cf377151468fe032b6642a741c" translate="yes" xml:space="preserve">
          <source>IterMut::min</source>
          <target state="translated">IterMut::min</target>
        </trans-unit>
        <trans-unit id="6afc2639b644683e7d150f8f0a89926a274e7f5d" translate="yes" xml:space="preserve">
          <source>IterMut::min_by</source>
          <target state="translated">IterMut::min_by</target>
        </trans-unit>
        <trans-unit id="ba1f0877c3ded4eb9fc2eca35f95a34f57a1aa87" translate="yes" xml:space="preserve">
          <source>IterMut::min_by_key</source>
          <target state="translated">IterMut::min_by_key</target>
        </trans-unit>
        <trans-unit id="5c517328108a7b9b0752cdfee41b31e1a02675ed" translate="yes" xml:space="preserve">
          <source>IterMut::ne</source>
          <target state="translated">IterMut::ne</target>
        </trans-unit>
        <trans-unit id="4a2e580d79a7438865d40d31a56726e9127888c8" translate="yes" xml:space="preserve">
          <source>IterMut::next</source>
          <target state="translated">IterMut::next</target>
        </trans-unit>
        <trans-unit id="139a3236402870ecd266bb0a9bc31561280b31bb" translate="yes" xml:space="preserve">
          <source>IterMut::next_back</source>
          <target state="translated">IterMut::next_back</target>
        </trans-unit>
        <trans-unit id="7bbe293cbd53f286fef36815b6c7398d20db404f" translate="yes" xml:space="preserve">
          <source>IterMut::nth</source>
          <target state="translated">IterMut::nth</target>
        </trans-unit>
        <trans-unit id="5772506353380947ff699b52a37feaee46051df3" translate="yes" xml:space="preserve">
          <source>IterMut::nth_back</source>
          <target state="translated">IterMut::nth_back</target>
        </trans-unit>
        <trans-unit id="5668de5a92d85d1071ad1f82e9ef7513d2b7bc31" translate="yes" xml:space="preserve">
          <source>IterMut::partial_cmp</source>
          <target state="translated">IterMut::partial_cmp</target>
        </trans-unit>
        <trans-unit id="a3382b312019633bbea8d455e903695ff7a81f6d" translate="yes" xml:space="preserve">
          <source>IterMut::partition</source>
          <target state="translated">IterMut::partition</target>
        </trans-unit>
        <trans-unit id="def8ddaad6d23f184f1d8f90e47c52e6771c8726" translate="yes" xml:space="preserve">
          <source>IterMut::peekable</source>
          <target state="translated">IterMut::peekable</target>
        </trans-unit>
        <trans-unit id="e4e4bcd4ad39225fe6f1d31a86b7460e74649082" translate="yes" xml:space="preserve">
          <source>IterMut::position</source>
          <target state="translated">IterMut::position</target>
        </trans-unit>
        <trans-unit id="f8e28dca24a6d5cb911b812d63ca4210ad500397" translate="yes" xml:space="preserve">
          <source>IterMut::product</source>
          <target state="translated">IterMut::product</target>
        </trans-unit>
        <trans-unit id="e40a83a0559fe372b3fe052ff00a96a4950cded6" translate="yes" xml:space="preserve">
          <source>IterMut::rev</source>
          <target state="translated">IterMut::rev</target>
        </trans-unit>
        <trans-unit id="1e68d13e84703c21f465d900fde2ea2255c05c3d" translate="yes" xml:space="preserve">
          <source>IterMut::rfind</source>
          <target state="translated">IterMut::rfind</target>
        </trans-unit>
        <trans-unit id="1071e32d4bd9d85b7bb9988ca035b92c220cbc89" translate="yes" xml:space="preserve">
          <source>IterMut::rfold</source>
          <target state="translated">IterMut::rfold</target>
        </trans-unit>
        <trans-unit id="d9ad978343710ca3ac668584e5ec56ee87a41af1" translate="yes" xml:space="preserve">
          <source>IterMut::rposition</source>
          <target state="translated">IterMut::rposition</target>
        </trans-unit>
        <trans-unit id="3d57b99fe3a36a90ffb9f9e83e9da20276fd9a22" translate="yes" xml:space="preserve">
          <source>IterMut::scan</source>
          <target state="translated">IterMut::scan</target>
        </trans-unit>
        <trans-unit id="fae924a614763f37e082883ddaabc2b87b19bf2c" translate="yes" xml:space="preserve">
          <source>IterMut::size_hint</source>
          <target state="translated">IterMut::size_hint</target>
        </trans-unit>
        <trans-unit id="709c8510ff15526b1a9b732e5db04549151388c6" translate="yes" xml:space="preserve">
          <source>IterMut::skip</source>
          <target state="translated">IterMut::skip</target>
        </trans-unit>
        <trans-unit id="c54d538f96fcc47416c4e42ffc8829538ae491ab" translate="yes" xml:space="preserve">
          <source>IterMut::skip_while</source>
          <target state="translated">IterMut::skip_while</target>
        </trans-unit>
        <trans-unit id="38fb28ea29c6bc530e47f9dad6ca847a8308a455" translate="yes" xml:space="preserve">
          <source>IterMut::step_by</source>
          <target state="translated">IterMut::step_by</target>
        </trans-unit>
        <trans-unit id="07bbba43ad63c86d9539b561228e2c22eba74a81" translate="yes" xml:space="preserve">
          <source>IterMut::sum</source>
          <target state="translated">IterMut::sum</target>
        </trans-unit>
        <trans-unit id="e4e5a5c0090d5cac8762c3c6b597e5689d25a27c" translate="yes" xml:space="preserve">
          <source>IterMut::take</source>
          <target state="translated">IterMut::take</target>
        </trans-unit>
        <trans-unit id="33dd2e99d843e213c0ddd91584e7448ac2d4b106" translate="yes" xml:space="preserve">
          <source>IterMut::take_while</source>
          <target state="translated">IterMut::take_while</target>
        </trans-unit>
        <trans-unit id="89c3c4340f9719a145ec3899304b1842903b1e8e" translate="yes" xml:space="preserve">
          <source>IterMut::try_fold</source>
          <target state="translated">IterMut::try_fold</target>
        </trans-unit>
        <trans-unit id="3ecd354292c647432d92da5022d802acbefdaf09" translate="yes" xml:space="preserve">
          <source>IterMut::try_for_each</source>
          <target state="translated">IterMut::try_for_each</target>
        </trans-unit>
        <trans-unit id="07824f2f826e7e718e59741916504b108d880d62" translate="yes" xml:space="preserve">
          <source>IterMut::try_from</source>
          <target state="translated">IterMut::try_from</target>
        </trans-unit>
        <trans-unit id="9a96ea4150cfa217a4f1dd08ae093708354d29eb" translate="yes" xml:space="preserve">
          <source>IterMut::try_into</source>
          <target state="translated">IterMut::try_into</target>
        </trans-unit>
        <trans-unit id="29aff2c0b7bfd47c5d4837ac67638482b835e70d" translate="yes" xml:space="preserve">
          <source>IterMut::try_rfold</source>
          <target state="translated">IterMut::try_rfold</target>
        </trans-unit>
        <trans-unit id="bf0e0921f0da7331cb27e7d17d9e221b70171a7a" translate="yes" xml:space="preserve">
          <source>IterMut::type_id</source>
          <target state="translated">IterMut::type_id</target>
        </trans-unit>
        <trans-unit id="7f6f9babd020f3f6641909fd4a54810ef8d5c98a" translate="yes" xml:space="preserve">
          <source>IterMut::unzip</source>
          <target state="translated">IterMut::unzip</target>
        </trans-unit>
        <trans-unit id="bbedf0cc88bd2517be640465c65b23b15a5a71ba" translate="yes" xml:space="preserve">
          <source>IterMut::zip</source>
          <target state="translated">IterMut::zip</target>
        </trans-unit>
        <trans-unit id="5de97051f4a5bf9656a21f5c9446ab6c961f1d50" translate="yes" xml:space="preserve">
          <source>Iterate over a series of values with &lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Repita una serie de valores con &lt;a href=&quot;keyword.for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2499260c1be5541b8c3abea5b95c5cff7ca9f173" translate="yes" xml:space="preserve">
          <source>Iterate through each line of the contents.</source>
          <target state="translated">Iterar a través de cada línea del contenido.</target>
        </trans-unit>
        <trans-unit id="ddc1d37b3a6ff7065f6616ad5090d037179310e5" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements</source>
          <target state="translated">Iterados sobre todo el iterador,multiplicando todos los elementos</target>
        </trans-unit>
        <trans-unit id="12f90576d62ee51bcd72346f4eea97d035ff3fbf" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../../../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Itera sobre todo el iterador, multiplicando todos los elementos &lt;a href=&quot;../../../iter/trait.iterator#method.product&quot;&gt;Leer m&amp;aacute;s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e32fff0b6901e0665a7a8c46f77166fe30575d0c" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Itera sobre todo el iterador, multiplicando todos los elementos &lt;a href=&quot;../../iter/trait.iterator#method.product&quot;&gt;Leer m&amp;aacute;s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ba661f58c25c048da380a890db7f86c82d555ed" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Itera sobre todo el iterador, multiplicando todos los elementos &lt;a href=&quot;../iter/trait.iterator#method.product&quot;&gt;Leer m&amp;aacute;s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e40697331454225ecb2ac731fb00044a53174cc1" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Itera sobre todo el iterador, multiplicando todos los elementos &lt;a href=&quot;iter/trait.iterator#method.product&quot;&gt;Leer m&amp;aacute;s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba2858c97778cf6ff78dc3d4e578f6ce94c7f587" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Itera sobre todo el iterador, multiplicando todos los elementos &lt;a href=&quot;trait.iterator#method.product&quot;&gt;Leer m&amp;aacute;s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dff502cf70a8cb10dd882dfdf098dc4aa48cf1e" translate="yes" xml:space="preserve">
          <source>Iterates over the slice &lt;code&gt;other&lt;/code&gt;, clones each element, and then appends it to this &lt;code&gt;Vec&lt;/code&gt;. The &lt;code&gt;other&lt;/code&gt; vector is traversed in-order.</source>
          <target state="translated">Itera sobre el &lt;code&gt;other&lt;/code&gt; segmento , clona cada elemento y luego lo agrega a este &lt;code&gt;Vec&lt;/code&gt; . El &lt;code&gt;other&lt;/code&gt; vector se recorre en orden.</target>
        </trans-unit>
        <trans-unit id="5d265d453acaa19c0ae15ceee2e6a72145e4e232" translate="yes" xml:space="preserve">
          <source>Iterating Through Lines with the &lt;code id=&quot;iterating-through-lines-with-the-lines-method&quot;&gt;lines&lt;/code&gt; Method</source>
          <target state="translated">Iterando a trav&amp;eacute;s de l&amp;iacute;neas con el m&amp;eacute;todo de &lt;code id=&quot;iterating-through-lines-with-the-lines-method&quot;&gt;lines&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9232973e4659ad95034977407f818f02bad0423b" translate="yes" xml:space="preserve">
          <source>Iterating over the Values in a Vector</source>
          <target state="translated">Iterar sobre los valores en un vector</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="4bbe26c7d68240e48a823975e3e785a737635548" translate="yes" xml:space="preserve">
          <source>Iteration with &lt;a href=&quot;keyword.in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;, trait implementation with &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../reference/trait-bounds#higher-ranked-trait-bounds&quot;&gt;higher-ranked trait bounds&lt;/a&gt; (&lt;code&gt;for&amp;lt;'a&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Iteraci&amp;oacute;n con &lt;a href=&quot;keyword.in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; , implementaci&amp;oacute;n de rasgo con &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; , o &lt;a href=&quot;../reference/trait-bounds#higher-ranked-trait-bounds&quot;&gt;l&amp;iacute;mites de rasgo de rango superior&lt;/a&gt; ( &lt;code&gt;for&amp;lt;'a&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="9423090682be31506d3158301d684f4abe89d00e" translate="yes" xml:space="preserve">
          <source>Iterator behavior</source>
          <target state="translated">Comportamiento iterativo</target>
        </trans-unit>
        <trans-unit id="bb7528b69192612888be1c4ce8f89b0e0e581862" translate="yes" xml:space="preserve">
          <source>Iterator loops</source>
          <target state="translated">Lazos iterativos</target>
        </trans-unit>
        <trans-unit id="d19530e5d03b36f27c9d84864c3b65bb57584a79" translate="yes" xml:space="preserve">
          <source>Iterator over the entries in a directory.</source>
          <target state="translated">Iteración sobre las entradas de un directorio.</target>
        </trans-unit>
        <trans-unit id="ba33042f2a1b69e3f8c089958f5c5514f1643aee" translate="yes" xml:space="preserve">
          <source>Iterator types</source>
          <target state="translated">Tipos de iterativos</target>
        </trans-unit>
        <trans-unit id="4273ec271075233286703458c7e9ebc00e2e82df" translate="yes" xml:space="preserve">
          <source>Iterator::all</source>
          <target state="translated">Iterator::all</target>
        </trans-unit>
        <trans-unit id="f86c54ca12225c13236cdc3a624968944761ea05" translate="yes" xml:space="preserve">
          <source>Iterator::any</source>
          <target state="translated">Iterator::any</target>
        </trans-unit>
        <trans-unit id="d57ec500fe9ec2bba36378c03fe82c9f66576f38" translate="yes" xml:space="preserve">
          <source>Iterator::by_ref</source>
          <target state="translated">Iterator::by_ref</target>
        </trans-unit>
        <trans-unit id="eee7519010a092f18111fa15dd804b221949785a" translate="yes" xml:space="preserve">
          <source>Iterator::chain</source>
          <target state="translated">Iterator::chain</target>
        </trans-unit>
        <trans-unit id="2737cab8dbd36c284c2d2a04345b6f802d76520e" translate="yes" xml:space="preserve">
          <source>Iterator::cloned</source>
          <target state="translated">Iterator::cloned</target>
        </trans-unit>
        <trans-unit id="4d53642d0597c543ebd99c70d62ee5234be120ee" translate="yes" xml:space="preserve">
          <source>Iterator::cmp</source>
          <target state="translated">Iterator::cmp</target>
        </trans-unit>
        <trans-unit id="6840be4400b24989a5f3ee01f218588655855ede" translate="yes" xml:space="preserve">
          <source>Iterator::collect</source>
          <target state="translated">Iterator::collect</target>
        </trans-unit>
        <trans-unit id="afd3fcee84d868df85114f2c2de87906ba8b73fd" translate="yes" xml:space="preserve">
          <source>Iterator::copied</source>
          <target state="translated">Iterator::copied</target>
        </trans-unit>
        <trans-unit id="65c267a3908408f21f20c7542c580b394c3ac479" translate="yes" xml:space="preserve">
          <source>Iterator::count</source>
          <target state="translated">Iterator::count</target>
        </trans-unit>
        <trans-unit id="a62029a441e5502574f74110e73622b6c124b195" translate="yes" xml:space="preserve">
          <source>Iterator::cycle</source>
          <target state="translated">Iterator::cycle</target>
        </trans-unit>
        <trans-unit id="4cf31dbb9795763807136c75aa5ab726e70ab4da" translate="yes" xml:space="preserve">
          <source>Iterator::enumerate</source>
          <target state="translated">Iterator::enumerate</target>
        </trans-unit>
        <trans-unit id="e54da00842cf3d69c5bb79f7e6ff037be7b7d1eb" translate="yes" xml:space="preserve">
          <source>Iterator::eq</source>
          <target state="translated">Iterator::eq</target>
        </trans-unit>
        <trans-unit id="7cf8c3afdf60282496111d5e9294d886ba58ff32" translate="yes" xml:space="preserve">
          <source>Iterator::filter</source>
          <target state="translated">Iterator::filter</target>
        </trans-unit>
        <trans-unit id="d6f882e7564be02de62cc36c2cb255e404103b69" translate="yes" xml:space="preserve">
          <source>Iterator::filter_map</source>
          <target state="translated">Iterator::filter_map</target>
        </trans-unit>
        <trans-unit id="8bad19b292d0ba35dd2b96e68725fc1ecca7ab20" translate="yes" xml:space="preserve">
          <source>Iterator::find</source>
          <target state="translated">Iterator::find</target>
        </trans-unit>
        <trans-unit id="3ea058ee3e827f8722e557a5ed69196b9d69ffef" translate="yes" xml:space="preserve">
          <source>Iterator::find_map</source>
          <target state="translated">Iterator::find_map</target>
        </trans-unit>
        <trans-unit id="fb5d2f94b065377a6651ac4b6316f941b8a73d83" translate="yes" xml:space="preserve">
          <source>Iterator::flat_map</source>
          <target state="translated">Iterator::flat_map</target>
        </trans-unit>
        <trans-unit id="111068d32ae21f272191794cb73558e1cac98f8c" translate="yes" xml:space="preserve">
          <source>Iterator::flatten</source>
          <target state="translated">Iterator::flatten</target>
        </trans-unit>
        <trans-unit id="43a4b81bd3319dd7c1f643ea1239981100f2bfe0" translate="yes" xml:space="preserve">
          <source>Iterator::fold</source>
          <target state="translated">Iterator::fold</target>
        </trans-unit>
        <trans-unit id="4b6d8e0bb7e0875f730af26e464f2d7f56787c00" translate="yes" xml:space="preserve">
          <source>Iterator::for_each</source>
          <target state="translated">Iterator::for_each</target>
        </trans-unit>
        <trans-unit id="d331641f18373a947667fdd994090cbdbe5e56e3" translate="yes" xml:space="preserve">
          <source>Iterator::fuse</source>
          <target state="translated">Iterator::fuse</target>
        </trans-unit>
        <trans-unit id="a1d0aae8a33bedb12212f917dec98beb3c31719d" translate="yes" xml:space="preserve">
          <source>Iterator::ge</source>
          <target state="translated">Iterator::ge</target>
        </trans-unit>
        <trans-unit id="d02804beda6f63be283b340587c424846986c214" translate="yes" xml:space="preserve">
          <source>Iterator::gt</source>
          <target state="translated">Iterator::gt</target>
        </trans-unit>
        <trans-unit id="f6f98700823020b1af15767f0fd9cf51cc5b3580" translate="yes" xml:space="preserve">
          <source>Iterator::inspect</source>
          <target state="translated">Iterator::inspect</target>
        </trans-unit>
        <trans-unit id="2b970d2781d8419238596de0ecda94a2ec01de0f" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted</source>
          <target state="translated">Iterator::is_sorted</target>
        </trans-unit>
        <trans-unit id="856d4b939b6e2b1172c61d2fab65a6f2f22d06a3" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted_by</source>
          <target state="translated">Iterator::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d2695a4fa6c8f77acecd3c782968648c5c7e47f" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted_by_key</source>
          <target state="translated">Iterator::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="fc7204aa1fca5db78599c8ff71f528a152d2799f" translate="yes" xml:space="preserve">
          <source>Iterator::last</source>
          <target state="translated">Iterator::last</target>
        </trans-unit>
        <trans-unit id="89a83249a4c0370a4e7fe4b445980fe3d4bdb85b" translate="yes" xml:space="preserve">
          <source>Iterator::le</source>
          <target state="translated">Iterator::le</target>
        </trans-unit>
        <trans-unit id="3de38ebedca0b7133046aaeeabbf64a22e912ef4" translate="yes" xml:space="preserve">
          <source>Iterator::lt</source>
          <target state="translated">Iterator::lt</target>
        </trans-unit>
        <trans-unit id="791a1e23f54e2b3d01c25daf21bceda253396401" translate="yes" xml:space="preserve">
          <source>Iterator::map</source>
          <target state="translated">Iterator::map</target>
        </trans-unit>
        <trans-unit id="14ca2127fd3ab1a13326b57f93a743807d4a385a" translate="yes" xml:space="preserve">
          <source>Iterator::max</source>
          <target state="translated">Iterator::max</target>
        </trans-unit>
        <trans-unit id="73c5938125fe2dda5817351036d306957ab62fdf" translate="yes" xml:space="preserve">
          <source>Iterator::max_by</source>
          <target state="translated">Iterator::max_by</target>
        </trans-unit>
        <trans-unit id="0d48dc0112caa2401ba3e6305374cbe9d9f62de6" translate="yes" xml:space="preserve">
          <source>Iterator::max_by_key</source>
          <target state="translated">Iterator::max_by_key</target>
        </trans-unit>
        <trans-unit id="1e915bf62293697842ab0cc1c78d7c4d9247f8a2" translate="yes" xml:space="preserve">
          <source>Iterator::min</source>
          <target state="translated">Iterator::min</target>
        </trans-unit>
        <trans-unit id="350a01c462ad653692ad3d7c81cc7f998b33cc7a" translate="yes" xml:space="preserve">
          <source>Iterator::min_by</source>
          <target state="translated">Iterator::min_by</target>
        </trans-unit>
        <trans-unit id="3fa40a72cbf669f1ff2dd6db52b49bf6e29072d6" translate="yes" xml:space="preserve">
          <source>Iterator::min_by_key</source>
          <target state="translated">Iterator::min_by_key</target>
        </trans-unit>
        <trans-unit id="898579db7c8bd3e1760f9dc45aebef8f31d79de6" translate="yes" xml:space="preserve">
          <source>Iterator::ne</source>
          <target state="translated">Iterator::ne</target>
        </trans-unit>
        <trans-unit id="2d360ad0443fc86aaf713ff8a07e3d0e24910e14" translate="yes" xml:space="preserve">
          <source>Iterator::next</source>
          <target state="translated">Iterator::next</target>
        </trans-unit>
        <trans-unit id="4ef73a468549da918e9ddd255430293b4d475cf4" translate="yes" xml:space="preserve">
          <source>Iterator::nth</source>
          <target state="translated">Iterator::nth</target>
        </trans-unit>
        <trans-unit id="6430563009c292bd461b9dbdbc8efbc87ed667e5" translate="yes" xml:space="preserve">
          <source>Iterator::partial_cmp</source>
          <target state="translated">Iterator::partial_cmp</target>
        </trans-unit>
        <trans-unit id="38feb7e4eded7516cbc44a5b7ae390dbea8a1c5f" translate="yes" xml:space="preserve">
          <source>Iterator::partition</source>
          <target state="translated">Iterator::partition</target>
        </trans-unit>
        <trans-unit id="b1d4b5a349a9bfe583ffe37ec59e50ccad659479" translate="yes" xml:space="preserve">
          <source>Iterator::peekable</source>
          <target state="translated">Iterator::peekable</target>
        </trans-unit>
        <trans-unit id="6ffb8dda5bc3637bf0fea7d50ee2879f36477dbd" translate="yes" xml:space="preserve">
          <source>Iterator::position</source>
          <target state="translated">Iterator::position</target>
        </trans-unit>
        <trans-unit id="ec1b6d5e61cc3a26f25348b0a2e1ad79bbac1c52" translate="yes" xml:space="preserve">
          <source>Iterator::product</source>
          <target state="translated">Iterator::product</target>
        </trans-unit>
        <trans-unit id="48046e9ab82515a6dd4fd7b646f1ce53e8faac3b" translate="yes" xml:space="preserve">
          <source>Iterator::rev</source>
          <target state="translated">Iterator::rev</target>
        </trans-unit>
        <trans-unit id="67f9a990bd064873346b5c9e2d17fe35c839d67c" translate="yes" xml:space="preserve">
          <source>Iterator::rposition</source>
          <target state="translated">Iterator::rposition</target>
        </trans-unit>
        <trans-unit id="ff5bd4337968d7f15fa02188bc9ec8899d066887" translate="yes" xml:space="preserve">
          <source>Iterator::scan</source>
          <target state="translated">Iterator::scan</target>
        </trans-unit>
        <trans-unit id="ecc32183d685c53eedf20225f612a8f2cd0d1e50" translate="yes" xml:space="preserve">
          <source>Iterator::size_hint</source>
          <target state="translated">Iterator::size_hint</target>
        </trans-unit>
        <trans-unit id="5407d981fcc2957741d940d765b5c8aeeb89a7d3" translate="yes" xml:space="preserve">
          <source>Iterator::skip</source>
          <target state="translated">Iterator::skip</target>
        </trans-unit>
        <trans-unit id="b37ac34fd4f971b4431eb07cfed110e756486a69" translate="yes" xml:space="preserve">
          <source>Iterator::skip_while</source>
          <target state="translated">Iterator::skip_while</target>
        </trans-unit>
        <trans-unit id="18e1ae8414f33fb71bfb82df82aa89205f40cf2a" translate="yes" xml:space="preserve">
          <source>Iterator::step_by</source>
          <target state="translated">Iterator::step_by</target>
        </trans-unit>
        <trans-unit id="17eae761d55f0527972d28d8efb13700ff9cd9a8" translate="yes" xml:space="preserve">
          <source>Iterator::sum</source>
          <target state="translated">Iterator::sum</target>
        </trans-unit>
        <trans-unit id="7818fb82bcb2e27b1eaf83bc4a006e1deaa87c61" translate="yes" xml:space="preserve">
          <source>Iterator::take</source>
          <target state="translated">Iterator::take</target>
        </trans-unit>
        <trans-unit id="8585d3ded5bed1eba060e171ff1f8d071aa3c3c0" translate="yes" xml:space="preserve">
          <source>Iterator::take_while</source>
          <target state="translated">Iterator::take_while</target>
        </trans-unit>
        <trans-unit id="f3a0250ddc27ec143683c1a6492e90be2e63cdfb" translate="yes" xml:space="preserve">
          <source>Iterator::try_fold</source>
          <target state="translated">Iterator::try_fold</target>
        </trans-unit>
        <trans-unit id="97ee2ddc3ae8f6722d8aa8a8f03acf882d6fb21c" translate="yes" xml:space="preserve">
          <source>Iterator::try_for_each</source>
          <target state="translated">Iterator::try_for_each</target>
        </trans-unit>
        <trans-unit id="d42112e418ab0fd56186356df14c7791d504e7e2" translate="yes" xml:space="preserve">
          <source>Iterator::unzip</source>
          <target state="translated">Iterator::unzip</target>
        </trans-unit>
        <trans-unit id="2191de9c88e99f9f5438674c00e37989322ce302" translate="yes" xml:space="preserve">
          <source>Iterator::zip</source>
          <target state="translated">Iterator::zip</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="2f934a245522e136eca293cd75a09317df2f2cd7" translate="yes" xml:space="preserve">
          <source>Iterators (and iterator &lt;a href=&quot;#adapters&quot;&gt;adapters&lt;/a&gt;) are &lt;em&gt;lazy&lt;/em&gt;. This means that just creating an iterator doesn't &lt;em&gt;do&lt;/em&gt; a whole lot. Nothing really happens until you call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;. This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method calls a closure on each element it iterates over:</source>
          <target state="translated">Los iteradores (y los &lt;a href=&quot;#adapters&quot;&gt;adaptadores de&lt;/a&gt; iteradores ) son &lt;em&gt;perezosos&lt;/em&gt; . Esto significa que solo crear un iterador no &lt;em&gt;hace&lt;/em&gt; mucho. Realmente no pasa nada hasta que llame a &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; . A veces, esto es una fuente de confusi&amp;oacute;n cuando se crea un iterador &amp;uacute;nicamente por sus efectos secundarios. Por ejemplo, el m&amp;eacute;todo del &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; a&lt;/a&gt; llama a un cierre en cada elemento sobre el que itera:</target>
        </trans-unit>
        <trans-unit id="bc571c24ac50d6cee6e1818f6a078d2a419abc9e" translate="yes" xml:space="preserve">
          <source>Iterators also provide a series of &lt;em&gt;adapter&lt;/em&gt; methods for performing common threads to sequences. Among the adapters are functional favorites like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt;. Of particular interest to collections is the &lt;code&gt;rev&lt;/code&gt; adapter, that reverses any iterator that supports this operation. Most collections provide reversible iterators as the way to iterate over them in reverse order.</source>
          <target state="translated">Los iteradores tambi&amp;eacute;n proporcionan una serie de m&amp;eacute;todos de &lt;em&gt;adaptador&lt;/em&gt; para realizar subprocesos comunes a secuencias. Entre los adaptadores se encuentran los favoritos funcionales como &lt;code&gt;map&lt;/code&gt; a , &lt;code&gt;fold&lt;/code&gt; , &lt;code&gt;skip&lt;/code&gt; y &lt;code&gt;take&lt;/code&gt; . De particular inter&amp;eacute;s para las colecciones es el adaptador de &lt;code&gt;rev&lt;/code&gt; oluciones , que invierte cualquier iterador que admita esta operaci&amp;oacute;n. La mayor&amp;iacute;a de las colecciones proporcionan iteradores reversibles como forma de iterar sobre ellas en orden inverso.</target>
        </trans-unit>
        <trans-unit id="1604a556288e09f94874ae1b1e2b1eb8eabf0eb7" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful and robust mechanism used throughout Rust's standard libraries. Iterators provide a sequence of values in a generic, safe, efficient and convenient way. The contents of an iterator are usually &lt;em&gt;lazily&lt;/em&gt; evaluated, so that only the values that are actually needed are ever actually produced, and no allocation need be done to temporarily store them. Iterators are primarily consumed using a &lt;code&gt;for&lt;/code&gt; loop, although many functions also take iterators where a collection or sequence of values is desired.</source>
          <target state="translated">Los iteradores son un mecanismo potente y robusto que se utiliza en todas las bibliotecas est&amp;aacute;ndar de Rust. Los iteradores proporcionan una secuencia de valores de manera gen&amp;eacute;rica, segura, eficiente y conveniente. El contenido de un iterador generalmente se eval&amp;uacute;a de manera &lt;em&gt;perezosa&lt;/em&gt; , de modo que solo se producen realmente los valores que realmente se necesitan, y no es necesario realizar una asignaci&amp;oacute;n para almacenarlos temporalmente. Los iteradores se consumen principalmente mediante un bucle &lt;code&gt;for&lt;/code&gt; , aunque muchas funciones tambi&amp;eacute;n toman iteradores cuando se desea una colecci&amp;oacute;n o secuencia de valores.</target>
        </trans-unit>
        <trans-unit id="578d7fdeb01ae2ce26df2699ac5468054a311e64" translate="yes" xml:space="preserve">
          <source>Iterators are also composable, and it's common to chain them together to do more complex forms of processing. See the &lt;a href=&quot;#adapters&quot;&gt;Adapters&lt;/a&gt; section below for more details.</source>
          <target state="translated">Los iteradores tambi&amp;eacute;n se pueden componer y es com&amp;uacute;n encadenarlos para realizar formas de procesamiento m&amp;aacute;s complejas. Consulte la secci&amp;oacute;n &lt;a href=&quot;#adapters&quot;&gt;Adaptadores a&lt;/a&gt; continuaci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="73a40f4f406e6b8d805bf4ec3dd55761493e5309" translate="yes" xml:space="preserve">
          <source>Iterators do not have to be finite. As an example, an open-ended range is an infinite iterator:</source>
          <target state="translated">Los iteradores no tienen que ser finitos.Por ejemplo,un rango abierto es un iterador infinito:</target>
        </trans-unit>
        <trans-unit id="cd7908f9004d53eb6241ef825d90a63188a57756" translate="yes" xml:space="preserve">
          <source>Iterators handle all that logic for you, cutting down on repetitive code you could potentially mess up. Iterators give you more flexibility to use the same logic with many different kinds of sequences, not just data structures you can index into, like vectors. Let&amp;rsquo;s examine how iterators do that.</source>
          <target state="translated">Los iteradores manejan toda esa l&amp;oacute;gica por usted, reduciendo el c&amp;oacute;digo repetitivo que podr&amp;iacute;a estropear. Los iteradores le brindan m&amp;aacute;s flexibilidad para usar la misma l&amp;oacute;gica con muchos tipos diferentes de secuencias, no solo estructuras de datos en las que puede indexar, como vectores. Examinemos c&amp;oacute;mo los iteradores hacen eso.</target>
        </trans-unit>
        <trans-unit id="ef660a43407868b9cb1e9e11d499fe58b2a67f0d" translate="yes" xml:space="preserve">
          <source>Iterators of known length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c70e7513b6f7cfa60a8740edd8f829825ff6ce" translate="yes" xml:space="preserve">
          <source>Iterators produce a series of values, and collections can also be thought of as a series of values. The &lt;code&gt;Extend&lt;/code&gt; trait bridges this gap, allowing you to extend a collection by including the contents of that iterator. When extending a collection with an already existing key, that entry is updated or, in the case of collections that permit multiple entries with equal keys, that entry is inserted.</source>
          <target state="translated">Los iteradores producen una serie de valores y las colecciones tambi&amp;eacute;n se pueden considerar como una serie de valores. El rasgo &lt;code&gt;Extend&lt;/code&gt; cierra esta brecha, lo que le permite extender una colecci&amp;oacute;n al incluir el contenido de ese iterador. Al ampliar una colecci&amp;oacute;n con una clave ya existente, esa entrada se actualiza o, en el caso de colecciones que permiten m&amp;uacute;ltiples entradas con claves iguales, se inserta esa entrada.</target>
        </trans-unit>
        <trans-unit id="36fe73edebcef37071d90c761137d6e576a12835" translate="yes" xml:space="preserve">
          <source>Iterators that dynamically terminate.</source>
          <target state="translated">Iteradores que terminan dinámicamente.</target>
        </trans-unit>
        <trans-unit id="c4a0156a59a95761c105c3a3e41e56a330667ccb" translate="yes" xml:space="preserve">
          <source>Iterators:</source>
          <target state="translated">Iterators:</target>
        </trans-unit>
        <trans-unit id="f0236db9f43733339562b17d0dc2c960dc9c9a8f" translate="yes" xml:space="preserve">
          <source>Its type is &lt;code&gt;'static&lt;/code&gt; duration borrowed string slice, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">Su tipo es &lt;code&gt;'static&lt;/code&gt; porci&amp;oacute;n de cadena prestada de duraci&amp;oacute;n est&amp;aacute;tica , &lt;code&gt;&amp;amp;'static str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="9c46090b4698309dc6d00e2e6c188ead587a40e9" translate="yes" xml:space="preserve">
          <source>JoinHandle</source>
          <target state="translated">JoinHandle</target>
        </trans-unit>
        <trans-unit id="dbe795c59f1c72343d5a4f517f9ad3b4275e45c2" translate="yes" xml:space="preserve">
          <source>JoinHandle::as_pthread_t</source>
          <target state="translated">JoinHandle::as_pthread_t</target>
        </trans-unit>
        <trans-unit id="412c59894065992ad9701ec7e4a5555a722a3202" translate="yes" xml:space="preserve">
          <source>JoinHandle::as_raw_handle</source>
          <target state="translated">JoinHandle::as_raw_handle</target>
        </trans-unit>
        <trans-unit id="3cec4888e9d7b5ae79106f6aa6dc453c6917c4e8" translate="yes" xml:space="preserve">
          <source>JoinHandle::borrow</source>
          <target state="translated">JoinHandle::borrow</target>
        </trans-unit>
        <trans-unit id="fd2845c5bf15e89eb7f9f69c8adaebecb219c672" translate="yes" xml:space="preserve">
          <source>JoinHandle::borrow_mut</source>
          <target state="translated">JoinHandle::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4c3ce23926add99bcb7d4f4c43a106d00bccac89" translate="yes" xml:space="preserve">
          <source>JoinHandle::fmt</source>
          <target state="translated">JoinHandle::fmt</target>
        </trans-unit>
        <trans-unit id="f7242c7bfb17274370663c2f02ebe9f7d7c96f0f" translate="yes" xml:space="preserve">
          <source>JoinHandle::from</source>
          <target state="translated">JoinHandle::from</target>
        </trans-unit>
        <trans-unit id="d5627903ac6c6fca86247def251096015fffbc5a" translate="yes" xml:space="preserve">
          <source>JoinHandle::into</source>
          <target state="translated">JoinHandle::into</target>
        </trans-unit>
        <trans-unit id="7e1eec403cc018629f136e34f3666787322dd901" translate="yes" xml:space="preserve">
          <source>JoinHandle::into_pthread_t</source>
          <target state="translated">JoinHandle::into_pthread_t</target>
        </trans-unit>
        <trans-unit id="c6314894dabf847146013c8140ba901c5f3fc886" translate="yes" xml:space="preserve">
          <source>JoinHandle::into_raw_handle</source>
          <target state="translated">JoinHandle::into_raw_handle</target>
        </trans-unit>
        <trans-unit id="45b01c0739817e609f8d08e9f75c05ce81644422" translate="yes" xml:space="preserve">
          <source>JoinHandle::join</source>
          <target state="translated">JoinHandle::join</target>
        </trans-unit>
        <trans-unit id="c16676e74c56443eeda553ebfbb33efee8fee2c2" translate="yes" xml:space="preserve">
          <source>JoinHandle::thread</source>
          <target state="translated">JoinHandle::thread</target>
        </trans-unit>
        <trans-unit id="8607545c9c64edf874a5905869af45ed541936fc" translate="yes" xml:space="preserve">
          <source>JoinHandle::try_from</source>
          <target state="translated">JoinHandle::try_from</target>
        </trans-unit>
        <trans-unit id="5b4f897ba8176b628f13a3930ac9376591daff65" translate="yes" xml:space="preserve">
          <source>JoinHandle::try_into</source>
          <target state="translated">JoinHandle::try_into</target>
        </trans-unit>
        <trans-unit id="81095dc64ba5b13ce027669fbb3134aaf6614b5d" translate="yes" xml:space="preserve">
          <source>JoinHandle::type_id</source>
          <target state="translated">JoinHandle::type_id</target>
        </trans-unit>
        <trans-unit id="abb0b2d530b1bed37c520e95e0964bc4442ee134" translate="yes" xml:space="preserve">
          <source>JoinHandleExt</source>
          <target state="translated">JoinHandleExt</target>
        </trans-unit>
        <trans-unit id="c5dafe3d3c39e51618733fd88e0def9741b4e835" translate="yes" xml:space="preserve">
          <source>JoinPathsError</source>
          <target state="translated">JoinPathsError</target>
        </trans-unit>
        <trans-unit id="dec0bd024ba9e43e73fa5ecd613a46a6513fd917" translate="yes" xml:space="preserve">
          <source>JoinPathsError::borrow</source>
          <target state="translated">JoinPathsError::borrow</target>
        </trans-unit>
        <trans-unit id="1f287d847c80825aeaa42f5ff5c4d17823d49d12" translate="yes" xml:space="preserve">
          <source>JoinPathsError::borrow_mut</source>
          <target state="translated">JoinPathsError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="823a4e0b65b65d02ed9c70bea6734955e28b7a64" translate="yes" xml:space="preserve">
          <source>JoinPathsError::cause</source>
          <target state="translated">JoinPathsError::cause</target>
        </trans-unit>
        <trans-unit id="edc1e4fdc91ad7cadf96a809927c8b059c8a1cbe" translate="yes" xml:space="preserve">
          <source>JoinPathsError::description</source>
          <target state="translated">JoinPathsError::description</target>
        </trans-unit>
        <trans-unit id="c6c91db5b7bc4a5beebd630f559897ab6b3cea42" translate="yes" xml:space="preserve">
          <source>JoinPathsError::fmt</source>
          <target state="translated">JoinPathsError::fmt</target>
        </trans-unit>
        <trans-unit id="127ef4e1b3f565f1a2bca65f9de0550244e7bc38" translate="yes" xml:space="preserve">
          <source>JoinPathsError::from</source>
          <target state="translated">JoinPathsError::from</target>
        </trans-unit>
        <trans-unit id="8a0a4301d2f110a8e8ef605ea4bf646ad3a9581c" translate="yes" xml:space="preserve">
          <source>JoinPathsError::into</source>
          <target state="translated">JoinPathsError::into</target>
        </trans-unit>
        <trans-unit id="0693ee59f808878ad8873da2ff694215418c0ee4" translate="yes" xml:space="preserve">
          <source>JoinPathsError::source</source>
          <target state="translated">JoinPathsError::source</target>
        </trans-unit>
        <trans-unit id="b148a85037443dfc7b589e93179ee679cee0e0a2" translate="yes" xml:space="preserve">
          <source>JoinPathsError::to_string</source>
          <target state="translated">JoinPathsError::to_string</target>
        </trans-unit>
        <trans-unit id="e3d928e5001d65eef527b0e798f2ed958d4242d9" translate="yes" xml:space="preserve">
          <source>JoinPathsError::try_from</source>
          <target state="translated">JoinPathsError::try_from</target>
        </trans-unit>
        <trans-unit id="e96758935a84b6c6b7f43135aee06bfbdb4c12b7" translate="yes" xml:space="preserve">
          <source>JoinPathsError::try_into</source>
          <target state="translated">JoinPathsError::try_into</target>
        </trans-unit>
        <trans-unit id="b4849b93731305d8c42c5c2a1a4688106ef4de73" translate="yes" xml:space="preserve">
          <source>JoinPathsError::type_id</source>
          <target state="translated">JoinPathsError::type_id</target>
        </trans-unit>
        <trans-unit id="97c4f7769f9c5e2f4f5b9d5caac54744e0a9f90a" translate="yes" xml:space="preserve">
          <source>Joining a path containing a colon on a Unix-like platform results in an error:</source>
          <target state="translated">Unir un camino que contiene un colon en una plataforma tipo Unix resulta en un error:</target>
        </trans-unit>
        <trans-unit id="b4466f438f59f9e3e6b0c11543857ad0cb8e936d" translate="yes" xml:space="preserve">
          <source>Joining paths on a Unix-like platform:</source>
          <target state="translated">Uniendo caminos en una plataforma tipo Unix:</target>
        </trans-unit>
        <trans-unit id="b3a56bf6b2881876f787cf53e3b3c50398570960" translate="yes" xml:space="preserve">
          <source>Joins a collection of &lt;a href=&quot;../path/struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;s appropriately for the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">Une una colecci&amp;oacute;n de &lt;a href=&quot;../path/struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; de forma&lt;/a&gt; apropiada para la &lt;code&gt;PATH&lt;/code&gt; entorno PATH .</target>
        </trans-unit>
        <trans-unit id="9058cfb3941c57451d031360b87440956e3d0576" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;cargo run&lt;/code&gt; compiles your code and then runs the resulting binary, &lt;code&gt;cargo test&lt;/code&gt; compiles your code in test mode and runs the resulting test binary. You can specify command line options to change the default behavior of &lt;code&gt;cargo test&lt;/code&gt;. For example, the default behavior of the binary produced by &lt;code&gt;cargo test&lt;/code&gt; is to run all the tests in parallel and capture output generated during test runs, preventing the output from being displayed and making it easier to read the output related to the test results.</source>
          <target state="translated">As&amp;iacute; como &lt;code&gt;cargo run&lt;/code&gt; compila su c&amp;oacute;digo y luego ejecuta el binario resultante, &lt;code&gt;cargo test&lt;/code&gt; compila su c&amp;oacute;digo en modo de prueba y ejecuta el binario de prueba resultante. Puede especificar opciones de l&amp;iacute;nea de comando para cambiar el comportamiento predeterminado de &lt;code&gt;cargo test&lt;/code&gt; de carga . Por ejemplo, el comportamiento predeterminado del binario producido por &lt;code&gt;cargo test&lt;/code&gt; es ejecutar todas las pruebas en paralelo y capturar la salida generada durante las pruebas, evitando que se muestre la salida y facilitando la lectura de la salida relacionada con los resultados de la prueba.</target>
        </trans-unit>
        <trans-unit id="001e99c6d562d4610082356bd914b66e7791c6d7" translate="yes" xml:space="preserve">
          <source>Just as variables are immutable by default, so are references. We&amp;rsquo;re not allowed to modify something we have a reference to.</source>
          <target state="translated">As&amp;iacute; como las variables son inmutables por defecto, tambi&amp;eacute;n lo son las referencias. No podemos modificar algo a lo que hagamos referencia.</target>
        </trans-unit>
        <trans-unit id="d60a8e1c1966b92263798202c5f621ad3271182f" translate="yes" xml:space="preserve">
          <source>Just as we might want to refer to a part of a string, we might want to refer to part of an array. We&amp;rsquo;d do so like this:</source>
          <target state="translated">As&amp;iacute; como podr&amp;iacute;amos querer referirnos a una parte de una cadena, podr&amp;iacute;amos querer referirnos a parte de una matriz. Lo har&amp;iacute;amos as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7ad9184de5a77f6309e9e7ededd89f40f9a37f5e" translate="yes" xml:space="preserve">
          <source>Just as with &lt;a href=&quot;external-blocks&quot;&gt;external block&lt;/a&gt;, when the &lt;code&gt;extern&lt;/code&gt; keyword is used and the &lt;code&gt;&quot;ABI&lt;/code&gt; is omitted, the ABI used defaults to &lt;code&gt;&quot;C&quot;&lt;/code&gt;. That is, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cd0c38914e4f9de946957888fda12a2aef698c" translate="yes" xml:space="preserve">
          <source>Just because a function contains unsafe code doesn&amp;rsquo;t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let&amp;rsquo;s study a function from the standard library, &lt;code&gt;split_at_mut&lt;/code&gt;, that requires some unsafe code and explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use &lt;code&gt;split_at_mut&lt;/code&gt;.</source>
          <target state="translated">El hecho de que una funci&amp;oacute;n contenga c&amp;oacute;digo inseguro no significa que debamos marcar toda la funci&amp;oacute;n como insegura. De hecho, envolver c&amp;oacute;digo inseguro en una funci&amp;oacute;n segura es una abstracci&amp;oacute;n com&amp;uacute;n. Como ejemplo, estudiemos una funci&amp;oacute;n de la biblioteca est&amp;aacute;ndar, &lt;code&gt;split_at_mut&lt;/code&gt; , que requiere c&amp;oacute;digo inseguro y exploremos c&amp;oacute;mo podr&amp;iacute;amos implementarlo. Este m&amp;eacute;todo seguro se define en porciones mutables: toma una porci&amp;oacute;n y la convierte en dos dividiendo la porci&amp;oacute;n en el &amp;iacute;ndice dado como argumento. El Listado 19-4 muestra c&amp;oacute;mo usar &lt;code&gt;split_at_mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687163feff04cea4e68067b5a858f533ad06e05e" translate="yes" xml:space="preserve">
          <source>Just compiling with &lt;code&gt;rustc&lt;/code&gt; is fine for simple programs, but as your project grows, you&amp;rsquo;ll want to manage all the options and make it easy to share your code. Next, we&amp;rsquo;ll introduce you to the Cargo tool, which will help you write real-world Rust programs.</source>
          <target state="translated">Simplemente compilar con &lt;code&gt;rustc&lt;/code&gt; est&amp;aacute; bien para programas simples, pero a medida que su proyecto crezca, querr&amp;aacute; administrar todas las opciones y facilitar el intercambio de su c&amp;oacute;digo. A continuaci&amp;oacute;n, le presentaremos la herramienta Cargo, que le ayudar&amp;aacute; a escribir programas de Rust del mundo real.</target>
        </trans-unit>
        <trans-unit id="edf4d5cc727a6c57ca685432668f892eb6c7cbd1" translate="yes" xml:space="preserve">
          <source>Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a &lt;code&gt;read_volatile&lt;/code&gt; and any write operation to the same location is undefined behavior.</source>
          <target state="translated">Al igual que en C, el hecho de que una operaci&amp;oacute;n sea vol&amp;aacute;til no influye en absoluto en cuestiones relacionadas con el acceso simult&amp;aacute;neo desde varios subprocesos. Los accesos vol&amp;aacute;tiles se comportan exactamente como los accesos no at&amp;oacute;micos en ese sentido. En particular, una carrera entre un &lt;code&gt;read_volatile&lt;/code&gt; y cualquier operaci&amp;oacute;n de escritura en la misma ubicaci&amp;oacute;n es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="317bc7ae9f1ea2d73138794a7e1fffbd3badd2f1" translate="yes" xml:space="preserve">
          <source>Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a &lt;code&gt;write_volatile&lt;/code&gt; and any other operation (reading or writing) on the same location is undefined behavior.</source>
          <target state="translated">Al igual que en C, el hecho de que una operaci&amp;oacute;n sea vol&amp;aacute;til no influye en absoluto en cuestiones relacionadas con el acceso simult&amp;aacute;neo desde varios subprocesos. Los accesos vol&amp;aacute;tiles se comportan exactamente como los accesos no at&amp;oacute;micos en ese sentido. En particular, una carrera entre un &lt;code&gt;write_volatile&lt;/code&gt; y cualquier otra operaci&amp;oacute;n (lectura o escritura) en la misma ubicaci&amp;oacute;n es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="4e495fa1d1e849a4610409f46ad4ee2226bcc303" translate="yes" xml:space="preserve">
          <source>Just like static functions, associated constants aren't stored on the method table. If the trait or any subtrait contain an associated constant, they cannot be made into an object.</source>
          <target state="translated">Al igual que las funciones estáticas,las constantes asociadas no se almacenan en la tabla de métodos.Si el rasgo o cualquier subrasgo contienen una constante asociada,no pueden convertirse en un objeto.</target>
        </trans-unit>
        <trans-unit id="f8bf7b98f101ed3ceab4b0a28bb6ad41d9542aea" translate="yes" xml:space="preserve">
          <source>Just like vectors, hash maps store their data on the heap. This &lt;code&gt;HashMap&lt;/code&gt; has keys of type &lt;code&gt;String&lt;/code&gt; and values of type &lt;code&gt;i32&lt;/code&gt;. Like vectors, hash maps are homogeneous: all of the keys must have the same type, and all of the values must have the same type.</source>
          <target state="translated">Al igual que los vectores, los mapas hash almacenan sus datos en el mont&amp;oacute;n. Este &lt;code&gt;HashMap&lt;/code&gt; tiene claves de tipo &lt;code&gt;String&lt;/code&gt; y valores de tipo &lt;code&gt;i32&lt;/code&gt; . Al igual que los vectores, los mapas hash son homog&amp;eacute;neos: todas las claves deben tener el mismo tipo y todos los valores deben tener el mismo tipo.</target>
        </trans-unit>
        <trans-unit id="f4b3ade3597f2a53cd73a47fd91e8d89c9f37a8f" translate="yes" xml:space="preserve">
          <source>Just like you cannot have both &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; representation hints on a same type, a &lt;code&gt;packed&lt;/code&gt; type cannot contain another type with the &lt;code&gt;align&lt;/code&gt; representation hint. However, you can do the opposite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad38c597b8238e8c5ffff5cb9392234534096181" translate="yes" xml:space="preserve">
          <source>KW_ABSTRACT : &lt;code&gt;abstract&lt;/code&gt;</source>
          <target state="translated">KW_ABSTRACT: &lt;code&gt;abstract&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be90ce625c319a7fdfb58a43e5bc5c5d9b71f25a" translate="yes" xml:space="preserve">
          <source>KW_AS : &lt;code&gt;as&lt;/code&gt;</source>
          <target state="translated">KW_AS: &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0173c787da7a615493ad8d7a2cb0a37333dc413" translate="yes" xml:space="preserve">
          <source>KW_ASYNC : &lt;code&gt;async&lt;/code&gt;</source>
          <target state="translated">KW_ASYNC: &lt;code&gt;async&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48849139f33d9b0b0e09242876428fca2f3b32a0" translate="yes" xml:space="preserve">
          <source>KW_AWAIT : &lt;code&gt;await&lt;/code&gt;</source>
          <target state="translated">KW_AWAIT: &lt;code&gt;await&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="faeff081e9c7bb1476ef0597e5745e683e9089ac" translate="yes" xml:space="preserve">
          <source>KW_BECOME : &lt;code&gt;become&lt;/code&gt;</source>
          <target state="translated">KW_BECOME: &lt;code&gt;become&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb5b5f47578617a58162739554c68db1988e5f19" translate="yes" xml:space="preserve">
          <source>KW_BOX : &lt;code&gt;box&lt;/code&gt;</source>
          <target state="translated">KW_BOX: &lt;code&gt;box&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="789f5a93cd563740436ffcc55aa832d91d39e504" translate="yes" xml:space="preserve">
          <source>KW_BREAK : &lt;code&gt;break&lt;/code&gt;</source>
          <target state="translated">KW_BREAK: &lt;code&gt;break&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="646ebf0a8faa491f908a99b63b433e9b938d1d0d" translate="yes" xml:space="preserve">
          <source>KW_CONST : &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">KW_CONST: &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3b44085f94ca57ca2f334704a2a2c477986387b" translate="yes" xml:space="preserve">
          <source>KW_CONTINUE : &lt;code&gt;continue&lt;/code&gt;</source>
          <target state="translated">KW_CONTINUE: &lt;code&gt;continue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e94a62fd0360430796d17226621f22aabfdbae9" translate="yes" xml:space="preserve">
          <source>KW_CRATE : &lt;code&gt;crate&lt;/code&gt;</source>
          <target state="translated">KW_CRATE: &lt;code&gt;crate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e516b0f9399c34f538fa08c26037ff452464083" translate="yes" xml:space="preserve">
          <source>KW_DO : &lt;code&gt;do&lt;/code&gt;</source>
          <target state="translated">KW_DO: &lt;code&gt;do&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a55ecfee6ea0809448ea6f5c0847e66b961b8869" translate="yes" xml:space="preserve">
          <source>KW_DYN : &lt;code&gt;dyn&lt;/code&gt;</source>
          <target state="translated">KW_DYN: &lt;code&gt;dyn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43bd7725cfebb3448607c8a4f8fa78700ac6e981" translate="yes" xml:space="preserve">
          <source>KW_ELSE : &lt;code&gt;else&lt;/code&gt;</source>
          <target state="translated">KW_ELSE: &lt;code&gt;else&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5b15ab165b8a37f5ca1b5c6cb8b552b4b74656" translate="yes" xml:space="preserve">
          <source>KW_ENUM : &lt;code&gt;enum&lt;/code&gt;</source>
          <target state="translated">KW_ENUM: &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="f0ab52e66c553f670a2e4b9deb4214bb9187af23" translate="yes" xml:space="preserve">
          <source>KW_EXTERN : &lt;code&gt;extern&lt;/code&gt;</source>
          <target state="translated">KW_EXTERN: &lt;code&gt;extern&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a82d8ca4b2bfb3195b34b23742e5f65175a92d0" translate="yes" xml:space="preserve">
          <source>KW_FALSE : &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">KW_FALSE: &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c805a2e97aa19bcae5903d9a457908adfeea3d5" translate="yes" xml:space="preserve">
          <source>KW_FINAL : &lt;code&gt;final&lt;/code&gt;</source>
          <target state="translated">KW_FINAL: &lt;code&gt;final&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a1dbe403904f42293db37c4c0873bfb1846c985" translate="yes" xml:space="preserve">
          <source>KW_FN : &lt;code&gt;fn&lt;/code&gt;</source>
          <target state="translated">KW_FN: &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51804441d72df4f1c2711281dfd36ba09d409775" translate="yes" xml:space="preserve">
          <source>KW_FOR : &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">KW_FOR: &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ae9f72e482e9a846d12338bb40fabc6e91c7824" translate="yes" xml:space="preserve">
          <source>KW_IF : &lt;code&gt;if&lt;/code&gt;</source>
          <target state="translated">KW_IF: &lt;code&gt;if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a367c162e2fe29dc4e94c96cbfc7218815660b1" translate="yes" xml:space="preserve">
          <source>KW_IF, INTEGER_LITERAL</source>
          <target state="translated">KW_IF,INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="73fa9c35080f85eae254306fc02ef20b3a0228db" translate="yes" xml:space="preserve">
          <source>KW_IMPL : &lt;code&gt;impl&lt;/code&gt;</source>
          <target state="translated">KW_IMPL: &lt;code&gt;impl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59c563aec15dd074ead40cd8d2c65822bdb4fef2" translate="yes" xml:space="preserve">
          <source>KW_IN : &lt;code&gt;in&lt;/code&gt;</source>
          <target state="translated">KW_IN: &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10df35e646555ba6a73e442c5fb68654f251460" translate="yes" xml:space="preserve">
          <source>KW_LET : &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">KW_LET: &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc99c61ef358b05bbd7856a61981d75499ebec" translate="yes" xml:space="preserve">
          <source>KW_LOOP : &lt;code&gt;loop&lt;/code&gt;</source>
          <target state="translated">KW_LOOP: &lt;code&gt;loop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf074b1962cc7aeed758b10c5e770f59576a496d" translate="yes" xml:space="preserve">
          <source>KW_MACRO : &lt;code&gt;macro&lt;/code&gt;</source>
          <target state="translated">KW_MACRO: &lt;code&gt;macro&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21616e3fdd9348e77ec41feb87c87238b3f4e26c" translate="yes" xml:space="preserve">
          <source>KW_MATCH : &lt;code&gt;match&lt;/code&gt;</source>
          <target state="translated">KW_MATCH: &lt;code&gt;match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cacbc1424997c4e31784ec865a9cf0e227d1f331" translate="yes" xml:space="preserve">
          <source>KW_MOD : &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">KW_MOD: &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c49906f1ece7b2086399766a4ebb775592dce9" translate="yes" xml:space="preserve">
          <source>KW_MOVE : &lt;code&gt;move&lt;/code&gt;</source>
          <target state="translated">KW_MOVE: &lt;code&gt;move&lt;/code&gt; r</target>
        </trans-unit>
        <trans-unit id="e93813d5f885df35d1d34208741cb14417dd32b9" translate="yes" xml:space="preserve">
          <source>KW_MUT : &lt;code&gt;mut&lt;/code&gt;</source>
          <target state="translated">KW_MUT: &lt;code&gt;mut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="986112403ae83ef4c659145d144f9037283438f0" translate="yes" xml:space="preserve">
          <source>KW_OVERRIDE : &lt;code&gt;override&lt;/code&gt;</source>
          <target state="translated">KW_OVERRIDE: &lt;code&gt;override&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="096b897ed7d5ae1c63992283c83f6e0f9013d7f0" translate="yes" xml:space="preserve">
          <source>KW_PRIV : &lt;code&gt;priv&lt;/code&gt;</source>
          <target state="translated">KW_PRIV: &lt;code&gt;priv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f48e0064a9cb22ae594e388e4915e7d88ce3349c" translate="yes" xml:space="preserve">
          <source>KW_PUB : &lt;code&gt;pub&lt;/code&gt;</source>
          <target state="translated">KW_PUB: &lt;code&gt;pub&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf55b9ade912097bcab3d0fc356bd22943c572" translate="yes" xml:space="preserve">
          <source>KW_REF : &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="translated">KW_REF: &lt;code&gt;ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4aa1bbded52171e54febc09f265f40e1c0be60b" translate="yes" xml:space="preserve">
          <source>KW_RETURN : &lt;code&gt;return&lt;/code&gt;</source>
          <target state="translated">KW_RETURN: &lt;code&gt;return&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb8c1f081587b4145c8d20e256de8a57807802c8" translate="yes" xml:space="preserve">
          <source>KW_SELFTYPE : &lt;code&gt;Self&lt;/code&gt;</source>
          <target state="translated">KW_SELFTYPE: &lt;code&gt;Self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589c3916c9b199922a8c5503d2f10a38cd602f6d" translate="yes" xml:space="preserve">
          <source>KW_SELFVALUE : &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">KW_SELFVALUE: &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e97f068c91e52b8ee0bf7536b78346905ff65084" translate="yes" xml:space="preserve">
          <source>KW_STATIC : &lt;code&gt;static&lt;/code&gt;</source>
          <target state="translated">KW_STATIC: &lt;code&gt;static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f4b78faf33e54502b143b3311dfbbea495dd79" translate="yes" xml:space="preserve">
          <source>KW_STATICLIFETIME : &lt;code&gt;'static&lt;/code&gt;</source>
          <target state="translated">KW_STATICLIFETIME: &lt;code&gt;'static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96f670f49f58217687c9c79e68cbb2ce6b233631" translate="yes" xml:space="preserve">
          <source>KW_STRUCT : &lt;code&gt;struct&lt;/code&gt;</source>
          <target state="translated">KW_STRUCT: &lt;code&gt;struct&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb41d3d257888d3ae68c1492a043887998f5646e" translate="yes" xml:space="preserve">
          <source>KW_SUPER : &lt;code&gt;super&lt;/code&gt;</source>
          <target state="translated">KW_SUPER: &lt;code&gt;super&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d62ea6cea231ded0372e49c12635b034d685a2" translate="yes" xml:space="preserve">
          <source>KW_TRAIT : &lt;code&gt;trait&lt;/code&gt;</source>
          <target state="translated">KW_TRAIT: &lt;code&gt;trait&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2436e51574011f63df503ea8e052114e32b38421" translate="yes" xml:space="preserve">
          <source>KW_TRUE : &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">KW_TRUE: &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33857bab7317b38e930f6e043274e294dfdb0837" translate="yes" xml:space="preserve">
          <source>KW_TRY : &lt;code&gt;try&lt;/code&gt;</source>
          <target state="translated">KW_TRY: &lt;code&gt;try&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b98be3594c838969fbf8e804a3b83125cd8f9164" translate="yes" xml:space="preserve">
          <source>KW_TYPE : &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">KW_TYPE: &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f90893de8264f12555e264daf55d8d3573f648a" translate="yes" xml:space="preserve">
          <source>KW_TYPEOF : &lt;code&gt;typeof&lt;/code&gt;</source>
          <target state="translated">KW_TYPEOF: &lt;code&gt;typeof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="810b6331cc472782bf330b62c25e7caade19a83a" translate="yes" xml:space="preserve">
          <source>KW_UNION : &lt;code&gt;union&lt;/code&gt;</source>
          <target state="translated">KW_UNION: &lt;code&gt;union&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8c046c3fefb22d66beea883f5fe4ae12ff703c3" translate="yes" xml:space="preserve">
          <source>KW_UNSAFE : &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">KW_UNSAFE: &lt;code&gt;unsafe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a504e9e9c867afd9ae5cd6865e04fd6708c18c" translate="yes" xml:space="preserve">
          <source>KW_UNSIZED : &lt;code&gt;unsized&lt;/code&gt;</source>
          <target state="translated">KW_UNSIZED: &lt;code&gt;unsized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a42f6264915b56a563a35b937d40ee2b1092d828" translate="yes" xml:space="preserve">
          <source>KW_USE : &lt;code&gt;use&lt;/code&gt;</source>
          <target state="translated">KW_USE: &lt;code&gt;use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0164d2f9ee89b4ff7027682d51a2a239aa74f90" translate="yes" xml:space="preserve">
          <source>KW_VIRTUAL : &lt;code&gt;virtual&lt;/code&gt;</source>
          <target state="translated">KW_VIRTUAL: &lt;code&gt;virtual&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddbe1f7c29b3f7210557405db5ed34966c662d08" translate="yes" xml:space="preserve">
          <source>KW_WHERE : &lt;code&gt;where&lt;/code&gt;</source>
          <target state="translated">KW_WHERE: &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c9dfcdf6820da0b224753fce346422cdc8d7ae5" translate="yes" xml:space="preserve">
          <source>KW_WHILE : &lt;code&gt;while&lt;/code&gt;</source>
          <target state="translated">KW_WHILE: &lt;code&gt;while&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98333a752caf854e21271745fd6749b9c1d1a7d1" translate="yes" xml:space="preserve">
          <source>KW_YIELD : &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">KW_YIELD: &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0691b0c7d3cefeeeae3a2289278f41bd8c7c1e6f" translate="yes" xml:space="preserve">
          <source>Keep a global count of live threads:</source>
          <target state="translated">Lleve un recuento global de los hilos vivos:</target>
        </trans-unit>
        <trans-unit id="d2d8fe2c08e017878e56af189be768b49b58a3e4" translate="yes" xml:space="preserve">
          <source>Keep in mind that Rust is a &lt;em&gt;statically typed&lt;/em&gt; language, which means that it must know the types of all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it. In cases when many types are possible, such as when we converted a &lt;code&gt;String&lt;/code&gt; to a numeric type using &lt;code&gt;parse&lt;/code&gt; in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we must add a type annotation, like this:</source>
          <target state="translated">Tenga en cuenta que Rust es un &lt;em&gt;lenguaje de tipo est&amp;aacute;tico&lt;/em&gt; , lo que significa que debe conocer los tipos de todas las variables en el momento de la compilaci&amp;oacute;n. El compilador generalmente puede inferir qu&amp;eacute; tipo queremos usar en funci&amp;oacute;n del valor y c&amp;oacute;mo lo usamos. En los casos en los que son posibles muchos tipos, como cuando convertimos una &lt;code&gt;String&lt;/code&gt; en un tipo num&amp;eacute;rico usando el &lt;code&gt;parse&lt;/code&gt; en la secci&amp;oacute;n &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;Comparaci&amp;oacute;n de la suposici&amp;oacute;n con el n&amp;uacute;mero secreto&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 2, debemos agregar una anotaci&amp;oacute;n de tipo, como esta:</target>
        </trans-unit>
        <trans-unit id="52e9fac3044bab3714b6ee55ecb852540b800b38" translate="yes" xml:space="preserve">
          <source>Keeping Track of Borrows at Runtime with &lt;code id=&quot;keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Seguimiento de los pr&amp;eacute;stamos en tiempo de ejecuci&amp;oacute;n con &lt;code id=&quot;keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3ebbc3717ea52d0fdffcb979b6a75601bc35c26" translate="yes" xml:space="preserve">
          <source>Keeping a crate&amp;rsquo;s functionality in its own scope clarifies whether particular functionality is defined in our crate or the &lt;code&gt;rand&lt;/code&gt; crate and prevents potential conflicts. For example, the &lt;code&gt;rand&lt;/code&gt; crate provides a trait named &lt;code&gt;Rng&lt;/code&gt;. We can also define a &lt;code&gt;struct&lt;/code&gt; named &lt;code&gt;Rng&lt;/code&gt; in our own crate. Because a crate&amp;rsquo;s functionality is namespaced in its own scope, when we add &lt;code&gt;rand&lt;/code&gt; as a dependency, the compiler isn&amp;rsquo;t confused about what the name &lt;code&gt;Rng&lt;/code&gt; refers to. In our crate, it refers to the &lt;code&gt;struct Rng&lt;/code&gt; that we defined. We would access the &lt;code&gt;Rng&lt;/code&gt; trait from the &lt;code&gt;rand&lt;/code&gt; crate as &lt;code&gt;rand::Rng&lt;/code&gt;.</source>
          <target state="translated">Mantener la funcionalidad de una caja en su propio alcance aclara si una funcionalidad particular est&amp;aacute; definida en nuestra caja o en la caja &lt;code&gt;rand&lt;/code&gt; y evita posibles conflictos. Por ejemplo, la caja &lt;code&gt;rand&lt;/code&gt; proporciona un rasgo llamado &lt;code&gt;Rng&lt;/code&gt; . Tambi&amp;eacute;n podemos definir una &lt;code&gt;struct&lt;/code&gt; llamada &lt;code&gt;Rng&lt;/code&gt; en nuestra propia caja. Debido a que la funcionalidad de una caja tiene un espacio de nombres en su propio alcance, cuando agregamos &lt;code&gt;rand&lt;/code&gt; como una dependencia, el compilador no se confunde sobre a qu&amp;eacute; se refiere el nombre &lt;code&gt;Rng&lt;/code&gt; . En nuestra caja, se refiere a la &lt;code&gt;struct Rng&lt;/code&gt; que definimos. Nos acceder al &lt;code&gt;Rng&lt;/code&gt; rasgo del &lt;code&gt;rand&lt;/code&gt; caj&amp;oacute;n como &lt;code&gt;rand::Rng&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9f12e803a098c99995539cb42f36c9f9739f97e" translate="yes" xml:space="preserve">
          <source>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don&amp;rsquo;t run out of space are all problems that ownership addresses. Once you understand ownership, you won&amp;rsquo;t need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.</source>
          <target state="translated">Hacer un seguimiento de qu&amp;eacute; partes del c&amp;oacute;digo est&amp;aacute;n usando qu&amp;eacute; datos en el mont&amp;oacute;n, minimizar la cantidad de datos duplicados en el mont&amp;oacute;n y limpiar los datos no utilizados en el mont&amp;oacute;n para que no se quede sin espacio son todos problemas que la propiedad aborda. Una vez que comprenda la propiedad, no tendr&amp;aacute; que pensar en la pila y el mont&amp;oacute;n con mucha frecuencia, pero saber que la gesti&amp;oacute;n de los datos del mont&amp;oacute;n es la raz&amp;oacute;n por la que existe la propiedad puede ayudar a explicar por qu&amp;eacute; funciona de la manera en que lo hace.</target>
        </trans-unit>
        <trans-unit id="cd35d612a134cd358cb5ad1ce1e9e74301067e1d" translate="yes" xml:space="preserve">
          <source>Key-value option set at most once with the target's operating system value.</source>
          <target state="translated">Opción de valor clave establecida como máximo una vez con el valor del sistema operativo del objetivo.</target>
        </trans-unit>
        <trans-unit id="ce96f30fb0633a0de5217c6ddf2318f94830e44b" translate="yes" xml:space="preserve">
          <source>Key-value option set for each platform feature available for the current compilation target.</source>
          <target state="translated">Opción de valor clave establecida para cada característica de la plataforma disponible para el objetivo de compilación actual.</target>
        </trans-unit>
        <trans-unit id="ce9ea81e67f13ab1e763fa87e4c0b2168fc63774" translate="yes" xml:space="preserve">
          <source>Key-value option set once with either a value of &quot;little&quot; or &quot;big&quot; depending on the endianness of the target's CPU.</source>
          <target state="translated">La opción de valor clave se establece una vez con un valor de &quot;pequeño&quot; o &quot;grande&quot;,dependiendo de la capacidad de la CPU del objetivo.</target>
        </trans-unit>
        <trans-unit id="63e95325de8c37181511cb94e0cd4096c6b7d2ef" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's CPU architecture. The value is similar to the first element of the platform's target triple, but not identical.</source>
          <target state="translated">Opción de valor clave establecida una vez con la arquitectura de la CPU del objetivo.El valor es similar al primer elemento del triple del objetivo de la plataforma,pero no idéntico.</target>
        </trans-unit>
        <trans-unit id="9f535aa6f58b910aacefadf78335cfd96c455f70" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's operating system. This value is similar to the second and third element of the platform's target triple.</source>
          <target state="translated">Opción de valor clave establecida una vez con el sistema operativo del objetivo.Este valor es similar al segundo y tercer elemento del triple del objetivo de la plataforma.</target>
        </trans-unit>
        <trans-unit id="21bb65083a0c78de1363d38fcb64deec6c2f621f" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's pointer width in bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ebc4327b545eab4c13648ab9805f30fdc72faa" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's pointer width in bits. For example, for targets with 32-bit pointers, this is set to &lt;code&gt;&quot;32&quot;&lt;/code&gt;. Likewise, it is set to &lt;code&gt;&quot;64&quot;&lt;/code&gt; for targets with 64-bit pointers.</source>
          <target state="translated">La opci&amp;oacute;n de valor-clave se establece una vez con el ancho del puntero del objetivo en bits. Por ejemplo, para destinos con punteros de 32 bits, se establece en &lt;code&gt;&quot;32&quot;&lt;/code&gt; . Asimismo, se establece en &lt;code&gt;&quot;64&quot;&lt;/code&gt; para destinos con punteros de 64 bits.</target>
        </trans-unit>
        <trans-unit id="919823df75a839f68908ab4a52f685cce0bc3afd" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the vendor of the target.</source>
          <target state="translated">Opción de valor clave establecida una vez con el vendedor del objetivo.</target>
        </trans-unit>
        <trans-unit id="11da1ff3fc87f22cc67c02cf8eb624f317fde1c5" translate="yes" xml:space="preserve">
          <source>Key-value option set with further disambiguating information about the target platform with information about the ABI or &lt;code&gt;libc&lt;/code&gt; used. For historical reasons, this value is only defined as not the empty-string when actually needed for disambiguation. Thus, for example, on many GNU platforms, this value will be empty. This value is similar to the fourth element of the platform's target triple. One difference is that embedded ABIs such as &lt;code&gt;gnueabihf&lt;/code&gt; will simply define &lt;code&gt;target_env&lt;/code&gt; as &lt;code&gt;&quot;gnu&quot;&lt;/code&gt;.</source>
          <target state="translated">Conjunto de opciones de clave-valor con informaci&amp;oacute;n adicional para eliminar ambig&amp;uuml;edades sobre la plataforma de destino con informaci&amp;oacute;n sobre la ABI o &lt;code&gt;libc&lt;/code&gt; utilizada. Por razones hist&amp;oacute;ricas, este valor solo se define como no la cadena vac&amp;iacute;a cuando realmente se necesita para la desambiguaci&amp;oacute;n. As&amp;iacute;, por ejemplo, en muchas plataformas GNU, este valor estar&amp;aacute; vac&amp;iacute;o. Este valor es similar al cuarto elemento del triple objetivo de la plataforma. Una diferencia es que las &lt;code&gt;gnueabihf&lt;/code&gt; integradas como gnueabihf simplemente definir&amp;aacute;n &lt;code&gt;target_env&lt;/code&gt; como &lt;code&gt;&quot;gnu&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="8f31576d96d60f0abebc904da3b4f2881c89ac5a" translate="yes" xml:space="preserve">
          <source>Keys are not unique in the set of key-value configuration options. For example, both &lt;code&gt;feature = &quot;std&quot;&lt;/code&gt; and &lt;code&gt;feature = &quot;serde&quot;&lt;/code&gt; can be set at the same time.</source>
          <target state="translated">Las claves no son &amp;uacute;nicas en el conjunto de opciones de configuraci&amp;oacute;n de clave-valor. Por ejemplo, &lt;code&gt;feature = &quot;std&quot;&lt;/code&gt; y &lt;code&gt;feature = &quot;serde&quot;&lt;/code&gt; se pueden configurar al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="6fe4683b112b96ba7631fcdc86fabb26bd695c7d" translate="yes" xml:space="preserve">
          <source>Keyword Self</source>
          <target state="translated">La palabra clave &quot;Yo&quot;...</target>
        </trans-unit>
        <trans-unit id="7a05409abe457818d06a7b2a827d071925e3123d" translate="yes" xml:space="preserve">
          <source>Keyword as</source>
          <target state="translated">La palabra clave como</target>
        </trans-unit>
        <trans-unit id="111297ecda21e09bfe2a8317450e29b120adfb90" translate="yes" xml:space="preserve">
          <source>Keyword async</source>
          <target state="translated">Palabra clave async</target>
        </trans-unit>
        <trans-unit id="2b96f62624a68fd871d5766ca2fa2145d4644a70" translate="yes" xml:space="preserve">
          <source>Keyword await</source>
          <target state="translated">La palabra clave espera</target>
        </trans-unit>
        <trans-unit id="f6c6e1b25bec0a5a14bc88afab261e9a04ec9707" translate="yes" xml:space="preserve">
          <source>Keyword break</source>
          <target state="translated">Romper la palabra clave...</target>
        </trans-unit>
        <trans-unit id="436846eb0b7f7b9748553b55f55233f3a2e1b42b" translate="yes" xml:space="preserve">
          <source>Keyword const</source>
          <target state="translated">La palabra clave const</target>
        </trans-unit>
        <trans-unit id="2a3920d65d1221a1de8f19c31f0add5d8fc541dd" translate="yes" xml:space="preserve">
          <source>Keyword continue</source>
          <target state="translated">La palabra clave continúa</target>
        </trans-unit>
        <trans-unit id="9eb24d787290917c89c3e8b0eb98d952c8cdf70d" translate="yes" xml:space="preserve">
          <source>Keyword crate</source>
          <target state="translated">Caja de palabras clave</target>
        </trans-unit>
        <trans-unit id="9274e1d61951bc25e37abafb1a71c5c41800be68" translate="yes" xml:space="preserve">
          <source>Keyword dyn</source>
          <target state="translated">La palabra clave dyn</target>
        </trans-unit>
        <trans-unit id="377e304b2d1e85347b20ff335b6d99538e6c187b" translate="yes" xml:space="preserve">
          <source>Keyword else</source>
          <target state="translated">Palabra clave más</target>
        </trans-unit>
        <trans-unit id="7aba16f0afd468040716e09c2ae6718f272a6458" translate="yes" xml:space="preserve">
          <source>Keyword enum</source>
          <target state="translated">La palabra clave enum</target>
        </trans-unit>
        <trans-unit id="497cef40287ff8c1a00ccb47de8f855e132be344" translate="yes" xml:space="preserve">
          <source>Keyword extern</source>
          <target state="translated">Palabra clave externa</target>
        </trans-unit>
        <trans-unit id="2a6e421aa23f1681fcb97ab460fe75051a3e013b" translate="yes" xml:space="preserve">
          <source>Keyword false</source>
          <target state="translated">La palabra clave es falsa</target>
        </trans-unit>
        <trans-unit id="ad325f8a9f86ad3293235a282313ef21d8bfd594" translate="yes" xml:space="preserve">
          <source>Keyword fn</source>
          <target state="translated">Palabra clave fn</target>
        </trans-unit>
        <trans-unit id="a25477170e21ac7e2572a740282b4353f075bcfe" translate="yes" xml:space="preserve">
          <source>Keyword for</source>
          <target state="translated">Palabra clave para</target>
        </trans-unit>
        <trans-unit id="aa09921301016318d19919d413f46e0991eaa034" translate="yes" xml:space="preserve">
          <source>Keyword if</source>
          <target state="translated">La palabra clave si</target>
        </trans-unit>
        <trans-unit id="70d230cf570b8b6b9e41e2c04e4b1eecd566cc1c" translate="yes" xml:space="preserve">
          <source>Keyword impl</source>
          <target state="translated">La palabra clave impl</target>
        </trans-unit>
        <trans-unit id="1d1b8618ebc37a044f2789a54f15fcc89bca4b48" translate="yes" xml:space="preserve">
          <source>Keyword in</source>
          <target state="translated">Palabra clave en</target>
        </trans-unit>
        <trans-unit id="e45321f53ba7f20aaa2734b8d92fce994255c877" translate="yes" xml:space="preserve">
          <source>Keyword let</source>
          <target state="translated">La palabra clave es &quot;dejar&quot;...</target>
        </trans-unit>
        <trans-unit id="b17d0119a3acf3683a3f63c42ae8a1a62b0f2bec" translate="yes" xml:space="preserve">
          <source>Keyword loop</source>
          <target state="translated">Bucle de palabras clave</target>
        </trans-unit>
        <trans-unit id="08770e678060c19974b3fc3b3f50ffe441004b2d" translate="yes" xml:space="preserve">
          <source>Keyword match</source>
          <target state="translated">La palabra clave coincide con</target>
        </trans-unit>
        <trans-unit id="eb89d3478115288bccdf47fcaee875e6e9dec53b" translate="yes" xml:space="preserve">
          <source>Keyword mod</source>
          <target state="translated">Palabra clave mod</target>
        </trans-unit>
        <trans-unit id="5fcfe7efe61a879544f9458d60ef298a6eae68ef" translate="yes" xml:space="preserve">
          <source>Keyword move</source>
          <target state="translated">Movimiento de la palabra clave</target>
        </trans-unit>
        <trans-unit id="e8f403359a67fdeb4f9a69ff28eebe446a15425c" translate="yes" xml:space="preserve">
          <source>Keyword mut</source>
          <target state="translated">Palabra clave mut</target>
        </trans-unit>
        <trans-unit id="5aad2726454c0cfe99c64b86b5506fbc780aba60" translate="yes" xml:space="preserve">
          <source>Keyword pub</source>
          <target state="translated">Palabra clave pub</target>
        </trans-unit>
        <trans-unit id="fd01e715bc85516f46378428fd84c2baadd44546" translate="yes" xml:space="preserve">
          <source>Keyword ref</source>
          <target state="translated">Palabra clave ref.</target>
        </trans-unit>
        <trans-unit id="0d24ace1f65b53c2f9e03ed8271b08e7fc77ee6d" translate="yes" xml:space="preserve">
          <source>Keyword return</source>
          <target state="translated">La palabra clave &quot;return&quot;...</target>
        </trans-unit>
        <trans-unit id="17548e2276001357bd22942d19f5cb00544567f5" translate="yes" xml:space="preserve">
          <source>Keyword static</source>
          <target state="translated">La palabra clave estática</target>
        </trans-unit>
        <trans-unit id="05f8b04e053f5e1b453e9b0b93670f8ffca49cf9" translate="yes" xml:space="preserve">
          <source>Keyword struct</source>
          <target state="translated">Estructura de la palabra clave</target>
        </trans-unit>
        <trans-unit id="c230764a5d99ee580877e7cde563c5c1768ec51f" translate="yes" xml:space="preserve">
          <source>Keyword super</source>
          <target state="translated">La palabra clave super</target>
        </trans-unit>
        <trans-unit id="48effa325ed166316a6e508bc8da17af9983e809" translate="yes" xml:space="preserve">
          <source>Keyword trait</source>
          <target state="translated">Rasgo de la palabra clave</target>
        </trans-unit>
        <trans-unit id="3092260b25ab0be886a76ed515be7af36594b34e" translate="yes" xml:space="preserve">
          <source>Keyword true</source>
          <target state="translated">La palabra clave &quot;verdadero&quot;...</target>
        </trans-unit>
        <trans-unit id="48b8acd5cc92e931fbcf08f4564de6254a3688f3" translate="yes" xml:space="preserve">
          <source>Keyword type</source>
          <target state="translated">Tipo de palabra clave</target>
        </trans-unit>
        <trans-unit id="df96c1b537e86440f56db5003c98baa08726505b" translate="yes" xml:space="preserve">
          <source>Keyword union</source>
          <target state="translated">Unión de palabras clave</target>
        </trans-unit>
        <trans-unit id="16040d77331d2a3b59872c42f67d3f8a96b1c3dd" translate="yes" xml:space="preserve">
          <source>Keyword unsafe</source>
          <target state="translated">Palabra clave insegura</target>
        </trans-unit>
        <trans-unit id="f29c9f829c3c510995b3f7cdf3202a3d7c402a35" translate="yes" xml:space="preserve">
          <source>Keyword use</source>
          <target state="translated">Uso de palabras clave</target>
        </trans-unit>
        <trans-unit id="fe4e85de0c4f74847bd8e598f60609044af0ee40" translate="yes" xml:space="preserve">
          <source>Keyword where</source>
          <target state="translated">La palabra clave donde</target>
        </trans-unit>
        <trans-unit id="7d7b00f33afab4f85be61beaf96d76b0462792b9" translate="yes" xml:space="preserve">
          <source>Keyword while</source>
          <target state="translated">La palabra clave mientras</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e3640301ed0023ff94e08911cc76aa75eb8d7a5e" translate="yes" xml:space="preserve">
          <source>Keywords Currently in Use</source>
          <target state="translated">Palabras clave actualmente en uso</target>
        </trans-unit>
        <trans-unit id="8a1e43b45921c00d897b3f014078137489061012" translate="yes" xml:space="preserve">
          <source>Keywords Reserved for Future Use</source>
          <target state="translated">Palabras clave reservadas para uso futuro</target>
        </trans-unit>
        <trans-unit id="8894c6a0dbced6c16c0d9df706a39a96c0879833" translate="yes" xml:space="preserve">
          <source>Knowing that you can take slices of literals and &lt;code&gt;String&lt;/code&gt; values leads us to one more improvement on &lt;code&gt;first_word&lt;/code&gt;, and that&amp;rsquo;s its signature:</source>
          <target state="translated">Saber que puede tomar porciones de literales y valores de &lt;code&gt;String&lt;/code&gt; nos lleva a una mejora m&amp;aacute;s en &lt;code&gt;first_word&lt;/code&gt; , y esa es su firma:</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">Problemas conocidos</target>
        </trans-unit>
        <trans-unit id="d3ae07e851fde32543939729ee80148fb0ebdf41" translate="yes" xml:space="preserve">
          <source>Known bugs</source>
          <target state="translated">Bichos conocidos</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="7c94d83254a2ffa0762a5bfff0ef000108b0fbf6" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+ g&lt;/code&gt;) = { &lt;code&gt;g&lt;/code&gt; }</source>
          <target state="translated">&amp;Uacute;LTIMO ( &lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+ g&lt;/code&gt; ) = { &lt;code&gt;g&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="e400fae22d0553b70188e398d3482c7e98a473b0" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+&lt;/code&gt;) = { &lt;code&gt;;&lt;/code&gt; }</source>
          <target state="translated">&amp;Uacute;LTIMO ( &lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+&lt;/code&gt; ) = { &lt;code&gt;;&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="f4251e0f413cd3f41f3df9bb22d15a8115a98157" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)*&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt;, &amp;epsilon;, &lt;code&gt;h&lt;/code&gt; }</source>
          <target state="translated">&amp;Uacute;LTIMO ( &lt;code&gt;$( $d:ident $e:expr );* $(h)*&lt;/code&gt; ) = { &lt;code&gt;$e:expr&lt;/code&gt; , &amp;epsilon;, &lt;code&gt;h&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="7ff61fa787f2c62adc8ee173405366e66cca6711" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );*&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt;, &amp;epsilon; }</source>
          <target state="translated">&amp;Uacute;LTIMO ( &lt;code&gt;$( $d:ident $e:expr );*&lt;/code&gt; ) = { &lt;code&gt;$e:expr&lt;/code&gt; , &amp;epsilon;}</target>
        </trans-unit>
        <trans-unit id="37aef063f183280d4f7dc041920c02a28b503744" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$d:ident $e:expr&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt; }</source>
          <target state="translated">&amp;Uacute;LTIMO ( &lt;code&gt;$d:ident $e:expr&lt;/code&gt; ) = { &lt;code&gt;$e:expr&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="7fab544af8af2c23b62871343f4c928563121b43" translate="yes" xml:space="preserve">
          <source>LAST(M), defined by case analysis on M itself (a sequence of token-trees):</source>
          <target state="translated">LAST(M),definido por el análisis de casos sobre la propia M (una secuencia de árboles simbólicos):</target>
        </trans-unit>
        <trans-unit id="f85099a357b111ba1d477f0dbd426a597f6e3435" translate="yes" xml:space="preserve">
          <source>LAST(M): collects the tokens potentially used last when matching a fragment to M.</source>
          <target state="translated">ÚLTIMA (M):recoge las fichas potencialmente utilizadas en último lugar al emparejar un fragmento con M.</target>
        </trans-unit>
        <trans-unit id="e8ea6b99f854e01dbe363d86b29cecae5304f225" translate="yes" xml:space="preserve">
          <source>LIFETIME_OR_LABEL</source>
          <target state="translated">LIFETIME_OR_LABEL</target>
        </trans-unit>
        <trans-unit id="40a1fdbb26c080098fc98bb4705851d4859ab4d3" translate="yes" xml:space="preserve">
          <source>LIFETIME_OR_LABEL :</source>
          <target state="translated">VIDA_O_ETIQUETA :</target>
        </trans-unit>
        <trans-unit id="46318a9c5b3843dedcc74d3eda791e4202987f7e" translate="yes" xml:space="preserve">
          <source>LIFETIME_TOKEN :</source>
          <target state="translated">LIFETIME_TOKEN :</target>
        </trans-unit>
        <trans-unit id="ed2747925f72878526dce1d4b02fb7c509e9b22b" translate="yes" xml:space="preserve">
          <source>LINE_COMMENT :</source>
          <target state="translated">COMENTARIO DE LÍNEA :</target>
        </trans-unit>
        <trans-unit id="f87b1be490e7f2bd1d43aa401d9acb86c892b5d9" translate="yes" xml:space="preserve">
          <source>LLVM checks the validity of the constraints and the assembly string passed to it. This error implies that LLVM seems something wrong with the inline assembly call.</source>
          <target state="translated">El LLVM comprueba la validez de las restricciones y la cadena de montaje que se le ha pasado.Este error implica que la LLVM parece que algo está mal con la llamada de ensamblaje en línea.</target>
        </trans-unit>
        <trans-unit id="9b658c08127be6d116e98bc8876055e873db0602" translate="yes" xml:space="preserve">
          <source>LLVM-style inline assembly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c275bc5d1a4e6d0414829b996cfcec4698e44c4" translate="yes" xml:space="preserve">
          <source>LN_10</source>
          <target state="translated">LN_10</target>
        </trans-unit>
        <trans-unit id="6a259766cb7d3ece474214d8a5b06e89f14ab44c" translate="yes" xml:space="preserve">
          <source>LN_2</source>
          <target state="translated">LN_2</target>
        </trans-unit>
        <trans-unit id="98673bb5e17015cbf16ed84d89d8f970845d818b" translate="yes" xml:space="preserve">
          <source>LOG10_2</source>
          <target state="translated">LOG10_2</target>
        </trans-unit>
        <trans-unit id="66e6842f3da223e16de827da3acf936ddc9d0df5" translate="yes" xml:space="preserve">
          <source>LOG10_E</source>
          <target state="translated">LOG10_E</target>
        </trans-unit>
        <trans-unit id="615a1422d501618265e393e3550ecb5f40f525ea" translate="yes" xml:space="preserve">
          <source>LOG2_10</source>
          <target state="translated">LOG2_10</target>
        </trans-unit>
        <trans-unit id="1e3656097aebf0f10597eae43f1c807651a96817" translate="yes" xml:space="preserve">
          <source>LOG2_E</source>
          <target state="translated">LOG2_E</target>
        </trans-unit>
        <trans-unit id="64b87b109e5db684a74aa921ff29dc63050bf704" translate="yes" xml:space="preserve">
          <source>Lang items are already implemented in the standard library. Unless you are writing a free-standing application (e.g., a kernel), you do not need to provide them yourself.</source>
          <target state="translated">Los artículos de Lang ya están implementados en la biblioteca estándar.A menos que esté escribiendo una aplicación independiente (por ejemplo,un núcleo),no necesita proporcionarlos usted mismo.</target>
        </trans-unit>
        <trans-unit id="ec882b1a036e4071e5191bd244e46720429e3479" translate="yes" xml:space="preserve">
          <source>Languages without case are not changed:</source>
          <target state="translated">Los idiomas sin caja no se cambian:</target>
        </trans-unit>
        <trans-unit id="8f3396549fa1fe2041e1f31d203c0b16d63a7207" translate="yes" xml:space="preserve">
          <source>Large amounts of data are being stored</source>
          <target state="translated">Se están almacenando grandes cantidades de datos</target>
        </trans-unit>
        <trans-unit id="d3612663cc19e49c3a2d261d922690a9fc7582ed" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f32&lt;/code&gt; value.</source>
          <target state="translated">Mayor valor de &lt;code&gt;f32&lt;/code&gt; finito .</target>
        </trans-unit>
        <trans-unit id="cdef2a389723afff7da4b608a1325e2bd13839b5" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f32&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MAX&quot;&gt;&lt;code&gt;f32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f275a12dc16bf46e1c9b02d6b9bdd0fdd3cd4f44" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f64&lt;/code&gt; value.</source>
          <target state="translated">Mayor valor finito de &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caa7ded1cda53ab540342fa3edd4f2916d1b87b9" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f64&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MAX&quot;&gt;&lt;code&gt;f64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58d72036ad47fa0a1439cec22ee87f753fd7e3f" translate="yes" xml:space="preserve">
          <source>Last, but certainly not least, is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. This type is used as the return type of many &lt;code&gt;std::io&lt;/code&gt; functions that can cause an error, and can be returned from your own functions as well. Many of the examples in this module use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">Por &amp;uacute;ltimo, pero ciertamente no menos importante, es &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; . Este tipo se usa como el tipo de retorno de muchas funciones &lt;code&gt;std::io&lt;/code&gt; que pueden causar un error y tambi&amp;eacute;n se puede devolver desde sus propias funciones. Muchos de los ejemplos de este m&amp;oacute;dulo utilizan &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; operador&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="972ad8d8a50397ba8c02433ed8f048eeb4074b85" translate="yes" xml:space="preserve">
          <source>Layout</source>
          <target state="translated">Layout</target>
        </trans-unit>
        <trans-unit id="ae8568d10c64dba6b746ac76005e66dab74cb9ab" translate="yes" xml:space="preserve">
          <source>Layout of a block of memory.</source>
          <target state="translated">Diseño de un bloque de memoria.</target>
        </trans-unit>
        <trans-unit id="7d4179a87c3ab99e827a9f6e1aa71781644d0b85" translate="yes" xml:space="preserve">
          <source>Layout::align</source>
          <target state="translated">Layout::align</target>
        </trans-unit>
        <trans-unit id="2b7cae98e285326dfa8874cd827b7060dafbb97f" translate="yes" xml:space="preserve">
          <source>Layout::align_to</source>
          <target state="translated">Layout::align_to</target>
        </trans-unit>
        <trans-unit id="6ffbac24ba5cb9cdd880e70819658687db1a163d" translate="yes" xml:space="preserve">
          <source>Layout::array</source>
          <target state="translated">Layout::array</target>
        </trans-unit>
        <trans-unit id="faf545bb524583c428a14d8796fd332e8b1f4538" translate="yes" xml:space="preserve">
          <source>Layout::borrow</source>
          <target state="translated">Layout::borrow</target>
        </trans-unit>
        <trans-unit id="6e7c904826d6356b87a5fd10b67922e27e248f36" translate="yes" xml:space="preserve">
          <source>Layout::borrow_mut</source>
          <target state="translated">Layout::borrow_mut</target>
        </trans-unit>
        <trans-unit id="e98c55355125dbd6a52d2480ae5f678bafc47354" translate="yes" xml:space="preserve">
          <source>Layout::clone</source>
          <target state="translated">Layout::clone</target>
        </trans-unit>
        <trans-unit id="2687d55f8151ff4e3d3dfd56105fc50d005dbef6" translate="yes" xml:space="preserve">
          <source>Layout::clone_from</source>
          <target state="translated">Layout::clone_from</target>
        </trans-unit>
        <trans-unit id="d247f8af0b3641c1febfca5a66104f7e6cd7ae07" translate="yes" xml:space="preserve">
          <source>Layout::clone_into</source>
          <target state="translated">Layout::clone_into</target>
        </trans-unit>
        <trans-unit id="28c4c39a207293b5ac856dadaca01591e69acdf2" translate="yes" xml:space="preserve">
          <source>Layout::eq</source>
          <target state="translated">Layout::eq</target>
        </trans-unit>
        <trans-unit id="807fbd84446164c635ef92d05b4f032e4e469c63" translate="yes" xml:space="preserve">
          <source>Layout::extend</source>
          <target state="translated">Layout::extend</target>
        </trans-unit>
        <trans-unit id="8a66e95e85ef65243dad3fec906d59a444e63307" translate="yes" xml:space="preserve">
          <source>Layout::extend_packed</source>
          <target state="translated">Layout::extend_packed</target>
        </trans-unit>
        <trans-unit id="ebdf1907153114cac58ba5ec846d319f09e3c275" translate="yes" xml:space="preserve">
          <source>Layout::fmt</source>
          <target state="translated">Layout::fmt</target>
        </trans-unit>
        <trans-unit id="aab6fc5da3370994e8eb6ae5619aeb20b2942b01" translate="yes" xml:space="preserve">
          <source>Layout::for_value</source>
          <target state="translated">Layout::for_value</target>
        </trans-unit>
        <trans-unit id="804e6daf71de8cbddc2847d4efac40f08b730f12" translate="yes" xml:space="preserve">
          <source>Layout::from</source>
          <target state="translated">Layout::from</target>
        </trans-unit>
        <trans-unit id="9c52da202dbc1e86eb154e999a408fd8e5fbffba" translate="yes" xml:space="preserve">
          <source>Layout::from_size_align</source>
          <target state="translated">Layout::from_size_align</target>
        </trans-unit>
        <trans-unit id="97f7ac20412edfee9be62fc236598951052b803a" translate="yes" xml:space="preserve">
          <source>Layout::from_size_align_unchecked</source>
          <target state="translated">Layout::from_size_align_unchecked</target>
        </trans-unit>
        <trans-unit id="9cb8530d3128b6bd4c274c8e7e0e34f2f70b863a" translate="yes" xml:space="preserve">
          <source>Layout::into</source>
          <target state="translated">Layout::into</target>
        </trans-unit>
        <trans-unit id="e888b6d02ea4794c5fef327a295c976cc60f99e3" translate="yes" xml:space="preserve">
          <source>Layout::ne</source>
          <target state="translated">Layout::ne</target>
        </trans-unit>
        <trans-unit id="f8038f15aebe6dce4d4de95b3c13e472d2b02064" translate="yes" xml:space="preserve">
          <source>Layout::new</source>
          <target state="translated">Layout::new</target>
        </trans-unit>
        <trans-unit id="c67933e7b53ec19707602158f0983ec3386107e4" translate="yes" xml:space="preserve">
          <source>Layout::pad_to_align</source>
          <target state="translated">Layout::pad_to_align</target>
        </trans-unit>
        <trans-unit id="fb534b2d9180d9c41c85be4f3cc7a5e10900d871" translate="yes" xml:space="preserve">
          <source>Layout::padding_needed_for</source>
          <target state="translated">Layout::padding_needed_for</target>
        </trans-unit>
        <trans-unit id="a53e256b922777e3d8b52ed41502d58861453b8a" translate="yes" xml:space="preserve">
          <source>Layout::repeat</source>
          <target state="translated">Layout::repeat</target>
        </trans-unit>
        <trans-unit id="ac76fcd730f9145d3ef5771a73793f24557f189a" translate="yes" xml:space="preserve">
          <source>Layout::repeat_packed</source>
          <target state="translated">Layout::repeat_packed</target>
        </trans-unit>
        <trans-unit id="39b88a7f119bc78ddb9f4adea7781765100ba7de" translate="yes" xml:space="preserve">
          <source>Layout::size</source>
          <target state="translated">Layout::size</target>
        </trans-unit>
        <trans-unit id="4fc54c6aa1d00c912811a3198ba6c26a31cb141d" translate="yes" xml:space="preserve">
          <source>Layout::to_owned</source>
          <target state="translated">Layout::to_owned</target>
        </trans-unit>
        <trans-unit id="ec3e4dd97b8bdfbb69e8e8a4fe407933742763da" translate="yes" xml:space="preserve">
          <source>Layout::try_from</source>
          <target state="translated">Layout::try_from</target>
        </trans-unit>
        <trans-unit id="e7254c8b2c904f17a579a6512de1c3f53903e338" translate="yes" xml:space="preserve">
          <source>Layout::try_into</source>
          <target state="translated">Layout::try_into</target>
        </trans-unit>
        <trans-unit id="69613b626753f65b515ca28b5fe4fd7436a0a88d" translate="yes" xml:space="preserve">
          <source>Layout::type_id</source>
          <target state="translated">Layout::type_id</target>
        </trans-unit>
        <trans-unit id="6b15514a909ca7b027740ad8a4c4fe6fbfdeead1" translate="yes" xml:space="preserve">
          <source>LayoutErr</source>
          <target state="translated">LayoutErr</target>
        </trans-unit>
        <trans-unit id="18ae5986925972906df162748403c4571a3bd382" translate="yes" xml:space="preserve">
          <source>LayoutErr::borrow</source>
          <target state="translated">LayoutErr::borrow</target>
        </trans-unit>
        <trans-unit id="92579002fabcdb4525eb6353397c1fc960583290" translate="yes" xml:space="preserve">
          <source>LayoutErr::borrow_mut</source>
          <target state="translated">LayoutErr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1c9995b499c2000f5ea89f003f69988ad4d9295a" translate="yes" xml:space="preserve">
          <source>LayoutErr::cause</source>
          <target state="translated">LayoutErr::cause</target>
        </trans-unit>
        <trans-unit id="8694453e9f4b16d83cc25ab2975ab170ff1ad8c9" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone</source>
          <target state="translated">LayoutErr::clone</target>
        </trans-unit>
        <trans-unit id="b630e1b5713feb7087721a06315e5b984a418a6f" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone_from</source>
          <target state="translated">LayoutErr::clone_from</target>
        </trans-unit>
        <trans-unit id="c42cb73e4c87ec15d8bccdf73bd650c9df417b9b" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone_into</source>
          <target state="translated">LayoutErr::clone_into</target>
        </trans-unit>
        <trans-unit id="3d5c517ec7fe54611274ae766b7e9a7911dc4865" translate="yes" xml:space="preserve">
          <source>LayoutErr::description</source>
          <target state="translated">LayoutErr::description</target>
        </trans-unit>
        <trans-unit id="497868f6f797da1325f8a9e9334379ca52fe4d37" translate="yes" xml:space="preserve">
          <source>LayoutErr::eq</source>
          <target state="translated">LayoutErr::eq</target>
        </trans-unit>
        <trans-unit id="3e42ce22d91446434898d46efd3223372301d536" translate="yes" xml:space="preserve">
          <source>LayoutErr::fmt</source>
          <target state="translated">LayoutErr::fmt</target>
        </trans-unit>
        <trans-unit id="73c4ad8234e8ca96453bac67aff91d0248f854d8" translate="yes" xml:space="preserve">
          <source>LayoutErr::from</source>
          <target state="translated">LayoutErr::from</target>
        </trans-unit>
        <trans-unit id="c3349dca57dd20451bc1fb01674dae961d63e9ce" translate="yes" xml:space="preserve">
          <source>LayoutErr::into</source>
          <target state="translated">LayoutErr::into</target>
        </trans-unit>
        <trans-unit id="f0f74e1ec8093e352aa9e8a3fd380fef9597b057" translate="yes" xml:space="preserve">
          <source>LayoutErr::ne</source>
          <target state="translated">LayoutErr::ne</target>
        </trans-unit>
        <trans-unit id="13438de55c63f100651925816f56012c5f1b1197" translate="yes" xml:space="preserve">
          <source>LayoutErr::source</source>
          <target state="translated">LayoutErr::source</target>
        </trans-unit>
        <trans-unit id="3bbdcbefa6e28507c6b0c6c634c7c7dc826a8bf4" translate="yes" xml:space="preserve">
          <source>LayoutErr::to_owned</source>
          <target state="translated">LayoutErr::to_owned</target>
        </trans-unit>
        <trans-unit id="2ec834ea6aa3644afac64a7ad23be1e1d6c10755" translate="yes" xml:space="preserve">
          <source>LayoutErr::to_string</source>
          <target state="translated">LayoutErr::to_string</target>
        </trans-unit>
        <trans-unit id="569d09cda7ad780d06bfd86cc93c53c21d1d507f" translate="yes" xml:space="preserve">
          <source>LayoutErr::try_from</source>
          <target state="translated">LayoutErr::try_from</target>
        </trans-unit>
        <trans-unit id="da95ddd29b8a42941df811e96eda4d3f3b529f15" translate="yes" xml:space="preserve">
          <source>LayoutErr::try_into</source>
          <target state="translated">LayoutErr::try_into</target>
        </trans-unit>
        <trans-unit id="b157e123211e4f6e633b31e52c5a1dcb6f18cc93" translate="yes" xml:space="preserve">
          <source>LayoutErr::type_id</source>
          <target state="translated">LayoutErr::type_id</target>
        </trans-unit>
        <trans-unit id="882d7824546e260d7aecb582ca23a9e9525d35d8" translate="yes" xml:space="preserve">
          <source>Laziness</source>
          <target state="translated">Laziness</target>
        </trans-unit>
        <trans-unit id="1a855a2a58b53f62fc3df50bb4fbd170d6d9104f" translate="yes" xml:space="preserve">
          <source>Lazy boolean operators</source>
          <target state="translated">Perezosos operadores booleanos</target>
        </trans-unit>
        <trans-unit id="7e80f065af51812290038b5aef5b515381e7b069" translate="yes" xml:space="preserve">
          <source>Lazy values and one-time initialization of static data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="5c517a3f3609c8f91e1addb0b08b45eb552a8056" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace represent an error.</source>
          <target state="translated">El espacio blanco que va delante y detrás representa un error.</target>
        </trans-unit>
        <trans-unit id="171d90f8bc7e44b38d039153f89d2f57be6e9170" translate="yes" xml:space="preserve">
          <source>Leak an I/O object, never closing the file:</source>
          <target state="translated">Filtrar un objeto I/O,sin cerrar nunca el archivo:</target>
        </trans-unit>
        <trans-unit id="0c87712acc6d428c2446529002e5d51f0d06f2b8" translate="yes" xml:space="preserve">
          <source>Leaks of memory and other resources</source>
          <target state="translated">Fugas de memoria y otros recursos</target>
        </trans-unit>
        <trans-unit id="4a0f6a000e4abc155c2355349886b493447a871e" translate="yes" xml:space="preserve">
          <source>Learn a bit about TCP and HTTP.</source>
          <target state="translated">Aprende un poco sobre TCP y HTTP.</target>
        </trans-unit>
        <trans-unit id="3b3bf48bce1a18fd95b7ca358e1f16b46d7a4f20" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;reference/attributes#conditional-compilation&quot;&gt;Conditional Compilation&lt;/a&gt; section of the Reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee627fb00174e09c28a9f8c4feb833b6e5f743c" translate="yes" xml:space="preserve">
          <source>Leaves the original &lt;code&gt;Option&lt;/code&gt; in-place, creating a new one containing a mutable reference to the inner type's &lt;code&gt;Deref::Target&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7cf535c3451fcfd6307510b8776e34c835efbed" translate="yes" xml:space="preserve">
          <source>Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c694f6b8cb7b00330c4d48a5ced6de4ae07bc6" translate="yes" xml:space="preserve">
          <source>Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Deja la opci&amp;oacute;n original en su lugar, creando una nueva con una referencia a la original, adem&amp;aacute;s de coaccionar el contenido a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbc8d1a601145e0b8a0f4e2783062a13702a5915" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing both the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; arms of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Deja el Resultado original en su lugar, creando uno nuevo con una referencia al original, adem&amp;aacute;s de coaccionar los brazos &lt;code&gt;Ok&lt;/code&gt; y &lt;code&gt;Err&lt;/code&gt; del Resultado a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35c9a587594a401fda69e05b935e4d8b2ac65ada" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing the &lt;code&gt;Err&lt;/code&gt; arm of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Deja el Resultado original en su lugar, creando uno nuevo con una referencia al original, adem&amp;aacute;s de coaccionar el brazo &lt;code&gt;Err&lt;/code&gt; del Resultado a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50d3f8b919eb6aee8c76227d9ffbe9d9e4ef3631" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing the &lt;code&gt;Ok&lt;/code&gt; arm of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Deja el Resultado original en su lugar, creando uno nuevo con una referencia al original, adem&amp;aacute;s de coaccionar el brazo &lt;code&gt;Ok&lt;/code&gt; del Resultado a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="494064e70529e54389ad678d759801779c5c72df" translate="yes" xml:space="preserve">
          <source>Left Shift</source>
          <target state="translated">Cambio a la izquierda</target>
        </trans-unit>
        <trans-unit id="357a167cfbb492462507b9b8569ac04e39500116" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions.</source>
          <target state="translated">Operando izquierdo en expresiones de &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexaci&amp;oacute;n de matrices&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="802deb5f6a24f0153e1b52a743d60aef22ab93a7" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">Operando izquierdo en &lt;a href=&quot;expressions/call-expr&quot;&gt;expresiones de llamada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3463667b7fa2b91f4f33b26ea8c6945778008832" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; expressions.</source>
          <target state="translated">Operando izquierdo en expresiones de &lt;a href=&quot;expressions/field-expr&quot;&gt;campo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="604e7ca527ffc17876e5a83a46e96dfa0fc8df57" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method-call&lt;/a&gt; expressions.</source>
          <target state="translated">Operando izquierdo en expresiones de &lt;a href=&quot;expressions/method-call-expr&quot;&gt;llamada a m&amp;eacute;todo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb226dadb2d69601a2e88f0aff30921d841ff9e2" translate="yes" xml:space="preserve">
          <source>Left operands of the &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt;.</source>
          <target state="translated">Operandos izquierdos de la &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;asignaci&amp;oacute;n compuesta&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c80da6a471da3578e154404c086273e1a0815411" translate="yes" xml:space="preserve">
          <source>Left-shift</source>
          <target state="translated">Left-shift</target>
        </trans-unit>
        <trans-unit id="b5ac21daa5921e49b42d9ee7f63e24eef4f4e0f5" translate="yes" xml:space="preserve">
          <source>Left-shift and assignment</source>
          <target state="translated">Turno izquierdo y asignación</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">Menos de</target>
        </trans-unit>
        <trans-unit id="2dd999a5f745b11640e747579b45ca334f6bd164" translate="yes" xml:space="preserve">
          <source>Less than comparison</source>
          <target state="translated">Menos que una comparación</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">Menos que o igual a</target>
        </trans-unit>
        <trans-unit id="4c0c7f8feba1a3be504536a32e6253de66037beb" translate="yes" xml:space="preserve">
          <source>Less than or equal to comparison</source>
          <target state="translated">Menos que o igual a la comparación</target>
        </trans-unit>
        <trans-unit id="2bf9b5b6040aab2674d9953c9b7c713583f20dae" translate="yes" xml:space="preserve">
          <source>Less-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">Comparaci&amp;oacute;n menor que para dos &lt;code&gt;Arc&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="e86e08a482dea944d87e01c7d1358debb5cc8f8f" translate="yes" xml:space="preserve">
          <source>Less-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">Comparaci&amp;oacute;n menor que para dos &lt;code&gt;Rc&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="023a23666ee1826dd775c67ffcc792722addcad9" translate="yes" xml:space="preserve">
          <source>Let ALPHA_SET(M) = FIRST(&lt;code&gt;&amp;alpha;&lt;/code&gt;) if OP = &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; and ALPHA_SET(M) = {} if OP = &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Sea ALPHA_SET (M) = FIRST ( &lt;code&gt;&amp;alpha;&lt;/code&gt; ) si OP = &lt;code&gt;\*&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; y ALPHA_SET (M) = {} si OP = &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c00ee374b6dc82a14932bb4fd3e12ef63fb5d55f" translate="yes" xml:space="preserve">
          <source>Let SEP_SET(M) = { SEP } if SEP is present and &amp;epsilon; &amp;isin; FIRST(&lt;code&gt;tt ...&lt;/code&gt;); otherwise SEP_SET(M) = {}.</source>
          <target state="translated">Sea SEP_SET (M) = {SEP} si SEP est&amp;aacute; presente y &amp;epsilon; &amp;isin; FIRST ( &lt;code&gt;tt ...&lt;/code&gt; ); de lo contrario, SEP_SET (M) = {}.</target>
        </trans-unit>
        <trans-unit id="53530264e4da661c5ecd3e262365a6de39f515ea" translate="yes" xml:space="preserve">
          <source>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</source>
          <target state="translated">Que sep_set={SEP}si SEP presente;de lo contrario sep_set={}.</target>
        </trans-unit>
        <trans-unit id="911e3ff1d34feb7b7cd623e6d1a6a2dd2992b8d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add another test, but this time we&amp;rsquo;ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. We talked about the simplest way to cause a panic in Chapter 9, which is to call the &lt;code&gt;panic!&lt;/code&gt; macro. Enter the new test, &lt;code&gt;another&lt;/code&gt;, so your &lt;em&gt;src/lib.rs&lt;/em&gt; file looks like Listing 11-3.</source>
          <target state="translated">Agreguemos otra prueba, &amp;iexcl;pero esta vez haremos una prueba que falla! Las pruebas fallan cuando algo en la funci&amp;oacute;n de prueba entra en p&amp;aacute;nico. Cada prueba se ejecuta en un nuevo hilo y cuando el hilo principal ve que un hilo de prueba ha muerto, la prueba se marca como fallida. Hablamos sobre la forma m&amp;aacute;s sencilla de causar p&amp;aacute;nico en el Cap&amp;iacute;tulo 9, que es llamar al &lt;code&gt;panic!&lt;/code&gt; macro. Ingrese la nueva prueba, &lt;code&gt;another&lt;/code&gt; , para que su archivo &lt;em&gt;src / lib.rs se&lt;/em&gt; vea como el Listado 11-3.</target>
        </trans-unit>
        <trans-unit id="862ded2868716c0b1f9c7eb816092a939af7bcb0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s address the second error, which points to the code at the end of &lt;code&gt;Worker::new&lt;/code&gt;; we need to wrap the &lt;code&gt;thread&lt;/code&gt; value in &lt;code&gt;Some&lt;/code&gt; when we create a new &lt;code&gt;Worker&lt;/code&gt;. Make the following changes to fix this error:</source>
          <target state="translated">Abordemos el segundo error, que apunta al c&amp;oacute;digo al final de &lt;code&gt;Worker::new&lt;/code&gt; ; necesitamos envolver el valor del &lt;code&gt;thread&lt;/code&gt; en &lt;code&gt;Some&lt;/code&gt; cuando creamos un nuevo &lt;code&gt;Worker&lt;/code&gt; . Realice los siguientes cambios para corregir este error:</target>
        </trans-unit>
        <trans-unit id="2f2efb01063714d86b5480ed1b824b067b1a031d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s address these four problems by refactoring our project.</source>
          <target state="translated">Abordemos estos cuatro problemas refactorizando nuestro proyecto.</target>
        </trans-unit>
        <trans-unit id="533040ac56d9f1aa4e4c0e2a9a9719c3755f6d7a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also make the &lt;code&gt;add_to_waitlist&lt;/code&gt; function public by adding the &lt;code&gt;pub&lt;/code&gt; keyword before its definition, as in Listing 7-7.</source>
          <target state="translated">Tambi&amp;eacute;n hagamos p&amp;uacute;blica la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; agregando la palabra clave &lt;code&gt;pub&lt;/code&gt; antes de su definici&amp;oacute;n, como en el Listado 7-7.</target>
        </trans-unit>
        <trans-unit id="ea4a0f30216adf2bf51b73cd6dbecc829205bb86" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the first rule: each parameter gets its own lifetime. This time we have two parameters instead of one, so we have two lifetimes:</source>
          <target state="translated">Apliquemos la primera regla: cada par&amp;aacute;metro tiene su propia vida. Esta vez tenemos dos par&amp;aacute;metros en lugar de uno, por lo que tenemos dos vidas:</target>
        </trans-unit>
        <trans-unit id="0bfaeb7ed44c7ba50fa8b27070055c189f55db1b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break down the &lt;code&gt;match&lt;/code&gt; in the &lt;code&gt;value_in_cents&lt;/code&gt; function. First, we list the &lt;code&gt;match&lt;/code&gt; keyword followed by an expression, which in this case is the value &lt;code&gt;coin&lt;/code&gt;. This seems very similar to an expression used with &lt;code&gt;if&lt;/code&gt;, but there&amp;rsquo;s a big difference: with &lt;code&gt;if&lt;/code&gt;, the expression needs to return a Boolean value, but here, it can be any type. The type of &lt;code&gt;coin&lt;/code&gt; in this example is the &lt;code&gt;Coin&lt;/code&gt; enum that we defined on line 1.</source>
          <target state="translated">Analicemos la &lt;code&gt;match&lt;/code&gt; en la funci&amp;oacute;n &lt;code&gt;value_in_cents&lt;/code&gt; . Primero, enumeramos la palabra clave de &lt;code&gt;match&lt;/code&gt; seguida de una expresi&amp;oacute;n, que en este caso es la &lt;code&gt;coin&lt;/code&gt; valor . Esto parece muy similar a una expresi&amp;oacute;n usada con &lt;code&gt;if&lt;/code&gt; , pero hay una gran diferencia: con &lt;code&gt;if&lt;/code&gt; , la expresi&amp;oacute;n necesita devolver un valor booleano, pero aqu&amp;iacute;, puede ser de cualquier tipo. El tipo de &lt;code&gt;coin&lt;/code&gt; en este ejemplo es la enumeraci&amp;oacute;n &lt;code&gt;Coin&lt;/code&gt; que definimos en la l&amp;iacute;nea 1.</target>
        </trans-unit>
        <trans-unit id="f56b403e93973d8ea8cf3d0611a5804ed42ec21f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break down this request data to understand what the browser is asking of our program.</source>
          <target state="translated">Analicemos los datos de esta solicitud para comprender qu&amp;eacute; le pide el navegador a nuestro programa.</target>
        </trans-unit>
        <trans-unit id="b36a5ce769815370ab06336595b70e1c5c477b25" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s briefly look at the syntax of specifying generic type parameters, trait bounds, and lifetimes all in one function!</source>
          <target state="translated">Veamos brevemente la sintaxis de especificar par&amp;aacute;metros de tipo gen&amp;eacute;rico, l&amp;iacute;mites de rasgos y tiempos de vida, &amp;iexcl;todo en una funci&amp;oacute;n!</target>
        </trans-unit>
        <trans-unit id="0b5fe379df9523f20646a85915698650e52f567f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s build a smart pointer similar to the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library to experience how smart pointers behave differently from references by default. Then we&amp;rsquo;ll look at how to add the ability to use the dereference operator.</source>
          <target state="translated">Construyamos un puntero inteligente similar al tipo &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; proporcionado por la biblioteca est&amp;aacute;ndar para experimentar c&amp;oacute;mo los punteros inteligentes se comportan de manera diferente a las referencias por defecto. Luego veremos c&amp;oacute;mo agregar la capacidad de usar el operador de desreferencia.</target>
        </trans-unit>
        <trans-unit id="a51f4557e798f86ab9a943604a40558633731ed7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s build the workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory!</source>
          <target state="translated">&amp;iexcl;Construyamos el espacio de trabajo ejecutando &lt;code&gt;cargo build&lt;/code&gt; en el directorio de &lt;em&gt;adici&amp;oacute;n de&lt;/em&gt; nivel superior !</target>
        </trans-unit>
        <trans-unit id="5f04507c41a7a28beafb3cead61fdadb3dea0a6f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s call a function that returns a &lt;code&gt;Result&lt;/code&gt; value because the function could fail. In Listing 9-3 we try to open a file.</source>
          <target state="translated">Llamemos a una funci&amp;oacute;n que devuelve un valor de &lt;code&gt;Result&lt;/code&gt; ado porque la funci&amp;oacute;n podr&amp;iacute;a fallar. En el Listado 9-3 intentamos abrir un archivo.</target>
        </trans-unit>
        <trans-unit id="a513da811ee53d6a1f83cac6544789f14693ebd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change our working example in Listing 15-18 so we can see the reference counts changing as we create and drop references to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Cambiemos nuestro ejemplo de trabajo en el Listado 15-18 para que podamos ver que los recuentos de referencias cambian a medida que creamos y eliminamos referencias a &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13b7e2a02ac5f6f1d6e7771973bf7e4e8630f77c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;area&lt;/code&gt; function that has a &lt;code&gt;Rectangle&lt;/code&gt; instance as a parameter and instead make an &lt;code&gt;area&lt;/code&gt; method defined on the &lt;code&gt;Rectangle&lt;/code&gt; struct, as shown in Listing 5-13.</source>
          <target state="translated">Cambiemos la funci&amp;oacute;n de &lt;code&gt;area&lt;/code&gt; que tiene una instancia de &lt;code&gt;Rectangle&lt;/code&gt; como par&amp;aacute;metro y en su lugar hagamos un m&amp;eacute;todo de &lt;code&gt;area&lt;/code&gt; definido en la estructura &lt;code&gt;Rectangle&lt;/code&gt; , como se muestra en el Listado 5-13.</target>
        </trans-unit>
        <trans-unit id="a1f781d100edd0654c8707256174d0183b82ca21" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the name of our test to see how that changes the test output. Change the &lt;code&gt;it_works&lt;/code&gt; function to a different name, such as &lt;code&gt;exploration&lt;/code&gt;, like so:</source>
          <target state="translated">Cambiemos el nombre de nuestra prueba para ver c&amp;oacute;mo cambia la salida de la prueba. Cambie la funci&amp;oacute;n &lt;code&gt;it_works&lt;/code&gt; a un nombre diferente, como &lt;code&gt;exploration&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="e085a2cf9e4bfbccd609eb67b047befe0756bfad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that it passes!</source>
          <target state="translated">&amp;iexcl;Comprobemos que pasa!</target>
        </trans-unit>
        <trans-unit id="6e6584addded7d162e25546426216dd008dbd0f0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check the code again:</source>
          <target state="translated">Revisemos el c&amp;oacute;digo nuevamente:</target>
        </trans-unit>
        <trans-unit id="58ec20357926eeae9e87a4ac077cb4fc985ca821" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s combine the knowledge you learned in this chapter and in previous chapters to work on a project!</source>
          <target state="translated">&amp;iexcl;Combinemos el conocimiento que aprendi&amp;oacute; en este cap&amp;iacute;tulo y en los cap&amp;iacute;tulos anteriores para trabajar en un proyecto!</target>
        </trans-unit>
        <trans-unit id="7729d445e0c4aa723c02605775741a07569ce3c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the first part of &lt;code&gt;main&lt;/code&gt; in Listing 17-11:</source>
          <target state="translated">Consideremos la primera parte de &lt;code&gt;main&lt;/code&gt; en el Listado 17-11:</target>
        </trans-unit>
        <trans-unit id="9bd7feb2aa1c163d92ba2edc07ccaeec3f556691" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a crate named &lt;code&gt;hello_macro&lt;/code&gt; that defines a trait named &lt;code&gt;HelloMacro&lt;/code&gt; with one associated function named &lt;code&gt;hello_macro&lt;/code&gt;. Rather than making our crate users implement the &lt;code&gt;HelloMacro&lt;/code&gt; trait for each of their types, we&amp;rsquo;ll provide a procedural macro so users can annotate their type with &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; to get a default implementation of the &lt;code&gt;hello_macro&lt;/code&gt; function. The default implementation will print &lt;code&gt;Hello, Macro! My name is TypeName!&lt;/code&gt; where &lt;code&gt;TypeName&lt;/code&gt; is the name of the type on which this trait has been defined. In other words, we&amp;rsquo;ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.</source>
          <target state="translated">&lt;code&gt;hello_macro&lt;/code&gt; una caja llamada hello_macro que defina un rasgo llamado &lt;code&gt;HelloMacro&lt;/code&gt; con una funci&amp;oacute;n asociada llamada &lt;code&gt;hello_macro&lt;/code&gt; . En lugar de hacer que nuestros usuarios de cajas implementen el rasgo &lt;code&gt;HelloMacro&lt;/code&gt; para cada uno de sus tipos, proporcionaremos una macro de procedimiento para que los usuarios puedan anotar su tipo con &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; para obtener una implementaci&amp;oacute;n predeterminada de la funci&amp;oacute;n &lt;code&gt;hello_macro&lt;/code&gt; . La implementaci&amp;oacute;n predeterminada imprimir&amp;aacute; &lt;code&gt;Hello, Macro! My name is TypeName!&lt;/code&gt; donde &lt;code&gt;TypeName&lt;/code&gt; es el nombre del tipo en el que se ha definido este rasgo. En otras palabras, escribiremos una caja que le permita a otro programador escribir c&amp;oacute;digo como el Listado 19-30 usando nuestra caja.</target>
        </trans-unit>
        <trans-unit id="9e2142a26e44f4e6756b16f8090c68fc06e7085b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new library project called &lt;code&gt;adder&lt;/code&gt;:</source>
          <target state="translated">Creemos un nuevo proyecto de biblioteca llamado &lt;code&gt;adder&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9c7399eee11ccb14463b23d58e457c71508e98d8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project using Cargo and look at how it differs from our original &amp;ldquo;Hello, world!&amp;rdquo; project. Navigate back to your &lt;em&gt;projects&lt;/em&gt; directory (or wherever you decided to store your code). Then, on any operating system, run the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d473890aa102e1a8805b09a6342b2b1e9d3dd1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project using Cargo and look at how it differs from our original Hello, world! project. Navigate back to your &lt;em&gt;projects&lt;/em&gt; directory (or wherever you decided to store your code). Then, on any operating system, run the following:</source>
          <target state="translated">Creemos un nuevo proyecto con Cargo y veamos en qu&amp;eacute; se diferencia de nuestro Hello, world original. proyecto. Vuelve a tu directorio de &lt;em&gt;proyectos&lt;/em&gt; (o al lugar donde decidiste almacenar tu c&amp;oacute;digo). Luego, en cualquier sistema operativo, ejecute lo siguiente:</target>
        </trans-unit>
        <trans-unit id="74b1a7e7740baca8e782bfd3b97f4ca92299f7fa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project with, as always, &lt;code&gt;cargo new&lt;/code&gt;. We&amp;rsquo;ll call our project &lt;code&gt;minigrep&lt;/code&gt; to distinguish it from the &lt;code&gt;grep&lt;/code&gt; tool that you might already have on your system.</source>
          <target state="translated">Creemos un nuevo proyecto con, como siempre, &lt;code&gt;cargo new&lt;/code&gt; . Llamaremos a nuestro proyecto &lt;code&gt;minigrep&lt;/code&gt; para distinguirlo de la herramienta &lt;code&gt;grep&lt;/code&gt; que quiz&amp;aacute;s ya tenga en su sistema.</target>
        </trans-unit>
        <trans-unit id="7498e03400c34fc782316cecb8cfae701609c72c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create an integration test. With the code in Listing 11-12 still in the &lt;em&gt;src/lib.rs&lt;/em&gt; file, make a &lt;em&gt;tests&lt;/em&gt; directory, create a new file named &lt;em&gt;tests/integration_test.rs&lt;/em&gt;, and enter the code in Listing 11-13.</source>
          <target state="translated">Creemos una prueba de integraci&amp;oacute;n. Con el c&amp;oacute;digo del Listado 11-12 todav&amp;iacute;a en el archivo &lt;em&gt;src / lib.rs&lt;/em&gt; , cree un directorio de &lt;em&gt;pruebas&lt;/em&gt; , cree un nuevo archivo llamado &lt;em&gt;tests / integration_test.rs&lt;/em&gt; e ingrese el c&amp;oacute;digo en el Listado 11-13.</target>
        </trans-unit>
        <trans-unit id="76a754330b004eb7ac6a2d3134c0ac997e30ee22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dig into the details of a dynamically sized type called &lt;code&gt;str&lt;/code&gt;, which we&amp;rsquo;ve been using throughout the book. That&amp;rsquo;s right, not &lt;code&gt;&amp;amp;str&lt;/code&gt;, but &lt;code&gt;str&lt;/code&gt; on its own, is a DST. We can&amp;rsquo;t know how long the string is until runtime, meaning we can&amp;rsquo;t create a variable of type &lt;code&gt;str&lt;/code&gt;, nor can we take an argument of type &lt;code&gt;str&lt;/code&gt;. Consider the following code, which does not work:</source>
          <target state="translated">Profundicemos en los detalles de un tipo de tama&amp;ntilde;o din&amp;aacute;mico llamado &lt;code&gt;str&lt;/code&gt; , que hemos estado usando a lo largo del libro. As&amp;iacute; es, no &lt;code&gt;&amp;amp;str&lt;/code&gt; , pero &lt;code&gt;str&lt;/code&gt; por s&amp;iacute; solo, es un DST. No podemos saber cu&amp;aacute;nto tiempo dura la cadena hasta el tiempo de ejecuci&amp;oacute;n, lo que significa que no podemos crear una variable de tipo &lt;code&gt;str&lt;/code&gt; , ni podemos tomar un argumento de tipo &lt;code&gt;str&lt;/code&gt; . Considere el siguiente c&amp;oacute;digo, que no funciona:</target>
        </trans-unit>
        <trans-unit id="135058566e52c47af5c9c244e255bc4ce73db5f0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive in!</source>
          <target state="translated">&amp;iexcl;Vamos a sumergirnos!</target>
        </trans-unit>
        <trans-unit id="5ea067197cecc0dcafe00ab16ce7bc41edb2cce3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s examine the difference between the two concepts with an example from Chapter 13 that implements the &lt;code&gt;Iterator&lt;/code&gt; trait on the &lt;code&gt;Counter&lt;/code&gt; struct. In Listing 13-21, we specified that the &lt;code&gt;Item&lt;/code&gt; type was &lt;code&gt;u32&lt;/code&gt;:</source>
          <target state="translated">Examinemos la diferencia entre los dos conceptos con un ejemplo del Cap&amp;iacute;tulo 13 que implementa el rasgo &lt;code&gt;Iterator&lt;/code&gt; en la estructura &lt;code&gt;Counter&lt;/code&gt; . En el Listado 13-21, especificamos que el tipo de &lt;code&gt;Item&lt;/code&gt; era &lt;code&gt;u32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="51c8e9031bf91446f9115b59a4810cccd5e08ba7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s examine the first execution of &lt;code&gt;plus_one&lt;/code&gt; in more detail. When we call &lt;code&gt;plus_one(five)&lt;/code&gt;, the variable &lt;code&gt;x&lt;/code&gt; in the body of &lt;code&gt;plus_one&lt;/code&gt; will have the value &lt;code&gt;Some(5)&lt;/code&gt;. We then compare that against each match arm.</source>
          <target state="translated">Examinemos la primera ejecuci&amp;oacute;n de &lt;code&gt;plus_one&lt;/code&gt; con m&amp;aacute;s detalle. Cuando llamamos &lt;code&gt;plus_one(five)&lt;/code&gt; , la variable &lt;code&gt;x&lt;/code&gt; en el cuerpo de &lt;code&gt;plus_one&lt;/code&gt; tendr&amp;aacute; el valor &lt;code&gt;Some(5)&lt;/code&gt; . Luego comparamos eso con cada brazo de f&amp;oacute;sforo.</target>
        </trans-unit>
        <trans-unit id="6e71d1e8c50827371eaf73f583536f9bfaf50c55" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the &lt;em&gt;cons list&lt;/em&gt;, which is a data type common in functional programming languages, as an example of a recursive type. The cons list type we&amp;rsquo;ll define is straightforward except for the recursion; therefore, the concepts in the example we&amp;rsquo;ll work with will be useful any time you get into more complex situations involving recursive types.</source>
          <target state="translated">Exploremos la &lt;em&gt;lista de contras&lt;/em&gt; , que es un tipo de datos com&amp;uacute;n en los lenguajes de programaci&amp;oacute;n funcionales, como un ejemplo de un tipo recursivo. El tipo de lista de contras que definiremos es sencillo excepto por la recursividad; por lo tanto, los conceptos del ejemplo con los que trabajaremos ser&amp;aacute;n &amp;uacute;tiles cada vez que se encuentre en situaciones m&amp;aacute;s complejas que involucren tipos recursivos.</target>
        </trans-unit>
        <trans-unit id="8dd4037a982ed3562f2f33f83b29e377988c8c74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore this concept by looking at the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that follows the interior mutability pattern.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; este concepto observando el tipo RefCell &amp;lt;T&amp;gt; que sigue el patr&amp;oacute;n de mutabilidad interior.</target>
        </trans-unit>
        <trans-unit id="33abe13cd0e5ac2dde5cfd9e196411eace5691ef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s figure this out by simplifying the program. Instead of making 10 threads in a &lt;code&gt;for&lt;/code&gt; loop, let&amp;rsquo;s just make two threads without a loop and see what happens. Replace the first &lt;code&gt;for&lt;/code&gt; loop in Listing 16-13 with this code instead:</source>
          <target state="translated">Resolvamos esto simplificando el programa. En lugar de hacer 10 hilos en un bucle &lt;code&gt;for&lt;/code&gt; , hagamos dos hilos sin bucle y veamos qu&amp;eacute; sucede. Reemplace el primer ciclo &lt;code&gt;for&lt;/code&gt; en el Listado 16-13 con este c&amp;oacute;digo en su lugar:</target>
        </trans-unit>
        <trans-unit id="f074800650aafbfc4673a0db2d7d24603b94e675" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s finally implement the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. We&amp;rsquo;ll also change &lt;code&gt;Job&lt;/code&gt; from a struct to a type alias for a trait object that holds the type of closure that &lt;code&gt;execute&lt;/code&gt; receives. As discussed in the &lt;a href=&quot;ch19-04-advanced-types#creating-type-synonyms-with-type-aliases&quot;&gt;&amp;ldquo;Creating Type Synonyms with Type Aliases&amp;rdquo;&lt;/a&gt; section of Chapter 19, type aliases allow us to make long types shorter. Look at Listing 20-19.</source>
          <target state="translated">Finalmente implementemos el m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; en &lt;code&gt;ThreadPool&lt;/code&gt; . Tambi&amp;eacute;n cambiaremos &lt;code&gt;Job&lt;/code&gt; de una estructura a un alias de tipo para un objeto de rasgo que contiene el tipo de cierre que recibe la &lt;code&gt;execute&lt;/code&gt; . Como se discuti&amp;oacute; en la secci&amp;oacute;n &lt;a href=&quot;ch19-04-advanced-types#creating-type-synonyms-with-type-aliases&quot;&gt;&amp;ldquo;Creaci&amp;oacute;n de sin&amp;oacute;nimos de tipos con alias de tipos&amp;rdquo;&lt;/a&gt; del Cap&amp;iacute;tulo 19, los alias de tipos nos permiten acortar los tipos largos. Mire el Listado 20-19.</target>
        </trans-unit>
        <trans-unit id="8d1bc217cc494100da333abaf87d765e4a86b4ca" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first look at how the dereference operator works with regular references. Then we&amp;rsquo;ll try to define a custom type that behaves like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and see why the dereference operator doesn&amp;rsquo;t work like a reference on our newly defined type. We&amp;rsquo;ll explore how implementing the &lt;code&gt;Deref&lt;/code&gt; trait makes it possible for smart pointers to work in a similar way as references. Then we&amp;rsquo;ll look at Rust&amp;rsquo;s &lt;em&gt;deref coercion&lt;/em&gt; feature and how it lets us work with either references or smart pointers.</source>
          <target state="translated">Veamos primero c&amp;oacute;mo funciona el operador de desreferencia con referencias regulares. Luego, intentaremos definir un tipo personalizado que se comporte como &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y veremos por qu&amp;eacute; el operador de desreferencia no funciona como una referencia en nuestro tipo reci&amp;eacute;n definido. Exploraremos c&amp;oacute;mo la implementaci&amp;oacute;n del rasgo &lt;code&gt;Deref&lt;/code&gt; hace posible que los punteros inteligentes funcionen de manera similar a las referencias. Luego veremos la &lt;em&gt;funci&amp;oacute;n de coerci&amp;oacute;n deref&lt;/em&gt; de Rust y c&amp;oacute;mo nos permite trabajar con referencias o punteros inteligentes.</target>
        </trans-unit>
        <trans-unit id="16b3f7c211345e679774caea38315635e0c83e2f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first look at how the dereference operator works with regular references. Then we&amp;rsquo;ll try to define a custom type that behaves like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and see why the dereference operator doesn&amp;rsquo;t work like a reference on our newly defined type. We&amp;rsquo;ll explore how implementing the &lt;code&gt;Deref&lt;/code&gt; trait makes it possible for smart pointers to work in ways similar to references. Then we&amp;rsquo;ll look at Rust&amp;rsquo;s &lt;em&gt;deref coercion&lt;/em&gt; feature and how it lets us work with either references or smart pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5282924b8e4ccd503b1b10249bbf09058e192d22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started on the implementation of the library! We know we need a public &lt;code&gt;Post&lt;/code&gt; struct that holds some content, so we&amp;rsquo;ll start with the definition of the struct and an associated public &lt;code&gt;new&lt;/code&gt; function to create an instance of &lt;code&gt;Post&lt;/code&gt;, as shown in Listing 17-12. We&amp;rsquo;ll also make a private &lt;code&gt;State&lt;/code&gt; trait. Then &lt;code&gt;Post&lt;/code&gt; will hold a trait object of &lt;code&gt;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; inside an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; in a private field named &lt;code&gt;state&lt;/code&gt;. You&amp;rsquo;ll see why the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is necessary in a bit.</source>
          <target state="translated">&amp;iexcl;Comencemos con la implementaci&amp;oacute;n de la biblioteca! Sabemos que necesitamos una estructura &lt;code&gt;Post&lt;/code&gt; p&amp;uacute;blica que contenga alg&amp;uacute;n contenido, por lo que comenzaremos con la definici&amp;oacute;n de la estructura y una &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n p&amp;uacute;blica asociada para crear una instancia de &lt;code&gt;Post&lt;/code&gt; , como se muestra en el Listado 17-12. Tambi&amp;eacute;n haremos un rasgo &lt;code&gt;State&lt;/code&gt; privado . Luego, &lt;code&gt;Post&lt;/code&gt; contendr&amp;aacute; un objeto de rasgo de &lt;code&gt;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; dentro de una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; en un campo privado llamado &lt;code&gt;state&lt;/code&gt; . Ver&amp;aacute; por qu&amp;eacute; la &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; es necesaria en un momento.</target>
        </trans-unit>
        <trans-unit id="6cf0779362e5e6e79905eb41dbbcf314ec8be6ec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try! First, we&amp;rsquo;ll run our program without the environment variable set and with the query &lt;code&gt;to&lt;/code&gt;, which should match any line that contains the word &amp;ldquo;to&amp;rdquo; in all lowercase:</source>
          <target state="translated">&amp;iexcl;Hagamos un intento! Primero, ejecutaremos nuestro programa sin la variable de entorno configurada y con la consulta &lt;code&gt;to&lt;/code&gt; , que debe coincidir con cualquier l&amp;iacute;nea que contenga la palabra &quot;to&quot; en min&amp;uacute;sculas:</target>
        </trans-unit>
        <trans-unit id="e21e94e46417f5d70be1f74cdc80a0200cf7ab38" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s imagine that a friend of ours is trying to collect all 50 state quarters. While we sort our loose change by coin type, we&amp;rsquo;ll also call out the name of the state associated with each quarter so if it&amp;rsquo;s one our friend doesn&amp;rsquo;t have, they can add it to their collection.</source>
          <target state="translated">Imaginemos que un amigo nuestro est&amp;aacute; tratando de recolectar los 50 cuartos estatales. Mientras clasificamos nuestro cambio suelto por tipo de moneda, tambi&amp;eacute;n llamaremos el nombre del estado asociado con cada trimestre, por lo que si es uno que nuestro amigo no tiene, pueden agregarlo a su colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d46ead76362decf8ea1c4631f151578daeb7b13e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the functionality for returning more than a blank page. Create a new file, &lt;em&gt;hello.html&lt;/em&gt;, in the root of your project directory, not in the &lt;em&gt;src&lt;/em&gt; directory. You can input any HTML you want; Listing 20-4 shows one possibility.</source>
          <target state="translated">Implementemos la funcionalidad para devolver m&amp;aacute;s de una p&amp;aacute;gina en blanco. Cree un nuevo archivo, &lt;em&gt;hello.html&lt;/em&gt; , en la ra&amp;iacute;z del directorio de su proyecto, no en el directorio &lt;em&gt;src&lt;/em&gt; . Puede ingresar cualquier HTML que desee; El listado 20-4 muestra una posibilidad.</target>
        </trans-unit>
        <trans-unit id="875e251ee421cd235e0091a3ea3fc8e405d04cfd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the functionality to read the request from the browser! To separate the concerns of first getting a connection and then taking some action with the connection, we&amp;rsquo;ll start a new function for processing connections. In this new &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ll read data from the TCP stream and print it so we can see the data being sent from the browser. Change the code to look like Listing 20-2.</source>
          <target state="translated">&amp;iexcl;Implementemos la funcionalidad para leer la solicitud desde el navegador! Para separar las preocupaciones de obtener primero una conexi&amp;oacute;n y luego tomar alguna acci&amp;oacute;n con la conexi&amp;oacute;n, iniciaremos una nueva funci&amp;oacute;n para procesar conexiones. En esta nueva funci&amp;oacute;n &lt;code&gt;handle_connection&lt;/code&gt; , leeremos datos de la secuencia TCP y los imprimiremos para que podamos ver los datos que se env&amp;iacute;an desde el navegador. Cambie el c&amp;oacute;digo para que se parezca al Listado 20-2.</target>
        </trans-unit>
        <trans-unit id="b145c020f35d5cf12c1f16d9ae23adffafb9cf49" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s introduce a bug into our code to see what it looks like when a test that uses &lt;code&gt;assert_eq!&lt;/code&gt; fails. Change the implementation of the &lt;code&gt;add_two&lt;/code&gt; function to instead add &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">&amp;iexcl; &lt;code&gt;assert_eq!&lt;/code&gt; un error en nuestro c&amp;oacute;digo para ver c&amp;oacute;mo se ve cuando se realiza una prueba que usa assert_eq! falla. Cambie la implementaci&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;add_two&lt;/code&gt; para agregar &lt;code&gt;3&lt;/code&gt; en su lugar :</target>
        </trans-unit>
        <trans-unit id="1a740028676c8b0002977c98fe2eec37d0bee51d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s introduce a bug into this code by changing &lt;code&gt;greeting&lt;/code&gt; to not include &lt;code&gt;name&lt;/code&gt; to see what this test failure looks like:</source>
          <target state="translated">Introduzcamos un error en este c&amp;oacute;digo cambiando el &lt;code&gt;greeting&lt;/code&gt; para que no incluya el &lt;code&gt;name&lt;/code&gt; para ver c&amp;oacute;mo se ve este error de prueba:</target>
        </trans-unit>
        <trans-unit id="19083fee6a8cc87ffd6b0d04bb94a51935ddddce" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s jump into Rust by working through a hands-on project together! This chapter introduces you to a few common Rust concepts by showing you how to use them in a real program. You&amp;rsquo;ll learn about &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, using external crates, and more! The following chapters will explore these ideas in more detail. In this chapter, you&amp;rsquo;ll practice the fundamentals.</source>
          <target state="translated">&amp;iexcl;Saltemos a Rust trabajando juntos en un proyecto pr&amp;aacute;ctico! Este cap&amp;iacute;tulo le presenta algunos conceptos comunes de Rust mostr&amp;aacute;ndole c&amp;oacute;mo usarlos en un programa real. &amp;iexcl;Aprender&amp;aacute; sobre &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;match&lt;/code&gt; , m&amp;eacute;todos, funciones asociadas, uso de cajas externas y m&amp;aacute;s! Los siguientes cap&amp;iacute;tulos explorar&amp;aacute;n estas ideas con m&amp;aacute;s detalle. En este cap&amp;iacute;tulo, practicar&amp;aacute;s los fundamentos.</target>
        </trans-unit>
        <trans-unit id="63819f186c88b0330ee047bed09e478063cb1dae" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. These are the only possibilities for an IP address that our program will come across: we can &lt;em&gt;enumerate&lt;/em&gt; all possible values, which is where enumeration gets its name.</source>
          <target state="translated">Veamos una situaci&amp;oacute;n que podr&amp;iacute;amos querer expresar en c&amp;oacute;digo y veamos por qu&amp;eacute; las enumeraciones son &amp;uacute;tiles y m&amp;aacute;s apropiadas que las estructuras en este caso. Digamos que necesitamos trabajar con direcciones IP. Actualmente, se utilizan dos est&amp;aacute;ndares principales para las direcciones IP: la versi&amp;oacute;n cuatro y la versi&amp;oacute;n seis. Estas son las &amp;uacute;nicas posibilidades para una direcci&amp;oacute;n IP que nuestro programa encontrar&amp;aacute;: podemos &lt;em&gt;enumerar&lt;/em&gt; todos los valores posibles, que es donde la enumeraci&amp;oacute;n obtiene su nombre.</target>
        </trans-unit>
        <trans-unit id="983a8ae99cfeef9a151c58849d32ffe20aab79f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. These are the only possibilities for an IP address that our program will come across: we can &lt;em&gt;enumerate&lt;/em&gt; all possible variants, which is where enumeration gets its name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b455b737e0cc051701700c07362ed0b4be96ade0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example of what happens when we try to use a refutable pattern where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a &lt;code&gt;let&lt;/code&gt; statement, but for the pattern we&amp;rsquo;ve specified &lt;code&gt;Some(x)&lt;/code&gt;, a refutable pattern. As you might expect, this code will not compile.</source>
          <target state="translated">Veamos un ejemplo de lo que sucede cuando intentamos usar un patr&amp;oacute;n refutable donde Rust requiere un patr&amp;oacute;n irrefutable y viceversa. El listado 18-8 muestra una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; , pero para el patr&amp;oacute;n hemos especificado &lt;code&gt;Some(x)&lt;/code&gt; , un patr&amp;oacute;n refutable. Como era de esperar, este c&amp;oacute;digo no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="18ece25ab1e94beac903ba47f460140cd6525deb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another enum in the standard library that is very common and useful: &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">Veamos otra enumeraci&amp;oacute;n en la biblioteca est&amp;aacute;ndar que es muy com&amp;uacute;n y &amp;uacute;til: &lt;code&gt;Option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5a86e48ba4d029ee5e559b44f91369e39297f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.</source>
          <target state="translated">Veamos otro ejemplo de enumeraci&amp;oacute;n en el Listado 6-2: este tiene una amplia variedad de tipos incrustados en sus variantes.</target>
        </trans-unit>
        <trans-unit id="eb252b4c369cd56d53d91f13fd045947d1bc97a2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example to see what it&amp;rsquo;s like when a &lt;code&gt;panic!&lt;/code&gt; call comes from a library because of a bug in our code instead of from our code calling the macro directly. Listing 9-1 has some code that attempts to access an element by index in a vector.</source>
          <target state="translated">&amp;iexcl;Veamos otro ejemplo para ver c&amp;oacute;mo es cuando &lt;code&gt;panic!&lt;/code&gt; La llamada proviene de una biblioteca debido a un error en nuestro c&amp;oacute;digo en lugar de nuestro c&amp;oacute;digo que llama a la macro directamente. El Listado 9-1 tiene alg&amp;uacute;n c&amp;oacute;digo que intenta acceder a un elemento por &amp;iacute;ndice en un vector.</target>
        </trans-unit>
        <trans-unit id="6282a087fac47a7a9f015495370791f1a001baba" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example, this time using the &lt;code&gt;longest&lt;/code&gt; function that had no lifetime parameters when we started working with it in Listing 10-21:</source>
          <target state="translated">Veamos otro ejemplo, esta vez usando la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; que no ten&amp;iacute;a par&amp;aacute;metros de duraci&amp;oacute;n cuando comenzamos a trabajar con ella en el Listado 10-21:</target>
        </trans-unit>
        <trans-unit id="79d263a7d612b559cee379001fac98bd72d76b84" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example:</source>
          <target state="translated">Veamos otro ejemplo:</target>
        </trans-unit>
        <trans-unit id="4d45845f16951bf95eef2bf35703a5d1765d659f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at each of the five unsafe superpowers in turn. We&amp;rsquo;ll also look at some abstractions that provide a safe interface to unsafe code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b25580ad4eac065cdf4b9269d34a342f40133" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at each of the four unsafe superpowers in turn. We&amp;rsquo;ll also look at some abstractions that provide a safe interface to unsafe code.</source>
          <target state="translated">Echemos un vistazo a cada una de las cuatro superpotencias inseguras. Tambi&amp;eacute;n veremos algunas abstracciones que proporcionan una interfaz segura para c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="df2bdcb8a48c5ab6b335860afc48b8bc078015c4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how a reference cycle might happen and how to prevent it, starting with the definition of the &lt;code&gt;List&lt;/code&gt; enum and a &lt;code&gt;tail&lt;/code&gt; method in Listing 15-25:</source>
          <target state="translated">Veamos c&amp;oacute;mo podr&amp;iacute;a ocurrir un ciclo de referencia y c&amp;oacute;mo prevenirlo, comenzando con la definici&amp;oacute;n de la enumeraci&amp;oacute;n &lt;code&gt;List&lt;/code&gt; y un m&amp;eacute;todo de &lt;code&gt;tail&lt;/code&gt; en el Listado 15-25:</target>
        </trans-unit>
        <trans-unit id="0944037c3cfba2d633f74e95d90cd2030445a3ef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how the &lt;code&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt; values of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; instances change by creating a new inner scope and moving the creation of &lt;code&gt;branch&lt;/code&gt; into that scope. By doing so, we can see what happens when &lt;code&gt;branch&lt;/code&gt; is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29:</source>
          <target state="translated">Veamos c&amp;oacute;mo &lt;code&gt;weak_count&lt;/code&gt; valores de cuenta &lt;code&gt;strong_count&lt;/code&gt; y cuenta d&amp;eacute;bil de las instancias de &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; creando un nuevo alcance interno y moviendo la creaci&amp;oacute;n de la &lt;code&gt;branch&lt;/code&gt; a ese alcance. Al hacerlo, podemos ver qu&amp;eacute; sucede cuando se crea la &lt;code&gt;branch&lt;/code&gt; y luego se elimina cuando sale del alcance. Las modificaciones se muestran en el Listado 15-29:</target>
        </trans-unit>
        <trans-unit id="cefbc5ea6d98c6566c78f52ee80e603c9ecbe131" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how the lifetime annotations restrict the &lt;code&gt;longest&lt;/code&gt; function by passing in references that have different concrete lifetimes. Listing 10-23 is a straightforward example.</source>
          <target state="translated">Veamos c&amp;oacute;mo las anotaciones de duraci&amp;oacute;n restringen la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; al pasar referencias que tienen distintas duraciones concretas. El listado 10-23 es un ejemplo sencillo.</target>
        </trans-unit>
        <trans-unit id="2d907807641db37c8b548f8e680fff80ec47014d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how this works with an example that uses the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum:</source>
          <target state="translated">Veamos c&amp;oacute;mo funciona esto con un ejemplo que usa la enumeraci&amp;oacute;n &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; la biblioteca est&amp;aacute;ndar :</target>
        </trans-unit>
        <trans-unit id="017d18fbfa7c60f454e03eabc7d8ac1aa92c2937" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at the different kinds of procedural macros. We&amp;rsquo;ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.</source>
          <target state="translated">Veamos los diferentes tipos de macros de procedimiento. Comenzaremos con una macro de derivaci&amp;oacute;n personalizada y luego explicaremos las peque&amp;ntilde;as diferencias que hacen que las otras formas sean diferentes.</target>
        </trans-unit>
        <trans-unit id="47696a65864265aca3d18b3b28f87964618b9312" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at the features Rust provides specifically for writing tests that take these actions, which include the &lt;code&gt;test&lt;/code&gt; attribute, a few macros, and the &lt;code&gt;should_panic&lt;/code&gt; attribute.</source>
          <target state="translated">Veamos las caracter&amp;iacute;sticas que Rust proporciona espec&amp;iacute;ficamente para escribir pruebas que realizan estas acciones, que incluyen el atributo de &lt;code&gt;test&lt;/code&gt; , algunas macros y el atributo &lt;code&gt;should_panic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9e9db94ec59c60082aa0b5bcf4f78e81ff1885" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at what happens if we use the &lt;code&gt;?&lt;/code&gt; operator in the &lt;code&gt;main&lt;/code&gt; function, which you&amp;rsquo;ll recall has a return type of &lt;code&gt;()&lt;/code&gt;:</source>
          <target state="translated">Veamos qu&amp;eacute; sucede si usamos el &lt;code&gt;?&lt;/code&gt; operador en la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; , que recordar&amp;aacute; tiene un tipo de retorno de &lt;code&gt;()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="994a941f48d3bb1b233dbddd0cea3be0ad22a0a6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make a new binary project with Cargo called &lt;em&gt;rectangles&lt;/em&gt; that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 5-8 shows a short program with one way of doing exactly that in our project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">Hagamos un nuevo proyecto binario con Cargo llamado &lt;em&gt;rect&amp;aacute;ngulos&lt;/em&gt; que tomar&amp;aacute; el ancho y alto de un rect&amp;aacute;ngulo especificado en p&amp;iacute;xeles y calcular&amp;aacute; el &amp;aacute;rea del rect&amp;aacute;ngulo. El Listado 5-8 muestra un programa corto con una forma de hacer exactamente eso en &lt;em&gt;src / main.rs de&lt;/em&gt; nuestro proyecto .</target>
        </trans-unit>
        <trans-unit id="c3c6a3325302ea36dd5b079af7f9dcc2a96f2a1b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make the following changes to what happens when we create a &lt;code&gt;ThreadPool&lt;/code&gt;. We&amp;rsquo;ll implement the code that sends the closure to the thread after we have &lt;code&gt;Worker&lt;/code&gt; set up in this way:</source>
          <target state="translated">Hagamos los siguientes cambios en lo que sucede cuando creamos un &lt;code&gt;ThreadPool&lt;/code&gt; . Implementaremos el c&amp;oacute;digo que env&amp;iacute;a el cierre al hilo despu&amp;eacute;s de haber configurado &lt;code&gt;Worker&lt;/code&gt; de esta manera:</target>
        </trans-unit>
        <trans-unit id="d6f3986ccdbd0c969d703b2cf489c2df505e5f38" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move all the code that isn&amp;rsquo;t the &lt;code&gt;main&lt;/code&gt; function from &lt;em&gt;src/main.rs&lt;/em&gt; to &lt;em&gt;src/lib.rs&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Muevamos&lt;/em&gt; todo el c&amp;oacute;digo que no es la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; de &lt;em&gt;src / main.rs&lt;/em&gt; a &lt;em&gt;src / lib.rs&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="e0993d86e241fd6659cd1a45b6773ecb8b7a697f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move on and talk about the module system!</source>
          <target state="translated">&amp;iexcl;Sigamos adelante y hablemos del sistema de m&amp;oacute;dulos!</target>
        </trans-unit>
        <trans-unit id="a8ee98777403910d66295d417b2df29ea314fb29" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move the transmitting end into a spawned thread and have it send one string so the spawned thread is communicating with the main thread, as shown in Listing 16-7. This is like putting a rubber duck in the river upstream or sending a chat message from one thread to another.</source>
          <target state="translated">Muevamos el extremo transmisor a un hilo generado y hagamos que env&amp;iacute;e una cadena para que el hilo generado se comunique con el hilo principal, como se muestra en el Listado 16-7. Esto es como poner un pato de goma en el r&amp;iacute;o r&amp;iacute;o arriba o enviar un mensaje de chat de un hilo a otro.</target>
        </trans-unit>
        <trans-unit id="7d7bc5a1faae0876b47946a48ddda878ed24b40e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice using methods by implementing a second method on the &lt;code&gt;Rectangle&lt;/code&gt; struct. This time, we want an instance of &lt;code&gt;Rectangle&lt;/code&gt; to take another instance of &lt;code&gt;Rectangle&lt;/code&gt; and return &lt;code&gt;true&lt;/code&gt; if the second &lt;code&gt;Rectangle&lt;/code&gt; can fit completely within &lt;code&gt;self&lt;/code&gt;; otherwise it should return &lt;code&gt;false&lt;/code&gt;. That is, we want to be able to write the program shown in Listing 5-14, once we&amp;rsquo;ve defined the &lt;code&gt;can_hold&lt;/code&gt; method.</source>
          <target state="translated">Practiquemos el uso de m&amp;eacute;todos implementando un segundo m&amp;eacute;todo en la estructura &lt;code&gt;Rectangle&lt;/code&gt; . Esta vez, queremos que una instancia de &lt;code&gt;Rectangle&lt;/code&gt; tome otra instancia de &lt;code&gt;Rectangle&lt;/code&gt; y devuelva &lt;code&gt;true&lt;/code&gt; si el segundo &lt;code&gt;Rectangle&lt;/code&gt; puede caber completamente dentro de &lt;code&gt;self&lt;/code&gt; ; de lo contrario, deber&amp;iacute;a devolver &lt;code&gt;false&lt;/code&gt; . Es decir, queremos poder escribir el programa que se muestra en el Listado 5-14, una vez que hayamos definido el m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f6a747ae7e60532bbff7c109c117027e46d5672" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s pretend we&amp;rsquo;re the compiler. We&amp;rsquo;ll apply these rules to figure out what the lifetimes of the references in the signature of the &lt;code&gt;first_word&lt;/code&gt; function in Listing 10-26 are. The signature starts without any lifetimes associated with the references:</source>
          <target state="translated">Supongamos que somos el compilador. Aplicaremos estas reglas para averiguar cu&amp;aacute;l es la duraci&amp;oacute;n de las referencias en la firma de la funci&amp;oacute;n &lt;code&gt;first_word&lt;/code&gt; en el Listado 10-26. La firma comienza sin ning&amp;uacute;n per&amp;iacute;odo de vida asociado con las referencias:</target>
        </trans-unit>
        <trans-unit id="93c702edd44f0391f6b49bca85a25bb1c08f5ed4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s program the game to quit when the user wins by adding a &lt;code&gt;break&lt;/code&gt; statement:</source>
          <target state="translated">Programemos el juego para que se cierre cuando el usuario gane agregando una declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37e690afeb6a44a19f29feff1bce10a2708fa622" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s re-implement the counter iterator from &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;:</source>
          <target state="translated">Reimplementemos el iterador de contador de la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel&lt;/a&gt; de m&amp;oacute;dulo :</target>
        </trans-unit>
        <trans-unit id="12315912398a998ea0c31348f27e33b72d707ec2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what we&amp;rsquo;ve discussed about references:</source>
          <target state="translated">Recapitulemos lo que hemos discutido sobre las referencias:</target>
        </trans-unit>
        <trans-unit id="28953519c0667e1646cf53e71f06f86d4e114c07" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what we&amp;rsquo;ve learned so far about Cargo:</source>
          <target state="translated">Recapitulemos lo que hemos aprendido hasta ahora sobre Cargo:</target>
        </trans-unit>
        <trans-unit id="2c9a7290077df3cf275a9a0becb103de92fc4b1c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our cons list example in Listing 15-5. Recall that we defined it using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. This time, we&amp;rsquo;ll create two lists that both share ownership of a third list. Conceptually, this looks similar to Figure 15-3:</source>
          <target state="translated">Regresemos a nuestro ejemplo de lista de contras en el Listado 15-5. Recuerde que lo definimos usando &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . Esta vez, crearemos dos listas que comparten la propiedad de una tercera lista. Conceptualmente, esto se parece a la Figura 15-3:</target>
        </trans-unit>
        <trans-unit id="4d5406eb80899f442e99be52053a8af746acbb33" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our example: &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; have the same API, so we fix our program by changing the &lt;code&gt;use&lt;/code&gt; line, the call to &lt;code&gt;new&lt;/code&gt;, and the call to &lt;code&gt;clone&lt;/code&gt;. The code in Listing 16-15 will finally compile and run:</source>
          <target state="translated">Volvamos a nuestro ejemplo: &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; tienen la misma API, as&amp;iacute; que arreglamos nuestro programa cambiando la l&amp;iacute;nea de &lt;code&gt;use&lt;/code&gt; , la llamada a &lt;code&gt;new&lt;/code&gt; y la llamada a &lt;code&gt;clone&lt;/code&gt; . El c&amp;oacute;digo del Listado 16-15 finalmente se compilar&amp;aacute; y ejecutar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="38b65fe4b5d3898a7fcecb397aa7533be4bdc414" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our workout generation app. In Listing 13-6, our code was still calling the expensive calculation closure more times than it needed to. One option to solve this issue is to save the result of the expensive closure in a variable for reuse and use the variable in each place we need the result, instead of calling the closure again. However, this method could result in a lot of repeated code.</source>
          <target state="translated">Volvamos a nuestra aplicaci&amp;oacute;n de generaci&amp;oacute;n de ejercicios. En el Listado 13-6, nuestro c&amp;oacute;digo segu&amp;iacute;a llamando al cierre de c&amp;aacute;lculo costoso m&amp;aacute;s veces de las necesarias. Una opci&amp;oacute;n para resolver este problema es guardar el resultado del cierre costoso en una variable para reutilizarlo y usar la variable en cada lugar donde necesitemos el resultado, en lugar de volver a llamar al cierre. Sin embargo, este m&amp;eacute;todo podr&amp;iacute;a resultar en una gran cantidad de c&amp;oacute;digo repetido.</target>
        </trans-unit>
        <trans-unit id="42c033ee17d1839060442674688298fa9208193f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the error in Listing 7-4 that told us the &lt;code&gt;hosting&lt;/code&gt; module is private. We want the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function in the parent module to have access to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in the child module, so we mark the &lt;code&gt;hosting&lt;/code&gt; module with the &lt;code&gt;pub&lt;/code&gt; keyword, as shown in Listing 7-5.</source>
          <target state="translated">Regresemos al error del Listado 7-4 que nos dijo que el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; es privado. Queremos que la funci&amp;oacute;n &lt;code&gt;eat_at_restaurant&lt;/code&gt; en el m&amp;oacute;dulo padre tenga acceso a la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; en el m&amp;oacute;dulo hijo, por lo que marcamos el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; con el &lt;code&gt;pub&lt;/code&gt; palabra clave , como se muestra en el Listado 7-5.</target>
        </trans-unit>
        <trans-unit id="f0f51e7669e18c0438bddca7e592dae1d7afb926" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the example in Listing 7-1. How do we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? This is the same as asking, what&amp;rsquo;s the path of the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? In Listing 7-3, we simplified our code a bit by removing some of the modules and functions. We&amp;rsquo;ll show two ways to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function from a new function &lt;code&gt;eat_at_restaurant&lt;/code&gt; defined in the crate root. The &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is part of our library crate&amp;rsquo;s public API, so we mark it with the &lt;code&gt;pub&lt;/code&gt; keyword. In the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&amp;rdquo;Exposing Paths with the &lt;code&gt;pub&lt;/code&gt; Keyword&amp;rdquo;&lt;/a&gt; section, we&amp;rsquo;ll go into more detail about &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">Regresemos al ejemplo del Listado 7-1. &amp;iquest;C&amp;oacute;mo llamamos a la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; ? Esto es lo mismo que preguntar, &amp;iquest;cu&amp;aacute;l es la ruta de la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; ? En el Listado 7-3, simplificamos un poco nuestro c&amp;oacute;digo eliminando algunos de los m&amp;oacute;dulos y funciones. &lt;code&gt;add_to_waitlist&lt;/code&gt; dos formas de llamar a la funci&amp;oacute;n add_to_waitlist desde una nueva funci&amp;oacute;n &lt;code&gt;eat_at_restaurant&lt;/code&gt; definida en la ra&amp;iacute;z de la caja. La funci&amp;oacute;n &lt;code&gt;eat_at_restaurant&lt;/code&gt; es parte de la API p&amp;uacute;blica de nuestra biblioteca, por lo que la marcamos con la palabra clave &lt;code&gt;pub&lt;/code&gt; . En la secci&amp;oacute;n &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&quot;Exponer rutas con la palabra clave &lt;code&gt;pub&lt;/code&gt; &quot;&lt;/a&gt; , entraremos en m&amp;aacute;s detalles sobre &lt;code&gt;pub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5708c518fe3a8a47dd6a9247e9757413e4ab26a1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the example in Listing 7-1. How do we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? This is the same as asking, what&amp;rsquo;s the path of the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? In Listing 7-3, we simplified our code a bit by removing some of the modules and functions. We&amp;rsquo;ll show two ways to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function from a new function &lt;code&gt;eat_at_restaurant&lt;/code&gt; defined in the crate root. The &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is part of our library crate&amp;rsquo;s public API, so we mark it with the &lt;code&gt;pub&lt;/code&gt; keyword. In the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&amp;rdquo;Exposing Paths with the &lt;code&gt;pub&lt;/code&gt; Keyword&amp;rdquo;&lt;/a&gt; section, we&amp;rsquo;ll go into more detail about &lt;code&gt;pub&lt;/code&gt;. Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477b6d3273f07c6abd6b664ce37ceef78d0f7dbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the guessing game program. You now know that &lt;code&gt;let mut guess&lt;/code&gt; will introduce a mutable variable named &lt;code&gt;guess&lt;/code&gt;. On the other side of the equal sign (&lt;code&gt;=&lt;/code&gt;) is the value that &lt;code&gt;guess&lt;/code&gt; is bound to, which is the result of calling &lt;code&gt;String::new&lt;/code&gt;, a function that returns a new instance of a &lt;code&gt;String&lt;/code&gt;. &lt;a href=&quot;../std/string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a string type provided by the standard library that is a growable, UTF-8 encoded bit of text.</source>
          <target state="translated">Volvamos al programa del juego de adivinanzas. Ahora sabe que &lt;code&gt;let mut guess&lt;/code&gt; introducir&amp;aacute; una variable mutable llamada &lt;code&gt;guess&lt;/code&gt; . En el otro lado del signo igual ( &lt;code&gt;=&lt;/code&gt; ) es el valor que &lt;code&gt;guess&lt;/code&gt; est&amp;aacute; obligado a, que es el resultado de la llamada &lt;code&gt;String::new&lt;/code&gt; , una funci&amp;oacute;n que devuelve una nueva instancia de una &lt;code&gt;String&lt;/code&gt; . &lt;a href=&quot;../std/string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; es un tipo de cadena proporcionado por la biblioteca est&amp;aacute;ndar que es un bit de texto codificado en UTF-8 que puede crecer.</target>
        </trans-unit>
        <trans-unit id="1b391440eed0071039b3e089734bb6dbffc57331" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s review in detail what just happened in your &amp;ldquo;Hello, world!&amp;rdquo; program. Here&amp;rsquo;s the first piece of the puzzle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9b8de2d5b44130b83fee9c1ecdc0d98e51930d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s review in detail what just happened in your Hello, world! program. Here&amp;rsquo;s the first piece of the puzzle:</source>
          <target state="translated">Repasemos en detalle lo que acaba de pasar en su &amp;iexcl;Hola, mundo! programa. Aqu&amp;iacute; est&amp;aacute; la primera pieza del rompecabezas:</target>
        </trans-unit>
        <trans-unit id="158e58c1e56ad7bd97dd01d2a60cf00e419cdf7a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the program again with arguments that don&amp;rsquo;t cause an error but still redirect standard output to a file, like so:</source>
          <target state="translated">Ejecutemos el programa nuevamente con argumentos que no causen un error pero que a&amp;uacute;n redirijan la salida est&amp;aacute;ndar a un archivo, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="c402a40660ac8a0f30bee1587ae0160a6f7fa3c1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the program now!</source>
          <target state="translated">&amp;iexcl;Ejecutemos el programa ahora!</target>
        </trans-unit>
        <trans-unit id="a23620a8daca09feb45d362acea31eb531fda8ce" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run this code with any string as the first command line argument (because we haven&amp;rsquo;t implemented the searching part yet) and the &lt;em&gt;poem.txt&lt;/em&gt; file as the second argument:</source>
          <target state="translated">Ejecutemos este c&amp;oacute;digo con cualquier cadena como primer argumento de la l&amp;iacute;nea de comando (porque a&amp;uacute;n no hemos implementado la parte de b&amp;uacute;squeda) y el &lt;em&gt;poema.txt&lt;/em&gt; archivo como segundo argumento:</target>
        </trans-unit>
        <trans-unit id="a00a1c9672a401c35b2df73be4edbb0185a8d666" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say a regression is found. Good thing we had some time to test the beta release before the regression snuck into a stable release! The fix is applied to &lt;code&gt;master&lt;/code&gt;, so that nightly is fixed, and then the fix is backported to the &lt;code&gt;beta&lt;/code&gt; branch, and a new release of beta is produced:</source>
          <target state="translated">Digamos que se encuentra una regresi&amp;oacute;n. &amp;iexcl;Menos mal que tuvimos algo de tiempo para probar la versi&amp;oacute;n beta antes de que la regresi&amp;oacute;n se colara en una versi&amp;oacute;n estable! La correcci&amp;oacute;n se aplica al &lt;code&gt;master&lt;/code&gt; , de modo que todas las noches se corrige, y luego la correcci&amp;oacute;n se retroporta a la rama &lt;code&gt;beta&lt;/code&gt; y se produce una nueva versi&amp;oacute;n beta:</target>
        </trans-unit>
        <trans-unit id="9f9ce6103baa4662da2c83f8f5cc76efdcd0525f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we want to write a function that takes an &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; and, if there&amp;rsquo;s a value inside, adds 1 to that value. If there isn&amp;rsquo;t a value inside, the function should return the &lt;code&gt;None&lt;/code&gt; value and not attempt to perform any operations.</source>
          <target state="translated">Digamos que queremos escribir una funci&amp;oacute;n que tome una &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; y, si hay un valor dentro, agregue 1 a ese valor. Si no hay un valor dentro, la funci&amp;oacute;n debe devolver el valor &lt;code&gt;None&lt;/code&gt; y no intentar realizar ninguna operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2d4331831e839f96e4320b04d84f9d160c78c289" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a variable of type &lt;code&gt;u8&lt;/code&gt; that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, &lt;em&gt;integer overflow&lt;/em&gt; will occur. Rust has some interesting rules involving this behavior. When you&amp;rsquo;re compiling in debug mode, Rust includes checks for integer overflow that cause your program to &lt;em&gt;panic&lt;/em&gt; at runtime if this behavior occurs. Rust uses the term panicking when a program exits with an error; we&amp;rsquo;ll discuss panics in more depth in the &lt;a href=&quot;ch09-01-unrecoverable-errors-with-panic&quot;&gt;&amp;ldquo;Unrecoverable Errors with &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section in Chapter 9.</source>
          <target state="translated">Digamos que tiene una variable de tipo &lt;code&gt;u8&lt;/code&gt; que puede contener valores entre 0 y 255. Si intenta cambiar la variable a un valor fuera de ese rango, como 256, se producir&amp;aacute; un &lt;em&gt;desbordamiento de enteros&lt;/em&gt; . Rust tiene algunas reglas interesantes que involucran este comportamiento. Cuando est&amp;aacute; compilando en modo de depuraci&amp;oacute;n, Rust incluye comprobaciones de desbordamiento de enteros que hacen que su programa entre en &lt;em&gt;p&amp;aacute;nico&lt;/em&gt; en tiempo de ejecuci&amp;oacute;n si ocurre este comportamiento. Rust usa el t&amp;eacute;rmino entrar en p&amp;aacute;nico cuando un programa sale con un error; discutiremos los p&amp;aacute;nicos con m&amp;aacute;s profundidad en el &lt;a href=&quot;ch09-01-unrecoverable-errors-with-panic&quot;&gt;cap&amp;iacute;tulo &amp;ldquo;&amp;iexcl;Errores irrecuperables con &lt;code&gt;panic!&lt;/code&gt; &amp;rdquo;&lt;/a&gt; En el Cap&amp;iacute;tulo 9.</target>
        </trans-unit>
        <trans-unit id="f0e1d796103ec14a5789c6d54a9113a4a736b9aa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see if this implementation passes the tests:</source>
          <target state="translated">Veamos si esta implementaci&amp;oacute;n pasa las pruebas:</target>
        </trans-unit>
        <trans-unit id="e75f56bc99e0b08a29707c986c241848f766cec0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see what happens when we try to implement &lt;code&gt;OutlinePrint&lt;/code&gt; on a type that doesn&amp;rsquo;t implement &lt;code&gt;Display&lt;/code&gt;, such as the &lt;code&gt;Point&lt;/code&gt; struct:</source>
          <target state="translated">Veamos qu&amp;eacute; sucede cuando intentamos implementar &lt;code&gt;OutlinePrint&lt;/code&gt; en un tipo que no implementa &lt;code&gt;Display&lt;/code&gt; , como la estructura &lt;code&gt;Point&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c59bb772f42d6153c276f779685fbcbc51239a51" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new binary project named &lt;em&gt;functions&lt;/em&gt; to explore functions further. Place the &lt;code&gt;another_function&lt;/code&gt; example in &lt;em&gt;src/main.rs&lt;/em&gt; and run it. You should see the following output:</source>
          <target state="translated">Comencemos un nuevo proyecto binario llamado &lt;em&gt;funciones&lt;/em&gt; para explorar m&amp;aacute;s funciones. Coloque el ejemplo &lt;code&gt;another_function&lt;/code&gt; en &lt;em&gt;src / main.rs&lt;/em&gt; y ejec&amp;uacute;telo. Deber&amp;iacute;a ver el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="97cf07881b2328430539d964be0df2b91b35c6ed" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a channel in &lt;code&gt;ThreadPool::new&lt;/code&gt; and holding the sending side in the &lt;code&gt;ThreadPool&lt;/code&gt; instance, as shown in Listing 20-16. The &lt;code&gt;Job&lt;/code&gt; struct doesn&amp;rsquo;t hold anything for now but will be the type of item we&amp;rsquo;re sending down the channel.</source>
          <target state="translated">Comencemos creando un canal en &lt;code&gt;ThreadPool::new&lt;/code&gt; y manteniendo el lado de env&amp;iacute;o en la instancia de &lt;code&gt;ThreadPool&lt;/code&gt; , como se muestra en el Listado 20-16. La estructura de &lt;code&gt;Job&lt;/code&gt; no contiene nada por ahora, pero ser&amp;aacute; el tipo de elemento que enviaremos por el canal.</target>
        </trans-unit>
        <trans-unit id="bf13023ab8a50a9cde566fb86f6034b24ede9e80" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with implementing &lt;code&gt;Drop&lt;/code&gt; on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-22 shows a first attempt at a &lt;code&gt;Drop&lt;/code&gt; implementation; this code won&amp;rsquo;t quite work yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590a1a269af356fe7eb20ade960ec2172988f407" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with implementing &lt;code&gt;Drop&lt;/code&gt; on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-23 shows a first attempt at a &lt;code&gt;Drop&lt;/code&gt; implementation; this code won&amp;rsquo;t quite work yet.</source>
          <target state="translated">Comencemos con la implementaci&amp;oacute;n de &lt;code&gt;Drop&lt;/code&gt; en nuestro grupo de subprocesos. Cuando se suelta el grupo, todos nuestros hilos deben unirse para asegurarse de que terminen su trabajo. El Listado 20-23 muestra un primer intento de implementaci&amp;oacute;n de &lt;code&gt;Drop&lt;/code&gt; ; este c&amp;oacute;digo a&amp;uacute;n no funcionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="17bad3ae86bcd63a6cce044cc99494cc4fff84d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start your Rust journey! There&amp;rsquo;s a lot to learn, but every journey starts somewhere. In this chapter, we&amp;rsquo;ll discuss:</source>
          <target state="translated">&amp;iexcl;Comencemos su viaje por Rust! Hay mucho que aprender, pero cada viaje comienza en alguna parte. En este cap&amp;iacute;tulo, discutiremos:</target>
        </trans-unit>
        <trans-unit id="0457bf0b3ac99ac66b1f341140a99488a66fb382" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s switch to something a bit less complex: hash maps!</source>
          <target state="translated">Cambiemos a algo un poco menos complejo: &amp;iexcl;mapas hash!</target>
        </trans-unit>
        <trans-unit id="27749ea9200d1a0f4c7054bf492ec3c0b20e784f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at exactly what&amp;rsquo;s happening at each stage of our &lt;code&gt;dangle&lt;/code&gt; code:</source>
          <target state="translated">Echemos un vistazo m&amp;aacute;s de cerca a lo que est&amp;aacute; sucediendo exactamente en cada etapa de nuestro c&amp;oacute;digo &lt;code&gt;dangle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7d9a8307e36aca49fe8db4d93f11fe8c7cef9311" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at the function call here:</source>
          <target state="translated">Echemos un vistazo m&amp;aacute;s de cerca a la llamada a la funci&amp;oacute;n aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="9a0c63ba49eeceb9940e6cb267159151436db7f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: we&amp;rsquo;ll write some tests!</source>
          <target state="translated">Aprovechemos esta modularidad reci&amp;eacute;n descubierta haciendo algo que hubiera sido dif&amp;iacute;cil con el c&amp;oacute;digo anterior pero es f&amp;aacute;cil con el nuevo c&amp;oacute;digo: &amp;iexcl;escribiremos algunas pruebas!</target>
        </trans-unit>
        <trans-unit id="1e8a01207efa7ffcc3d9fbd6fc8377d0a2bd28de" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the idea of using Rust&amp;rsquo;s type system to ensure we have a valid value one step further and look at creating a custom type for validation. Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user&amp;rsquo;s guess was between those numbers before checking it against our secret number; we only validated that the guess was positive. In this case, the consequences were not very dire: our output of &amp;ldquo;Too high&amp;rdquo; or &amp;ldquo;Too low&amp;rdquo; would still be correct. But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when a user guesses a number that&amp;rsquo;s out of range versus when a user types, for example, letters instead.</source>
          <target state="translated">Tomemos la idea de usar el sistema de tipos de Rust para asegurarnos de que tenemos un valor v&amp;aacute;lido un paso m&amp;aacute;s all&amp;aacute; y consideremos la creaci&amp;oacute;n de un tipo personalizado para la validaci&amp;oacute;n. Recuerde el juego de adivinanzas del cap&amp;iacute;tulo 2 en el que nuestro c&amp;oacute;digo le ped&amp;iacute;a al usuario que adivinara un n&amp;uacute;mero entre 1 y 100. Nunca validamos que la suposici&amp;oacute;n del usuario estuviera entre esos n&amp;uacute;meros antes de compararla con nuestro n&amp;uacute;mero secreto; solo validamos que la suposici&amp;oacute;n fue positiva. En este caso, las consecuencias no fueron muy graves: nuestra salida de &quot;Demasiado alto&quot; o &quot;Demasiado bajo&quot; a&amp;uacute;n ser&amp;iacute;a correcta. Pero ser&amp;iacute;a una mejora &amp;uacute;til para guiar al usuario hacia conjeturas v&amp;aacute;lidas y tener un comportamiento diferente cuando un usuario adivina un n&amp;uacute;mero que est&amp;aacute; fuera de rango en comparaci&amp;oacute;n con cuando un usuario escribe, por ejemplo, letras.</target>
        </trans-unit>
        <trans-unit id="10bbc468cc51314953c3274a9c50cb0da6662c26" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s test the first part of the guessing game. Run it using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">Probemos la primera parte del juego de adivinanzas. Ejec&amp;uacute;telo usando &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f2f9297e2dc6cf0f3bff432893229470763f14d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about the signature of this function:</source>
          <target state="translated">Pensemos en la firma de esta funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="0e370a4cd7c7ee7160c1da9e21eeb3426aa051c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try adding the &lt;code&gt;main&lt;/code&gt; function in Listing 15-7 to Listing 15-8 and changing it to use the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;ve defined instead of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. The code in Listing 15-9 won&amp;rsquo;t compile because Rust doesn&amp;rsquo;t know how to dereference &lt;code&gt;MyBox&lt;/code&gt;.</source>
          <target state="translated">Intentemos agregar la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; en el Listado 15-7 al Listado 15-8 y cambiarla para usar el tipo &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; que hemos definido en lugar de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . El c&amp;oacute;digo del Listado 15-9 no se compilar&amp;aacute; porque Rust no sabe c&amp;oacute;mo &lt;code&gt;MyBox&lt;/code&gt; referencia a MyBox .</target>
        </trans-unit>
        <trans-unit id="f6856c71f770128395912c9e4d84ed22f9c2d61c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try calling &lt;code&gt;panic!&lt;/code&gt; in a simple program:</source>
          <target state="translated">&amp;iexcl;Intentemos llamar al &lt;code&gt;panic!&lt;/code&gt; en un programa simple:</target>
        </trans-unit>
        <trans-unit id="495c15a2fcdcf4917d9c1bfab9452d52f6946a12" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try changing the value of &lt;code&gt;number&lt;/code&gt; to a value that makes the condition &lt;code&gt;false&lt;/code&gt; to see what happens:</source>
          <target state="translated">Intentemos cambiar el valor del &lt;code&gt;number&lt;/code&gt; a un valor que haga que la condici&amp;oacute;n sea &lt;code&gt;false&lt;/code&gt; para ver qu&amp;eacute; sucede:</target>
        </trans-unit>
        <trans-unit id="7e7646ea7f3a1ac4db23658ee4f242a38dc0f2d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try it! The &lt;code&gt;println!&lt;/code&gt; macro call will now look like &lt;code&gt;println!(&quot;rect1 is {:?}&quot;, rect1);&lt;/code&gt;. Putting the specifier &lt;code&gt;:?&lt;/code&gt; inside the curly brackets tells &lt;code&gt;println!&lt;/code&gt; we want to use an output format called &lt;code&gt;Debug&lt;/code&gt;. The &lt;code&gt;Debug&lt;/code&gt; trait enables us to print our struct in a way that is useful for developers so we can see its value while we&amp;rsquo;re debugging our code.</source>
          <target state="translated">&amp;iexcl;Vamos a intentarlo! &amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; la llamada a macro ahora se ver&amp;aacute; como &lt;code&gt;println!(&quot;rect1 is {:?}&quot;, rect1);&lt;/code&gt; . Poniendo el especificador &lt;code&gt;:?&lt;/code&gt; dentro de los corchetes dice &lt;code&gt;println!&lt;/code&gt; queremos usar un formato de salida llamado &lt;code&gt;Debug&lt;/code&gt; . El rasgo &lt;code&gt;Debug&lt;/code&gt; nos permite imprimir nuestra estructura de una manera que sea &amp;uacute;til para los desarrolladores para que podamos ver su valor mientras depuramos nuestro c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="bd95d7f3d11c94bb095fdce37f40a8188a0a9f0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try passing a receiving end of the channel into each worker as the thread pool creates the channel. We know we want to use the receiving end in the thread that the workers spawn, so we&amp;rsquo;ll reference the &lt;code&gt;receiver&lt;/code&gt; parameter in the closure. The code in Listing 20-17 won&amp;rsquo;t quite compile yet.</source>
          <target state="translated">Intentemos pasar un extremo receptor del canal a cada trabajador a medida que el grupo de subprocesos crea el canal. Sabemos que queremos usar el extremo receptor en el hilo que generan los trabajadores, por lo que haremos referencia al par&amp;aacute;metro del &lt;code&gt;receiver&lt;/code&gt; en el cierre. El c&amp;oacute;digo del Listado 20-17 a&amp;uacute;n no se compilar&amp;aacute; del todo.</target>
        </trans-unit>
        <trans-unit id="1369c278ca19b1e056ddf12681c203bea51b902a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try running this code! Invoke &lt;code&gt;cargo run&lt;/code&gt; in the terminal and then load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser. The browser should show an error message like &amp;ldquo;Connection reset,&amp;rdquo; because the server isn&amp;rsquo;t currently sending back any data. But when you look at your terminal, you should see several messages that were printed when the browser connected to the server!</source>
          <target state="translated">&amp;iexcl;Intentemos ejecutar este c&amp;oacute;digo! Invoque la &lt;code&gt;cargo run&lt;/code&gt; en la terminal y luego cargue &lt;em&gt;127.0.0.1:7878&lt;/em&gt; en un navegador web. El navegador deber&amp;iacute;a mostrar un mensaje de error como &quot;Conexi&amp;oacute;n restablecida&quot;, porque el servidor no est&amp;aacute; enviando ning&amp;uacute;n dato en ese momento. Pero cuando miras tu terminal, deber&amp;iacute;as ver varios mensajes que se imprimieron cuando el navegador se conect&amp;oacute; al servidor.</target>
        </trans-unit>
        <trans-unit id="b5df448e7bbf55b42cbf4762a517bb598ff93363" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try running this code. Replace the program currently in your &lt;em&gt;functions&lt;/em&gt; project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file with the preceding example and run it using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">Intentemos ejecutar este c&amp;oacute;digo. Reemplace el programa actualmente en el archivo &lt;em&gt;src / main.rs de&lt;/em&gt; su proyecto de &lt;em&gt;funciones&lt;/em&gt; con el ejemplo anterior y ejec&amp;uacute;telo usando &lt;code&gt;cargo run&lt;/code&gt; :&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41e20d578122ffb945b15f0ad510b73ca09a5d3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try this code! Start the program and make a request in a web browser again. Note that we&amp;rsquo;ll still get an error page in the browser, but our program&amp;rsquo;s output in the terminal will now look similar to this:</source>
          <target state="translated">&amp;iexcl;Probemos este c&amp;oacute;digo! Inicie el programa y vuelva a realizar una solicitud en un navegador web. Tenga en cuenta que todav&amp;iacute;a obtendremos una p&amp;aacute;gina de error en el navegador, pero la salida de nuestro programa en la terminal ahora se ver&amp;aacute; similar a esto:</target>
        </trans-unit>
        <trans-unit id="7cc97ca0df32f4fb1eb75d95da6a337fcd334535" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to compile Listing 7-3 and find out why it won&amp;rsquo;t compile yet! The error we get is shown in Listing 7-4.</source>
          <target state="translated">&amp;iexcl;Intentemos compilar el Listado 7-3 y descubramos por qu&amp;eacute; no se compila todav&amp;iacute;a! El error que obtenemos se muestra en el Listado 7-4.</target>
        </trans-unit>
        <trans-unit id="11ff9da674c818134a4406c35f39622fa04e8cbd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to create a dangling reference, which Rust will prevent with a compile-time error:</source>
          <target state="translated">Intentemos crear una referencia colgante, que Rust evitar&amp;aacute; con un error en tiempo de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ad30420ec21f7046e9cdcc78a94ec41a99a4cd28" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through an example of what would happen with the &lt;code&gt;match&lt;/code&gt; expression used here. Say that the user has guessed 50 and the randomly generated secret number this time is 38. When the code compares 50 to 38, the &lt;code&gt;cmp&lt;/code&gt; method will return &lt;code&gt;Ordering::Greater&lt;/code&gt;, because 50 is greater than 38. The &lt;code&gt;match&lt;/code&gt; expression gets the &lt;code&gt;Ordering::Greater&lt;/code&gt; value and starts checking each arm&amp;rsquo;s pattern. It looks at the first arm&amp;rsquo;s pattern, &lt;code&gt;Ordering::Less&lt;/code&gt;, and sees that the value &lt;code&gt;Ordering::Greater&lt;/code&gt; does not match &lt;code&gt;Ordering::Less&lt;/code&gt;, so it ignores the code in that arm and moves to the next arm. The next arm&amp;rsquo;s pattern, &lt;code&gt;Ordering::Greater&lt;/code&gt;, &lt;em&gt;does&lt;/em&gt; match &lt;code&gt;Ordering::Greater&lt;/code&gt;! The associated code in that arm will execute and print &lt;code&gt;Too big!&lt;/code&gt; to the screen. The &lt;code&gt;match&lt;/code&gt; expression ends because it has no need to look at the last arm in this scenario.</source>
          <target state="translated">Veamos un ejemplo de lo que suceder&amp;iacute;a con la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; que se usa aqu&amp;iacute;. Digamos que el usuario ha adivinado 50 y el n&amp;uacute;mero secreto generado aleatoriamente esta vez es 38. Cuando el c&amp;oacute;digo compara 50 con 38, el m&amp;eacute;todo &lt;code&gt;cmp&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;Ordering::Greater&lt;/code&gt; , porque 50 es mayor que 38. La expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; obtiene el &lt;code&gt;Ordering::Greater&lt;/code&gt; valor y comienza a comprobar el patr&amp;oacute;n de cada brazo. Observa el patr&amp;oacute;n del primer brazo, &lt;code&gt;Ordering::Less&lt;/code&gt; , y ve que el valor &lt;code&gt;Ordering::Greater&lt;/code&gt; no coincide con &lt;code&gt;Ordering::Less&lt;/code&gt; , por lo que ignora el c&amp;oacute;digo de ese brazo y pasa al siguiente brazo. El siguiente patr&amp;oacute;n del brazo, &lt;code&gt;Ordering::Greater&lt;/code&gt; , &lt;em&gt;Hace&lt;/em&gt; partido &lt;code&gt;Ordering::Greater&lt;/code&gt; ! El c&amp;oacute;digo asociado en ese brazo se ejecutar&amp;aacute; e imprimir&amp;aacute; &amp;iexcl; &lt;code&gt;Too big!&lt;/code&gt; a la pantalla. La expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; finaliza porque no es necesario mirar el &amp;uacute;ltimo brazo en este escenario.</target>
        </trans-unit>
        <trans-unit id="7603084911e7c02de0fffb01fc0d07271e8ab207" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through what happens when the &lt;code&gt;match&lt;/code&gt; expression runs. The pattern in the first match arm doesn&amp;rsquo;t match the defined value of &lt;code&gt;x&lt;/code&gt;, so the code continues.</source>
          <target state="translated">Repasemos lo que sucede cuando se ejecuta la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; . El patr&amp;oacute;n en el primer brazo de coincidencia no coincide con el valor definido de &lt;code&gt;x&lt;/code&gt; , por lo que el c&amp;oacute;digo contin&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="9dbd7c7d9a346617c48d1fe6e1ab8464dd12c2ee" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through what happens when we create a package. First, we enter the command &lt;code&gt;cargo new&lt;/code&gt;:</source>
          <target state="translated">Repasemos lo que sucede cuando creamos un paquete. Primero, ingresamos al comando &lt;code&gt;cargo new&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="85979a5d9f34f3050620ce86eda10daa14a1b88f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work on an example of a situation in which it&amp;rsquo;s useful to store a closure to be executed later. Along the way, we&amp;rsquo;ll talk about the syntax of closures, type inference, and traits.</source>
          <target state="translated">Trabajemos en un ejemplo de una situaci&amp;oacute;n en la que es &amp;uacute;til almacenar un cierre para ejecutarlo m&amp;aacute;s tarde. En el camino, hablaremos sobre la sintaxis de los cierres, la inferencia de tipos y los rasgos.</target>
        </trans-unit>
        <trans-unit id="dde68cf723b263931fff6274e2649443a376d09e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work through a practical example where we can use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; to mutate an immutable value and see why that is useful.</source>
          <target state="translated">Trabajemos con un ejemplo pr&amp;aacute;ctico en el que podemos usar &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; para mutar un valor inmutable y ver por qu&amp;eacute; es &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="48386f6d1144155006a32871e15dfe1b9ce157fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work through each step, starting with iterating through lines.</source>
          <target state="translated">Trabajemos en cada paso, comenzando con la iteraci&amp;oacute;n de l&amp;iacute;neas.</target>
        </trans-unit>
        <trans-unit id="a1a52fb721ec0d05f400a261580d4ddb22293c65" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a function that returns the longer of two string slices. This function will take two string slices and return a string slice. After we&amp;rsquo;ve implemented the &lt;code&gt;longest&lt;/code&gt; function, the code in Listing 10-20 should print &lt;code&gt;The longest string is abcd&lt;/code&gt;.</source>
          <target state="translated">Escribamos una funci&amp;oacute;n que devuelva el m&amp;aacute;s largo de dos cortes de cadena. Esta funci&amp;oacute;n tomar&amp;aacute; dos segmentos de cadena y devolver&amp;aacute; un segmento de cadena. Despu&amp;eacute;s de haber implementado la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; , el c&amp;oacute;digo del Listado 10-20 deber&amp;iacute;a imprimirse. &lt;code&gt;The longest string is abcd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31701d3a630b4f1aa08c2b129407ae716eb89b88" translate="yes" xml:space="preserve">
          <source>Let's cover each of those in turn:</source>
          <target state="translated">Cubramos cada uno de ellos por turnos:</target>
        </trans-unit>
        <trans-unit id="4c315b125c5927660bb768b8b3fda2b0a5ee7326" translate="yes" xml:space="preserve">
          <source>Let's make an iterator named &lt;code&gt;Counter&lt;/code&gt; which counts from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;:</source>
          <target state="translated">Hagamos un iterador llamado &lt;code&gt;Counter&lt;/code&gt; que cuente de &lt;code&gt;1&lt;/code&gt; a &lt;code&gt;5&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6c6a4583ed007c9bb1513143277357a280135d4c" translate="yes" xml:space="preserve">
          <source>Let's start with some erroneous code examples:</source>
          <target state="translated">Empecemos con algunos ejemplos de códigos erróneos:</target>
        </trans-unit>
        <trans-unit id="de018a296a31a1ffdcd9d1c61756c91e2595cea1" translate="yes" xml:space="preserve">
          <source>Let's walk through each step of the iteration here:</source>
          <target state="translated">Caminemos a través de cada paso de la iteración aquí:</target>
        </trans-unit>
        <trans-unit id="44815d1f0973ea841fa50391ff27766e7a1e43e1" translate="yes" xml:space="preserve">
          <source>Let's write the numbers one through ten to a &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Escribamos los n&amp;uacute;meros del uno al diez en un &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a46a79428acd36421f88fb475bcbddfbea0e22e5" translate="yes" xml:space="preserve">
          <source>Lexical structure</source>
          <target state="translated">Estructura léxica</target>
        </trans-unit>
        <trans-unit id="97ced95f3282c2304ccbd2d1176522c359d54ea9" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cca5450332e424d128448475a6775439ff31f6" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0dc7378d16e255ed01aabc2a54a07e3e6629f4" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d55096d24feded547137c63c7a384f3c4c0f255" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddaf8f2edd0c91cf260c1ac14934d6aa825ae88" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a76c78472395e823b945082e38bc5d303e55719" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d126c71de93d47651f31c95e0aa450c4800fd88" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609c60c9d5603d69bbf35fffd3566a6af30afb36" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c25090a4ef088c71ace7e293566a76c0bb25be" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668bd83da9d322ea78d016864c5ab95e76011dec" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bff3a67247c3882318b7f41ce97184a0411570f" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5c8cdaa83d4509b191af2c71b1b48c60f72b24" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf6b114d1123581ae2c9e4273fca508b0fdbde3" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4ebf62364837d04d562c736d452c744c46f6e4" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3953e041c330441a75e1dfa61d597df8c7d470e" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2ad7e98b8195217ed6030e622bceaccf34c46b" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513ec20a4e8698e9bbbff2e3985a29e06196f05c" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e31f29d209ae250a7a227132954b7d8fe04deb" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3f1a9e4282d09a166c49d84325b88085f57ffa" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f489f2a5cd07e538c7596d152dd9c17e3db469d7" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c8e7753b0c8e6c7481529dc1eff5f203de8fd0" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c64287527264c710512a6ae1c3417e504fcde8" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22f0e1553138efb51680148ef1747ad26c97982" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another.</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro.</target>
        </trans-unit>
        <trans-unit id="d38859ceb7b6303a207032995bde9d03c3feea29" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca4735197429808d0efeb2b253fe9bcfce18fe50" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da9611fc3a83516ea2471a2bc5512aa400680e0d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="baa7a6a1172224029d4ace92b0dcc42af5ea43dc" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df2d601aaa116406a1d3ed2d19ce7ccb8eda9f6d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e11c383f8dbc8d0d02a7e4c42f755738eaa3bd8b" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5193c64367cbcdbfcac47602ae539c77c733dbd" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50753dbaf3a4231173ff7ea3444ae3faef6bec15" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a26e03f1b58a87f3e69a164fb32f2308387a9a0d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77268650d6474077dd95b0c1034d89e6138d9c8a" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Compara lexicogr&amp;aacute;ficamente los elementos de este &lt;code&gt;Iterator&lt;/code&gt; con los de otro. &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7cdfc7b1ef1b25862c1df7bf310283ec505f2f9e" translate="yes" xml:space="preserve">
          <source>Library authors should usually not directly implement this trait, but should prefer implementing the &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; trait, which offers greater flexibility and provides an equivalent &lt;code&gt;TryInto&lt;/code&gt; implementation for free, thanks to a blanket implementation in the standard library. For more information on this, see the documentation for &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los autores de bibliotecas normalmente no deber&amp;iacute;an implementar directamente este rasgo, pero deber&amp;iacute;an preferir implementar el rasgo &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; , que ofrece una mayor flexibilidad y proporciona una implementaci&amp;oacute;n &lt;code&gt;TryInto&lt;/code&gt; equivalente de forma gratuita, gracias a una implementaci&amp;oacute;n general en la biblioteca est&amp;aacute;ndar. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esto, consulte la documentaci&amp;oacute;n de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4758ec4228804e6ab30fe33d5019e3936dc6e0ac" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.</source>
          <target state="translated">Licenciado bajo la licencia de Apache,versión 2.0 o la licencia del MIT,a su elección.</target>
        </trans-unit>
        <trans-unit id="5ef0008f25a377dd2d246f55bb6f44f04dd3b9a3" translate="yes" xml:space="preserve">
          <source>Lifetime Annotation Syntax</source>
          <target state="translated">Sintaxis de la anotación de toda la vida</target>
        </trans-unit>
        <trans-unit id="d684ab1615c80d05a111e3a5d43f3dd40b1f7fc7" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Function Signatures</source>
          <target state="translated">Anotaciones de por vida en las firmas de funciones</target>
        </trans-unit>
        <trans-unit id="ff9298a957239ce20a277b248758f21de5df0edf" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Method Definitions</source>
          <target state="translated">Anotaciones de por vida en las definiciones de los métodos</target>
        </trans-unit>
        <trans-unit id="bf7eeb5a85880b38a5e28e77bcee94cc13003db0" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Struct Definitions</source>
          <target state="translated">Anotaciones de por vida en las definiciones de las estructuras</target>
        </trans-unit>
        <trans-unit id="674c9a2bca3da0091dd89b55224da7caea179e1f" translate="yes" xml:space="preserve">
          <source>Lifetime Elision</source>
          <target state="translated">Elección de por vida</target>
        </trans-unit>
        <trans-unit id="717ff13cd888c9b3f73863d8fc6f55fb70c424ad" translate="yes" xml:space="preserve">
          <source>Lifetime annotations don&amp;rsquo;t change how long any of the references live. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter. Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</source>
          <target state="translated">Las anotaciones de por vida no cambian la duraci&amp;oacute;n de las referencias. As&amp;iacute; como las funciones pueden aceptar cualquier tipo cuando la firma especifica un par&amp;aacute;metro de tipo gen&amp;eacute;rico, las funciones pueden aceptar referencias con cualquier duraci&amp;oacute;n especificando un par&amp;aacute;metro de duraci&amp;oacute;n gen&amp;eacute;rico. Las anotaciones de por vida describen las relaciones de las vidas de m&amp;uacute;ltiples referencias entre s&amp;iacute; sin afectar las vidas.</target>
        </trans-unit>
        <trans-unit id="afdff3576da5c17c6d56a74897ff356724bed98a" translate="yes" xml:space="preserve">
          <source>Lifetime annotations have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe (&lt;code&gt;'&lt;/code&gt;) and are usually all lowercase and very short, like generic types. Most people use the name &lt;code&gt;'a&lt;/code&gt;. We place lifetime parameter annotations after the &lt;code&gt;&amp;amp;&lt;/code&gt; of a reference, using a space to separate the annotation from the reference&amp;rsquo;s type.</source>
          <target state="translated">Las anotaciones de por vida tienen una sintaxis levemente inusual: los nombres de los par&amp;aacute;metros de por vida deben comenzar con un ap&amp;oacute;strofe ( &lt;code&gt;'&lt;/code&gt; ) y generalmente son todos en min&amp;uacute;sculas y muy cortos, como los tipos gen&amp;eacute;ricos. La mayor&amp;iacute;a de la gente usa el nombre &lt;code&gt;'a&lt;/code&gt; . Colocamos anotaciones de par&amp;aacute;metros de duraci&amp;oacute;n despu&amp;eacute;s del &lt;code&gt;&amp;amp;&lt;/code&gt; de una referencia, usando un espacio para separar la anotaci&amp;oacute;n del tipo de referencia.</target>
        </trans-unit>
        <trans-unit id="1135a93608f0c4c9693be849ed8d4d3c3627b3b8" translate="yes" xml:space="preserve">
          <source>Lifetime bounds</source>
          <target state="translated">Límites de la vida</target>
        </trans-unit>
        <trans-unit id="251f40e2a7cdcbd4967d480a9d96d101163e7557" translate="yes" xml:space="preserve">
          <source>Lifetime bounds can be applied to types or other lifetimes. The bound &lt;code&gt;'a: 'b&lt;/code&gt; is usually read as &lt;code&gt;'a&lt;/code&gt;&lt;em&gt;outlives&lt;/em&gt;&lt;code&gt;'b&lt;/code&gt;. &lt;code&gt;'a: 'b&lt;/code&gt; means that &lt;code&gt;'a&lt;/code&gt; lasts longer than &lt;code&gt;'b&lt;/code&gt;, so a reference &lt;code&gt;&amp;amp;'a ()&lt;/code&gt; is valid whenever &lt;code&gt;&amp;amp;'b ()&lt;/code&gt; is valid.</source>
          <target state="translated">Los l&amp;iacute;mites de vida se pueden aplicar a tipos u otras vidas. El l&amp;iacute;mite &lt;code&gt;'a: 'b&lt;/code&gt; generalmente se lee como &lt;code&gt;'a&lt;/code&gt; &lt;em&gt;sobrevive &lt;/em&gt; &lt;code&gt;'b&lt;/code&gt; . &lt;code&gt;'a: 'b&lt;/code&gt; significa que &lt;code&gt;'a&lt;/code&gt; dura m&amp;aacute;s que &lt;code&gt;'b&lt;/code&gt; , por lo que una referencia &lt;code&gt;&amp;amp;'a ()&lt;/code&gt; es v&amp;aacute;lida siempre que &lt;code&gt;&amp;amp;'b ()&lt;/code&gt; sea ​​v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="4dbeb69ffc17e7e2b0614af0534a87d095aeab01" translate="yes" xml:space="preserve">
          <source>Lifetime elision</source>
          <target state="translated">Elección de por vida</target>
        </trans-unit>
        <trans-unit id="4ed17519ce5dbd6c80c5942b9e801bd65600d677" translate="yes" xml:space="preserve">
          <source>Lifetime elision in functions</source>
          <target state="translated">La elisión de por vida en las funciones</target>
        </trans-unit>
        <trans-unit id="cdf660f0b0e8334138261c27b1ecaed43d9845fb" translate="yes" xml:space="preserve">
          <source>Lifetime elision is a special, limited kind of inference for lifetimes in function signatures which allows you to leave out lifetimes in certain cases. For more background on lifetime elision see &lt;a href=&quot;book/ch10-03-lifetime-syntax#lifetime-elision&quot;&gt;the book&lt;/a&gt;.</source>
          <target state="translated">La elisi&amp;oacute;n de por vida es un tipo de inferencia especial y limitado para las vidas en las firmas de funciones que le permite omitir las vidas en ciertos casos. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la elisi&amp;oacute;n de por vida, consulte &lt;a href=&quot;book/ch10-03-lifetime-syntax#lifetime-elision&quot;&gt;el libro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1728f6f98aaf9465cf90c15cd1b748f66e76ad" translate="yes" xml:space="preserve">
          <source>Lifetime names for struct fields always need to be declared after the &lt;code&gt;impl&lt;/code&gt; keyword and then used after the struct&amp;rsquo;s name, because those lifetimes are part of the struct&amp;rsquo;s type.</source>
          <target state="translated">Los nombres de vida para los campos de estructura siempre deben declararse despu&amp;eacute;s de la palabra clave &lt;code&gt;impl&lt;/code&gt; y luego usarse despu&amp;eacute;s del nombre de la estructura, porque esas vidas son parte del tipo de estructura.</target>
        </trans-unit>
        <trans-unit id="a900c570930642dfc60a61e8d7bac83d7d6ce835" translate="yes" xml:space="preserve">
          <source>Lifetime parameters and &lt;a href=&quot;expressions/loop-expr&quot;&gt;loop labels&lt;/a&gt; use LIFETIME_OR_LABEL tokens. Any LIFETIME_TOKEN will be accepted by the lexer, and for example, can be used in macros.</source>
          <target state="translated">Los par&amp;aacute;metros de por vida y las &lt;a href=&quot;expressions/loop-expr&quot;&gt;etiquetas de bucle&lt;/a&gt; usan tokens LIFETIME_OR_LABEL. Cualquier LIFETIME_TOKEN ser&amp;aacute; aceptado por el lexer y, por ejemplo, puede usarse en macros.</target>
        </trans-unit>
        <trans-unit id="4ff5a6b571244bea88cc86b164846e047b3ec7b5" translate="yes" xml:space="preserve">
          <source>Lifetime parameters or &lt;a href=&quot;expressions/loop-expr#loop-labels&quot;&gt;loop labels&lt;/a&gt;</source>
          <target state="translated">Par&amp;aacute;metros de por vida o &lt;a href=&quot;expressions/loop-expr#loop-labels&quot;&gt;etiquetas de bucle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec6b2b953ecf8f329d7e04b783de42bfc3652a53" translate="yes" xml:space="preserve">
          <source>Lifetimes</source>
          <target state="translated">Lifetimes</target>
        </trans-unit>
        <trans-unit id="6e3d4513c00b42e75eeb4d12543903cf3991d567" translate="yes" xml:space="preserve">
          <source>Lifetimes and loop labels</source>
          <target state="translated">Vidas y etiquetas de bucle</target>
        </trans-unit>
        <trans-unit id="44ebe0741417aa78ef5defc6e06797a635cee244" translate="yes" xml:space="preserve">
          <source>Lifetimes on function or method parameters are called &lt;em&gt;input lifetimes&lt;/em&gt;, and lifetimes on return values are called &lt;em&gt;output lifetimes&lt;/em&gt;.</source>
          <target state="translated">La vida &lt;em&gt;&amp;uacute;til de los&lt;/em&gt; par&amp;aacute;metros de funci&amp;oacute;n o m&amp;eacute;todo se denomina &lt;em&gt;vida &amp;uacute;til de entrada&lt;/em&gt; , y la vida &amp;uacute;til de los valores de retorno se denomina &lt;em&gt;vida &amp;uacute;til de salida&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b0908dfa434be81e3deb0facdeb85bcd33472550" translate="yes" xml:space="preserve">
          <source>Lifetimes used in &lt;code&gt;fn&lt;/code&gt; or &lt;code&gt;Fn&lt;/code&gt; syntax must be explicitly declared using &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; binders. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711484ebabd34c5bee47c2a0196b50ef7c53c764" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">Al igual que &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , el bloqueo especificado se volver&amp;aacute; a adquirir cuando esta funci&amp;oacute;n regrese, independientemente de si transcurri&amp;oacute; el tiempo de espera o no.</target>
        </trans-unit>
        <trans-unit id="9143067c5010240235e5098fdd6d0b035ca2de7f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">Al igual que &lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt; , el bloqueo especificado se volver&amp;aacute; a adquirir cuando esta funci&amp;oacute;n regrese, independientemente de si transcurri&amp;oacute; el tiempo de espera o no.</target>
        </trans-unit>
        <trans-unit id="841a9a19b58dd6630bdc34ede04fb57fa218eece" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090c127fd35edc1d60b1dabd86f3ca4ea132ca47" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cbabaec83102adcf38ba2f63965f7483dc4ff0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">Al igual que &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy&lt;/code&gt; crea una copia bit a bit de &lt;code&gt;T&lt;/code&gt; , independientemente de si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , usar los valores de la regi&amp;oacute;n que comienza en &lt;code&gt;*src&lt;/code&gt; y la regi&amp;oacute;n que comienza en &lt;code&gt;*dst&lt;/code&gt; puede &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violar la seguridad de la memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6b5f673832d554b3ba278cb3e90ddc20575f12f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf650a829b373e9102813a508f7fe2ddc52356d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">Al igual que &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy_nonoverlapping&lt;/code&gt; crea una copia bit a bit de &lt;code&gt;T&lt;/code&gt; , independientemente de si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , utilizando &lt;em&gt;ambos&lt;/em&gt; los valores en el principio regi&amp;oacute;n en &lt;code&gt;*src&lt;/code&gt; y la regi&amp;oacute;n a partir de las &lt;code&gt;*dst&lt;/code&gt; puede &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violar la seguridad de la memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="673f6dbc7b8c22dd58a3649d0763e6d47086e689" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; (for load, store, and load-with-store operations, respectively) with the additional guarantee that all threads see all sequentially consistent operations in the same order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf9f8511904c5069b83f4fd094004a94b015444" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.forget&quot;&gt;&lt;code&gt;forget&lt;/code&gt;&lt;/a&gt;, but also accepts unsized values.</source>
          <target state="translated">Como &lt;a href=&quot;fn.forget&quot;&gt; &lt;code&gt;forget&lt;/code&gt; &lt;/a&gt; , pero tambi&amp;eacute;n acepta valores sin tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="4b60bd7f4df6aad7fa80856c1bd518eaad347be6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">Al igual que &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy&lt;/code&gt; crea una copia bit a bit de &lt;code&gt;T&lt;/code&gt; , independientemente de si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , usar los valores de la regi&amp;oacute;n que comienza en &lt;code&gt;*src&lt;/code&gt; y la regi&amp;oacute;n que comienza en &lt;code&gt;*dst&lt;/code&gt; puede &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violar la seguridad de la memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae45f3009db76dae79642054ed9d2e4707eced76" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfb87516d3e691309e3183e393372085b3eb5c7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">Al igual que &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy_nonoverlapping&lt;/code&gt; crea una copia bit a bit de &lt;code&gt;T&lt;/code&gt; , independientemente de si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , utilizando &lt;em&gt;ambos&lt;/em&gt; los valores en el principio regi&amp;oacute;n en &lt;code&gt;*src&lt;/code&gt; y la regi&amp;oacute;n a partir de las &lt;code&gt;*dst&lt;/code&gt; puede &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violar la seguridad de la memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29fb501f0793a6ba4173aacc2026afb59ff625c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the returned value and the value at &lt;code&gt;*src&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">Como &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;read_unaligned&lt;/code&gt; crea una copia bit a bit de &lt;code&gt;T&lt;/code&gt; , independientemente de si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , usar tanto el valor devuelto como el valor en &lt;code&gt;*src&lt;/code&gt; puede &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violar la seguridad de la memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf95f150b3e045a75caa61fd8dd299e1f6177de4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_volatile&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the returned value and the value at &lt;code&gt;*src&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;. However, storing non-&lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types in volatile memory is almost certainly incorrect.</source>
          <target state="translated">Al igual que &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;read_volatile&lt;/code&gt; crea una copia bit a bit de &lt;code&gt;T&lt;/code&gt; , independientemente de si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , usar tanto el valor devuelto como el valor en &lt;code&gt;*src&lt;/code&gt; puede &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violar la seguridad de la memoria&lt;/a&gt; . Sin embargo, es casi seguro que almacenar tipos que no son de &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; en la memoria vol&amp;aacute;til es incorrecto.</target>
        </trans-unit>
        <trans-unit id="a2ef8c40adbd6ce1d9e2b9decbefda1339ad636f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; (for load, store, and load-with-store operations, respectively) with the additional guarantee that all threads see all sequentially consistent operations in the same order.</source>
          <target state="translated">Como &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; (para operaciones de carga, almacenamiento y carga con tienda, respectivamente) con la garant&amp;iacute;a adicional de que todos los subprocesos ven todas las operaciones secuencialmente consistentes en el mismo orden.</target>
        </trans-unit>
        <trans-unit id="10040ebca04aab631b833e06ce9af822e9824086" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb3f2bd27f2c64ea34e80152dae14864b47bd75" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;keyword.enum&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;s, a module and its content are private by default, unaccessible to code outside of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a2b45437346496bd0f17702b7e91d1466c2799" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, this macro also has a second version, where a custom panic message can be provided.</source>
          <target state="translated">&amp;iexcl;Como &lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;, esta macro tambi&amp;eacute;n tiene una segunda versi&amp;oacute;n, donde se puede proporcionar un mensaje de p&amp;aacute;nico personalizado.</target>
        </trans-unit>
        <trans-unit id="4a3d6c41c117ef0813067fce9ad6d2c797819f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, this macro has a second form, where a custom panic message can be provided.</source>
          <target state="translated">&amp;iexcl;Como &lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;, esta macro tiene una segunda forma, donde se puede proporcionar un mensaje de p&amp;aacute;nico personalizado.</target>
        </trans-unit>
        <trans-unit id="2f9660f47631acac7f2a52b8ab96514dc036d49e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;LineWriter&lt;/code&gt;&amp;rsquo;s buffer will also be flushed when the &lt;code&gt;LineWriter&lt;/code&gt; goes out of scope or when its internal buffer is full.</source>
          <target state="translated">Al igual que &lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt; , el b&amp;uacute;fer de &lt;code&gt;LineWriter&lt;/code&gt; tambi&amp;eacute;n se &lt;code&gt;LineWriter&lt;/code&gt; cuando LineWriter quede fuera del alcance o cuando su b&amp;uacute;fer interno est&amp;eacute; lleno.</target>
        </trans-unit>
        <trans-unit id="58df427e5bbce21caf2fe2b837297d163849e77b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c450b5b408d7fbd12d604817a55adc65281b8d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8fc695456a6957ca08bda068f50835ca6480df" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, if there is a value, it is wrapped in a &lt;code&gt;Some(T)&lt;/code&gt;. But if the iteration is over, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">Como a &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; , si hay un valor, se envuelve en &lt;code&gt;Some(T)&lt;/code&gt; . Pero si la iteraci&amp;oacute;n finaliza, se devuelve &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="375e88d0fb45924c13a3ac3d25d35cc53e0b6dbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ece68e98c367b427da7eda601344bdda8373dc9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96e1257fda431003f96a740ec957795754307e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; is normally associated with the innermost enclosing loop, but &lt;code&gt;continue 'label&lt;/code&gt; may be used to specify the loop affected. A &lt;code&gt;continue&lt;/code&gt; expression is only permitted in the body of a loop.</source>
          <target state="translated">Al igual que &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; normalmente se asocia con el bucle de cierre m&amp;aacute;s interno, pero se puede usar la &lt;code&gt;continue 'label&lt;/code&gt; para especificar el bucle afectado. Una expresi&amp;oacute;n de &lt;code&gt;continue&lt;/code&gt; solo est&amp;aacute; permitida en el cuerpo de un bucle.</target>
        </trans-unit>
        <trans-unit id="4e6414b7dcb2bf632ebca1570eac937be87ca89a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; is normally associated with the innermost enclosing loop, but labels may be used to specify the affected loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088a111a2146143c269622f6720bedf46b4095af" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;ctlz&lt;/code&gt;, but extra-unsafe as it returns &lt;code&gt;undef&lt;/code&gt; when given an &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Como &lt;code&gt;ctlz&lt;/code&gt; , pero muy inseguro, ya que devuelve &lt;code&gt;undef&lt;/code&gt; cuando se le da una &lt;code&gt;x&lt;/code&gt; con valor &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0441e738f2dd6cd8b8b2b78d7c0e5293c433e051" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cttz&lt;/code&gt;, but extra-unsafe as it returns &lt;code&gt;undef&lt;/code&gt; when given an &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Como &lt;code&gt;cttz&lt;/code&gt; , pero extra-inseguro ya que devuelve &lt;code&gt;undef&lt;/code&gt; cuando se le da una &lt;code&gt;x&lt;/code&gt; con valor &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aafea1bc859a7c488e520cc6c530088c8d2d86f9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;panic!&lt;/code&gt;, this macro has a second form for displaying custom values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af819e7752cc0d0f79bda85b3236f2d4d09b2e2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers.</source>
          <target state="translated">Como &lt;code&gt;read&lt;/code&gt; , excepto que lee en una porci&amp;oacute;n de b&amp;uacute;feres.</target>
        </trans-unit>
        <trans-unit id="c398915090a8fe75043794195cb2a1010511d11d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;../../../io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;read&lt;/code&gt; , excepto que lee en una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;../../../io/trait.read#method.read_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4193e9abdbffc61433821360262b7ce147ba44be" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;../io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;read&lt;/code&gt; , excepto que lee en una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;../io/trait.read#method.read_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19a11d624c5ac2fd3c32083744114569a63b8be1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;read&lt;/code&gt; , excepto que lee en una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;io/trait.read#method.read_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab91074c2b287fdf8a7b212edaf2da1655891bbf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;read&lt;/code&gt; , excepto que lee en una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;trait.read#method.read_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0c137ee5317a547c2505ef5380b9708644889bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers.</source>
          <target state="translated">Como &lt;code&gt;write&lt;/code&gt; , excepto que escribe desde una porci&amp;oacute;n de b&amp;uacute;feres.</target>
        </trans-unit>
        <trans-unit id="52fa708382c8776f6cbe3b5227e8d830d96b01c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;write&lt;/code&gt; , excepto que escribe desde una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5724f707420fb63c78e29f6894aa5e96feb279b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;write&lt;/code&gt; , excepto que escribe desde una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8e23cd5a3cb733eb5eff3ebaeba471859348fb4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;write&lt;/code&gt; , excepto que escribe desde una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be2823934efbd612499317ea4eb64b49a897e3b9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Como &lt;code&gt;write&lt;/code&gt; , excepto que escribe desde una porci&amp;oacute;n de b&amp;uacute;feres. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="902993443cc36d88600a8cb05ef8c36915632034" translate="yes" xml:space="preserve">
          <source>Like all instances of UB, if this assumption turns out to be wrong, i.e., the &lt;code&gt;unreachable_unchecked()&lt;/code&gt; call is actually reachable among all possible control flow, the compiler will apply the wrong optimization strategy, and may sometimes even corrupt seemingly unrelated code, causing difficult-to-debug problems.</source>
          <target state="translated">Como todas las instancias de UB, si esta suposici&amp;oacute;n resulta ser incorrecta, es decir, la llamada &lt;code&gt;unreachable_unchecked()&lt;/code&gt; es realmente accesible entre todos los flujos de control posibles, el compilador aplicar&amp;aacute; la estrategia de optimizaci&amp;oacute;n incorrecta y, a veces, incluso puede corromper el c&amp;oacute;digo aparentemente no relacionado, causando Problemas dif&amp;iacute;ciles de depurar.</target>
        </trans-unit>
        <trans-unit id="649ba6cfd601ba5aca37823d799268a81f5dc250" translate="yes" xml:space="preserve">
          <source>Like all technical books, this book has certain conventions in how it displays information. These conventions are documented here.</source>
          <target state="translated">Como todos los libros técnicos,este libro tiene ciertas convenciones en la forma de mostrar la información.Estas convenciones están documentadas aquí.</target>
        </trans-unit>
        <trans-unit id="44d26e3390ffce91f282ebeb751d71157005049b" translate="yes" xml:space="preserve">
          <source>Like any literal, an integer literal may be followed (immediately, without any spaces) by an &lt;em&gt;integer suffix&lt;/em&gt;, which forcibly sets the type of the literal. The integer suffix must be the name of one of the integral types: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, or &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Como cualquier literal, un literal entero puede ir seguido (inmediatamente, sin espacios) por un &lt;em&gt;sufijo entero&lt;/em&gt; , que establece forzosamente el tipo de literal. El sufijo entero debe ser el nombre de uno de los tipos integrales: &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;i8&lt;/code&gt; , &lt;code&gt;u16&lt;/code&gt; , &lt;code&gt;i16&lt;/code&gt; , &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;i32&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , &lt;code&gt;i64&lt;/code&gt; , &lt;code&gt;u128&lt;/code&gt; , &lt;code&gt;i128&lt;/code&gt; , &lt;code&gt;usize&lt;/code&gt; , o &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe96ba09f6c5b465c5068945c430d86210b786b4" translate="yes" xml:space="preserve">
          <source>Like any other &lt;code&gt;struct&lt;/code&gt;, a vector is freed when it goes out of scope, as annotated in Listing 8-4.</source>
          <target state="translated">Como cualquier otra &lt;code&gt;struct&lt;/code&gt; , un vector se libera cuando sale del alcance, como se indica en el Listado 8-4.</target>
        </trans-unit>
        <trans-unit id="05c02c45bd9fe3c41ff9466036864fee28d10e75" translate="yes" xml:space="preserve">
          <source>Like asynchronous channels, if the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, If the &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Al igual que los canales asincr&amp;oacute;nicos, si el &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; se desconecta al intentar &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; con &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; , el m&amp;eacute;todo de &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; un &lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt; . De manera similar, si &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; se desconecta mientras intenta &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; , el m&amp;eacute;todo &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; un &lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5aebd2c614f88bfe78d840f656119aee198d25e8" translate="yes" xml:space="preserve">
          <source>Like integer literals, a floating-point literal may be followed by a suffix, so long as the pre-suffix part does not end with &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). The suffix forcibly sets the type of the literal. There are two valid &lt;em&gt;floating-point suffixes&lt;/em&gt;, &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt; (the 32-bit and 64-bit floating point types), which explicitly determine the type of the literal.</source>
          <target state="translated">Al igual que los literales enteros, un literal de coma flotante puede ir seguido de un sufijo, siempre que la parte del prefijo no termine en &lt;code&gt;U+002E&lt;/code&gt; ( &lt;code&gt;.&lt;/code&gt; ). El sufijo establece a la fuerza el tipo de literal. Hay dos v&amp;aacute;lidos &lt;em&gt;sufijos de punto flotante&lt;/em&gt; , &lt;code&gt;f32&lt;/code&gt; y &lt;code&gt;f64&lt;/code&gt; (los tipos de 32 bits y de coma flotante de 64 bits), que determinan de manera expl&amp;iacute;cita el tipo de literal.</target>
        </trans-unit>
        <trans-unit id="75d8318497142cc1c07dc08759286ca5f2b7edc7" translate="yes" xml:space="preserve">
          <source>Like items, &lt;code&gt;use&lt;/code&gt; declarations are private to the containing module, by default. Also like items, a &lt;code&gt;use&lt;/code&gt; declaration can be public, if qualified by the &lt;code&gt;pub&lt;/code&gt; keyword. Such a &lt;code&gt;use&lt;/code&gt; declaration serves to &lt;em&gt;re-export&lt;/em&gt; a name. A public &lt;code&gt;use&lt;/code&gt; declaration can therefore &lt;em&gt;redirect&lt;/em&gt; some public name to a different target definition: even a definition with a private canonical path, inside a different module. If a sequence of such redirections form a cycle or cannot be resolved unambiguously, they represent a compile-time error.</source>
          <target state="translated">Al igual que los elementos, las declaraciones de &lt;code&gt;use&lt;/code&gt; son privadas para el m&amp;oacute;dulo contenedor, de forma predeterminada. Tambi&amp;eacute;n como los elementos, una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; puede ser p&amp;uacute;blica, si est&amp;aacute; calificada por la palabra clave &lt;code&gt;pub&lt;/code&gt; . Esta declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; sirve para &lt;em&gt;reexportar&lt;/em&gt; un nombre. Por lo tanto, una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; p&amp;uacute;blico puede &lt;em&gt;redirigir&lt;/em&gt; alg&amp;uacute;n nombre p&amp;uacute;blico a una definici&amp;oacute;n de destino diferente: incluso una definici&amp;oacute;n con una ruta can&amp;oacute;nica privada, dentro de un m&amp;oacute;dulo diferente. Si una secuencia de tales redirecciones forma un ciclo o no se puede resolver sin ambig&amp;uuml;edades, representan un error en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4455a5352379b9bfb84306293e10135e6768efff" translate="yes" xml:space="preserve">
          <source>Like most indexing operations, the count starts from zero, so &lt;code&gt;nth(0)&lt;/code&gt; returns the first value, &lt;code&gt;nth(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">Como la mayor&amp;iacute;a de las operaciones de indexaci&amp;oacute;n, el recuento comienza desde cero, por lo que &lt;code&gt;nth(0)&lt;/code&gt; devuelve el primer valor, &lt;code&gt;nth(1)&lt;/code&gt; el segundo y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="808e2460e25efca05f0265071060604e1e534bac" translate="yes" xml:space="preserve">
          <source>Like references in rust, function pointers are assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type &lt;code&gt;Option&amp;lt;fn()&amp;gt;&lt;/code&gt; with your required signature.</source>
          <target state="translated">Al igual que las referencias en rust, se supone que los punteros de funci&amp;oacute;n no son nulos, por lo que si desea pasar un puntero de funci&amp;oacute;n sobre FFI y poder acomodar punteros nulos, haga su tipo &lt;code&gt;Option&amp;lt;fn()&amp;gt;&lt;/code&gt; con su firma requerida.</target>
        </trans-unit>
        <trans-unit id="8e44ee89e79563bdf5dbc7eeeb4e89ae7df53d96" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; expression, we can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;. A &lt;code&gt;while&lt;/code&gt; expression cannot break with a value and always evaluates to &lt;code&gt;()&lt;/code&gt; unlike &lt;a href=&quot;keyword.loop&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdec5b5891f0978d4130ee94d9517ad5371a9c05" translate="yes" xml:space="preserve">
          <source>Likewise, combining the &lt;code&gt;C&lt;/code&gt; representation with a primitive representation, the layout is unspecified.</source>
          <target state="translated">Asimismo, al combinar la representaci&amp;oacute;n &lt;code&gt;C&lt;/code&gt; con una representaci&amp;oacute;n primitiva, el dise&amp;ntilde;o no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="43eac78cc95cdbd3213a6055d8d48f1d53720313" translate="yes" xml:space="preserve">
          <source>Likewise, combining two primitive representations together is unspecified.</source>
          <target state="translated">Asimismo,no se especifica la combinación de dos representaciones primitivas.</target>
        </trans-unit>
        <trans-unit id="a87f62e5c0ad27b39b657994af4f2f6af6bcd4e4" translate="yes" xml:space="preserve">
          <source>Likewise, the signature of the function uses &lt;code&gt;&amp;amp;&lt;/code&gt; to indicate that the type of the parameter &lt;code&gt;s&lt;/code&gt; is a reference. Let&amp;rsquo;s add some explanatory annotations:</source>
          <target state="translated">Asimismo, la firma de la funci&amp;oacute;n usa &lt;code&gt;&amp;amp;&lt;/code&gt; para indicar que el tipo de par&amp;aacute;metro &lt;code&gt;s&lt;/code&gt; es una referencia. Agreguemos algunas anotaciones explicativas:</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="01de4d38c5a9265699ce4ab27dfaf087bbe8ecf6" translate="yes" xml:space="preserve">
          <source>Limitations of the &lt;code id=&quot;limitations-of-the-cacher-implementation&quot;&gt;Cacher&lt;/code&gt; Implementation</source>
          <target state="translated">Limitaciones de la implementaci&amp;oacute;n de &lt;code id=&quot;limitations-of-the-cacher-implementation&quot;&gt;Cacher&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="6374b1b52339bde3abd0bb8e4d466f1af18a84f0" translate="yes" xml:space="preserve">
          <source>Line comment</source>
          <target state="translated">Comentario de la línea</target>
        </trans-unit>
        <trans-unit id="deea94a5bfb30ea2c7507a3f03c99253e4272a0a" translate="yes" xml:space="preserve">
          <source>Line comments beginning with &lt;code&gt;//!&lt;/code&gt; and block comments &lt;code&gt;/*! ... */&lt;/code&gt; are doc comments that apply to the parent of the comment, rather than the item that follows. That is, they are equivalent to writing &lt;code&gt;#![doc=&quot;...&quot;]&lt;/code&gt; around the body of the comment. &lt;code&gt;//!&lt;/code&gt; comments are usually used to document modules that occupy a source file.</source>
          <target state="translated">Comentarios de l&amp;iacute;nea que comienzan con &lt;code&gt;//!&lt;/code&gt; y bloquear comentarios &lt;code&gt;/*! ... */&lt;/code&gt; son comentarios de documentos que se aplican al padre del comentario, en lugar del elemento que sigue. Es decir, equivalen a escribir &lt;code&gt;#![doc=&quot;...&quot;]&lt;/code&gt; alrededor del cuerpo del comentario. &lt;code&gt;//!&lt;/code&gt; Los comentarios se utilizan generalmente para documentar m&amp;oacute;dulos que ocupan un archivo fuente.</target>
        </trans-unit>
        <trans-unit id="762dee2b9cd8a9da4291e16ff13ceac56af56d99" translate="yes" xml:space="preserve">
          <source>Line doc comments beginning with exactly &lt;em&gt;three&lt;/em&gt; slashes (&lt;code&gt;///&lt;/code&gt;), and block doc comments (&lt;code&gt;/** ... */&lt;/code&gt;), both inner doc comments, are interpreted as a special syntax for &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt; attributes&lt;/a&gt;. That is, they are equivalent to writing &lt;code&gt;#[doc=&quot;...&quot;]&lt;/code&gt; around the body of the comment, i.e., &lt;code&gt;/// Foo&lt;/code&gt; turns into &lt;code&gt;#[doc=&quot;Foo&quot;]&lt;/code&gt; and &lt;code&gt;/** Bar */&lt;/code&gt; turns into &lt;code&gt;#[doc=&quot;Bar&quot;]&lt;/code&gt;.</source>
          <target state="translated">Los comentarios de documentos de l&amp;iacute;nea que comienzan con exactamente &lt;em&gt;tres&lt;/em&gt; barras ( &lt;code&gt;///&lt;/code&gt; ) y los comentarios de documentos de bloque ( &lt;code&gt;/** ... */&lt;/code&gt; ), ambos comentarios de documentos internos, se interpretan como una sintaxis especial para los &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;atributos de &lt;/a&gt; &lt;code&gt;doc&lt;/code&gt; umentos . Es decir, equivalen a escribir &lt;code&gt;#[doc=&quot;...&quot;]&lt;/code&gt; alrededor del cuerpo del comentario, es decir, &lt;code&gt;/// Foo&lt;/code&gt; convierte en &lt;code&gt;#[doc=&quot;Foo&quot;]&lt;/code&gt; y &lt;code&gt;/** Bar */&lt;/code&gt; convierte en &lt;code&gt;#[doc=&quot;Bar&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0f09e1a35a919b04916a657dcaf775def02ecc3" translate="yes" xml:space="preserve">
          <source>Line feed is escaped as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">El salto de l&amp;iacute;nea se escapa como &lt;code&gt;\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11a574794cee21df3f3bbe1f9331a0946b02f437" translate="yes" xml:space="preserve">
          <source>Line-break characters are allowed in string literals. Normally they represent themselves (i.e. no translation), but as a special exception, when an unescaped &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;) occurs immediately before the newline (&lt;code&gt;U+000A&lt;/code&gt;), the &lt;code&gt;U+005C&lt;/code&gt; character, the newline, and all whitespace at the beginning of the next line are ignored. Thus &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal:</source>
          <target state="translated">Se permiten caracteres de salto de l&amp;iacute;nea en literales de cadena. Normalmente se representan a s&amp;iacute; mismos (es decir, sin traducci&amp;oacute;n), pero como una excepci&amp;oacute;n especial, cuando un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; sin escape ( &lt;code&gt;\&lt;/code&gt; ) aparece inmediatamente antes de la nueva l&amp;iacute;nea ( &lt;code&gt;U+000A&lt;/code&gt; ), el car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; , la nueva l&amp;iacute;nea y todos los espacios en blanco en el principio de la siguiente l&amp;iacute;nea se ignora. Por lo tanto &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son iguales:</target>
        </trans-unit>
        <trans-unit id="d7a69d21787a597ee70bd4037b342464706e333a" translate="yes" xml:space="preserve">
          <source>Line-breaks are allowed in string literals. A line-break is either a newline (&lt;code&gt;U+000A&lt;/code&gt;) or a pair of carriage return and newline (&lt;code&gt;U+000D&lt;/code&gt;, &lt;code&gt;U+000A&lt;/code&gt;). Both byte sequences are normally translated to &lt;code&gt;U+000A&lt;/code&gt;, but as a special exception, when an unescaped &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;) occurs immediately before the line-break, then the &lt;code&gt;U+005C&lt;/code&gt; character, the line-break, and all whitespace at the beginning of the next line are ignored. Thus &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2830ad93f43cfc81ed338845630996d89e8c3581" translate="yes" xml:space="preserve">
          <source>LineWriter</source>
          <target state="translated">LineWriter</target>
        </trans-unit>
        <trans-unit id="a467a8d1c87cedc92c6a62d00ba608ee83995811" translate="yes" xml:space="preserve">
          <source>LineWriter::borrow</source>
          <target state="translated">LineWriter::borrow</target>
        </trans-unit>
        <trans-unit id="be9800c1f2dec531de8f863888451a1e1e2311ab" translate="yes" xml:space="preserve">
          <source>LineWriter::borrow_mut</source>
          <target state="translated">LineWriter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2c13ce7518167bb16bb38a5b26d00211f5dffbd5" translate="yes" xml:space="preserve">
          <source>LineWriter::by_ref</source>
          <target state="translated">LineWriter::by_ref</target>
        </trans-unit>
        <trans-unit id="ad5e984ff0e6171936808b93fcf31ce4b80c212c" translate="yes" xml:space="preserve">
          <source>LineWriter::flush</source>
          <target state="translated">LineWriter::flush</target>
        </trans-unit>
        <trans-unit id="df10811fc6539a5582a3d6ba85fdf94454c319b5" translate="yes" xml:space="preserve">
          <source>LineWriter::fmt</source>
          <target state="translated">LineWriter::fmt</target>
        </trans-unit>
        <trans-unit id="99043611351dc9ff3e05b31b6386acec9bd4d9f9" translate="yes" xml:space="preserve">
          <source>LineWriter::from</source>
          <target state="translated">LineWriter::from</target>
        </trans-unit>
        <trans-unit id="ac69fff03ab2476a267ab98b2b6890c7cf1cc55d" translate="yes" xml:space="preserve">
          <source>LineWriter::get_mut</source>
          <target state="translated">LineWriter::get_mut</target>
        </trans-unit>
        <trans-unit id="1f40adca93e9d87127f3dcb17bebb2d113f8e8fe" translate="yes" xml:space="preserve">
          <source>LineWriter::get_ref</source>
          <target state="translated">LineWriter::get_ref</target>
        </trans-unit>
        <trans-unit id="e241aca740fc32914d91f0be104b82973eb66e5e" translate="yes" xml:space="preserve">
          <source>LineWriter::into</source>
          <target state="translated">LineWriter::into</target>
        </trans-unit>
        <trans-unit id="775f2c8ae9898d577c81da95ed4fcd902133aac3" translate="yes" xml:space="preserve">
          <source>LineWriter::into_inner</source>
          <target state="translated">LineWriter::into_inner</target>
        </trans-unit>
        <trans-unit id="dc3a9d15cfff5be7e19c52c4a56f2c5757e1f703" translate="yes" xml:space="preserve">
          <source>LineWriter::new</source>
          <target state="translated">LineWriter::new</target>
        </trans-unit>
        <trans-unit id="24e05e7c8c89d11d5f69df6388a9b0041bdc7c12" translate="yes" xml:space="preserve">
          <source>LineWriter::try_from</source>
          <target state="translated">LineWriter::try_from</target>
        </trans-unit>
        <trans-unit id="61eebd307b1c261703d7a99419578cfb8f7603b3" translate="yes" xml:space="preserve">
          <source>LineWriter::try_into</source>
          <target state="translated">LineWriter::try_into</target>
        </trans-unit>
        <trans-unit id="af6ffe50802be602950bd895cf9e0cb854fb1812" translate="yes" xml:space="preserve">
          <source>LineWriter::type_id</source>
          <target state="translated">LineWriter::type_id</target>
        </trans-unit>
        <trans-unit id="554b503c3ba754005e39b90ec87f0d92638d2c6e" translate="yes" xml:space="preserve">
          <source>LineWriter::with_capacity</source>
          <target state="translated">LineWriter::with_capacity</target>
        </trans-unit>
        <trans-unit id="221f080203de74c4a951139b8978acaf6b428212" translate="yes" xml:space="preserve">
          <source>LineWriter::write</source>
          <target state="translated">LineWriter::write</target>
        </trans-unit>
        <trans-unit id="718afa20219fcf1aa652f5865af9a7a30b0cf90f" translate="yes" xml:space="preserve">
          <source>LineWriter::write_all</source>
          <target state="translated">LineWriter::write_all</target>
        </trans-unit>
        <trans-unit id="e92db461a6c35320c65374e4144e5044c1b88bad" translate="yes" xml:space="preserve">
          <source>LineWriter::write_fmt</source>
          <target state="translated">LineWriter::write_fmt</target>
        </trans-unit>
        <trans-unit id="d174a06b1546e4b7fde2c0cdcd5ca37b66ded43b" translate="yes" xml:space="preserve">
          <source>LineWriter::write_vectored</source>
          <target state="translated">LineWriter::write_vectored</target>
        </trans-unit>
        <trans-unit id="c6fd3870c86e7422a0146e1e2a052437fb8e51e2" translate="yes" xml:space="preserve">
          <source>Lines</source>
          <target state="translated">Lines</target>
        </trans-unit>
        <trans-unit id="34d99e5c2f3cbf7a2f6c06ae38bf6f1437170c72" translate="yes" xml:space="preserve">
          <source>Lines are ended with either a newline (&lt;code&gt;\n&lt;/code&gt;) or a carriage return with a line feed (&lt;code&gt;\r\n&lt;/code&gt;).</source>
          <target state="translated">Las l&amp;iacute;neas terminan con una nueva l&amp;iacute;nea ( &lt;code&gt;\n&lt;/code&gt; ) o un retorno de carro con un salto de l&amp;iacute;nea ( &lt;code&gt;\r\n&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8372047979cef10f511e256735d06fdb5834080a" translate="yes" xml:space="preserve">
          <source>Lines::all</source>
          <target state="translated">Lines::all</target>
        </trans-unit>
        <trans-unit id="ab3890e2134cb7b243711c9eb9d91f7d2b2bdbb5" translate="yes" xml:space="preserve">
          <source>Lines::any</source>
          <target state="translated">Lines::any</target>
        </trans-unit>
        <trans-unit id="70cb6c67edb194cbf85640b28d5918c1d359d3b1" translate="yes" xml:space="preserve">
          <source>Lines::borrow</source>
          <target state="translated">Lines::borrow</target>
        </trans-unit>
        <trans-unit id="18b3ef85cc38f93f055a82652080b268c1813b05" translate="yes" xml:space="preserve">
          <source>Lines::borrow_mut</source>
          <target state="translated">Lines::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ddcac326a974acb99a5bdd0266258af4cf68f560" translate="yes" xml:space="preserve">
          <source>Lines::by_ref</source>
          <target state="translated">Lines::by_ref</target>
        </trans-unit>
        <trans-unit id="2210ca2bf58eac1157cb91245ab84bdb9fbfa42e" translate="yes" xml:space="preserve">
          <source>Lines::chain</source>
          <target state="translated">Lines::chain</target>
        </trans-unit>
        <trans-unit id="819432c98b0ed8115a058abc108fe41e16c028a7" translate="yes" xml:space="preserve">
          <source>Lines::clone</source>
          <target state="translated">Lines::clone</target>
        </trans-unit>
        <trans-unit id="3a9a20c42d37180cc289d3ed86b67aeef7065926" translate="yes" xml:space="preserve">
          <source>Lines::clone_from</source>
          <target state="translated">Lines::clone_from</target>
        </trans-unit>
        <trans-unit id="6d03cc14ec75314e6e9cd97f6317e2bfc576a512" translate="yes" xml:space="preserve">
          <source>Lines::clone_into</source>
          <target state="translated">Lines::clone_into</target>
        </trans-unit>
        <trans-unit id="2cc7e95a9a252a0e4512584de05d3735eda6c7e4" translate="yes" xml:space="preserve">
          <source>Lines::cloned</source>
          <target state="translated">Lines::cloned</target>
        </trans-unit>
        <trans-unit id="a59dde6acd33a5348665946c0a8673f286d24d8a" translate="yes" xml:space="preserve">
          <source>Lines::cmp</source>
          <target state="translated">Lines::cmp</target>
        </trans-unit>
        <trans-unit id="5fc1ed1cda1fe359bfcd4cfa1c08b06a6870ed72" translate="yes" xml:space="preserve">
          <source>Lines::collect</source>
          <target state="translated">Lines::collect</target>
        </trans-unit>
        <trans-unit id="40c012a06c39d10c7006c0601e73b3570aeddd35" translate="yes" xml:space="preserve">
          <source>Lines::copied</source>
          <target state="translated">Lines::copied</target>
        </trans-unit>
        <trans-unit id="484755e089b99c626b30d970a194b907cb3dceef" translate="yes" xml:space="preserve">
          <source>Lines::count</source>
          <target state="translated">Lines::count</target>
        </trans-unit>
        <trans-unit id="f9088b84e14bdd699a44622c6a8c96e4ac54b67c" translate="yes" xml:space="preserve">
          <source>Lines::cycle</source>
          <target state="translated">Lines::cycle</target>
        </trans-unit>
        <trans-unit id="bb1a7e9933496da163e7e92f98497488344c4b65" translate="yes" xml:space="preserve">
          <source>Lines::enumerate</source>
          <target state="translated">Lines::enumerate</target>
        </trans-unit>
        <trans-unit id="e403dedf91eb2082514d2e5162543f8e68efb7da" translate="yes" xml:space="preserve">
          <source>Lines::eq</source>
          <target state="translated">Lines::eq</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
