<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="74ec56d1bf817c0befd406275e3cdc68acd63801" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9f752b0935e93abaf0f9500cbb548195f26e0793" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a8dd251a1207d4e11e3d10d61c6d014b2646ff37" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="900d145487fbb075cf35b7f31871559fc4e06aea" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="ccd5990162f9019755ca0861aec17eeb838635c5" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="df27b63255e5ca4dd10ee3931d89a214cb7a79e8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b1ea069ef9327f5c3a1a861557ea04c82575ae3c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a3f52e8e92525a9484f9ea21a413660d15607c54" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="cc590a03de1082f370b8b404e093e91ac5cb0306" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Verbatim&quot;&gt;&lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Verbatim&quot;&gt; &lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="5aa296add133e61d06a6d4259d1fb0881eb7bd39" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="f6b929546a75faa42e8181de8ca57bcfbd173f85" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimUNC&quot;&gt;&lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimUNC&quot;&gt; &lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9cd9ad739de8cce934db346fc40fc958c8b3429e" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="31c97026aa6d07f6414185d909730c36779144a9" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="61e6c90d5de31882b090799d674e61ef0d0f389c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="dc8ede49b45bb296751c2a5d3ace189c5a80e69c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="6b8f56e3c79b5975e1be195dd3734989bee366c7" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8d30ecbd2f33931b54af81e7b1473f6ce8c0ba0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;NOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type&lt;/a&gt;&lt;/strong&gt;. This includes Inf and NaN. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;NOTA: actualmente, esto causar&amp;aacute; un comportamiento indefinido si el valor redondeado no puede ser representado por el tipo de entero de destino&lt;/a&gt;&lt;/strong&gt; . Esto incluye Inf y NaN. Esto es un error y se solucionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="92971d62fe3186475f026398e7a0174099738633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;NOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32&lt;/a&gt;&lt;/strong&gt;. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;NOTA: actualmente, esto causar&amp;aacute; un comportamiento indefinido si el valor es finito pero mayor o menor que el valor finito m&amp;aacute;s grande o m&amp;aacute;s peque&amp;ntilde;o representable por f32&lt;/a&gt;&lt;/strong&gt; . Esto es un error y se solucionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="1afbb08e18a2a8950ebdff5b3534ae0f7e3fd83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can make the program slower, so this attribute should be used with care.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Nota&lt;/em&gt;&lt;/strong&gt; : Elcompilador &lt;code&gt;rustc&lt;/code&gt; integra autom&amp;aacute;ticamente funciones basadas en heur&amp;iacute;sticas internas. La inserci&amp;oacute;n incorrecta de funciones puede hacer que el programa sea m&amp;aacute;s lento, por lo que este atributo debe usarse con cuidado.</target>
        </trans-unit>
        <trans-unit id="52af196e2df7d6d1d70d4b20971e00ada5feef77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; Dereferencing an unaligned pointer is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; and it is possible to &lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt;safely create unaligned pointers to &lt;code&gt;packed&lt;/code&gt; fields&lt;/a&gt;. Like all ways to create undefined behavior in safe Rust, this is a bug.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Advertencia:&lt;/em&gt;&lt;/strong&gt; Desreferenciar un puntero no alineado es&lt;a href=&quot;behavior-considered-undefined&quot;&gt; un comportamiento indefinido&lt;/a&gt; y es posible&lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt; crear de forma segura punteros no alineados a campos &lt;code&gt;packed&lt;/code&gt; &lt;/a&gt; . Como todas las formas de crear un comportamiento indefinido en Safe Rust, esto es un error.</target>
        </trans-unit>
        <trans-unit id="641eae7d16c8e6d62bab0c62010b11532ce2de80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; For &lt;a href=&quot;../types/trait-object&quot;&gt;trait objects&lt;/a&gt;, if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression. Instead, you can call the method using &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt;, in which case it calls the trait method, not the inherent method. There is no way to call the inherent method. Just don't define inherent methods on trait objects with the same name a trait method and you'll be fine.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Advertencia:&lt;/em&gt;&lt;/strong&gt; para los&lt;a href=&quot;../types/trait-object&quot;&gt; objetos de rasgo&lt;/a&gt; , si hay un m&amp;eacute;todo inherente del mismo nombre que un m&amp;eacute;todo de rasgo, dar&amp;aacute; un error de compilador al intentar llamar al m&amp;eacute;todo en una expresi&amp;oacute;n de llamada de m&amp;eacute;todo. En su lugar, puede llamar al m&amp;eacute;todo utilizando la&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt; sintaxis de llamada de funci&amp;oacute;n que elimina la ambig&amp;uuml;edad&lt;/a&gt; , en cuyo caso llama al m&amp;eacute;todo de rasgo, no al m&amp;eacute;todo inherente. No hay forma de llamar al m&amp;eacute;todo inherente. Simplemente no defina m&amp;eacute;todos inherentes en objetos de rasgo con el mismo nombre que un m&amp;eacute;todo de rasgo y estar&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="14f5badea1be2736539096eaf684db8c5d26b01b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; The following list is not exhaustive. There is no formal model of Rust's semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. The following list is just what we know for sure is undefined behavior. Please read the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;Rustonomicon&lt;/a&gt; before writing unsafe code.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Advertencia:&lt;/em&gt;&lt;/strong&gt; la siguiente lista no es exhaustiva. No existe un modelo formal de la sem&amp;aacute;ntica de Rust para lo que est&amp;aacute; y no est&amp;aacute; permitido en el c&amp;oacute;digo inseguro, por lo que puede haber m&amp;aacute;s comportamientos considerados inseguros. La siguiente lista es lo que sabemos con certeza es un comportamiento indefinido. Lea el&lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt; Rustonomicon&lt;/a&gt; antes de escribir c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="0029a09af0cc0f5afc1611697c9ad1ed7b7d0cfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; With two trait object types, even when the complete set of traits is the same, if the base traits differ, the type is different. For example, &lt;code&gt;dyn Send + Sync&lt;/code&gt; is a different type from &lt;code&gt;dyn Sync + Send&lt;/code&gt;. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt;issue 33140&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Advertencia:&lt;/em&gt;&lt;/strong&gt; Con dos tipos de objetos de rasgos, incluso cuando el conjunto completo de rasgos es el mismo, si los rasgos b&amp;aacute;sicos difieren, el tipo es diferente. Por ejemplo, &lt;code&gt;dyn Send + Sync&lt;/code&gt; es un tipo diferente de &lt;code&gt;dyn Sync + Send&lt;/code&gt; . Consulte el&lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt; n&amp;uacute;mero 33140&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee107fe206809602998471109ca3cf88bae2bbb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2015&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer 2015&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="086e314e305cc39ba4d4b327b89e5d7a0d8c6f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2018+&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer 2018+&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32563aa7feb766e8d7e65307f8bc48e47003b702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3ac7aad80402b534d708e407025f17f7772a4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="13ea811ecc594e94181b24eb80a75c60e5e29672" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4284bd4d709ac711e8c06bbdaf51939ae42316ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="04d38a540329625df538c94f4f56761b0074d0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;Tama&amp;ntilde;o de car&amp;aacute;cter&lt;/strong&gt; : las cadenas C pueden usar &lt;strong&gt;caracteres de tama&amp;ntilde;o &lt;/strong&gt; &lt;code&gt;char&lt;/code&gt; o &lt;code&gt;wchar_t&lt;/code&gt; ; tenga en &lt;strong&gt;cuenta&lt;/strong&gt; que el &lt;code&gt;char&lt;/code&gt; de C es diferente al de Rust. El est&amp;aacute;ndar C deja los tama&amp;ntilde;os reales de esos tipos abiertos a interpretaci&amp;oacute;n, pero define diferentes API para cadenas formadas por cada tipo de car&amp;aacute;cter. Las cadenas de Rust son siempre UTF-8, por lo que se codificar&amp;aacute;n diferentes caracteres Unicode en un n&amp;uacute;mero variable de bytes cada uno. El &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; tipo Rust representa un ' &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;valor escalar Unicode&lt;/a&gt; ', que es similar, pero no igual, a un ' &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;punto de c&amp;oacute;digo Unicode&lt;/a&gt; '.</target>
        </trans-unit>
        <trans-unit id="0ce042add186ebd327aa00b3f56f494c53302773" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1da5390166def59a905c5a3bf23d0d789eae735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700eaca40cee125f38cc4d75b02d62979fde8825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Crates:&lt;/strong&gt; A tree of modules that produces a library or executable</source>
          <target state="translated">&lt;strong&gt;Cajas:&lt;/strong&gt; un &amp;aacute;rbol de m&amp;oacute;dulos que produce una biblioteca o ejecutable</target>
        </trans-unit>
        <trans-unit id="e782bb6068e1aacf17c4b0b3ec1d9875e47c4925" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer:&lt;/strong&gt; These system calls might change over time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8b3462b6d6c541b754f0aec381f7e706c421ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 Edition, the crate root contains a variety of different items, including external crates, default crates such as &lt;code&gt;std&lt;/code&gt; and &lt;code&gt;core&lt;/code&gt;, and items in the top level of the crate (including &lt;code&gt;use&lt;/code&gt; imports).</source>
          <target state="translated">&lt;strong&gt;Diferencias Edition&lt;/strong&gt; : En el 2015 Edition, la ra&amp;iacute;z del caj&amp;oacute;n contiene una variedad de diferentes art&amp;iacute;culos, incluyendo cajas externas, por defecto ba&amp;uacute;les tales como &lt;code&gt;std&lt;/code&gt; y &lt;code&gt;core&lt;/code&gt; , y los art&amp;iacute;culos en el nivel superior de la jaula (incluyendo &lt;code&gt;use&lt;/code&gt; las importaciones).</target>
        </trans-unit>
        <trans-unit id="e088bfe5ad018353c64bdbb01968dcde42ba3d14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, &lt;code&gt;use&lt;/code&gt; paths also allow accessing items in the crate root. Using the example above, the following &lt;code&gt;use&lt;/code&gt; paths work in 2015 but not 2018:</source>
          <target state="translated">&lt;strong&gt;Diferencias de edici&amp;oacute;n&lt;/strong&gt; : en la edici&amp;oacute;n de 2015, las rutas de &lt;code&gt;use&lt;/code&gt; tambi&amp;eacute;n permiten acceder a elementos en la ra&amp;iacute;z de la caja. Usando el ejemplo anterior, las siguientes rutas de &lt;code&gt;use&lt;/code&gt; funcionan en 2015 pero no en 2018:</target>
        </trans-unit>
        <trans-unit id="627f712f9b93a0a851f59c926530c05272107ff4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, crates in the extern prelude cannot be referenced via &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt;, so it is generally standard practice to include &lt;code&gt;extern crate&lt;/code&gt; declarations to bring them into scope.</source>
          <target state="translated">&lt;strong&gt;Diferencias de edici&amp;oacute;n&lt;/strong&gt; : en la edici&amp;oacute;n de 2015, no se puede hacer referencia a las cajas en el preludio externo mediante &lt;a href=&quot;use-declarations&quot;&gt;declaraciones de uso&lt;/a&gt; , por lo que generalmente es una pr&amp;aacute;ctica est&amp;aacute;ndar incluir declaraciones de &lt;code&gt;extern crate&lt;/code&gt; para ponerlas en el alcance.</target>
        </trans-unit>
        <trans-unit id="f5085a0b269138950b893252f1966657953ef4b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, if the first bound of the trait object is a path that starts with &lt;code&gt;::&lt;/code&gt;, then the &lt;code&gt;dyn&lt;/code&gt; will be treated as a part of the path. The first path can be put in parenthesis to get around this. As such, if you want a trait object with the trait &lt;code&gt;::your_module::Trait&lt;/code&gt;, you should write it as &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Diferencias de edici&amp;oacute;n&lt;/strong&gt; : en la edici&amp;oacute;n de 2015, si el primer l&amp;iacute;mite del objeto de rasgo es una ruta que comienza con &lt;code&gt;::&lt;/code&gt; , entonces el &lt;code&gt;dyn&lt;/code&gt; se tratar&amp;aacute; como parte de la ruta. La primera ruta se puede poner entre par&amp;eacute;ntesis para evitar esto. Como tal, si desea un objeto de rasgo con el rasgo &lt;code&gt;::your_module::Trait&lt;/code&gt; , debe escribirlo como &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d876e32afa65f2d220b1dd922c7a25c124ae5c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. &lt;code&gt;fn foo(u8)&lt;/code&gt;). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.</source>
          <target state="translated">&lt;strong&gt;Diferencias de edici&amp;oacute;n&lt;/strong&gt; : En la edici&amp;oacute;n de 2015, es posible declarar m&amp;eacute;todos de rasgo con par&amp;aacute;metros an&amp;oacute;nimos (por ejemplo, &lt;code&gt;fn foo(u8)&lt;/code&gt; ). Esto est&amp;aacute; desaprobado y es un error a partir de la edici&amp;oacute;n 2018. Todos los par&amp;aacute;metros deben tener un nombre de argumento.</target>
        </trans-unit>
        <trans-unit id="d8a4eb3a8ecd26bd2a8200c1aa407e7c962a47c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, this syntax is valid that is disallowed as of the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;Diferencias de edici&amp;oacute;n&lt;/strong&gt; : en la edici&amp;oacute;n de 2015, esta sintaxis es v&amp;aacute;lida y no est&amp;aacute; permitida a partir de la edici&amp;oacute;n de 2018.</target>
        </trans-unit>
        <trans-unit id="e6c48e95dbd2c5b344112038b2d6d28be512c6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: Starting with the 2018 edition, paths for &lt;code&gt;pub(in path)&lt;/code&gt; must start with &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, or &lt;code&gt;super&lt;/code&gt;. The 2015 edition may also use paths starting with &lt;code&gt;::&lt;/code&gt; or modules from the crate root.</source>
          <target state="translated">&lt;strong&gt;Diferencias de edici&amp;oacute;n&lt;/strong&gt; : a partir de la edici&amp;oacute;n 2018, las rutas para &lt;code&gt;pub(in path)&lt;/code&gt; deben comenzar con &lt;code&gt;crate&lt;/code&gt; , &lt;code&gt;self&lt;/code&gt; o &lt;code&gt;super&lt;/code&gt; . La edici&amp;oacute;n 2015 tambi&amp;eacute;n puede usar rutas que comiencen con &lt;code&gt;::&lt;/code&gt; o m&amp;oacute;dulos de la ra&amp;iacute;z de la caja.</target>
        </trans-unit>
        <trans-unit id="62a6b70d43483dfe4d5b7b6c6b58326793ee331d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async blocks are only available beginning with Rust 2018.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffeac211f4d5959ca339c3909c25a46b1449c9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async functions are only available beginning with Rust 2018.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbba24256158782afff4e1bf3667267a636ed2ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Await expressions are only available beginning with Rust 2018.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd803d8196215afbdb722ca42ff6863ebfdce05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Encodings&lt;/strong&gt; - Rust strings are UTF-8, but C strings may use other encodings. If you are using a string from C, you should check its encoding explicitly, rather than just assuming that it is UTF-8 like you can do in Rust.</source>
          <target state="translated">&lt;strong&gt;Codificaciones&lt;/strong&gt; : las cadenas Rust son UTF-8, pero las cadenas C pueden usar otras codificaciones. Si est&amp;aacute; utilizando una cadena de C, debe verificar su codificaci&amp;oacute;n expl&amp;iacute;citamente, en lugar de simplemente asumir que es UTF-8 como puede hacer en Rust.</target>
        </trans-unit>
        <trans-unit id="c4744b4de56ac84ab4967b9e79393a7382d93137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Errors&lt;/strong&gt;: If the function returns a &lt;code&gt;Result&lt;/code&gt;, describing the kinds of errors that might occur and what conditions might cause those errors to be returned can be helpful to callers so they can write code to handle the different kinds of errors in different ways.</source>
          <target state="translated">&lt;strong&gt;Errores&lt;/strong&gt; : si la funci&amp;oacute;n devuelve un &lt;code&gt;Result&lt;/code&gt; , describir los tipos de errores que pueden ocurrir y las condiciones que pueden causar que se devuelvan esos errores puede ser &amp;uacute;til para las personas que llaman para que puedan escribir c&amp;oacute;digo para manejar los diferentes tipos de errores de diferentes maneras.</target>
        </trans-unit>
        <trans-unit id="ab2c858e00d5352d65014ede49ecfd4f78f2629f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="translated">&lt;strong&gt;De C a Rust: &lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; representa una cadena C prestada; es lo que usar&amp;iacute;a para ajustar un &lt;code&gt;*const &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; sin procesar&lt;/a&gt; que obtuvo de una funci&amp;oacute;n de C. Se garantiza que un &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; es una matriz de bytes terminada en nulo . Una vez que tenga un &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; , puede convertirlo en un Rust &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; si es UTF-8 v&amp;aacute;lido, o convertirlo con p&amp;eacute;rdidas agregando caracteres de reemplazo.</target>
        </trans-unit>
        <trans-unit id="be0edd96752d258e24714cab9620512785d60bc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a880c7c09fd0c1f69a3098a3095ef95bac0a546" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="translated">&lt;strong&gt;De Rust a C: &lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; representa una cadena compatible&lt;strong&gt; con C de&lt;/strong&gt; propiedad: termina en nulo y no tiene caracteres nulos internos. El c&amp;oacute;digo de Rust puede crear un &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; a&lt;/a&gt; partir de una cadena normal (siempre que la cadena no tenga caracteres nulos en el medio) y luego usar una variedad de m&amp;eacute;todos para obtener un &lt;code&gt;*mut &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; sin procesar&lt;/a&gt; que luego se puede pasar como argumento a funciones que utilizan las convenciones de C para cadenas.</target>
        </trans-unit>
        <trans-unit id="aae173511f045be6a9f0dfcffd69891dd82a8b0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2238adb64a05e56adbe151507af6c19abcbbbc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From a Rust string&lt;/strong&gt;: &lt;code&gt;OsString&lt;/code&gt; implements &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;, so you can use &lt;code&gt;my_string.from&lt;/code&gt; to create an &lt;code&gt;OsString&lt;/code&gt; from a normal Rust string.</source>
          <target state="translated">&lt;strong&gt;Desde una cadena Rust&lt;/strong&gt; : &lt;code&gt;OsString&lt;/code&gt; implementa &lt;a href=&quot;../convert/trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; , por lo que puede usar &lt;code&gt;my_string.from&lt;/code&gt; para crear una &lt;code&gt;OsString&lt;/code&gt; a partir de una cadena Rust normal.</target>
        </trans-unit>
        <trans-unit id="a856fdf688afa04d2bd84181c6260aaef0048cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;String::push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;struct.osstring#method.new&quot;&gt;&lt;code&gt;OsString::new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;struct.osstring#method.push&quot;&gt;&lt;code&gt;OsString::push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfbc9f4c9b7bf87cce69244480b633a8de2c39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;strong&gt;A partir de cortes: al&lt;/strong&gt; igual que puede comenzar con un Rust &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; vac&amp;iacute;o y luego &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; subcadenas de corte en &amp;eacute;l, puede crear un &lt;code&gt;OsString&lt;/code&gt; vac&amp;iacute;o con el &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo y luego insertar cortes de cadena en &amp;eacute;l con el m&amp;eacute;todo &lt;a href=&quot;#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5663223157e2b3d6031e4a48c107b41038aa63b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important.&lt;/strong&gt; At least at present, you should avoid using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; where the C definition is just using &lt;code&gt;T*&lt;/code&gt; can lead to undefined behavior, as described in &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines/issues/198&quot;&gt;rust-lang/unsafe-code-guidelines#198&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629ec911ccd79d718629d3b5e11521368319be97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internal nul characters&lt;/strong&gt; - When C strings have a nul terminator character, this usually means that they cannot have nul characters in the middle &amp;mdash; a nul character would essentially truncate the string. Rust strings &lt;em&gt;can&lt;/em&gt; have nul characters in the middle, because nul does not have to mark the end of the string in Rust.</source>
          <target state="translated">&lt;strong&gt;Caracteres nulos internos&lt;/strong&gt; : cuando las cadenas C tienen un car&amp;aacute;cter terminador nulo, esto generalmente significa que no pueden tener caracteres nulos en el medio; un car&amp;aacute;cter nulo esencialmente truncar&amp;iacute;a la cadena. Las cadenas de Rust &lt;em&gt;pueden&lt;/em&gt; tener caracteres nulos en el medio, porque nul no tiene que marcar el final de la cadena en Rust.</target>
        </trans-unit>
        <trans-unit id="b41d1a37bb22ed7e91444167c781b032f81cc870" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules&lt;/strong&gt; and &lt;strong&gt;use:&lt;/strong&gt; Let you control the organization, scope, and privacy of paths</source>
          <target state="translated">&lt;strong&gt;M&amp;oacute;dulos&lt;/strong&gt; y &lt;strong&gt;uso: le&lt;/strong&gt; permiten controlar la organizaci&amp;oacute;n, el alcance y la privacidad de las rutas.</target>
        </trans-unit>
        <trans-unit id="41c40dd8ed6820329fca0f856e36989c1fdbd2b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NB.&lt;/strong&gt; The never type was expected to be stabilized in 1.41, but due to some last minute regressions detected the stabilization was temporarily reverted. The &lt;code&gt;!&lt;/code&gt; type can only appear in function return types presently. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;the tracking issue&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060d89d923956472cc05e7319b76fa9d50a7e876" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE: The third invariant is currently unenforced due to historical oversight and significant reliance on the behaviour. It is currently undecided what to do about this going forward. Macros that do not respect the behaviour may become invalid in a future edition of Rust. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;tracking issue&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTA: El tercer invariante actualmente no se aplica debido a una supervisi&amp;oacute;n hist&amp;oacute;rica y una dependencia significativa del comportamiento. Actualmente no est&amp;aacute; decidido qu&amp;eacute; hacer al respecto en el futuro. Las macros que no respeten el comportamiento pueden dejar de ser v&amp;aacute;lidas en una edici&amp;oacute;n futura de Rust. Vea el &lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;problema de seguimiento&lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="379a60c8e2b4b827557b233553a6bc6c82683fa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: If a parent of the given path doesn't exist, this function will return an error. To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;strong&gt;NOTA&lt;/strong&gt; : Si no existe un padre de la ruta dada, esta funci&amp;oacute;n devolver&amp;aacute; un error. Para crear un directorio y todos sus padres faltantes al mismo tiempo, use la funci&amp;oacute;n &lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c177380835dd615160771cec4b0171b325482499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No matter what, Safe Rust can't cause Undefined Behavior&lt;/strong&gt;. This is referred to as &lt;a href=&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library&quot;&gt;soundness&lt;/a&gt;: a well-typed program actually has the desired properties. The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html&quot;&gt;Nomicon&lt;/a&gt; has a more detailed explanation on the subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6558cd07ee1a59a066bae7f1a7d1d4e7129c19ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota: este rasgo no debe fallar&lt;/strong&gt; . Si la conversi&amp;oacute;n puede fallar, use &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc7fd5e949a51b13efc359ef4faae3bf584089ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota: este rasgo no debe fallar&lt;/strong&gt; . Si la conversi&amp;oacute;n puede fallar, use &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5b6ef596678a6ec7ac86f37d73d853ca889a37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use a dedicated method which returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota: este rasgo no debe fallar&lt;/strong&gt; . Si la conversi&amp;oacute;n puede fallar, use un m&amp;eacute;todo dedicado que devuelva una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; o un &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7d81ecf2a6b96e00a858ce77d080e3c485f5c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you need to borrow a string that was allocated by foreign code, use &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. If you need to take ownership of a string that was allocated by foreign code, you will need to make your own provisions for freeing it appropriately, likely with the foreign code's API to do that.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Si necesita tomar prestada una cadena que fue asignada por c&amp;oacute;digo externo, use &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; . Si necesita tomar posesi&amp;oacute;n de una cadena que fue asignada por c&amp;oacute;digo externo, deber&amp;aacute; hacer sus propias disposiciones para liberarla de manera apropiada, probablemente con la API del c&amp;oacute;digo externo para hacerlo.</target>
        </trans-unit>
        <trans-unit id="64f82543ebfb5e0c22f3304371c4e50429156fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The future type that rustc generates is roughly equivalent to an enum with one variant per &lt;code&gt;await&lt;/code&gt; point, where each variant stores the data needed to resume from its corresponding point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2eeefa40f9901be73a381ca76c97ef76a1ea8ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2293fd49da6801b825298bc259cec03257c7fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b262d56cf8e8f408dcc17fe9b8801b4eb3fadab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b9eed4ac2d21cb27e6a0debb93f9f3a3bcc5a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;isize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44eefe3185a3db0f5cea7158f26fe463c75dc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1fea0129a87e0a989b444fe1258f62a320490b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e50b005c31c5d32ebfdba7f184b17a96b48b58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc61ff9f0824102bc626b9c7cdffa39c424b522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;usize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7305f68e95514e24a7c95d0883b00ea54e7a5611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9beca619923587f1e53345a612ee54183accda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4637566695ac5a54cd62243b48c42f9fc2ba5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This syntax only adds another restriction to the visibility of an item. It does not guarantee that the item is visible within all parts of the specified scope. To access an item, all of its parent items up to the current scope must still be visible as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133699edea54cc02f638b728f6d305bf0c4eb4aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d47c135cd7e9598aabb084d4e238fb2da1f926" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12df48c2a5ede4cad5f196c278170c76aa69b27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770d30f50039965c0a80bc18afb0f57006c8ecf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3770fb7d89c845d66075484dac6af6613879c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb007ca7675d599d0fd1022828e893745c373c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf286238fb78dad77f34b185f05fcd2ccdeabb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3460e7cb91ab667e7a2edc5f99bef2b41f79b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0118a9443b5848b0cf822fd3a311a3f6ce113f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de09eea9ef2bf2d098a984258c71927e3c4b2b70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc278c534e3be01a1f5e2970b2fd676ed81d535" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Uninitialized memory is also implicitly invalid for any type that has a restricted set of valid values. In other words, the only cases in which reading uninitialized memory is permitted are inside &lt;code&gt;union&lt;/code&gt;s and in &quot;padding&quot; (the gaps between the fields/elements of a type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb5d63cdf94e5456c6918112042bd1091e5e9f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; items, and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d46ac6d8774740d98a4009a231d2213aeed2a7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;rustc&lt;/code&gt; achieves this with the unstable &lt;code&gt;rustc_layout_scalar_valid_range_*&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50c739d9eb5da5613037181f561652a032953a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf68398fddb94f0a1abd51db31ce0b9347bd8495" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt;&lt;code&gt;proc_macro&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Las cajas adicionales que se env&amp;iacute;an con &lt;code&gt;rustc&lt;/code&gt; , como &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt; &lt;code&gt;proc_macro&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; , no se incluyen autom&amp;aacute;ticamente con la bandera &lt;code&gt;--extern&lt;/code&gt; cuando se usa Cargo. Deben incluirse en el &amp;aacute;mbito de aplicaci&amp;oacute;n con una declaraci&amp;oacute;n de &lt;code&gt;extern crate&lt;/code&gt; , incluso en la edici&amp;oacute;n de 2018.</target>
        </trans-unit>
        <trans-unit id="d2b504e0a31dcf2bae64d03c73c728e13b4132f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Configuration options with the key &lt;code&gt;feature&lt;/code&gt; are a convention used by &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo&lt;/a&gt; for specifying compile-time options and optional dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8381d4f5be828c7771e48194e3784bf6556e9d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e534aae954895e78357179a1ac94a40dd8cf86b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Para &lt;code&gt;rustc&lt;/code&gt; , las opciones de configuraci&amp;oacute;n establecidas arbitrariamente se establecen mediante la &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt; &lt;code&gt;--cfg&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c424a34ea4d877226958104553992541e3787ae9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In the past, the Rust community used the terms &quot;Unambiguous Function Call Syntax&quot;, &quot;Universal Function Call Syntax&quot;, or &quot;UFCS&quot;, in documentation, issues, RFCs, and other community writings. However, the term lacks descriptive power and potentially confuses the issue at hand. We mention it here for searchability's sake.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : En el pasado, la comunidad de Rust usaba los t&amp;eacute;rminos &quot;Sintaxis de llamada de funci&amp;oacute;n inequ&amp;iacute;voca&quot;, &quot;Sintaxis de llamada de funci&amp;oacute;n universal&quot; o &quot;UFCS&quot;, en documentaci&amp;oacute;n, problemas, RFC y otros escritos de la comunidad. Sin embargo, el t&amp;eacute;rmino carece de poder descriptivo y potencialmente confunde el tema en cuesti&amp;oacute;n. Lo mencionamos aqu&amp;iacute; por el bien de la b&amp;uacute;squeda.</target>
        </trans-unit>
        <trans-unit id="7e4168c7dfa2ff3fb21bdd3b2ee7e059ab5726bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Lifetimes can be, and usually are, elided with this shorthand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccc13cc797f7b85b663c8c0720dcbb028e2999f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Many pieces of Rust code may assume that pointers, &lt;code&gt;usize&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt; are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee6a6f44b42148913ce05336e8333f03b878a8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On platforms that do not support receiving spin-loop hints this function does not do anything at all.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : En las plataformas que no admiten la recepci&amp;oacute;n de sugerencias de bucle giratorio, esta funci&amp;oacute;n no hace nada en absoluto.</target>
        </trans-unit>
        <trans-unit id="3cd7dc42d46fc1a7eaf8316e86e18b4771b7a37c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Previous to &lt;code&gt;rustc&lt;/code&gt; 1.30, using &lt;code&gt;mod.rs&lt;/code&gt; files was the way to load a module with nested children. It is encouraged to use the new naming convention as it is more consistent, and avoids having many files named &lt;code&gt;mod.rs&lt;/code&gt; within a project.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Antes de &lt;code&gt;rustc&lt;/code&gt; 1.30, el uso de archivos &lt;code&gt;mod.rs&lt;/code&gt; era la forma de cargar un m&amp;oacute;dulo con elementos secundarios anidados. Se recomienda utilizar la nueva convenci&amp;oacute;n de nomenclatura ya que es m&amp;aacute;s coherente y evita tener muchos archivos denominados &lt;code&gt;mod.rs&lt;/code&gt; dentro de un proyecto.</target>
        </trans-unit>
        <trans-unit id="09dbeb2a0b5b6ab350517ca73457c241b60699f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : &lt;code&gt;cfg_attr&lt;/code&gt; puede expandirse a otro &lt;code&gt;cfg_attr&lt;/code&gt; . Por ejemplo, &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; es v&amp;aacute;lido. Este ejemplo ser&amp;iacute;a equivalente a &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48afce94d3f617db585b69f838ac8fa2fe7c7c45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542e5e434f17a5e7fe96f177447ca260c03e5782" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; test harness supports the &lt;code&gt;--include-ignored&lt;/code&gt; flag to force ignored tests to be run.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : El arn&amp;eacute;s de prueba &lt;code&gt;rustc&lt;/code&gt; admite la &lt;code&gt;--include-ignored&lt;/code&gt; para forzar la ejecuci&amp;oacute;n de las pruebas ignoradas.</target>
        </trans-unit>
        <trans-unit id="ee8746d1970619c1573d4cba9ddf4d37981ddfcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The LLVM backend of the &lt;code&gt;rustc&lt;/code&gt; implementation aborts the process by executing an illegal instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6a9b1648330a6c400057a929b0e006d7b0e3f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9663ac595985a9b26dbb960d0c43b0ba63112b12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The tuple index may include an &lt;code&gt;INTEGER_SUFFIX&lt;/code&gt;, but this is not intended to be valid, and may be removed in a future version. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60210&quot;&gt;https://github.com/rust-lang/rust/issues/60210&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e578eea7529dc499f5ab70e8ee02f1a3a04f7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function returns an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta funci&amp;oacute;n devuelve una matriz de 2, 4 u 8 bytes de longitud, seg&amp;uacute;n el tama&amp;ntilde;o del puntero de destino.</target>
        </trans-unit>
        <trans-unit id="204f556d6eb284d02edf2bf12e7415dff429dcbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function takes an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta funci&amp;oacute;n toma una matriz de 2, 4 u 8 bytes de longitud, dependiendo del tama&amp;ntilde;o del puntero de destino.</target>
        </trans-unit>
        <trans-unit id="205669dd54e34ac0f225ea4e8c1e039e92861b84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is an example note.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta es una nota de ejemplo.</target>
        </trans-unit>
        <trans-unit id="4f8175ab0b6ced026c78c226ce62e4e0326a00cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a 0-cost cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este m&amp;eacute;todo se implementa actualmente como una conversi&amp;oacute;n de costo 0, pero se planea modificar su definici&amp;oacute;n en el futuro para realizar el c&amp;aacute;lculo de longitud cada vez que se llame a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="9364ca407d4e4789b372b4d12ec8ebcdd47debe7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este m&amp;eacute;todo se implementa actualmente como una conversi&amp;oacute;n de tiempo constante, pero se planea modificar su definici&amp;oacute;n en el futuro para realizar el c&amp;aacute;lculo de longitud cada vez que se llame a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="9acff81794f805a2a107dfa5d332d79517391aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented to check for validity after a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation in addition to the UTF-8 check whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Este m&amp;eacute;todo se implementa actualmente para verificar la validez despu&amp;eacute;s de una conversi&amp;oacute;n de tiempo constante, pero se planea alterar su definici&amp;oacute;n en el futuro para realizar el c&amp;aacute;lculo de longitud adem&amp;aacute;s de la verificaci&amp;oacute;n UTF-8 siempre que se llame a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="77e80de2eb59d874ef66f952f67864f1b6680268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416612bbf1909b1aaf73c8e8594ced2ad9b5958a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798babd1633ffc3445fb72738f51aaf665f2e799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f814fd42a6f3586c98e8e6d74c5e1cf0d998f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a8e7d995f2b7f517cfd0675f44c74f193e4d3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7cf4f75cf7c1494a07e470c8288c8e67f0a8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902c1326c59de40d4ee4bf24e303fa8f00886b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49fa7c747b4b2f8fc4c2e1fee0ddd570ecece9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60105950473e3de294db7b21f197086831cb667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be6463d1fafa0db1e322e03e3852c3a451379a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c5be5853f961e5512f727adc94106859254411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This operation is intended to be a 0-cost cast but it is currently implemented with an up-front calculation of the length of the string. This is not guaranteed to always be the case.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esta operaci&amp;oacute;n est&amp;aacute; destinada a ser una conversi&amp;oacute;n de costo 0, pero actualmente se implementa con un c&amp;aacute;lculo inicial de la longitud de la cadena. No se garantiza que este sea siempre el caso.</target>
        </trans-unit>
        <trans-unit id="669d4b633ce688c467334ac7653c165183f2e3ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section is incomplete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543aaedbc9a3d7322ce93678b22b0281abf794f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245a6aeba0c030e92193a51c1b871f48d851f54f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of pointers. Its size depends on the target pointer's size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5df3103e6447e1ad2ce9490f42afb19650917b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : El comportamiento indefinido afecta a todo el programa. Por ejemplo, llamar a una funci&amp;oacute;n en C que exhibe un comportamiento indefinido de C significa que todo el programa contiene un comportamiento indefinido que tambi&amp;eacute;n puede afectar el c&amp;oacute;digo de Rust. Y viceversa, el comportamiento indefinido en Rust puede causar efectos adversos en el c&amp;oacute;digo ejecutado por cualquier llamada FFI a otros lenguajes.</target>
        </trans-unit>
        <trans-unit id="9b1e7bb136e3f88a33c4a3167dcad6a39cd6165d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike field access expressions, tuple index expressions can be the function operand of a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; as it cannot be confused with a method call since method names cannot be numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf566863d0e6c1f93fa47ff736f9ade81dd38c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When using Cargo, Procedural macro crates are defined with the &lt;code&gt;proc-macro&lt;/code&gt; key in your manifest:</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Al usar Cargo, las cajas de macro de procedimiento se definen con la clave &lt;code&gt;proc-macro&lt;/code&gt; en su manifiesto:</target>
        </trans-unit>
        <trans-unit id="a7f8ef7c18d1ebc911a4b8802c9c294409605f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Whitespace around the &lt;code&gt;=&lt;/code&gt; is ignored. &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; and &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; are equivalent configuration options.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Se ignoran los espacios en blanco alrededor de &lt;code&gt;=&lt;/code&gt; . &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; y &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; son opciones de configuraci&amp;oacute;n equivalentes.</target>
        </trans-unit>
        <trans-unit id="c47f0cd1f3859cc5bbc515bae176883c35a2e5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0b8f99436f4b7d93b7e3e4bd936fecc9cacde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : que la &lt;code&gt;match&lt;/code&gt; externa se utiliza para garantizar que &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;los valores temporales&lt;/a&gt; en &lt;code&gt;iter_expr&lt;/code&gt; no se eliminen antes de que finalice el ciclo. &lt;code&gt;next&lt;/code&gt; se declara antes de ser asignado porque da como resultado que los tipos se infieran correctamente con m&amp;aacute;s frecuencia.</target>
        </trans-unit>
        <trans-unit id="3d08b1d0d9771f64d914289f8a909594611ec769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this list is more restrictive than what you can write in regular constants</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : esta lista es m&amp;aacute;s restrictiva de lo que puede escribir en constantes regulares</target>
        </trans-unit>
        <trans-unit id="ff87edb614dc63eb552a33d527babfe470e595e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this module is unstable and is designed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md&quot;&gt;RFC 2504&lt;/a&gt;, and you can learn more about its status in the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/53487&quot;&gt;tracking issue&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0d06bb798430870d22a876657b39e78b6fbe0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a &lt;code&gt;O(1)&lt;/code&gt; operation (because the length is stored); in C it is an &lt;code&gt;O(length)&lt;/code&gt; operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484956955d43e1da5356d63148d3bf3ffefed245" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a O(1) operation (because the length is stored); in C it is an O(length) operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="translated">&lt;strong&gt;Terminadores nulos y longitudes de cadenas impl&amp;iacute;citas&lt;/strong&gt; : a menudo, las cadenas C terminan en nulo, es decir, tienen un car&amp;aacute;cter &lt;code&gt;\0&lt;/code&gt; al final. La longitud de un b&amp;uacute;fer de cadena no se almacena, pero debe calcularse; para calcular la longitud de una cadena, c&amp;oacute;digo C debe llamar manualmente una funci&amp;oacute;n como &lt;code&gt;strlen()&lt;/code&gt; para &lt;code&gt;char&lt;/code&gt; basados en cadenas o &lt;code&gt;wcslen()&lt;/code&gt; para &lt;code&gt;wchar_t&lt;/code&gt; los basados. Esas funciones devuelven el n&amp;uacute;mero de caracteres en la cadena excluyendo el terminador nulo, por lo que la longitud del b&amp;uacute;fer es realmente &lt;code&gt;len+1&lt;/code&gt; caracteres. Las cadenas de &amp;oacute;xido no tienen un terminador nulo; su longitud siempre se almacena y no es necesario calcularla. Mientras que en Rust acceder a la longitud de una cadena es una operaci&amp;oacute;n O (1) (porque la longitud est&amp;aacute; almacenada); en C es una operaci&amp;oacute;n O (longitud) porque la longitud debe calcularse escaneando la cadena en busca del terminador nulo.</target>
        </trans-unit>
        <trans-unit id="b3a55015f9b574b249377781d35ad1256b26e09a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Packages:&lt;/strong&gt; A Cargo feature that lets you build, test, and share crates</source>
          <target state="translated">&lt;strong&gt;Paquetes:&lt;/strong&gt; una funci&amp;oacute;n de carga que le permite construir, probar y compartir cajas</target>
        </trans-unit>
        <trans-unit id="b9614e48c420558746aa5a195f1ca3514d9bdb89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Panics&lt;/strong&gt;: The scenarios in which the function being documented could panic. Callers of the function who don&amp;rsquo;t want their programs to panic should make sure they don&amp;rsquo;t call the function in these situations.</source>
          <target state="translated">&lt;strong&gt;P&amp;aacute;nicos&lt;/strong&gt; : los escenarios en los que la funci&amp;oacute;n que se est&amp;aacute; documentando podr&amp;iacute;a entrar en p&amp;aacute;nico. Las personas que llaman a la funci&amp;oacute;n que no quieren que sus programas entren en p&amp;aacute;nico deben asegurarse de no llamar a la funci&amp;oacute;n en estas situaciones.</target>
        </trans-unit>
        <trans-unit id="48ddec251d4b93c950c826aa556ff50e924f3f09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paths:&lt;/strong&gt; A way of naming an item, such as a struct, function, or module</source>
          <target state="translated">&lt;strong&gt;Rutas:&lt;/strong&gt; una forma de nombrar un elemento, como una estructura, funci&amp;oacute;n o m&amp;oacute;dulo</target>
        </trans-unit>
        <trans-unit id="481513e92d2c79e9922e6fdaeaecbe26904d2dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safety&lt;/strong&gt;: If the function is &lt;code&gt;unsafe&lt;/code&gt; to call (we discuss unsafety in Chapter 19), there should be a section explaining why the function is unsafe and covering the invariants that the function expects callers to uphold.</source>
          <target state="translated">&lt;strong&gt;Seguridad&lt;/strong&gt; : si la funci&amp;oacute;n &lt;code&gt;unsafe&lt;/code&gt; es segura para llamar (discutimos la inseguridad en el Cap&amp;iacute;tulo 19), deber&amp;iacute;a haber una secci&amp;oacute;n que explique por qu&amp;eacute; la funci&amp;oacute;n no es segura y cubra las invariantes que la funci&amp;oacute;n espera que los llamantes mantengan.</target>
        </trans-unit>
        <trans-unit id="f938faca9bb27bfed4287077e548ce31cbf39365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stability note:&lt;/strong&gt; This impl does not yet exist, but we are &quot;reserving space&quot; to add it in the future. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64715&quot;&gt;rust-lang/rust#64715&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e43e997b28aeec3b9c71554f3cb60497761adcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Supertraits&lt;/strong&gt; are traits that are required to be implemented for a type to implement a specific trait. Furthermore, anywhere a &lt;a href=&quot;generics&quot;&gt;generic&lt;/a&gt; or &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt; is bounded by a trait, it has access to the associated items of its supertraits.</source>
          <target state="translated">&lt;strong&gt;Los supertraits&lt;/strong&gt; son rasgos que deben implementarse para que un tipo implemente un rasgo espec&amp;iacute;fico. Adem&amp;aacute;s, en cualquier lugar en el que un &lt;a href=&quot;../types/trait-object&quot;&gt;objeto &lt;/a&gt;&lt;a href=&quot;generics&quot;&gt;gen&amp;eacute;rico&lt;/a&gt; o de rasgo est&amp;eacute; delimitado por un rasgo, tiene acceso a los elementos asociados de sus supertraits.</target>
        </trans-unit>
        <trans-unit id="b38548e4d26b2038d4463b0d5471fd35986ae8ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This function is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3ae627337dcbcd948c51fd96893635d151265e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This functon is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Esta funci&amp;oacute;n est&amp;aacute; obsoleta. &lt;/strong&gt;Utilice &lt;a href=&quot;union.maybeuninit&quot;&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="90d5331accb6d1f759b6d533c2ffbb7485074384" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This method is soft-deprecated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Este m&amp;eacute;todo est&amp;aacute; obsoleto.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2492dfd60adc66b908569e7ad4f918b77633047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type coercions&lt;/strong&gt; are implicit operations that change the type of a value. They happen automatically at specific locations and are highly restricted in what types actually coerce.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd5055ffa46d984c313532603ca78647862a3d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unix&lt;/strong&gt;: On Unix-like platforms, it is unlikely that all 32 bits of &lt;code&gt;exit&lt;/code&gt; will be visible to a parent process inspecting the exit code. On most Unix-like platforms, only the eight least-significant bits are considered.</source>
          <target state="translated">&lt;strong&gt;Unix&lt;/strong&gt; : en plataformas similares a Unix, es poco probable que los 32 bits de &lt;code&gt;exit&lt;/code&gt; sean visibles para un proceso padre que inspecciona el c&amp;oacute;digo de salida. En la mayor&amp;iacute;a de las plataformas similares a Unix, solo se consideran los ocho bits menos significativos.</target>
        </trans-unit>
        <trans-unit id="4c1aa9b3c8e196e8c2b0242b80db4f7600ac8956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version &amp;amp; Edition Differences&lt;/strong&gt;: Prior to Rust 1.30, &lt;code&gt;$crate&lt;/code&gt; and &lt;code&gt;local_inner_macros&lt;/code&gt; (below) were unsupported. They were added alongside path-based imports of macros (described above), to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use &lt;code&gt;$crate&lt;/code&gt; or &lt;code&gt;local_inner_macros&lt;/code&gt; to work well with path-based imports.</source>
          <target state="translated">&lt;strong&gt;Diferencias de versi&amp;oacute;n y edici&amp;oacute;n&lt;/strong&gt; : antes de Rust 1.30, &lt;code&gt;$crate&lt;/code&gt; &lt;code&gt;local_inner_macros&lt;/code&gt; y local_inner_macros (a continuaci&amp;oacute;n) no eran compatibles. Se agregaron junto con las importaciones de macros basadas en rutas (descritas anteriormente), para garantizar que los usuarios de una caja de macroexportaci&amp;oacute;n no tuvieran que importar manualmente las macros auxiliares. Las cajas escritas para versiones anteriores de Rust que usan macros auxiliares deben modificarse para usar &lt;code&gt;$crate&lt;/code&gt; &lt;code&gt;local_inner_macros&lt;/code&gt; o local_inner_macros para que funcionen bien con importaciones basadas en rutas.</target>
        </trans-unit>
        <trans-unit id="a61fe7dcc9b944b7aa4bb3863418ae332c93ffba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;WARNING&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70d92d3e972f8d8fddf85474fbc20df429ca9e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: While various forms of this were discussed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC #1937&lt;/a&gt;, it was ultimately cut from that RFC, and thus this type is more subject to change even than the usual unstable item churn.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : Si bien se discutieron varias formas de esto en &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC # 1937&lt;/a&gt; , finalmente se elimin&amp;oacute; de ese RFC y, por lo tanto, este tipo est&amp;aacute; m&amp;aacute;s sujeto a cambios incluso que la rotaci&amp;oacute;n habitual de elementos inestables.</target>
        </trans-unit>
        <trans-unit id="430cf372e21694405a7f29b4ea7aae36bbc30335" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0a5afaa9ee5bac968c87333877722aa1495b952b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="488963209bc6867c0591ac82a1cb9c1a6a118fd7" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt;. It has the following grammar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ab7f7217b5214e279ea052fb2ed3cfbd58c8f2" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt; and the &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;meta&lt;/code&gt; macro fragment specifier&lt;/a&gt;. It has the following grammar:</source>
          <target state="translated">Un &quot;elemento meta&quot; es la sintaxis utilizada para la regla &lt;em&gt;Attr&lt;/em&gt; por la mayor&amp;iacute;a &lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;de los atributos incorporados&lt;/a&gt; y el &lt;a href=&quot;macros-by-example&quot;&gt;especificador de fragmentos &lt;/a&gt; &lt;code&gt;meta&lt;/code&gt; macro . Tiene la siguiente gram&amp;aacute;tica:</target>
        </trans-unit>
        <trans-unit id="22d3a6ec1e16d0b77c16e420bbe8e26c33c2811f" translate="yes" xml:space="preserve">
          <source>A &quot;stack allocated string&quot;:</source>
          <target state="translated">Una &quot;cadena de asignación de pila&quot;:</target>
        </trans-unit>
        <trans-unit id="b64a876ef415d016ec9dc92ffaf76e9ab89ca04f" translate="yes" xml:space="preserve">
          <source>A 'radix' here is sometimes also called a 'base'. A radix of two indicates a binary number, a radix of ten, decimal, and a radix of sixteen, hexadecimal, to give some common values. Arbitrary radices are supported.</source>
          <target state="translated">Un &quot;radix&quot; aquí es a veces también llamado &quot;base&quot;.Un radix de dos indica un número binario,un radix de diez,decimal,y un radix de dieciséis,hexadecimal,para dar algunos valores comunes.Se admiten radices arbitrarios.</target>
        </trans-unit>
        <trans-unit id="41c53bc2a64d3e62babdedd9c3047a7e08995ee3" translate="yes" xml:space="preserve">
          <source>A (half-open) range bounded inclusively below and exclusively above (&lt;code&gt;start..end&lt;/code&gt;).</source>
          <target state="translated">Un rango (semiabierto) delimitado inclusive por debajo y exclusivamente por arriba ( &lt;code&gt;start..end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e85a39e82a0e6ccf8c895d65c91fa1d7ce99d7cb" translate="yes" xml:space="preserve">
          <source>A 32-bit floating point type (specifically, the &quot;binary32&quot; type defined in IEEE 754-2008).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10239381d11a9cda1bbf8cfa43daeb6653a356ab" translate="yes" xml:space="preserve">
          <source>A 64-bit floating point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a791c9e3c1b8c3cb3ad7090a3f0956b3498d4ea" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c403143d347d88d290407287e086a1c24df257de" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3523931588ba19ab3285934f4c9625ad5b0ff3e8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43257c2bbdee41f14d8f6aab49394bf581fd3e4e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1847a494c164bc5812c67ca50bfe2768f6e254d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../expressions/closure-expr&quot;&gt;closure expression&lt;/a&gt; produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables. For instance, the following closure:</source>
          <target state="translated">Una &lt;a href=&quot;../expressions/closure-expr&quot;&gt;expresi&amp;oacute;n de cierre&lt;/a&gt; produce un valor de cierre con un tipo &amp;uacute;nico y an&amp;oacute;nimo que no se puede escribir. Un tipo de cierre es aproximadamente equivalente a una estructura que contiene las variables capturadas. Por ejemplo, el siguiente cierre:</target>
        </trans-unit>
        <trans-unit id="3cfb72d2748a10ee8855d86ad887d39ff3f43dfe" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; used as an expression context denotes either a local variable or an item. Path expressions that resolve to local or static variables are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expressions&lt;/a&gt;, other paths are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt;. Using a &lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt;&lt;code&gt;static mut&lt;/code&gt;&lt;/a&gt; variable requires an &lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt; block&lt;/a&gt;.</source>
          <target state="translated">Una &lt;a href=&quot;../paths&quot;&gt;ruta&lt;/a&gt; utilizada como contexto de expresi&amp;oacute;n denota una variable local o un elemento. Las expresiones de ruta que se resuelven en variables locales o est&amp;aacute;ticas son &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresiones de lugar&lt;/a&gt; , otras rutas son &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresiones de valor&lt;/a&gt; . El uso de una variable &lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt; &lt;code&gt;static mut&lt;/code&gt; &lt;/a&gt; requiere un &lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt;bloque &lt;/a&gt; &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c135626ccc454eee440ccf3a13f0ec15be919ba" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">Un &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; es un &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;valor escalar Unicode&lt;/a&gt; , lo que significa que es un &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;punto de c&amp;oacute;digo&lt;/a&gt; , pero solo los que est&amp;aacute;n dentro de un cierto rango. &lt;code&gt;MAX&lt;/code&gt; es el punto de c&amp;oacute;digo v&amp;aacute;lido m&amp;aacute;s alto que es un &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;valor escalar Unicode&lt;/a&gt; v&amp;aacute;lido .</target>
        </trans-unit>
        <trans-unit id="e348847ccb660c7b0b5c01ab1a1ba0e9112a0d13" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3502c112d8c240016de6db9fd46c1abe533f18" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; without structural pinning could &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because the contents are never pinned and the &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; itself is fine with being moved as well. At that point pinning just has no effect on the vector at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd0f4f45a9992b5e83d00a801ad1d124dd353bf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; result needs to contain the whole matched pattern, however &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817aefb1123a860203996fe1bc087199cf9a9301" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fn.null&quot;&gt;null&lt;/a&gt; pointer is &lt;em&gt;never&lt;/em&gt; valid, not even for accesses of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">Un puntero &lt;a href=&quot;fn.null&quot;&gt;nulo &lt;/a&gt;&lt;em&gt;nunca&lt;/em&gt; es v&amp;aacute;lido, ni siquiera para accesos de &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;tama&amp;ntilde;o cero&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64470c49d997c71e612fbbb1108517461ba5028e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;items/associated-items#methods&quot;&gt;method&lt;/a&gt; defined in an &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;inherent implementation&lt;/a&gt;, not in a trait implementation.</source>
          <target state="translated">Un &lt;a href=&quot;items/associated-items#methods&quot;&gt;m&amp;eacute;todo&lt;/a&gt; definido en una &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;implementaci&amp;oacute;n inherente&lt;/a&gt; , no en una implementaci&amp;oacute;n de rasgo.</target>
        </trans-unit>
        <trans-unit id="2929c70726dc937049a9f5950f13c4723ad1c193" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="translated">Una &lt;a href=&quot;loop-expr#infinite-loops&quot;&gt;expresi&amp;oacute;n de &lt;/a&gt; &lt;code&gt;loop&lt;/code&gt; denota un bucle infinito.</target>
        </trans-unit>
        <trans-unit id="e86e93a58bbbbc71c44b9b885a659ff826ce9490" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="translated">Una &lt;a href=&quot;loop-expr#iterator-loops&quot;&gt;expresi&amp;oacute;n &lt;/a&gt; &lt;code&gt;for&lt;/code&gt; extrae valores de un iterador, repitiendo hasta que el iterador est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="78d2df8a50ce969bca66a5211eeeb6570b3f1784" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="translated">Un &lt;a href=&quot;loop-expr#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; de expresi&amp;oacute;n&lt;/a&gt; bucles hasta un predicado es falso.</target>
        </trans-unit>
        <trans-unit id="506fd8c66fe2c3330ab3ababc69a27680d58db08" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="translated">Un &lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; expresi&amp;oacute;n&lt;/a&gt; pruebe un patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="33cacd9cafdfaf3ef4cf01b5b7dfb994c4cd9727" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;patterns#struct-patterns&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, or &lt;a href=&quot;patterns#slice-patterns&quot;&gt;slice&lt;/a&gt; pattern where at least one of the direct subpatterns is a extending pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1f2559cf32a60aeffbe295d8dcc8b7d2d1bc74" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; might contain non-Unicode data. This &lt;code&gt;struct&lt;/code&gt; implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait in a way that mitigates that. It is created by the &lt;a href=&quot;struct.path#method.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; puede contener datos que no son Unicode. Esta &lt;code&gt;struct&lt;/code&gt; implementa el rasgo &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; de una manera que lo mitiga. Se crea mediante el m&amp;eacute;todo de &lt;a href=&quot;struct.path#method.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ad6cb9fb2de3ff94c9692c27c57c7195ec6d6cb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;.</source>
          <target state="translated">Un &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; asegura que el puntero de cualquier puntero tipo &lt;code&gt;P&lt;/code&gt; tenga una ubicaci&amp;oacute;n estable en la memoria, lo que significa que no se puede mover a otro lugar y su memoria no se puede desasignar hasta que se suelte. Decimos que el puntero est&amp;aacute; &quot;anclado&quot;.</target>
        </trans-unit>
        <trans-unit id="a15e8cc8aa6158fcb3389cfdaf6e7e84bacae80c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; is used to send data to a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;. Both senders are clone-able (multi-producer) such that many threads can send simultaneously to one receiver (single-consumer).</source>
          <target state="translated">Se utiliza un &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; o un &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; para enviar datos a un &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; . Ambos remitentes son clonables (m&amp;uacute;ltiples productores), de modo que muchos subprocesos pueden enviarse simult&amp;aacute;neamente a un receptor (un solo consumidor).</target>
        </trans-unit>
        <trans-unit id="e878b6c48911644ea2ee908e204d14d9ba8414f3" translate="yes" xml:space="preserve">
          <source>A &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt; Struct Responsible for Sending Code from the &lt;code&gt;ThreadPool&lt;/code&gt; to a Thread</source>
          <target state="translated">Una estructura de &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt; responsable de enviar c&amp;oacute;digo desde &lt;code&gt;ThreadPool&lt;/code&gt; a un hilo</target>
        </trans-unit>
        <trans-unit id="f340f8a1c0de4fb7863ae5c6dacd93b470ac42d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;!&lt;/code&gt; (all values are invalid for this type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1329292e0705741bc6efb49bebc4980736dafb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared for a feature that is stable in the current edition, but not in all editions.</source>
          <target state="translated">Se declar&amp;oacute; un atributo &lt;code&gt;#![feature]&lt;/code&gt; para una funci&amp;oacute;n que es estable en la edici&amp;oacute;n actual, pero no en todas las ediciones.</target>
        </trans-unit>
        <trans-unit id="aaa8a708af81269c0b5576d02729333db199fa1d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared multiple times.</source>
          <target state="translated">Un atributo &lt;code&gt;#![feature]&lt;/code&gt; se declar&amp;oacute; varias veces.</target>
        </trans-unit>
        <trans-unit id="871ef5c0f72000286445ffa6aeaeb13201eef94a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong item type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a617fa960129a71a59055ffc0553333e4d1938" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[marker]&lt;/code&gt; trait contained an associated item.</source>
          <target state="translated">Un rasgo &lt;code&gt;#[marker]&lt;/code&gt; conten&amp;iacute;a un elemento asociado.</target>
        </trans-unit>
        <trans-unit id="9dfceb8cd31c1c51915cc559ef8cce0d369c7062" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9d6b916ce0da508f854e05a1feec7e0befaef9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(inttype)]&lt;/code&gt; must be provided on an &lt;code&gt;enum&lt;/code&gt; if it has a non-unit variant with a discriminant, or where there are both unit variants with discriminants and non-unit variants. This restriction ensures that there is a well-defined way to extract a variant's discriminant from a value; for instance:</source>
          <target state="translated">Se debe proporcionar un &lt;code&gt;#[repr(inttype)]&lt;/code&gt; en una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n si tiene una variante no unitaria con un discriminante, o cuando hay ambas variantes unitarias con discriminantes y variantes no unitarias. Esta restricci&amp;oacute;n asegura que existe una forma bien definida de extraer el discriminante de una variante de un valor; por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b12f48dd90abc9841d426a5fab9c2ec4ff61214a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[simd]&lt;/code&gt; attribute was applied to an empty tuple struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c012898141fc2cec018c7c222ae43346e5dd5f44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;T&lt;/code&gt; reference can be released to safe code and there it can co-exist with other &lt;code&gt;&amp;amp;T&lt;/code&gt; references, but not with a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</source>
          <target state="translated">La referencia A &lt;code&gt;&amp;amp;T&lt;/code&gt; se puede liberar a un c&amp;oacute;digo seguro y all&amp;iacute; puede coexistir con otras referencias &lt;code&gt;&amp;amp;T&lt;/code&gt; , pero no con un &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec5710ef1f0b84eb29b3c1cc1f924e822fb56fa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference may be released to safe code provided neither other &lt;code&gt;&amp;amp;mut T&lt;/code&gt; nor &lt;code&gt;&amp;amp;T&lt;/code&gt; co-exist with it. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; must always be unique.</source>
          <target state="translated">Una referencia de &lt;code&gt;&amp;amp;mut T&lt;/code&gt; puede ser liberada a un c&amp;oacute;digo seguro siempre que no &lt;code&gt;&amp;amp;mut T&lt;/code&gt; otros &amp;amp; mut T ni &lt;code&gt;&amp;amp;T&lt;/code&gt; con &amp;eacute;l. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; siempre debe ser &amp;uacute;nico.</target>
        </trans-unit>
        <trans-unit id="40585fc29df20c1219babfcdddcfc95974719e32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">A &lt;code&gt;&amp;amp;str&lt;/code&gt; se compone de dos componentes: un puntero a algunos bytes y una longitud. Puede &lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; con los m&amp;eacute;todos as_ptr y &lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="96eae277d841da5acce951109ccad7e43958c9c5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26915dade1d3ce3c223fcfcc944e12fb9d06d42" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;Barrier::wait()&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35fb8d8640dfbea523c47310a34e3d854229d236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">Un &lt;code&gt;BarrierWaitResult&lt;/code&gt; es devuelto por &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; cuando todos los subprocesos de &lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; se&lt;/a&gt; han reunido.</target>
        </trans-unit>
        <trans-unit id="a33fe1ab5786729bf200982553a4a40b28677c12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufRead&lt;/code&gt; is a type of &lt;code&gt;Read&lt;/code&gt;er which has an internal buffer, allowing it to perform extra ways of reading.</source>
          <target state="translated">Un &lt;code&gt;BufRead&lt;/code&gt; es un tipo de &lt;code&gt;Read&lt;/code&gt; er que tiene un buffer interno, que le permite realizar formas adicionales de lectura.</target>
        </trans-unit>
        <trans-unit id="c2a7d564e1881467808b1da26fc7f621d550ac35" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BuildHasher&lt;/code&gt; is typically used (e.g., by &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;) to create &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s for each key such that they are hashed independently of one another, since &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s contain state.</source>
          <target state="translated">Un &lt;code&gt;BuildHasher&lt;/code&gt; se usa t&amp;iacute;picamente (por ejemplo, por &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; ) para crear &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; s para cada clave, de modo que est&amp;eacute;n hash independientemente entre s&amp;iacute;, ya que los &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; contienen el estado.</target>
        </trans-unit>
        <trans-unit id="5ac6d9ca4b25b818aa6f9cb17715ea50c25bf2ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">Un &lt;code&gt;CString&lt;/code&gt; se crea a partir de un segmento de bytes o un vector de bytes, o cualquier cosa que implemente &lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (por ejemplo, puede construir un &lt;code&gt;CString&lt;/code&gt; directamente a partir de un &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; o un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; , ya que ambos implementan ese rasgo).</target>
        </trans-unit>
        <trans-unit id="a976b86b7133ebd168dd44069ca430099fb11fcd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef22157720da42f049eda44831ae9039ff96672" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or ).</source>
          <target state="translated">Un &lt;code&gt;Component&lt;/code&gt; corresponde aproximadamente a una subcadena entre separadores de ruta ( &lt;code&gt;/&lt;/code&gt; o).</target>
        </trans-unit>
        <trans-unit id="00d5a6a3fb8d035432bd26a66264da1cd9fcfcb1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8dc93d165313d1d53fe035b20236e511c258009" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth, and can safely mutate the list during iteration. This is because the lifetime of its yielded references is tied to its own lifetime, instead of just the underlying list. This means cursors cannot yield multiple elements at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1edbc893c845d675ae565c5adc4b48af73fbd0b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592f6bf36d948cda2dbd34364696113591fa1887" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; wraps an in-memory buffer and provides it with a &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Un &lt;code&gt;Cursor&lt;/code&gt; envuelve un b&amp;uacute;fer en memoria y le proporciona una implementaci&amp;oacute;n de &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a89cb140638fa3cd771cb02496374d776ad6d007" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; type to represent a span of time, typically used for system timeouts.</source>
          <target state="translated">Un tipo de &lt;code&gt;Duration&lt;/code&gt; para representar un lapso de tiempo, generalmente utilizado para tiempos de espera del sistema.</target>
        </trans-unit>
        <trans-unit id="e39d340a59cb5b2bb2e11548f7d50ffd50cdcaa5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Formatter&lt;/code&gt; represents various options related to formatting. Users do not construct &lt;code&gt;Formatter&lt;/code&gt;s directly; a mutable reference to one is passed to the &lt;code&gt;fmt&lt;/code&gt; method of all formatting traits, like &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un &lt;code&gt;Formatter&lt;/code&gt; representa varias opciones relacionadas con el formato. Los usuarios no construyen &lt;code&gt;Formatter&lt;/code&gt; directamente; una referencia mutable a uno se pasa al m&amp;eacute;todo &lt;code&gt;fmt&lt;/code&gt; de todos los rasgos de formato, como &lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="921821ce37ee7be55d1f4cd9ec14a09989a7422f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashMap&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">Un &lt;code&gt;HashMap&lt;/code&gt; con una lista fija de elementos se puede inicializar desde una matriz:</target>
        </trans-unit>
        <trans-unit id="9e3e7578434780dbd4d9d999f38a9955ea8f8204" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashSet&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">Un &lt;code&gt;HashSet&lt;/code&gt; con una lista fija de elementos se puede inicializar desde una matriz:</target>
        </trans-unit>
        <trans-unit id="9b7c01af6b5011fee801753cdfcb67030ddd18ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JoinHandle&lt;/code&gt;&lt;em&gt;detaches&lt;/em&gt; the associated thread when it is dropped, which means that there is no longer any handle to thread and no way to &lt;code&gt;join&lt;/code&gt; on it.</source>
          <target state="translated">Un &lt;code&gt;JoinHandle&lt;/code&gt; &lt;em&gt;separa&lt;/em&gt; el hilo asociado cuando se suelta , lo que significa que ya no hay ning&amp;uacute;n identificador para el hilo y no hay forma de &lt;code&gt;join&lt;/code&gt; a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="134a2452be93d4c2cdb1b9f1f0542b4b65ecae3d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LocalKey&lt;/code&gt;'s initializer cannot recursively depend on itself, and using a &lt;code&gt;LocalKey&lt;/code&gt; in this way will cause the initializer to infinitely recurse on the first call to &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;LocalKey&lt;/code&gt; una LocalKey no puede depender recursivamente de s&amp;iacute; mismo, y usar una &lt;code&gt;LocalKey&lt;/code&gt; de esta manera har&amp;aacute; que el inicializador se repita infinitamente en la primera llamada a &lt;code&gt;with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c72c40c2b2da09870992c3f25ebf2fd884c3cef5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Match&lt;/code&gt; result needs to contain the whole matched pattern, however &lt;code&gt;Reject&lt;/code&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">Un resultado de &lt;code&gt;Match&lt;/code&gt; debe contener todo el patr&amp;oacute;n coincidente, sin embargo, los resultados de &lt;code&gt;Reject&lt;/code&gt; pueden dividirse en muchos fragmentos adyacentes arbitrarios. Ambos rangos pueden tener una longitud cero.</target>
        </trans-unit>
        <trans-unit id="14d52da7769e774ed02f1e53e420687489f136bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5668f2d21fa477474ed4b8f6c89c068e50ff97ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;code&gt;&amp;amp;'a str&lt;/code&gt;.</source>
          <target state="translated">Un &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresa que el tipo de implementaci&amp;oacute;n puede usarse como un patr&amp;oacute;n de cadena para buscar en un &lt;code&gt;&amp;amp;'a str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">Un &lt;code&gt;RawWaker&lt;/code&gt; permite al implementador de un ejecutor de tareas crear un &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; que proporciona un comportamiento de activaci&amp;oacute;n personalizado.</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">Un &lt;code&gt;String&lt;/code&gt; puede aumentar de tama&amp;ntilde;o y su contenido puede cambiar, al igual que el contenido de un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , si inserta m&amp;aacute;s datos en &amp;eacute;l. &amp;iexcl;Adem&amp;aacute;s, puede utilizar c&amp;oacute;modamente el operador &lt;code&gt;+&lt;/code&gt; o el &lt;code&gt;format!&lt;/code&gt; macro para concatenar valores de &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">Un &lt;code&gt;String&lt;/code&gt; es un envoltorio sobre un &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; . Veamos algunas de nuestras cadenas de ejemplo UTF-8 codificadas correctamente del Listado 8-14. Primero, este:</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">Una &lt;code&gt;String&lt;/code&gt; se compone de tres componentes: un puntero a algunos bytes, una longitud y una capacidad. El puntero apunta a un b&amp;uacute;fer interno que &lt;code&gt;String&lt;/code&gt; utiliza para almacenar sus datos. La longitud es el n&amp;uacute;mero de bytes almacenados actualmente en el b&amp;uacute;fer y la capacidad es el tama&amp;ntilde;o del b&amp;uacute;fer en bytes. Como tal, la longitud siempre ser&amp;aacute; menor o igual que la capacidad.</target>
        </trans-unit>
        <trans-unit id="2ad19c9717a97c44c08a93976b602e0990d24669" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;SystemTime::duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;SystemTime::elapsed&lt;/code&gt;&lt;/a&gt; methods whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">Se &lt;code&gt;SystemTimeError&lt;/code&gt; un SystemTimeError de los m&amp;eacute;todos &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt; de &lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt; siempre que la segunda hora del sistema representa un punto posterior en el tiempo que el &lt;code&gt;self&lt;/code&gt; de la llamada al m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un &lt;code&gt;ThreadId&lt;/code&gt; es un objeto opaco que tiene un valor &amp;uacute;nico para cada hilo que crea uno. &lt;code&gt;ThreadId&lt;/code&gt; se garantiza que los ThreadId se correspondan con el identificador designado por el sistema de un hilo. Un &lt;code&gt;ThreadId&lt;/code&gt; se puede recuperar del m&amp;eacute;todo &lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; en un &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">Un &lt;code&gt;TypeId&lt;/code&gt; actualmente solo est&amp;aacute; disponible para los tipos que se adscriben a &lt;code&gt;'static&lt;/code&gt; , pero esta limitaci&amp;oacute;n puede eliminarse en el futuro.</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">Un &lt;code&gt;TypeId&lt;/code&gt; representa un identificador &amp;uacute;nico global para un tipo.</target>
        </trans-unit>
        <trans-unit id="05e63a516d556e9577522a23860139fad9899875" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a &lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;../primitive.reference&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">Un &lt;code&gt;Vec&lt;/code&gt; puede ser mutable. Las rebanadas, por otro lado, son objetos de solo lectura. Para obtener una rebanada, use &lt;code&gt;&amp;amp;&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">Un &lt;code&gt;Waker&lt;/code&gt; es un identificador para despertar una tarea notificando a su ejecutor que est&amp;aacute; lista para ejecutarse.</target>
        </trans-unit>
        <trans-unit id="d9bc289fc584bbfaef86d0de4ba94863300845d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a226c54ce6028079ee3f0e935344b03753cf6ea2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">Un puntero &lt;code&gt;Weak&lt;/code&gt; es &amp;uacute;til para mantener una referencia temporal al valor dentro de &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; sin extender su vida &amp;uacute;til. Tambi&amp;eacute;n se usa para evitar referencias circulares entre punteros de &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; , ya que las referencias de propiedad mutua nunca permitir&amp;iacute;an que se &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; ninguno de los Arc . Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; de los nodos principales a los hijos y &lt;code&gt;Weak&lt;/code&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">Un puntero &lt;code&gt;Weak&lt;/code&gt; es &amp;uacute;til para mantener una referencia temporal al valor dentro de &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; sin extender su vida &amp;uacute;til. Tambi&amp;eacute;n se utiliza para evitar referencias circulares entre punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; , ya que las referencias de propiedad mutua nunca permitir&amp;iacute;an que se &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; ninguno de los Rc . Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; de los nodos principales a los hijos y &lt;code&gt;Weak&lt;/code&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="2ab6f5c59e2d0418f87950a3ebfb26ab14b557db" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">Un &lt;code&gt;break&lt;/code&gt; expresi&amp;oacute;n se asocia normalmente con el interior &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; o &lt;code&gt;while&lt;/code&gt; bucle que encierra el &lt;code&gt;break&lt;/code&gt; expresi&amp;oacute;n, pero una &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;etiqueta&lt;/a&gt; se puede utilizar para especificar que encierra bucle se ve afectada. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="dc2182d07a207a24da6c811d0b8e308ce9f0619b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; solo est&amp;aacute; permitida en el cuerpo de un bucle y tiene una de las formas &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;break 'label&lt;/code&gt; o ( &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;ver m&amp;aacute;s abajo&lt;/a&gt; ) &lt;code&gt;break EXPR&lt;/code&gt; o &lt;code&gt;break 'label EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">Una &lt;code&gt;break&lt;/code&gt; declaraci&amp;oacute;n con un argumento no apareci&amp;oacute; en un &lt;code&gt;loop&lt;/code&gt; bucle.</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; sin una etiqueta apareci&amp;oacute; dentro de un bloque etiquetado.</target>
        </trans-unit>
        <trans-unit id="3cd69f4f6c3139636621e0e9a9e16305bdb70d6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ee25848e86a1b5a5cc249fddb42f44e3d6d658" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">Una &lt;code&gt;const&lt;/code&gt; ante representa un valor constante que nunca deber&amp;iacute;a cambiar. Si uno toma una referencia &lt;code&gt;&amp;amp;&lt;/code&gt; a la constante, entonces est&amp;aacute; tomando un puntero a alguna ubicaci&amp;oacute;n de memoria que contiene el valor. Normalmente esto est&amp;aacute; perfectamente bien: la mayor&amp;iacute;a de los valores no se pueden cambiar a trav&amp;eacute;s de un puntero &lt;code&gt;&amp;amp;&lt;/code&gt; compartido , pero la mutabilidad interior lo permitir&amp;iacute;a. Es decir, se podr&amp;iacute;a mutar un valor constante. Por otro lado, una &lt;code&gt;static&lt;/code&gt; es expl&amp;iacute;citamente una &amp;uacute;nica ubicaci&amp;oacute;n de memoria, que puede mutarse a voluntad.</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">Una expresi&amp;oacute;n &lt;code&gt;for&lt;/code&gt; es una construcci&amp;oacute;n sint&amp;aacute;ctica para recorrer elementos proporcionados por una implementaci&amp;oacute;n de &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; . Si el iterador produce un valor, a ese valor se le da el nombre especificado y se ejecuta el cuerpo del ciclo, entonces el control vuelve al principio del ciclo &lt;code&gt;for&lt;/code&gt; . Si el iterador est&amp;aacute; vac&amp;iacute;o, la expresi&amp;oacute;n &lt;code&gt;for&lt;/code&gt; se completa.</target>
        </trans-unit>
        <trans-unit id="7cc2ad054c8700f44ee39d9eb760a19117e088af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">Un bucle &lt;code&gt;for&lt;/code&gt; se expande como se muestra:</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de &lt;code&gt;loop&lt;/code&gt; repite la ejecuci&amp;oacute;n de su cuerpo continuamente: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d617ef5af3dab30c4c49b4baffa8bfa3c5f2ec66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&amp;iexcl;Una expresi&amp;oacute;n de &lt;code&gt;loop&lt;/code&gt; sin una expresi&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; asociada es divergente y tiene tipo &lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; . Un &lt;code&gt;loop&lt;/code&gt; de expresi&amp;oacute;n que contiene asociada &lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; expresi&amp;oacute;n (s)&lt;/a&gt; puede terminar, y debe tener un tipo compatible con el valor de la &lt;code&gt;break&lt;/code&gt; de expresi&amp;oacute;n (s).</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">Una &lt;code&gt;match&lt;/code&gt; comporta de manera diferente dependiendo de si la expresi&amp;oacute;n del escrutinio es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar o&lt;/a&gt; una expresi&amp;oacute;n de valor . Si la expresi&amp;oacute;n del escrutinio es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de valor&lt;/a&gt; , primero se eval&amp;uacute;a en una ubicaci&amp;oacute;n temporal y el valor resultante se compara secuencialmente con los patrones en los brazos hasta que se encuentra una coincidencia. El primer brazo con un patr&amp;oacute;n coincidente se elige como el objetivo de la rama del &lt;code&gt;match&lt;/code&gt; , las variables limitadas por el patr&amp;oacute;n se asignan a las variables locales en el bloque del brazo y el control ingresa al bloque.</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">Una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; est&amp;aacute; formada por &lt;em&gt;brazos&lt;/em&gt; . Un brazo consta de un &lt;em&gt;patr&amp;oacute;n&lt;/em&gt; y el c&amp;oacute;digo que debe ejecutarse si el valor dado al comienzo de la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; ajusta al patr&amp;oacute;n de ese brazo. Rust toma el valor dado para &lt;code&gt;match&lt;/code&gt; y mira a trav&amp;eacute;s del patr&amp;oacute;n de cada brazo por turno. La construcci&amp;oacute;n y los patrones de &lt;code&gt;match&lt;/code&gt; son caracter&amp;iacute;sticas poderosas en Rust que le permiten expresar una variedad de situaciones que su c&amp;oacute;digo puede encontrar y asegurarse de manejarlas todas. Estas caracter&amp;iacute;sticas se cubrir&amp;aacute;n en detalle en el Cap&amp;iacute;tulo 6 y el Cap&amp;iacute;tulo 18, respectivamente.</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">A &lt;code&gt;repr(transparent)&lt;/code&gt; tipo tambi&amp;eacute;n fue anotado con otros, consejos de representaci&amp;oacute;n incompatibles.</target>
        </trans-unit>
        <trans-unit id="c5a4ca7ea6b5bc0339d74f8626989e641c9a4f2a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; marks the end of an execution path in a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04d984159639545c2a9b782d494bbc89f68eb09" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; which was defined in the current crate. This is not affected by applied type arguments. &lt;code&gt;struct Foo&lt;/code&gt; is considered local, but &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; is not. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; is local. Type aliases do not affect locality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bcaf88ff1b66b63413f83d3b7d32c0a7ea7cbfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Un &lt;em&gt;tipo de &lt;/em&gt; &lt;code&gt;struct&lt;/code&gt; es un producto heterog&amp;eacute;neo de otros tipos, llamados &lt;em&gt;campos&lt;/em&gt; del tipo. &lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5dc372cb983e81c62a84e7d307e5c691468779fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; is like an interface that data types can implement. When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad87d3d4edf2b4861565127275e5ad1afc1a755" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; is always local, regardless of the types substituted for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ab68cda9330ceba3e059532d454bd1454a3c76" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; cannot have fields with destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7456e28e3269b8fcb15b4e8220467fa67683b4bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d933644dc98827f86adb027ad1edada503180c92" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; looks like a &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; in terms of declaration, but all of its fields exist in the same memory, superimposed over one another. For instance, if we wanted some bits in memory that we sometimes interpret as a &lt;code&gt;u32&lt;/code&gt; and sometimes as an &lt;code&gt;f32&lt;/code&gt;, we could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae4dfd16f669123c1df46acb99529aa8db4f78e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; was declared with fields with destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">Un bucle &lt;code&gt;while let&lt;/code&gt; es equivalente a una expresi&amp;oacute;n de &lt;code&gt;loop&lt;/code&gt; que contiene una &lt;a href=&quot;match-expr&quot;&gt;expresi&amp;oacute;n de &lt;/a&gt; &lt;code&gt;match&lt;/code&gt; siguiente manera.</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">A &lt;code&gt;while let&lt;/code&gt; bucle es sem&amp;aacute;nticamente similar a un &lt;code&gt;while&lt;/code&gt; bucle pero en lugar de una expresi&amp;oacute;n condici&amp;oacute;n que espera que la palabra clave &lt;code&gt;let&lt;/code&gt; seguido por un patr&amp;oacute;n, un &lt;code&gt;=&lt;/code&gt; , un &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expresi&amp;oacute;n y una expresi&amp;oacute;n de bloque. Si el valor del escrutinio coincide con el patr&amp;oacute;n, el bloque del cuerpo del bucle se ejecuta y el control vuelve a la declaraci&amp;oacute;n de coincidencia del patr&amp;oacute;n. De lo contrario, la expresi&amp;oacute;n while se completa.</target>
        </trans-unit>
        <trans-unit id="718179093a0d6e082dbdc6f07f43775afb09f0f9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; expression is used for predicate loops. The &lt;code&gt;while&lt;/code&gt; expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, or exits the loop otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">A &lt;code&gt;while&lt;/code&gt; bucle comienza evaluando el bucle expresi&amp;oacute;n condicional booleano. Si la expresi&amp;oacute;n condicional del bucle se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; , el bloque del cuerpo del bucle se ejecuta y el control vuelve a la expresi&amp;oacute;n condicional del bucle. Si la expresi&amp;oacute;n condicional de bucle se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;while&lt;/code&gt; se completa.</target>
        </trans-unit>
        <trans-unit id="9024dfdf6115f20a47566e1a178072686b644d4c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;yield&lt;/code&gt; clause was used in an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">Un &lt;em&gt;escape de punto de c&amp;oacute;digo de 24 bits&lt;/em&gt; comienza con &lt;code&gt;U+0075&lt;/code&gt; ( &lt;code&gt;u&lt;/code&gt; ) y va seguido de hasta seis &lt;em&gt;d&amp;iacute;gitos hexadecimales&lt;/em&gt; rodeados por llaves &lt;code&gt;U+007B&lt;/code&gt; ( &lt;code&gt;{&lt;/code&gt; ) y &lt;code&gt;U+007D&lt;/code&gt; ( &lt;code&gt;}&lt;/code&gt; ). Denota el punto de c&amp;oacute;digo Unicode igual al valor hexadecimal proporcionado.</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">Un &lt;em&gt;escape de punto de c&amp;oacute;digo de 7 bits&lt;/em&gt; comienza con &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ) y es seguido exactamente por dos &lt;em&gt;d&amp;iacute;gitos hexadecimales&lt;/em&gt; con un valor de hasta &lt;code&gt;0x7F&lt;/code&gt; . Denota el car&amp;aacute;cter ASCII con un valor igual al valor hexadecimal proporcionado. No se permiten valores m&amp;aacute;s altos porque es ambiguo si se refieren a puntos de c&amp;oacute;digo Unicode o valores de bytes.</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n &lt;/em&gt;&lt;em&gt; &lt;code&gt;let&lt;/code&gt; &lt;/em&gt; introduce un nuevo conjunto de &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt; , dado por un &lt;a href=&quot;patterns&quot;&gt;patr&amp;oacute;n&lt;/a&gt; . El patr&amp;oacute;n es seguido opcionalmente por una anotaci&amp;oacute;n de tipo y luego opcionalmente por una expresi&amp;oacute;n inicializadora. Cuando no se proporciona una anotaci&amp;oacute;n de tipo, el compilador inferir&amp;aacute; el tipo o se&amp;ntilde;alar&amp;aacute; un error si no hay suficiente informaci&amp;oacute;n de tipo disponible para una inferencia definitiva. Cualquier variable introducida por una declaraci&amp;oacute;n de variable es visible desde el punto de declaraci&amp;oacute;n hasta el final del alcance del bloque adjunto.</target>
        </trans-unit>
        <trans-unit id="8ca18f2a30c6ddfd6e41efbe967d1604f354b083" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by an irrefutable &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de &lt;/em&gt;&lt;em&gt; &lt;code&gt;match&lt;/code&gt; &lt;/em&gt; ramifica en un patr&amp;oacute;n. La forma exacta de coincidencia que se produce depende del &lt;a href=&quot;../patterns&quot;&gt;patr&amp;oacute;n&lt;/a&gt; . Una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; tiene una &lt;em&gt;expresi&amp;oacute;n de &lt;/em&gt;&lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;escrutinio&lt;/a&gt;&lt;/em&gt; , que es el valor para comparar con los patrones. La expresi&amp;oacute;n del escrutinio y los patrones deben ser del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">Un &lt;em&gt;literal binario&lt;/em&gt; comienza con la secuencia de caracteres &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;0b&lt;/code&gt; ) y contin&amp;uacute;a como cualquier combinaci&amp;oacute;n (con al menos un d&amp;iacute;gito) de d&amp;iacute;gitos binarios y guiones bajos.</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de bloque&lt;/em&gt; , o &lt;em&gt;bloque&lt;/em&gt; , es una expresi&amp;oacute;n de flujo de control y un &amp;aacute;mbito de espacio de nombres an&amp;oacute;nimo para elementos y declaraciones de variables. Como expresi&amp;oacute;n de flujo de control, un bloque ejecuta secuencialmente sus declaraciones de declaraci&amp;oacute;n de componentes que no son elementos y luego su expresi&amp;oacute;n opcional final. Como un &amp;aacute;mbito de espacio de nombres an&amp;oacute;nimo, las declaraciones de elementos solo est&amp;aacute;n dentro del &amp;aacute;mbito del bloque y las variables declaradas por las sentencias &lt;code&gt;let&lt;/code&gt; est&amp;aacute;n dentro del &amp;aacute;mbito desde la siguiente sentencia hasta el final del bloque.</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">Un &lt;em&gt;escape de byte de escape&lt;/em&gt; comienza con &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ) y es seguido exactamente por dos &lt;em&gt;d&amp;iacute;gitos hexadecimales&lt;/em&gt; . Denota el byte igual al valor hexadecimal proporcionado.</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal de byte&lt;/em&gt; es un solo car&amp;aacute;cter ASCII (en el rango &lt;code&gt;U+0000&lt;/code&gt; a &lt;code&gt;U+007F&lt;/code&gt; ) o un solo &lt;em&gt;escape&lt;/em&gt; precedido por los caracteres &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) y &lt;code&gt;U+0027&lt;/code&gt; (comillas simples), y seguido por el car&amp;aacute;cter &lt;code&gt;U+0027&lt;/code&gt; . Si el car&amp;aacute;cter &lt;code&gt;U+0027&lt;/code&gt; est&amp;aacute; presente dentro del literal, debe &lt;em&gt;escaparse&lt;/em&gt; con un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) anterior. Es equivalente a un &lt;em&gt;literal de n&amp;uacute;mero&lt;/em&gt; entero de 8 bits sin signo &lt;code&gt;u8&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de llamada&lt;/em&gt; consta de una expresi&amp;oacute;n seguida de una lista de expresiones entre par&amp;eacute;ntesis. Invoca una funci&amp;oacute;n, proporcionando cero o m&amp;aacute;s variables de entrada. Si la funci&amp;oacute;n finalmente regresa, la expresi&amp;oacute;n se completa. Para &lt;a href=&quot;../types/function-item&quot;&gt;tipos que no son funciones&lt;/a&gt; , la expresi&amp;oacute;n f (...) usa el m&amp;eacute;todo en uno de los rasgos &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt; , que difieren en si toman el tipo por referencia, referencia mutable o se apropian respectivamente. Se tomar&amp;aacute; un pr&amp;eacute;stamo autom&amp;aacute;tico si es necesario. Rust tambi&amp;eacute;n eliminar&amp;aacute; autom&amp;aacute;ticamente la referencia &lt;code&gt;f&lt;/code&gt; seg&amp;uacute;n sea necesario. Algunos ejemplos de expresiones de llamada:</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">Un &lt;em&gt;literal de car&amp;aacute;cter&lt;/em&gt; es un car&amp;aacute;cter Unicode &amp;uacute;nico encerrado entre dos caracteres &lt;code&gt;U+0027&lt;/code&gt; (comillas simples), con la excepci&amp;oacute;n del propio &lt;code&gt;U+0027&lt;/code&gt; , que debe &lt;em&gt;escaparse&lt;/em&gt; con un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; precedente ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de cierre&lt;/em&gt; define un cierre y lo denota como un valor, en una sola expresi&amp;oacute;n. Una expresi&amp;oacute;n de cierre es una lista delimitada por s&amp;iacute;mbolos de barra vertical ( &lt;code&gt;|&lt;/code&gt; ) de &lt;a href=&quot;../patterns&quot;&gt;patrones&lt;/a&gt; irrefutables seguida de una expresi&amp;oacute;n. Opcionalmente, se pueden agregar anotaciones de tipo para el tipo de par&amp;aacute;metros o para el tipo de retorno. Si hay un tipo de retorno, la expresi&amp;oacute;n utilizada para el cuerpo del cierre debe ser un &lt;a href=&quot;block-expr&quot;&gt;bloque&lt;/a&gt; normal . Una expresi&amp;oacute;n de cierre tambi&amp;eacute;n puede comenzar con la palabra clave &lt;code&gt;move&lt;/code&gt; antes de la inicial &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="339cfc7fe9f16f898782c7f7150b6fb18b64f9c3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt;, also know as a lambda expression or a lambda, defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">Una &lt;em&gt;lista de contras&lt;/em&gt; es una estructura de datos que proviene del lenguaje de programaci&amp;oacute;n Lisp y sus dialectos. En Lisp, la funci&amp;oacute;n &lt;code&gt;cons&lt;/code&gt; (abreviatura de &quot;funci&amp;oacute;n de construcci&amp;oacute;n&quot;) construye un nuevo par a partir de sus dos argumentos, que normalmente son un valor &amp;uacute;nico y otro par. Estos pares que contienen pares forman una lista.</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">Un &lt;em&gt;contexto constante&lt;/em&gt; es uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="493b2f63697e56331a49f53a0195846cde72e171" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const fn&lt;/em&gt; is a function that one is permitted to call from a const context. Declaring a function &lt;code&gt;const&lt;/code&gt; has no effect on any existing uses, it only restricts the types that arguments and the return type may use, as well as prevent various expressions from being used within it. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">Un &lt;em&gt;elemento constante&lt;/em&gt; es un &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;valor constante&lt;/a&gt;&lt;/em&gt; opcionalmente nombrado que no est&amp;aacute; asociado con una ubicaci&amp;oacute;n de memoria espec&amp;iacute;fica en el programa. Las constantes est&amp;aacute;n esencialmente en l&amp;iacute;nea dondequiera que se usen, lo que significa que se copian directamente en el contexto relevante cuando se usan. No se garantiza necesariamente que las referencias a la misma constante se refieran a la misma direcci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="2e06b409839c096ae71106f8baaaf9f78507004d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">Una &lt;em&gt;caja&lt;/em&gt; es una unidad de compilaci&amp;oacute;n y vinculaci&amp;oacute;n, as&amp;iacute; como de control de versiones, distribuci&amp;oacute;n y carga en tiempo de ejecuci&amp;oacute;n. Una caja contiene un &lt;em&gt;&amp;aacute;rbol&lt;/em&gt; de &amp;aacute;mbitos de &lt;a href=&quot;items/modules&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; anidados . El nivel superior de este &amp;aacute;rbol es un m&amp;oacute;dulo que es an&amp;oacute;nimo (desde el punto de vista de las rutas dentro del m&amp;oacute;dulo) y cualquier elemento dentro de una caja tiene una &lt;a href=&quot;paths&quot;&gt;ruta de m&amp;oacute;dulo&lt;/a&gt; can&amp;oacute;nica indica su ubicaci&amp;oacute;n dentro del &amp;aacute;rbol de m&amp;oacute;dulos de la caja.</target>
        </trans-unit>
        <trans-unit id="7dbd934a0d90b722d503e93f98eb0c64d5f9ddfa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal decimal&lt;/em&gt; seguido de un car&amp;aacute;cter de punto &lt;code&gt;U+002E&lt;/code&gt; ( &lt;code&gt;.&lt;/code&gt; ). Esto es seguido opcionalmente por otro literal decimal, con un &lt;em&gt;exponente&lt;/em&gt; opcional .</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal decimal&lt;/em&gt; comienza con un &lt;em&gt;d&amp;iacute;gito decimal&lt;/em&gt; y contin&amp;uacute;a con cualquier combinaci&amp;oacute;n de &lt;em&gt;d&amp;iacute;gitos decimales&lt;/em&gt; y &lt;em&gt;guiones bajos.&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n de declaraci&amp;oacute;n&lt;/em&gt; es aquella que introduce uno o m&amp;aacute;s &lt;em&gt;nombres&lt;/em&gt; en el bloque de declaraci&amp;oacute;n adjunto. Los nombres declarados pueden denotar nuevas variables o nuevos &lt;a href=&quot;items&quot;&gt;elementos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de campo&lt;/em&gt; consta de una expresi&amp;oacute;n seguida de un solo punto y un &lt;a href=&quot;../identifiers&quot;&gt;identificador&lt;/a&gt; , cuando no est&amp;aacute; seguida inmediatamente por una lista de expresiones entre par&amp;eacute;ntesis (esta &amp;uacute;ltima es siempre una &lt;a href=&quot;method-call-expr&quot;&gt;expresi&amp;oacute;n de llamada de m&amp;eacute;todo&lt;/a&gt; ). Una expresi&amp;oacute;n de campo denota un campo de una &lt;a href=&quot;../items/structs&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;../items/unions&quot;&gt;uni&amp;oacute;n&lt;/a&gt; . Para llamar a una funci&amp;oacute;n almacenada en una estructura, se necesitan par&amp;eacute;ntesis alrededor de la expresi&amp;oacute;n del campo.</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">Un &lt;em&gt;literal de punto flotante&lt;/em&gt; tiene una de dos formas:</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">Una &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; consta de un &lt;a href=&quot;../expressions/block-expr&quot;&gt;bloque&lt;/a&gt; , junto con un nombre y un conjunto de par&amp;aacute;metros. Aparte del nombre, todos estos son opcionales. Las funciones se declaran con la palabra clave &lt;code&gt;fn&lt;/code&gt; . Las funciones pueden declarar un conjunto de &lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; de &lt;em&gt;entrada&lt;/em&gt; como par&amp;aacute;metros, a trav&amp;eacute;s de los cuales el llamador pasa argumentos a la funci&amp;oacute;n, y el &lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;tipo&lt;/em&gt;&lt;/a&gt; de &lt;em&gt;salida&lt;/em&gt; del valor que la funci&amp;oacute;n devolver&amp;aacute; a su llamador al finalizar.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">Una &lt;em&gt;funci&amp;oacute;n gen&amp;eacute;rica&lt;/em&gt; permite que aparezcan uno o m&amp;aacute;s &lt;em&gt;tipos parametrizados&lt;/em&gt; en su firma. Cada par&amp;aacute;metro de tipo debe declararse expl&amp;iacute;citamente en una lista delimitada por corchetes angulares y separada por comas, despu&amp;eacute;s del nombre de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;mapa hash le&lt;/em&gt; permite asociar un valor con una clave en particular. Es una implementaci&amp;oacute;n particular de la estructura de datos m&amp;aacute;s general llamada &lt;em&gt;mapa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">Un &lt;em&gt;literal hexadecimal&lt;/em&gt; comienza con la secuencia de caracteres &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;0x&lt;/code&gt; ) y contin&amp;uacute;a como cualquier combinaci&amp;oacute;n (con al menos un d&amp;iacute;gito) de d&amp;iacute;gitos hexadecimales y guiones bajos.</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n literal&lt;/em&gt; consta de una de las formas &lt;a href=&quot;../tokens#literals&quot;&gt;literales&lt;/a&gt; descritas anteriormente. Describe directamente un n&amp;uacute;mero, car&amp;aacute;cter, cadena o valor booleano.</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">Una &lt;em&gt;variable local&lt;/em&gt; (o asignaci&amp;oacute;n &lt;em&gt;local de pila&lt;/em&gt; ) tiene un valor directamente, asignado dentro de la memoria de la pila. El valor es parte del marco de la pila.</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">Un &lt;em&gt;protector de f&amp;oacute;sforo&lt;/em&gt; es una condici&amp;oacute;n adicional &lt;code&gt;if&lt;/code&gt; se especifica despu&amp;eacute;s del patr&amp;oacute;n en un brazo de &lt;code&gt;match&lt;/code&gt; que tambi&amp;eacute;n debe coincidir, junto con el patr&amp;oacute;n de coincidencia, para que ese brazo sea elegido. Los protectores de f&amp;oacute;sforos son &amp;uacute;tiles para expresar ideas m&amp;aacute;s complejas de las que permite un patr&amp;oacute;n por s&amp;iacute; solo.</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">Una &lt;em&gt;llamada a&lt;/em&gt; un &lt;em&gt;m&amp;eacute;todo&lt;/em&gt; consta de una expresi&amp;oacute;n (el &lt;em&gt;receptor&lt;/em&gt; ) seguida de un solo punto, un segmento de ruta de expresi&amp;oacute;n y una lista de expresiones entre par&amp;eacute;ntesis. Las llamadas a &lt;a href=&quot;../items/associated-items#methods&quot;&gt;m&amp;eacute;todos&lt;/a&gt; se resuelven a m&amp;eacute;todos asociados en rasgos espec&amp;iacute;ficos, ya sea despach&amp;aacute;ndose est&amp;aacute;ticamente a un m&amp;eacute;todo si se conoce &lt;code&gt;self&lt;/code&gt; tipo exacto del lado izquierdo, o despachando din&amp;aacute;micamente si la expresi&amp;oacute;n del lado izquierdo es un &lt;a href=&quot;../types/trait-object&quot;&gt;objeto de rasgo&lt;/a&gt; indirecto .</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">Un &lt;em&gt;elemento de m&amp;oacute;dulo&lt;/em&gt; es un m&amp;oacute;dulo, entre llaves, nombrado y prefijado con la palabra clave &lt;code&gt;mod&lt;/code&gt; . Un elemento de m&amp;oacute;dulo introduce un m&amp;oacute;dulo nuevo con nombre en el &amp;aacute;rbol de m&amp;oacute;dulos que forman una caja. Los m&amp;oacute;dulos pueden anidarse arbitrariamente.</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">Un &lt;em&gt;literal num&amp;eacute;rico&lt;/em&gt; es un &lt;em&gt;literal entero&lt;/em&gt; o un &lt;em&gt;literal de punto flotante&lt;/em&gt; . La gram&amp;aacute;tica para reconocer los dos tipos de literales es mixta.</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">Una &lt;em&gt;ruta&lt;/em&gt; es una secuencia de uno o m&amp;aacute;s segmentos de ruta separados &lt;em&gt;l&amp;oacute;gicamente&lt;/em&gt; por un calificador de espacio de nombres ( &lt;code&gt;::&lt;/code&gt; ) . Si una ruta consta de un solo segmento, se refiere a un &lt;a href=&quot;items&quot;&gt;elemento&lt;/a&gt; o una &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; en un &amp;aacute;mbito de control local. Si una ruta tiene varios segmentos, siempre se refiere a un elemento.</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de lugar&lt;/em&gt; es una expresi&amp;oacute;n que representa una ubicaci&amp;oacute;n de memoria. Estas expresiones son &lt;a href=&quot;expressions/path-expr&quot;&gt;rutas&lt;/a&gt; que se refieren a variables locales, variables &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;ticas&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;desreferencias&lt;/a&gt; ( &lt;code&gt;*expr&lt;/code&gt; ), expresiones de &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexaci&amp;oacute;n de matrices&lt;/a&gt; ( &lt;code&gt;expr[expr]&lt;/code&gt; ), referencias de &lt;a href=&quot;expressions/field-expr&quot;&gt;campo&lt;/a&gt; ( &lt;code&gt;expr.f&lt;/code&gt; ) y expresiones de lugar entre par&amp;eacute;ntesis. Todas las dem&amp;aacute;s expresiones son expresiones de valor.</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">Un &lt;em&gt;puntero&lt;/em&gt; es un concepto general de una variable que contiene una direcci&amp;oacute;n en la memoria. Esta direcci&amp;oacute;n se refiere a, o &amp;ldquo;apunta a&amp;rdquo;, algunos otros datos. El tipo m&amp;aacute;s com&amp;uacute;n de puntero en Rust es una referencia, que aprendi&amp;oacute; en el Cap&amp;iacute;tulo 4. Las referencias se indican con el s&amp;iacute;mbolo &lt;code&gt;&amp;amp;&lt;/code&gt; y toman prestado el valor al que apuntan. No tienen ninguna capacidad especial m&amp;aacute;s que referirse a los datos. Adem&amp;aacute;s, no tienen sobrecarga y son el tipo de puntero que usamos con m&amp;aacute;s frecuencia.</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">Una &lt;em&gt;ruta relativa&lt;/em&gt; comienza desde el m&amp;oacute;dulo actual y usa &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;super&lt;/code&gt; o un identificador en el m&amp;oacute;dulo actual.</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">Un tipo &lt;em&gt;escalar&lt;/em&gt; representa un valor &amp;uacute;nico. Rust tiene cuatro tipos escalares principales: enteros, n&amp;uacute;meros de punto flotante, booleanos y caracteres. Puede reconocerlos de otros lenguajes de programaci&amp;oacute;n. Veamos c&amp;oacute;mo funcionan en Rust.</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n&lt;/em&gt; es un componente de un &lt;a href=&quot;expressions/block-expr&quot;&gt;bloque&lt;/a&gt; , que a su vez es un componente de una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; o &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n&lt;/a&gt; externa .</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">Un &lt;em&gt;elemento est&amp;aacute;tico&lt;/em&gt; es similar a una &lt;a href=&quot;constant-items&quot;&gt;constante&lt;/a&gt; , excepto que representa una ubicaci&amp;oacute;n de memoria precisa en el programa. Todas las referencias a la est&amp;aacute;tica se refieren a la misma ubicaci&amp;oacute;n de memoria. Los art&amp;iacute;culos est&amp;aacute;ticos tienen una vida &amp;uacute;til &lt;code&gt;static&lt;/code&gt; , que sobrevive a todas las dem&amp;aacute;s vidas en un programa Rust. Los elementos est&amp;aacute;ticos no &lt;code&gt;mut&lt;/code&gt; que contienen un tipo que no es &lt;a href=&quot;../interior-mutability&quot;&gt;mutable interior&lt;/a&gt; se pueden colocar en la memoria de s&amp;oacute;lo lectura. Los elementos est&amp;aacute;ticos no llaman a la &lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; al final del programa.</target>
        </trans-unit>
        <trans-unit id="9ed445848ff0ebfb7d1082c79316c3f0dc94cf17" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">Un &lt;em&gt;literal de cadena&lt;/em&gt; es una secuencia de cualquier car&amp;aacute;cter Unicode encerrado entre dos caracteres &lt;code&gt;U+0022&lt;/code&gt; (comillas dobles), con la excepci&amp;oacute;n del propio &lt;code&gt;U+0022&lt;/code&gt; , que debe &lt;em&gt;escaparse&lt;/em&gt; con un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; precedente ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">Un &lt;em&gt;segmento de cadena&lt;/em&gt; es una referencia a parte de una &lt;code&gt;String&lt;/code&gt; y tiene este aspecto:</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">Una &lt;em&gt;cadena&lt;/em&gt; es una colecci&amp;oacute;n de caracteres. Hemos mencionado el tipo &lt;code&gt;String&lt;/code&gt; anteriormente, pero en este cap&amp;iacute;tulo hablaremos sobre &amp;eacute;l en profundidad.</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de estructura&lt;/em&gt; crea una estructura o un valor de uni&amp;oacute;n. Consiste en una ruta a una &lt;a href=&quot;../items/structs&quot;&gt;estructura&lt;/a&gt; o elemento de &lt;a href=&quot;../items/unions&quot;&gt;uni&amp;oacute;n&lt;/a&gt; seguida de los valores de los campos del elemento. Hay tres formas de expresiones de estructura: estructura, tupla y unidad.</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Una &lt;em&gt;estructura&lt;/em&gt; es un tipo de &lt;a href=&quot;../types/struct&quot;&gt;estructura&lt;/a&gt; nominal definido con la palabra clave &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">Una &lt;em&gt;estructura&lt;/em&gt; , o &lt;em&gt;estructura&lt;/em&gt; , es un tipo de datos personalizado que le permite nombrar y empaquetar varios valores relacionados que forman un grupo significativo. Si est&amp;aacute; familiarizado con un lenguaje orientado a objetos, una &lt;em&gt;estructura&lt;/em&gt; es como los atributos de datos de un objeto. En este cap&amp;iacute;tulo, compararemos y contrastaremos tuplas con estructuras, demostraremos c&amp;oacute;mo usar estructuras y discutiremos c&amp;oacute;mo definir m&amp;eacute;todos y funciones asociadas para especificar el comportamiento asociado con los datos de una estructura. Las estructuras y enumeraciones (discutidas en el Cap&amp;iacute;tulo 6) son los bloques de construcci&amp;oacute;n para crear nuevos tipos en el dominio de su programa para aprovechar al m&amp;aacute;ximo la verificaci&amp;oacute;n de tipos en tiempo de compilaci&amp;oacute;n de Rust.</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">Un &lt;em&gt;doble de prueba&lt;/em&gt; es el concepto de programaci&amp;oacute;n general para un tipo utilizado en lugar de otro tipo durante la prueba. &lt;em&gt;Los objetos simulados&lt;/em&gt; son tipos espec&amp;iacute;ficos de dobles de prueba que registran lo que sucede durante una prueba para que pueda afirmar que se llevaron a cabo las acciones correctas.</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">Un &lt;em&gt;grupo de subprocesos&lt;/em&gt; es un grupo de subprocesos generados que est&amp;aacute;n esperando y listos para manejar una tarea. Cuando el programa recibe una nueva tarea, asigna uno de los subprocesos en el grupo a la tarea, y ese subproceso procesar&amp;aacute; la tarea. Los subprocesos restantes del grupo est&amp;aacute;n disponibles para manejar cualquier otra tarea que se presente mientras se procesa el primer subproceso. Cuando el primer subproceso termina de procesar su tarea, se devuelve al grupo de subprocesos inactivos, listo para manejar una nueva tarea. Un grupo de subprocesos le permite procesar conexiones al mismo tiempo, aumentando el rendimiento de su servidor.</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">Una &lt;em&gt;implementaci&amp;oacute;n de rasgo&lt;/em&gt; se define como una implementaci&amp;oacute;n inherente excepto que las declaraciones de tipo gen&amp;eacute;rico opcionales van seguidas de un &lt;a href=&quot;traits&quot;&gt;rasgo&lt;/a&gt; seguido de la palabra clave &lt;code&gt;for&lt;/code&gt; . Seguido de un camino hacia un tipo nominal.</target>
        </trans-unit>
        <trans-unit id="61547573b3bf424e11f1f4f9cd8d9184f5546ee1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. A trait object implements all specified traits as well as their supertraits (if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">Un &lt;em&gt;objeto de rasgo&lt;/em&gt; es un valor opaco de otro tipo que implementa un conjunto de rasgos. El conjunto de rasgos se compone de un &lt;em&gt;rasgo base &lt;/em&gt;&lt;a href=&quot;../items/traits#object-safety&quot;&gt;seguro para objetos&lt;/a&gt; m&amp;aacute;s cualquier n&amp;uacute;mero de &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;rasgos autom&amp;aacute;ticos&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">Un &lt;em&gt;rasgo&lt;/em&gt; describe una interfaz abstracta que los tipos pueden implementar. Esta interfaz consta de &lt;a href=&quot;associated-items&quot;&gt;elementos asociados&lt;/a&gt; , que vienen en tres variedades:</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">Un &lt;em&gt;rasgo&lt;/em&gt; le dice al compilador de Rust sobre la funcionalidad que tiene un tipo en particular y que puede compartir con otros tipos. Podemos utilizar rasgos para definir el comportamiento compartido de forma abstracta. Podemos usar l&amp;iacute;mites de rasgos para especificar que un gen&amp;eacute;rico puede ser cualquier tipo que tenga cierto comportamiento.</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">Un &lt;em&gt;&amp;iacute;ndice de tupla&lt;/em&gt; es &lt;code&gt;0&lt;/code&gt; o comienza con un &lt;em&gt;d&amp;iacute;gito decimal distinto de cero&lt;/em&gt; y contin&amp;uacute;a con cero o m&amp;aacute;s d&amp;iacute;gitos decimales. Los &amp;iacute;ndices de &lt;a href=&quot;items/structs&quot;&gt;tupla&lt;/a&gt; se utilizan para hacer referencia a los campos de &lt;a href=&quot;types/tuple&quot;&gt;tuplas&lt;/a&gt; , estructuras de &lt;a href=&quot;items/enumerations&quot;&gt;tuplas&lt;/a&gt; y variantes de tuplas .</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">Una &lt;em&gt;estructura de tupla&lt;/em&gt; es un tipo de &lt;a href=&quot;../types/tuple&quot;&gt;tupla&lt;/a&gt; nominal , tambi&amp;eacute;n definida con la palabra clave &lt;code&gt;struct&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">Un tipo de &lt;em&gt;estructura de tupla&lt;/em&gt; es como un tipo de estructura, excepto que los campos son an&amp;oacute;nimos.</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">Un &lt;em&gt;alias de tipo&lt;/em&gt; define un nuevo nombre para un &lt;a href=&quot;../types&quot;&gt;tipo&lt;/a&gt; existente . Los alias de tipo se declaran con el &lt;code&gt;type&lt;/code&gt; palabra clave . Cada valor tiene un tipo &amp;uacute;nico y espec&amp;iacute;fico, pero puede implementar varios rasgos diferentes o ser compatible con varias restricciones de tipo diferentes.</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de tipo&lt;/em&gt; como se define en la regla gramatical de &lt;em&gt;tipo&lt;/em&gt; anterior es la sintaxis para referirse a un tipo. Puede referirse a:</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">Un &lt;em&gt;tipo de uni&amp;oacute;n&lt;/em&gt; es una &lt;em&gt;uni&amp;oacute;n de tipo&lt;/em&gt; C heterog&amp;eacute;nea y nominal, indicada por el nombre de un &lt;a href=&quot;../items/unions&quot;&gt;elemento de &lt;/a&gt; &lt;code&gt;union&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">Una &lt;em&gt;estructura similar a&lt;/em&gt; una &lt;em&gt;unidad&lt;/em&gt; es una estructura sin campos, definida dejando fuera la lista de campos por completo. Tal estructura define impl&amp;iacute;citamente una constante de su tipo con el mismo nombre. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">Un tipo de &lt;em&gt;estructura similar a&lt;/em&gt; una &lt;em&gt;unidad&lt;/em&gt; es como un tipo de estructura, excepto que no tiene campos. El &amp;uacute;nico valor construido por la &lt;a href=&quot;../expressions/struct-expr&quot;&gt;expresi&amp;oacute;n de estructura&lt;/a&gt; asociada es el &amp;uacute;nico valor que habita dicho tipo.</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n de uso&lt;/em&gt; crea uno o m&amp;aacute;s enlaces de nombres locales sin&amp;oacute;nimo de alguna otra &lt;a href=&quot;../paths&quot;&gt;ruta&lt;/a&gt; . Por lo general, se &lt;code&gt;use&lt;/code&gt; una declaraci&amp;oacute;n de uso para acortar la ruta requerida para hacer referencia a un elemento de m&amp;oacute;dulo. Estas declaraciones pueden aparecer en &lt;a href=&quot;modules&quot;&gt;m&amp;oacute;dulos&lt;/a&gt; y &lt;a href=&quot;../expressions/block-expr&quot;&gt;bloques&lt;/a&gt; , generalmente en la parte superior.</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de valor&lt;/em&gt; es una expresi&amp;oacute;n que representa un valor real.</target>
        </trans-unit>
        <trans-unit id="e6fd1c9fb448dc3050e431f7efdd6fccf7fb69e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">Una &lt;em&gt;variable&lt;/em&gt; es un componente de un marco de pila, ya sea un par&amp;aacute;metro de funci&amp;oacute;n con nombre, un &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporal&lt;/a&gt; an&amp;oacute;nimo o una variable local con nombre.</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">Un &lt;em&gt;vector le&lt;/em&gt; permite almacenar un n&amp;uacute;mero variable de valores uno al lado del otro.</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">Un &lt;em&gt;escape de espacio en blanco&lt;/em&gt; es uno de los caracteres &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) o &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; ), que denota los valores Unicode &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) o &lt;code&gt;U+0009&lt;/code&gt; (HT) respectivamente.</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">Un &lt;em&gt;escape de espacio en blanco&lt;/em&gt; es uno de los caracteres &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) o &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; ), que denota los valores de bytes &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) o &lt;code&gt;0x09&lt;/code&gt; (ASCII HT ) respectivamente.</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">Un &lt;em&gt;espacio de trabajo&lt;/em&gt; es un conjunto de paquetes que comparten el mismo &lt;em&gt;Cargo.lock&lt;/em&gt; y el mismo directorio de salida. Hagamos un proyecto usando un espacio de trabajo; usaremos c&amp;oacute;digo trivial para poder concentrarnos en la estructura del espacio de trabajo. Hay varias formas de estructurar un espacio de trabajo; vamos a mostrar una forma com&amp;uacute;n. Tendremos un espacio de trabajo que contiene un binario y dos bibliotecas. El binario, que proporcionar&amp;aacute; la funcionalidad principal, depender&amp;aacute; de las dos bibliotecas. Una biblioteca proporcionar&amp;aacute; una funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; y una segunda biblioteca una funci&amp;oacute;n &lt;code&gt;add_two&lt;/code&gt; . Estas tres cajas formar&amp;aacute;n parte del mismo espacio de trabajo. Comenzaremos creando un nuevo directorio para el espacio de trabajo:</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">Un sistema &lt;strong&gt;multiprocesador&lt;/strong&gt; que ejecuta m&amp;uacute;ltiples subprocesos de hardware al mismo tiempo: en escenarios de m&amp;uacute;ltiples subprocesos, puede usar dos tipos de primitivas para lidiar con la sincronizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">Una operaci&amp;oacute;n de &lt;strong&gt;env&amp;iacute;o&lt;/strong&gt; solo puede fallar si el extremo receptor de un canal est&amp;aacute; desconectado, lo que implica que los datos nunca podr&amp;iacute;an recibirse. El error contiene los datos que se env&amp;iacute;an como una carga &amp;uacute;til para que se puedan recuperar.</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">Un &lt;strong&gt;solo procesador que&lt;/strong&gt; ejecuta instrucciones &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;fuera de orden&lt;/a&gt; : las CPU modernas son capaces de una ejecuci&amp;oacute;n &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superescalar&lt;/a&gt; , es decir, pueden ejecutarse varias instrucciones al mismo tiempo, aunque el c&amp;oacute;digo m&amp;aacute;quina describa un proceso secuencial.</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">En cambio, un &amp;aacute;rbol B hace que cada nodo contenga elementos B-1 a 2B-1 en una matriz contigua. Al hacer esto, reducimos el n&amp;uacute;mero de asignaciones en un factor de B y mejoramos la eficiencia de la cach&amp;eacute; en las b&amp;uacute;squedas. Sin embargo, esto significa que las b&amp;uacute;squedas tendr&amp;aacute;n que hacer &lt;em&gt;m&amp;aacute;s&lt;/em&gt; comparaciones en promedio. El n&amp;uacute;mero exacto de comparaciones depende de la estrategia de b&amp;uacute;squeda de nodos utilizada. Para una eficiencia de cach&amp;eacute; &amp;oacute;ptima, se pueden buscar los nodos linealmente. Para realizar comparaciones &amp;oacute;ptimas, se puede buscar en el nodo mediante una b&amp;uacute;squeda binaria. Como compromiso, tambi&amp;eacute;n se podr&amp;iacute;a realizar una b&amp;uacute;squeda lineal que inicialmente solo verifica cada i- &lt;sup&gt;&amp;eacute;simo&lt;/sup&gt; elemento para alguna elecci&amp;oacute;n de i.</target>
        </trans-unit>
        <trans-unit id="4c64fcf1b73694ea8bba81897d2a64705afb1b18" translate="yes" xml:space="preserve">
          <source>A C-variadic type is used to give an undefined number of parameters to a given function (like &lt;code&gt;printf&lt;/code&gt; in C). The equivalent in Rust would be to use macros directly (like &lt;code&gt;println!&lt;/code&gt; for example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">Una mirada más cercana a una solicitud de HTTP</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">Una condición variable</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Un binario o biblioteca del óxido.</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">Un programa Rust tiene idéntico significado si cada elemento de espacio en blanco se sustituye por cualquier otro elemento de espacio en blanco legal,como por ejemplo un único carácter de espacio.</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Un archivo de origen de Rust describe un m&amp;oacute;dulo, el nombre y la ubicaci&amp;oacute;n del cual, en el &amp;aacute;rbol de m&amp;oacute;dulos de la caja actual, se definen desde fuera del archivo de origen: ya sea por un elemento de &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;m&amp;oacute;dulo&lt;/em&gt;&lt;/a&gt; expl&amp;iacute;cito en un archivo de origen de referencia, o por el nombre del caja en s&amp;iacute;. Cada archivo fuente es un m&amp;oacute;dulo, pero no todos los m&amp;oacute;dulos necesitan su propio archivo fuente: las &lt;a href=&quot;items/modules&quot;&gt;definiciones de m&amp;oacute;dulo&lt;/a&gt; se pueden anidar dentro de un archivo.</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">Un atajo para propagar errores: el &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operador</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">Un servidor de socorro TCP,escuchando las conexiones.</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">Un flujo TCP entre un enchufe local y uno remoto.</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">Un toque de refactorización</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">Un recorrido por la biblioteca de The Rust Standard</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">Un enchufe UDP.</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">Un cordón UTF-8 codificado,cultivable.</target>
        </trans-unit>
        <trans-unit id="9de745a43beb358e074abd87790ad347e9b21ca2" translate="yes" xml:space="preserve">
          <source>A UTF-8&amp;ndash;encoded, growable string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">Un zócalo de datagramas de Unix.</target>
        </trans-unit>
        <trans-unit id="735c3a01ab88f3b77275bbda413fc5d0f8e00e4c" translate="yes" xml:space="preserve">
          <source>A Unix socket Ancillary data struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">Un enchufe de corriente Unix.</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">Un caso de uso para la mutación interior:Objetos de imitación</target>
        </trans-unit>
        <trans-unit id="822d2ee37fadc9a2c447d0ca642e7e4a4d011579" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Un prefijo de ruta de Windows, por ejemplo, &lt;code&gt;C:&lt;/code&gt; o &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41a63844a54d0452136942153b7bfc3f9e8d7950" translate="yes" xml:space="preserve">
          <source>A backtrace has been captured and the &lt;code&gt;Backtrace&lt;/code&gt; should print reasonable information when rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063c41d44c26a8e514637789567756dedf001744" translate="yes" xml:space="preserve">
          <source>A backtrace is typically quite handy to attach to errors (e.g. types implementing &lt;code&gt;std::error::Error&lt;/code&gt;) to get a causal chain of where an error was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">Una barrera permite a múltiples hilos sincronizar el comienzo de algunos cálculos.</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una barrera bloquear&amp;aacute; &lt;code&gt;n&lt;/code&gt; -1 hilos que llaman a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; y luego activan todos los subprocesos a la vez cuando las &lt;code&gt;n&lt;/code&gt; - &amp;eacute;simas llamadas &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62ccc167e0423bac501b2cd57e5b7720dec15103" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">Un ejemplo básico:</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">Una declaraci&amp;oacute;n de cadena b&amp;aacute;sica del tipo &lt;code&gt;&amp;amp;str&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e58e2e213f635868b8917c1f64d97bcd94087385" translate="yes" xml:space="preserve">
          <source>A binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807a8b4172841ae84d2493b466a14c239a712c9e" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the &lt;code&gt;main()&lt;/code&gt; function. If there are multiple instances of this function, please rename one of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">Un binario solo puede tener un punto de entrada y, por defecto, ese punto de entrada es la funci&amp;oacute;n &lt;code&gt;main()&lt;/code&gt; . Si hay varias de estas funciones, cambie el nombre de una.</target>
        </trans-unit>
        <trans-unit id="66f8440b5cbe5979ef5cd4aca43bf502a1ba0914" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">Se intentó una operación binaria en un tipo que no la soporta.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">Una unión ensombreció algo que no debería.</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">Una expresión de bloque como la expresión de la cola de otra expresión de bloque.</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">Un bloque de c&amp;oacute;digo puede tener el prefijo &lt;code&gt;unsafe&lt;/code&gt; palabra clave insegura para permitir &lt;a href=&quot;../unsafety&quot;&gt;operaciones inseguras&lt;/a&gt; . Ejemplos:</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">Un bloque de c&amp;oacute;digo puede tener el prefijo &lt;code&gt;unsafe&lt;/code&gt; palabra clave insegura , para permitir llamar a funciones &lt;code&gt;unsafe&lt;/code&gt; o desreferenciar punteros en bruto dentro de una funci&amp;oacute;n segura.</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">Una entrada de blog comienza como un borrador vacío.</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">Un tipo booleano que puede ser compartido con seguridad entre hilos.</target>
        </trans-unit>
        <trans-unit id="eb779fca6863a6a0d358d8e696c27d09f35c87e4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">Se intentó un préstamo de una constante que contenía la mutabilidad interior.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="6c3704913d69bb40474f716695cc894d7bfa528c" translate="yes" xml:space="preserve">
          <source>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f237c3c1919eddd418933b1a63f322a0d0d2a0eb" translate="yes" xml:space="preserve">
          <source>A borrowed value was moved out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2fc820fbc3d301d2c71b19ff6713c60dff7377" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">Una variable prestada fue utilizada por un cierre.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="b7c0d93da848c216d8d60ef97d23c6ae7dfef33f" translate="yes" xml:space="preserve">
          <source>A break expression is normally associated with the innermost loop enclosing the &lt;code&gt;break&lt;/code&gt; but a label can be used to specify which enclosing loop is affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">Una direcci&amp;oacute;n de difusi&amp;oacute;n tiene todos los octetos establecidos en 255 como se define en &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">Un amortiguador que es demasiado pequeño:</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">Un tipo de tamp&amp;oacute;n usado con &lt;code&gt;Read::read_vectored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">Un tipo de tamp&amp;oacute;n usado con &lt;code&gt;Write::write_vectored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">Un constructor para la computación donde en un HashMap se almacenaría un par llave-valor.</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">Un constructor solía crear directorios de varias maneras.</target>
        </trans-unit>
        <trans-unit id="d9b7dd70756681f35180b19cd1bfebd1be340c71" translate="yes" xml:space="preserve">
          <source>A builtin-macro was defined more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3712794ff88bfb37526db3c27354e391cdfb3531" translate="yes" xml:space="preserve">
          <source>A by-value &lt;a href=&quot;../primitive.array&quot;&gt;array&lt;/a&gt; iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1dde52635a5e1dfcc3c9c412ee03038fd5a1fd" translate="yes" xml:space="preserve">
          <source>A byte constant wasn't correctly ended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358ac47a7f574535f0a6c2b6627900a1db482bcb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;Drop::drop&lt;/code&gt; for that value, if this special &lt;code&gt;Drop&lt;/code&gt; trait is implemented for its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">Una llamada a &lt;code&gt;park&lt;/code&gt; no garantiza que el hilo permanezca aparcado para siempre, y las personas que llaman deben estar preparadas para esta posibilidad.</target>
        </trans-unit>
        <trans-unit id="310114efe1d071325aac9ee697835f3fab748547" translate="yes" xml:space="preserve">
          <source>A captured OS thread stack backtrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068d1bfcec9a1ae7628a6bb97579dd58498f1145" translate="yes" xml:space="preserve">
          <source>A captured variable in a closure may not live long enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">Se intentó una escayola entre un puntero delgado y uno gordo.</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">Se intent&amp;oacute; lanzar a &lt;code&gt;char&lt;/code&gt; en un tipo que no sea &lt;code&gt;u8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">Se intentó hacer un molde a un tipo sin tamaño.</target>
        </trans-unit>
        <trans-unit id="8ca946f31b782b50520401ae5f6d2242f47dbf2a" translate="yes" xml:space="preserve">
          <source>A cell which can be written to only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">Un canal en programaci&amp;oacute;n tiene dos mitades: un transmisor y un receptor. La mitad del transmisor es la ubicaci&amp;oacute;n corriente arriba donde pones los patitos de goma en el r&amp;iacute;o, y la mitad del receptor es donde el pato de goma termina corriente abajo. Una parte de su c&amp;oacute;digo llama a m&amp;eacute;todos en el transmisor con los datos que desea enviar, y otra parte verifica el extremo receptor para ver si llegan mensajes. Se dice que un canal est&amp;aacute; &lt;em&gt;cerrado&lt;/em&gt; si se cae la mitad del transmisor o del receptor.</target>
        </trans-unit>
        <trans-unit id="9b271c9cb4969ff9e8017b48dea5ee7ea287981f" translate="yes" xml:space="preserve">
          <source>A character literal wasn't ended with a quote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">Un tipo de personaje.</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">Una clasificación de números de punto flotante.</target>
        </trans-unit>
        <trans-unit id="dea8ae8b6b70c73b2cce436aaeecb02e010d0c2b" translate="yes" xml:space="preserve">
          <source>A clobber was surrounded by braces in the &lt;code&gt;llvm_asm&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">Un puntero inteligente de clonación y escritura.</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">Una expresi&amp;oacute;n de cierre denota una funci&amp;oacute;n que asigna una lista de par&amp;aacute;metros a la expresi&amp;oacute;n que sigue a los par&amp;aacute;metros. Al igual que un &lt;a href=&quot;../statements#let-statements&quot;&gt;enlace &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; , los par&amp;aacute;metros son &lt;a href=&quot;../patterns&quot;&gt;patrones&lt;/a&gt; irrefutables , cuyo tipo de anotaci&amp;oacute;n es opcional y se deducir&amp;aacute; del contexto si no se da. Cada expresi&amp;oacute;n de cierre tiene un tipo &amp;uacute;nico y an&amp;oacute;nimo.</target>
        </trans-unit>
        <trans-unit id="229f7ae12c2338583566d98b6347b250aaf7fe51" translate="yes" xml:space="preserve">
          <source>A closure has been used as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">Un cierre es &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; si no captura ning&amp;uacute;n valor por referencia &amp;uacute;nica inmutable o mutable, y si todos los valores que captura al copiar o mover son &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un cierre es &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; si todas las variables capturadas por una referencia inmutable no &amp;uacute;nica est&amp;aacute;n &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; , y todos los valores capturados por una referencia, copia o movimiento &amp;uacute;nico inmutable o mutable son &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un cierre es &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; si todas las variables capturadas son &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">Se construyó un cierre o generador que hace referencia a su propio tipo.</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">Se utilizó un cierre pero no se implementó el rasgo esperado.</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">Un cierre que no se mueve fuera de ninguna variable capturada implementa &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , lo que indica que puede ser llamado por referencia mutable.</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">Un cierre que no mute ni se mueva fuera de ninguna variable capturada implementa &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , lo que indica que se puede llamar por referencia compartida.</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">La coacción sólo puede producirse en determinados lugares de coacción de un programa;se trata típicamente de lugares en los que el tipo deseado es explícito o puede derivarse por propagación de tipos explícitos (sin inferencia de tipo).Los posibles sitios de coacción son:</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">Conjunto de métodos necesarios para dar formato a un mensaje en un flujo.</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">Un ejemplo com&amp;uacute;n es el m&amp;eacute;todo de &lt;code&gt;collect&lt;/code&gt; en &lt;code&gt;Iterator&lt;/code&gt; . Tiene un par&amp;aacute;metro de tipo gen&amp;eacute;rico con un l&amp;iacute;mite &lt;code&gt;FromIterator&lt;/code&gt; , que para un iterador &lt;code&gt;char&lt;/code&gt; es implementado por &lt;code&gt;Vec&lt;/code&gt; y &lt;code&gt;String&lt;/code&gt; entre otros. Considere el siguiente fragmento que invierte los caracteres de una cadena:</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">Una interfaz común para una clase de tipos.</target>
        </trans-unit>
        <trans-unit id="8baf44157a38997462218326dfa5b36c89567539" translate="yes" xml:space="preserve">
          <source>A common interface for a group of types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">Un error com&amp;uacute;n es pensar que &quot;las direcciones de enlace local de unidifusi&amp;oacute;n comienzan con &lt;code&gt;fe80::&lt;/code&gt; &quot;, pero el &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291 en&lt;/a&gt; realidad define un formato m&amp;aacute;s estricto para estas direcciones:</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">Un problema com&amp;uacute;n con el uso de valores devueltos para indicar errores es que es f&amp;aacute;cil ignorar el valor devuelto, por lo que no se puede manejar el error. &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; se anota con el atributo &lt;code&gt;#[must_use]&lt;/code&gt; , que har&amp;aacute; que el compilador emita una advertencia cuando se ignore un valor de Resultado. Esto hace que &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; sea especialmente &amp;uacute;til con funciones que pueden encontrar errores pero que de otro modo no devuelven un valor &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">Un rasgo común para la capacidad de duplicar explícitamente un objeto.</target>
        </trans-unit>
        <trans-unit id="f3fcc76ff39756ffd2b4cb1d33e25cb209dbe4a4" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3bf37cba543ca385f5031852ec32495e2e84e3" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop_hint&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&amp;iexcl;Un uso com&amp;uacute;n para el &lt;code&gt;format!&lt;/code&gt; es la concatenaci&amp;oacute;n e interpolaci&amp;oacute;n de cadenas. &amp;iexcl;La misma convenci&amp;oacute;n se usa con la &lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;y &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;macros, seg&amp;uacute;n el destino previsto de la cadena.</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">Un uso com&amp;uacute;n de esta funci&amp;oacute;n es envenenar los recursos compartidos cuando se escribe c&amp;oacute;digo inseguro, marcando el &lt;code&gt;panicking&lt;/code&gt; cuando se llama a la &lt;code&gt;drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">Una forma com&amp;uacute;n de probar la funcionalidad es comparar el resultado del c&amp;oacute;digo bajo prueba con el valor que espera que devuelva el c&amp;oacute;digo para asegurarse de que sean iguales. &amp;iexcl;Podr&amp;iacute;as hacer esto usando la &lt;code&gt;assert!&lt;/code&gt; macro y pas&amp;aacute;ndole una expresi&amp;oacute;n usando el operador &lt;code&gt;==&lt;/code&gt; . Sin embargo, esta es una prueba tan com&amp;uacute;n que la biblioteca est&amp;aacute;ndar proporciona un par de macros &lt;code&gt;assert_eq!&lt;/code&gt; y &lt;code&gt;assert_ne!&lt;/code&gt; &amp;mdash;Para realizar esta prueba de manera m&amp;aacute;s conveniente. Estas macros comparan dos argumentos a favor de la igualdad o la desigualdad, respectivamente. Tambi&amp;eacute;n imprimir&amp;aacute;n los dos valores si falla la afirmaci&amp;oacute;n, lo que facilita ver &lt;em&gt;por qu&amp;eacute;&lt;/em&gt; fall&amp;oacute; la prueba; a la inversa, &lt;code&gt;assert!&lt;/code&gt; macro solo indica que obtuvo un &lt;code&gt;false&lt;/code&gt; valor para &lt;code&gt;==&lt;/code&gt; expresi&amp;oacute;n, no los valores que conducen al valor &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">Una forma com&amp;uacute;n de utilizar &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; es en combinaci&amp;oacute;n con &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; . Recuerde que &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; permite tener varios propietarios de algunos datos, pero solo brinda acceso inmutable a esos datos. Si tiene un &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; que contiene un &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , puede obtener un valor que puede tener varios propietarios &lt;em&gt;y&lt;/em&gt; que puede mutar.</target>
        </trans-unit>
        <trans-unit id="c3a2eb5105511775d59e5e4cd686eb5579136f33" translate="yes" xml:space="preserve">
          <source>A comparison like the one above, which ignores some fields of the struct, can be dangerous. It can easily lead to an unintended violation of the requirements for a partial equivalence relation. For example, if we kept the above implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;BookFormat&lt;/code&gt; and added an implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;Book&lt;/code&gt; (either via a &lt;code&gt;#[derive]&lt;/code&gt; or via the manual implementation from the first example) then the result would violate transitivity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">Nunca se emite un error de tiempo de compilación cuando se utiliza esta macro,independientemente de si la variable de entorno está presente o no.</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">Una valla de memoria del compilador.</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">Una barrera de memoria sólo para el compilador.</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">Una opción de configuración.Es verdadera si la opción está configurada y falsa si no está configurada.</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">Una consecuencia de las reglas de pr&amp;eacute;stamo es que cuando tienes un valor inmutable, no puedes pedirlo prestado de manera mutante. Por ejemplo, este c&amp;oacute;digo no se compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="82e92c5c9841d5d2d3e69bff0f6aeb9309a13f00" translate="yes" xml:space="preserve">
          <source>A constant item was initialized with something that is not a constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce86a2e004403aa5ba6b72a885c67d143829985" translate="yes" xml:space="preserve">
          <source>A constant value failed to get evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Un tipo de matriz de crecimiento contiguo con contenido asignado al mont&amp;oacute;n, escrito &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">Un tipo de matriz de crecimiento contiguo, escrito &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; pero pronunciado 'vector'.</target>
        </trans-unit>
        <trans-unit id="821a3f39751014be2886a42509e99ef71f4b3a2f" translate="yes" xml:space="preserve">
          <source>A control-flow expression was used inside a const context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">Una funci&amp;oacute;n de conveniencia que muestra un &lt;code&gt;io::Result&lt;/code&gt; a su llamador:</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">Un impl&amp;iacute;cito de conveniencia que delega al impl para &lt;code&gt;&amp;amp;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35a7bd82b1e1370c217a40362b5ca9b11be11f9d" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5815609ea9bdc6c8447adfe133c418ba6a0e628" translate="yes" xml:space="preserve">
          <source>A correct implementation could look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">Una caja es algo an&amp;aacute;loga a un &lt;em&gt;ensamblaje&lt;/em&gt; en el modelo CLI ECMA-335, una &lt;em&gt;biblioteca&lt;/em&gt; en el Administrador de compilaci&amp;oacute;n SML / NJ, una &lt;em&gt;unidad&lt;/em&gt; en el sistema de m&amp;oacute;dulos Owens y Flatt o una &lt;em&gt;configuraci&amp;oacute;n&lt;/em&gt; en Mesa.</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">Un cajón necesita un &quot;módulo de ayuda&quot; disponible a nivel mundial para sí mismo,pero no quiere exponer el módulo de ayuda como una API pública.Para lograrlo,la raíz de la jerarquía de la caja tendría un módulo privado que luego internamente tendría una &quot;API pública&quot;.Dado que toda la caja es descendiente de la raíz,entonces toda la caja local puede acceder a este módulo privado a través del segundo caso.</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">Una caja que contiene una &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n &lt;/a&gt; &lt;code&gt;main&lt;/code&gt; se puede compilar en un ejecutable. Si una funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; est&amp;aacute; presente, no debe tomar argumentos, no debe declarar ning&amp;uacute;n &lt;a href=&quot;trait-bounds&quot;&gt;rasgo o l&amp;iacute;mites de por vida&lt;/a&gt; , no debe tener &lt;a href=&quot;items/generics#where-clauses&quot;&gt;cl&amp;aacute;usulas where&lt;/a&gt; y su tipo de retorno debe ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">Una caja agrupar&amp;aacute; la funcionalidad relacionada en un &amp;aacute;mbito para que la funcionalidad sea f&amp;aacute;cil de compartir entre m&amp;uacute;ltiples proyectos. Por ejemplo, la caja &lt;code&gt;rand&lt;/code&gt; que usamos en el &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Cap&amp;iacute;tulo 2&lt;/a&gt; proporciona una funcionalidad que genera n&amp;uacute;meros aleatorios. Podemos usar esa funcionalidad en nuestros propios proyectos al incorporar la caja &lt;code&gt;rand&lt;/code&gt; al alcance de nuestro proyecto. Se puede acceder a toda la funcionalidad proporcionada por la caja &lt;code&gt;rand&lt;/code&gt; a trav&amp;eacute;s del nombre de la caja, &lt;code&gt;rand&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9489488427833bc0214d8f4c5f5a907ee47ae129" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">Se implementó un rasgo de exclusión cruzada en algo que no era un tipo de estructura o enumeración.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="521073eb4a9d5dea34971bbf2d3b43472252d22c" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt; with editing operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e765e383228431ae063a8d9a831d2b82107b6c73" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">Un ciclo entre punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; nunca se desasignar&amp;aacute;. Por esta raz&amp;oacute;n, &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; se utiliza para romper ciclos. Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; de los nodos principales a los hijos y &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">Un ciclo entre punteros de &lt;code&gt;Arc&lt;/code&gt; nunca se desasignar&amp;aacute;. Por esta raz&amp;oacute;n, &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; se utiliza para romper ciclos. Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;code&gt;Arc&lt;/code&gt; de los nodos principales a los hijos y &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">Una estructura de datos está en un estado temporalmente inválido cuando el hilo entra en pánico.</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">Se puede generar una configuraci&amp;oacute;n predeterminada usando &lt;code&gt;Command::new(program)&lt;/code&gt; , donde el &lt;code&gt;program&lt;/code&gt; a proporciona una ruta al programa que se ejecutar&amp;aacute;. Los m&amp;eacute;todos de construcci&amp;oacute;n adicionales permiten cambiar la configuraci&amp;oacute;n (por ejemplo, agregando argumentos) antes de la generaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">En la aplicación de un rasgo se dio una definición de un método que no está en el rasgo aplicado.</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">Un discriminante en una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n no incluido en la definici&amp;oacute;n de tipo.</target>
        </trans-unit>
        <trans-unit id="1d4413773858071be2cda9c035b93d8adb5ed9c4" translate="yes" xml:space="preserve">
          <source>A discriminant value is present more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33398f8a1c82819cfc272eb4db0376550aceebc" translate="yes" xml:space="preserve">
          <source>A doc comment that is not attached to anything has been encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">Se encontró un comentario de documentación que no documenta nada.</target>
        </trans-unit>
        <trans-unit id="b5da65d7d41e577505a8697b6d53146c919ad568" translate="yes" xml:space="preserve">
          <source>A double quote byte string (&lt;code&gt;b&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c189219618ff090bbaf1c282c8ad43303eb7709" translate="yes" xml:space="preserve">
          <source>A double quote string (&lt;code&gt;&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">Un iterador de doble extremo con la dirección invertida.</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">Una cola de doble terminación implementada con un buffer de anillo cultivable.</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">Una lista doblemente vinculada con nodos propios.</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador para &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador para &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre los elementos de un &lt;code&gt;BinaryHeap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre los elementos de un &lt;code&gt;VecDeque&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre las entradas de un &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre los elementos de un &lt;code&gt;HashSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0414ecefaa3523675384470efb07b95159dba45" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb2903d11786dcb8b8844e91d87fb7f80657414" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40d5a17630e0b8c5262cd5da85143e19cf981ab" translate="yes" xml:space="preserve">
          <source>A duration of zero time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">Un tipo de tamaño dinámico (DST)es un tipo sin un tamaño o alineación estáticamente conocido.</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">Una vista de tama&amp;ntilde;o din&amp;aacute;mico en una secuencia contigua, &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9b7bf32fab7bb231166bbede96c90271ed78811" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">Un atributo de característica llamado una característica que ha sido eliminada.</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">Un atributo de característica llamado característica que fue desautorizado en las banderas de la línea de comandos del compilador.</target>
        </trans-unit>
        <trans-unit id="7d16601ad6554f548eab3701b5a36e77bca297da" translate="yes" xml:space="preserve">
          <source>A feature name is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">Una cerca 'A' que tiene (al menos) Sem&amp;aacute;ntica de orden de &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; , se sincroniza con una cerca 'B' con (al menos) Sem&amp;aacute;ntica de &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; , si y solo si existen operaciones X e Y, ambas operando sobre alg&amp;uacute;n objeto at&amp;oacute;mico 'M' tal que A se secuencia antes de X, Y se sincroniza antes de que B e Y observen el cambio a M. Esto proporciona una dependencia de suceder antes de A y B.</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">Una valla que tiene &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; pedidos, adem&amp;aacute;s de tener tanto &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; sem&amp;aacute;ntica, participa en el orden programa global de los dem&amp;aacute;s &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; operaciones y / o cercas.</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">Un acceso de campo es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar que se&lt;/a&gt; refiere a la ubicaci&amp;oacute;n de ese campo. Cuando la subexpresi&amp;oacute;n es &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt; , la expresi&amp;oacute;n del campo tambi&amp;eacute;n lo es.</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">No se encontró un archivo para un módulo fuera de línea.</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Una &amp;uacute;ltima raz&amp;oacute;n por la que Rust no nos permite indexar en una &lt;code&gt;String&lt;/code&gt; para obtener un car&amp;aacute;cter es que se espera que las operaciones de indexaci&amp;oacute;n siempre tomen un tiempo constante (O (1)). Pero no es posible garantizar ese rendimiento con una &lt;code&gt;String&lt;/code&gt; , porque Rust tendr&amp;iacute;a que recorrer el contenido desde el principio hasta el &amp;iacute;ndice para determinar cu&amp;aacute;ntos caracteres v&amp;aacute;lidos hab&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">Una secuencia heterog&amp;eacute;nea finita, &lt;code&gt;(T, U, ..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Una matriz de tama&amp;ntilde;o fijo, denotada &lt;code&gt;[T; N]&lt;/code&gt; , para el tipo de elemento, &lt;code&gt;T&lt;/code&gt; , y el tama&amp;ntilde;o constante de tiempo de compilaci&amp;oacute;n no negativo, &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">A de bucle es equivalente a la siguiente expresión de bloque.</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">Se requiere una cadena de formato para utilizar todos sus argumentos,de lo contrario es un error en tiempo de compilación.Puede referirse al mismo argumento más de una vez en la cadena de formato.</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">Una funci&amp;oacute;n anotada con el atributo de &lt;code&gt;test&lt;/code&gt; tambi&amp;eacute;n se puede anotar con el atributo &lt;code&gt;ignore&lt;/code&gt; . El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/em&gt; le dice al arn&amp;eacute;s de prueba que no ejecute esa funci&amp;oacute;n como prueba. Todav&amp;iacute;a se compilar&amp;aacute; cuando est&amp;eacute; en modo de prueba.</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">Una funci&amp;oacute;n anotada con el atributo de &lt;code&gt;test&lt;/code&gt; que devuelve &lt;code&gt;()&lt;/code&gt; tambi&amp;eacute;n se puede anotar con el atributo &lt;code&gt;should_panic&lt;/code&gt; . El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt; hace que la prueba solo pase si realmente entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">No se permite una llamada a la función en la expresión de inicialización de la const,porque el valor de la expresión debe conocerse en tiempo de compilación.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">Una funci&amp;oacute;n declarada en un bloque externo es impl&amp;iacute;citamente &lt;code&gt;unsafe&lt;/code&gt; . Cuando se coacciona a un puntero de funci&amp;oacute;n, una funci&amp;oacute;n declarada en un bloque externo tiene el tipo &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; , donde &lt;code&gt;'l1&lt;/code&gt; , ... &lt;code&gt;'lm&lt;/code&gt; son sus par&amp;aacute;metros de duraci&amp;oacute;n, &lt;code&gt;A1&lt;/code&gt; , ..., &lt;code&gt;An&lt;/code&gt; son los tipos declarados de sus par&amp;aacute;metros y &lt;code&gt;R&lt;/code&gt; es el tipo de retorno declarado.</target>
        </trans-unit>
        <trans-unit id="d0692343f061c0cd9d5ae6d4139b26c55c59ad9f" translate="yes" xml:space="preserve">
          <source>A function is using &lt;code&gt;continue&lt;/code&gt; keyword incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">Una función o un puntero de función.</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">La firma de una funci&amp;oacute;n debe declarar el n&amp;uacute;mero y tipo de par&amp;aacute;metros que tiene la funci&amp;oacute;n. Las macros, por otro lado, pueden tomar un n&amp;uacute;mero variable de par&amp;aacute;metros: podemos llamar a &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; con un argumento o &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; con dos argumentos. Adem&amp;aacute;s, las macros se expanden antes de que el compilador interprete el significado del c&amp;oacute;digo, por lo que una macro puede, por ejemplo, implementar un rasgo en un tipo determinado. Una funci&amp;oacute;n no puede, porque se llama en tiempo de ejecuci&amp;oacute;n y es necesario implementar un rasgo en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">Una funci&amp;oacute;n que tiene un par&amp;aacute;metro o devuelve solo n&amp;uacute;meros entre 1 y 100 podr&amp;iacute;a declarar en su firma que toma o devuelve un &lt;code&gt;Guess&lt;/code&gt; en lugar de un &lt;code&gt;i32&lt;/code&gt; y no necesitar&amp;iacute;a hacer ninguna verificaci&amp;oacute;n adicional en su cuerpo.</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">Una función que es opaca para el optimizador,para permitir que los puntos de referencia pretendan utilizar los resultados para ayudar a evitar la eliminación del código muerto.</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">Se declar&amp;oacute; una funci&amp;oacute;n con el atributo de &lt;code&gt;start&lt;/code&gt; con par&amp;aacute;metros de tipo.</target>
        </trans-unit>
        <trans-unit id="cc716e4e83b4efb34e4101d17ccb62e4b2b1eb26" translate="yes" xml:space="preserve">
          <source>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. The &lt;code&gt;Fn&lt;/code&gt; traits and &lt;code&gt;Sized&lt;/code&gt; are fundamental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0649f34bf1c96947359554a4e3b1fb6bd7f77d90" translate="yes" xml:space="preserve">
          <source>A fundamental type constructor is a type where implementing a &lt;a href=&quot;#blanket-implementation&quot;&gt;blanket implementation&lt;/a&gt; over it is a breaking change. &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, &lt;code&gt;Box&lt;/code&gt;, and &lt;code&gt;Pin&lt;/code&gt; are fundamental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">Un futuro es un valor que puede no haber terminado de computar todavía.Este tipo de &quot;valor asíncrono&quot; hace posible que un hilo continúe haciendo un trabajo útil mientras espera a que el valor esté disponible.</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">Un futuro representa un cálculo asíncrono.</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">Una generalizaci&amp;oacute;n de &lt;code&gt;Clone&lt;/code&gt; a datos prestados.</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">Una función genérica debe ser tratada de manera similar:</target>
        </trans-unit>
        <trans-unit id="47dc8336e1d401035013095c768eec4aaa7de80d" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">Se describió un tipo genérico utilizando paréntesis en lugar de paréntesis angulares.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">Un tipo gen&amp;eacute;rico donde uno o m&amp;aacute;s tipos asociados tienen asignaciones espec&amp;iacute;ficas (p. Ej., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">Una nota espantosa 👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">Una determinada pareja M se encarga de tres juegos:PRIMERA(M),ULTIMA(M)y SEGUIDA(M).</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">Un gran ejemplo de una situaci&amp;oacute;n en la que esta t&amp;eacute;cnica es &amp;uacute;til es la sobrecarga del operador. &lt;em&gt;La sobrecarga de operadores&lt;/em&gt; es personalizar el comportamiento de un operador (como &lt;code&gt;+&lt;/code&gt; ) en situaciones particulares.</target>
        </trans-unit>
        <trans-unit id="77b606312f70d0e0e8a4e81eb457af73b41943c1" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; does not permit zero-initialization: This will statically either panic, or do nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d1fa93ccd1713ed23cb21dd7e4493abed0a332" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; has invalid bit patterns: This will statically either panic, or do nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">Una protecci&amp;oacute;n para funciones inseguras que no se pueden ejecutar nunca si &lt;code&gt;T&lt;/code&gt; est&amp;aacute; deshabitado: esto entrar&amp;aacute; en p&amp;aacute;nico est&amp;aacute;ticamente o no har&amp;aacute; nada.</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">Un mango para la entrada estándar de un proceso infantil (stdin).</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">Un mango para la salida estándar de un proceso infantil (stdout).</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">Una manija para el error del proceso de un niño.</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">Un mango a un hilo.</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">Una manija para el flujo de salida estándar global del proceso actual.</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">Una manija para el flujo de error estándar de un proceso.</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">Una manija para el flujo de entrada estándar de un proceso.</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">Un mapa hash implementado con sondeo lineal y robo de cubos de Robin Hood.</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">Un mapa hash implementado con sondeo cuadrático y búsqueda SIMD.</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Un conjunto de hash implementado como &lt;code&gt;HashMap&lt;/code&gt; donde el valor es &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">Un tipo de hachís.</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">Una estructura de ayuda para el orden inverso.</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">Un rasgo de ayuda utilizado para las operaciones de indexación.</target>
        </trans-unit>
        <trans-unit id="29862de09ef195f3021bf8c1026b55bc84123b69" translate="yes" xml:space="preserve">
          <source>A incorrectly formatted &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; will produce an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">Se redefinió un ítem de langosta.</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">Un gran n&amp;uacute;mero de las estructuras proporcionadas por &lt;code&gt;std::io&lt;/code&gt; son para varias formas de iterar sobre E / S. Por ejemplo, &lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; &lt;/a&gt; se utiliza para dividir l&amp;iacute;neas:</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos a diferencia de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la diferencia de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la intersecci&amp;oacute;n de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la intersecci&amp;oacute;n de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la diferencia sim&amp;eacute;trica de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la diferencia sim&amp;eacute;trica de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la uni&amp;oacute;n de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la uni&amp;oacute;n de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">Un desarrollador de bibliotecas necesita exponer la funcionalidad a las cajas que se vinculan con su biblioteca. Como consecuencia del primer caso, esto significa que todo lo que sea utilizable externamente debe ser &lt;code&gt;pub&lt;/code&gt; licarse desde la ra&amp;iacute;z hasta el elemento de destino. Cualquier art&amp;iacute;culo privado de la cadena no permitir&amp;aacute; los accesos externos.</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">Una vida aparece sólo en una unión de tipo asociado,y no en los tipos de entrada al rasgo.</target>
        </trans-unit>
        <trans-unit id="15786eaf619ace068790ae58d796d7da4d047a8c" translate="yes" xml:space="preserve">
          <source>A lifetime bound on a trait implementation was captured at an incorrect place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">Una vida atada no fue satisfecha.</target>
        </trans-unit>
        <trans-unit id="f5eb99d9ba1d633f5bab932159c4263f91c6e225" translate="yes" xml:space="preserve">
          <source>A lifetime cannot be determined in the given situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cad79ba7fd3784fc14fc3f6b2c2d3527062c63" translate="yes" xml:space="preserve">
          <source>A lifetime didn't match what was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2036255cc30a38458aebc41a1b7522c2030656d" translate="yes" xml:space="preserve">
          <source>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">Un nombre de por vida no puede ser declarado más de una vez en el mismo ámbito.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="315c1653fb8738d323beeedab26038fcdebdd0a1" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">Un nombre de toda la vida es la sombra de otro nombre de toda la vida.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="60dd9352a1988e94c38ce60166a9c885adb54457" translate="yes" xml:space="preserve">
          <source>A lifetime was declared more than once in the same scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c742ea21e8d68de6fe9c8cd053579ea9357b0ab" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">Se dio un nombre de enlace con un nombre vacío.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="7aff8ae0fa99ab18b982ebf4bf49db472c773b53" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">Se utilizó un enlace sin un parámetro de nombre.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">Un atributo de verificaci&amp;oacute;n de pelusa fue anulado por una directiva &lt;code&gt;forbid&lt;/code&gt; establecida como un atributo en un alcance adjunto, o en la l&amp;iacute;nea de comando con el &lt;code&gt;-F&lt;/code&gt; opci&amp;oacute;n -F .</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">Un cheque de pelusa nombra un patr&amp;oacute;n de codificaci&amp;oacute;n potencialmente no deseado, como un c&amp;oacute;digo inalcanzable o documentaci&amp;oacute;n omitida. Los atributos de pelusa &lt;code&gt;allow&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; , &lt;code&gt;deny&lt;/code&gt; y &lt;code&gt;forbid&lt;/code&gt; uso de la sintaxis de &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; para especificar una lista de nombres de pelusa para cambiar el nivel de pelusa de la entidad a la que se aplica el atributo.</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">Una lista de los elementos de idioma externos disponibles est&amp;aacute; disponible en &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="a93ce4eba1c20223d4f7efd374435922dc780a28" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">Una lista que especifica las categorías generales de errores de E/S.</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">Una lista con cada elemento, es decir, &lt;code&gt;[x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">Un literal es una expresi&amp;oacute;n que consta de un solo token, en lugar de una secuencia de tokens, que denota inmediata y directamente el valor que eval&amp;uacute;a, en lugar de referirse a &amp;eacute;l por su nombre o alguna otra regla de evaluaci&amp;oacute;n. Un literal es una forma de&lt;a href=&quot;const_eval#constant-expressions&quot;&gt; expresi&amp;oacute;n constante&lt;/a&gt; , por lo que se eval&amp;uacute;a (principalmente) en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1857afd88875f6678401e5a6388b40ec5e076688" translate="yes" xml:space="preserve">
          <source>A literal value was used inside &lt;code&gt;#[derive]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">Se usó un literal en un atributo incorporado que no soporta los literales.</target>
        </trans-unit>
        <trans-unit id="efa9c544d88ff2ed4857caf7a6d5b87ab71f9e34" translate="yes" xml:space="preserve">
          <source>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the &lt;code&gt;Island&lt;/code&gt; trait, you need to put a doc comment before it, not inside it. Same goes for the &lt;code&gt;lost&lt;/code&gt; method: the doc comment needs to be before it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">Una referencia bloqueada al &lt;code&gt;Stderr&lt;/code&gt; mango .</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">Una referencia cerrada al &lt;code&gt;Stdin&lt;/code&gt; mango .</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">Una referencia bloqueada al &lt;code&gt;Stdout&lt;/code&gt; identificador .</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">Una entrada est&amp;aacute;ndar bloqueada implementa &lt;code&gt;BufRead&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3af527db8725fae95a62589160c6f0f2118456fd" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de bucle puede tener opcionalmente una &lt;em&gt;etiqueta&lt;/em&gt; . La etiqueta est&amp;aacute; escrita como una vida que precede a la expresi&amp;oacute;n de bucle, como en &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; , &lt;code&gt;'bar: while false {}&lt;/code&gt; , &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; . Si hay una etiqueta, entonces las expresiones etiquetadas &lt;code&gt;break&lt;/code&gt; y &lt;code&gt;continue&lt;/code&gt; anidadas dentro de este bucle pueden salir de este bucle o devolver el control a su cabeza. Ver &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;expresiones de ruptura&lt;/a&gt; y &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continuar expresiones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="621a2333164d1c1ddcc3e28445c529a5edcd0f4d" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used inside a closure but outside of any loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49094ffad160345ac5b867a45ab1d0476b39ead" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used outside of a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">Se puede obtener un decodificador con p&amp;eacute;rdida reemplazando &lt;code&gt;Err&lt;/code&gt; resultados de con el car&amp;aacute;cter de reemplazo:</target>
        </trans-unit>
        <trans-unit id="aaa61df7a5c37f0e9baf2b1d7a2af95d48009664" translate="yes" xml:space="preserve">
          <source>A lower range wasn't less than the upper range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">Una macroinvocación ejecuta una macro en tiempo de compilación y reemplaza la invocación con el resultado de la macro.Las macros pueden ser invocadas en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">No se encontró una macro que figurara en la lista de importaciones.</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">Una macro para probar en &lt;em&gt;tiempo&lt;/em&gt; de &lt;em&gt;ejecuci&amp;oacute;n&lt;/em&gt; si una funci&amp;oacute;n de CPU est&amp;aacute; disponible en plataformas x86 / x86-64.</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">Uno de los principales objetivos del compilador es asegurar que una biblioteca nunca aparezca más de una vez en ningún artefacto.Por ejemplo,si las bibliotecas dinámicas B y C estuvieran vinculadas estáticamente a la biblioteca A,entonces una caja no podría vincularse a B y C juntas porque habría dos copias de A.El compilador permite mezclar los formatos rlib y dylib,pero esta restricción debe ser satisfecha.</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">Un mapa basado en un árbol B.</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">Un rasgo marcador que representa los tipos en los que una referencia compartida se considera segura.</target>
        </trans-unit>
        <trans-unit id="3bc97c0d55aa2cae1126bc3f3d83ef27e23658de" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; can be used for a &lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">Un rasgo de marcador para expresar que un &lt;code&gt;ReverseSearcher&lt;/code&gt; se puede usar para un &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementaci&amp;oacute;n de .</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Un rasgo marcador que representa los tipos &quot;seguros contra el pánico&quot; en Rust.</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">Un tipo de marcador que no implementa &lt;code&gt;Unpin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Una medida de un reloj mon&amp;oacute;tonamente no decreciente. Opaco y &amp;uacute;til solo con &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">Una medida del reloj del sistema,útil para hablar con entidades externas como el sistema de archivos u otros procesos.</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">Un asignador de memoria que se puede registrar como predeterminado de la biblioteca est&amp;aacute;ndar a trav&amp;eacute;s de los atributos &lt;code&gt;#[global_allocator]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36390b8dd6062ca0b9666a02db751bef68ddc91f" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default through the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">Una metavariable debe aparecer exactamente en el mismo n&amp;uacute;mero, tipo y orden de anidaci&amp;oacute;n de repeticiones en el transcriptor que en el comparador. Entonces, para el comparador &lt;code&gt;$( $i:ident ),*&lt;/code&gt; , los transcriptores &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; , &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; y &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; son todo ilegal, pero &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; es correcto y reemplaza una lista de identificadores separados por comas por una lista separada por punto y coma.</target>
        </trans-unit>
        <trans-unit id="8b9a4a11c65ef071b5b26c72c1c0d6cc7317036f" translate="yes" xml:space="preserve">
          <source>A method or constant was implemented on a primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">Un método fue llamado en un puntero crudo cuyo tipo interior no se conocía completamente.</target>
        </trans-unit>
        <trans-unit id="da23ec6794439455d8bda2444d9dc191c1a91b2b" translate="yes" xml:space="preserve">
          <source>A method was called on an ambiguous numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6424b2d67ae2d104f32890640da913ac560f8f" translate="yes" xml:space="preserve">
          <source>A method was implemented on a primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83bd54b545ece8364d586c3e7f838baf02e8c65" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">Se aplicó un método cuando se esperaba otro rasgo.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">Un m&amp;oacute;dulo puede importar &lt;code&gt;std::fmt::Write&lt;/code&gt; y &lt;code&gt;std::io::Write&lt;/code&gt; y llamar a &lt;code&gt;write!&lt;/code&gt; en los objetos que implementan cualquiera, ya que los objetos no suelen implementar ambos. Sin embargo, el m&amp;oacute;dulo debe importar los rasgos calificados para que sus nombres no entren en conflicto:</target>
        </trans-unit>
        <trans-unit id="8df0b4f7cbe7a3d63c8935c00a09e49b670eda46" translate="yes" xml:space="preserve">
          <source>A module cannot be found and therefore, the visibility cannot be determined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">Un módulo para trabajar con datos prestados.</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">Un módulo para trabajar con procesos.</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">Un m&amp;oacute;dulo es un contenedor para cero o m&amp;aacute;s &lt;a href=&quot;../items&quot;&gt;elementos.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">Un m&amp;oacute;dulo sin cuerpo se carga desde un archivo externo. Cuando el m&amp;oacute;dulo no tiene un atributo de &lt;code&gt;path&lt;/code&gt; , la ruta al archivo refleja la &lt;a href=&quot;../paths&quot;&gt;ruta del m&amp;oacute;dulo&lt;/a&gt; l&amp;oacute;gico . Los componentes de la ruta del m&amp;oacute;dulo ancestro son directorios y el contenido del m&amp;oacute;dulo est&amp;aacute; en un archivo con el nombre del m&amp;oacute;dulo m&amp;aacute;s la extensi&amp;oacute;n &lt;code&gt;.rs&lt;/code&gt; . Por ejemplo, la siguiente estructura de m&amp;oacute;dulo puede tener esta estructura de sistema de archivos correspondiente:</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">Un ejemplo más complejo:</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">Un patrón más complejo,usando un cierre:</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">Un rust&amp;aacute;ceo m&amp;aacute;s experimentado escribir&amp;iacute;a la firma que se muestra en el Listado 4-9 porque nos permite usar la misma funci&amp;oacute;n en los valores &lt;code&gt;&amp;amp;String&lt;/code&gt; y &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">Un uso m&amp;aacute;s realista de &lt;code&gt;!&lt;/code&gt; est&amp;aacute; en este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="47b3111cf8992e03f361ef35402077d40b862b00" translate="yes" xml:space="preserve">
          <source>A more user-friendly and stable version of this operation is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80c7507fc9ff231be351f8cae94b1cf2dae1652" translate="yes" xml:space="preserve">
          <source>A multi-line (doc-)comment is unterminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">Una unión,referencia o puntero mutable.</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre un &lt;code&gt;BTreeMap&lt;/code&gt; de entradas en un BTreeMap .</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los elementos de una &lt;code&gt;LinkedList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los elementos de un &lt;code&gt;VecDeque&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre las entradas de un &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre las entradas de un &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los valores de un &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los valores de un &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">Una ubicación de memoria mutable con reglas de préstamo comprobadas dinámicamente</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">Una ubicación de memoria mutable.</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">Se puede crear una referencia mutable con &lt;code&gt;&amp;amp;mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa831fb6e4681d63ec9057ce3580c443fec9edb2" translate="yes" xml:space="preserve">
          <source>A mutable reference was used in a constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad0f3cf407381fd22bba2cf586e95f6a6a15615" translate="yes" xml:space="preserve">
          <source>A mutable variable is used but it is already captured by a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ceef8798472360db16ce7d238d9ede4272142f3" translate="yes" xml:space="preserve">
          <source>A mutable variable, reference, or pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">Una exclusión mutua primitiva útil para proteger los datos compartidos</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">Una dirección con nombre:</target>
        </trans-unit>
        <trans-unit id="01a291706f0b443b495b0b8c907121279cbace5d" translate="yes" xml:space="preserve">
          <source>A negative impl was made default impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">Una aplicación negativa es aquella que excluye a un tipo de la aplicación de un rasgo particular.No poder utilizar un rasgo es siempre una operación segura,por lo que las implementaciones negativas son siempre seguras y nunca necesitan ser marcadas como inseguras.</target>
        </trans-unit>
        <trans-unit id="64f76de0f189c143b75250fce4afe6feb8fa06dc" translate="yes" xml:space="preserve">
          <source>A negative implementation was marked as unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">Una nueva tubería debe ser arreglada para conectar los procesos padre e hijo.</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">Se puede configurar un nuevo hilo antes de que se genere a trav&amp;eacute;s de &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; tipo de , que actualmente le permite establecer el nombre y el tama&amp;ntilde;o de la pila para el hilo secundario:</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Se puede &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; un nuevo hilo usando la funci&amp;oacute;n thread :: spawn :</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">Un nodo podr&amp;aacute; hacer referencia a su nodo principal, pero no es propietario de su principal. En el Listado 15-28, actualizamos &lt;code&gt;main&lt;/code&gt; para usar esta nueva definici&amp;oacute;n para que el nodo &lt;code&gt;leaf&lt;/code&gt; tenga una forma de referirse a su &lt;code&gt;branch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d77bcf0653e102d2dc04011199024bd95fbb9db" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;'static&lt;/code&gt; lifetime was used in a const generic. This is currently not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">Se utilizó un valor no constante en una expresión constante.</target>
        </trans-unit>
        <trans-unit id="1eee5bad5b1b537626b09062a59e028d86d55ec2" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">Ya se ha realizado una aplicación no por defecto de este tipo,por lo que no se puede especializar más.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">Un componente no final en la ruta no es un directorio.</target>
        </trans-unit>
        <trans-unit id="c1d61674888a79b8d093da31552849442beb0211" translate="yes" xml:space="preserve">
          <source>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2d2a8d307a0d585bf4d4468aa00fb158ce3e7d" translate="yes" xml:space="preserve">
          <source>A non-mutable value was assigned a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal de cadena de bytes&lt;/em&gt; no sin &lt;em&gt;formato&lt;/em&gt; es una secuencia de caracteres ASCII y &lt;em&gt;escapes&lt;/em&gt; , precedidos por los caracteres &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) y &lt;code&gt;U+0022&lt;/code&gt; (comillas dobles), y seguidos por el car&amp;aacute;cter &lt;code&gt;U+0022&lt;/code&gt; . Si el car&amp;aacute;cter &lt;code&gt;U+0022&lt;/code&gt; est&amp;aacute; presente dentro del literal, debe &lt;em&gt;escaparse&lt;/em&gt; de un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) precedente . Alternativamente, un literal de cadena de bytes puede ser un &lt;em&gt;literal de cadena de bytes sin formato&lt;/em&gt; , definido a continuaci&amp;oacute;n. El tipo de un literal de cadena de bytes de longitud &lt;code&gt;n&lt;/code&gt; es &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">Un módulo sin raíz intenta importar macros de otra caja.</target>
        </trans-unit>
        <trans-unit id="0f7f88934a0864a48a1aa3e075daab332c8783a0" translate="yes" xml:space="preserve">
          <source>A non-root module tried to import macros from another crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ccf07b47b66963a7e3e32486b9dba6e199bf07" translate="yes" xml:space="preserve">
          <source>A non-structural-match type was used as the type of a const generic parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">Se solicitó una interfaz inexistente o la dirección solicitada no era local.</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">Un componente normal, por ejemplo, &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; en &lt;code&gt;a/b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">Una nota sobre los tipos de tama&amp;ntilde;o cero y los dise&amp;ntilde;os de tama&amp;ntilde;o cero: muchos m&amp;eacute;todos en el rasgo &lt;code&gt;Alloc&lt;/code&gt; establecen que las solicitudes de asignaci&amp;oacute;n deben tener un tama&amp;ntilde;o distinto de cero, o de lo contrario puede resultar un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="d70ff5d8ac6ec719cfc0758b679c32b46a7a0fdd" translate="yes" xml:space="preserve">
          <source>A null &lt;code&gt;fn&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd524388dc48721a46df11a0e678684cddc1ff5" translate="yes" xml:space="preserve">
          <source>A number in a non-decimal base has no digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">Pánico al desbordarse:</target>
        </trans-unit>
        <trans-unit id="7e451dc65737a3d0078f0a0cdca0352afd247852" translate="yes" xml:space="preserve">
          <source>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17681e220340a047c028939b5c9a6007c707423" translate="yes" xml:space="preserve">
          <source>A parameter type is missing an explicit lifetime bound and may not live long enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">Un parámetro era incorrecto.</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">No existe un padre de la ruta dada. (Para crear un directorio y todos sus padres faltantes al mismo tiempo, use la funci&amp;oacute;n &lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">Una instancia particular de &lt;code&gt;RandomState&lt;/code&gt; crear&amp;aacute; las mismas instancias de &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; , pero es poco probable que los hashers creados por dos instancias de &lt;code&gt;RandomState&lt;/code&gt; diferentes produzcan el mismo resultado para los mismos valores.</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">Un patr&amp;oacute;n en particular &lt;code&gt;_&lt;/code&gt; coincidir&amp;aacute; con cualquier cosa, pero nunca se une a una variable, por lo que a menudo se usa en el &amp;uacute;ltimo brazo de coincidencia. El patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; puede resultar &amp;uacute;til cuando desee ignorar cualquier valor no especificado, por ejemplo. Cubriremos el patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; con m&amp;aacute;s detalle en la secci&amp;oacute;n &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&quot;Ignorar valores en un patr&amp;oacute;n&quot;&lt;/a&gt; m&amp;aacute;s adelante en este cap&amp;iacute;tulo.</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">Un camino puede tomar dos formas:</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">Un patr&amp;oacute;n a &lt;code&gt;..=&lt;/code&gt; b siempre debe tener a &amp;le; b. Es un error tener un patr&amp;oacute;n de rango &lt;code&gt;10..=0&lt;/code&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="891da3d988f6fc5238b5b4fb583d072b5a0287dc" translate="yes" xml:space="preserve">
          <source>A pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6b7416ed8a3ba7b4dcdc0423f76b297ea15288" translate="yes" xml:space="preserve">
          <source>A pattern binding is using the same name as one of the variants of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b95bece3c7641fd29f13b871ae1a3d402281d9" translate="yes" xml:space="preserve">
          <source>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3ec235405c966e5db61078265ddd06c38fdf87" translate="yes" xml:space="preserve">
          <source>A pattern guard may refer to the variables bound within the pattern they follow. Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">Se dice que un patr&amp;oacute;n es &lt;em&gt;refutable&lt;/em&gt; cuando tiene la posibilidad de no coincidir con el valor con el que se compara. &lt;em&gt;Los&lt;/em&gt; patrones &lt;em&gt;irrefutables&lt;/em&gt; , por otro lado, siempre coinciden con el valor con el que se comparan. Ejemplos:</target>
        </trans-unit>
        <trans-unit id="50718096ba0e9d977821568bde4dc051a6527468" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">Un patrón utilizado para cotejar con una variante del enum debe proporcionar un subpatrón para cada campo de la variante del enum.Este error indica que un patrón intentó extraer un número incorrecto de campos de una variante.</target>
        </trans-unit>
        <trans-unit id="27a0056206e19a4b052630f19a00fbd4710c685a" translate="yes" xml:space="preserve">
          <source>A pattern was declared as an argument in a foreign function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">Un puntero de alfiler.</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">Un lugar que es válido para la duración de un programa.</target>
        </trans-unit>
        <trans-unit id="7d0a1c9d0822781050522c413844b46b3f9e19ec" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">Se declaró un plugin/caja pero no se puede encontrar.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="2db11183c5e69392e41fbe166caeebf1df741e85" translate="yes" xml:space="preserve">
          <source>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">Un tipo de puntero para la asignación de la pila.</target>
        </trans-unit>
        <trans-unit id="068b4756f4660015d453841abd0c47d397debbf3" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">Una &lt;code&gt;Once&lt;/code&gt; envenenada :</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">Sin embargo, un mutex envenenado no evita todo el acceso a los datos subyacentes. El tipo &lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; &lt;/a&gt; tiene un m&amp;eacute;todo &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; &lt;/a&gt; que devolver&amp;aacute; la protecci&amp;oacute;n que de otro modo se hubiera devuelto en un bloqueo exitoso. Esto permite el acceso a los datos, a pesar de que la cerradura est&amp;eacute; envenenada.</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">Un posible valor de error al convertir una &lt;code&gt;String&lt;/code&gt; de un segmento de bytes UTF-16.</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">Un posible valor de error al convertir una &lt;code&gt;String&lt;/code&gt; de un vector de bytes UTF-8.</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">Un preludio para escribir convenientemente el código específico de la plataforma.</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">Una cola de prioridad implementada con un montón de binarios.</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">Un objeto privado fue usado fuera de su alcance.</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">Un artículo privado fue usado fuera de su alcance.</target>
        </trans-unit>
        <trans-unit id="b050bad5b423d40a7cbc2510e0a714043fcaa01a" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">Se utilizó un rasgo privado en un parámetro de tipo público limitado.Ejemplos de códigos erróneos:</target>
        </trans-unit>
        <trans-unit id="9a0df3af8cfe7414b96a23dc7a41a25700bb086e" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">Se utilizó un tipo privado en una firma de tipo público.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">Un constructor de procesos,que proporciona un control de grano fino sobre la forma en que un nuevo proceso debe ser engendrado.</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">Un rápido repaso sobre el ordenamiento de la memoria:</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">Un número aleatorio que generará cierta variedad en los planes de entrenamiento</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">Un rango limitado inclusive por debajo y por encima ( &lt;code&gt;start..=end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">Un rango solo limitado exclusivamente por encima ( &lt;code&gt;..end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">Un rango solo delimitado inclusive arriba ( &lt;code&gt;..=end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">Un rango solo delimitado inclusive por debajo de ( &lt;code&gt;start..&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">Un identificador en bruto es como un identificador normal, pero con el prefijo &lt;code&gt;r#&lt;/code&gt; . (Tenga en cuenta que el prefijo &lt;code&gt;r#&lt;/code&gt; no se incluye como parte del identificador real). A diferencia de un identificador normal, un identificador en bruto puede ser cualquier palabra clave estricta o reservada, excepto las enumeradas anteriormente para &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">Un tipo de puntero crudo que puede ser compartido con seguridad entre los hilos.</target>
        </trans-unit>
        <trans-unit id="f1f955686d561bc8208f2ce3b12ca99c3765110a" translate="yes" xml:space="preserve">
          <source>A raw string isn't correctly terminated because the trailing &lt;code&gt;#&lt;/code&gt; count doesn't match its leading &lt;code&gt;#&lt;/code&gt; count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">Un lector que siempre está en EOF.</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">Un lector que produce un byte una y otra vez y otra y otra y otra y otra...</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">Un bloqueo de lector-escritor</target>
        </trans-unit>
        <trans-unit id="2d89d8dfb8b1c58f5d841e5165fcf975a6c55e6a" translate="yes" xml:space="preserve">
          <source>A recursive type has infinite size because it doesn't have an indirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">Una referencia tiene una vida útil más larga que los datos a los que hace referencia.</target>
        </trans-unit>
        <trans-unit id="8299c0d135b8f5441cc8858d8675b0fc5f91fcc2" translate="yes" xml:space="preserve">
          <source>A reference or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that is dangling, unaligned, or points to an invalid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">Una referencia representa un pr&amp;eacute;stamo de alg&amp;uacute;n valor propio. Puede obtener uno usando los operadores &lt;code&gt;&amp;amp;&lt;/code&gt; o &lt;code&gt;&amp;amp;mut&lt;/code&gt; en un valor, o usando un patr&amp;oacute;n &lt;code&gt;ref&lt;/code&gt; o &lt;code&gt;ref mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def229fac786a814e540383a36be7448c81c2810" translate="yes" xml:space="preserve">
          <source>A reference to a local variable was returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">Una referencia a un archivo abierto en el sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Una referencia al directorio actual, es decir, &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">Una referencia al directorio padre, es decir, &lt;code&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b305ff2e1e8a128729de5a06db133ccf46d493cc" translate="yes" xml:space="preserve">
          <source>A reference/pointer is &quot;dangling&quot; if it is null or not all of the bytes it points to are part of the same allocation (so in particular they all have to be part of &lt;em&gt;some&lt;/em&gt; allocation). The span of bytes it points to is determined by the pointer value and the size of the pointee type (using &lt;code&gt;size_of_val&lt;/code&gt;). As a consequence, if the span is empty, &quot;dangling&quot; is the same as &quot;non-null&quot;. Note that slices and strings point to their entire range, so it is important that the length metadata is never too large. In particular, allocations and therefore slices and strings cannot be bigger than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">Un número regular de punto flotante.</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">Una referencia regular es un tipo de puntero, y una forma de pensar en un puntero es como una flecha a un valor almacenado en otro lugar. En el Listado 15-6, creamos una referencia a un valor &lt;code&gt;i32&lt;/code&gt; y luego usamos el operador de desreferencia para seguir la referencia a los datos:</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">Un concepto relacionado es el alcance: el contexto anidado en el que se escribe el c&amp;oacute;digo tiene un conjunto de nombres que se definen como &quot;dentro del alcance&quot;. Al leer, escribir y compilar c&amp;oacute;digo, los programadores y compiladores necesitan saber si un nombre particular en un lugar particular se refiere a una variable, funci&amp;oacute;n, estructura, enumeraci&amp;oacute;n, m&amp;oacute;dulo, constante u otro elemento y qu&amp;eacute; significa ese elemento. Puede crear &amp;aacute;mbitos y cambiar los nombres que est&amp;aacute;n dentro o fuera del &amp;aacute;mbito. No puede tener dos elementos con el mismo nombre en el mismo &amp;aacute;mbito; Hay herramientas disponibles para resolver conflictos de nombres.</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n repetida &lt;code&gt;[x; N]&lt;/code&gt; , que produce una matriz con &lt;code&gt;N&lt;/code&gt; copias de &lt;code&gt;x&lt;/code&gt; . El tipo de &lt;code&gt;x&lt;/code&gt; debe ser &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3238c87767b981c84fc407d2a6b89dd0a8979fcd" translate="yes" xml:space="preserve">
          <source>A restriction is imposed on the shebang syntax to avoid confusion with an &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;. The &lt;code&gt;#!&lt;/code&gt; characters must not be followed by a &lt;code&gt;[&lt;/code&gt; token, ignoring intervening &lt;a href=&quot;comments&quot;&gt;comments&lt;/a&gt; or &lt;a href=&quot;whitespace&quot;&gt;whitespace&lt;/a&gt;. If this restriction fails, then it is not treated as a shebang, but instead as the start of an attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">Se encontró una declaración de retorno fuera de un cuerpo funcional.</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">Un buscador inverso para un patrón de cadenas.</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">Un escrutinio es la expresi&amp;oacute;n que coincide en expresiones de &lt;code&gt;match&lt;/code&gt; y construcciones de coincidencia de patrones similares. Por ejemplo, en la &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; es el escrutinio.</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">Un buscador de un patrón de cuerda.</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">Se permite una búsqueda más allá del final de un arroyo,pero el comportamiento se define por la implementación.</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">Un conjunto basado en un árbol B.</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">Un error similar es E0201. La diferencia es si hay un bloque de declaraci&amp;oacute;n o no. Para evitar este error, debe &lt;code&gt;fn&lt;/code&gt; cada fn un nombre exclusivo.</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">Existe una regla similar para combinar referencias mutables e inmutables.Este código da como resultado un error:</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">Un simple ejemplo:</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">Una funci&amp;oacute;n simple que devuelve el &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; podr&amp;iacute;a definirse y usarse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">Un simple giro:</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">Una solución simple es usar un método de ayuda en su lugar:</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">Un simple envoltorio alrededor de un tipo para afirmar que es seguro para desenvolverse.</target>
        </trans-unit>
        <trans-unit id="b53617da96fc2eac5eec0b6bb0e92f32c47fc76e" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un solo hilo (arbitrario) recibir&amp;aacute; un &lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt; que devuelve &lt;code&gt;true&lt;/code&gt; de &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; al regresar de esta funci&amp;oacute;n, y todos los dem&amp;aacute;s hilos recibir&amp;aacute;n un resultado que devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; de &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">Un solo &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; puede codificarse como m&amp;aacute;s de un byte. Este m&amp;eacute;todo solo puede tener &amp;eacute;xito si la secuencia de bytes completa se escribi&amp;oacute; correctamente y este m&amp;eacute;todo no regresar&amp;aacute; hasta que se hayan escrito todos los datos o se haya producido un error.</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">Un solo &lt;em&gt;literal decimal&lt;/em&gt; seguido de un &lt;em&gt;exponente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">Un solo componente de un camino.</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">Un puntero contador de referencias de un solo hilo.Rc' significa 'Referencia Contada'.</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">Una rebanada es un &lt;a href=&quot;../dynamically-sized-types&quot;&gt;tipo din&amp;aacute;micamente tama&amp;ntilde;o&lt;/a&gt; que representa una 'vista' en una secuencia de elementos de tipo &lt;code&gt;T&lt;/code&gt; . El tipo de rebanada se escribe como &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">Un sector es una vista de tama&amp;ntilde;o din&amp;aacute;mico en una secuencia contigua, escrita como &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Un trozo de un camino (similar a &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2759e6b662ba691ba47b65069c920c9b980fcd79" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">Un ejemplo un poco triste de no leer nada en un buffer:</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">La dirección de un enchufe no se puede vincular porque la dirección ya se utiliza en otro lugar.</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">Una consecuencia algo sorprendente de la definici&amp;oacute;n es que &lt;code&gt;&amp;amp;mut T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; (si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; ) aunque parece que eso podr&amp;iacute;a proporcionar una mutaci&amp;oacute;n no sincronizada. El truco es que una referencia mutable detr&amp;aacute;s de una referencia com&amp;uacute;n (es decir, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; ) se convierte de s&amp;oacute;lo lectura, como si se tratara de un &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; . Por tanto, no hay riesgo de una carrera de datos.</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">Un archivo fuente puede tener un &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (producci&amp;oacute;n SHEBANG), que indica al sistema operativo qu&amp;eacute; programa utilizar para ejecutar este archivo. B&amp;aacute;sicamente, sirve para tratar el archivo fuente como un script ejecutable. El shebang solo puede ocurrir al principio del archivo (pero despu&amp;eacute;s del &lt;em&gt;UTF8BOM&lt;/em&gt; opcional ). El compilador lo ignora. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5ec62fb18603ebc6519f469782df4169fc5a681f" translate="yes" xml:space="preserve">
          <source>A source stage in an iterator pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">Un tipo de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; especializado para operaciones de E / S.</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">Un tipo de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; especializado para subprocesos.</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">Un iterador de empalme para &lt;code&gt;Vec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="382d455769d00569a95a026174c2cb511f9bbb7a" translate="yes" xml:space="preserve">
          <source>A stability attribute has been used outside of the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6a5b448820983a6050fcd10b6c3d4dd333f376" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">Se utilizó un atributo de estabilidad fuera de la biblioteca estándar.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">Una declaración es el elemento autónomo más pequeño de un lenguaje de programación que ordena a un ordenador realizar una acción.</target>
        </trans-unit>
        <trans-unit id="7993655a3c3f53e3aa0f9baecc01e8b1f97ae73b" translate="yes" xml:space="preserve">
          <source>A statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d137e324ac57303f829812294caa15b53500d48e" translate="yes" xml:space="preserve">
          <source>A static item is a value which is valid for the entire duration of your program (a &lt;code&gt;'static&lt;/code&gt; lifetime).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1525834046325d03a0ffcca63064524577af3217" translate="yes" xml:space="preserve">
          <source>A string (&lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">Una cadena que describe la arquitectura de la CPU que está actualmente en uso.</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">Cadena que describe el sistema operativo espec&amp;iacute;fico en uso. El valor de ejemplo es &lt;code&gt;linux&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">Una cadena es una secuencia de bytes. 'Izquierda' en este contexto significa la primera posici&amp;oacute;n de esa cadena de bytes; para un idioma como el &amp;aacute;rabe o el hebreo que son &quot;de derecha a izquierda&quot; en lugar de &quot;de izquierda a derecha&quot;, este ser&amp;aacute; el lado &lt;em&gt;derecho&lt;/em&gt; , no el izquierdo.</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">Una cadena es una secuencia de bytes. 'Derecha' en este contexto significa la &amp;uacute;ltima posici&amp;oacute;n de esa cadena de bytes; para un idioma como el &amp;aacute;rabe o el hebreo que son 'de derecha a izquierda' en lugar de 'de izquierda a derecha', este ser&amp;aacute; el lado &lt;em&gt;izquierdo&lt;/em&gt; , no el derecho.</target>
        </trans-unit>
        <trans-unit id="a7d73837e1ae6f385cc7b12b321574d70650bd43" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">Una cadena es una secuencia de bytes. &lt;code&gt;end&lt;/code&gt; en este contexto significa la &amp;uacute;ltima posici&amp;oacute;n de esa cadena de bytes; para un idioma de izquierda a derecha como ingl&amp;eacute;s o ruso, este ser&amp;aacute; el lado derecho, y para idiomas de derecha a izquierda como &amp;aacute;rabe o hebreo, este ser&amp;aacute; el lado izquierdo.</target>
        </trans-unit>
        <trans-unit id="8add450b8d835c6c86dcce6d9f4412fe207173ed" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">Una cadena es una secuencia de bytes. &lt;code&gt;start&lt;/code&gt; en este contexto significa la primera posici&amp;oacute;n de esa cadena de bytes; para un idioma de izquierda a derecha como ingl&amp;eacute;s o ruso, este ser&amp;aacute; el lado izquierdo, y para idiomas de derecha a izquierda como &amp;aacute;rabe o hebreo, este ser&amp;aacute; el lado derecho.</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">Un literal de cadena es una cadena almacenada directamente en el binario final, por lo que ser&amp;aacute; v&amp;aacute;lida durante la &lt;code&gt;'static&lt;/code&gt; duraci&amp;oacute;n est&amp;aacute;tica' .</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">Un patrón de cuerda.</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">Un segmento de cadena ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; formado por bytes ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; ) y un segmento de bytes ( &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; compuesto por bytes, por lo que esta funci&amp;oacute;n convierte entre los dos. Sin embargo, no todos los segmentos de bytes son segmentos de cadena v&amp;aacute;lidos: &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; requiere que sea UTF-8 v&amp;aacute;lido. &lt;code&gt;from_utf8()&lt;/code&gt; comprueba que los bytes sean UTF-8 v&amp;aacute;lidos y luego realiza la conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">Un segmento de cadena ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; formado por bytes ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; ) y un vector de bytes ( &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; formado por bytes, por lo que esta funci&amp;oacute;n convierte entre los dos. Sin embargo, no todos los segmentos de bytes son &lt;code&gt;String&lt;/code&gt; s v&amp;aacute;lidos : &lt;code&gt;String&lt;/code&gt; requiere que sea UTF-8 v&amp;aacute;lido. &lt;code&gt;from_utf8()&lt;/code&gt; comprueba que los bytes sean UTF-8 v&amp;aacute;lidos y luego realiza la conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">Un segmento de cadena es el tipo de cadena m&amp;aacute;s primitivo en Rust, escrito como &lt;code&gt;str&lt;/code&gt; . A menudo se ve en sus formas prestadas, ya sea mutable o compartida. El tipo de segmento de cadena compartida es &lt;code&gt;&amp;amp;str&lt;/code&gt; , mientras que el tipo de segmento de cadena mutable es &lt;code&gt;&amp;amp;mut str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">Una estructura puede ser &lt;code&gt;Copy&lt;/code&gt; e &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; es &lt;code&gt;Copy&lt;/code&gt; , por lo tanto, &lt;code&gt;Point&lt;/code&gt; es elegible para ser &lt;code&gt;Copy&lt;/code&gt; . Por el contrario, considere</target>
        </trans-unit>
        <trans-unit id="eb9b96b59ca1189f15dc2a933aeadc425813dff3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">Se invocó a un constructor de estructuras con campos privados.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">Una estructura que contiene información sobre la ubicación de un pánico.</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">Una expresi&amp;oacute;n de estructura puede terminar con la sintaxis &lt;code&gt;..&lt;/code&gt; seguida de una expresi&amp;oacute;n para denotar una actualizaci&amp;oacute;n funcional. La expresi&amp;oacute;n que sigue a &lt;code&gt;..&lt;/code&gt; (la base) debe tener el mismo tipo de estructura que el nuevo tipo de estructura que se est&amp;aacute; formando.</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">Una expresión de estructura con campos encerrados en llaves rizadas permite especificar el valor de cada campo individual en cualquier orden.El nombre del campo se separa de su valor con dos puntos.</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">Una expresi&amp;oacute;n de estructura con campos entre par&amp;eacute;ntesis construye una estructura de tupla. Aunque aparece aqu&amp;iacute; como una expresi&amp;oacute;n espec&amp;iacute;fica para completar, es equivalente a una &lt;a href=&quot;call-expr&quot;&gt;expresi&amp;oacute;n de llamada&lt;/a&gt; al constructor de la estructura de tupla. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4a5683978535ef36d2f4a36fc97769f59882d764" translate="yes" xml:space="preserve">
          <source>A struct pattern attempted to extract a non-existent field from a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">Un patrón de estructura es refutable cuando uno de sus subpatrones es refutable.</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">Una estructura que proporciona información sobre el pánico.</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">Una estructura para ayudar con las implementaciones de &lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="878d9a84ea5b4c1dd0e00cf0901eb339704e2d00" translate="yes" xml:space="preserve">
          <source>A struct was declared with two fields having the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">Una estructura con un solo campo al que se puede acceder derivando la estructura.</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">Una estructura con un solo campo que es modificable al desreferenciar la estructura.</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">Una estructura con m&amp;aacute;s de un campo que contiene un tipo sin &lt;code&gt;CoerceUnsized&lt;/code&gt; no puede implementar CoerceUnsized . Esto solo ocurre cuando intenta forzar uno de los tipos en su estructura a otro tipo en la estructura. En este caso, intentamos &lt;code&gt;CoerceUnsized&lt;/code&gt; de &lt;code&gt;T&lt;/code&gt; a &lt;code&gt;U&lt;/code&gt; , que son los dos tipos que toma la estructura. Un &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;tipo sin tama&amp;ntilde;o&lt;/a&gt; es cualquier tipo del que el compilador no conoce la longitud o la alineaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n. Cualquier estructura que contenga un tipo sin tama&amp;ntilde;o tampoco tiene tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">Una estructura con la sugerencia de representaci&amp;oacute;n &lt;code&gt;repr(transparent)&lt;/code&gt; ten&amp;iacute;a cero o m&amp;aacute;s de un campo que no estaba garantizado para ser de tama&amp;ntilde;o cero.</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">Una estructura sin un campo que contenga un tipo sin &lt;code&gt;CoerceUnsized&lt;/code&gt; no puede implementar CoerceUnsized . Un &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;tipo sin tama&amp;ntilde;o&lt;/a&gt; es cualquier tipo del que el compilador no conoce la longitud o la alineaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n. Cualquier estructura que contenga un tipo sin tama&amp;ntilde;o tampoco tiene tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="bfe3d05f336ffd910d212738048395d48df402c2" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcfe0f822e1b5462565a584546dacf4f3c36744" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was specified more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">Una estructura, enumeraci&amp;oacute;n o uni&amp;oacute;n con la sugerencia de representaci&amp;oacute;n &lt;code&gt;repr(transparent)&lt;/code&gt; contiene un campo de tama&amp;ntilde;o cero que requiere una alineaci&amp;oacute;n no trivial.</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">Una estructura que representa un servidor de sockets de dominio Unix.</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Una estructura que representa un tipo de archivo con descriptores de acceso para cada tipo de archivo. Es devuelto por el m&amp;eacute;todo &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">Una estructura que envuelve un prefijo de ruta de Windows así como su representación de cadena sin par.</target>
        </trans-unit>
        <trans-unit id="a18cd960fc14986c70aa975cf92200531a20ff48" translate="yes" xml:space="preserve">
          <source>A structure-literal syntax was used to create an item that is not a structure or enum variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450ed556ad629fd6ee6dd398c15074a8c129be66" translate="yes" xml:space="preserve">
          <source>A successful conversion will produce the same result as &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; when called without the ending nul byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un env&amp;iacute;o exitoso ocurre cuando se determina que el otro extremo del canal a&amp;uacute;n no ha colgado. Un env&amp;iacute;o fallido ser&amp;iacute;a uno en el que el receptor correspondiente ya ha sido desasignado. Tenga en cuenta que un valor de retorno de &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; medios que nunca ser&amp;aacute;n recibidos los datos, pero un valor de retorno de &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; no &lt;em&gt;, no&lt;/em&gt; significa que se recibir&amp;aacute;n los datos. Es posible que el receptor correspondiente cuelgue inmediatamente despu&amp;eacute;s de que esta funci&amp;oacute;n devuelva &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">Un sufijo es un identificador no binario que sigue inmediatamente (sin espacio en blanco)a la parte primaria de un literal.</target>
        </trans-unit>
        <trans-unit id="01225be668ae4fcd869b26b266eae668b00e87f5" translate="yes" xml:space="preserve">
          <source>A super trait has been added to an auto trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd1d7403a3a0b004c92da849e81f0a2dc9aaf82" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">Una primitiva de sincronizaci&amp;oacute;n que se puede utilizar para ejecutar una inicializaci&amp;oacute;n global &amp;uacute;nica. &amp;Uacute;til para la inicializaci&amp;oacute;n &amp;uacute;nica de FFI o funciones relacionadas. Este tipo solo se puede construir con el valor &lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt; o el equivalente &lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt; constructor.</target>
        </trans-unit>
        <trans-unit id="7ae033712f05c69a86c1b61d9806f301efbdf2ee" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be written to only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">Un canal sincr&amp;oacute;nico y limitado. La funci&amp;oacute;n &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; una &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; donde el almacenamiento de los mensajes pendientes es un b&amp;uacute;fer preasignado de un tama&amp;ntilde;o fijo. Todos los env&amp;iacute;os ser&amp;aacute;n &lt;strong&gt;sincr&amp;oacute;nicos&lt;/strong&gt; bloqueando hasta que haya espacio de b&amp;uacute;fer disponible. Tenga en cuenta que se permite un l&amp;iacute;mite de 0, lo que hace que el canal se convierta en un canal de &quot;encuentro&quot; en el que cada remitente entrega at&amp;oacute;micamente un mensaje a un receptor.</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">Una producción sintáctica</target>
        </trans-unit>
        <trans-unit id="a737498d76fd77a9ff17becf5c122eff8eaa0e65" translate="yes" xml:space="preserve">
          <source>A temporary value is being dropped while a borrow is still in active use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">Un hilo tambi&amp;eacute;n puede devolver un valor a trav&amp;eacute;s de su &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; , puede usar esto para realizar c&amp;aacute;lculos asincr&amp;oacute;nicos (aunque los futuros pueden ser m&amp;aacute;s apropiados).</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">Una clave de almacenamiento local de hilo que es dueña de su contenido.</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">Se considera que un hilo que se completa sin pánico sale con éxito.</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">Una clave local de subproceso posee el valor que contiene y destruir&amp;aacute; el valor cuando el subproceso salga. &amp;iexcl;Se crea con &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;macro y puede contener cualquier valor que sea &lt;code&gt;'static&lt;/code&gt; (sin punteros prestados). Proporciona una funci&amp;oacute;n de acceso, &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; , que produce una referencia compartida al valor del cierre especificado. Las claves locales de subprocesos solo permiten el acceso compartido a los valores, ya que no habr&amp;iacute;a forma de garantizar la unicidad si se permitieran los pr&amp;eacute;stamos mutables. La mayor&amp;iacute;a de los valores querr&amp;aacute;n hacer uso de alguna forma de &lt;strong&gt;mutabilidad interior a&lt;/strong&gt; trav&amp;eacute;s de los tipos &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">Un puntero contador de referencias seguro.&quot;Arco&quot; significa &quot;Referencia atómica contada&quot;.</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">Una ficha producida por el lexer</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">Una barra final se normaliza de distancia, &lt;code&gt;/a/b&lt;/code&gt; y &lt;code&gt;/a/b/&lt;/code&gt; son equivalentes.</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">&amp;iquest;Un rasgo vinculado a &lt;code&gt;?Sized&lt;/code&gt; es lo opuesto a un rasgo vinculado a &lt;code&gt;Sized&lt;/code&gt; : leer&amp;iacute;amos esto como &quot; &lt;code&gt;T&lt;/code&gt; puede o no puede ser &lt;code&gt;Sized&lt;/code&gt; &quot;. Esta sintaxis solo est&amp;aacute; disponible para &lt;code&gt;Sized&lt;/code&gt; , no para otros rasgos.</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">Un rasgo puede tener múltiples métodos en su cuerpo:las firmas de los métodos se enumeran una por línea y cada línea termina en un punto y coma.</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">Un rasgo para tomar prestado los datos.</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Un rasgo para convertir un valor en una &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un rasgo para crear instancias de &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">&amp;iquest;Un rasgo para personalizar el comportamiento del &lt;code&gt;?&lt;/code&gt; operador.</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">Un rasgo para dar a un tipo un valor por defecto útil.</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">Un rasgo para la obtención de un flujo arbitrario de bytes.</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">Un rasgo para implementar tipos de retorno arbitrarios en la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">Un rasgo para tomar datos prestados mutablemente.</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">Un rasgo para los objetos que son fregaderos orientados a los bytes.</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">Un rasgo de los objetos que se pueden convertir o resolver en uno o m&amp;aacute;s valores &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20da43414d9faf5772a30fd6329b8b6d3aa3e3b4" translate="yes" xml:space="preserve">
          <source>A trait for writing or formatting into Unicode-accepting buffers or streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23adce518b9b9c7fb3e196dc3fd75bab1e5f0059" translate="yes" xml:space="preserve">
          <source>A trait implementation has stricter requirements than the trait definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">La aplicación de un rasgo se considera incoherente si falla el control de huérfanos o si hay instancias de aplicación que se superponen.</target>
        </trans-unit>
        <trans-unit id="a4884230017ffb802f52c6721c470c8593e7fcd5" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="translated">La implementación de un rasgo debe definir todos los elementos asociados no predeterminados declarados por el rasgo implementado,puede redefinir los elementos asociados predeterminados definidos por el rasgo implementado y no puede definir ningún otro elemento.</target>
        </trans-unit>
        <trans-unit id="d0010f4426c0d6cbe2dc68d818b29e968be48db6" translate="yes" xml:space="preserve">
          <source>A trait implementation was marked as unsafe while the trait is safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">Un rasgo es un elemento del lenguaje que se utiliza para describir las funcionalidades que un tipo debe proporcionar.Permite a un tipo hacer ciertas promesas sobre su comportamiento.</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">Se puede implementar un rasgo para &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; en la misma caja que &lt;code&gt;T&lt;/code&gt; , que las &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;reglas hu&amp;eacute;rfanas&lt;/a&gt; impiden para otros tipos gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="1b745de10511ea796795a51c79ea5a4b196da151" translate="yes" xml:space="preserve">
          <source>A trait method was declared const.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">Un objeto de rasgo se define sobre un rasgo &amp;uacute;nico y completamente definido. Con un par&amp;aacute;metro predeterminado regular, este par&amp;aacute;metro puede simplemente sustituirse. Sin embargo, si el par&amp;aacute;metro predeterminado es &lt;code&gt;Self&lt;/code&gt; , el rasgo cambia para cada tipo de concreto; es decir, &lt;code&gt;i32&lt;/code&gt; se esperar&amp;aacute; para implementar &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; se espera para implementar &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; , etc ... Estos tipos no compartir&amp;aacute;n la implementaci&amp;oacute;n de un rasgo completamente definido; en cambio, comparten implementaciones de un rasgo con diferentes par&amp;aacute;metros sustituidos para cada implementaci&amp;oacute;n. Esto es irreconciliable con lo que necesitamos para hacer que un objeto de rasgo funcione y, por lo tanto, no est&amp;aacute; permitido. Hacer que el rasgo sea concreto especificando expl&amp;iacute;citamente el valor del par&amp;aacute;metro predeterminado solucionar&amp;aacute; este problema. Ejemplo fijo:</target>
        </trans-unit>
        <trans-unit id="09ed217e59efc6a63ebd08cd2d7fd8370e33eb53" translate="yes" xml:space="preserve">
          <source>A trait object was declared with no traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16935dd0c42b10d2b4960eb5cbdc15bbae87c965" translate="yes" xml:space="preserve">
          <source>A trait to emulate dynamic typing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">Un rasgo que expresa la capacidad de construir un objeto a partir de un descriptor de archivos en bruto.</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">Un rasgo para expresar la capacidad de consumir un objeto y adquirir la propiedad de su &lt;code&gt;HANDLE&lt;/code&gt; bruto .</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">Un rasgo para expresar la capacidad de consumir un objeto y adquirir la propiedad de su &lt;code&gt;SOCKET&lt;/code&gt; en bruto .</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">Un rasgo que expresa la capacidad de consumir un objeto y adquirir la propiedad de su descriptor de archivo en bruto.</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">Un rasgo para extraer el descriptor de archivos unix en bruto de un objeto subyacente.</target>
        </trans-unit>
        <trans-unit id="74dfee4318a470e1c8aa720bcf48b06f65b677a2" translate="yes" xml:space="preserve">
          <source>A trait type has been dereferenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b4acf36ca74c434adb6226f16d93f351b2c3d1" translate="yes" xml:space="preserve">
          <source>A trait was implemented on another which already automatically implemented it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">Se supone que una estructura, enumeraci&amp;oacute;n o uni&amp;oacute;n transparente se representa exactamente como la pieza de datos que contiene. Los campos de tama&amp;ntilde;o cero con diferentes requisitos de alineaci&amp;oacute;n pueden entrar en conflicto con esta propiedad. En el ejemplo anterior, &lt;code&gt;Wrapper&lt;/code&gt; tendr&amp;iacute;a que alinearse a 32 bytes aunque &lt;code&gt;f32&lt;/code&gt; tiene un requisito de alineaci&amp;oacute;n menor.</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">Un ejemplo difícil,con la sigma:</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">Un ejemplo trivial del uso de &lt;code&gt;bool&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">Un &lt;em&gt;tipo de&lt;/em&gt; tupla es un producto heterog&amp;eacute;neo de otros tipos, llamados &lt;em&gt;elementos&lt;/em&gt; de la tupla. No tiene un nombre nominal y en su lugar est&amp;aacute; escrito estructuralmente.</target>
        </trans-unit>
        <trans-unit id="e9dbb3e94f53ac8e3a8ca087dfd88ec94acc48f5" translate="yes" xml:space="preserve">
          <source>A tuple index is used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt;, and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0541e4cbc97c5e40f947c03ae1731aeaba596f" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">Una tupla es una forma general de agrupar algunos otros valores con una variedad de tipos en un tipo compuesto.Las tuplas tienen una longitud fija:una vez declaradas,no pueden crecer o reducirse en tamaño.</target>
        </trans-unit>
        <trans-unit id="8d3a96e70924f2a82e85cf6036b452ac805c64ec" translate="yes" xml:space="preserve">
          <source>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">Un patrón de estructura tuple es refutable cuando uno de sus subpatrones es refutable.</target>
        </trans-unit>
        <trans-unit id="8f5d8407de99f6165aaf419c7f8aaf0ecf33a5a2" translate="yes" xml:space="preserve">
          <source>A tuple struct's element isn't a machine type when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c229f3f830c234653affc74d3c7117a6730da6" translate="yes" xml:space="preserve">
          <source>A type alias for &lt;a href=&quot;../convert/enum.infallible&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">Un tipo de alias para el resultado de un método de bloqueo que puede ser envenenado.</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">Un tipo de alias para el resultado de un método de bloqueo sin bloqueo.</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">Un alias de tipo hace que este c&amp;oacute;digo sea m&amp;aacute;s manejable al reducir la repetici&amp;oacute;n. En el Listado 19-25, hemos introducido un alias llamado &lt;code&gt;Thunk&lt;/code&gt; para el tipo detallado y podemos reemplazar todos los usos del tipo con el alias &lt;code&gt;Thunk&lt;/code&gt; m&amp;aacute;s corto .</target>
        </trans-unit>
        <trans-unit id="4e38a79e72762fd78e402d5747ab629fd9e3cf95" translate="yes" xml:space="preserve">
          <source>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">No se puede utilizar un alias de un tipo enum para calificar a los constructores:</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">Un tipo anotado como &lt;code&gt;repr(transparent)&lt;/code&gt; delega todas las preocupaciones de representaci&amp;oacute;n a otro tipo, por lo que agregar m&amp;aacute;s sugerencias de representaci&amp;oacute;n es contradictorio. Elimine la sugerencia &lt;code&gt;transparent&lt;/code&gt; e o las otras sugerencias, como esta:</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">Un tipo también puede tener múltiples implementaciones inherentes.Un tipo de implementación debe definirse dentro de la misma caja que la definición del tipo original.</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">Un tipo puede implementar &lt;code&gt;Copy&lt;/code&gt; si todos sus componentes implementan &lt;code&gt;Copy&lt;/code&gt; . Por ejemplo, esta estructura puede ser &lt;code&gt;Copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de conversi&amp;oacute;n de tipo se denota con el operador binario &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b97b41bd9c7eae77d5c3b940d4a5832d7e972fb" translate="yes" xml:space="preserve">
          <source>A type dependency cycle has been encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2904374f2c0e91251791d02f72bd6378c8bccc80" translate="yes" xml:space="preserve">
          <source>A type has both &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; representation hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f0b7a28b6f2753f1d76d09de19c12454b7888f" translate="yes" xml:space="preserve">
          <source>A type has conflicting &lt;code&gt;packed&lt;/code&gt; representation hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">Un tipo que implementa &lt;code&gt;Try&lt;/code&gt; es uno que tiene una forma can&amp;oacute;nica de verlo en t&amp;eacute;rminos de una dicotom&amp;iacute;a de &amp;eacute;xito / fracaso. Este rasgo permite tanto extraer esos valores de &amp;eacute;xito o fracaso de una instancia existente como crear una nueva instancia a partir de un valor de &amp;eacute;xito o fracaso.</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">Un tipo que indica si una espera temporizada en una variable de condición regresó debido a un tiempo muerto o no.</target>
        </trans-unit>
        <trans-unit id="bcb42c5f4b4345c9c33893996e574612ab86b0f7" translate="yes" xml:space="preserve">
          <source>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is not &quot;empty&quot; in the sense that there can be values of the type. Opposite of &lt;a href=&quot;#uninhabited&quot;&gt;Uninhabited&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c125cceb1922063b5ac33f0666ef79257f43a2" translate="yes" xml:space="preserve">
          <source>A type is uninhabited if it has no constructors and therefore can never be instantiated. An uninhabited type is &quot;empty&quot; in the sense that there are no values of the type. The canonical example of an uninhabited type is the &lt;a href=&quot;types/never&quot;&gt;never type&lt;/a&gt;&lt;code&gt;!&lt;/code&gt;, or an enum with no variants &lt;code&gt;enum Never { }&lt;/code&gt;. Opposite of &lt;a href=&quot;#inhabited&quot;&gt;Inhabited&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3666c5137a8c2f5bd25b41e59026d010547814d" translate="yes" xml:space="preserve">
          <source>A type mismatched an associated type of a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">Un tipo de error que puede ser devuelto cuando se adquiere una cerradura.</target>
        </trans-unit>
        <trans-unit id="e09ee31e80fe4ed67d90fe93645d23ccc6bd8f11" translate="yes" xml:space="preserve">
          <source>A type or lifetime parameter has been declared but is not actually used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">Un tipo o módulo ha sido definido más de una vez.</target>
        </trans-unit>
        <trans-unit id="630bff58f7c530334c09b287d02fb5f603530515" translate="yes" xml:space="preserve">
          <source>A type parameter that is specified for &lt;code&gt;impl&lt;/code&gt; is not constrained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">Se declaró un parámetro de tipo que ensombrece uno existente.Un ejemplo de este error:</target>
        </trans-unit>
        <trans-unit id="0e1d3a1b69ee90016db302de62e4dd15a2f4ff16" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">No se especific&amp;oacute; un par&amp;aacute;metro de tipo que hace referencia a &lt;code&gt;Self&lt;/code&gt; en su valor predeterminado. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="5ff8db748ed5eaad6145c2ecc683c1493e2ac732" translate="yes" xml:space="preserve">
          <source>A type parameter with default value is using forward declared identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">Un tipo que representa una cadena propia,compatible con C,con terminación nula y sin nulos bytes en el medio.</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">Un tipo que puede ser cualquiera de varias variantes.</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">Un tipo que puede representar cuerdas propias y mutables de la plataforma,pero que se puede interconvertir de forma barata con cuerdas de óxido.</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">Un tipo que se compone de otros tipos.</target>
        </trans-unit>
        <trans-unit id="0a851afebbaf8a3f378080846c51bf756d8476cc" translate="yes" xml:space="preserve">
          <source>A type that is not a trait was used in a trait position, such as a bound or &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">Un tipo para emular la escritura dinámica.</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">Un tipo que se usa para inicializar condicionalmente los b&amp;uacute;feres que se pasan a los m&amp;eacute;todos de &lt;code&gt;Read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a527d3dadad04c815571442c7e455c6295d0179" translate="yes" xml:space="preserve">
          <source>A type which does not appear as an argument to another type. For example, &lt;code&gt;T&lt;/code&gt; is uncovered, but the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is covered. This is only relevant for type arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a3662dff4bc918fde00d869523d6a4f45ec09b" translate="yes" xml:space="preserve">
          <source>A type with &lt;code&gt;packed&lt;/code&gt; representation hint has a field with &lt;code&gt;align&lt;/code&gt; representation hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">El comportamiento de un tipo consiste en los m&amp;eacute;todos que podemos llamar a ese tipo. Los diferentes tipos comparten el mismo comportamiento si podemos llamar a los mismos m&amp;eacute;todos en todos esos tipos. Las definiciones de rasgos son una forma de agrupar las firmas de m&amp;eacute;todos para definir un conjunto de comportamientos necesarios para lograr alg&amp;uacute;n prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un acceso de uni&amp;oacute;n transmuta el contenido de la uni&amp;oacute;n al tipo de campo al que se accede. Dado que las transmutaciones pueden causar un comportamiento inesperado o indefinido, se requiere que &lt;code&gt;unsafe&lt;/code&gt; sea seguro leer desde un campo de uni&amp;oacute;n o escribir en un campo que no implementa &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Una declaraci&amp;oacute;n de uni&amp;oacute;n usa la misma sintaxis que una declaraci&amp;oacute;n de estructura, excepto con &lt;code&gt;union&lt;/code&gt; en lugar de &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">Una uni&amp;oacute;n declarada con &lt;code&gt;#[repr(C)]&lt;/code&gt; tendr&amp;aacute; el mismo tama&amp;ntilde;o y alineaci&amp;oacute;n que una declaraci&amp;oacute;n de uni&amp;oacute;n C equivalente en el lenguaje C para la plataforma de destino. La uni&amp;oacute;n tendr&amp;aacute; un tama&amp;ntilde;o del tama&amp;ntilde;o m&amp;aacute;ximo de todos sus campos redondeados a su alineaci&amp;oacute;n, y una alineaci&amp;oacute;n de la alineaci&amp;oacute;n m&amp;aacute;xima de todos sus campos. Estos m&amp;aacute;ximos pueden provenir de diferentes campos.</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">Un identificador único para un hilo conductor.</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">Una expresión de estructura unitaria es sólo el camino a un elemento de estructura unitaria.Se refiere a la constante implícita de la estructura unitaria de su valor.El valor de la estructura unitaria también puede construirse con una expresión de estructura sin campo.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">Se utilizó un atributo de representación no reconocido.</target>
        </trans-unit>
        <trans-unit id="5b4c71cc75880bc2daa87d6294e45d4e462f56c4" translate="yes" xml:space="preserve">
          <source>A used type name is not in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">Una entrada vacía.</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">Un valor en un &lt;code&gt;char&lt;/code&gt; que es un sustituto o superior a &lt;code&gt;char::MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">Tambi&amp;eacute;n se puede crear un valor de un tipo de &lt;a href=&quot;../items/unions&quot;&gt;uni&amp;oacute;n&lt;/a&gt; utilizando esta sintaxis, excepto que debe especificar exactamente un campo.</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">Un valor de un tipo de unión puede crearse utilizando la misma sintaxis que se utiliza para los tipos de estructura,excepto que debe especificar exactamente un campo:</target>
        </trans-unit>
        <trans-unit id="2edc0a57205327b0c616a8834c05686bc2cd3aab" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7083e77e4fd9ce896b8de61f936c4776bbf66b89" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">Un valor de tipo &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; que&lt;/a&gt; representa un &lt;strong&gt;falso&lt;/strong&gt; l&amp;oacute;gico .</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">Un valor de tipo &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; que&lt;/a&gt; representa &lt;strong&gt;verdadero&lt;/strong&gt; l&amp;oacute;gico .</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;char&lt;/code&gt; es un &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;valor escalar Unicode&lt;/a&gt; (es decir, un punto de c&amp;oacute;digo que no es un sustituto), representado como una palabra sin signo de 32 bits en el rango 0x0000 a 0xD7FF o 0xE000 a 0x10FFFF. Un &lt;code&gt;[char]&lt;/code&gt; es efectivamente una cadena UCS-4 / UTF-32.</target>
        </trans-unit>
        <trans-unit id="d1f3055da898f22398d4fbd4a38fa84ee1e65f98" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e06926f845b74d33c5ef28adb8bb299e3388cd7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;str&lt;/code&gt; es una cadena Unicode, representada como una matriz de bytes sin firmar de 8 bits que contienen una secuencia de puntos de c&amp;oacute;digo UTF-8. Dado que &lt;code&gt;str&lt;/code&gt; es un &lt;a href=&quot;../dynamically-sized-types&quot;&gt;tipo de tama&amp;ntilde;o din&amp;aacute;mico&lt;/a&gt; , no es un tipo de &lt;em&gt;primera clase&lt;/em&gt; , pero solo se puede crear una instancia a trav&amp;eacute;s de un tipo de puntero, como &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb241cb793b74334bb4ee4c800e211086ca2124" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is represented the same way as &lt;code&gt;[u8]&lt;/code&gt;, it is a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about &lt;code&gt;str&lt;/code&gt;: methods working on &lt;code&gt;str&lt;/code&gt; assume and ensure that the data in there is valid UTF-8. Calling a &lt;code&gt;str&lt;/code&gt; method with a non-UTF-8 buffer can cause &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; now or in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Un valor que no sea &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) o &lt;code&gt;true&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) en un &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">Un valor fue movido de una matriz de tamaño fijo sin copia.</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">Un valor fue trasladado mientras todavía estaba prestado.</target>
        </trans-unit>
        <trans-unit id="82027756f29be28c79aeae3975a5766aa1d2efa8" translate="yes" xml:space="preserve">
          <source>A value was moved whose size was not known at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">Se movió un valor.Sin embargo,su tamaño no se conocía en el momento de la compilación,y sólo los valores de un tamaño conocido pueden ser movidos.</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">Un valor fue usado después de que fue mutablemente prestado.</target>
        </trans-unit>
        <trans-unit id="a269a1265b9da40e02988ddb4b935f3e57685c81" translate="yes" xml:space="preserve">
          <source>A value which is initialized on the first access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9fd9c77be9db665eaa8aa09f7c11046598c96c" translate="yes" xml:space="preserve">
          <source>A value with a custom &lt;code&gt;Drop&lt;/code&gt; implementation may be dropped during const-eval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">Un valor, una vez fijado, debe permanecer fijado para siempre (a menos que su tipo implemente &lt;code&gt;Unpin&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una conversi&amp;oacute;n de valor a valor que consume el valor de entrada. Lo contrario de &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ec26c2f12c942e7a95c50dd2e23886df77a4d3b" translate="yes" xml:space="preserve">
          <source>A variable already borrowed as immutable was borrowed as mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">Una variable se inicializa si se le ha asignado un valor y no se ha movido desde entonces.Se supone que todas las demás ubicaciones de memoria no están inicializadas.Sólo un Rust inseguro puede crear tal memoria sin inicializarla.</target>
        </trans-unit>
        <trans-unit id="bcb706d6a23f6a1ef0d6e932c9012ea02de89d1f" translate="yes" xml:space="preserve">
          <source>A variable used inside an inner function comes from a dynamic environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624b6ee4bba7ea4936aac9cd4851655dde5b7367" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">Una variable fue prestada como mutable más de una vez.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="8f68dfea86962d0e6496e5ee7e7ba76db7429014" translate="yes" xml:space="preserve">
          <source>A variable was used after its contents have been moved elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7373f15283d19d70ccdc1ebdabd671b6fa35a616" translate="yes" xml:space="preserve">
          <source>A variable which requires unique access is being used in more than one closure at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">Una fuente de entrada muy común es la entrada estándar:</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">Una implementaci&amp;oacute;n muy simple de una estructura &lt;code&gt;Balance&lt;/code&gt; que tiene dos lados, donde cada uno puede indexarse ​​de manera mutante e inmutable.</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">Una vista de una sola entrada en un mapa,que puede estar vacía u ocupada.</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada vac&amp;iacute;a en un &lt;code&gt;BTreeMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada vac&amp;iacute;a en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada vac&amp;iacute;a en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada ocupada en un &lt;code&gt;BTreeMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada ocupada en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada ocupada en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una tabla de punteros de funci&amp;oacute;n virtual (vtable) que especifica el comportamiento de un &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3a191fe5eca1034f9485c5579c98bfcc0c4efc" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">Se usó un calificador de visibilidad cuando no era necesario.Ejemplos de códigos erróneos:</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">Un patr&amp;oacute;n while-let intenta coincidir con el patr&amp;oacute;n y entra en el cuerpo si la combinaci&amp;oacute;n fue exitosa. Si la coincidencia es irrefutable (cuando no puede fallar en la coincidencia), utilice un enlace &lt;code&gt;let&lt;/code&gt; normal dentro de un &lt;code&gt;loop&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="410ed7d62125fc62e5f4dca9f96376b96589d768" translate="yes" xml:space="preserve">
          <source>A windowed iterator over a slice in overlapping chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">Una solución a este problema es envolver el rasgo en una estructura,e implementar Drop en eso.A continuación se muestra un ejemplo:</target>
        </trans-unit>
        <trans-unit id="f617743555e205f1a8f890d184cd3c23b7f7c1f7" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">Una versión de trabajo sería:</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">Un envoltorio para &lt;code&gt;va_list&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">Un contenedor para impedir que el compilador llame autom&amp;aacute;ticamente al destructor de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd107425d645d1765a8fa8c1d57cb5b2986006a8" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor. This wrapper is 0-cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Un tipo de contenedor para un valor prestado de manera &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; un RefCell &amp;lt;T&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Un tipo de envoltura de construir casos no inicializadas de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">Un escritor que moverá datos al vacío.</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">Un tir&amp;oacute;n &lt;em&gt;no&lt;/em&gt; borra ning&amp;uacute;n c&amp;oacute;digo. Por ejemplo, la funci&amp;oacute;n yank no est&amp;aacute; dise&amp;ntilde;ada para eliminar secretos cargados accidentalmente. Si eso sucede, debe restablecer esos secretos de inmediato.</target>
        </trans-unit>
        <trans-unit id="c0f586bae86592aff79f5cdbd80a984e38bc5729" translate="yes" xml:space="preserve">
          <source>A yield expression was used outside of the generator literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI,vinculación,símbolos y FFI</target>
        </trans-unit>
        <trans-unit id="6984d7f2e63fc7e0a74bddee5e62b9dd8e8c052e" translate="yes" xml:space="preserve">
          <source>API not fully fleshed out and ready to be stabilized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711248439308ea2477b7d1f8ab4f7bd34663bf23" translate="yes" xml:space="preserve">
          <source>APIs like &lt;code&gt;try_for_each&lt;/code&gt; don't need values with &lt;code&gt;Break&lt;/code&gt;, so this provides a way to avoid typing &lt;code&gt;(())&lt;/code&gt;, if you prefer it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Las plataformas ARM como &lt;code&gt;armv5te&lt;/code&gt; que no son para Linux no tienen atomics en absoluto.</target>
        </trans-unit>
        <trans-unit id="9c08db2a34e8bae40e385191593c075648426189" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc. Additionally on Linux, these CAS operations are implemented via &lt;a href=&quot;https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt&quot;&gt;operating system support&lt;/a&gt;, which may come with a performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">Los objetivos ARM con &lt;code&gt;thumbv6m&lt;/code&gt; no tienen operaciones at&amp;oacute;micas en absoluto.</target>
        </trans-unit>
        <trans-unit id="f34ee041311ae3f08813e81fbedc2a8cd4a047c6" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">ASCII :</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">ASCII byte literal</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">El ASCII se escapa</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">Las letras ASCII de la &quot;A&quot; a la &quot;Z&quot; están asignadas a la &quot;a&quot; a la &quot;z&quot;,pero las letras no ASCII no cambian.</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">Las letras ASCII de la &quot;a&quot; a la &quot;z&quot; están asignadas a la &quot;A&quot; a la &quot;Z&quot;,pero las letras no ASCII no cambian.</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR :</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING :</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">Abortar por error o fallo en la asignación de memoria.</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">Aborta la ejecución del proceso.</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">Tipos de retorno abstracto</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">Los tipos de retorno abstracto ( &lt;code&gt;impl Trait&lt;/code&gt; escrito para alg&amp;uacute;n rasgo de &lt;code&gt;Trait&lt;/code&gt; ) solo se permiten como tipos de retorno impl&amp;iacute;citos de funci&amp;oacute;n e inherentes.</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">Árbol de sintaxis abstracta</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">Acepta una nueva conexión entrante de este oyente.</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">Aceptando los argumentos de la línea de mando</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">Acepta pedidos &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">Acepta una nueva conexión entrante con este oyente.</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">Acceder a una entrada mediante una llave y su hachís.</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">Accede a una entrada por hachís.</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">Acceder a una entrada por clave.</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">Campos de acceso en una estructura empaquetada:</target>
        </trans-unit>
        <trans-unit id="dcc61ae90f40e1ace5937cd1dcd9d685d9053fd4" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;a href=&quot;keyword.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b465e0094928c80bf2ab2af5859dca5bafc8fa28" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;code&gt;union&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">Acceder a los miembros de una estructura empaquetada por referencia:</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">Acceder o modificar una variable estática mutable</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">Acceda al error UTF-8 subyacente que fue la causa de este error.</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">Acceso a los elementos de la matriz</target>
        </trans-unit>
        <trans-unit id="0457e6128b17f06deb434a0c2873ebd99b60eb0d" translate="yes" xml:space="preserve">
          <source>Accessing Fields of a Union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">Acceder a los valores en un mapa Hash</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">Acceder a un campo de un &lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; , que no sea para asignarlo.</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">Accediendo al adyacente &lt;code&gt;u8&lt;/code&gt; como &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
