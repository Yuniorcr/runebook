<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="c012898141fc2cec018c7c222ae43346e5dd5f44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;T&lt;/code&gt; reference can be released to safe code and there it can co-exist with other &lt;code&gt;&amp;amp;T&lt;/code&gt; references, but not with a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</source>
          <target state="translated">La referencia A &lt;code&gt;&amp;amp;T&lt;/code&gt; se puede liberar a un c&amp;oacute;digo seguro y all&amp;iacute; puede coexistir con otras referencias &lt;code&gt;&amp;amp;T&lt;/code&gt; , pero no con un &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec5710ef1f0b84eb29b3c1cc1f924e822fb56fa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference may be released to safe code provided neither other &lt;code&gt;&amp;amp;mut T&lt;/code&gt; nor &lt;code&gt;&amp;amp;T&lt;/code&gt; co-exist with it. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; must always be unique.</source>
          <target state="translated">Una referencia de &lt;code&gt;&amp;amp;mut T&lt;/code&gt; puede ser liberada a un c&amp;oacute;digo seguro siempre que no &lt;code&gt;&amp;amp;mut T&lt;/code&gt; otros &amp;amp; mut T ni &lt;code&gt;&amp;amp;T&lt;/code&gt; con &amp;eacute;l. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; siempre debe ser &amp;uacute;nico.</target>
        </trans-unit>
        <trans-unit id="40585fc29df20c1219babfcdddcfc95974719e32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">A &lt;code&gt;&amp;amp;str&lt;/code&gt; se compone de dos componentes: un puntero a algunos bytes y una longitud. Puede &lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; con los m&amp;eacute;todos as_ptr y &lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="96eae277d841da5acce951109ccad7e43958c9c5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26915dade1d3ce3c223fcfcc944e12fb9d06d42" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;Barrier::wait()&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35fb8d8640dfbea523c47310a34e3d854229d236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">Un &lt;code&gt;BarrierWaitResult&lt;/code&gt; es devuelto por &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; cuando todos los subprocesos de &lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; se&lt;/a&gt; han reunido.</target>
        </trans-unit>
        <trans-unit id="a33fe1ab5786729bf200982553a4a40b28677c12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufRead&lt;/code&gt; is a type of &lt;code&gt;Read&lt;/code&gt;er which has an internal buffer, allowing it to perform extra ways of reading.</source>
          <target state="translated">Un &lt;code&gt;BufRead&lt;/code&gt; es un tipo de &lt;code&gt;Read&lt;/code&gt; er que tiene un buffer interno, que le permite realizar formas adicionales de lectura.</target>
        </trans-unit>
        <trans-unit id="c2a7d564e1881467808b1da26fc7f621d550ac35" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BuildHasher&lt;/code&gt; is typically used (e.g., by &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;) to create &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s for each key such that they are hashed independently of one another, since &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s contain state.</source>
          <target state="translated">Un &lt;code&gt;BuildHasher&lt;/code&gt; se usa t&amp;iacute;picamente (por ejemplo, por &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; ) para crear &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; s para cada clave, de modo que est&amp;eacute;n hash independientemente entre s&amp;iacute;, ya que los &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; contienen el estado.</target>
        </trans-unit>
        <trans-unit id="5ac6d9ca4b25b818aa6f9cb17715ea50c25bf2ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">Un &lt;code&gt;CString&lt;/code&gt; se crea a partir de un segmento de bytes o un vector de bytes, o cualquier cosa que implemente &lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (por ejemplo, puede construir un &lt;code&gt;CString&lt;/code&gt; directamente a partir de un &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; o un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; , ya que ambos implementan ese rasgo).</target>
        </trans-unit>
        <trans-unit id="a976b86b7133ebd168dd44069ca430099fb11fcd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef22157720da42f049eda44831ae9039ff96672" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or ).</source>
          <target state="translated">Un &lt;code&gt;Component&lt;/code&gt; corresponde aproximadamente a una subcadena entre separadores de ruta ( &lt;code&gt;/&lt;/code&gt; o).</target>
        </trans-unit>
        <trans-unit id="00d5a6a3fb8d035432bd26a66264da1cd9fcfcb1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8dc93d165313d1d53fe035b20236e511c258009" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth, and can safely mutate the list during iteration. This is because the lifetime of its yielded references is tied to its own lifetime, instead of just the underlying list. This means cursors cannot yield multiple elements at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1edbc893c845d675ae565c5adc4b48af73fbd0b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592f6bf36d948cda2dbd34364696113591fa1887" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; wraps an in-memory buffer and provides it with a &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Un &lt;code&gt;Cursor&lt;/code&gt; envuelve un b&amp;uacute;fer en memoria y le proporciona una implementaci&amp;oacute;n de &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a89cb140638fa3cd771cb02496374d776ad6d007" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; type to represent a span of time, typically used for system timeouts.</source>
          <target state="translated">Un tipo de &lt;code&gt;Duration&lt;/code&gt; para representar un lapso de tiempo, generalmente utilizado para tiempos de espera del sistema.</target>
        </trans-unit>
        <trans-unit id="e39d340a59cb5b2bb2e11548f7d50ffd50cdcaa5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Formatter&lt;/code&gt; represents various options related to formatting. Users do not construct &lt;code&gt;Formatter&lt;/code&gt;s directly; a mutable reference to one is passed to the &lt;code&gt;fmt&lt;/code&gt; method of all formatting traits, like &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un &lt;code&gt;Formatter&lt;/code&gt; representa varias opciones relacionadas con el formato. Los usuarios no construyen &lt;code&gt;Formatter&lt;/code&gt; directamente; una referencia mutable a uno se pasa al m&amp;eacute;todo &lt;code&gt;fmt&lt;/code&gt; de todos los rasgos de formato, como &lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="921821ce37ee7be55d1f4cd9ec14a09989a7422f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashMap&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">Un &lt;code&gt;HashMap&lt;/code&gt; con una lista fija de elementos se puede inicializar desde una matriz:</target>
        </trans-unit>
        <trans-unit id="9e3e7578434780dbd4d9d999f38a9955ea8f8204" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashSet&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">Un &lt;code&gt;HashSet&lt;/code&gt; con una lista fija de elementos se puede inicializar desde una matriz:</target>
        </trans-unit>
        <trans-unit id="9b7c01af6b5011fee801753cdfcb67030ddd18ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JoinHandle&lt;/code&gt;&lt;em&gt;detaches&lt;/em&gt; the associated thread when it is dropped, which means that there is no longer any handle to thread and no way to &lt;code&gt;join&lt;/code&gt; on it.</source>
          <target state="translated">Un &lt;code&gt;JoinHandle&lt;/code&gt; &lt;em&gt;separa&lt;/em&gt; el hilo asociado cuando se suelta , lo que significa que ya no hay ning&amp;uacute;n identificador para el hilo y no hay forma de &lt;code&gt;join&lt;/code&gt; a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="134a2452be93d4c2cdb1b9f1f0542b4b65ecae3d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LocalKey&lt;/code&gt;'s initializer cannot recursively depend on itself, and using a &lt;code&gt;LocalKey&lt;/code&gt; in this way will cause the initializer to infinitely recurse on the first call to &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;LocalKey&lt;/code&gt; una LocalKey no puede depender recursivamente de s&amp;iacute; mismo, y usar una &lt;code&gt;LocalKey&lt;/code&gt; de esta manera har&amp;aacute; que el inicializador se repita infinitamente en la primera llamada a &lt;code&gt;with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c72c40c2b2da09870992c3f25ebf2fd884c3cef5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Match&lt;/code&gt; result needs to contain the whole matched pattern, however &lt;code&gt;Reject&lt;/code&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">Un resultado de &lt;code&gt;Match&lt;/code&gt; debe contener todo el patr&amp;oacute;n coincidente, sin embargo, los resultados de &lt;code&gt;Reject&lt;/code&gt; pueden dividirse en muchos fragmentos adyacentes arbitrarios. Ambos rangos pueden tener una longitud cero.</target>
        </trans-unit>
        <trans-unit id="14d52da7769e774ed02f1e53e420687489f136bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5668f2d21fa477474ed4b8f6c89c068e50ff97ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;code&gt;&amp;amp;'a str&lt;/code&gt;.</source>
          <target state="translated">Un &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresa que el tipo de implementaci&amp;oacute;n puede usarse como un patr&amp;oacute;n de cadena para buscar en un &lt;code&gt;&amp;amp;'a str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">Un &lt;code&gt;RawWaker&lt;/code&gt; permite al implementador de un ejecutor de tareas crear un &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; que proporciona un comportamiento de activaci&amp;oacute;n personalizado.</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">Un &lt;code&gt;String&lt;/code&gt; puede aumentar de tama&amp;ntilde;o y su contenido puede cambiar, al igual que el contenido de un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , si inserta m&amp;aacute;s datos en &amp;eacute;l. &amp;iexcl;Adem&amp;aacute;s, puede utilizar c&amp;oacute;modamente el operador &lt;code&gt;+&lt;/code&gt; o el &lt;code&gt;format!&lt;/code&gt; macro para concatenar valores de &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">Un &lt;code&gt;String&lt;/code&gt; es un envoltorio sobre un &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; . Veamos algunas de nuestras cadenas de ejemplo UTF-8 codificadas correctamente del Listado 8-14. Primero, este:</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">Una &lt;code&gt;String&lt;/code&gt; se compone de tres componentes: un puntero a algunos bytes, una longitud y una capacidad. El puntero apunta a un b&amp;uacute;fer interno que &lt;code&gt;String&lt;/code&gt; utiliza para almacenar sus datos. La longitud es el n&amp;uacute;mero de bytes almacenados actualmente en el b&amp;uacute;fer y la capacidad es el tama&amp;ntilde;o del b&amp;uacute;fer en bytes. Como tal, la longitud siempre ser&amp;aacute; menor o igual que la capacidad.</target>
        </trans-unit>
        <trans-unit id="2ad19c9717a97c44c08a93976b602e0990d24669" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;SystemTime::duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;SystemTime::elapsed&lt;/code&gt;&lt;/a&gt; methods whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">Se &lt;code&gt;SystemTimeError&lt;/code&gt; un SystemTimeError de los m&amp;eacute;todos &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt; de &lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt; siempre que la segunda hora del sistema representa un punto posterior en el tiempo que el &lt;code&gt;self&lt;/code&gt; de la llamada al m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un &lt;code&gt;ThreadId&lt;/code&gt; es un objeto opaco que tiene un valor &amp;uacute;nico para cada hilo que crea uno. &lt;code&gt;ThreadId&lt;/code&gt; se garantiza que los ThreadId se correspondan con el identificador designado por el sistema de un hilo. Un &lt;code&gt;ThreadId&lt;/code&gt; se puede recuperar del m&amp;eacute;todo &lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; en un &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">Un &lt;code&gt;TypeId&lt;/code&gt; actualmente solo est&amp;aacute; disponible para los tipos que se adscriben a &lt;code&gt;'static&lt;/code&gt; , pero esta limitaci&amp;oacute;n puede eliminarse en el futuro.</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">Un &lt;code&gt;TypeId&lt;/code&gt; representa un identificador &amp;uacute;nico global para un tipo.</target>
        </trans-unit>
        <trans-unit id="05e63a516d556e9577522a23860139fad9899875" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a &lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;../primitive.reference&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">Un &lt;code&gt;Vec&lt;/code&gt; puede ser mutable. Las rebanadas, por otro lado, son objetos de solo lectura. Para obtener una rebanada, use &lt;code&gt;&amp;amp;&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">Un &lt;code&gt;Waker&lt;/code&gt; es un identificador para despertar una tarea notificando a su ejecutor que est&amp;aacute; lista para ejecutarse.</target>
        </trans-unit>
        <trans-unit id="d9bc289fc584bbfaef86d0de4ba94863300845d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a226c54ce6028079ee3f0e935344b03753cf6ea2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">Un puntero &lt;code&gt;Weak&lt;/code&gt; es &amp;uacute;til para mantener una referencia temporal al valor dentro de &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; sin extender su vida &amp;uacute;til. Tambi&amp;eacute;n se usa para evitar referencias circulares entre punteros de &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; , ya que las referencias de propiedad mutua nunca permitir&amp;iacute;an que se &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; ninguno de los Arc . Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; de los nodos principales a los hijos y &lt;code&gt;Weak&lt;/code&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">Un puntero &lt;code&gt;Weak&lt;/code&gt; es &amp;uacute;til para mantener una referencia temporal al valor dentro de &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; sin extender su vida &amp;uacute;til. Tambi&amp;eacute;n se utiliza para evitar referencias circulares entre punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; , ya que las referencias de propiedad mutua nunca permitir&amp;iacute;an que se &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; ninguno de los Rc . Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; de los nodos principales a los hijos y &lt;code&gt;Weak&lt;/code&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="2ab6f5c59e2d0418f87950a3ebfb26ab14b557db" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">Un &lt;code&gt;break&lt;/code&gt; expresi&amp;oacute;n se asocia normalmente con el interior &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; o &lt;code&gt;while&lt;/code&gt; bucle que encierra el &lt;code&gt;break&lt;/code&gt; expresi&amp;oacute;n, pero una &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;etiqueta&lt;/a&gt; se puede utilizar para especificar que encierra bucle se ve afectada. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="dc2182d07a207a24da6c811d0b8e308ce9f0619b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; solo est&amp;aacute; permitida en el cuerpo de un bucle y tiene una de las formas &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;break 'label&lt;/code&gt; o ( &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;ver m&amp;aacute;s abajo&lt;/a&gt; ) &lt;code&gt;break EXPR&lt;/code&gt; o &lt;code&gt;break 'label EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">Una &lt;code&gt;break&lt;/code&gt; declaraci&amp;oacute;n con un argumento no apareci&amp;oacute; en un &lt;code&gt;loop&lt;/code&gt; bucle.</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">Una declaraci&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; sin una etiqueta apareci&amp;oacute; dentro de un bloque etiquetado.</target>
        </trans-unit>
        <trans-unit id="3cd69f4f6c3139636621e0e9a9e16305bdb70d6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">Una &lt;code&gt;const&lt;/code&gt; ante representa un valor constante que nunca deber&amp;iacute;a cambiar. Si uno toma una referencia &lt;code&gt;&amp;amp;&lt;/code&gt; a la constante, entonces est&amp;aacute; tomando un puntero a alguna ubicaci&amp;oacute;n de memoria que contiene el valor. Normalmente esto est&amp;aacute; perfectamente bien: la mayor&amp;iacute;a de los valores no se pueden cambiar a trav&amp;eacute;s de un puntero &lt;code&gt;&amp;amp;&lt;/code&gt; compartido , pero la mutabilidad interior lo permitir&amp;iacute;a. Es decir, se podr&amp;iacute;a mutar un valor constante. Por otro lado, una &lt;code&gt;static&lt;/code&gt; es expl&amp;iacute;citamente una &amp;uacute;nica ubicaci&amp;oacute;n de memoria, que puede mutarse a voluntad.</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">Una expresi&amp;oacute;n &lt;code&gt;for&lt;/code&gt; es una construcci&amp;oacute;n sint&amp;aacute;ctica para recorrer elementos proporcionados por una implementaci&amp;oacute;n de &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; . Si el iterador produce un valor, a ese valor se le da el nombre especificado y se ejecuta el cuerpo del ciclo, entonces el control vuelve al principio del ciclo &lt;code&gt;for&lt;/code&gt; . Si el iterador est&amp;aacute; vac&amp;iacute;o, la expresi&amp;oacute;n &lt;code&gt;for&lt;/code&gt; se completa.</target>
        </trans-unit>
        <trans-unit id="7cc2ad054c8700f44ee39d9eb760a19117e088af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">Un bucle &lt;code&gt;for&lt;/code&gt; se expande como se muestra:</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de &lt;code&gt;loop&lt;/code&gt; repite la ejecuci&amp;oacute;n de su cuerpo continuamente: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d617ef5af3dab30c4c49b4baffa8bfa3c5f2ec66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&amp;iexcl;Una expresi&amp;oacute;n de &lt;code&gt;loop&lt;/code&gt; sin una expresi&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; asociada es divergente y tiene tipo &lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; . Un &lt;code&gt;loop&lt;/code&gt; de expresi&amp;oacute;n que contiene asociada &lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; expresi&amp;oacute;n (s)&lt;/a&gt; puede terminar, y debe tener un tipo compatible con el valor de la &lt;code&gt;break&lt;/code&gt; de expresi&amp;oacute;n (s).</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">Una &lt;code&gt;match&lt;/code&gt; comporta de manera diferente dependiendo de si la expresi&amp;oacute;n del escrutinio es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar o&lt;/a&gt; una expresi&amp;oacute;n de valor . Si la expresi&amp;oacute;n del escrutinio es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de valor&lt;/a&gt; , primero se eval&amp;uacute;a en una ubicaci&amp;oacute;n temporal y el valor resultante se compara secuencialmente con los patrones en los brazos hasta que se encuentra una coincidencia. El primer brazo con un patr&amp;oacute;n coincidente se elige como el objetivo de la rama del &lt;code&gt;match&lt;/code&gt; , las variables limitadas por el patr&amp;oacute;n se asignan a las variables locales en el bloque del brazo y el control ingresa al bloque.</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">Una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; est&amp;aacute; formada por &lt;em&gt;brazos&lt;/em&gt; . Un brazo consta de un &lt;em&gt;patr&amp;oacute;n&lt;/em&gt; y el c&amp;oacute;digo que debe ejecutarse si el valor dado al comienzo de la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; ajusta al patr&amp;oacute;n de ese brazo. Rust toma el valor dado para &lt;code&gt;match&lt;/code&gt; y mira a trav&amp;eacute;s del patr&amp;oacute;n de cada brazo por turno. La construcci&amp;oacute;n y los patrones de &lt;code&gt;match&lt;/code&gt; son caracter&amp;iacute;sticas poderosas en Rust que le permiten expresar una variedad de situaciones que su c&amp;oacute;digo puede encontrar y asegurarse de manejarlas todas. Estas caracter&amp;iacute;sticas se cubrir&amp;aacute;n en detalle en el Cap&amp;iacute;tulo 6 y el Cap&amp;iacute;tulo 18, respectivamente.</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">A &lt;code&gt;repr(transparent)&lt;/code&gt; tipo tambi&amp;eacute;n fue anotado con otros, consejos de representaci&amp;oacute;n incompatibles.</target>
        </trans-unit>
        <trans-unit id="c5a4ca7ea6b5bc0339d74f8626989e641c9a4f2a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; marks the end of an execution path in a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04d984159639545c2a9b782d494bbc89f68eb09" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; which was defined in the current crate. This is not affected by applied type arguments. &lt;code&gt;struct Foo&lt;/code&gt; is considered local, but &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; is not. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; is local. Type aliases do not affect locality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bcaf88ff1b66b63413f83d3b7d32c0a7ea7cbfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Un &lt;em&gt;tipo de &lt;/em&gt; &lt;code&gt;struct&lt;/code&gt; es un producto heterog&amp;eacute;neo de otros tipos, llamados &lt;em&gt;campos&lt;/em&gt; del tipo. &lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5dc372cb983e81c62a84e7d307e5c691468779fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; is like an interface that data types can implement. When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad87d3d4edf2b4861565127275e5ad1afc1a755" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; is always local, regardless of the types substituted for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ab68cda9330ceba3e059532d454bd1454a3c76" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; cannot have fields with destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7456e28e3269b8fcb15b4e8220467fa67683b4bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d933644dc98827f86adb027ad1edada503180c92" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; looks like a &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; in terms of declaration, but all of its fields exist in the same memory, superimposed over one another. For instance, if we wanted some bits in memory that we sometimes interpret as a &lt;code&gt;u32&lt;/code&gt; and sometimes as an &lt;code&gt;f32&lt;/code&gt;, we could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae4dfd16f669123c1df46acb99529aa8db4f78e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; was declared with fields with destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">Un bucle &lt;code&gt;while let&lt;/code&gt; es equivalente a una expresi&amp;oacute;n de &lt;code&gt;loop&lt;/code&gt; que contiene una &lt;a href=&quot;match-expr&quot;&gt;expresi&amp;oacute;n de &lt;/a&gt; &lt;code&gt;match&lt;/code&gt; siguiente manera.</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">A &lt;code&gt;while let&lt;/code&gt; bucle es sem&amp;aacute;nticamente similar a un &lt;code&gt;while&lt;/code&gt; bucle pero en lugar de una expresi&amp;oacute;n condici&amp;oacute;n que espera que la palabra clave &lt;code&gt;let&lt;/code&gt; seguido por un patr&amp;oacute;n, un &lt;code&gt;=&lt;/code&gt; , un &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expresi&amp;oacute;n y una expresi&amp;oacute;n de bloque. Si el valor del escrutinio coincide con el patr&amp;oacute;n, el bloque del cuerpo del bucle se ejecuta y el control vuelve a la declaraci&amp;oacute;n de coincidencia del patr&amp;oacute;n. De lo contrario, la expresi&amp;oacute;n while se completa.</target>
        </trans-unit>
        <trans-unit id="718179093a0d6e082dbdc6f07f43775afb09f0f9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; expression is used for predicate loops. The &lt;code&gt;while&lt;/code&gt; expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, or exits the loop otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">A &lt;code&gt;while&lt;/code&gt; bucle comienza evaluando el bucle expresi&amp;oacute;n condicional booleano. Si la expresi&amp;oacute;n condicional del bucle se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; , el bloque del cuerpo del bucle se ejecuta y el control vuelve a la expresi&amp;oacute;n condicional del bucle. Si la expresi&amp;oacute;n condicional de bucle se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;while&lt;/code&gt; se completa.</target>
        </trans-unit>
        <trans-unit id="9024dfdf6115f20a47566e1a178072686b644d4c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;yield&lt;/code&gt; clause was used in an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">Un &lt;em&gt;escape de punto de c&amp;oacute;digo de 24 bits&lt;/em&gt; comienza con &lt;code&gt;U+0075&lt;/code&gt; ( &lt;code&gt;u&lt;/code&gt; ) y va seguido de hasta seis &lt;em&gt;d&amp;iacute;gitos hexadecimales&lt;/em&gt; rodeados por llaves &lt;code&gt;U+007B&lt;/code&gt; ( &lt;code&gt;{&lt;/code&gt; ) y &lt;code&gt;U+007D&lt;/code&gt; ( &lt;code&gt;}&lt;/code&gt; ). Denota el punto de c&amp;oacute;digo Unicode igual al valor hexadecimal proporcionado.</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">Un &lt;em&gt;escape de punto de c&amp;oacute;digo de 7 bits&lt;/em&gt; comienza con &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ) y es seguido exactamente por dos &lt;em&gt;d&amp;iacute;gitos hexadecimales&lt;/em&gt; con un valor de hasta &lt;code&gt;0x7F&lt;/code&gt; . Denota el car&amp;aacute;cter ASCII con un valor igual al valor hexadecimal proporcionado. No se permiten valores m&amp;aacute;s altos porque es ambiguo si se refieren a puntos de c&amp;oacute;digo Unicode o valores de bytes.</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n &lt;/em&gt;&lt;em&gt; &lt;code&gt;let&lt;/code&gt; &lt;/em&gt; introduce un nuevo conjunto de &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt; , dado por un &lt;a href=&quot;patterns&quot;&gt;patr&amp;oacute;n&lt;/a&gt; . El patr&amp;oacute;n es seguido opcionalmente por una anotaci&amp;oacute;n de tipo y luego opcionalmente por una expresi&amp;oacute;n inicializadora. Cuando no se proporciona una anotaci&amp;oacute;n de tipo, el compilador inferir&amp;aacute; el tipo o se&amp;ntilde;alar&amp;aacute; un error si no hay suficiente informaci&amp;oacute;n de tipo disponible para una inferencia definitiva. Cualquier variable introducida por una declaraci&amp;oacute;n de variable es visible desde el punto de declaraci&amp;oacute;n hasta el final del alcance del bloque adjunto.</target>
        </trans-unit>
        <trans-unit id="8ca18f2a30c6ddfd6e41efbe967d1604f354b083" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by an irrefutable &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de &lt;/em&gt;&lt;em&gt; &lt;code&gt;match&lt;/code&gt; &lt;/em&gt; ramifica en un patr&amp;oacute;n. La forma exacta de coincidencia que se produce depende del &lt;a href=&quot;../patterns&quot;&gt;patr&amp;oacute;n&lt;/a&gt; . Una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; tiene una &lt;em&gt;expresi&amp;oacute;n de &lt;/em&gt;&lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;escrutinio&lt;/a&gt;&lt;/em&gt; , que es el valor para comparar con los patrones. La expresi&amp;oacute;n del escrutinio y los patrones deben ser del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">Un &lt;em&gt;literal binario&lt;/em&gt; comienza con la secuencia de caracteres &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;0b&lt;/code&gt; ) y contin&amp;uacute;a como cualquier combinaci&amp;oacute;n (con al menos un d&amp;iacute;gito) de d&amp;iacute;gitos binarios y guiones bajos.</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de bloque&lt;/em&gt; , o &lt;em&gt;bloque&lt;/em&gt; , es una expresi&amp;oacute;n de flujo de control y un &amp;aacute;mbito de espacio de nombres an&amp;oacute;nimo para elementos y declaraciones de variables. Como expresi&amp;oacute;n de flujo de control, un bloque ejecuta secuencialmente sus declaraciones de declaraci&amp;oacute;n de componentes que no son elementos y luego su expresi&amp;oacute;n opcional final. Como un &amp;aacute;mbito de espacio de nombres an&amp;oacute;nimo, las declaraciones de elementos solo est&amp;aacute;n dentro del &amp;aacute;mbito del bloque y las variables declaradas por las sentencias &lt;code&gt;let&lt;/code&gt; est&amp;aacute;n dentro del &amp;aacute;mbito desde la siguiente sentencia hasta el final del bloque.</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">Un &lt;em&gt;escape de byte de escape&lt;/em&gt; comienza con &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ) y es seguido exactamente por dos &lt;em&gt;d&amp;iacute;gitos hexadecimales&lt;/em&gt; . Denota el byte igual al valor hexadecimal proporcionado.</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal de byte&lt;/em&gt; es un solo car&amp;aacute;cter ASCII (en el rango &lt;code&gt;U+0000&lt;/code&gt; a &lt;code&gt;U+007F&lt;/code&gt; ) o un solo &lt;em&gt;escape&lt;/em&gt; precedido por los caracteres &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) y &lt;code&gt;U+0027&lt;/code&gt; (comillas simples), y seguido por el car&amp;aacute;cter &lt;code&gt;U+0027&lt;/code&gt; . Si el car&amp;aacute;cter &lt;code&gt;U+0027&lt;/code&gt; est&amp;aacute; presente dentro del literal, debe &lt;em&gt;escaparse&lt;/em&gt; con un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) anterior. Es equivalente a un &lt;em&gt;literal de n&amp;uacute;mero&lt;/em&gt; entero de 8 bits sin signo &lt;code&gt;u8&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de llamada&lt;/em&gt; consta de una expresi&amp;oacute;n seguida de una lista de expresiones entre par&amp;eacute;ntesis. Invoca una funci&amp;oacute;n, proporcionando cero o m&amp;aacute;s variables de entrada. Si la funci&amp;oacute;n finalmente regresa, la expresi&amp;oacute;n se completa. Para &lt;a href=&quot;../types/function-item&quot;&gt;tipos que no son funciones&lt;/a&gt; , la expresi&amp;oacute;n f (...) usa el m&amp;eacute;todo en uno de los rasgos &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt; , que difieren en si toman el tipo por referencia, referencia mutable o se apropian respectivamente. Se tomar&amp;aacute; un pr&amp;eacute;stamo autom&amp;aacute;tico si es necesario. Rust tambi&amp;eacute;n eliminar&amp;aacute; autom&amp;aacute;ticamente la referencia &lt;code&gt;f&lt;/code&gt; seg&amp;uacute;n sea necesario. Algunos ejemplos de expresiones de llamada:</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">Un &lt;em&gt;literal de car&amp;aacute;cter&lt;/em&gt; es un car&amp;aacute;cter Unicode &amp;uacute;nico encerrado entre dos caracteres &lt;code&gt;U+0027&lt;/code&gt; (comillas simples), con la excepci&amp;oacute;n del propio &lt;code&gt;U+0027&lt;/code&gt; , que debe &lt;em&gt;escaparse&lt;/em&gt; con un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; precedente ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de cierre&lt;/em&gt; define un cierre y lo denota como un valor, en una sola expresi&amp;oacute;n. Una expresi&amp;oacute;n de cierre es una lista delimitada por s&amp;iacute;mbolos de barra vertical ( &lt;code&gt;|&lt;/code&gt; ) de &lt;a href=&quot;../patterns&quot;&gt;patrones&lt;/a&gt; irrefutables seguida de una expresi&amp;oacute;n. Opcionalmente, se pueden agregar anotaciones de tipo para el tipo de par&amp;aacute;metros o para el tipo de retorno. Si hay un tipo de retorno, la expresi&amp;oacute;n utilizada para el cuerpo del cierre debe ser un &lt;a href=&quot;block-expr&quot;&gt;bloque&lt;/a&gt; normal . Una expresi&amp;oacute;n de cierre tambi&amp;eacute;n puede comenzar con la palabra clave &lt;code&gt;move&lt;/code&gt; antes de la inicial &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="339cfc7fe9f16f898782c7f7150b6fb18b64f9c3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt;, also know as a lambda expression or a lambda, defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">Una &lt;em&gt;lista de contras&lt;/em&gt; es una estructura de datos que proviene del lenguaje de programaci&amp;oacute;n Lisp y sus dialectos. En Lisp, la funci&amp;oacute;n &lt;code&gt;cons&lt;/code&gt; (abreviatura de &quot;funci&amp;oacute;n de construcci&amp;oacute;n&quot;) construye un nuevo par a partir de sus dos argumentos, que normalmente son un valor &amp;uacute;nico y otro par. Estos pares que contienen pares forman una lista.</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">Un &lt;em&gt;contexto constante&lt;/em&gt; es uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="493b2f63697e56331a49f53a0195846cde72e171" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const fn&lt;/em&gt; is a function that one is permitted to call from a const context. Declaring a function &lt;code&gt;const&lt;/code&gt; has no effect on any existing uses, it only restricts the types that arguments and the return type may use, as well as prevent various expressions from being used within it. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">Un &lt;em&gt;elemento constante&lt;/em&gt; es un &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;valor constante&lt;/a&gt;&lt;/em&gt; opcionalmente nombrado que no est&amp;aacute; asociado con una ubicaci&amp;oacute;n de memoria espec&amp;iacute;fica en el programa. Las constantes est&amp;aacute;n esencialmente en l&amp;iacute;nea dondequiera que se usen, lo que significa que se copian directamente en el contexto relevante cuando se usan. No se garantiza necesariamente que las referencias a la misma constante se refieran a la misma direcci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="2e06b409839c096ae71106f8baaaf9f78507004d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">Una &lt;em&gt;caja&lt;/em&gt; es una unidad de compilaci&amp;oacute;n y vinculaci&amp;oacute;n, as&amp;iacute; como de control de versiones, distribuci&amp;oacute;n y carga en tiempo de ejecuci&amp;oacute;n. Una caja contiene un &lt;em&gt;&amp;aacute;rbol&lt;/em&gt; de &amp;aacute;mbitos de &lt;a href=&quot;items/modules&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; anidados . El nivel superior de este &amp;aacute;rbol es un m&amp;oacute;dulo que es an&amp;oacute;nimo (desde el punto de vista de las rutas dentro del m&amp;oacute;dulo) y cualquier elemento dentro de una caja tiene una &lt;a href=&quot;paths&quot;&gt;ruta de m&amp;oacute;dulo&lt;/a&gt; can&amp;oacute;nica indica su ubicaci&amp;oacute;n dentro del &amp;aacute;rbol de m&amp;oacute;dulos de la caja.</target>
        </trans-unit>
        <trans-unit id="7dbd934a0d90b722d503e93f98eb0c64d5f9ddfa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal decimal&lt;/em&gt; seguido de un car&amp;aacute;cter de punto &lt;code&gt;U+002E&lt;/code&gt; ( &lt;code&gt;.&lt;/code&gt; ). Esto es seguido opcionalmente por otro literal decimal, con un &lt;em&gt;exponente&lt;/em&gt; opcional .</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal decimal&lt;/em&gt; comienza con un &lt;em&gt;d&amp;iacute;gito decimal&lt;/em&gt; y contin&amp;uacute;a con cualquier combinaci&amp;oacute;n de &lt;em&gt;d&amp;iacute;gitos decimales&lt;/em&gt; y &lt;em&gt;guiones bajos.&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n de declaraci&amp;oacute;n&lt;/em&gt; es aquella que introduce uno o m&amp;aacute;s &lt;em&gt;nombres&lt;/em&gt; en el bloque de declaraci&amp;oacute;n adjunto. Los nombres declarados pueden denotar nuevas variables o nuevos &lt;a href=&quot;items&quot;&gt;elementos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de campo&lt;/em&gt; consta de una expresi&amp;oacute;n seguida de un solo punto y un &lt;a href=&quot;../identifiers&quot;&gt;identificador&lt;/a&gt; , cuando no est&amp;aacute; seguida inmediatamente por una lista de expresiones entre par&amp;eacute;ntesis (esta &amp;uacute;ltima es siempre una &lt;a href=&quot;method-call-expr&quot;&gt;expresi&amp;oacute;n de llamada de m&amp;eacute;todo&lt;/a&gt; ). Una expresi&amp;oacute;n de campo denota un campo de una &lt;a href=&quot;../items/structs&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;../items/unions&quot;&gt;uni&amp;oacute;n&lt;/a&gt; . Para llamar a una funci&amp;oacute;n almacenada en una estructura, se necesitan par&amp;eacute;ntesis alrededor de la expresi&amp;oacute;n del campo.</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">Un &lt;em&gt;literal de punto flotante&lt;/em&gt; tiene una de dos formas:</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">Una &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; consta de un &lt;a href=&quot;../expressions/block-expr&quot;&gt;bloque&lt;/a&gt; , junto con un nombre y un conjunto de par&amp;aacute;metros. Aparte del nombre, todos estos son opcionales. Las funciones se declaran con la palabra clave &lt;code&gt;fn&lt;/code&gt; . Las funciones pueden declarar un conjunto de &lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; de &lt;em&gt;entrada&lt;/em&gt; como par&amp;aacute;metros, a trav&amp;eacute;s de los cuales el llamador pasa argumentos a la funci&amp;oacute;n, y el &lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;tipo&lt;/em&gt;&lt;/a&gt; de &lt;em&gt;salida&lt;/em&gt; del valor que la funci&amp;oacute;n devolver&amp;aacute; a su llamador al finalizar.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">Una &lt;em&gt;funci&amp;oacute;n gen&amp;eacute;rica&lt;/em&gt; permite que aparezcan uno o m&amp;aacute;s &lt;em&gt;tipos parametrizados&lt;/em&gt; en su firma. Cada par&amp;aacute;metro de tipo debe declararse expl&amp;iacute;citamente en una lista delimitada por corchetes angulares y separada por comas, despu&amp;eacute;s del nombre de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;mapa hash le&lt;/em&gt; permite asociar un valor con una clave en particular. Es una implementaci&amp;oacute;n particular de la estructura de datos m&amp;aacute;s general llamada &lt;em&gt;mapa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">Un &lt;em&gt;literal hexadecimal&lt;/em&gt; comienza con la secuencia de caracteres &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;0x&lt;/code&gt; ) y contin&amp;uacute;a como cualquier combinaci&amp;oacute;n (con al menos un d&amp;iacute;gito) de d&amp;iacute;gitos hexadecimales y guiones bajos.</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n literal&lt;/em&gt; consta de una de las formas &lt;a href=&quot;../tokens#literals&quot;&gt;literales&lt;/a&gt; descritas anteriormente. Describe directamente un n&amp;uacute;mero, car&amp;aacute;cter, cadena o valor booleano.</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">Una &lt;em&gt;variable local&lt;/em&gt; (o asignaci&amp;oacute;n &lt;em&gt;local de pila&lt;/em&gt; ) tiene un valor directamente, asignado dentro de la memoria de la pila. El valor es parte del marco de la pila.</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">Un &lt;em&gt;protector de f&amp;oacute;sforo&lt;/em&gt; es una condici&amp;oacute;n adicional &lt;code&gt;if&lt;/code&gt; se especifica despu&amp;eacute;s del patr&amp;oacute;n en un brazo de &lt;code&gt;match&lt;/code&gt; que tambi&amp;eacute;n debe coincidir, junto con el patr&amp;oacute;n de coincidencia, para que ese brazo sea elegido. Los protectores de f&amp;oacute;sforos son &amp;uacute;tiles para expresar ideas m&amp;aacute;s complejas de las que permite un patr&amp;oacute;n por s&amp;iacute; solo.</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">Una &lt;em&gt;llamada a&lt;/em&gt; un &lt;em&gt;m&amp;eacute;todo&lt;/em&gt; consta de una expresi&amp;oacute;n (el &lt;em&gt;receptor&lt;/em&gt; ) seguida de un solo punto, un segmento de ruta de expresi&amp;oacute;n y una lista de expresiones entre par&amp;eacute;ntesis. Las llamadas a &lt;a href=&quot;../items/associated-items#methods&quot;&gt;m&amp;eacute;todos&lt;/a&gt; se resuelven a m&amp;eacute;todos asociados en rasgos espec&amp;iacute;ficos, ya sea despach&amp;aacute;ndose est&amp;aacute;ticamente a un m&amp;eacute;todo si se conoce &lt;code&gt;self&lt;/code&gt; tipo exacto del lado izquierdo, o despachando din&amp;aacute;micamente si la expresi&amp;oacute;n del lado izquierdo es un &lt;a href=&quot;../types/trait-object&quot;&gt;objeto de rasgo&lt;/a&gt; indirecto .</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">Un &lt;em&gt;elemento de m&amp;oacute;dulo&lt;/em&gt; es un m&amp;oacute;dulo, entre llaves, nombrado y prefijado con la palabra clave &lt;code&gt;mod&lt;/code&gt; . Un elemento de m&amp;oacute;dulo introduce un m&amp;oacute;dulo nuevo con nombre en el &amp;aacute;rbol de m&amp;oacute;dulos que forman una caja. Los m&amp;oacute;dulos pueden anidarse arbitrariamente.</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">Un &lt;em&gt;literal num&amp;eacute;rico&lt;/em&gt; es un &lt;em&gt;literal entero&lt;/em&gt; o un &lt;em&gt;literal de punto flotante&lt;/em&gt; . La gram&amp;aacute;tica para reconocer los dos tipos de literales es mixta.</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">Una &lt;em&gt;ruta&lt;/em&gt; es una secuencia de uno o m&amp;aacute;s segmentos de ruta separados &lt;em&gt;l&amp;oacute;gicamente&lt;/em&gt; por un calificador de espacio de nombres ( &lt;code&gt;::&lt;/code&gt; ) . Si una ruta consta de un solo segmento, se refiere a un &lt;a href=&quot;items&quot;&gt;elemento&lt;/a&gt; o una &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; en un &amp;aacute;mbito de control local. Si una ruta tiene varios segmentos, siempre se refiere a un elemento.</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de lugar&lt;/em&gt; es una expresi&amp;oacute;n que representa una ubicaci&amp;oacute;n de memoria. Estas expresiones son &lt;a href=&quot;expressions/path-expr&quot;&gt;rutas&lt;/a&gt; que se refieren a variables locales, variables &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;ticas&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;desreferencias&lt;/a&gt; ( &lt;code&gt;*expr&lt;/code&gt; ), expresiones de &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexaci&amp;oacute;n de matrices&lt;/a&gt; ( &lt;code&gt;expr[expr]&lt;/code&gt; ), referencias de &lt;a href=&quot;expressions/field-expr&quot;&gt;campo&lt;/a&gt; ( &lt;code&gt;expr.f&lt;/code&gt; ) y expresiones de lugar entre par&amp;eacute;ntesis. Todas las dem&amp;aacute;s expresiones son expresiones de valor.</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">Un &lt;em&gt;puntero&lt;/em&gt; es un concepto general de una variable que contiene una direcci&amp;oacute;n en la memoria. Esta direcci&amp;oacute;n se refiere a, o &amp;ldquo;apunta a&amp;rdquo;, algunos otros datos. El tipo m&amp;aacute;s com&amp;uacute;n de puntero en Rust es una referencia, que aprendi&amp;oacute; en el Cap&amp;iacute;tulo 4. Las referencias se indican con el s&amp;iacute;mbolo &lt;code&gt;&amp;amp;&lt;/code&gt; y toman prestado el valor al que apuntan. No tienen ninguna capacidad especial m&amp;aacute;s que referirse a los datos. Adem&amp;aacute;s, no tienen sobrecarga y son el tipo de puntero que usamos con m&amp;aacute;s frecuencia.</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">Una &lt;em&gt;ruta relativa&lt;/em&gt; comienza desde el m&amp;oacute;dulo actual y usa &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;super&lt;/code&gt; o un identificador en el m&amp;oacute;dulo actual.</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">Un tipo &lt;em&gt;escalar&lt;/em&gt; representa un valor &amp;uacute;nico. Rust tiene cuatro tipos escalares principales: enteros, n&amp;uacute;meros de punto flotante, booleanos y caracteres. Puede reconocerlos de otros lenguajes de programaci&amp;oacute;n. Veamos c&amp;oacute;mo funcionan en Rust.</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n&lt;/em&gt; es un componente de un &lt;a href=&quot;expressions/block-expr&quot;&gt;bloque&lt;/a&gt; , que a su vez es un componente de una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; o &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n&lt;/a&gt; externa .</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">Un &lt;em&gt;elemento est&amp;aacute;tico&lt;/em&gt; es similar a una &lt;a href=&quot;constant-items&quot;&gt;constante&lt;/a&gt; , excepto que representa una ubicaci&amp;oacute;n de memoria precisa en el programa. Todas las referencias a la est&amp;aacute;tica se refieren a la misma ubicaci&amp;oacute;n de memoria. Los art&amp;iacute;culos est&amp;aacute;ticos tienen una vida &amp;uacute;til &lt;code&gt;static&lt;/code&gt; , que sobrevive a todas las dem&amp;aacute;s vidas en un programa Rust. Los elementos est&amp;aacute;ticos no &lt;code&gt;mut&lt;/code&gt; que contienen un tipo que no es &lt;a href=&quot;../interior-mutability&quot;&gt;mutable interior&lt;/a&gt; se pueden colocar en la memoria de s&amp;oacute;lo lectura. Los elementos est&amp;aacute;ticos no llaman a la &lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; al final del programa.</target>
        </trans-unit>
        <trans-unit id="9ed445848ff0ebfb7d1082c79316c3f0dc94cf17" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">Un &lt;em&gt;literal de cadena&lt;/em&gt; es una secuencia de cualquier car&amp;aacute;cter Unicode encerrado entre dos caracteres &lt;code&gt;U+0022&lt;/code&gt; (comillas dobles), con la excepci&amp;oacute;n del propio &lt;code&gt;U+0022&lt;/code&gt; , que debe &lt;em&gt;escaparse&lt;/em&gt; con un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; precedente ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">Un &lt;em&gt;segmento de cadena&lt;/em&gt; es una referencia a parte de una &lt;code&gt;String&lt;/code&gt; y tiene este aspecto:</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">Una &lt;em&gt;cadena&lt;/em&gt; es una colecci&amp;oacute;n de caracteres. Hemos mencionado el tipo &lt;code&gt;String&lt;/code&gt; anteriormente, pero en este cap&amp;iacute;tulo hablaremos sobre &amp;eacute;l en profundidad.</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de estructura&lt;/em&gt; crea una estructura o un valor de uni&amp;oacute;n. Consiste en una ruta a una &lt;a href=&quot;../items/structs&quot;&gt;estructura&lt;/a&gt; o elemento de &lt;a href=&quot;../items/unions&quot;&gt;uni&amp;oacute;n&lt;/a&gt; seguida de los valores de los campos del elemento. Hay tres formas de expresiones de estructura: estructura, tupla y unidad.</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Una &lt;em&gt;estructura&lt;/em&gt; es un tipo de &lt;a href=&quot;../types/struct&quot;&gt;estructura&lt;/a&gt; nominal definido con la palabra clave &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">Una &lt;em&gt;estructura&lt;/em&gt; , o &lt;em&gt;estructura&lt;/em&gt; , es un tipo de datos personalizado que le permite nombrar y empaquetar varios valores relacionados que forman un grupo significativo. Si est&amp;aacute; familiarizado con un lenguaje orientado a objetos, una &lt;em&gt;estructura&lt;/em&gt; es como los atributos de datos de un objeto. En este cap&amp;iacute;tulo, compararemos y contrastaremos tuplas con estructuras, demostraremos c&amp;oacute;mo usar estructuras y discutiremos c&amp;oacute;mo definir m&amp;eacute;todos y funciones asociadas para especificar el comportamiento asociado con los datos de una estructura. Las estructuras y enumeraciones (discutidas en el Cap&amp;iacute;tulo 6) son los bloques de construcci&amp;oacute;n para crear nuevos tipos en el dominio de su programa para aprovechar al m&amp;aacute;ximo la verificaci&amp;oacute;n de tipos en tiempo de compilaci&amp;oacute;n de Rust.</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">Un &lt;em&gt;doble de prueba&lt;/em&gt; es el concepto de programaci&amp;oacute;n general para un tipo utilizado en lugar de otro tipo durante la prueba. &lt;em&gt;Los objetos simulados&lt;/em&gt; son tipos espec&amp;iacute;ficos de dobles de prueba que registran lo que sucede durante una prueba para que pueda afirmar que se llevaron a cabo las acciones correctas.</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">Un &lt;em&gt;grupo de subprocesos&lt;/em&gt; es un grupo de subprocesos generados que est&amp;aacute;n esperando y listos para manejar una tarea. Cuando el programa recibe una nueva tarea, asigna uno de los subprocesos en el grupo a la tarea, y ese subproceso procesar&amp;aacute; la tarea. Los subprocesos restantes del grupo est&amp;aacute;n disponibles para manejar cualquier otra tarea que se presente mientras se procesa el primer subproceso. Cuando el primer subproceso termina de procesar su tarea, se devuelve al grupo de subprocesos inactivos, listo para manejar una nueva tarea. Un grupo de subprocesos le permite procesar conexiones al mismo tiempo, aumentando el rendimiento de su servidor.</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">Una &lt;em&gt;implementaci&amp;oacute;n de rasgo&lt;/em&gt; se define como una implementaci&amp;oacute;n inherente excepto que las declaraciones de tipo gen&amp;eacute;rico opcionales van seguidas de un &lt;a href=&quot;traits&quot;&gt;rasgo&lt;/a&gt; seguido de la palabra clave &lt;code&gt;for&lt;/code&gt; . Seguido de un camino hacia un tipo nominal.</target>
        </trans-unit>
        <trans-unit id="61547573b3bf424e11f1f4f9cd8d9184f5546ee1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. A trait object implements all specified traits as well as their supertraits (if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">Un &lt;em&gt;objeto de rasgo&lt;/em&gt; es un valor opaco de otro tipo que implementa un conjunto de rasgos. El conjunto de rasgos se compone de un &lt;em&gt;rasgo base &lt;/em&gt;&lt;a href=&quot;../items/traits#object-safety&quot;&gt;seguro para objetos&lt;/a&gt; m&amp;aacute;s cualquier n&amp;uacute;mero de &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;rasgos autom&amp;aacute;ticos&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">Un &lt;em&gt;rasgo&lt;/em&gt; describe una interfaz abstracta que los tipos pueden implementar. Esta interfaz consta de &lt;a href=&quot;associated-items&quot;&gt;elementos asociados&lt;/a&gt; , que vienen en tres variedades:</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">Un &lt;em&gt;rasgo&lt;/em&gt; le dice al compilador de Rust sobre la funcionalidad que tiene un tipo en particular y que puede compartir con otros tipos. Podemos utilizar rasgos para definir el comportamiento compartido de forma abstracta. Podemos usar l&amp;iacute;mites de rasgos para especificar que un gen&amp;eacute;rico puede ser cualquier tipo que tenga cierto comportamiento.</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">Un &lt;em&gt;&amp;iacute;ndice de tupla&lt;/em&gt; es &lt;code&gt;0&lt;/code&gt; o comienza con un &lt;em&gt;d&amp;iacute;gito decimal distinto de cero&lt;/em&gt; y contin&amp;uacute;a con cero o m&amp;aacute;s d&amp;iacute;gitos decimales. Los &amp;iacute;ndices de &lt;a href=&quot;items/structs&quot;&gt;tupla&lt;/a&gt; se utilizan para hacer referencia a los campos de &lt;a href=&quot;types/tuple&quot;&gt;tuplas&lt;/a&gt; , estructuras de &lt;a href=&quot;items/enumerations&quot;&gt;tuplas&lt;/a&gt; y variantes de tuplas .</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">Una &lt;em&gt;estructura de tupla&lt;/em&gt; es un tipo de &lt;a href=&quot;../types/tuple&quot;&gt;tupla&lt;/a&gt; nominal , tambi&amp;eacute;n definida con la palabra clave &lt;code&gt;struct&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">Un tipo de &lt;em&gt;estructura de tupla&lt;/em&gt; es como un tipo de estructura, excepto que los campos son an&amp;oacute;nimos.</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">Un &lt;em&gt;alias de tipo&lt;/em&gt; define un nuevo nombre para un &lt;a href=&quot;../types&quot;&gt;tipo&lt;/a&gt; existente . Los alias de tipo se declaran con el &lt;code&gt;type&lt;/code&gt; palabra clave . Cada valor tiene un tipo &amp;uacute;nico y espec&amp;iacute;fico, pero puede implementar varios rasgos diferentes o ser compatible con varias restricciones de tipo diferentes.</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de tipo&lt;/em&gt; como se define en la regla gramatical de &lt;em&gt;tipo&lt;/em&gt; anterior es la sintaxis para referirse a un tipo. Puede referirse a:</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">Un &lt;em&gt;tipo de uni&amp;oacute;n&lt;/em&gt; es una &lt;em&gt;uni&amp;oacute;n de tipo&lt;/em&gt; C heterog&amp;eacute;nea y nominal, indicada por el nombre de un &lt;a href=&quot;../items/unions&quot;&gt;elemento de &lt;/a&gt; &lt;code&gt;union&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">Una &lt;em&gt;estructura similar a&lt;/em&gt; una &lt;em&gt;unidad&lt;/em&gt; es una estructura sin campos, definida dejando fuera la lista de campos por completo. Tal estructura define impl&amp;iacute;citamente una constante de su tipo con el mismo nombre. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">Un tipo de &lt;em&gt;estructura similar a&lt;/em&gt; una &lt;em&gt;unidad&lt;/em&gt; es como un tipo de estructura, excepto que no tiene campos. El &amp;uacute;nico valor construido por la &lt;a href=&quot;../expressions/struct-expr&quot;&gt;expresi&amp;oacute;n de estructura&lt;/a&gt; asociada es el &amp;uacute;nico valor que habita dicho tipo.</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">Una &lt;em&gt;declaraci&amp;oacute;n de uso&lt;/em&gt; crea uno o m&amp;aacute;s enlaces de nombres locales sin&amp;oacute;nimo de alguna otra &lt;a href=&quot;../paths&quot;&gt;ruta&lt;/a&gt; . Por lo general, se &lt;code&gt;use&lt;/code&gt; una declaraci&amp;oacute;n de uso para acortar la ruta requerida para hacer referencia a un elemento de m&amp;oacute;dulo. Estas declaraciones pueden aparecer en &lt;a href=&quot;modules&quot;&gt;m&amp;oacute;dulos&lt;/a&gt; y &lt;a href=&quot;../expressions/block-expr&quot;&gt;bloques&lt;/a&gt; , generalmente en la parte superior.</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">Una &lt;em&gt;expresi&amp;oacute;n de valor&lt;/em&gt; es una expresi&amp;oacute;n que representa un valor real.</target>
        </trans-unit>
        <trans-unit id="e6fd1c9fb448dc3050e431f7efdd6fccf7fb69e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">Una &lt;em&gt;variable&lt;/em&gt; es un componente de un marco de pila, ya sea un par&amp;aacute;metro de funci&amp;oacute;n con nombre, un &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporal&lt;/a&gt; an&amp;oacute;nimo o una variable local con nombre.</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">Un &lt;em&gt;vector le&lt;/em&gt; permite almacenar un n&amp;uacute;mero variable de valores uno al lado del otro.</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">Un &lt;em&gt;escape de espacio en blanco&lt;/em&gt; es uno de los caracteres &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) o &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; ), que denota los valores Unicode &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) o &lt;code&gt;U+0009&lt;/code&gt; (HT) respectivamente.</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">Un &lt;em&gt;escape de espacio en blanco&lt;/em&gt; es uno de los caracteres &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) o &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; ), que denota los valores de bytes &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) o &lt;code&gt;0x09&lt;/code&gt; (ASCII HT ) respectivamente.</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">Un &lt;em&gt;espacio de trabajo&lt;/em&gt; es un conjunto de paquetes que comparten el mismo &lt;em&gt;Cargo.lock&lt;/em&gt; y el mismo directorio de salida. Hagamos un proyecto usando un espacio de trabajo; usaremos c&amp;oacute;digo trivial para poder concentrarnos en la estructura del espacio de trabajo. Hay varias formas de estructurar un espacio de trabajo; vamos a mostrar una forma com&amp;uacute;n. Tendremos un espacio de trabajo que contiene un binario y dos bibliotecas. El binario, que proporcionar&amp;aacute; la funcionalidad principal, depender&amp;aacute; de las dos bibliotecas. Una biblioteca proporcionar&amp;aacute; una funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; y una segunda biblioteca una funci&amp;oacute;n &lt;code&gt;add_two&lt;/code&gt; . Estas tres cajas formar&amp;aacute;n parte del mismo espacio de trabajo. Comenzaremos creando un nuevo directorio para el espacio de trabajo:</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">Un sistema &lt;strong&gt;multiprocesador&lt;/strong&gt; que ejecuta m&amp;uacute;ltiples subprocesos de hardware al mismo tiempo: en escenarios de m&amp;uacute;ltiples subprocesos, puede usar dos tipos de primitivas para lidiar con la sincronizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">Una operaci&amp;oacute;n de &lt;strong&gt;env&amp;iacute;o&lt;/strong&gt; solo puede fallar si el extremo receptor de un canal est&amp;aacute; desconectado, lo que implica que los datos nunca podr&amp;iacute;an recibirse. El error contiene los datos que se env&amp;iacute;an como una carga &amp;uacute;til para que se puedan recuperar.</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">Un &lt;strong&gt;solo procesador que&lt;/strong&gt; ejecuta instrucciones &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;fuera de orden&lt;/a&gt; : las CPU modernas son capaces de una ejecuci&amp;oacute;n &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superescalar&lt;/a&gt; , es decir, pueden ejecutarse varias instrucciones al mismo tiempo, aunque el c&amp;oacute;digo m&amp;aacute;quina describa un proceso secuencial.</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">En cambio, un &amp;aacute;rbol B hace que cada nodo contenga elementos B-1 a 2B-1 en una matriz contigua. Al hacer esto, reducimos el n&amp;uacute;mero de asignaciones en un factor de B y mejoramos la eficiencia de la cach&amp;eacute; en las b&amp;uacute;squedas. Sin embargo, esto significa que las b&amp;uacute;squedas tendr&amp;aacute;n que hacer &lt;em&gt;m&amp;aacute;s&lt;/em&gt; comparaciones en promedio. El n&amp;uacute;mero exacto de comparaciones depende de la estrategia de b&amp;uacute;squeda de nodos utilizada. Para una eficiencia de cach&amp;eacute; &amp;oacute;ptima, se pueden buscar los nodos linealmente. Para realizar comparaciones &amp;oacute;ptimas, se puede buscar en el nodo mediante una b&amp;uacute;squeda binaria. Como compromiso, tambi&amp;eacute;n se podr&amp;iacute;a realizar una b&amp;uacute;squeda lineal que inicialmente solo verifica cada i- &lt;sup&gt;&amp;eacute;simo&lt;/sup&gt; elemento para alguna elecci&amp;oacute;n de i.</target>
        </trans-unit>
        <trans-unit id="4c64fcf1b73694ea8bba81897d2a64705afb1b18" translate="yes" xml:space="preserve">
          <source>A C-variadic type is used to give an undefined number of parameters to a given function (like &lt;code&gt;printf&lt;/code&gt; in C). The equivalent in Rust would be to use macros directly (like &lt;code&gt;println!&lt;/code&gt; for example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">Una mirada más cercana a una solicitud de HTTP</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">Una condición variable</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Un binario o biblioteca del óxido.</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">Un programa Rust tiene idéntico significado si cada elemento de espacio en blanco se sustituye por cualquier otro elemento de espacio en blanco legal,como por ejemplo un único carácter de espacio.</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Un archivo de origen de Rust describe un m&amp;oacute;dulo, el nombre y la ubicaci&amp;oacute;n del cual, en el &amp;aacute;rbol de m&amp;oacute;dulos de la caja actual, se definen desde fuera del archivo de origen: ya sea por un elemento de &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;m&amp;oacute;dulo&lt;/em&gt;&lt;/a&gt; expl&amp;iacute;cito en un archivo de origen de referencia, o por el nombre del caja en s&amp;iacute;. Cada archivo fuente es un m&amp;oacute;dulo, pero no todos los m&amp;oacute;dulos necesitan su propio archivo fuente: las &lt;a href=&quot;items/modules&quot;&gt;definiciones de m&amp;oacute;dulo&lt;/a&gt; se pueden anidar dentro de un archivo.</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">Un atajo para propagar errores: el &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operador</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">Un servidor de socorro TCP,escuchando las conexiones.</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">Un flujo TCP entre un enchufe local y uno remoto.</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">Un toque de refactorización</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">Un recorrido por la biblioteca de The Rust Standard</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">Un enchufe UDP.</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">Un cordón UTF-8 codificado,cultivable.</target>
        </trans-unit>
        <trans-unit id="9de745a43beb358e074abd87790ad347e9b21ca2" translate="yes" xml:space="preserve">
          <source>A UTF-8&amp;ndash;encoded, growable string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">Un zócalo de datagramas de Unix.</target>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">Un enchufe de corriente Unix.</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">Un caso de uso para la mutación interior:Objetos de imitación</target>
        </trans-unit>
        <trans-unit id="822d2ee37fadc9a2c447d0ca642e7e4a4d011579" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Un prefijo de ruta de Windows, por ejemplo, &lt;code&gt;C:&lt;/code&gt; o &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41a63844a54d0452136942153b7bfc3f9e8d7950" translate="yes" xml:space="preserve">
          <source>A backtrace has been captured and the &lt;code&gt;Backtrace&lt;/code&gt; should print reasonable information when rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063c41d44c26a8e514637789567756dedf001744" translate="yes" xml:space="preserve">
          <source>A backtrace is typically quite handy to attach to errors (e.g. types implementing &lt;code&gt;std::error::Error&lt;/code&gt;) to get a causal chain of where an error was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">Una barrera permite a múltiples hilos sincronizar el comienzo de algunos cálculos.</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una barrera bloquear&amp;aacute; &lt;code&gt;n&lt;/code&gt; -1 hilos que llaman a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; y luego activan todos los subprocesos a la vez cuando las &lt;code&gt;n&lt;/code&gt; - &amp;eacute;simas llamadas &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62ccc167e0423bac501b2cd57e5b7720dec15103" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">Un ejemplo básico:</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">Una declaraci&amp;oacute;n de cadena b&amp;aacute;sica del tipo &lt;code&gt;&amp;amp;str&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e58e2e213f635868b8917c1f64d97bcd94087385" translate="yes" xml:space="preserve">
          <source>A binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807a8b4172841ae84d2493b466a14c239a712c9e" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the &lt;code&gt;main()&lt;/code&gt; function. If there are multiple instances of this function, please rename one of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">Un binario solo puede tener un punto de entrada y, por defecto, ese punto de entrada es la funci&amp;oacute;n &lt;code&gt;main()&lt;/code&gt; . Si hay varias de estas funciones, cambie el nombre de una.</target>
        </trans-unit>
        <trans-unit id="66f8440b5cbe5979ef5cd4aca43bf502a1ba0914" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">Se intentó una operación binaria en un tipo que no la soporta.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">Una unión ensombreció algo que no debería.</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">Una expresión de bloque como la expresión de la cola de otra expresión de bloque.</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">Un bloque de c&amp;oacute;digo puede tener el prefijo &lt;code&gt;unsafe&lt;/code&gt; palabra clave insegura para permitir &lt;a href=&quot;../unsafety&quot;&gt;operaciones inseguras&lt;/a&gt; . Ejemplos:</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">Un bloque de c&amp;oacute;digo puede tener el prefijo &lt;code&gt;unsafe&lt;/code&gt; palabra clave insegura , para permitir llamar a funciones &lt;code&gt;unsafe&lt;/code&gt; o desreferenciar punteros en bruto dentro de una funci&amp;oacute;n segura.</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">Una entrada de blog comienza como un borrador vacío.</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">Un tipo booleano que puede ser compartido con seguridad entre hilos.</target>
        </trans-unit>
        <trans-unit id="eb779fca6863a6a0d358d8e696c27d09f35c87e4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">Se intentó un préstamo de una constante que contenía la mutabilidad interior.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="6c3704913d69bb40474f716695cc894d7bfa528c" translate="yes" xml:space="preserve">
          <source>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f237c3c1919eddd418933b1a63f322a0d0d2a0eb" translate="yes" xml:space="preserve">
          <source>A borrowed value was moved out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2fc820fbc3d301d2c71b19ff6713c60dff7377" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">Una variable prestada fue utilizada por un cierre.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="b7c0d93da848c216d8d60ef97d23c6ae7dfef33f" translate="yes" xml:space="preserve">
          <source>A break expression is normally associated with the innermost loop enclosing the &lt;code&gt;break&lt;/code&gt; but a label can be used to specify which enclosing loop is affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">Una direcci&amp;oacute;n de difusi&amp;oacute;n tiene todos los octetos establecidos en 255 como se define en &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">Un amortiguador que es demasiado pequeño:</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">Un tipo de tamp&amp;oacute;n usado con &lt;code&gt;Read::read_vectored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">Un tipo de tamp&amp;oacute;n usado con &lt;code&gt;Write::write_vectored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">Un constructor para la computación donde en un HashMap se almacenaría un par llave-valor.</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">Un constructor solía crear directorios de varias maneras.</target>
        </trans-unit>
        <trans-unit id="d9b7dd70756681f35180b19cd1bfebd1be340c71" translate="yes" xml:space="preserve">
          <source>A builtin-macro was defined more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3712794ff88bfb37526db3c27354e391cdfb3531" translate="yes" xml:space="preserve">
          <source>A by-value &lt;a href=&quot;../primitive.array&quot;&gt;array&lt;/a&gt; iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1dde52635a5e1dfcc3c9c412ee03038fd5a1fd" translate="yes" xml:space="preserve">
          <source>A byte constant wasn't correctly ended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358ac47a7f574535f0a6c2b6627900a1db482bcb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;Drop::drop&lt;/code&gt; for that value, if this special &lt;code&gt;Drop&lt;/code&gt; trait is implemented for its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">Una llamada a &lt;code&gt;park&lt;/code&gt; no garantiza que el hilo permanezca aparcado para siempre, y las personas que llaman deben estar preparadas para esta posibilidad.</target>
        </trans-unit>
        <trans-unit id="310114efe1d071325aac9ee697835f3fab748547" translate="yes" xml:space="preserve">
          <source>A captured OS thread stack backtrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068d1bfcec9a1ae7628a6bb97579dd58498f1145" translate="yes" xml:space="preserve">
          <source>A captured variable in a closure may not live long enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">Se intentó una escayola entre un puntero delgado y uno gordo.</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">Se intent&amp;oacute; lanzar a &lt;code&gt;char&lt;/code&gt; en un tipo que no sea &lt;code&gt;u8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">Se intentó hacer un molde a un tipo sin tamaño.</target>
        </trans-unit>
        <trans-unit id="8ca946f31b782b50520401ae5f6d2242f47dbf2a" translate="yes" xml:space="preserve">
          <source>A cell which can be written to only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">Un canal en programaci&amp;oacute;n tiene dos mitades: un transmisor y un receptor. La mitad del transmisor es la ubicaci&amp;oacute;n corriente arriba donde pones los patitos de goma en el r&amp;iacute;o, y la mitad del receptor es donde el pato de goma termina corriente abajo. Una parte de su c&amp;oacute;digo llama a m&amp;eacute;todos en el transmisor con los datos que desea enviar, y otra parte verifica el extremo receptor para ver si llegan mensajes. Se dice que un canal est&amp;aacute; &lt;em&gt;cerrado&lt;/em&gt; si se cae la mitad del transmisor o del receptor.</target>
        </trans-unit>
        <trans-unit id="9b271c9cb4969ff9e8017b48dea5ee7ea287981f" translate="yes" xml:space="preserve">
          <source>A character literal wasn't ended with a quote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">Un tipo de personaje.</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">Una clasificación de números de punto flotante.</target>
        </trans-unit>
        <trans-unit id="dea8ae8b6b70c73b2cce436aaeecb02e010d0c2b" translate="yes" xml:space="preserve">
          <source>A clobber was surrounded by braces in the &lt;code&gt;llvm_asm&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">Un puntero inteligente de clonación y escritura.</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">Una expresi&amp;oacute;n de cierre denota una funci&amp;oacute;n que asigna una lista de par&amp;aacute;metros a la expresi&amp;oacute;n que sigue a los par&amp;aacute;metros. Al igual que un &lt;a href=&quot;../statements#let-statements&quot;&gt;enlace &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; , los par&amp;aacute;metros son &lt;a href=&quot;../patterns&quot;&gt;patrones&lt;/a&gt; irrefutables , cuyo tipo de anotaci&amp;oacute;n es opcional y se deducir&amp;aacute; del contexto si no se da. Cada expresi&amp;oacute;n de cierre tiene un tipo &amp;uacute;nico y an&amp;oacute;nimo.</target>
        </trans-unit>
        <trans-unit id="229f7ae12c2338583566d98b6347b250aaf7fe51" translate="yes" xml:space="preserve">
          <source>A closure has been used as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">Un cierre es &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; si no captura ning&amp;uacute;n valor por referencia &amp;uacute;nica inmutable o mutable, y si todos los valores que captura al copiar o mover son &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un cierre es &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; si todas las variables capturadas por una referencia inmutable no &amp;uacute;nica est&amp;aacute;n &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; , y todos los valores capturados por una referencia, copia o movimiento &amp;uacute;nico inmutable o mutable son &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un cierre es &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; si todas las variables capturadas son &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">Se construyó un cierre o generador que hace referencia a su propio tipo.</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">Se utilizó un cierre pero no se implementó el rasgo esperado.</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">Un cierre que no se mueve fuera de ninguna variable capturada implementa &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , lo que indica que puede ser llamado por referencia mutable.</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">Un cierre que no mute ni se mueva fuera de ninguna variable capturada implementa &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , lo que indica que se puede llamar por referencia compartida.</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">La coacción sólo puede producirse en determinados lugares de coacción de un programa;se trata típicamente de lugares en los que el tipo deseado es explícito o puede derivarse por propagación de tipos explícitos (sin inferencia de tipo).Los posibles sitios de coacción son:</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">Conjunto de métodos necesarios para dar formato a un mensaje en un flujo.</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">Un ejemplo com&amp;uacute;n es el m&amp;eacute;todo de &lt;code&gt;collect&lt;/code&gt; en &lt;code&gt;Iterator&lt;/code&gt; . Tiene un par&amp;aacute;metro de tipo gen&amp;eacute;rico con un l&amp;iacute;mite &lt;code&gt;FromIterator&lt;/code&gt; , que para un iterador &lt;code&gt;char&lt;/code&gt; es implementado por &lt;code&gt;Vec&lt;/code&gt; y &lt;code&gt;String&lt;/code&gt; entre otros. Considere el siguiente fragmento que invierte los caracteres de una cadena:</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">Una interfaz común para una clase de tipos.</target>
        </trans-unit>
        <trans-unit id="8baf44157a38997462218326dfa5b36c89567539" translate="yes" xml:space="preserve">
          <source>A common interface for a group of types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">Un error com&amp;uacute;n es pensar que &quot;las direcciones de enlace local de unidifusi&amp;oacute;n comienzan con &lt;code&gt;fe80::&lt;/code&gt; &quot;, pero el &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291 en&lt;/a&gt; realidad define un formato m&amp;aacute;s estricto para estas direcciones:</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">Un problema com&amp;uacute;n con el uso de valores devueltos para indicar errores es que es f&amp;aacute;cil ignorar el valor devuelto, por lo que no se puede manejar el error. &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; se anota con el atributo &lt;code&gt;#[must_use]&lt;/code&gt; , que har&amp;aacute; que el compilador emita una advertencia cuando se ignore un valor de Resultado. Esto hace que &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; sea especialmente &amp;uacute;til con funciones que pueden encontrar errores pero que de otro modo no devuelven un valor &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">Un rasgo común para la capacidad de duplicar explícitamente un objeto.</target>
        </trans-unit>
        <trans-unit id="f3fcc76ff39756ffd2b4cb1d33e25cb209dbe4a4" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3bf37cba543ca385f5031852ec32495e2e84e3" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop_hint&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&amp;iexcl;Un uso com&amp;uacute;n para el &lt;code&gt;format!&lt;/code&gt; es la concatenaci&amp;oacute;n e interpolaci&amp;oacute;n de cadenas. &amp;iexcl;La misma convenci&amp;oacute;n se usa con la &lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;y &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;macros, seg&amp;uacute;n el destino previsto de la cadena.</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">Un uso com&amp;uacute;n de esta funci&amp;oacute;n es envenenar los recursos compartidos cuando se escribe c&amp;oacute;digo inseguro, marcando el &lt;code&gt;panicking&lt;/code&gt; cuando se llama a la &lt;code&gt;drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">Una forma com&amp;uacute;n de probar la funcionalidad es comparar el resultado del c&amp;oacute;digo bajo prueba con el valor que espera que devuelva el c&amp;oacute;digo para asegurarse de que sean iguales. &amp;iexcl;Podr&amp;iacute;as hacer esto usando la &lt;code&gt;assert!&lt;/code&gt; macro y pas&amp;aacute;ndole una expresi&amp;oacute;n usando el operador &lt;code&gt;==&lt;/code&gt; . Sin embargo, esta es una prueba tan com&amp;uacute;n que la biblioteca est&amp;aacute;ndar proporciona un par de macros &lt;code&gt;assert_eq!&lt;/code&gt; y &lt;code&gt;assert_ne!&lt;/code&gt; &amp;mdash;Para realizar esta prueba de manera m&amp;aacute;s conveniente. Estas macros comparan dos argumentos a favor de la igualdad o la desigualdad, respectivamente. Tambi&amp;eacute;n imprimir&amp;aacute;n los dos valores si falla la afirmaci&amp;oacute;n, lo que facilita ver &lt;em&gt;por qu&amp;eacute;&lt;/em&gt; fall&amp;oacute; la prueba; a la inversa, &lt;code&gt;assert!&lt;/code&gt; macro solo indica que obtuvo un &lt;code&gt;false&lt;/code&gt; valor para &lt;code&gt;==&lt;/code&gt; expresi&amp;oacute;n, no los valores que conducen al valor &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">Una forma com&amp;uacute;n de utilizar &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; es en combinaci&amp;oacute;n con &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; . Recuerde que &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; permite tener varios propietarios de algunos datos, pero solo brinda acceso inmutable a esos datos. Si tiene un &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; que contiene un &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , puede obtener un valor que puede tener varios propietarios &lt;em&gt;y&lt;/em&gt; que puede mutar.</target>
        </trans-unit>
        <trans-unit id="c3a2eb5105511775d59e5e4cd686eb5579136f33" translate="yes" xml:space="preserve">
          <source>A comparison like the one above, which ignores some fields of the struct, can be dangerous. It can easily lead to an unintended violation of the requirements for a partial equivalence relation. For example, if we kept the above implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;BookFormat&lt;/code&gt; and added an implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;Book&lt;/code&gt; (either via a &lt;code&gt;#[derive]&lt;/code&gt; or via the manual implementation from the first example) then the result would violate transitivity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">Nunca se emite un error de tiempo de compilación cuando se utiliza esta macro,independientemente de si la variable de entorno está presente o no.</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">Una valla de memoria del compilador.</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">Una barrera de memoria sólo para el compilador.</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">Una opción de configuración.Es verdadera si la opción está configurada y falsa si no está configurada.</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">Una consecuencia de las reglas de pr&amp;eacute;stamo es que cuando tienes un valor inmutable, no puedes pedirlo prestado de manera mutante. Por ejemplo, este c&amp;oacute;digo no se compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="82e92c5c9841d5d2d3e69bff0f6aeb9309a13f00" translate="yes" xml:space="preserve">
          <source>A constant item was initialized with something that is not a constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce86a2e004403aa5ba6b72a885c67d143829985" translate="yes" xml:space="preserve">
          <source>A constant value failed to get evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Un tipo de matriz de crecimiento contiguo con contenido asignado al mont&amp;oacute;n, escrito &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">Un tipo de matriz de crecimiento contiguo, escrito &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; pero pronunciado 'vector'.</target>
        </trans-unit>
        <trans-unit id="821a3f39751014be2886a42509e99ef71f4b3a2f" translate="yes" xml:space="preserve">
          <source>A control-flow expression was used inside a const context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">Una funci&amp;oacute;n de conveniencia que muestra un &lt;code&gt;io::Result&lt;/code&gt; a su llamador:</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">Un impl&amp;iacute;cito de conveniencia que delega al impl para &lt;code&gt;&amp;amp;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35a7bd82b1e1370c217a40362b5ca9b11be11f9d" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5815609ea9bdc6c8447adfe133c418ba6a0e628" translate="yes" xml:space="preserve">
          <source>A correct implementation could look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">Una caja es algo an&amp;aacute;loga a un &lt;em&gt;ensamblaje&lt;/em&gt; en el modelo CLI ECMA-335, una &lt;em&gt;biblioteca&lt;/em&gt; en el Administrador de compilaci&amp;oacute;n SML / NJ, una &lt;em&gt;unidad&lt;/em&gt; en el sistema de m&amp;oacute;dulos Owens y Flatt o una &lt;em&gt;configuraci&amp;oacute;n&lt;/em&gt; en Mesa.</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">Un cajón necesita un &quot;módulo de ayuda&quot; disponible a nivel mundial para sí mismo,pero no quiere exponer el módulo de ayuda como una API pública.Para lograrlo,la raíz de la jerarquía de la caja tendría un módulo privado que luego internamente tendría una &quot;API pública&quot;.Dado que toda la caja es descendiente de la raíz,entonces toda la caja local puede acceder a este módulo privado a través del segundo caso.</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">Una caja que contiene una &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n &lt;/a&gt; &lt;code&gt;main&lt;/code&gt; se puede compilar en un ejecutable. Si una funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; est&amp;aacute; presente, no debe tomar argumentos, no debe declarar ning&amp;uacute;n &lt;a href=&quot;trait-bounds&quot;&gt;rasgo o l&amp;iacute;mites de por vida&lt;/a&gt; , no debe tener &lt;a href=&quot;items/generics#where-clauses&quot;&gt;cl&amp;aacute;usulas where&lt;/a&gt; y su tipo de retorno debe ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">Una caja agrupar&amp;aacute; la funcionalidad relacionada en un &amp;aacute;mbito para que la funcionalidad sea f&amp;aacute;cil de compartir entre m&amp;uacute;ltiples proyectos. Por ejemplo, la caja &lt;code&gt;rand&lt;/code&gt; que usamos en el &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Cap&amp;iacute;tulo 2&lt;/a&gt; proporciona una funcionalidad que genera n&amp;uacute;meros aleatorios. Podemos usar esa funcionalidad en nuestros propios proyectos al incorporar la caja &lt;code&gt;rand&lt;/code&gt; al alcance de nuestro proyecto. Se puede acceder a toda la funcionalidad proporcionada por la caja &lt;code&gt;rand&lt;/code&gt; a trav&amp;eacute;s del nombre de la caja, &lt;code&gt;rand&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9489488427833bc0214d8f4c5f5a907ee47ae129" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">Se implementó un rasgo de exclusión cruzada en algo que no era un tipo de estructura o enumeración.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="521073eb4a9d5dea34971bbf2d3b43472252d22c" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt; with editing operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e765e383228431ae063a8d9a831d2b82107b6c73" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">Un ciclo entre punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; nunca se desasignar&amp;aacute;. Por esta raz&amp;oacute;n, &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; se utiliza para romper ciclos. Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; de los nodos principales a los hijos y &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">Un ciclo entre punteros de &lt;code&gt;Arc&lt;/code&gt; nunca se desasignar&amp;aacute;. Por esta raz&amp;oacute;n, &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; se utiliza para romper ciclos. Por ejemplo, un &amp;aacute;rbol podr&amp;iacute;a tener fuertes punteros &lt;code&gt;Arc&lt;/code&gt; de los nodos principales a los hijos y &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; punteros de los ni&amp;ntilde;os a sus padres.</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">Una estructura de datos está en un estado temporalmente inválido cuando el hilo entra en pánico.</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">Se puede generar una configuraci&amp;oacute;n predeterminada usando &lt;code&gt;Command::new(program)&lt;/code&gt; , donde el &lt;code&gt;program&lt;/code&gt; a proporciona una ruta al programa que se ejecutar&amp;aacute;. Los m&amp;eacute;todos de construcci&amp;oacute;n adicionales permiten cambiar la configuraci&amp;oacute;n (por ejemplo, agregando argumentos) antes de la generaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">En la aplicación de un rasgo se dio una definición de un método que no está en el rasgo aplicado.</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">Un discriminante en una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n no incluido en la definici&amp;oacute;n de tipo.</target>
        </trans-unit>
        <trans-unit id="1d4413773858071be2cda9c035b93d8adb5ed9c4" translate="yes" xml:space="preserve">
          <source>A discriminant value is present more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33398f8a1c82819cfc272eb4db0376550aceebc" translate="yes" xml:space="preserve">
          <source>A doc comment that is not attached to anything has been encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">Se encontró un comentario de documentación que no documenta nada.</target>
        </trans-unit>
        <trans-unit id="b5da65d7d41e577505a8697b6d53146c919ad568" translate="yes" xml:space="preserve">
          <source>A double quote byte string (&lt;code&gt;b&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c189219618ff090bbaf1c282c8ad43303eb7709" translate="yes" xml:space="preserve">
          <source>A double quote string (&lt;code&gt;&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">Un iterador de doble extremo con la dirección invertida.</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">Una cola de doble terminación implementada con un buffer de anillo cultivable.</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">Una lista doblemente vinculada con nodos propios.</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador para &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador para &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre los elementos de un &lt;code&gt;BinaryHeap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre los elementos de un &lt;code&gt;VecDeque&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre las entradas de un &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">Un iterador agotador sobre los elementos de un &lt;code&gt;HashSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0414ecefaa3523675384470efb07b95159dba45" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb2903d11786dcb8b8844e91d87fb7f80657414" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40d5a17630e0b8c5262cd5da85143e19cf981ab" translate="yes" xml:space="preserve">
          <source>A duration of zero time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">Un tipo de tamaño dinámico (DST)es un tipo sin un tamaño o alineación estáticamente conocido.</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">Una vista de tama&amp;ntilde;o din&amp;aacute;mico en una secuencia contigua, &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9b7bf32fab7bb231166bbede96c90271ed78811" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">Un atributo de característica llamado una característica que ha sido eliminada.</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">Un atributo de característica llamado característica que fue desautorizado en las banderas de la línea de comandos del compilador.</target>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">Una cerca 'A' que tiene (al menos) Sem&amp;aacute;ntica de orden de &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; , se sincroniza con una cerca 'B' con (al menos) Sem&amp;aacute;ntica de &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; , si y solo si existen operaciones X e Y, ambas operando sobre alg&amp;uacute;n objeto at&amp;oacute;mico 'M' tal que A se secuencia antes de X, Y se sincroniza antes de que B e Y observen el cambio a M. Esto proporciona una dependencia de suceder antes de A y B.</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">Una valla que tiene &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; pedidos, adem&amp;aacute;s de tener tanto &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; sem&amp;aacute;ntica, participa en el orden programa global de los dem&amp;aacute;s &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; operaciones y / o cercas.</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">Un acceso de campo es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar que se&lt;/a&gt; refiere a la ubicaci&amp;oacute;n de ese campo. Cuando la subexpresi&amp;oacute;n es &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt; , la expresi&amp;oacute;n del campo tambi&amp;eacute;n lo es.</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">No se encontró un archivo para un módulo fuera de línea.</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Una &amp;uacute;ltima raz&amp;oacute;n por la que Rust no nos permite indexar en una &lt;code&gt;String&lt;/code&gt; para obtener un car&amp;aacute;cter es que se espera que las operaciones de indexaci&amp;oacute;n siempre tomen un tiempo constante (O (1)). Pero no es posible garantizar ese rendimiento con una &lt;code&gt;String&lt;/code&gt; , porque Rust tendr&amp;iacute;a que recorrer el contenido desde el principio hasta el &amp;iacute;ndice para determinar cu&amp;aacute;ntos caracteres v&amp;aacute;lidos hab&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">Una secuencia heterog&amp;eacute;nea finita, &lt;code&gt;(T, U, ..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Una matriz de tama&amp;ntilde;o fijo, denotada &lt;code&gt;[T; N]&lt;/code&gt; , para el tipo de elemento, &lt;code&gt;T&lt;/code&gt; , y el tama&amp;ntilde;o constante de tiempo de compilaci&amp;oacute;n no negativo, &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">A de bucle es equivalente a la siguiente expresión de bloque.</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">Se requiere una cadena de formato para utilizar todos sus argumentos,de lo contrario es un error en tiempo de compilación.Puede referirse al mismo argumento más de una vez en la cadena de formato.</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">Una funci&amp;oacute;n anotada con el atributo de &lt;code&gt;test&lt;/code&gt; tambi&amp;eacute;n se puede anotar con el atributo &lt;code&gt;ignore&lt;/code&gt; . El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/em&gt; le dice al arn&amp;eacute;s de prueba que no ejecute esa funci&amp;oacute;n como prueba. Todav&amp;iacute;a se compilar&amp;aacute; cuando est&amp;eacute; en modo de prueba.</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">Una funci&amp;oacute;n anotada con el atributo de &lt;code&gt;test&lt;/code&gt; que devuelve &lt;code&gt;()&lt;/code&gt; tambi&amp;eacute;n se puede anotar con el atributo &lt;code&gt;should_panic&lt;/code&gt; . El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt; hace que la prueba solo pase si realmente entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">No se permite una llamada a la función en la expresión de inicialización de la const,porque el valor de la expresión debe conocerse en tiempo de compilación.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">Una funci&amp;oacute;n declarada en un bloque externo es impl&amp;iacute;citamente &lt;code&gt;unsafe&lt;/code&gt; . Cuando se coacciona a un puntero de funci&amp;oacute;n, una funci&amp;oacute;n declarada en un bloque externo tiene el tipo &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; , donde &lt;code&gt;'l1&lt;/code&gt; , ... &lt;code&gt;'lm&lt;/code&gt; son sus par&amp;aacute;metros de duraci&amp;oacute;n, &lt;code&gt;A1&lt;/code&gt; , ..., &lt;code&gt;An&lt;/code&gt; son los tipos declarados de sus par&amp;aacute;metros y &lt;code&gt;R&lt;/code&gt; es el tipo de retorno declarado.</target>
        </trans-unit>
        <trans-unit id="d0692343f061c0cd9d5ae6d4139b26c55c59ad9f" translate="yes" xml:space="preserve">
          <source>A function is using &lt;code&gt;continue&lt;/code&gt; keyword incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">Una función o un puntero de función.</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">La firma de una funci&amp;oacute;n debe declarar el n&amp;uacute;mero y tipo de par&amp;aacute;metros que tiene la funci&amp;oacute;n. Las macros, por otro lado, pueden tomar un n&amp;uacute;mero variable de par&amp;aacute;metros: podemos llamar a &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; con un argumento o &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; con dos argumentos. Adem&amp;aacute;s, las macros se expanden antes de que el compilador interprete el significado del c&amp;oacute;digo, por lo que una macro puede, por ejemplo, implementar un rasgo en un tipo determinado. Una funci&amp;oacute;n no puede, porque se llama en tiempo de ejecuci&amp;oacute;n y es necesario implementar un rasgo en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">Una funci&amp;oacute;n que tiene un par&amp;aacute;metro o devuelve solo n&amp;uacute;meros entre 1 y 100 podr&amp;iacute;a declarar en su firma que toma o devuelve un &lt;code&gt;Guess&lt;/code&gt; en lugar de un &lt;code&gt;i32&lt;/code&gt; y no necesitar&amp;iacute;a hacer ninguna verificaci&amp;oacute;n adicional en su cuerpo.</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">Una función que es opaca para el optimizador,para permitir que los puntos de referencia pretendan utilizar los resultados para ayudar a evitar la eliminación del código muerto.</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">Se declar&amp;oacute; una funci&amp;oacute;n con el atributo de &lt;code&gt;start&lt;/code&gt; con par&amp;aacute;metros de tipo.</target>
        </trans-unit>
        <trans-unit id="cc716e4e83b4efb34e4101d17ccb62e4b2b1eb26" translate="yes" xml:space="preserve">
          <source>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. The &lt;code&gt;Fn&lt;/code&gt; traits and &lt;code&gt;Sized&lt;/code&gt; are fundamental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0649f34bf1c96947359554a4e3b1fb6bd7f77d90" translate="yes" xml:space="preserve">
          <source>A fundamental type constructor is a type where implementing a &lt;a href=&quot;#blanket-implementation&quot;&gt;blanket implementation&lt;/a&gt; over it is a breaking change. &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, &lt;code&gt;Box&lt;/code&gt;, and &lt;code&gt;Pin&lt;/code&gt; are fundamental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">Un futuro es un valor que puede no haber terminado de computar todavía.Este tipo de &quot;valor asíncrono&quot; hace posible que un hilo continúe haciendo un trabajo útil mientras espera a que el valor esté disponible.</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">Un futuro representa un cálculo asíncrono.</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">Una generalizaci&amp;oacute;n de &lt;code&gt;Clone&lt;/code&gt; a datos prestados.</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">Una función genérica debe ser tratada de manera similar:</target>
        </trans-unit>
        <trans-unit id="47dc8336e1d401035013095c768eec4aaa7de80d" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">Se describió un tipo genérico utilizando paréntesis en lugar de paréntesis angulares.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">Un tipo gen&amp;eacute;rico donde uno o m&amp;aacute;s tipos asociados tienen asignaciones espec&amp;iacute;ficas (p. Ej., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">Una nota espantosa 👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">Una determinada pareja M se encarga de tres juegos:PRIMERA(M),ULTIMA(M)y SEGUIDA(M).</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">Un gran ejemplo de una situaci&amp;oacute;n en la que esta t&amp;eacute;cnica es &amp;uacute;til es la sobrecarga del operador. &lt;em&gt;La sobrecarga de operadores&lt;/em&gt; es personalizar el comportamiento de un operador (como &lt;code&gt;+&lt;/code&gt; ) en situaciones particulares.</target>
        </trans-unit>
        <trans-unit id="77b606312f70d0e0e8a4e81eb457af73b41943c1" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; does not permit zero-initialization: This will statically either panic, or do nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d1fa93ccd1713ed23cb21dd7e4493abed0a332" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; has invalid bit patterns: This will statically either panic, or do nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">Una protecci&amp;oacute;n para funciones inseguras que no se pueden ejecutar nunca si &lt;code&gt;T&lt;/code&gt; est&amp;aacute; deshabitado: esto entrar&amp;aacute; en p&amp;aacute;nico est&amp;aacute;ticamente o no har&amp;aacute; nada.</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">Un mango para la entrada estándar de un proceso infantil (stdin).</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">Un mango para la salida estándar de un proceso infantil (stdout).</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">Una manija para el error del proceso de un niño.</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">Un mango a un hilo.</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">Una manija para el flujo de salida estándar global del proceso actual.</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">Una manija para el flujo de error estándar de un proceso.</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">Una manija para el flujo de entrada estándar de un proceso.</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">Un mapa hash implementado con sondeo lineal y robo de cubos de Robin Hood.</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">Un mapa hash implementado con sondeo cuadrático y búsqueda SIMD.</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Un conjunto de hash implementado como &lt;code&gt;HashMap&lt;/code&gt; donde el valor es &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">Un tipo de hachís.</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">Una estructura de ayuda para el orden inverso.</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">Un rasgo de ayuda utilizado para las operaciones de indexación.</target>
        </trans-unit>
        <trans-unit id="29862de09ef195f3021bf8c1026b55bc84123b69" translate="yes" xml:space="preserve">
          <source>A incorrectly formatted &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; will produce an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">Se redefinió un ítem de langosta.</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">Un gran n&amp;uacute;mero de las estructuras proporcionadas por &lt;code&gt;std::io&lt;/code&gt; son para varias formas de iterar sobre E / S. Por ejemplo, &lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; &lt;/a&gt; se utiliza para dividir l&amp;iacute;neas:</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos a diferencia de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la diferencia de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la intersecci&amp;oacute;n de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la intersecci&amp;oacute;n de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la diferencia sim&amp;eacute;trica de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la diferencia sim&amp;eacute;trica de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la uni&amp;oacute;n de &lt;code&gt;BTreeSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">Un iterador perezoso que produce elementos en la uni&amp;oacute;n de &lt;code&gt;HashSet&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">Un desarrollador de bibliotecas necesita exponer la funcionalidad a las cajas que se vinculan con su biblioteca. Como consecuencia del primer caso, esto significa que todo lo que sea utilizable externamente debe ser &lt;code&gt;pub&lt;/code&gt; licarse desde la ra&amp;iacute;z hasta el elemento de destino. Cualquier art&amp;iacute;culo privado de la cadena no permitir&amp;aacute; los accesos externos.</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">Una vida aparece sólo en una unión de tipo asociado,y no en los tipos de entrada al rasgo.</target>
        </trans-unit>
        <trans-unit id="15786eaf619ace068790ae58d796d7da4d047a8c" translate="yes" xml:space="preserve">
          <source>A lifetime bound on a trait implementation was captured at an incorrect place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">Una vida atada no fue satisfecha.</target>
        </trans-unit>
        <trans-unit id="f5eb99d9ba1d633f5bab932159c4263f91c6e225" translate="yes" xml:space="preserve">
          <source>A lifetime cannot be determined in the given situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cad79ba7fd3784fc14fc3f6b2c2d3527062c63" translate="yes" xml:space="preserve">
          <source>A lifetime didn't match what was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2036255cc30a38458aebc41a1b7522c2030656d" translate="yes" xml:space="preserve">
          <source>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">Un nombre de por vida no puede ser declarado más de una vez en el mismo ámbito.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="315c1653fb8738d323beeedab26038fcdebdd0a1" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">Un nombre de toda la vida es la sombra de otro nombre de toda la vida.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="60dd9352a1988e94c38ce60166a9c885adb54457" translate="yes" xml:space="preserve">
          <source>A lifetime was declared more than once in the same scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c742ea21e8d68de6fe9c8cd053579ea9357b0ab" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">Se dio un nombre de enlace con un nombre vacío.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="7aff8ae0fa99ab18b982ebf4bf49db472c773b53" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">Se utilizó un enlace sin un parámetro de nombre.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">Un atributo de verificaci&amp;oacute;n de pelusa fue anulado por una directiva &lt;code&gt;forbid&lt;/code&gt; establecida como un atributo en un alcance adjunto, o en la l&amp;iacute;nea de comando con el &lt;code&gt;-F&lt;/code&gt; opci&amp;oacute;n -F .</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">Un cheque de pelusa nombra un patr&amp;oacute;n de codificaci&amp;oacute;n potencialmente no deseado, como un c&amp;oacute;digo inalcanzable o documentaci&amp;oacute;n omitida. Los atributos de pelusa &lt;code&gt;allow&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; , &lt;code&gt;deny&lt;/code&gt; y &lt;code&gt;forbid&lt;/code&gt; uso de la sintaxis de &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; para especificar una lista de nombres de pelusa para cambiar el nivel de pelusa de la entidad a la que se aplica el atributo.</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">Una lista de los elementos de idioma externos disponibles est&amp;aacute; disponible en &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="a93ce4eba1c20223d4f7efd374435922dc780a28" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">Una lista que especifica las categorías generales de errores de E/S.</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">Una lista con cada elemento, es decir, &lt;code&gt;[x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">Un literal es una expresi&amp;oacute;n que consta de un solo token, en lugar de una secuencia de tokens, que denota inmediata y directamente el valor que eval&amp;uacute;a, en lugar de referirse a &amp;eacute;l por su nombre o alguna otra regla de evaluaci&amp;oacute;n. Un literal es una forma de&lt;a href=&quot;const_eval#constant-expressions&quot;&gt; expresi&amp;oacute;n constante&lt;/a&gt; , por lo que se eval&amp;uacute;a (principalmente) en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1857afd88875f6678401e5a6388b40ec5e076688" translate="yes" xml:space="preserve">
          <source>A literal value was used inside &lt;code&gt;#[derive]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">Se usó un literal en un atributo incorporado que no soporta los literales.</target>
        </trans-unit>
        <trans-unit id="efa9c544d88ff2ed4857caf7a6d5b87ab71f9e34" translate="yes" xml:space="preserve">
          <source>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the &lt;code&gt;Island&lt;/code&gt; trait, you need to put a doc comment before it, not inside it. Same goes for the &lt;code&gt;lost&lt;/code&gt; method: the doc comment needs to be before it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">Una referencia bloqueada al &lt;code&gt;Stderr&lt;/code&gt; mango .</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">Una referencia cerrada al &lt;code&gt;Stdin&lt;/code&gt; mango .</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">Una referencia bloqueada al &lt;code&gt;Stdout&lt;/code&gt; identificador .</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">Una entrada est&amp;aacute;ndar bloqueada implementa &lt;code&gt;BufRead&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3af527db8725fae95a62589160c6f0f2118456fd" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de bucle puede tener opcionalmente una &lt;em&gt;etiqueta&lt;/em&gt; . La etiqueta est&amp;aacute; escrita como una vida que precede a la expresi&amp;oacute;n de bucle, como en &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; , &lt;code&gt;'bar: while false {}&lt;/code&gt; , &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; . Si hay una etiqueta, entonces las expresiones etiquetadas &lt;code&gt;break&lt;/code&gt; y &lt;code&gt;continue&lt;/code&gt; anidadas dentro de este bucle pueden salir de este bucle o devolver el control a su cabeza. Ver &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;expresiones de ruptura&lt;/a&gt; y &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continuar expresiones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="621a2333164d1c1ddcc3e28445c529a5edcd0f4d" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used inside a closure but outside of any loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49094ffad160345ac5b867a45ab1d0476b39ead" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used outside of a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">Se puede obtener un decodificador con p&amp;eacute;rdida reemplazando &lt;code&gt;Err&lt;/code&gt; resultados de con el car&amp;aacute;cter de reemplazo:</target>
        </trans-unit>
        <trans-unit id="aaa61df7a5c37f0e9baf2b1d7a2af95d48009664" translate="yes" xml:space="preserve">
          <source>A lower range wasn't less than the upper range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">Una macroinvocación ejecuta una macro en tiempo de compilación y reemplaza la invocación con el resultado de la macro.Las macros pueden ser invocadas en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">No se encontró una macro que figurara en la lista de importaciones.</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">Una macro para probar en &lt;em&gt;tiempo&lt;/em&gt; de &lt;em&gt;ejecuci&amp;oacute;n&lt;/em&gt; si una funci&amp;oacute;n de CPU est&amp;aacute; disponible en plataformas x86 / x86-64.</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">Uno de los principales objetivos del compilador es asegurar que una biblioteca nunca aparezca más de una vez en ningún artefacto.Por ejemplo,si las bibliotecas dinámicas B y C estuvieran vinculadas estáticamente a la biblioteca A,entonces una caja no podría vincularse a B y C juntas porque habría dos copias de A.El compilador permite mezclar los formatos rlib y dylib,pero esta restricción debe ser satisfecha.</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">Un mapa basado en un árbol B.</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">Un rasgo marcador que representa los tipos en los que una referencia compartida se considera segura.</target>
        </trans-unit>
        <trans-unit id="3bc97c0d55aa2cae1126bc3f3d83ef27e23658de" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; can be used for a &lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">Un rasgo de marcador para expresar que un &lt;code&gt;ReverseSearcher&lt;/code&gt; se puede usar para un &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementaci&amp;oacute;n de .</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Un rasgo marcador que representa los tipos &quot;seguros contra el pánico&quot; en Rust.</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">Un tipo de marcador que no implementa &lt;code&gt;Unpin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Una medida de un reloj mon&amp;oacute;tonamente no decreciente. Opaco y &amp;uacute;til solo con &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">Una medida del reloj del sistema,útil para hablar con entidades externas como el sistema de archivos u otros procesos.</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">Un asignador de memoria que se puede registrar como predeterminado de la biblioteca est&amp;aacute;ndar a trav&amp;eacute;s de los atributos &lt;code&gt;#[global_allocator]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36390b8dd6062ca0b9666a02db751bef68ddc91f" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default through the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">Una metavariable debe aparecer exactamente en el mismo n&amp;uacute;mero, tipo y orden de anidaci&amp;oacute;n de repeticiones en el transcriptor que en el comparador. Entonces, para el comparador &lt;code&gt;$( $i:ident ),*&lt;/code&gt; , los transcriptores &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; , &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; y &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; son todo ilegal, pero &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; es correcto y reemplaza una lista de identificadores separados por comas por una lista separada por punto y coma.</target>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">Un método fue llamado en un puntero crudo cuyo tipo interior no se conocía completamente.</target>
        </trans-unit>
        <trans-unit id="da23ec6794439455d8bda2444d9dc191c1a91b2b" translate="yes" xml:space="preserve">
          <source>A method was called on an ambiguous numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6424b2d67ae2d104f32890640da913ac560f8f" translate="yes" xml:space="preserve">
          <source>A method was implemented on a primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83bd54b545ece8364d586c3e7f838baf02e8c65" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">Se aplicó un método cuando se esperaba otro rasgo.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">Un m&amp;oacute;dulo puede importar &lt;code&gt;std::fmt::Write&lt;/code&gt; y &lt;code&gt;std::io::Write&lt;/code&gt; y llamar a &lt;code&gt;write!&lt;/code&gt; en los objetos que implementan cualquiera, ya que los objetos no suelen implementar ambos. Sin embargo, el m&amp;oacute;dulo debe importar los rasgos calificados para que sus nombres no entren en conflicto:</target>
        </trans-unit>
        <trans-unit id="8df0b4f7cbe7a3d63c8935c00a09e49b670eda46" translate="yes" xml:space="preserve">
          <source>A module cannot be found and therefore, the visibility cannot be determined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">Un módulo para trabajar con datos prestados.</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">Un módulo para trabajar con procesos.</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">Un m&amp;oacute;dulo es un contenedor para cero o m&amp;aacute;s &lt;a href=&quot;../items&quot;&gt;elementos.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">Un m&amp;oacute;dulo sin cuerpo se carga desde un archivo externo. Cuando el m&amp;oacute;dulo no tiene un atributo de &lt;code&gt;path&lt;/code&gt; , la ruta al archivo refleja la &lt;a href=&quot;../paths&quot;&gt;ruta del m&amp;oacute;dulo&lt;/a&gt; l&amp;oacute;gico . Los componentes de la ruta del m&amp;oacute;dulo ancestro son directorios y el contenido del m&amp;oacute;dulo est&amp;aacute; en un archivo con el nombre del m&amp;oacute;dulo m&amp;aacute;s la extensi&amp;oacute;n &lt;code&gt;.rs&lt;/code&gt; . Por ejemplo, la siguiente estructura de m&amp;oacute;dulo puede tener esta estructura de sistema de archivos correspondiente:</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">Un ejemplo más complejo:</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">Un patrón más complejo,usando un cierre:</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">Un rust&amp;aacute;ceo m&amp;aacute;s experimentado escribir&amp;iacute;a la firma que se muestra en el Listado 4-9 porque nos permite usar la misma funci&amp;oacute;n en los valores &lt;code&gt;&amp;amp;String&lt;/code&gt; y &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">Un uso m&amp;aacute;s realista de &lt;code&gt;!&lt;/code&gt; est&amp;aacute; en este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="47b3111cf8992e03f361ef35402077d40b862b00" translate="yes" xml:space="preserve">
          <source>A more user-friendly and stable version of this operation is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80c7507fc9ff231be351f8cae94b1cf2dae1652" translate="yes" xml:space="preserve">
          <source>A multi-line (doc-)comment is unterminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">Una unión,referencia o puntero mutable.</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre un &lt;code&gt;BTreeMap&lt;/code&gt; de entradas en un BTreeMap .</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los elementos de una &lt;code&gt;LinkedList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los elementos de un &lt;code&gt;VecDeque&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre las entradas de un &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre las entradas de un &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los valores de un &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Un iterador mutable sobre los valores de un &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">Una ubicación de memoria mutable con reglas de préstamo comprobadas dinámicamente</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">Una ubicación de memoria mutable.</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">Se puede crear una referencia mutable con &lt;code&gt;&amp;amp;mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa831fb6e4681d63ec9057ce3580c443fec9edb2" translate="yes" xml:space="preserve">
          <source>A mutable reference was used in a constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad0f3cf407381fd22bba2cf586e95f6a6a15615" translate="yes" xml:space="preserve">
          <source>A mutable variable is used but it is already captured by a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ceef8798472360db16ce7d238d9ede4272142f3" translate="yes" xml:space="preserve">
          <source>A mutable variable, reference, or pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">Una exclusión mutua primitiva útil para proteger los datos compartidos</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">Una dirección con nombre:</target>
        </trans-unit>
        <trans-unit id="01a291706f0b443b495b0b8c907121279cbace5d" translate="yes" xml:space="preserve">
          <source>A negative impl was made default impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">Una aplicación negativa es aquella que excluye a un tipo de la aplicación de un rasgo particular.No poder utilizar un rasgo es siempre una operación segura,por lo que las implementaciones negativas son siempre seguras y nunca necesitan ser marcadas como inseguras.</target>
        </trans-unit>
        <trans-unit id="64f76de0f189c143b75250fce4afe6feb8fa06dc" translate="yes" xml:space="preserve">
          <source>A negative implementation was marked as unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">Una nueva tubería debe ser arreglada para conectar los procesos padre e hijo.</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">Se puede configurar un nuevo hilo antes de que se genere a trav&amp;eacute;s de &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; tipo de , que actualmente le permite establecer el nombre y el tama&amp;ntilde;o de la pila para el hilo secundario:</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Se puede &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; un nuevo hilo usando la funci&amp;oacute;n thread :: spawn :</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">Un nodo podr&amp;aacute; hacer referencia a su nodo principal, pero no es propietario de su principal. En el Listado 15-28, actualizamos &lt;code&gt;main&lt;/code&gt; para usar esta nueva definici&amp;oacute;n para que el nodo &lt;code&gt;leaf&lt;/code&gt; tenga una forma de referirse a su &lt;code&gt;branch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d77bcf0653e102d2dc04011199024bd95fbb9db" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;'static&lt;/code&gt; lifetime was used in a const generic. This is currently not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">Se utilizó un valor no constante en una expresión constante.</target>
        </trans-unit>
        <trans-unit id="1eee5bad5b1b537626b09062a59e028d86d55ec2" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">Ya se ha realizado una aplicación no por defecto de este tipo,por lo que no se puede especializar más.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">Un componente no final en la ruta no es un directorio.</target>
        </trans-unit>
        <trans-unit id="c1d61674888a79b8d093da31552849442beb0211" translate="yes" xml:space="preserve">
          <source>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2d2a8d307a0d585bf4d4468aa00fb158ce3e7d" translate="yes" xml:space="preserve">
          <source>A non-mutable value was assigned a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">Un &lt;em&gt;literal de cadena de bytes&lt;/em&gt; no sin &lt;em&gt;formato&lt;/em&gt; es una secuencia de caracteres ASCII y &lt;em&gt;escapes&lt;/em&gt; , precedidos por los caracteres &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) y &lt;code&gt;U+0022&lt;/code&gt; (comillas dobles), y seguidos por el car&amp;aacute;cter &lt;code&gt;U+0022&lt;/code&gt; . Si el car&amp;aacute;cter &lt;code&gt;U+0022&lt;/code&gt; est&amp;aacute; presente dentro del literal, debe &lt;em&gt;escaparse&lt;/em&gt; de un car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) precedente . Alternativamente, un literal de cadena de bytes puede ser un &lt;em&gt;literal de cadena de bytes sin formato&lt;/em&gt; , definido a continuaci&amp;oacute;n. El tipo de un literal de cadena de bytes de longitud &lt;code&gt;n&lt;/code&gt; es &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">Un módulo sin raíz intenta importar macros de otra caja.</target>
        </trans-unit>
        <trans-unit id="0f7f88934a0864a48a1aa3e075daab332c8783a0" translate="yes" xml:space="preserve">
          <source>A non-root module tried to import macros from another crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ccf07b47b66963a7e3e32486b9dba6e199bf07" translate="yes" xml:space="preserve">
          <source>A non-structural-match type was used as the type of a const generic parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">Se solicitó una interfaz inexistente o la dirección solicitada no era local.</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">Un componente normal, por ejemplo, &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; en &lt;code&gt;a/b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">Una nota sobre los tipos de tama&amp;ntilde;o cero y los dise&amp;ntilde;os de tama&amp;ntilde;o cero: muchos m&amp;eacute;todos en el rasgo &lt;code&gt;Alloc&lt;/code&gt; establecen que las solicitudes de asignaci&amp;oacute;n deben tener un tama&amp;ntilde;o distinto de cero, o de lo contrario puede resultar un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="d70ff5d8ac6ec719cfc0758b679c32b46a7a0fdd" translate="yes" xml:space="preserve">
          <source>A null &lt;code&gt;fn&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd524388dc48721a46df11a0e678684cddc1ff5" translate="yes" xml:space="preserve">
          <source>A number in a non-decimal base has no digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">Pánico al desbordarse:</target>
        </trans-unit>
        <trans-unit id="7e451dc65737a3d0078f0a0cdca0352afd247852" translate="yes" xml:space="preserve">
          <source>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17681e220340a047c028939b5c9a6007c707423" translate="yes" xml:space="preserve">
          <source>A parameter type is missing an explicit lifetime bound and may not live long enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">Un parámetro era incorrecto.</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">No existe un padre de la ruta dada. (Para crear un directorio y todos sus padres faltantes al mismo tiempo, use la funci&amp;oacute;n &lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">Una instancia particular de &lt;code&gt;RandomState&lt;/code&gt; crear&amp;aacute; las mismas instancias de &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; , pero es poco probable que los hashers creados por dos instancias de &lt;code&gt;RandomState&lt;/code&gt; diferentes produzcan el mismo resultado para los mismos valores.</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">Un patr&amp;oacute;n en particular &lt;code&gt;_&lt;/code&gt; coincidir&amp;aacute; con cualquier cosa, pero nunca se une a una variable, por lo que a menudo se usa en el &amp;uacute;ltimo brazo de coincidencia. El patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; puede resultar &amp;uacute;til cuando desee ignorar cualquier valor no especificado, por ejemplo. Cubriremos el patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; con m&amp;aacute;s detalle en la secci&amp;oacute;n &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&quot;Ignorar valores en un patr&amp;oacute;n&quot;&lt;/a&gt; m&amp;aacute;s adelante en este cap&amp;iacute;tulo.</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">Un camino puede tomar dos formas:</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">Un patr&amp;oacute;n a &lt;code&gt;..=&lt;/code&gt; b siempre debe tener a &amp;le; b. Es un error tener un patr&amp;oacute;n de rango &lt;code&gt;10..=0&lt;/code&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="891da3d988f6fc5238b5b4fb583d072b5a0287dc" translate="yes" xml:space="preserve">
          <source>A pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6b7416ed8a3ba7b4dcdc0423f76b297ea15288" translate="yes" xml:space="preserve">
          <source>A pattern binding is using the same name as one of the variants of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b95bece3c7641fd29f13b871ae1a3d402281d9" translate="yes" xml:space="preserve">
          <source>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3ec235405c966e5db61078265ddd06c38fdf87" translate="yes" xml:space="preserve">
          <source>A pattern guard may refer to the variables bound within the pattern they follow. Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">Se dice que un patr&amp;oacute;n es &lt;em&gt;refutable&lt;/em&gt; cuando tiene la posibilidad de no coincidir con el valor con el que se compara. &lt;em&gt;Los&lt;/em&gt; patrones &lt;em&gt;irrefutables&lt;/em&gt; , por otro lado, siempre coinciden con el valor con el que se comparan. Ejemplos:</target>
        </trans-unit>
        <trans-unit id="50718096ba0e9d977821568bde4dc051a6527468" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">Un patrón utilizado para cotejar con una variante del enum debe proporcionar un subpatrón para cada campo de la variante del enum.Este error indica que un patrón intentó extraer un número incorrecto de campos de una variante.</target>
        </trans-unit>
        <trans-unit id="27a0056206e19a4b052630f19a00fbd4710c685a" translate="yes" xml:space="preserve">
          <source>A pattern was declared as an argument in a foreign function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">Un puntero de alfiler.</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">Un lugar que es válido para la duración de un programa.</target>
        </trans-unit>
        <trans-unit id="7d0a1c9d0822781050522c413844b46b3f9e19ec" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">Se declaró un plugin/caja pero no se puede encontrar.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="2db11183c5e69392e41fbe166caeebf1df741e85" translate="yes" xml:space="preserve">
          <source>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">Un tipo de puntero para la asignación de la pila.</target>
        </trans-unit>
        <trans-unit id="068b4756f4660015d453841abd0c47d397debbf3" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">Una &lt;code&gt;Once&lt;/code&gt; envenenada :</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">Sin embargo, un mutex envenenado no evita todo el acceso a los datos subyacentes. El tipo &lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; &lt;/a&gt; tiene un m&amp;eacute;todo &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; &lt;/a&gt; que devolver&amp;aacute; la protecci&amp;oacute;n que de otro modo se hubiera devuelto en un bloqueo exitoso. Esto permite el acceso a los datos, a pesar de que la cerradura est&amp;eacute; envenenada.</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">Un posible valor de error al convertir una &lt;code&gt;String&lt;/code&gt; de un segmento de bytes UTF-16.</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">Un posible valor de error al convertir una &lt;code&gt;String&lt;/code&gt; de un vector de bytes UTF-8.</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">Un preludio para escribir convenientemente el código específico de la plataforma.</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">Una cola de prioridad implementada con un montón de binarios.</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">Un objeto privado fue usado fuera de su alcance.</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">Un artículo privado fue usado fuera de su alcance.</target>
        </trans-unit>
        <trans-unit id="b050bad5b423d40a7cbc2510e0a714043fcaa01a" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">Se utilizó un rasgo privado en un parámetro de tipo público limitado.Ejemplos de códigos erróneos:</target>
        </trans-unit>
        <trans-unit id="9a0df3af8cfe7414b96a23dc7a41a25700bb086e" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">Se utilizó un tipo privado en una firma de tipo público.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">Un constructor de procesos,que proporciona un control de grano fino sobre la forma en que un nuevo proceso debe ser engendrado.</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">Un rápido repaso sobre el ordenamiento de la memoria:</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">Un número aleatorio que generará cierta variedad en los planes de entrenamiento</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">Un rango limitado inclusive por debajo y por encima ( &lt;code&gt;start..=end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">Un rango solo limitado exclusivamente por encima ( &lt;code&gt;..end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">Un rango solo delimitado inclusive arriba ( &lt;code&gt;..=end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">Un rango solo delimitado inclusive por debajo de ( &lt;code&gt;start..&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">Un identificador en bruto es como un identificador normal, pero con el prefijo &lt;code&gt;r#&lt;/code&gt; . (Tenga en cuenta que el prefijo &lt;code&gt;r#&lt;/code&gt; no se incluye como parte del identificador real). A diferencia de un identificador normal, un identificador en bruto puede ser cualquier palabra clave estricta o reservada, excepto las enumeradas anteriormente para &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">Un tipo de puntero crudo que puede ser compartido con seguridad entre los hilos.</target>
        </trans-unit>
        <trans-unit id="f1f955686d561bc8208f2ce3b12ca99c3765110a" translate="yes" xml:space="preserve">
          <source>A raw string isn't correctly terminated because the trailing &lt;code&gt;#&lt;/code&gt; count doesn't match its leading &lt;code&gt;#&lt;/code&gt; count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">Un lector que siempre está en EOF.</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">Un lector que produce un byte una y otra vez y otra y otra y otra y otra...</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">Un bloqueo de lector-escritor</target>
        </trans-unit>
        <trans-unit id="2d89d8dfb8b1c58f5d841e5165fcf975a6c55e6a" translate="yes" xml:space="preserve">
          <source>A recursive type has infinite size because it doesn't have an indirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">Una referencia tiene una vida útil más larga que los datos a los que hace referencia.</target>
        </trans-unit>
        <trans-unit id="8299c0d135b8f5441cc8858d8675b0fc5f91fcc2" translate="yes" xml:space="preserve">
          <source>A reference or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that is dangling, unaligned, or points to an invalid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">Una referencia representa un pr&amp;eacute;stamo de alg&amp;uacute;n valor propio. Puede obtener uno usando los operadores &lt;code&gt;&amp;amp;&lt;/code&gt; o &lt;code&gt;&amp;amp;mut&lt;/code&gt; en un valor, o usando un patr&amp;oacute;n &lt;code&gt;ref&lt;/code&gt; o &lt;code&gt;ref mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def229fac786a814e540383a36be7448c81c2810" translate="yes" xml:space="preserve">
          <source>A reference to a local variable was returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">Una referencia a un archivo abierto en el sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Una referencia al directorio actual, es decir, &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">Una referencia al directorio padre, es decir, &lt;code&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b305ff2e1e8a128729de5a06db133ccf46d493cc" translate="yes" xml:space="preserve">
          <source>A reference/pointer is &quot;dangling&quot; if it is null or not all of the bytes it points to are part of the same allocation (so in particular they all have to be part of &lt;em&gt;some&lt;/em&gt; allocation). The span of bytes it points to is determined by the pointer value and the size of the pointee type (using &lt;code&gt;size_of_val&lt;/code&gt;). As a consequence, if the span is empty, &quot;dangling&quot; is the same as &quot;non-null&quot;. Note that slices and strings point to their entire range, so it is important that the length metadata is never too large. In particular, allocations and therefore slices and strings cannot be bigger than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">Un número regular de punto flotante.</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">Una referencia regular es un tipo de puntero, y una forma de pensar en un puntero es como una flecha a un valor almacenado en otro lugar. En el Listado 15-6, creamos una referencia a un valor &lt;code&gt;i32&lt;/code&gt; y luego usamos el operador de desreferencia para seguir la referencia a los datos:</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">Un concepto relacionado es el alcance: el contexto anidado en el que se escribe el c&amp;oacute;digo tiene un conjunto de nombres que se definen como &quot;dentro del alcance&quot;. Al leer, escribir y compilar c&amp;oacute;digo, los programadores y compiladores necesitan saber si un nombre particular en un lugar particular se refiere a una variable, funci&amp;oacute;n, estructura, enumeraci&amp;oacute;n, m&amp;oacute;dulo, constante u otro elemento y qu&amp;eacute; significa ese elemento. Puede crear &amp;aacute;mbitos y cambiar los nombres que est&amp;aacute;n dentro o fuera del &amp;aacute;mbito. No puede tener dos elementos con el mismo nombre en el mismo &amp;aacute;mbito; Hay herramientas disponibles para resolver conflictos de nombres.</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n repetida &lt;code&gt;[x; N]&lt;/code&gt; , que produce una matriz con &lt;code&gt;N&lt;/code&gt; copias de &lt;code&gt;x&lt;/code&gt; . El tipo de &lt;code&gt;x&lt;/code&gt; debe ser &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3238c87767b981c84fc407d2a6b89dd0a8979fcd" translate="yes" xml:space="preserve">
          <source>A restriction is imposed on the shebang syntax to avoid confusion with an &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;. The &lt;code&gt;#!&lt;/code&gt; characters must not be followed by a &lt;code&gt;[&lt;/code&gt; token, ignoring intervening &lt;a href=&quot;comments&quot;&gt;comments&lt;/a&gt; or &lt;a href=&quot;whitespace&quot;&gt;whitespace&lt;/a&gt;. If this restriction fails, then it is not treated as a shebang, but instead as the start of an attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">Se encontró una declaración de retorno fuera de un cuerpo funcional.</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">Un buscador inverso para un patrón de cadenas.</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">Un escrutinio es la expresi&amp;oacute;n que coincide en expresiones de &lt;code&gt;match&lt;/code&gt; y construcciones de coincidencia de patrones similares. Por ejemplo, en la &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; es el escrutinio.</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">Un buscador de un patrón de cuerda.</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">Se permite una búsqueda más allá del final de un arroyo,pero el comportamiento se define por la implementación.</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">Un conjunto basado en un árbol B.</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">Un error similar es E0201. La diferencia es si hay un bloque de declaraci&amp;oacute;n o no. Para evitar este error, debe &lt;code&gt;fn&lt;/code&gt; cada fn un nombre exclusivo.</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">Existe una regla similar para combinar referencias mutables e inmutables.Este código da como resultado un error:</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">Un simple ejemplo:</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">Una funci&amp;oacute;n simple que devuelve el &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; podr&amp;iacute;a definirse y usarse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">Un simple giro:</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">Una solución simple es usar un método de ayuda en su lugar:</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">Un simple envoltorio alrededor de un tipo para afirmar que es seguro para desenvolverse.</target>
        </trans-unit>
        <trans-unit id="b53617da96fc2eac5eec0b6bb0e92f32c47fc76e" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un solo hilo (arbitrario) recibir&amp;aacute; un &lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt; que devuelve &lt;code&gt;true&lt;/code&gt; de &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; al regresar de esta funci&amp;oacute;n, y todos los dem&amp;aacute;s hilos recibir&amp;aacute;n un resultado que devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; de &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">Un solo &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; puede codificarse como m&amp;aacute;s de un byte. Este m&amp;eacute;todo solo puede tener &amp;eacute;xito si la secuencia de bytes completa se escribi&amp;oacute; correctamente y este m&amp;eacute;todo no regresar&amp;aacute; hasta que se hayan escrito todos los datos o se haya producido un error.</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">Un solo &lt;em&gt;literal decimal&lt;/em&gt; seguido de un &lt;em&gt;exponente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">Un solo componente de un camino.</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">Un puntero contador de referencias de un solo hilo.Rc' significa 'Referencia Contada'.</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">Una rebanada es un &lt;a href=&quot;../dynamically-sized-types&quot;&gt;tipo din&amp;aacute;micamente tama&amp;ntilde;o&lt;/a&gt; que representa una 'vista' en una secuencia de elementos de tipo &lt;code&gt;T&lt;/code&gt; . El tipo de rebanada se escribe como &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">Un sector es una vista de tama&amp;ntilde;o din&amp;aacute;mico en una secuencia contigua, escrita como &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Un trozo de un camino (similar a &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2759e6b662ba691ba47b65069c920c9b980fcd79" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">Un ejemplo un poco triste de no leer nada en un buffer:</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">La dirección de un enchufe no se puede vincular porque la dirección ya se utiliza en otro lugar.</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">Una consecuencia algo sorprendente de la definici&amp;oacute;n es que &lt;code&gt;&amp;amp;mut T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; (si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; ) aunque parece que eso podr&amp;iacute;a proporcionar una mutaci&amp;oacute;n no sincronizada. El truco es que una referencia mutable detr&amp;aacute;s de una referencia com&amp;uacute;n (es decir, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; ) se convierte de s&amp;oacute;lo lectura, como si se tratara de un &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; . Por tanto, no hay riesgo de una carrera de datos.</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">Un archivo fuente puede tener un &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (producci&amp;oacute;n SHEBANG), que indica al sistema operativo qu&amp;eacute; programa utilizar para ejecutar este archivo. B&amp;aacute;sicamente, sirve para tratar el archivo fuente como un script ejecutable. El shebang solo puede ocurrir al principio del archivo (pero despu&amp;eacute;s del &lt;em&gt;UTF8BOM&lt;/em&gt; opcional ). El compilador lo ignora. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5ec62fb18603ebc6519f469782df4169fc5a681f" translate="yes" xml:space="preserve">
          <source>A source stage in an iterator pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">Un tipo de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; especializado para operaciones de E / S.</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">Un tipo de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; especializado para subprocesos.</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">Un iterador de empalme para &lt;code&gt;Vec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="382d455769d00569a95a026174c2cb511f9bbb7a" translate="yes" xml:space="preserve">
          <source>A stability attribute has been used outside of the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6a5b448820983a6050fcd10b6c3d4dd333f376" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">Se utilizó un atributo de estabilidad fuera de la biblioteca estándar.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">Una declaración es el elemento autónomo más pequeño de un lenguaje de programación que ordena a un ordenador realizar una acción.</target>
        </trans-unit>
        <trans-unit id="7993655a3c3f53e3aa0f9baecc01e8b1f97ae73b" translate="yes" xml:space="preserve">
          <source>A statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d137e324ac57303f829812294caa15b53500d48e" translate="yes" xml:space="preserve">
          <source>A static item is a value which is valid for the entire duration of your program (a &lt;code&gt;'static&lt;/code&gt; lifetime).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1525834046325d03a0ffcca63064524577af3217" translate="yes" xml:space="preserve">
          <source>A string (&lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">Una cadena que describe la arquitectura de la CPU que está actualmente en uso.</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">Cadena que describe el sistema operativo espec&amp;iacute;fico en uso. El valor de ejemplo es &lt;code&gt;linux&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">Una cadena es una secuencia de bytes. 'Izquierda' en este contexto significa la primera posici&amp;oacute;n de esa cadena de bytes; para un idioma como el &amp;aacute;rabe o el hebreo que son &quot;de derecha a izquierda&quot; en lugar de &quot;de izquierda a derecha&quot;, este ser&amp;aacute; el lado &lt;em&gt;derecho&lt;/em&gt; , no el izquierdo.</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">Una cadena es una secuencia de bytes. 'Derecha' en este contexto significa la &amp;uacute;ltima posici&amp;oacute;n de esa cadena de bytes; para un idioma como el &amp;aacute;rabe o el hebreo que son 'de derecha a izquierda' en lugar de 'de izquierda a derecha', este ser&amp;aacute; el lado &lt;em&gt;izquierdo&lt;/em&gt; , no el derecho.</target>
        </trans-unit>
        <trans-unit id="a7d73837e1ae6f385cc7b12b321574d70650bd43" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">Una cadena es una secuencia de bytes. &lt;code&gt;end&lt;/code&gt; en este contexto significa la &amp;uacute;ltima posici&amp;oacute;n de esa cadena de bytes; para un idioma de izquierda a derecha como ingl&amp;eacute;s o ruso, este ser&amp;aacute; el lado derecho, y para idiomas de derecha a izquierda como &amp;aacute;rabe o hebreo, este ser&amp;aacute; el lado izquierdo.</target>
        </trans-unit>
        <trans-unit id="8add450b8d835c6c86dcce6d9f4412fe207173ed" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">Una cadena es una secuencia de bytes. &lt;code&gt;start&lt;/code&gt; en este contexto significa la primera posici&amp;oacute;n de esa cadena de bytes; para un idioma de izquierda a derecha como ingl&amp;eacute;s o ruso, este ser&amp;aacute; el lado izquierdo, y para idiomas de derecha a izquierda como &amp;aacute;rabe o hebreo, este ser&amp;aacute; el lado derecho.</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">Un literal de cadena es una cadena almacenada directamente en el binario final, por lo que ser&amp;aacute; v&amp;aacute;lida durante la &lt;code&gt;'static&lt;/code&gt; duraci&amp;oacute;n est&amp;aacute;tica' .</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">Un patrón de cuerda.</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">Un segmento de cadena ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; formado por bytes ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; ) y un segmento de bytes ( &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; compuesto por bytes, por lo que esta funci&amp;oacute;n convierte entre los dos. Sin embargo, no todos los segmentos de bytes son segmentos de cadena v&amp;aacute;lidos: &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; requiere que sea UTF-8 v&amp;aacute;lido. &lt;code&gt;from_utf8()&lt;/code&gt; comprueba que los bytes sean UTF-8 v&amp;aacute;lidos y luego realiza la conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">Un segmento de cadena ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; formado por bytes ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; ) y un vector de bytes ( &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; ) est&amp;aacute; formado por bytes, por lo que esta funci&amp;oacute;n convierte entre los dos. Sin embargo, no todos los segmentos de bytes son &lt;code&gt;String&lt;/code&gt; s v&amp;aacute;lidos : &lt;code&gt;String&lt;/code&gt; requiere que sea UTF-8 v&amp;aacute;lido. &lt;code&gt;from_utf8()&lt;/code&gt; comprueba que los bytes sean UTF-8 v&amp;aacute;lidos y luego realiza la conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">Un segmento de cadena es el tipo de cadena m&amp;aacute;s primitivo en Rust, escrito como &lt;code&gt;str&lt;/code&gt; . A menudo se ve en sus formas prestadas, ya sea mutable o compartida. El tipo de segmento de cadena compartida es &lt;code&gt;&amp;amp;str&lt;/code&gt; , mientras que el tipo de segmento de cadena mutable es &lt;code&gt;&amp;amp;mut str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">Una estructura puede ser &lt;code&gt;Copy&lt;/code&gt; e &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; es &lt;code&gt;Copy&lt;/code&gt; , por lo tanto, &lt;code&gt;Point&lt;/code&gt; es elegible para ser &lt;code&gt;Copy&lt;/code&gt; . Por el contrario, considere</target>
        </trans-unit>
        <trans-unit id="eb9b96b59ca1189f15dc2a933aeadc425813dff3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">Se invocó a un constructor de estructuras con campos privados.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">Una estructura que contiene información sobre la ubicación de un pánico.</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">Una expresi&amp;oacute;n de estructura puede terminar con la sintaxis &lt;code&gt;..&lt;/code&gt; seguida de una expresi&amp;oacute;n para denotar una actualizaci&amp;oacute;n funcional. La expresi&amp;oacute;n que sigue a &lt;code&gt;..&lt;/code&gt; (la base) debe tener el mismo tipo de estructura que el nuevo tipo de estructura que se est&amp;aacute; formando.</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">Una expresión de estructura con campos encerrados en llaves rizadas permite especificar el valor de cada campo individual en cualquier orden.El nombre del campo se separa de su valor con dos puntos.</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">Una expresi&amp;oacute;n de estructura con campos entre par&amp;eacute;ntesis construye una estructura de tupla. Aunque aparece aqu&amp;iacute; como una expresi&amp;oacute;n espec&amp;iacute;fica para completar, es equivalente a una &lt;a href=&quot;call-expr&quot;&gt;expresi&amp;oacute;n de llamada&lt;/a&gt; al constructor de la estructura de tupla. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4a5683978535ef36d2f4a36fc97769f59882d764" translate="yes" xml:space="preserve">
          <source>A struct pattern attempted to extract a non-existent field from a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">Un patrón de estructura es refutable cuando uno de sus subpatrones es refutable.</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">Una estructura que proporciona información sobre el pánico.</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">Una estructura para ayudar con las implementaciones de &lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="878d9a84ea5b4c1dd0e00cf0901eb339704e2d00" translate="yes" xml:space="preserve">
          <source>A struct was declared with two fields having the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">Una estructura con un solo campo al que se puede acceder derivando la estructura.</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">Una estructura con un solo campo que es modificable al desreferenciar la estructura.</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">Una estructura con m&amp;aacute;s de un campo que contiene un tipo sin &lt;code&gt;CoerceUnsized&lt;/code&gt; no puede implementar CoerceUnsized . Esto solo ocurre cuando intenta forzar uno de los tipos en su estructura a otro tipo en la estructura. En este caso, intentamos &lt;code&gt;CoerceUnsized&lt;/code&gt; de &lt;code&gt;T&lt;/code&gt; a &lt;code&gt;U&lt;/code&gt; , que son los dos tipos que toma la estructura. Un &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;tipo sin tama&amp;ntilde;o&lt;/a&gt; es cualquier tipo del que el compilador no conoce la longitud o la alineaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n. Cualquier estructura que contenga un tipo sin tama&amp;ntilde;o tampoco tiene tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">Una estructura con la sugerencia de representaci&amp;oacute;n &lt;code&gt;repr(transparent)&lt;/code&gt; ten&amp;iacute;a cero o m&amp;aacute;s de un campo que no estaba garantizado para ser de tama&amp;ntilde;o cero.</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">Una estructura sin un campo que contenga un tipo sin &lt;code&gt;CoerceUnsized&lt;/code&gt; no puede implementar CoerceUnsized . Un &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;tipo sin tama&amp;ntilde;o&lt;/a&gt; es cualquier tipo del que el compilador no conoce la longitud o la alineaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n. Cualquier estructura que contenga un tipo sin tama&amp;ntilde;o tampoco tiene tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="bfe3d05f336ffd910d212738048395d48df402c2" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcfe0f822e1b5462565a584546dacf4f3c36744" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was specified more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">Una estructura, enumeraci&amp;oacute;n o uni&amp;oacute;n con la sugerencia de representaci&amp;oacute;n &lt;code&gt;repr(transparent)&lt;/code&gt; contiene un campo de tama&amp;ntilde;o cero que requiere una alineaci&amp;oacute;n no trivial.</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">Una estructura que representa un servidor de sockets de dominio Unix.</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Una estructura que representa un tipo de archivo con descriptores de acceso para cada tipo de archivo. Es devuelto por el m&amp;eacute;todo &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">Una estructura que envuelve un prefijo de ruta de Windows así como su representación de cadena sin par.</target>
        </trans-unit>
        <trans-unit id="a18cd960fc14986c70aa975cf92200531a20ff48" translate="yes" xml:space="preserve">
          <source>A structure-literal syntax was used to create an item that is not a structure or enum variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450ed556ad629fd6ee6dd398c15074a8c129be66" translate="yes" xml:space="preserve">
          <source>A successful conversion will produce the same result as &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; when called without the ending nul byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un env&amp;iacute;o exitoso ocurre cuando se determina que el otro extremo del canal a&amp;uacute;n no ha colgado. Un env&amp;iacute;o fallido ser&amp;iacute;a uno en el que el receptor correspondiente ya ha sido desasignado. Tenga en cuenta que un valor de retorno de &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; medios que nunca ser&amp;aacute;n recibidos los datos, pero un valor de retorno de &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; no &lt;em&gt;, no&lt;/em&gt; significa que se recibir&amp;aacute;n los datos. Es posible que el receptor correspondiente cuelgue inmediatamente despu&amp;eacute;s de que esta funci&amp;oacute;n devuelva &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">Un sufijo es un identificador no binario que sigue inmediatamente (sin espacio en blanco)a la parte primaria de un literal.</target>
        </trans-unit>
        <trans-unit id="01225be668ae4fcd869b26b266eae668b00e87f5" translate="yes" xml:space="preserve">
          <source>A super trait has been added to an auto trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd1d7403a3a0b004c92da849e81f0a2dc9aaf82" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">Una primitiva de sincronizaci&amp;oacute;n que se puede utilizar para ejecutar una inicializaci&amp;oacute;n global &amp;uacute;nica. &amp;Uacute;til para la inicializaci&amp;oacute;n &amp;uacute;nica de FFI o funciones relacionadas. Este tipo solo se puede construir con el valor &lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt; o el equivalente &lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt; constructor.</target>
        </trans-unit>
        <trans-unit id="7ae033712f05c69a86c1b61d9806f301efbdf2ee" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be written to only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">Un canal sincr&amp;oacute;nico y limitado. La funci&amp;oacute;n &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; una &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; donde el almacenamiento de los mensajes pendientes es un b&amp;uacute;fer preasignado de un tama&amp;ntilde;o fijo. Todos los env&amp;iacute;os ser&amp;aacute;n &lt;strong&gt;sincr&amp;oacute;nicos&lt;/strong&gt; bloqueando hasta que haya espacio de b&amp;uacute;fer disponible. Tenga en cuenta que se permite un l&amp;iacute;mite de 0, lo que hace que el canal se convierta en un canal de &quot;encuentro&quot; en el que cada remitente entrega at&amp;oacute;micamente un mensaje a un receptor.</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">Una producción sintáctica</target>
        </trans-unit>
        <trans-unit id="a737498d76fd77a9ff17becf5c122eff8eaa0e65" translate="yes" xml:space="preserve">
          <source>A temporary value is being dropped while a borrow is still in active use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">Un hilo tambi&amp;eacute;n puede devolver un valor a trav&amp;eacute;s de su &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; , puede usar esto para realizar c&amp;aacute;lculos asincr&amp;oacute;nicos (aunque los futuros pueden ser m&amp;aacute;s apropiados).</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">Una clave de almacenamiento local de hilo que es dueña de su contenido.</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">Se considera que un hilo que se completa sin pánico sale con éxito.</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">Una clave local de subproceso posee el valor que contiene y destruir&amp;aacute; el valor cuando el subproceso salga. &amp;iexcl;Se crea con &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;macro y puede contener cualquier valor que sea &lt;code&gt;'static&lt;/code&gt; (sin punteros prestados). Proporciona una funci&amp;oacute;n de acceso, &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; , que produce una referencia compartida al valor del cierre especificado. Las claves locales de subprocesos solo permiten el acceso compartido a los valores, ya que no habr&amp;iacute;a forma de garantizar la unicidad si se permitieran los pr&amp;eacute;stamos mutables. La mayor&amp;iacute;a de los valores querr&amp;aacute;n hacer uso de alguna forma de &lt;strong&gt;mutabilidad interior a&lt;/strong&gt; trav&amp;eacute;s de los tipos &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">Un puntero contador de referencias seguro.&quot;Arco&quot; significa &quot;Referencia atómica contada&quot;.</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">Una ficha producida por el lexer</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">Una barra final se normaliza de distancia, &lt;code&gt;/a/b&lt;/code&gt; y &lt;code&gt;/a/b/&lt;/code&gt; son equivalentes.</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">&amp;iquest;Un rasgo vinculado a &lt;code&gt;?Sized&lt;/code&gt; es lo opuesto a un rasgo vinculado a &lt;code&gt;Sized&lt;/code&gt; : leer&amp;iacute;amos esto como &quot; &lt;code&gt;T&lt;/code&gt; puede o no puede ser &lt;code&gt;Sized&lt;/code&gt; &quot;. Esta sintaxis solo est&amp;aacute; disponible para &lt;code&gt;Sized&lt;/code&gt; , no para otros rasgos.</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">Un rasgo puede tener múltiples métodos en su cuerpo:las firmas de los métodos se enumeran una por línea y cada línea termina en un punto y coma.</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">Un rasgo para tomar prestado los datos.</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Un rasgo para convertir un valor en una &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un rasgo para crear instancias de &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">&amp;iquest;Un rasgo para personalizar el comportamiento del &lt;code&gt;?&lt;/code&gt; operador.</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">Un rasgo para dar a un tipo un valor por defecto útil.</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">Un rasgo para la obtención de un flujo arbitrario de bytes.</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">Un rasgo para implementar tipos de retorno arbitrarios en la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">Un rasgo para tomar datos prestados mutablemente.</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">Un rasgo para los objetos que son fregaderos orientados a los bytes.</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">Un rasgo de los objetos que se pueden convertir o resolver en uno o m&amp;aacute;s valores &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20da43414d9faf5772a30fd6329b8b6d3aa3e3b4" translate="yes" xml:space="preserve">
          <source>A trait for writing or formatting into Unicode-accepting buffers or streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23adce518b9b9c7fb3e196dc3fd75bab1e5f0059" translate="yes" xml:space="preserve">
          <source>A trait implementation has stricter requirements than the trait definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">La aplicación de un rasgo se considera incoherente si falla el control de huérfanos o si hay instancias de aplicación que se superponen.</target>
        </trans-unit>
        <trans-unit id="a4884230017ffb802f52c6721c470c8593e7fcd5" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="translated">La implementación de un rasgo debe definir todos los elementos asociados no predeterminados declarados por el rasgo implementado,puede redefinir los elementos asociados predeterminados definidos por el rasgo implementado y no puede definir ningún otro elemento.</target>
        </trans-unit>
        <trans-unit id="d0010f4426c0d6cbe2dc68d818b29e968be48db6" translate="yes" xml:space="preserve">
          <source>A trait implementation was marked as unsafe while the trait is safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">Un rasgo es un elemento del lenguaje que se utiliza para describir las funcionalidades que un tipo debe proporcionar.Permite a un tipo hacer ciertas promesas sobre su comportamiento.</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">Se puede implementar un rasgo para &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; en la misma caja que &lt;code&gt;T&lt;/code&gt; , que las &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;reglas hu&amp;eacute;rfanas&lt;/a&gt; impiden para otros tipos gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="1b745de10511ea796795a51c79ea5a4b196da151" translate="yes" xml:space="preserve">
          <source>A trait method was declared const.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">Un objeto de rasgo se define sobre un rasgo &amp;uacute;nico y completamente definido. Con un par&amp;aacute;metro predeterminado regular, este par&amp;aacute;metro puede simplemente sustituirse. Sin embargo, si el par&amp;aacute;metro predeterminado es &lt;code&gt;Self&lt;/code&gt; , el rasgo cambia para cada tipo de concreto; es decir, &lt;code&gt;i32&lt;/code&gt; se esperar&amp;aacute; para implementar &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; se espera para implementar &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; , etc ... Estos tipos no compartir&amp;aacute;n la implementaci&amp;oacute;n de un rasgo completamente definido; en cambio, comparten implementaciones de un rasgo con diferentes par&amp;aacute;metros sustituidos para cada implementaci&amp;oacute;n. Esto es irreconciliable con lo que necesitamos para hacer que un objeto de rasgo funcione y, por lo tanto, no est&amp;aacute; permitido. Hacer que el rasgo sea concreto especificando expl&amp;iacute;citamente el valor del par&amp;aacute;metro predeterminado solucionar&amp;aacute; este problema. Ejemplo fijo:</target>
        </trans-unit>
        <trans-unit id="09ed217e59efc6a63ebd08cd2d7fd8370e33eb53" translate="yes" xml:space="preserve">
          <source>A trait object was declared with no traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16935dd0c42b10d2b4960eb5cbdc15bbae87c965" translate="yes" xml:space="preserve">
          <source>A trait to emulate dynamic typing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">Un rasgo que expresa la capacidad de construir un objeto a partir de un descriptor de archivos en bruto.</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">Un rasgo para expresar la capacidad de consumir un objeto y adquirir la propiedad de su &lt;code&gt;HANDLE&lt;/code&gt; bruto .</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">Un rasgo para expresar la capacidad de consumir un objeto y adquirir la propiedad de su &lt;code&gt;SOCKET&lt;/code&gt; en bruto .</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">Un rasgo que expresa la capacidad de consumir un objeto y adquirir la propiedad de su descriptor de archivo en bruto.</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">Un rasgo para extraer el descriptor de archivos unix en bruto de un objeto subyacente.</target>
        </trans-unit>
        <trans-unit id="74dfee4318a470e1c8aa720bcf48b06f65b677a2" translate="yes" xml:space="preserve">
          <source>A trait type has been dereferenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b4acf36ca74c434adb6226f16d93f351b2c3d1" translate="yes" xml:space="preserve">
          <source>A trait was implemented on another which already automatically implemented it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">Se supone que una estructura, enumeraci&amp;oacute;n o uni&amp;oacute;n transparente se representa exactamente como la pieza de datos que contiene. Los campos de tama&amp;ntilde;o cero con diferentes requisitos de alineaci&amp;oacute;n pueden entrar en conflicto con esta propiedad. En el ejemplo anterior, &lt;code&gt;Wrapper&lt;/code&gt; tendr&amp;iacute;a que alinearse a 32 bytes aunque &lt;code&gt;f32&lt;/code&gt; tiene un requisito de alineaci&amp;oacute;n menor.</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">Un ejemplo difícil,con la sigma:</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">Un ejemplo trivial del uso de &lt;code&gt;bool&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">Un &lt;em&gt;tipo de&lt;/em&gt; tupla es un producto heterog&amp;eacute;neo de otros tipos, llamados &lt;em&gt;elementos&lt;/em&gt; de la tupla. No tiene un nombre nominal y en su lugar est&amp;aacute; escrito estructuralmente.</target>
        </trans-unit>
        <trans-unit id="e9dbb3e94f53ac8e3a8ca087dfd88ec94acc48f5" translate="yes" xml:space="preserve">
          <source>A tuple index is used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt;, and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0541e4cbc97c5e40f947c03ae1731aeaba596f" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">Una tupla es una forma general de agrupar algunos otros valores con una variedad de tipos en un tipo compuesto.Las tuplas tienen una longitud fija:una vez declaradas,no pueden crecer o reducirse en tamaño.</target>
        </trans-unit>
        <trans-unit id="8d3a96e70924f2a82e85cf6036b452ac805c64ec" translate="yes" xml:space="preserve">
          <source>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">Un patrón de estructura tuple es refutable cuando uno de sus subpatrones es refutable.</target>
        </trans-unit>
        <trans-unit id="8f5d8407de99f6165aaf419c7f8aaf0ecf33a5a2" translate="yes" xml:space="preserve">
          <source>A tuple struct's element isn't a machine type when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c229f3f830c234653affc74d3c7117a6730da6" translate="yes" xml:space="preserve">
          <source>A type alias for &lt;a href=&quot;../convert/enum.infallible&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">Un tipo de alias para el resultado de un método de bloqueo que puede ser envenenado.</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">Un tipo de alias para el resultado de un método de bloqueo sin bloqueo.</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">Un alias de tipo hace que este c&amp;oacute;digo sea m&amp;aacute;s manejable al reducir la repetici&amp;oacute;n. En el Listado 19-25, hemos introducido un alias llamado &lt;code&gt;Thunk&lt;/code&gt; para el tipo detallado y podemos reemplazar todos los usos del tipo con el alias &lt;code&gt;Thunk&lt;/code&gt; m&amp;aacute;s corto .</target>
        </trans-unit>
        <trans-unit id="4e38a79e72762fd78e402d5747ab629fd9e3cf95" translate="yes" xml:space="preserve">
          <source>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">No se puede utilizar un alias de un tipo enum para calificar a los constructores:</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">Un tipo anotado como &lt;code&gt;repr(transparent)&lt;/code&gt; delega todas las preocupaciones de representaci&amp;oacute;n a otro tipo, por lo que agregar m&amp;aacute;s sugerencias de representaci&amp;oacute;n es contradictorio. Elimine la sugerencia &lt;code&gt;transparent&lt;/code&gt; e o las otras sugerencias, como esta:</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">Un tipo también puede tener múltiples implementaciones inherentes.Un tipo de implementación debe definirse dentro de la misma caja que la definición del tipo original.</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">Un tipo puede implementar &lt;code&gt;Copy&lt;/code&gt; si todos sus componentes implementan &lt;code&gt;Copy&lt;/code&gt; . Por ejemplo, esta estructura puede ser &lt;code&gt;Copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n de conversi&amp;oacute;n de tipo se denota con el operador binario &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b97b41bd9c7eae77d5c3b940d4a5832d7e972fb" translate="yes" xml:space="preserve">
          <source>A type dependency cycle has been encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2904374f2c0e91251791d02f72bd6378c8bccc80" translate="yes" xml:space="preserve">
          <source>A type has both &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; representation hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f0b7a28b6f2753f1d76d09de19c12454b7888f" translate="yes" xml:space="preserve">
          <source>A type has conflicting &lt;code&gt;packed&lt;/code&gt; representation hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">Un tipo que implementa &lt;code&gt;Try&lt;/code&gt; es uno que tiene una forma can&amp;oacute;nica de verlo en t&amp;eacute;rminos de una dicotom&amp;iacute;a de &amp;eacute;xito / fracaso. Este rasgo permite tanto extraer esos valores de &amp;eacute;xito o fracaso de una instancia existente como crear una nueva instancia a partir de un valor de &amp;eacute;xito o fracaso.</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">Un tipo que indica si una espera temporizada en una variable de condición regresó debido a un tiempo muerto o no.</target>
        </trans-unit>
        <trans-unit id="bcb42c5f4b4345c9c33893996e574612ab86b0f7" translate="yes" xml:space="preserve">
          <source>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is not &quot;empty&quot; in the sense that there can be values of the type. Opposite of &lt;a href=&quot;#uninhabited&quot;&gt;Uninhabited&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c125cceb1922063b5ac33f0666ef79257f43a2" translate="yes" xml:space="preserve">
          <source>A type is uninhabited if it has no constructors and therefore can never be instantiated. An uninhabited type is &quot;empty&quot; in the sense that there are no values of the type. The canonical example of an uninhabited type is the &lt;a href=&quot;types/never&quot;&gt;never type&lt;/a&gt;&lt;code&gt;!&lt;/code&gt;, or an enum with no variants &lt;code&gt;enum Never { }&lt;/code&gt;. Opposite of &lt;a href=&quot;#inhabited&quot;&gt;Inhabited&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3666c5137a8c2f5bd25b41e59026d010547814d" translate="yes" xml:space="preserve">
          <source>A type mismatched an associated type of a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">Un tipo de error que puede ser devuelto cuando se adquiere una cerradura.</target>
        </trans-unit>
        <trans-unit id="e09ee31e80fe4ed67d90fe93645d23ccc6bd8f11" translate="yes" xml:space="preserve">
          <source>A type or lifetime parameter has been declared but is not actually used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">Un tipo o módulo ha sido definido más de una vez.</target>
        </trans-unit>
        <trans-unit id="630bff58f7c530334c09b287d02fb5f603530515" translate="yes" xml:space="preserve">
          <source>A type parameter that is specified for &lt;code&gt;impl&lt;/code&gt; is not constrained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">Se declaró un parámetro de tipo que ensombrece uno existente.Un ejemplo de este error:</target>
        </trans-unit>
        <trans-unit id="0e1d3a1b69ee90016db302de62e4dd15a2f4ff16" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">No se especific&amp;oacute; un par&amp;aacute;metro de tipo que hace referencia a &lt;code&gt;Self&lt;/code&gt; en su valor predeterminado. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="5ff8db748ed5eaad6145c2ecc683c1493e2ac732" translate="yes" xml:space="preserve">
          <source>A type parameter with default value is using forward declared identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">Un tipo que representa una cadena propia,compatible con C,con terminación nula y sin nulos bytes en el medio.</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">Un tipo que puede ser cualquiera de varias variantes.</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">Un tipo que puede representar cuerdas propias y mutables de la plataforma,pero que se puede interconvertir de forma barata con cuerdas de óxido.</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">Un tipo que se compone de otros tipos.</target>
        </trans-unit>
        <trans-unit id="0a851afebbaf8a3f378080846c51bf756d8476cc" translate="yes" xml:space="preserve">
          <source>A type that is not a trait was used in a trait position, such as a bound or &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">Un tipo para emular la escritura dinámica.</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">Un tipo que se usa para inicializar condicionalmente los b&amp;uacute;feres que se pasan a los m&amp;eacute;todos de &lt;code&gt;Read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a527d3dadad04c815571442c7e455c6295d0179" translate="yes" xml:space="preserve">
          <source>A type which does not appear as an argument to another type. For example, &lt;code&gt;T&lt;/code&gt; is uncovered, but the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is covered. This is only relevant for type arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a3662dff4bc918fde00d869523d6a4f45ec09b" translate="yes" xml:space="preserve">
          <source>A type with &lt;code&gt;packed&lt;/code&gt; representation hint has a field with &lt;code&gt;align&lt;/code&gt; representation hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">El comportamiento de un tipo consiste en los m&amp;eacute;todos que podemos llamar a ese tipo. Los diferentes tipos comparten el mismo comportamiento si podemos llamar a los mismos m&amp;eacute;todos en todos esos tipos. Las definiciones de rasgos son una forma de agrupar las firmas de m&amp;eacute;todos para definir un conjunto de comportamientos necesarios para lograr alg&amp;uacute;n prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Un acceso de uni&amp;oacute;n transmuta el contenido de la uni&amp;oacute;n al tipo de campo al que se accede. Dado que las transmutaciones pueden causar un comportamiento inesperado o indefinido, se requiere que &lt;code&gt;unsafe&lt;/code&gt; sea seguro leer desde un campo de uni&amp;oacute;n o escribir en un campo que no implementa &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Una declaraci&amp;oacute;n de uni&amp;oacute;n usa la misma sintaxis que una declaraci&amp;oacute;n de estructura, excepto con &lt;code&gt;union&lt;/code&gt; en lugar de &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">Una uni&amp;oacute;n declarada con &lt;code&gt;#[repr(C)]&lt;/code&gt; tendr&amp;aacute; el mismo tama&amp;ntilde;o y alineaci&amp;oacute;n que una declaraci&amp;oacute;n de uni&amp;oacute;n C equivalente en el lenguaje C para la plataforma de destino. La uni&amp;oacute;n tendr&amp;aacute; un tama&amp;ntilde;o del tama&amp;ntilde;o m&amp;aacute;ximo de todos sus campos redondeados a su alineaci&amp;oacute;n, y una alineaci&amp;oacute;n de la alineaci&amp;oacute;n m&amp;aacute;xima de todos sus campos. Estos m&amp;aacute;ximos pueden provenir de diferentes campos.</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">Un identificador único para un hilo conductor.</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">Una expresión de estructura unitaria es sólo el camino a un elemento de estructura unitaria.Se refiere a la constante implícita de la estructura unitaria de su valor.El valor de la estructura unitaria también puede construirse con una expresión de estructura sin campo.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">Se utilizó un atributo de representación no reconocido.</target>
        </trans-unit>
        <trans-unit id="5b4c71cc75880bc2daa87d6294e45d4e462f56c4" translate="yes" xml:space="preserve">
          <source>A used type name is not in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">Una entrada vacía.</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">Un valor en un &lt;code&gt;char&lt;/code&gt; que es un sustituto o superior a &lt;code&gt;char::MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">Tambi&amp;eacute;n se puede crear un valor de un tipo de &lt;a href=&quot;../items/unions&quot;&gt;uni&amp;oacute;n&lt;/a&gt; utilizando esta sintaxis, excepto que debe especificar exactamente un campo.</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">Un valor de un tipo de unión puede crearse utilizando la misma sintaxis que se utiliza para los tipos de estructura,excepto que debe especificar exactamente un campo:</target>
        </trans-unit>
        <trans-unit id="2edc0a57205327b0c616a8834c05686bc2cd3aab" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7083e77e4fd9ce896b8de61f936c4776bbf66b89" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">Un valor de tipo &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; que&lt;/a&gt; representa un &lt;strong&gt;falso&lt;/strong&gt; l&amp;oacute;gico .</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">Un valor de tipo &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; que&lt;/a&gt; representa &lt;strong&gt;verdadero&lt;/strong&gt; l&amp;oacute;gico .</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;char&lt;/code&gt; es un &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;valor escalar Unicode&lt;/a&gt; (es decir, un punto de c&amp;oacute;digo que no es un sustituto), representado como una palabra sin signo de 32 bits en el rango 0x0000 a 0xD7FF o 0xE000 a 0x10FFFF. Un &lt;code&gt;[char]&lt;/code&gt; es efectivamente una cadena UCS-4 / UTF-32.</target>
        </trans-unit>
        <trans-unit id="d1f3055da898f22398d4fbd4a38fa84ee1e65f98" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;str&lt;/code&gt; es una cadena Unicode, representada como una matriz de bytes sin firmar de 8 bits que contienen una secuencia de puntos de c&amp;oacute;digo UTF-8. Dado que &lt;code&gt;str&lt;/code&gt; es un &lt;a href=&quot;../dynamically-sized-types&quot;&gt;tipo de tama&amp;ntilde;o din&amp;aacute;mico&lt;/a&gt; , no es un tipo de &lt;em&gt;primera clase&lt;/em&gt; , pero solo se puede crear una instancia a trav&amp;eacute;s de un tipo de puntero, como &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb241cb793b74334bb4ee4c800e211086ca2124" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is represented the same way as &lt;code&gt;[u8]&lt;/code&gt;, it is a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about &lt;code&gt;str&lt;/code&gt;: methods working on &lt;code&gt;str&lt;/code&gt; assume and ensure that the data in there is valid UTF-8. Calling a &lt;code&gt;str&lt;/code&gt; method with a non-UTF-8 buffer can cause &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; now or in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Un valor que no sea &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) o &lt;code&gt;true&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) en un &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">Un valor fue movido de una matriz de tamaño fijo sin copia.</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">Un valor fue trasladado mientras todavía estaba prestado.</target>
        </trans-unit>
        <trans-unit id="82027756f29be28c79aeae3975a5766aa1d2efa8" translate="yes" xml:space="preserve">
          <source>A value was moved whose size was not known at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">Se movió un valor.Sin embargo,su tamaño no se conocía en el momento de la compilación,y sólo los valores de un tamaño conocido pueden ser movidos.</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">Un valor fue usado después de que fue mutablemente prestado.</target>
        </trans-unit>
        <trans-unit id="a269a1265b9da40e02988ddb4b935f3e57685c81" translate="yes" xml:space="preserve">
          <source>A value which is initialized on the first access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9fd9c77be9db665eaa8aa09f7c11046598c96c" translate="yes" xml:space="preserve">
          <source>A value with a custom &lt;code&gt;Drop&lt;/code&gt; implementation may be dropped during const-eval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">Un valor, una vez fijado, debe permanecer fijado para siempre (a menos que su tipo implemente &lt;code&gt;Unpin&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una conversi&amp;oacute;n de valor a valor que consume el valor de entrada. Lo contrario de &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ec26c2f12c942e7a95c50dd2e23886df77a4d3b" translate="yes" xml:space="preserve">
          <source>A variable already borrowed as immutable was borrowed as mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">Una variable se inicializa si se le ha asignado un valor y no se ha movido desde entonces.Se supone que todas las demás ubicaciones de memoria no están inicializadas.Sólo un Rust inseguro puede crear tal memoria sin inicializarla.</target>
        </trans-unit>
        <trans-unit id="bcb706d6a23f6a1ef0d6e932c9012ea02de89d1f" translate="yes" xml:space="preserve">
          <source>A variable used inside an inner function comes from a dynamic environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624b6ee4bba7ea4936aac9cd4851655dde5b7367" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">Una variable fue prestada como mutable más de una vez.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="8f68dfea86962d0e6496e5ee7e7ba76db7429014" translate="yes" xml:space="preserve">
          <source>A variable was used after its contents have been moved elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7373f15283d19d70ccdc1ebdabd671b6fa35a616" translate="yes" xml:space="preserve">
          <source>A variable which requires unique access is being used in more than one closure at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">Una fuente de entrada muy común es la entrada estándar:</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">Una implementaci&amp;oacute;n muy simple de una estructura &lt;code&gt;Balance&lt;/code&gt; que tiene dos lados, donde cada uno puede indexarse ​​de manera mutante e inmutable.</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">Una vista de una sola entrada en un mapa,que puede estar vacía u ocupada.</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada vac&amp;iacute;a en un &lt;code&gt;BTreeMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada vac&amp;iacute;a en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada vac&amp;iacute;a en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada ocupada en un &lt;code&gt;BTreeMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada ocupada en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">Una vista de una entrada ocupada en un &lt;code&gt;HashMap&lt;/code&gt; . Es parte de la enumeraci&amp;oacute;n &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una tabla de punteros de funci&amp;oacute;n virtual (vtable) que especifica el comportamiento de un &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3a191fe5eca1034f9485c5579c98bfcc0c4efc" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">Se usó un calificador de visibilidad cuando no era necesario.Ejemplos de códigos erróneos:</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">Un patr&amp;oacute;n while-let intenta coincidir con el patr&amp;oacute;n y entra en el cuerpo si la combinaci&amp;oacute;n fue exitosa. Si la coincidencia es irrefutable (cuando no puede fallar en la coincidencia), utilice un enlace &lt;code&gt;let&lt;/code&gt; normal dentro de un &lt;code&gt;loop&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="410ed7d62125fc62e5f4dca9f96376b96589d768" translate="yes" xml:space="preserve">
          <source>A windowed iterator over a slice in overlapping chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">Una solución a este problema es envolver el rasgo en una estructura,e implementar Drop en eso.A continuación se muestra un ejemplo:</target>
        </trans-unit>
        <trans-unit id="f617743555e205f1a8f890d184cd3c23b7f7c1f7" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">Una versión de trabajo sería:</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">Un envoltorio para &lt;code&gt;va_list&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">Un contenedor para impedir que el compilador llame autom&amp;aacute;ticamente al destructor de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd107425d645d1765a8fa8c1d57cb5b2986006a8" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor. This wrapper is 0-cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Un tipo de contenedor para un valor prestado de manera &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; un RefCell &amp;lt;T&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Un tipo de envoltura de construir casos no inicializadas de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">Un escritor que moverá datos al vacío.</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">Un tir&amp;oacute;n &lt;em&gt;no&lt;/em&gt; borra ning&amp;uacute;n c&amp;oacute;digo. Por ejemplo, la funci&amp;oacute;n yank no est&amp;aacute; dise&amp;ntilde;ada para eliminar secretos cargados accidentalmente. Si eso sucede, debe restablecer esos secretos de inmediato.</target>
        </trans-unit>
        <trans-unit id="c0f586bae86592aff79f5cdbd80a984e38bc5729" translate="yes" xml:space="preserve">
          <source>A yield expression was used outside of the generator literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI,vinculación,símbolos y FFI</target>
        </trans-unit>
        <trans-unit id="711248439308ea2477b7d1f8ab4f7bd34663bf23" translate="yes" xml:space="preserve">
          <source>APIs like &lt;code&gt;try_for_each&lt;/code&gt; don't need values with &lt;code&gt;Break&lt;/code&gt;, so this provides a way to avoid typing &lt;code&gt;(())&lt;/code&gt;, if you prefer it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Las plataformas ARM como &lt;code&gt;armv5te&lt;/code&gt; que no son para Linux no tienen atomics en absoluto.</target>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">Los objetivos ARM con &lt;code&gt;thumbv6m&lt;/code&gt; no tienen operaciones at&amp;oacute;micas en absoluto.</target>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">ASCII :</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">ASCII byte literal</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">El ASCII se escapa</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">Las letras ASCII de la &quot;A&quot; a la &quot;Z&quot; están asignadas a la &quot;a&quot; a la &quot;z&quot;,pero las letras no ASCII no cambian.</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">Las letras ASCII de la &quot;a&quot; a la &quot;z&quot; están asignadas a la &quot;A&quot; a la &quot;Z&quot;,pero las letras no ASCII no cambian.</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR :</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING :</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">Abortar por error o fallo en la asignación de memoria.</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">Aborta la ejecución del proceso.</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">Tipos de retorno abstracto</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">Los tipos de retorno abstracto ( &lt;code&gt;impl Trait&lt;/code&gt; escrito para alg&amp;uacute;n rasgo de &lt;code&gt;Trait&lt;/code&gt; ) solo se permiten como tipos de retorno impl&amp;iacute;citos de funci&amp;oacute;n e inherentes.</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">Árbol de sintaxis abstracta</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">Acepta una nueva conexión entrante de este oyente.</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">Aceptando los argumentos de la línea de mando</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">Acepta pedidos &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">Acepta una nueva conexión entrante con este oyente.</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">Acceder a una entrada mediante una llave y su hachís.</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">Accede a una entrada por hachís.</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">Acceder a una entrada por clave.</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">Campos de acceso en una estructura empaquetada:</target>
        </trans-unit>
        <trans-unit id="dcc61ae90f40e1ace5937cd1dcd9d685d9053fd4" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;a href=&quot;keyword.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b465e0094928c80bf2ab2af5859dca5bafc8fa28" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;code&gt;union&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">Acceder a los miembros de una estructura empaquetada por referencia:</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">Acceder o modificar una variable estática mutable</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">Acceda al error UTF-8 subyacente que fue la causa de este error.</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">Acceso a los elementos de la matriz</target>
        </trans-unit>
        <trans-unit id="0457e6128b17f06deb434a0c2873ebd99b60eb0d" translate="yes" xml:space="preserve">
          <source>Accessing Fields of a Union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">Acceder a los valores en un mapa Hash</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">Acceder a un campo de un &lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; , que no sea para asignarlo.</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">Accediendo al adyacente &lt;code&gt;u8&lt;/code&gt; como &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="translated">Acceder a los datos en el mont&amp;oacute;n es m&amp;aacute;s lento que acceder a los datos en la pila porque debe seguir un puntero para llegar all&amp;iacute;. Los procesadores contempor&amp;aacute;neos son m&amp;aacute;s r&amp;aacute;pidos si saltan menos en la memoria. Continuando con la analog&amp;iacute;a, considere a un mesero en un restaurante que recibe pedidos de muchas mesas. Es m&amp;aacute;s eficiente obtener todos los pedidos en una mesa antes de pasar a la siguiente. Tomar un pedido de la tabla A, luego un pedido de la tabla B, luego uno de A nuevamente, y luego uno de B nuevamente ser&amp;iacute;a un proceso mucho m&amp;aacute;s lento. Del mismo modo, un procesador puede hacer mejor su trabajo si trabaja con datos que est&amp;aacute;n cerca de otros datos (como est&amp;aacute;n en la pila) en lugar de m&amp;aacute;s lejos (como pueden estar en el mont&amp;oacute;n). La asignaci&amp;oacute;n de una gran cantidad de espacio en el mont&amp;oacute;n tambi&amp;eacute;n puede llevar tiempo.</target>
        </trans-unit>
        <trans-unit id="f239f31c4b24ce084fa39af1811c8d4fc4e10b36" translate="yes" xml:space="preserve">
          <source>Accessing non-&lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt;&lt;code&gt;static&lt;/code&gt; items is considered safe, but some restrictions apply. Most notably, the type of a &lt;code&gt;static&lt;/code&gt; value needs to implement the &lt;a href=&quot;marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait, ruling out interior mutability containers like &lt;a href=&quot;cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../reference/items/static-items&quot;&gt;Reference&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="translated">Acceder o modificar una variable estática mutable</target>
        </trans-unit>
        <trans-unit id="f13080b643bf72eee286858a8d7c3ab06b544915" translate="yes" xml:space="preserve">
          <source>Accessing unaligned fields directly with e.g. &lt;code&gt;packed.unaligned&lt;/code&gt; is safe however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="translated">Documentar con precisi&amp;oacute;n sus paquetes ayudar&amp;aacute; a otros usuarios a saber c&amp;oacute;mo y cu&amp;aacute;ndo usarlos, por lo que vale la pena invertir tiempo en escribir documentaci&amp;oacute;n. En el Cap&amp;iacute;tulo 3, discutimos c&amp;oacute;mo comentar el c&amp;oacute;digo Rust usando dos barras, &lt;code&gt;//&lt;/code&gt; . Rust tambi&amp;eacute;n tiene un tipo particular de comentario para la documentaci&amp;oacute;n, conocido convenientemente como &lt;em&gt;comentario de documentaci&amp;oacute;n&lt;/em&gt; , que generar&amp;aacute; documentaci&amp;oacute;n HTML. El HTML muestra el contenido de los comentarios de la documentaci&amp;oacute;n para los elementos p&amp;uacute;blicos de la API destinados a los programadores interesados ​​en saber c&amp;oacute;mo &lt;em&gt;usar&lt;/em&gt; su caja en lugar de c&amp;oacute;mo se &lt;em&gt;implementa&lt;/em&gt; su caja .</target>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="translated">Adquirir-una barrera para adquirir una cerradura.Las lecturas y escritos subsiguientes tienen lugar después de la barrera.</target>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="translated">Adquiere una referencia mutable a la forma propia de los datos.</target>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="translated">Adquiere un mutex,bloqueando el hilo actual hasta que sea capaz de hacerlo.</target>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="translated">Adquiere una referencia al valor de esta clave TLS.</target>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="translated">Adquiere el puntero &lt;code&gt;*mut&lt;/code&gt; subyacente .</target>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="translated">Adquirir la ruta del ejecutable actual es una operación específica de la plataforma que puede fallar por un buen número de razones.Algunos errores pueden ser,entre otros,fallos en las operaciones del sistema de archivos o fallos generales del sistema de llamadas.</target>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="translated">Atributos activos e inertes</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="translated">Adaptador para encadenar dos lectores.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="5377ba24487df148115875083e9ad3100b466293" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;'static&lt;/code&gt; requirement to fix them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="translated">Agregue un m&amp;eacute;todo de &lt;code&gt;reject&lt;/code&gt; que cambie el estado de la &lt;code&gt;PendingReview&lt;/code&gt; de PendingReview a &lt;code&gt;Draft&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">Agregue una descripci&amp;oacute;n que sea solo una oraci&amp;oacute;n o dos, porque aparecer&amp;aacute; con su caja en los resultados de b&amp;uacute;squeda. Para el campo de la &lt;code&gt;license&lt;/code&gt; , debe proporcionar un &lt;em&gt;valor de identificador de licencia&lt;/em&gt; . El &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Software Package Data Exchange (SPDX) de Linux Foundation&lt;/a&gt; enumera los identificadores que puede usar para este valor. Por ejemplo, para especificar que ha obtenido la licencia de su caja con la licencia MIT, agregue el identificador &lt;code&gt;MIT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="translated">Añade una función de obtención:</target>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="translated">Añade las restricciones que deben respetarse para utilizar un artículo.</target>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="translated">Agregue m&amp;aacute;s documentaci&amp;oacute;n a &lt;code&gt;ThreadPool&lt;/code&gt; y sus m&amp;eacute;todos p&amp;uacute;blicos.</target>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="translated">Agregue pruebas de la funcionalidad de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="translated">Añade el tamaño del campo.</target>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="translated">Add::add</target>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="translated">AddAssign</target>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="translated">AddAssign::add_assign</target>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="translated">Agregar &lt;code&gt;rand&lt;/code&gt; como una dependencia en &lt;em&gt;Cargo.toml&lt;/em&gt; le dice a Cargo que descargue el paquete &lt;code&gt;rand&lt;/code&gt; y cualquier dependencia de &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; y haga que &lt;code&gt;rand&lt;/code&gt; est&amp;eacute; disponible para nuestro proyecto.</target>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="translated">Agregar &lt;code&gt;use&lt;/code&gt; y una ruta en un alcance es similar a crear un enlace simb&amp;oacute;lico en el sistema de archivos. Al agregar &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; en la ra&amp;iacute;z de la caja, &lt;code&gt;hosting&lt;/code&gt; ahora es un nombre v&amp;aacute;lido en ese &amp;aacute;mbito, como si el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; se hubiera definido en la ra&amp;iacute;z de la caja. Las rutas que se incorporan al alcance con el &lt;code&gt;use&lt;/code&gt; tambi&amp;eacute;n verifican la privacidad, como cualquier otra ruta.</target>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="translated">Añadir mensajes de error personalizados</target>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="translated">Agregar metadatos a una nueva caja</target>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="translated">Añadiendo funcionalidad útil con rasgos derivados</target>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="translated">Agregar un campo &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; a su tipo le dice al compilador que su tipo act&amp;uacute;a como si almacenara un valor de tipo &lt;code&gt;T&lt;/code&gt; , aunque en realidad no lo hace. Esta informaci&amp;oacute;n se utiliza al calcular ciertas propiedades de seguridad.</target>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="translated">Agregar un &lt;code&gt;Self: Sized&lt;/code&gt; vinculado a estos m&amp;eacute;todos generalmente har&amp;aacute; esta compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="translated">Añadir una referencia de un niño a su padre</target>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="translated">Añadir una prueba a un espacio de trabajo</target>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="translated">Adici&amp;oacute;n de un campo de tipo &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indica que el tipo de datos propietaria de tipo &lt;code&gt;T&lt;/code&gt; . Esto a su vez implica que cuando se deja caer su tipo, se puede caer una o m&amp;aacute;s instancias del tipo &lt;code&gt;T&lt;/code&gt; . Esto influye en el an&amp;aacute;lisis de &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;comprobaci&amp;oacute;n de ca&amp;iacute;da&lt;/a&gt; del compilador de Rust .</target>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="translated">Agregar bloques de c&amp;oacute;digo de ejemplo en los comentarios de su documentaci&amp;oacute;n puede ayudar a demostrar c&amp;oacute;mo usar su biblioteca, y hacerlo tiene una ventaja adicional: &amp;iexcl;ejecutar &lt;code&gt;cargo test&lt;/code&gt; ejecutar&amp;aacute; los ejemplos de c&amp;oacute;digo en su documentaci&amp;oacute;n como pruebas! Nada es mejor que la documentaci&amp;oacute;n con ejemplos. Pero nada es peor que los ejemplos que no funcionan porque el c&amp;oacute;digo ha cambiado desde que se escribi&amp;oacute; la documentaci&amp;oacute;n. Si ejecutamos &lt;code&gt;cargo test&lt;/code&gt; con la documentaci&amp;oacute;n para la funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; del Listado 14-1, veremos una secci&amp;oacute;n en los resultados de la prueba como esta:</target>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="translated">Agregar el m&amp;eacute;todo de &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; que cambia el comportamiento del &lt;code&gt;content&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;A&amp;ntilde;adiendo la l&amp;iacute;nea de &lt;code&gt;break&lt;/code&gt; despu&amp;eacute;s de &lt;code&gt;You win!&lt;/code&gt; hace que el programa salga del ciclo cuando el usuario adivina el n&amp;uacute;mero secreto correctamente. Salir del bucle tambi&amp;eacute;n significa salir del programa, porque el bucle es la &amp;uacute;ltima parte de &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="translated">Al agregar la palabra clave &lt;code&gt;mut&lt;/code&gt; ,se elimina la referencia a una referencia mutable. La mutabilidad debe coincidir con la mutabilidad de la referencia.</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="translated">Asignación de la adición</target>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="translated">Funcionalidad adicional para los números.</target>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="translated">Implementadores adicionales</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">Información adicional</target>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Par&amp;aacute;metros adicionales pasados ​​al &lt;code&gt;format!&lt;/code&gt; reemplace los &lt;code&gt;{}&lt;/code&gt; s dentro de la cadena de formato en el orden dado, a menos que se usen par&amp;aacute;metros con nombre o posicionales; consulte &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b89443b71b82e921f27bf8622eec75e5bb710e5e" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cf45e8eb3455f9aeaa5f7fa4c013c3116744f0" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;f32&lt;/code&gt; can represent a couple of special values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, un tipo &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; puede implementar &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; implementa &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; o &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; . Esto le permite proporcionar una coerci&amp;oacute;n sin tama&amp;ntilde;o a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="translated">Adem&amp;aacute;s, aunque &lt;code&gt;$crate&lt;/code&gt; permite que una macro se refiera a elementos dentro de su propia caja cuando se expande, su uso no tiene ning&amp;uacute;n efecto sobre la visibilidad. Un elemento o macro al que se hace referencia debe seguir siendo visible desde el sitio de invocaci&amp;oacute;n. En el siguiente ejemplo, cualquier intento de invocar &lt;code&gt;call_foo!()&lt;/code&gt; Desde fuera de su caja fallar&amp;aacute; porque &lt;code&gt;foo()&lt;/code&gt; no es p&amp;uacute;blico.</target>
        </trans-unit>
        <trans-unit id="8bd65ffd560b03ecf2792061831bdc28c657f4f7" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">Adem&amp;aacute;s, si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , usar el valor apuntado despu&amp;eacute;s de llamar a &lt;code&gt;drop_in_place&lt;/code&gt; puede causar un comportamiento indefinido. Tenga en cuenta que &lt;code&gt;*to_drop = foo&lt;/code&gt; cuenta como un uso porque har&amp;aacute; que el valor se elimine nuevamente. &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se puede utilizar para sobrescribir datos sin que se eliminen.</target>
        </trans-unit>
        <trans-unit id="4db0827a894435e479c60b5c414ff857b4d8ad46" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">Adem&amp;aacute;s, si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , usar el valor apuntado despu&amp;eacute;s de llamar a &lt;code&gt;drop_in_place&lt;/code&gt; puede causar un comportamiento indefinido. Tenga en cuenta que &lt;code&gt;*to_drop = foo&lt;/code&gt; cuenta como un uso porque har&amp;aacute; que el valor se elimine nuevamente. &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se puede utilizar para sobrescribir datos sin que se eliminen.</target>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, no elimina &lt;code&gt;src&lt;/code&gt; . Sem&amp;aacute;nticamente, &lt;code&gt;src&lt;/code&gt; se mueve a la ubicaci&amp;oacute;n apuntada por &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, en Unix &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; implementa el rasgo &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; , que proporciona m&amp;eacute;todos &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt; que consumen sus argumentos y toman o producen vectores de &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db4d415a7232a66cc30ffdbd6dbfd6bc3c496f2" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="translated">Adem&amp;aacute;s, en Windows &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; implementa el rasgo &lt;code&gt;std::os::windows:ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; , que proporciona un m&amp;eacute;todo &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;from_wide&lt;/code&gt; &lt;/a&gt; . El resultado de este m&amp;eacute;todo es un &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; que se puede redirigir a una cadena de Windows sin p&amp;eacute;rdidas.</target>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="translated">Adem&amp;aacute;s, quitar un trabajo de la cola del canal implica mutar el &lt;code&gt;receiver&lt;/code&gt; , por lo que los hilos necesitan una forma segura de compartir y modificar el &lt;code&gt;receiver&lt;/code&gt; ; de lo contrario, podr&amp;iacute;amos obtener condiciones de carrera (como se describe en el Cap&amp;iacute;tulo 16).</target>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="translated">Adem&amp;aacute;s, los tipos de &lt;code&gt;isize&lt;/code&gt; y &lt;code&gt;usize&lt;/code&gt; dependen del tipo de computadora en la que se ejecuta su programa: 64 bits si est&amp;aacute; en una arquitectura de 64 bits y 32 bits si est&amp;aacute; en una arquitectura de 32 bits.</target>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">Adem&amp;aacute;s, la persona que llama debe asegurarse de que la escritura &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes a la regi&amp;oacute;n dada de resultados de memoria en un valor v&amp;aacute;lido de la &lt;code&gt;T&lt;/code&gt; . Usar una regi&amp;oacute;n de memoria escrita como &lt;code&gt;T&lt;/code&gt; que contiene un valor inv&amp;aacute;lido de &lt;code&gt;T&lt;/code&gt; es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="translated">Además,la longitud de la cuerda se recalculará a partir del puntero.</target>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="translated">Adem&amp;aacute;s, el tiempo de vida &lt;code&gt;'a&lt;/code&gt; devuelto se arbitrariamente elegido y no refleja necesariamente la vida &amp;uacute;til real de los datos. Depende de la persona que llama asegurarse de que, durante esta vida, no se acceda a la memoria a la que apunta este puntero a trav&amp;eacute;s de ning&amp;uacute;n otro puntero.</target>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, el tiempo de vida &lt;code&gt;'a&lt;/code&gt; devuelto se arbitrariamente elegido y no refleja necesariamente la vida &amp;uacute;til real de los datos. &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; de la persona que llama asegurarse de que durante esta vida &amp;uacute;til, la memoria a la que apunta este puntero no se escriba fuera de UnsafeCell &amp;lt;U&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="translated">Adem&amp;aacute;s, el valor de retorno de esta funci&amp;oacute;n es &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; que es un alias de tipo de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;(), &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;std::fmt::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Las implementaciones de formato deben asegurar que propaguen errores desde el &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; (por ejemplo, al llamar a &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; ). Sin embargo, nunca deben devolver errores de forma falsa. Es decir, una implementaci&amp;oacute;n de formato debe y solo puede devolver un error si el &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; pasadodevuelve un error. Esto se debe a que, contrariamente a lo que podr&amp;iacute;a sugerir la firma de la funci&amp;oacute;n, el formateo de cadenas es una operaci&amp;oacute;n infalible. Esta funci&amp;oacute;n solo devuelve un resultado porque la escritura en la secuencia subyacente puede fallar y debe proporcionar una forma de propagar el hecho de que se ha producido un error en la pila.</target>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="translated">Adem&amp;aacute;s, todav&amp;iacute;a no podemos proporcionar la funci&amp;oacute;n &lt;code&gt;hello_macro&lt;/code&gt; con la implementaci&amp;oacute;n predeterminada que imprimir&amp;aacute; el nombre del tipo en el que se implementa el rasgo: Rust no tiene capacidades de reflexi&amp;oacute;n, por lo que no puede buscar el nombre del tipo en tiempo de ejecuci&amp;oacute;n. Necesitamos una macro para generar c&amp;oacute;digo en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="translated">Adem&amp;aacute;s, necesitar&amp;aacute; alg&amp;uacute;n tipo de vinculador. Es probable que ya haya uno instalado, pero cuando intentas compilar un programa Rust y obtienes errores que indican que un vinculador no se pudo ejecutar, eso significa que no hay un vinculador instalado en tu sistema y necesitar&amp;aacute;s instalar uno manualmente. Los compiladores de C generalmente vienen con el enlazador correcto. Consulte la documentaci&amp;oacute;n de su plataforma para saber c&amp;oacute;mo instalar un compilador de C. Adem&amp;aacute;s, algunos paquetes comunes de Rust dependen del c&amp;oacute;digo C y necesitar&amp;aacute;n un compilador C. Por lo tanto, podr&amp;iacute;a valer la pena instalar uno ahora.</target>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="translated">AddrParseError</target>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="translated">AddrParseError::borrow</target>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="translated">AddrParseError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="translated">AddrParseError::cause</target>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="translated">AddrParseError::clone</target>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="translated">AddrParseError::clone_from</target>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="translated">AddrParseError::clone_into</target>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="translated">AddrParseError::description</target>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="translated">AddrParseError::eq</target>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="translated">AddrParseError::fmt</target>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="translated">AddrParseError::from</target>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="translated">AddrParseError::into</target>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="translated">AddrParseError::ne</target>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="translated">AddrParseError::source</target>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="translated">AddrParseError::to_owned</target>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="translated">AddrParseError::to_string</target>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="translated">AddrParseError::try_from</target>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="translated">AddrParseError::try_into</target>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="translated">AddrParseError::type_id</target>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="translated">Dirección para el puntero</target>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">El tipo de direcci&amp;oacute;n puede ser cualquier implementador del rasgo &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para ver ejemplos concretos.</target>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="translated">Las direcciones devueltas por el sistema operativo que no son direcciones IP son ignoradas silenciosamente.</target>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="translated">Agrega un m&amp;eacute;todo &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; a un iterador. Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="translated">Agrega un &lt;code&gt;usize&lt;/code&gt; , devolviendo &lt;code&gt;None&lt;/code&gt; en caso de desbordamiento.</target>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="translated">Añade una nueva entrada a la salida de la lista.</target>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="translated">Añade una nueva entrada a la salida del mapa.</target>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="translated">Añade una nueva entrada a la salida del conjunto.</target>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="translated">Añade un nuevo campo a la salida de la estructura generada.</target>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="translated">Añade un nuevo campo a la salida de la estructura tuple generada.</target>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="translated">Añade un valor al conjunto,reemplazando el valor existente,si lo hay,que es igual al dado.Devuelve el valor sustituido.</target>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="translated">Añade un valor al conjunto.</target>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="translated">Añade un argumento para pasar al programa.</target>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="translated">Añade un elemento primero en la lista.</target>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="translated">Añade múltiples argumentos para pasar al programa.</target>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="translated">Añade uno a este paso,devolviendo el resultado.</target>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="translated">Añade o actualiza múltiples mapeos de variables de entorno.</target>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="translated">Añade soporte para tipos especiales de archivos Unix como dispositivos de bloque/caracteres,tuberías y enchufes.</target>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="translated">Añade el contenido de un iterador de entradas a la salida de la lista.</target>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="translated">Añade el contenido de un iterador de entradas a la salida del mapa.</target>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="translated">Añade el contenido de un iterador de entradas a la salida del conjunto.</target>
        </trans-unit>
        <trans-unit id="525909640b425a3865879f7bf9b4776de0cbde79" translate="yes" xml:space="preserve">
          <source>Adds the key part of a new entry to the map output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b33d8253f240296388fcf0db6ce4c17b122fb9" translate="yes" xml:space="preserve">
          <source>Adds the value part of a new entry to the map output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="translated">Se añade al valor actual,devolviendo el valor anterior.</target>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se suma al valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_add&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se suma al valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_add&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se suma al valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_add&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se suma al valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_add&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se suma al valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_add&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6c863d4412a4b55b1d93cf3d5f7516528289e4" translate="yes" xml:space="preserve">
          <source>Advance the internal cursor of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="translated">Avanza al siguiente arg.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">Características avanzadas</target>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="translated">Funciones avanzadas y cierres</target>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="translated">Rasgos avanzados</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">Tipos avanzados</target>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="translated">Funciones avanzadas y cierres:punteros de función y cierres de retorno</target>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="translated">Rasgos avanzados:tipos asociados,parámetros de tipos por defecto,sintaxis totalmente cualificada,supertratos y el nuevo patrón de tipos en relación con los rasgos</target>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="translated">Tipos avanzados:más sobre el patrón de nuevos tipos,alias de tipos,el tipo nunca,y tipos de tamaño dinámico</target>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="translated">Avanza el iterador y devuelve el siguiente valor.</target>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Avanza el iterador y devuelve el siguiente valor. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Avanza el iterador y devuelve el siguiente valor. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Avanza el iterador y devuelve el siguiente valor. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Avanza el iterador y devuelve el siguiente valor. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Avanza el iterador y devuelve el siguiente valor. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c629d1551783824351df46023949d62af853825" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fef351384b0144be153be53f79c7fc476bedfc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41de8018927ed7b54950980aec11f8f12d46606f" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09741f9824923fbfa016237025da37c62ee69dcc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3b9d2faa7136ddd042e31d3939c786f1c8da2c" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fde24899e07da847358f17c288cfcfe8ae74ea" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d66799c08b5e49880157cde9e0d13d223a5c3a3" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1f4e504d47f61c437fd02db056daa6ec47dc6c" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d59517951217a4fde7238ff6227ce7834fa1b5e" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bb721017aea2eeaededef2c5c856023eca871d" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148c4a64097476a8bb5779b8f3210d3b2962ff05" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="translated">Despu&amp;eacute;s de &lt;code&gt;#[test]&lt;/code&gt; agregamos la l&amp;iacute;nea &lt;code&gt;#[ignore]&lt;/code&gt; a la prueba que queremos excluir. Ahora cuando nos encontramos nuestras pruebas, &lt;code&gt;it_works&lt;/code&gt; carreras, pero &lt;code&gt;expensive_test&lt;/code&gt; no:</target>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="translated">Despu&amp;eacute;s de la &lt;code&gt;crate&lt;/code&gt; , incluimos cada uno de los m&amp;oacute;dulos sucesivos hasta llegar a &lt;code&gt;add_to_waitlist&lt;/code&gt; . Puede imaginar un sistema de archivos con la misma estructura, y especificar&amp;iacute;amos la ruta &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; para ejecutar el programa &lt;code&gt;add_to_waitlist&lt;/code&gt; ; usar el nombre de la &lt;code&gt;crate&lt;/code&gt; para comenzar desde la ra&amp;iacute;z de la caja es como usar &lt;code&gt;/&lt;/code&gt; para comenzar desde la ra&amp;iacute;z del sistema de archivos en su shell.</target>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="translated">Despu&amp;eacute;s de que se devuelva &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;skip_while()&lt;/code&gt; termina y el resto de los elementos se obtienen.</target>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="translated">Despu&amp;eacute;s de que se devuelve &lt;code&gt;false&lt;/code&gt; , el trabajo de &lt;code&gt;take_while()&lt;/code&gt; termina y el resto de los elementos se ignoran.</target>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="translated">Despu&amp;eacute;s de que se crea la &lt;code&gt;leaf&lt;/code&gt; , su &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; tiene un conteo fuerte de 1 y un conteo d&amp;eacute;bil de 0. En el &amp;aacute;mbito interno, creamos una &lt;code&gt;branch&lt;/code&gt; y la asociamos con la &lt;code&gt;leaf&lt;/code&gt; , en cuyo punto cuando imprimimos los conteos, el &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; en la &lt;code&gt;branch&lt;/code&gt; tendr&amp;aacute; un recuento fuerte de 1 y un recuento d&amp;eacute;bil de 1 (para &lt;code&gt;leaf.parent&lt;/code&gt; apuntando a la &lt;code&gt;branch&lt;/code&gt; con un &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ). Cuando imprimimos los recuentos en &lt;code&gt;leaf&lt;/code&gt; , veremos que tendr&amp;aacute; un recuento fuerte de 2, porque &lt;code&gt;branch&lt;/code&gt; ahora tiene un clon del &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; de &lt;code&gt;leaf&lt;/code&gt; almacenado en &lt;code&gt;branch.children&lt;/code&gt; , pero a&amp;uacute;n tendr&amp;aacute; un recuento d&amp;eacute;bil de 0.</target>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="translated">Despu&amp;eacute;s de que un iterador devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas futuras pueden o no producir &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; &lt;/a&gt; nuevamente. &lt;code&gt;fuse()&lt;/code&gt; adapta un iterador, asegur&amp;aacute;ndose de que despu&amp;eacute;s de dar &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , siempre devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; para siempre.</target>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">Despu&amp;eacute;s de aplicar este cierre a cada elemento del iterador, &lt;code&gt;fold()&lt;/code&gt; devuelve el acumulador.</target>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">Despu&amp;eacute;s de aplicar este cierre a cada elemento del iterador, &lt;code&gt;rfold()&lt;/code&gt; devuelve el acumulador.</target>
        </trans-unit>
        <trans-unit id="dbffd4bfa583f6bbb8aa4395e63df871ca521db4" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;v.as_mut_ptr()&lt;/code&gt; and transmitting the ownership of the data to &lt;code&gt;s&lt;/code&gt;, the &lt;code&gt;v&lt;/code&gt; value is invalid. Even when a value is just moved to &lt;code&gt;mem::forget&lt;/code&gt; (which won't inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned. Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">Despu&amp;eacute;s de llamar a esta funci&amp;oacute;n, el llamante es responsable de la memoria previamente gestionada por &lt;code&gt;Box&lt;/code&gt; . En particular, la persona que llama debe destruir correctamente &lt;code&gt;T&lt;/code&gt; y liberar la memoria, teniendo en cuenta el &lt;a href=&quot;index#memory-layout&quot;&gt;dise&amp;ntilde;o de memoria&lt;/a&gt; utilizado por &lt;code&gt;Box&lt;/code&gt; . La forma m&amp;aacute;s sencilla de hacer esto es convertir el puntero en bruto de nuevo en un &lt;code&gt;Box&lt;/code&gt; con la funci&amp;oacute;n &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; , permitiendo que el destructor de &lt;code&gt;Box&lt;/code&gt; realice la limpieza.</target>
        </trans-unit>
        <trans-unit id="7cad9f1c8273ecabd3f00d51212a63d92e2f707f" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw_in&quot;&gt;&lt;code&gt;Box::from_raw_in&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Despu&amp;eacute;s de llamar a esta funci&amp;oacute;n, el llamante es responsable de la memoria previamente gestionada por &lt;code&gt;Box&lt;/code&gt; . En particular, la persona que llama debe destruir correctamente &lt;code&gt;T&lt;/code&gt; y liberar la memoria. La forma m&amp;aacute;s sencilla de hacerlo es convertir el &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; en un puntero sin formato y de nuevo en un &lt;code&gt;Box&lt;/code&gt; con la funci&amp;oacute;n &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e43a947242c53bd7c33db133c10548b5bd4c117" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;String&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102d1de8629b57b21dac90f6d521b49048558b05" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Vec&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;Vec&lt;/code&gt; with the &lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="translated">Despu&amp;eacute;s de llamar a esta funci&amp;oacute;n, el puntero sin formato es propiedad del &lt;code&gt;Box&lt;/code&gt; resultante . Espec&amp;iacute;ficamente, el destructor de &lt;code&gt;Box&lt;/code&gt; llamar&amp;aacute; al destructor de &lt;code&gt;T&lt;/code&gt; y liberar&amp;aacute; la memoria asignada. Para que esto sea seguro, la memoria debe haber sido asignada de acuerdo con el &lt;a href=&quot;index#memory-layout&quot;&gt;dise&amp;ntilde;o de memoria&lt;/a&gt; utilizado por &lt;code&gt;Box&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Despu&amp;eacute;s de cambiar &lt;code&gt;println!&lt;/code&gt; para &lt;code&gt;eprintln!&lt;/code&gt; , ejecutemos el programa nuevamente de la misma manera, sin ning&amp;uacute;n argumento y redirigiendo la salida est&amp;aacute;ndar con &lt;code&gt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de crear un &lt;code&gt;TcpListener&lt;/code&gt; por &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; ing a una direcci&amp;oacute;n de conector, que recibe las conexiones TCP entrantes. Estos se pueden aceptar llamando a &lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; o iterando sobre el iterador &lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt; devuelto por &lt;a href=&quot;#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06868983dd9010816d16a947a2feebe64fc6c151" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">Despu&amp;eacute;s de crear un &lt;code&gt;TcpStream&lt;/code&gt; ya sea por &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; ing a un host remoto o &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; ing una conexi&amp;oacute;n en un &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; , los datos pueden ser transmitidos por &lt;a href=&quot;../io/trait.read&quot;&gt;la lectura&lt;/a&gt; y &lt;a href=&quot;../io/trait.write&quot;&gt;la escritura&lt;/a&gt; a la misma.</target>
        </trans-unit>
        <trans-unit id="dafc89a72358e6711ac4be0166b7dcfdffe57a68" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">Despu&amp;eacute;s de crear un &lt;code&gt;UdpSocket&lt;/code&gt; por &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; ing a una direcci&amp;oacute;n de conector, los datos pueden ser &lt;a href=&quot;#method.send_to&quot;&gt;enviados a&lt;/a&gt; y &lt;a href=&quot;#method.recv_from&quot;&gt;recibidos desde&lt;/a&gt; cualquier otra direcci&amp;oacute;n de socket.</target>
        </trans-unit>
        <trans-unit id="394b482d2eb5a6a4fcc8d7fdff6cfe2cd24f75e2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="translated">Despu&amp;eacute;s de crear una nueva instancia de &lt;code&gt;Job&lt;/code&gt; usando el cierre que nos ponemos en &lt;code&gt;execute&lt;/code&gt; , enviamos ese trabajo por el extremo de env&amp;iacute;o del canal. Llamamos a &lt;code&gt;unwrap&lt;/code&gt; al &lt;code&gt;send&lt;/code&gt; para el caso de que el env&amp;iacute;o falle. Esto podr&amp;iacute;a suceder si, por ejemplo, dejamos de ejecutar todos nuestros hilos, lo que significa que el extremo receptor ha dejado de recibir nuevos mensajes. Por el momento, no podemos detener la ejecuci&amp;oacute;n de nuestros hilos: nuestros hilos contin&amp;uacute;an ejecut&amp;aacute;ndose mientras exista el grupo. La raz&amp;oacute;n por la que usamos &lt;code&gt;unwrap&lt;/code&gt; es porque sabemos que el caso de falla no suceder&amp;aacute;, pero el compilador no lo sabe.</target>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="translated">Despu&amp;eacute;s de soltar el bloqueo, podemos imprimir el valor de mutex y ver que pudimos cambiar el &lt;code&gt;i32&lt;/code&gt; interno a 6.</target>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="translated">Despu&amp;eacute;s de implementar el rasgo, podemos llamar a los m&amp;eacute;todos en instancias de &lt;code&gt;NewsArticle&lt;/code&gt; y &lt;code&gt;Tweet&lt;/code&gt; de la misma manera que llamamos m&amp;eacute;todos regulares, como este:</target>
        </trans-unit>
        <trans-unit id="6aee078dffc9ca07e378d1b98649828937e42093" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-21.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="translated">Despu&amp;eacute;s de aprender sobre el ciclo &lt;code&gt;while let&lt;/code&gt; en el Cap&amp;iacute;tulo 18, es posible que se pregunte por qu&amp;eacute; no escribimos el c&amp;oacute;digo del hilo de trabajo como se muestra en el Listado 20-22.</target>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de ejecutar el c&amp;oacute;digo, el comportamiento de la precedencia es evidente: si la protecci&amp;oacute;n de coincidencia se aplicara solo al valor final en la lista de valores especificada usando el &lt;code&gt;|&lt;/code&gt; operador, el brazo habr&amp;iacute;a coincidido y el programa habr&amp;iacute;a impreso &lt;code&gt;yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="translated">Despu&amp;eacute;s de un tiempo, una vez que los desarrolladores de Rust que usan lanzamientos nocturnos hayan podido probar la nueva funci&amp;oacute;n, los miembros del equipo discutir&amp;aacute;n la funci&amp;oacute;n, c&amp;oacute;mo funciona cada noche y decidir&amp;aacute;n si debe convertirse en Rust estable o no. Si la decisi&amp;oacute;n es seguir adelante, la puerta de funci&amp;oacute;n se elimina y la funci&amp;oacute;n ahora se considera estable. Lleva los trenes a una nueva versi&amp;oacute;n estable de Rust.</target>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="translated">Despu&amp;eacute;s de esa declaraci&amp;oacute;n, nuevamente agregamos un &lt;code&gt;println!&lt;/code&gt; temporal . declaraci&amp;oacute;n que imprime el valor de los &lt;code&gt;contents&lt;/code&gt; despu&amp;eacute;s de leer el archivo, para que podamos comprobar que el programa est&amp;aacute; funcionando hasta el momento.</target>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="translated">Despu&amp;eacute;s de la firma del m&amp;eacute;todo, en lugar de proporcionar una implementaci&amp;oacute;n entre llaves, usamos un punto y coma. Cada tipo que implemente este rasgo debe proporcionar su propio comportamiento personalizado para el cuerpo del m&amp;eacute;todo. El compilador har&amp;aacute; cumplir que cualquier tipo que tenga el rasgo de &lt;code&gt;Summary&lt;/code&gt; tendr&amp;aacute; el m&amp;eacute;todo de &lt;code&gt;summarize&lt;/code&gt; definido con esta firma exactamente.</target>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="translated">Despu&amp;eacute;s de los par&amp;aacute;metros, colocamos llaves que sostienen el cuerpo del cierre; estos son opcionales si el cuerpo del cierre es una sola expresi&amp;oacute;n. El final del cierre, despu&amp;eacute;s de las llaves, necesita un punto y coma para completar la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; . El valor devuelto de la &amp;uacute;ltima l&amp;iacute;nea en el cuerpo del cierre ( &lt;code&gt;num&lt;/code&gt; ) ser&amp;aacute; el valor devuelto por el cierre cuando se llame, porque esa l&amp;iacute;nea no termina en punto y coma; al igual que en los cuerpos funcionales.</target>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="translated">Despu&amp;eacute;s de la l&amp;iacute;nea de solicitud, las l&amp;iacute;neas restantes a partir de &lt;code&gt;Host:&lt;/code&gt; en adelante son encabezados. &lt;code&gt;GET&lt;/code&gt; solicitudes GET no tienen cuerpo.</target>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de estas dos l&amp;iacute;neas, &lt;code&gt;s&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;foobar&lt;/code&gt; . El m&amp;eacute;todo &lt;code&gt;push_str&lt;/code&gt; toma un segmento de cadena porque no necesariamente queremos tomar posesi&amp;oacute;n del par&amp;aacute;metro. Por ejemplo, el c&amp;oacute;digo del Listado 8-16 muestra que ser&amp;iacute;a lamentable que no pudi&amp;eacute;ramos usar &lt;code&gt;s2&lt;/code&gt; despu&amp;eacute;s de agregar su contenido a &lt;code&gt;s1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="translated">Una vez consumidos, se ceden el resto de elementos. En lugar de anular este m&amp;eacute;todo directamente, anule el m&amp;eacute;todo &lt;code&gt;nth&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a8c993e11b907a98ea3122f628acdebbd6b42e" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed &lt;code&gt;libc&lt;/code&gt; and &lt;code&gt;rand_core&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on those to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">Despu&amp;eacute;s de actualizar el registro, Cargo revisa la secci&amp;oacute;n &lt;code&gt;[dependencies]&lt;/code&gt; y descarga las cajas que a&amp;uacute;n no tiene. En este caso, aunque solo enumeramos &lt;code&gt;rand&lt;/code&gt; como una dependencia, Cargo tambi&amp;eacute;n tom&amp;oacute; una copia de &lt;code&gt;libc&lt;/code&gt; , porque &lt;code&gt;rand&lt;/code&gt; depende de &lt;code&gt;libc&lt;/code&gt; para funcionar. Despu&amp;eacute;s de descargar las cajas, Rust las compila y luego compila el proyecto con las dependencias disponibles.</target>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="translated">Despu&amp;eacute;s de que definamos &lt;code&gt;summarize_author&lt;/code&gt; , podemos llamar a &lt;code&gt;summarize&lt;/code&gt; en instancias de la estructura &lt;code&gt;Tweet&lt;/code&gt; , y la implementaci&amp;oacute;n predeterminada de &lt;code&gt;summarize&lt;/code&gt; llamar&amp;aacute; a la definici&amp;oacute;n de &lt;code&gt;summarize_author&lt;/code&gt; que hemos proporcionado. Debido a que hemos implementado &lt;code&gt;summarize_author&lt;/code&gt; , el rasgo de &lt;code&gt;Summary&lt;/code&gt; nos ha dado el comportamiento del m&amp;eacute;todo de &lt;code&gt;summarize&lt;/code&gt; sin requerir que escribamos m&amp;aacute;s c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="translated">Una vez que hayamos adquirido el bloqueo, podemos tratar el valor de retorno, denominado &lt;code&gt;num&lt;/code&gt; en este caso, como una referencia mutable a los datos que contiene. El sistema de tipos asegura que adquirimos un bloqueo antes de usar el valor en &lt;code&gt;m&lt;/code&gt; : &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; no es un &lt;code&gt;i32&lt;/code&gt; , por lo que &lt;em&gt;debemos&lt;/em&gt; adquirir el bloqueo para poder usar el valor de &lt;code&gt;i32&lt;/code&gt; . No podemos olvidar; el sistema de tipos no nos permitir&amp;aacute; acceder al &lt;code&gt;i32&lt;/code&gt; interno de otra manera.</target>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="translated">Una vez que hayamos creado &lt;em&gt;tests / common / mod.rs&lt;/em&gt; , podemos usarlo desde cualquiera de los archivos de prueba de integraci&amp;oacute;n como m&amp;oacute;dulo. A continuaci&amp;oacute;n, se muestra un ejemplo de &lt;code&gt;it_adds_two&lt;/code&gt; llamar a la funci&amp;oacute;n de &lt;code&gt;setup&lt;/code&gt; desde la prueba it_adds_two en &lt;em&gt;tests / integration_test.rs&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="translated">Despu&amp;eacute;s de que hemos creado las listas en &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , y &lt;code&gt;c&lt;/code&gt; , se a&amp;ntilde;ade 10 al valor en &lt;code&gt;value&lt;/code&gt; . Hacemos esto llamando al &lt;code&gt;value&lt;/code&gt; &lt;code&gt;borrow_mut&lt;/code&gt; , que usa la funci&amp;oacute;n de desreferenciaci&amp;oacute;n autom&amp;aacute;tica que discutimos en el Cap&amp;iacute;tulo 5 (ver la secci&amp;oacute;n &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;&amp;iquest;D&amp;oacute;nde est&amp;aacute; el &lt;/a&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; Operador?&amp;rdquo; ) Para desreferenciar el &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; al valor interno de &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . El m&amp;eacute;todo &lt;code&gt;borrow_mut&lt;/code&gt; devuelve un puntero inteligente &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; , y usamos el operador de desreferencia en &amp;eacute;l y cambiamos el valor interno.</target>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="translated">Despu&amp;eacute;s de escribir mucho c&amp;oacute;digo de Rust, el equipo de Rust descubri&amp;oacute; que los programadores de Rust estaban ingresando las mismas anotaciones de por vida una y otra vez en situaciones particulares. Estas situaciones eran predecibles y segu&amp;iacute;an algunos patrones deterministas. Los desarrolladores programaron estos patrones en el c&amp;oacute;digo del compilador para que el verificador de pr&amp;eacute;stamos pudiera inferir la vida &amp;uacute;til en estas situaciones y no necesitar&amp;iacute;a anotaciones expl&amp;iacute;citas.</target>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="translated">Una vez que haya instalado Rust a trav&amp;eacute;s de &lt;code&gt;rustup&lt;/code&gt; , actualizar a la &amp;uacute;ltima versi&amp;oacute;n es f&amp;aacute;cil. Desde su shell, ejecute el siguiente script de actualizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="translated">De nuevo, esta es la implementaci&amp;oacute;n m&amp;aacute;s simple del m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; : no hace nada, pero solo intentamos compilar nuestro c&amp;oacute;digo. Comprob&amp;eacute;moslo de nuevo:</target>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="translated">Nuevamente, usamos &lt;code&gt;thread::spawn&lt;/code&gt; para crear un nuevo hilo y luego usamos &lt;code&gt;move&lt;/code&gt; para mover &lt;code&gt;tx&lt;/code&gt; al cierre para que el hilo generado sea due&amp;ntilde;o de &lt;code&gt;tx&lt;/code&gt; . El hilo generado debe poseer el extremo de transmisi&amp;oacute;n del canal para poder enviar mensajes a trav&amp;eacute;s del canal.</target>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="translated">De nuevo,no es necesario especificar el tipo completo si el compilador puede inferirlo:</target>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">&amp;iexcl;Aj&amp;aacute;! El primer mensaje de error indica que el &lt;code&gt;counter&lt;/code&gt; se mueve al cierre del hilo asociado con el &lt;code&gt;handle&lt;/code&gt; . &amp;iexcl;Ese movimiento nos impide capturar el &lt;code&gt;counter&lt;/code&gt; cuando intentamos llamar al &lt;code&gt;lock&lt;/code&gt; y almacenar el resultado en &lt;code&gt;num2&lt;/code&gt; en el segundo hilo! Entonces Rust nos est&amp;aacute; diciendo que no podemos mover la propiedad del &lt;code&gt;counter&lt;/code&gt; a varios subprocesos. Esto era dif&amp;iacute;cil de ver antes porque nuestros hilos estaban en un bucle y Rust no puede apuntar a diferentes hilos en diferentes iteraciones del bucle. Arreglemos el error del compilador con un m&amp;eacute;todo de propiedad m&amp;uacute;ltiple que discutimos en el Cap&amp;iacute;tulo 15.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="translated">Alignment::borrow</target>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="translated">Alignment::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="translated">Alignment::fmt</target>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="translated">Alignment::from</target>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="translated">Alignment::into</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
