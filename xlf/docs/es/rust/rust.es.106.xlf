<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">Los vectores tambi&amp;eacute;n admiten la indexaci&amp;oacute;n (a trav&amp;eacute;s de &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt; rasgos ):</target>
        </trans-unit>
        <trans-unit id="10bd4ec04f26e95aeb5bf4a6ea31710e8b61d3aa" translate="yes" xml:space="preserve">
          <source>Vectors ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">Los vectores tienen indexaci&amp;oacute;n &lt;code&gt;O(1)&lt;/code&gt; , &lt;code&gt;O(1)&lt;/code&gt; amortizado empujar (hasta el final) y &lt;code&gt;O(1)&lt;/code&gt; pop (desde el final).</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">Los vectores,las cadenas y los mapas hash proporcionarán una gran cantidad de funcionalidad necesaria en los programas cuando se necesite almacenar,acceder y modificar datos.Aquí hay algunos ejercicios para los que debería estar equipado para resolver:</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Los prefijos UNC verbatim constan de &lt;code&gt;\?\UNC\&lt;/code&gt; seguido inmediatamente por el nombre de host del servidor y un nombre compartido.</target>
        </trans-unit>
        <trans-unit id="deeec6948b9b0c7f539defff599e2c9119f209e1" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">Prefijo de disco literal, por ejemplo, &lt;code&gt;\?\C:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9892a19a8c55087305e1dc4f1a3f3fc14b7bbe" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\\?\C:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">Los prefijos de disco textuales constan de &lt;code&gt;\?\&lt;/code&gt; Seguido inmediatamente por la letra de la unidad y &lt;code&gt;:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbcf31c83c72d79322932f64e5c3a662a2b82084" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">Verbatim prefijo de uso de Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N&lt;/strong&gt; aming &lt;strong&gt;C&lt;/strong&gt; onvenci&amp;oacute;n&lt;/em&gt; , por ejemplo, &lt;code&gt;\?\UNC\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d803e02d9c2966256665f4a37fc515a7b6b0270" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">Prefijo literal, por ejemplo, &lt;code&gt;\?\cat_pics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec64b930987590c33c18d3b5f5e6cd65655febca" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\\?\cat_pics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">Los prefijos textuales consisten en &lt;code&gt;\?\&lt;/code&gt; Seguido inmediatamente por el componente dado.</target>
        </trans-unit>
        <trans-unit id="6c060304c7d1622fca546ec1708bfccb55b07579" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">Verifique que no haya escrito mal el nombre del campo o que el campo exista.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">A trav&amp;eacute;s de referencias inmutables, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; permite compartir datos entre m&amp;uacute;ltiples partes de su programa solo para lectura. Si &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; le permit&amp;iacute;a tener m&amp;uacute;ltiples referencias mutables, podr&amp;iacute;a violar una de las reglas de pr&amp;eacute;stamo discutidas en el Cap&amp;iacute;tulo 4: m&amp;uacute;ltiples pr&amp;eacute;stamos mutables en el mismo lugar pueden causar carreras de datos e inconsistencias. &amp;iexcl;Pero poder mutar datos es muy &amp;uacute;til! En la siguiente secci&amp;oacute;n, discutiremos el patr&amp;oacute;n de mutabilidad interior y el tipo &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; que puede usar junto con un &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; para trabajar con esta restricci&amp;oacute;n de inmutabilidad.</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">Ve los datos subyacentes como una subcategoría de los datos originales.</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">La violación de estos puede causar problemas como la corrupción de las estructuras internas de datos del asignador.</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">La violaci&amp;oacute;n de estos puede causar problemas como da&amp;ntilde;ar las estructuras de datos internas del asignador. Por ejemplo, es &lt;strong&gt;no&lt;/strong&gt; seguro para construir un &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; desde un puntero a una C &lt;code&gt;char&lt;/code&gt; matriz y un &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4c0ad7ae3e37221747e827bd3d99a0ac9c1516" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array with length &lt;code&gt;size_t&lt;/code&gt;. It's also not safe to build one from a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; and its length, because the allocator cares about the alignment, and these two types have different alignments. The buffer was allocated with alignment 2 (for &lt;code&gt;u16&lt;/code&gt;), but after turning it into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; it'll be deallocated with alignment 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">Visibilidad y privacidad</target>
        </trans-unit>
        <trans-unit id="acf880408a272d86a4dffcc14370fa0e4c75f47e" translate="yes" xml:space="preserve">
          <source>Visibility is restricted to a module which isn't an ancestor of the current item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">Visita los valores que representan la diferencia, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; pero no en &lt;code&gt;other&lt;/code&gt; , en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Visita los valores que representan la diferencia, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; pero no en el &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">Visita los valores que representan la intersecci&amp;oacute;n, es decir, los valores que est&amp;aacute;n tanto en &lt;code&gt;self&lt;/code&gt; como en &lt;code&gt;other&lt;/code&gt; , en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Visita los valores que representan la intersecci&amp;oacute;n, es decir, los valores que est&amp;aacute;n tanto en &lt;code&gt;self&lt;/code&gt; como en el &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">Visita los valores que representan la diferencia sim&amp;eacute;trica, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; pero no en ambos, en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">Visita los valores que representan la diferencia sim&amp;eacute;trica, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; pero no en ambos.</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">Visita los valores que representan la uni&amp;oacute;n, es decir, todos los valores en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; , sin duplicados, en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">Visita los valores que representan la uni&amp;oacute;n, es decir, todos los valores en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; , sin duplicados.</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">Visualizaci&amp;oacute;n de cambios en &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; y &lt;code&gt;weak_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">Las operaciones volátiles están pensadas para actuar sobre la memoria de E/S,y se garantiza que no serán eludidas o reordenadas por el compilador a través de otras operaciones volátiles.</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="84367e806ed16f93cd67aba890fbaef52d16a0b0" translate="yes" xml:space="preserve">
          <source>WASI</source>
          <target state="translated">WASI</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">Esperando a que todos los subprocesos terminen usando controles de &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">Esperando la completa expiración del tiempo de espera:</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">Espera a que el hilo asociado termine.</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">Espera a que el niño salga completamente,devolviendo el estado con el que salió.Esta función seguirá teniendo el mismo valor de retorno después de haber sido llamada al menos una vez.</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">Espera en esta variable de la condición para una notificación,que se prolonga después de una duración determinada.</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">Espera en esta variable de la condición para una notificación,que se prolonga después de una duración determinada.Las estelas espurias no harán que esta función regrese.</target>
        </trans-unit>
        <trans-unit id="d6a3650e37b6043ab9616dfc37b87c0ed505a997" translate="yes" xml:space="preserve">
          <source>Wake</source>
          <target state="translated">Wake</target>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">Despierta la tarea asociada con este &lt;code&gt;Waker&lt;/code&gt; sin consumir el &lt;code&gt;Waker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">Despierta la tarea asociada con este &lt;code&gt;Waker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">Despierta todos los hilos bloqueados en este condvar.</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">Despierta un hilo bloqueado en este condvar.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">Advertencia: &lt;code&gt;hash_builder&lt;/code&gt; se genera normalmente de forma aleatoria y est&amp;aacute; dise&amp;ntilde;ado para permitir que HashMaps sea resistente a ataques que provocan muchas colisiones y un rendimiento muy deficiente. Configurarlo manualmente usando esta funci&amp;oacute;n puede exponer un vector de ataque DoS.</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">Advertencia: &lt;code&gt;hasher&lt;/code&gt; normalmente se genera aleatoriamente y est&amp;aacute; dise&amp;ntilde;ado para permitir que los &lt;code&gt;HashSet&lt;/code&gt; sean resistentes a los ataques que causan muchas colisiones y un rendimiento muy bajo. Configurarlo manualmente usando esta funci&amp;oacute;n puede exponer un vector de ataque DoS.</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">Advertencia: Es posible que las opciones de configuraci&amp;oacute;n establecidas arbitrariamente tengan el mismo valor que las opciones de configuraci&amp;oacute;n establecidas por el compilador. Por ejemplo, es posible &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; mientras se compila en un destino de Windows, y tener configuradas las opciones de configuraci&amp;oacute;n de &lt;code&gt;unix&lt;/code&gt; y &lt;code&gt;windows&lt;/code&gt; al mismo tiempo. No es prudente hacer esto.</target>
        </trans-unit>
        <trans-unit id="953fdee2421f57eef922d79cc862ee6e22ccfc48" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; can only legally hold the discrimnant values, everything else is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. Therefore, using a field-less enum in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">Advertencia: existen diferencias cruciales entre una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n en el lenguaje C y las enumeraciones tipo C de Rust con esta representaci&amp;oacute;n. Una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n en C es principalmente un &lt;code&gt;typedef&lt;/code&gt; m&amp;aacute;s algunas constantes nombradas; en otras palabras, un objeto de tipo &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n puede contener cualquier valor entero. Por ejemplo, esto se utiliza a menudo para bitflags en &lt;code&gt;C&lt;/code&gt; . Por el contrario, las enumeraciones de tipo C de Rust solo pueden contener legalmente los valores discriminantes, todo lo dem&amp;aacute;s es un comportamiento indefinido. Por lo tanto, usar una enumeraci&amp;oacute;n similar a C en FFI para modelar una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n C a menudo es incorrecto.</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">Advertencia: este libro est&amp;aacute; incompleto. Documentar todo lleva un tiempo. Consulte los &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;problemas de GitHub&lt;/a&gt; para conocer lo que no est&amp;aacute; documentado en este libro.</target>
        </trans-unit>
        <trans-unit id="f1f7ce6b6e1db1f6b36ab4dbe1ad4b6e4aa8f982" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">Advertencia:Este es un ejemplo de advertencia.</target>
        </trans-unit>
        <trans-unit id="0411a6eec332f44831efbc3f9708608318be0eda" translate="yes" xml:space="preserve">
          <source>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">Advertencia: El uso de &lt;code&gt;no_std&lt;/code&gt; no evita que se vincule la biblioteca est&amp;aacute;ndar. A&amp;uacute;n es v&amp;aacute;lido poner &lt;code&gt;extern crate std;&lt;/code&gt; en la caja y las dependencias tambi&amp;eacute;n pueden vincularlo.</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">Las advertencias que muestran un comportamiento incorrecto en el lenguaje o posibles interacciones confusas de las características del lenguaje están en un recuadro de advertencia especial.</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">¿Tuvo éxito la terminación? La terminación de la señal no se considera un éxito,y el éxito se define como un estado de salida cero.</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">Formas en que las variables y los datos interactúan:Clonar</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">Formas en que las variables y los datos interactúan:Moverse</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">&lt;code&gt;use minigrep::Config&lt;/code&gt; una l&amp;iacute;nea use minigrep :: Config para llevar el tipo de &lt;code&gt;Config&lt;/code&gt; de la caja de la biblioteca al alcance de la caja binaria, y anteponemos la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; con nuestro nombre de caja. Ahora toda la funcionalidad deber&amp;iacute;a estar conectada y deber&amp;iacute;a funcionar. Ejecute el programa con &lt;code&gt;cargo run&lt;/code&gt; y aseg&amp;uacute;rese de que todo funcione correctamente.</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">Agregamos una implementaci&amp;oacute;n predeterminada para el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; que devuelve un segmento de cadena vac&amp;iacute;o. Eso significa que no necesitamos implementar &lt;code&gt;content&lt;/code&gt; en las estructuras &lt;code&gt;Draft&lt;/code&gt; y &lt;code&gt;PendingReview&lt;/code&gt; . La estructura &lt;code&gt;Published&lt;/code&gt; anular&amp;aacute; el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; y devolver&amp;aacute; el valor en &lt;code&gt;post.content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">Agregamos el m&amp;eacute;todo de &lt;code&gt;approve&lt;/code&gt; al rasgo de &lt;code&gt;State&lt;/code&gt; y agregamos una nueva estructura que implementa el &lt;code&gt;State&lt;/code&gt; , el estado &lt;code&gt;Published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">Agregamos tipos al l&amp;iacute;mite de rasgo &lt;code&gt;Fn&lt;/code&gt; para representar los tipos de par&amp;aacute;metros y valores de retorno que los cierres deben tener para coincidir con este l&amp;iacute;mite de rasgo. En este caso, nuestro cierre tiene un par&amp;aacute;metro de tipo &lt;code&gt;u32&lt;/code&gt; y devuelve &lt;code&gt;u32&lt;/code&gt; , por lo que el l&amp;iacute;mite de rasgo que especificamos es &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">Tambi&amp;eacute;n necesitamos una forma de almacenar las l&amp;iacute;neas que contienen nuestra cadena de consulta. Para eso, podemos hacer un vector mutable antes del ciclo &lt;code&gt;for&lt;/code&gt; y llamar al m&amp;eacute;todo &lt;code&gt;push&lt;/code&gt; para almacenar una &lt;code&gt;line&lt;/code&gt; en el vector. Despu&amp;eacute;s del ciclo &lt;code&gt;for&lt;/code&gt; , devolvemos el vector, como se muestra en el Listado 12-19.</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">No podemos ejecutar esta prueba y verla fallar porque la prueba ni siquiera se compila: &amp;iexcl;la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; a&amp;uacute;n no existe! As&amp;iacute; que ahora agregaremos el c&amp;oacute;digo suficiente para que la prueba se compile y se ejecute agregando una definici&amp;oacute;n de la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; que siempre devuelve un vector vac&amp;iacute;o, como se muestra en el Listado 12-16. Luego, la prueba deber&amp;iacute;a compilarse y fallar porque un vector vac&amp;iacute;o no coincide con un vector que contiene la l&amp;iacute;nea &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">No podemos usar las variables &lt;code&gt;field_name&lt;/code&gt; y &lt;code&gt;field_value&lt;/code&gt; despu&amp;eacute;s de que se hayan movido al mapa hash con la llamada a &lt;code&gt;insert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">No podemos usar &lt;code&gt;v1_iter&lt;/code&gt; despu&amp;eacute;s de la llamada a &lt;code&gt;sum&lt;/code&gt; porque &lt;code&gt;sum&lt;/code&gt; toma posesi&amp;oacute;n del iterador al que lo llamamos.</target>
        </trans-unit>
        <trans-unit id="03b218b584e4a8c7465d02aa1590edcd7370cd71" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">Adjuntamos los datos a cada variante del enum directamente,así que no hay necesidad de una estructura extra.</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">Nos unen &lt;code&gt;guess&lt;/code&gt; que la expresi&amp;oacute;n &lt;code&gt;guess.trim().parse()&lt;/code&gt; . La &lt;code&gt;guess&lt;/code&gt; en la expresi&amp;oacute;n se refiere a la &lt;code&gt;guess&lt;/code&gt; original que era una &lt;code&gt;String&lt;/code&gt; con la entrada en ella. El m&amp;eacute;todo de &lt;code&gt;trim&lt;/code&gt; en una instancia de &lt;code&gt;String&lt;/code&gt; eliminar&amp;aacute; cualquier espacio en blanco al principio y al final. Aunque &lt;code&gt;u32&lt;/code&gt; solo puede contener caracteres num&amp;eacute;ricos, el usuario debe presionar enter para satisfacer &lt;code&gt;read_line&lt;/code&gt; . Cuando el usuario presiona enter, se agrega un car&amp;aacute;cter de nueva l&amp;iacute;nea a la cadena. Por ejemplo, si el usuario escribe 5 y presiona Intro, &lt;code&gt;guess&lt;/code&gt; ver&amp;aacute; as&amp;iacute;: &lt;code&gt;5\n&lt;/code&gt; . El &lt;code&gt;\n&lt;/code&gt; representa &quot;nueva l&amp;iacute;nea&quot;, el resultado de presionar enter. El m&amp;eacute;todo de &lt;code&gt;trim&lt;/code&gt; elimina &lt;code&gt;\n&lt;/code&gt; , lo que da como resultado solo &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">Traemos &lt;code&gt;std::io::prelude&lt;/code&gt; al alcance para obtener acceso a ciertos rasgos que nos permiten leer y escribir en el flujo. En el bucle &lt;code&gt;for&lt;/code&gt; de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; , en lugar de imprimir un mensaje que dice que hicimos una conexi&amp;oacute;n, ahora llamamos a la nueva funci&amp;oacute;n &lt;code&gt;handle_connection&lt;/code&gt; y le pasamos el &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">Llamamos a tener referencias como &lt;em&gt;pr&amp;eacute;stamo de&lt;/em&gt; par&amp;aacute;metros de funci&amp;oacute;n . Como en la vida real, si una persona posee algo, se lo puede pedir prestado. Cuando termines, tienes que devolverlo.</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">Llamamos al m&amp;eacute;todo &lt;code&gt;as_ref&lt;/code&gt; en la &lt;code&gt;Option&lt;/code&gt; porque queremos una referencia al valor dentro de la &lt;code&gt;Option&lt;/code&gt; lugar de la propiedad del valor. Como el &lt;code&gt;state&lt;/code&gt; es una &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; , cuando llamamos a &lt;code&gt;as_ref&lt;/code&gt; , se devuelve una &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; . Si no llamamos a &lt;code&gt;as_ref&lt;/code&gt; , obtendr&amp;iacute;amos un error porque no podemos mover el &lt;code&gt;state&lt;/code&gt; del &lt;code&gt;&amp;amp;self&lt;/code&gt; prestado del par&amp;aacute;metro de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">Tambi&amp;eacute;n podemos implementar condicionalmente un rasgo para cualquier tipo que implemente otro rasgo. Las implementaciones de un rasgo en cualquier tipo que satisfaga los l&amp;iacute;mites del rasgo se denominan &lt;em&gt;implementaciones generales&lt;/em&gt; y se utilizan ampliamente en la biblioteca est&amp;aacute;ndar de Rust. Por ejemplo, la biblioteca est&amp;aacute;ndar implementa el rasgo &lt;code&gt;ToString&lt;/code&gt; en cualquier tipo que implemente el rasgo &lt;code&gt;Display&lt;/code&gt; . El bloque &lt;code&gt;impl&lt;/code&gt; en la biblioteca est&amp;aacute;ndar es similar a este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">Tambi&amp;eacute;n podemos construir rutas relativas que comienzan en el m&amp;oacute;dulo padre usando &lt;code&gt;super&lt;/code&gt; al comienzo de la ruta. Esto es como empezar un camino sistema de archivos con el &lt;code&gt;..&lt;/code&gt; sintaxis. &amp;iquest;Por qu&amp;eacute; querr&amp;iacute;amos hacer esto?</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">Tambi&amp;eacute;n podemos definir estructuras para usar un par&amp;aacute;metro de tipo gen&amp;eacute;rico en uno o m&amp;aacute;s campos usando la sintaxis &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Listado 10-6 muestra c&amp;oacute;mo definir un &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; estructura para sostener &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; valores de coordenadas de cualquier tipo.</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">También podemos desestructurar con valores literales como parte del patrón de estructura en lugar de crear variables para todos los campos.Hacerlo nos permite probar algunos de los campos para valores particulares mientras creamos variables para desestructurar los otros campos.</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">Tambi&amp;eacute;n podemos iterar sobre referencias mutables a cada elemento en un vector mutable para realizar cambios en todos los elementos. El ciclo &lt;code&gt;for&lt;/code&gt; del Listado 8-9 agregar&amp;aacute; &lt;code&gt;50&lt;/code&gt; a cada elemento.</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">Tambi&amp;eacute;n podemos ejecutar pruebas para una caja en particular en un espacio de trabajo desde el directorio de nivel superior usando la &lt;code&gt;-p&lt;/code&gt; y especificando el nombre de la caja que queremos probar:</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">Tambi&amp;eacute;n podemos especificar m&amp;aacute;s de un l&amp;iacute;mite de rasgo. Supongamos que queremos &lt;code&gt;notify&lt;/code&gt; para usar el formato de visualizaci&amp;oacute;n en el &lt;code&gt;item&lt;/code&gt; , as&amp;iacute; como el m&amp;eacute;todo de &lt;code&gt;summarize&lt;/code&gt; : especificamos en la definici&amp;oacute;n de &lt;code&gt;notify&lt;/code&gt; que el &lt;code&gt;item&lt;/code&gt; debe implementar tanto la &lt;code&gt;Display&lt;/code&gt; como el &lt;code&gt;Summary&lt;/code&gt; . Podemos hacerlo usando la sintaxis &lt;code&gt;+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">Tambi&amp;eacute;n podemos aprovechar los iteradores en la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; en nuestro proyecto de E / S, que se reproduce aqu&amp;iacute; en el Listado 13-28 como estaba en el Listado 12-19:</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar &lt;code&gt;_&lt;/code&gt; dentro de otro patr&amp;oacute;n para ignorar solo una parte de un valor, por ejemplo, cuando queremos probar solo una parte de un valor pero no tenemos uso para las otras partes en el c&amp;oacute;digo correspondiente que queremos ejecutar. El listado 18-18 muestra el c&amp;oacute;digo responsable de administrar el valor de una configuraci&amp;oacute;n. Los requisitos comerciales son que el usuario no debe poder sobrescribir una personalizaci&amp;oacute;n existente de una configuraci&amp;oacute;n, pero puede desarmar la configuraci&amp;oacute;n y darle un valor si no est&amp;aacute; configurada actualmente.</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar &lt;code&gt;extern&lt;/code&gt; para crear una interfaz que permita a otros lenguajes llamar a funciones de Rust. En lugar de un bloque &lt;code&gt;extern&lt;/code&gt; , agregamos la palabra clave &lt;code&gt;extern&lt;/code&gt; y especificamos el ABI a usar justo antes de la palabra clave &lt;code&gt;fn&lt;/code&gt; . Tambi&amp;eacute;n necesitamos agregar una anotaci&amp;oacute;n &lt;code&gt;#[no_mangle]&lt;/code&gt; para decirle al compilador de Rust que no altere el nombre de esta funci&amp;oacute;n. &lt;em&gt;Destrozar&lt;/em&gt;es cuando un compilador cambia el nombre que le hemos dado a una funci&amp;oacute;n por un nombre diferente que contiene m&amp;aacute;s informaci&amp;oacute;n para que otras partes del proceso de compilaci&amp;oacute;n la consuman, pero es menos legible por humanos. Cada compilador de lenguaje de programaci&amp;oacute;n modifica los nombres de manera ligeramente diferente, por lo que para que una funci&amp;oacute;n de Rust pueda ser nombrada por otros lenguajes, debemos deshabilitar la manipulaci&amp;oacute;n de nombres del compilador de Rust.</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar &lt;code&gt;pub&lt;/code&gt; para designar estructuras y enumeraciones como p&amp;uacute;blicas, pero hay algunos detalles adicionales. Si usamos &lt;code&gt;pub&lt;/code&gt; antes de una definici&amp;oacute;n de estructura, la hacemos p&amp;uacute;blica, pero los campos de la estructura seguir&amp;aacute;n siendo privados. Podemos hacer que cada campo sea p&amp;uacute;blico o no, caso por caso. En el Listado 7-9, hemos definido una &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; p&amp;uacute;blica back_of_house :: Breakfast con un campo de &lt;code&gt;toast&lt;/code&gt; p&amp;uacute;blico pero una &lt;code&gt;seasonal_fruit&lt;/code&gt; privada.campo. Esto modela el caso en un restaurante donde el cliente puede elegir el tipo de pan que viene con una comida, pero el chef decide qu&amp;eacute; fruta acompa&amp;ntilde;a la comida en funci&amp;oacute;n de la temporada y el stock. La fruta disponible cambia r&amp;aacute;pidamente, por lo que los clientes no pueden elegir la fruta o incluso ver qu&amp;eacute; fruta obtendr&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">También podemos utilizar patrones en las listas de parámetros de cierre de la misma manera que en las listas de parámetros de funciones,porque los cierres son similares a las funciones,como se discute en el capítulo 13.</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar patrones para desestructurar estructuras, enumeraciones, tuplas y referencias para usar diferentes partes de estos valores. Repasemos cada valor.</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar la sintaxis &lt;code&gt;impl Trait&lt;/code&gt; en la posici&amp;oacute;n de retorno para devolver un valor de alg&amp;uacute;n tipo que implemente un rasgo, como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar la funci&amp;oacute;n &lt;code&gt;String::from&lt;/code&gt; para crear un &lt;code&gt;String&lt;/code&gt; a partir de un string literal. El c&amp;oacute;digo del Listado 8-13 es equivalente al c&amp;oacute;digo del Listado 8-12 que usa &lt;code&gt;to_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">También podemos usar subrayados en múltiples lugares dentro de un patrón para ignorar valores particulares.La lista 18-19 muestra un ejemplo de ignorar el segundo y el cuarto valor en una tupla de cinco elementos.</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">Podemos construir un proyecto usando &lt;code&gt;cargo build&lt;/code&gt; &lt;code&gt;cargo check&lt;/code&gt; o verificaci&amp;oacute;n de carga .</target>
        </trans-unit>
        <trans-unit id="838e973f1067e2cb1c1db7ba741330fcbc0ac60a" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce64501de0b20285b589ca7f67901cf5515ef19d" translate="yes" xml:space="preserve">
          <source>We can build a project without producing a binary to check for errors using &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">Podemos construir y ejecutar un proyecto en un solo paso usando &lt;code&gt;cargo run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">Podemos llamar a cualquier funci&amp;oacute;n que hayamos definido ingresando su nombre seguido de un par de par&amp;eacute;ntesis. Debido a que &lt;code&gt;another_function&lt;/code&gt; est&amp;aacute; definida en el programa, se puede llamar desde dentro de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; . Tenga en cuenta que definimos otra &lt;code&gt;another_function&lt;/code&gt; &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; en el c&amp;oacute;digo fuente; tambi&amp;eacute;n podr&amp;iacute;amos haberlo definido antes. A Rust no le importa d&amp;oacute;nde defina sus funciones, solo que est&amp;eacute;n definidas en alg&amp;uacute;n lugar.</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">Podemos llamar a la funci&amp;oacute;n &lt;code&gt;hello&lt;/code&gt; con un segmento de cadena como argumento, como &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; por ejemplo. Deref coercion hace posible llamar &lt;code&gt;hello&lt;/code&gt; con una referencia a un valor de tipo &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; , como se muestra en el Listado 15-12:</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">Podemos llamar &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo siguiente en iteradores directamente; El Listado 13-15 demuestra qu&amp;eacute; valores se devuelven de llamadas repetidas a &lt;code&gt;next&lt;/code&gt; en el iterador creado a partir del vector.</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">Podemos cambiar la definici&amp;oacute;n de la enumeraci&amp;oacute;n &lt;code&gt;List&lt;/code&gt; en el Listado 15-2 y el uso de la &lt;code&gt;List&lt;/code&gt; a en el Listado 15-3 al c&amp;oacute;digo en el Listado 15-5, que compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">Podemos combinar &lt;code&gt;str&lt;/code&gt; con todo tipo de punteros: por ejemplo, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; o &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; . De hecho, has visto esto antes, pero con un tipo de tama&amp;ntilde;o din&amp;aacute;mico diferente: rasgos. Cada rasgo es un tipo de tama&amp;ntilde;o din&amp;aacute;mico al que podemos referirnos usando el nombre del rasgo. En el Cap&amp;iacute;tulo 17 en la secci&amp;oacute;n &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&quot;Uso de objetos de rasgo que permiten valores de diferentes tipos&quot;&lt;/a&gt; , mencionamos que para usar rasgos como objetos de rasgo, debemos ponerlos detr&amp;aacute;s de un puntero, como &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; o &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; ( &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; tambi&amp;eacute;n funcionar&amp;iacute;a).</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">Podemos crear instancias de cada una de las dos variantes de &lt;code&gt;IpAddrKind&lt;/code&gt; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="6778f0bff382e98f9e7494c1dbfeeb8d0d54aa88" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte (counting from 1) of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">Podemos crear rebanadas utilizando un rango entre corchetes especificando &lt;code&gt;[starting_index..ending_index]&lt;/code&gt; , donde &lt;code&gt;starting_index&lt;/code&gt; es la primera posici&amp;oacute;n en la rebanada y &lt;code&gt;ending_index&lt;/code&gt; es uno m&amp;aacute;s que la &amp;uacute;ltima posici&amp;oacute;n en la rebanada. Internamente, la estructura de datos rebanada almacena la posici&amp;oacute;n de partida y la longitud de la rebanada, que corresponde a &lt;code&gt;ending_index&lt;/code&gt; menos &lt;code&gt;starting_index&lt;/code&gt; . Entonces, en el caso de &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; , &lt;code&gt;world&lt;/code&gt; ser&amp;iacute;a un segmento que contiene un puntero al s&amp;eacute;ptimo byte de &lt;code&gt;s&lt;/code&gt; con un valor de longitud de 5.</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">Podemos expresar este concepto en c&amp;oacute;digo definiendo una enumeraci&amp;oacute;n &lt;code&gt;IpAddrKind&lt;/code&gt; y enumerando los posibles tipos que puede ser una direcci&amp;oacute;n IP, &lt;code&gt;V4&lt;/code&gt; y &lt;code&gt;V6&lt;/code&gt; . Estos se conocen como las &lt;em&gt;variantes&lt;/em&gt; de la enumeraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="76dc799b358f8c432443282c326218cb637140a7" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are the variants of the enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">Podemos arreglar el error en el código de la Lista 4-6 con sólo un pequeño ajuste:</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">Podemos solucionar el problema de que el hilo generado no se ejecute, o no se ejecute completamente, guardando el valor de retorno de &lt;code&gt;thread::spawn&lt;/code&gt; en una variable. El tipo de retorno de &lt;code&gt;thread::spawn&lt;/code&gt; es &lt;code&gt;JoinHandle&lt;/code&gt; . Un &lt;code&gt;JoinHandle&lt;/code&gt; es un valor de propiedad que, cuando llamamos al m&amp;eacute;todo de &lt;code&gt;join&lt;/code&gt; , esperar&amp;aacute; a que termine su hilo. El Listado 16-2 muestra c&amp;oacute;mo usar &lt;code&gt;JoinHandle&lt;/code&gt; del hilo que creamos en el Listado 16-1 y llamar a &lt;code&gt;join&lt;/code&gt; para asegurarse de que el hilo generado termina antes de las salidas &lt;code&gt;main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">Podemos obtener un valor del mapa hash proporcionando su clave para el m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; , como se muestra en el Listado 8-23.</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">Podemos hacer crecer una &lt;code&gt;String&lt;/code&gt; usando el m&amp;eacute;todo &lt;code&gt;push_str&lt;/code&gt; para agregar un segmento de cadena, como se muestra en el Listado 8-15.</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">Podemos implementar m&amp;eacute;todos en estructuras y enumeraciones (como hicimos en el Cap&amp;iacute;tulo 5) y tambi&amp;eacute;n usar tipos gen&amp;eacute;ricos en sus definiciones. El Listado 10-9 muestra la estructura &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; que definimos en el Listado 10-6 con un m&amp;eacute;todo llamado &lt;code&gt;x&lt;/code&gt; implementado en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">Podemos incluir un &lt;code&gt;else&lt;/code&gt; con un &lt;code&gt;if let&lt;/code&gt; . El bloque de c&amp;oacute;digo que va con &lt;code&gt;else&lt;/code&gt; es el mismo que el bloque de c&amp;oacute;digo que ir&amp;iacute;a con el caso &lt;code&gt;_&lt;/code&gt; en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; que es equivalente a &lt;code&gt;if let&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; . Recuerde la definici&amp;oacute;n de enumeraci&amp;oacute;n de &lt;code&gt;Coin&lt;/code&gt; en el Listado 6-4, donde la variante &lt;code&gt;Quarter&lt;/code&gt; tambi&amp;eacute;n ten&amp;iacute;a un valor &lt;code&gt;UsState&lt;/code&gt; . Si quisi&amp;eacute;ramos contar todas las monedas que no son de un cuarto que vemos al mismo tiempo que anunciamos el estado de los cuartos, podr&amp;iacute;amos hacerlo con una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; como esta:</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">En su lugar, podemos devolver un valor de &lt;code&gt;Result&lt;/code&gt; que contendr&amp;aacute; una instancia de &lt;code&gt;Config&lt;/code&gt; en el caso exitoso y describir&amp;aacute; el problema en el caso de error. Cuando &lt;code&gt;Config::new&lt;/code&gt; est&amp;aacute; comunicando con &lt;code&gt;main&lt;/code&gt; , podemos usar el tipo &lt;code&gt;Result&lt;/code&gt; para se&amp;ntilde;alar que hubo un problema. Entonces podemos cambiar &lt;code&gt;main&lt;/code&gt; para convertir una variante &lt;code&gt;Err&lt;/code&gt; en un error m&amp;aacute;s pr&amp;aacute;ctico para nuestros usuarios sin el texto circundante sobre el &lt;code&gt;thread 'main'&lt;/code&gt; y &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; que una llamada al &lt;code&gt;panic!&lt;/code&gt; causas.</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Podemos iterar sobre cada par clave / valor en un mapa hash de manera similar a como lo hacemos con los vectores, usando un bucle &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">Podemos mezclar,combinar y anidar patrones de desestructuración de maneras aún más complejas.El siguiente ejemplo muestra una desestructuración complicada en la que anidamos estructuras y tuplas dentro de una tupla y desestructuramos todos los valores primitivos hacia fuera:</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">Ahora podemos agregar &lt;code&gt;use rand;&lt;/code&gt; al archivo &lt;em&gt;add-one / src / lib.rs&lt;/em&gt; , y construir todo el espacio de trabajo ejecutando &lt;code&gt;cargo build&lt;/code&gt; en el directorio &lt;em&gt;add&lt;/em&gt; traer&amp;aacute; y compilar&amp;aacute; la caja &lt;code&gt;rand&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">Podemos pasar el nombre de cualquier funci&amp;oacute;n de &lt;code&gt;cargo test&lt;/code&gt; a la prueba de carga para ejecutar solo esa prueba:</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">Probablemente podemos adivinar lo que esto est&amp;aacute; haciendo: &amp;ldquo;atar el valor &lt;code&gt;5&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; ; luego haz una copia del valor en &lt;code&gt;x&lt;/code&gt; y &amp;uacute;nelo a &lt;code&gt;y&lt;/code&gt; &quot;. Ahora tenemos dos variables, &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , y ambos iguales &lt;code&gt;5&lt;/code&gt; . De hecho, esto es lo que est&amp;aacute; sucediendo, porque los n&amp;uacute;meros enteros son valores simples con un tama&amp;ntilde;o fijo conocido, y estos dos &lt;code&gt;5&lt;/code&gt; valores se insertan en la pila.</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">Podemos representar el mismo concepto de una manera m&amp;aacute;s concisa usando solo una enumeraci&amp;oacute;n, en lugar de una enumeraci&amp;oacute;n dentro de una estructura, colocando datos directamente en cada variante de enumeraci&amp;oacute;n. Esta nueva definici&amp;oacute;n de la enumeraci&amp;oacute;n &lt;code&gt;IpAddr&lt;/code&gt; dice que las variantes &lt;code&gt;V4&lt;/code&gt; y &lt;code&gt;V6&lt;/code&gt; tendr&amp;aacute;n valores de &lt;code&gt;String&lt;/code&gt; asociados :</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">Podemos reescribir el c&amp;oacute;digo en el Listado 15-6 para usar &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; lugar de una referencia; el operador de desreferencia funcionar&amp;aacute; como se muestra en el Listado 15-7:</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">Podemos ver que &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; tiene un recuento de referencia inicial de 1; luego, cada vez que llamamos a &lt;code&gt;clone&lt;/code&gt; , el recuento aumenta en 1. Cuando &lt;code&gt;c&lt;/code&gt; sale del alcance, el recuento disminuye en 1. No tenemos que llamar a una funci&amp;oacute;n para disminuir el recuento de referencias como tenemos que llamar a &lt;code&gt;Rc::clone&lt;/code&gt; para aumentar el recuento de referencias: la implementaci&amp;oacute;n del rasgo &lt;code&gt;Drop&lt;/code&gt; reduce el recuento de referencias autom&amp;aacute;ticamente cuando un valor &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; sale del alcance.</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">Podemos ver el valor que obtuvimos en la salida de la prueba,lo que nos ayudaría a depurar lo que sucedió en lugar de lo que esperábamos que sucediera.</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">Podemos especificar parte del nombre de una prueba y se ejecutar&amp;aacute; cualquier prueba cuyo nombre coincida con ese valor. Por ejemplo, debido a que dos de los nombres de nuestras pruebas contienen &lt;code&gt;add&lt;/code&gt; , podemos ejecutar esos dos ejecutando &lt;code&gt;cargo test add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">&amp;iexcl;A&amp;uacute;n podemos hacerlo mejor que esto! Dado que todas estas son cadenas, podemos usar &lt;code&gt;From::from&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">Todav&amp;iacute;a podemos ejecutar una funci&amp;oacute;n de prueba de integraci&amp;oacute;n particular especificando el nombre de la funci&amp;oacute;n de prueba como argumento para &lt;code&gt;cargo test&lt;/code&gt; . Para ejecutar todas las pruebas en un archivo de prueba de integraci&amp;oacute;n en particular, use el argumento &lt;code&gt;--test&lt;/code&gt; de &lt;code&gt;cargo test&lt;/code&gt; de carga seguido del nombre del archivo:</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">Podemos dar otro peque&amp;ntilde;o paso para mejorar &lt;code&gt;parse_config&lt;/code&gt; m&amp;aacute;s la funci&amp;oacute;n parse_config . Por el momento, estamos devolviendo una tupla, pero luego inmediatamente dividimos esa tupla en partes individuales nuevamente. Esta es una se&amp;ntilde;al de que quiz&amp;aacute;s a&amp;uacute;n no tengamos la abstracci&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">Podemos usar &lt;code&gt;LineWriter&lt;/code&gt; para escribir una l&amp;iacute;nea a la vez, reduciendo significativamente el n&amp;uacute;mero de escrituras reales en el archivo.</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">Podemos usar una ruta anidada en cualquier nivel de una ruta, lo cual es &amp;uacute;til cuando se combinan dos instrucciones de &lt;code&gt;use&lt;/code&gt; que comparten una subruta. Por ejemplo, el Listado 7-19 muestra dos declaraciones de &lt;code&gt;use&lt;/code&gt; : una que trae &lt;code&gt;std::io&lt;/code&gt; al alcance y otra que trae &lt;code&gt;std::io::Write&lt;/code&gt; al alcance.</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">Podemos usar gen&amp;eacute;ricos para crear definiciones para elementos como firmas de funciones o estructuras, que luego podemos usar con muchos tipos de datos concretos diferentes. Primero veamos c&amp;oacute;mo definir funciones, estructuras, enumeraciones y m&amp;eacute;todos usando gen&amp;eacute;ricos. Luego discutiremos c&amp;oacute;mo los gen&amp;eacute;ricos afectan el rendimiento del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">Podemos escribir pruebas que afirmen, por ejemplo, que cuando pasamos &lt;code&gt;3&lt;/code&gt; a la funci&amp;oacute;n &lt;code&gt;add_two&lt;/code&gt; , el valor devuelto es &lt;code&gt;5&lt;/code&gt; . Podemos ejecutar estas pruebas siempre que hagamos cambios en nuestro c&amp;oacute;digo para asegurarnos de que no haya cambiado ning&amp;uacute;n comportamiento correcto existente.</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">Podemos escribir este c&amp;oacute;digo de una manera m&amp;aacute;s concisa usando m&amp;eacute;todos de adaptador de iterador. Hacerlo tambi&amp;eacute;n nos permite evitar tener un vector de &lt;code&gt;results&lt;/code&gt; intermedios mutable . El estilo de programaci&amp;oacute;n funcional prefiere minimizar la cantidad de estado mutable para hacer el c&amp;oacute;digo m&amp;aacute;s claro. La eliminaci&amp;oacute;n del estado mutable podr&amp;iacute;a permitir una mejora futura para que la b&amp;uacute;squeda se realice en paralelo, porque no tendr&amp;iacute;amos que administrar el acceso simult&amp;aacute;neo al vector de &lt;code&gt;results&lt;/code&gt; . El Listado 13-29 muestra este cambio:</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">No podemos deshabilitar la inserci&amp;oacute;n autom&amp;aacute;tica de &lt;code&gt;drop&lt;/code&gt; cuando un valor sale del alcance, y no podemos llamar al m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; expl&amp;iacute;citamente. Entonces, si necesitamos forzar la limpieza de un valor temprano, podemos usar la funci&amp;oacute;n &lt;code&gt;std::mem::drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">No podemos hacer lo mismo con las funciones; si intentamos con el siguiente ejemplo, nuestro c&amp;oacute;digo no se compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">No podemos implementar esta funci&amp;oacute;n usando solo Rust seguro. Un intento podr&amp;iacute;a parecerse al Listado 19-5, que no se compilar&amp;aacute;. Para simplificar, implementaremos &lt;code&gt;split_at_mut&lt;/code&gt; como una funci&amp;oacute;n en lugar de un m&amp;eacute;todo y solo para segmentos de valores &lt;code&gt;i32&lt;/code&gt; en lugar de un tipo &lt;code&gt;T&lt;/code&gt; gen&amp;eacute;rico .</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">No podemos modificar &lt;code&gt;MockMessenger&lt;/code&gt; para realizar un seguimiento de los mensajes, porque el m&amp;eacute;todo de &lt;code&gt;send&lt;/code&gt; toma una referencia inmutable a &lt;code&gt;self&lt;/code&gt; . Tampoco podemos aceptar la sugerencia del texto de error para usar &lt;code&gt;&amp;amp;mut self&lt;/code&gt; en su lugar, porque entonces la firma del &lt;code&gt;send&lt;/code&gt; no coincidir&amp;iacute;a con la firma en la definici&amp;oacute;n del rasgo de &lt;code&gt;Messenger&lt;/code&gt; (si&amp;eacute;ntase libre de probar y ver qu&amp;eacute; mensaje de error obtiene).</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">No podemos especificar los nombres de m&amp;uacute;ltiples pruebas de esta manera; s&amp;oacute;lo se utilizar&amp;aacute; el primer valor dado a &lt;code&gt;cargo test&lt;/code&gt; . Pero hay una forma de ejecutar varias pruebas.</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">No podemos crear un objeto de tipo &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;amp;Foo&lt;/code&gt; ya que en este caso &lt;code&gt;Self&lt;/code&gt; no tendr&amp;iacute;a &lt;code&gt;Sized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">Elegimos &lt;code&gt;usize&lt;/code&gt; como el tipo de par&amp;aacute;metro de &lt;code&gt;size&lt;/code&gt; , porque sabemos que un n&amp;uacute;mero negativo de hilos no tiene ning&amp;uacute;n sentido. Tambi&amp;eacute;n sabemos que usaremos este 4 como el n&amp;uacute;mero de elementos en una colecci&amp;oacute;n de subprocesos, que es para lo que es el tipo &lt;code&gt;usize&lt;/code&gt; , como se discuti&amp;oacute; en la secci&amp;oacute;n &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Tipos de enteros&amp;rdquo;&lt;/a&gt; del Cap&amp;iacute;tulo 3.</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">Clonamos el &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; en &lt;code&gt;leaf&lt;/code&gt; y lo almacenamos en &lt;code&gt;branch&lt;/code&gt; , lo que significa que el &lt;code&gt;Node&lt;/code&gt; en &lt;code&gt;leaf&lt;/code&gt; ahora tiene dos propietarios: &lt;code&gt;leaf&lt;/code&gt; y &lt;code&gt;branch&lt;/code&gt; . Podemos ir de &lt;code&gt;branch&lt;/code&gt; en &lt;code&gt;leaf&lt;/code&gt; trav&amp;eacute;s de &lt;code&gt;branch.children&lt;/code&gt; , pero no hay forma de ir de &lt;code&gt;leaf&lt;/code&gt; en &lt;code&gt;branch&lt;/code&gt; . La raz&amp;oacute;n es que la &lt;code&gt;leaf&lt;/code&gt; no tiene ninguna referencia a la &lt;code&gt;branch&lt;/code&gt; y no sabe que est&amp;aacute;n relacionados. Queremos que la &lt;code&gt;leaf&lt;/code&gt; sepa que la &lt;code&gt;branch&lt;/code&gt; es su padre. Haremos eso a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">&amp;iexcl;Tambi&amp;eacute;n podr&amp;iacute;amos usar el &lt;code&gt;vec!&lt;/code&gt; macro para hacer un vector de dos enteros o un vector de cinco cortes de cadena. No podr&amp;iacute;amos usar una funci&amp;oacute;n para hacer lo mismo porque no sabr&amp;iacute;amos el n&amp;uacute;mero o tipo de valores por adelantado.</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">Podr&amp;iacute;amos cambiar la definici&amp;oacute;n de &lt;code&gt;Cons&lt;/code&gt; para contener referencias en su lugar, pero luego tendr&amp;iacute;amos que especificar par&amp;aacute;metros de duraci&amp;oacute;n. Al especificar los par&amp;aacute;metros de duraci&amp;oacute;n, estar&amp;iacute;amos especificando que cada elemento de la lista vivir&amp;aacute; al menos tanto como la lista completa. El comprobador de pr&amp;eacute;stamos no nos dejar&amp;iacute;a compilar &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; por ejemplo, porque el valor &lt;code&gt;Nil&lt;/code&gt; temporal se eliminar&amp;iacute;a antes de que &lt;code&gt;a&lt;/code&gt; pudiera hacer referencia a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">¡Podríamos hacer más aquí! Si quieres seguir mejorando este proyecto,aquí tienes algunas ideas:</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">Podr&amp;iacute;amos haber llamado &lt;code&gt;a.clone()&lt;/code&gt; lugar de &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; , pero la convenci&amp;oacute;n de Rust es usar &lt;code&gt;Rc::clone&lt;/code&gt; en este caso. La implementaci&amp;oacute;n de &lt;code&gt;Rc::clone&lt;/code&gt; no hace una copia profunda de todos los datos como hacen las implementaciones de &lt;code&gt;clone&lt;/code&gt; de la mayor&amp;iacute;a de los tipos . La llamada a &lt;code&gt;Rc::clone&lt;/code&gt; solo incrementa el recuento de referencias, lo que no lleva mucho tiempo. Las copias profundas de datos pueden llevar mucho tiempo. Al usar &lt;code&gt;Rc::clone&lt;/code&gt; para el recuento de referencias, podemos distinguir visualmente entre los tipos de clones de copia profunda y los tipos de clones que aumentan el recuento de referencias. Al buscar problemas de rendimiento en el c&amp;oacute;digo, solo debemos considerar los clones de copia profunda y podemos ignorar las llamadas a &lt;code&gt;Rc::clone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">Podr&amp;iacute;amos administrar los datos de &lt;code&gt;String&lt;/code&gt; de varias maneras diferentes, pero la ruta m&amp;aacute;s f&amp;aacute;cil, aunque algo ineficiente, es llamar al m&amp;eacute;todo de &lt;code&gt;clone&lt;/code&gt; en los valores. Esto har&amp;aacute; una copia completa de los datos para que los posea la instancia de &lt;code&gt;Config&lt;/code&gt; , lo que requiere m&amp;aacute;s tiempo y memoria que almacenar una referencia a los datos de la cadena. Sin embargo, clonar los datos tambi&amp;eacute;n hace que nuestro c&amp;oacute;digo sea muy sencillo porque no tenemos que administrar la vida &amp;uacute;til de las referencias; en esta circunstancia, renunciar a un poco de rendimiento para ganar simplicidad es una compensaci&amp;oacute;n que vale la pena.</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">Podr&amp;iacute;amos reestructurar el programa de ejercicios de muchas formas. Primero, intentaremos extraer la llamada duplicada a la funci&amp;oacute;n &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; en una variable, como se muestra en el Listado 13-4.</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">Podr&amp;iacute;amos, por ejemplo, implementar m&amp;eacute;todos solo en instancias de &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; lugar de en instancias de &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; con cualquier tipo gen&amp;eacute;rico. En el Listado 10-10 usamos el tipo concreto &lt;code&gt;f32&lt;/code&gt; , lo que significa que no declaramos ning&amp;uacute;n tipo despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">&amp;iexcl;Cubrimos mucho en este cap&amp;iacute;tulo! Ahora que conoce los par&amp;aacute;metros de tipo gen&amp;eacute;rico, las caracter&amp;iacute;sticas y los l&amp;iacute;mites de las caracter&amp;iacute;sticas, y los par&amp;aacute;metros de vida &amp;uacute;til gen&amp;eacute;ricos, est&amp;aacute; listo para escribir c&amp;oacute;digo sin repetici&amp;oacute;n que funcione en muchas situaciones diferentes. Los par&amp;aacute;metros de tipo gen&amp;eacute;rico le permiten aplicar el c&amp;oacute;digo a diferentes tipos. Los rasgos y los l&amp;iacute;mites de los rasgos garantizan que, aunque los tipos sean gen&amp;eacute;ricos, tendr&amp;aacute;n el comportamiento que necesita el c&amp;oacute;digo. Aprendi&amp;oacute; a usar anotaciones de por vida para asegurarse de que este c&amp;oacute;digo flexible no tenga referencias colgantes. Y todo este an&amp;aacute;lisis ocurre en tiempo de compilaci&amp;oacute;n, lo que no afecta el rendimiento del tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">Creamos una variable de &lt;code&gt;counter&lt;/code&gt; para contener un &lt;code&gt;i32&lt;/code&gt; dentro de un &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; , como hicimos en el Listado 16-12. A continuaci&amp;oacute;n, creamos 10 subprocesos iterando sobre un rango de n&amp;uacute;meros. Usamos &lt;code&gt;thread::spawn&lt;/code&gt; y damos a todos los hilos el mismo cierre, uno que mueve el contador al hilo, adquiere un bloqueo en &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; llamando al m&amp;eacute;todo de &lt;code&gt;lock&lt;/code&gt; , y luego agrega 1 al valor en el mutex. Cuando un hilo termina de ejecutar su cierre, &lt;code&gt;num&lt;/code&gt; saldr&amp;aacute; del alcance y liberar&amp;aacute; el bloqueo para que otro hilo pueda adquirirlo.</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">Creamos un directorio de &lt;em&gt;pruebas&lt;/em&gt; en el nivel superior de nuestro directorio de proyectos, junto a &lt;em&gt;src&lt;/em&gt; . Cargo sabe buscar archivos de prueba de integraci&amp;oacute;n en este directorio. Luego podemos crear tantos archivos de prueba como queramos en este directorio, y Cargo compilar&amp;aacute; cada uno de los archivos como una caja individual.</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">Creamos un nuevo canal usando la funci&amp;oacute;n &lt;code&gt;mpsc::channel&lt;/code&gt; ; &lt;code&gt;mpsc&lt;/code&gt; significa &lt;em&gt;productor m&amp;uacute;ltiple, consumidor &amp;uacute;nico&lt;/em&gt; . En resumen, la forma en que la biblioteca est&amp;aacute;ndar de Rust implementa canales significa que un canal puede tener m&amp;uacute;ltiples extremos de &lt;em&gt;env&amp;iacute;o&lt;/em&gt; que producen valores, pero solo un extremo de &lt;em&gt;recepci&amp;oacute;n&lt;/em&gt; que consume esos valores. Imag&amp;iacute;nese que varios arroyos fluyen juntos en un gran r&amp;iacute;o: todo lo que se env&amp;iacute;a por cualquiera de los arroyos terminar&amp;aacute; en un r&amp;iacute;o al final. Comenzaremos con un solo productor por ahora, pero agregaremos varios productores cuando este ejemplo funcione.</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">Creamos una tupla escribiendo una lista de valores separados por comas entre par&amp;eacute;ntesis. Cada posici&amp;oacute;n en la tupla tiene un tipo, y los tipos de los diferentes valores en la tupla no tienen que ser los mismos. Hemos agregado anotaciones de tipo opcionales en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Creamos un valor que es una instancia de &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; y lo almacenamos en una variable denominada &lt;code&gt;value&lt;/code&gt; para que podamos acceder a &amp;eacute;l directamente m&amp;aacute;s tarde. Entonces se crea una &lt;code&gt;List&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; con un &lt;code&gt;Cons&lt;/code&gt; variante que tiene &lt;code&gt;value&lt;/code&gt; . Necesitamos clonar el &lt;code&gt;value&lt;/code&gt; para que tanto &lt;code&gt;a&lt;/code&gt; como el &lt;code&gt;value&lt;/code&gt; tengan la propiedad del valor &lt;code&gt;5&lt;/code&gt; interno en lugar de transferir la propiedad del &lt;code&gt;value&lt;/code&gt; a &lt;code&gt;a&lt;/code&gt; o tener &lt;code&gt;a&lt;/code&gt; pr&amp;eacute;stamo del &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">Creamos una variable &lt;code&gt;one_borrow&lt;/code&gt; para el puntero inteligente &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; devuelto desde &lt;code&gt;borrow_mut&lt;/code&gt; . Luego creamos otro pr&amp;eacute;stamo mutable de la misma manera en la variable &lt;code&gt;two_borrow&lt;/code&gt; . Esto crea dos referencias mutables en el mismo &amp;aacute;mbito, lo cual no est&amp;aacute; permitido. Cuando ejecutamos las pruebas para nuestra biblioteca, el c&amp;oacute;digo del Listado 15-23 se compilar&amp;aacute; sin errores, pero la prueba fallar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">Creamos una variable llamada &lt;code&gt;guess&lt;/code&gt; . Pero espera, &amp;iquest;el programa no tiene ya una variable llamada &lt;code&gt;guess&lt;/code&gt; ? Lo hace, pero Rust nos permite &lt;em&gt;sombrear&lt;/em&gt; el valor anterior de &lt;code&gt;guess&lt;/code&gt; con uno nuevo. Esta funci&amp;oacute;n se utiliza a menudo en situaciones en las que desea convertir un valor de un tipo a otro. El sombreado nos permite reutilizar el nombre de la variable de &lt;code&gt;guess&lt;/code&gt; lugar de obligarnos a crear dos variables &amp;uacute;nicas, como &lt;code&gt;guess_str&lt;/code&gt; y &lt;code&gt;guess&lt;/code&gt; , por ejemplo. (El Cap&amp;iacute;tulo 3 cubre el sombreado con m&amp;aacute;s detalle).</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Creamos una instancia &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; contiene un valor &lt;code&gt;List&lt;/code&gt; en la variable &lt;code&gt;a&lt;/code&gt; con una lista inicial de &lt;code&gt;5, Nil&lt;/code&gt; . Luego creamos una instancia &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; contiene otro valor &lt;code&gt;List&lt;/code&gt; en la variable &lt;code&gt;b&lt;/code&gt; que contiene el valor 10 y apunta a la lista en &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">Definimos un m&amp;oacute;dulo comenzando con la palabra clave &lt;code&gt;mod&lt;/code&gt; y luego especificamos el nombre del m&amp;oacute;dulo (en este caso, &lt;code&gt;front_of_house&lt;/code&gt; ) y colocamos llaves alrededor del cuerpo del m&amp;oacute;dulo. Dentro de los m&amp;oacute;dulos, podemos tener otros m&amp;oacute;dulos, como en este caso con los m&amp;oacute;dulos de &lt;code&gt;hosting&lt;/code&gt; y &lt;code&gt;serving&lt;/code&gt; . Los m&amp;oacute;dulos tambi&amp;eacute;n pueden contener definiciones para otros elementos, como estructuras, enumeraciones, constantes, rasgos o, como en el Listado 7-1, funciones.</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">Definimos una estructura llamada &lt;code&gt;MyBox&lt;/code&gt; y declaramos un par&amp;aacute;metro gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; , porque queremos que nuestro tipo contenga valores de cualquier tipo. El &lt;code&gt;MyBox&lt;/code&gt; tipo es una struct tupla con un elemento de tipo &lt;code&gt;T&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;MyBox::new&lt;/code&gt; toma un par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; y devuelve una instancia de &lt;code&gt;MyBox&lt;/code&gt; que contiene el valor pasado.</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">Definimos la variable &lt;code&gt;b&lt;/code&gt; para que tenga el valor de una &lt;code&gt;Box&lt;/code&gt; que apunta al valor &lt;code&gt;5&lt;/code&gt; , que se asigna en el mont&amp;oacute;n. Este programa imprimir&amp;aacute; &lt;code&gt;b = 5&lt;/code&gt; ; en este caso, podemos acceder a los datos en el cuadro de manera similar a como lo har&amp;iacute;amos si estos datos estuvieran en la pila. Al igual que cualquier valor de propiedad, cuando un cuadro sale del alcance, como lo hace &lt;code&gt;b&lt;/code&gt; al final de &lt;code&gt;main&lt;/code&gt; , se desasignar&amp;aacute;. La desasignaci&amp;oacute;n ocurre para la caja (almacenada en la pila) y los datos a los que apunta (almacenados en la pila).</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">&amp;iexcl;Lo hicimos! Contamos de 0 a 10, lo que puede no parecer muy impresionante, pero nos ense&amp;ntilde;&amp;oacute; mucho sobre &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; y la seguridad de subprocesos. Tambi&amp;eacute;n puede usar la estructura de este programa para realizar operaciones m&amp;aacute;s complicadas que simplemente incrementar un contador. Con esta estrategia, puede dividir un c&amp;aacute;lculo en partes independientes, dividir esas partes en subprocesos y luego usar un &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; para que cada subproceso actualice el resultado final con su parte.</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">No manejamos el caso &lt;code&gt;None&lt;/code&gt; , por lo que este c&amp;oacute;digo provocar&amp;aacute; un error. Afortunadamente, es un error que Rust sabe atrapar. Si intentamos compilar este c&amp;oacute;digo, obtendremos este error:</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">Discutimos c&amp;oacute;mo controlar la encapsulaci&amp;oacute;n en el Cap&amp;iacute;tulo 7: podemos usar la palabra clave &lt;code&gt;pub&lt;/code&gt; para decidir qu&amp;eacute; m&amp;oacute;dulos, tipos, funciones y m&amp;eacute;todos en nuestro c&amp;oacute;digo deben ser p&amp;uacute;blicos y, por defecto, todo lo dem&amp;aacute;s es privado. Por ejemplo, podemos definir una estructura &lt;code&gt;AveragedCollection&lt;/code&gt; que tiene un campo que contiene un vector de valores &lt;code&gt;i32&lt;/code&gt; . La estructura tambi&amp;eacute;n puede tener un campo que contenga el promedio de los valores en el vector, lo que significa que el promedio no tiene que calcularse a pedido cuando alguien lo necesite. En otras palabras, &lt;code&gt;AveragedCollection&lt;/code&gt; almacenar&amp;aacute; en cach&amp;eacute; el promedio calculado para nosotros. El Listado 17-1 tiene la definici&amp;oacute;n de la estructura &lt;code&gt;AveragedCollection&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">Hacemos esto agregando otro atributo, &lt;code&gt;should_panic&lt;/code&gt; , a nuestra funci&amp;oacute;n de prueba. Este atributo hace un pase de prueba si el c&amp;oacute;digo dentro de la funci&amp;oacute;n entra en p&amp;aacute;nico; la prueba fallar&amp;aacute; si el c&amp;oacute;digo dentro de la funci&amp;oacute;n no entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">No recibimos un mensaje muy &amp;uacute;til en este caso, pero cuando miramos la funci&amp;oacute;n de prueba, vemos que est&amp;aacute; anotado con &lt;code&gt;#[should_panic]&lt;/code&gt; . La falla que obtuvimos significa que el c&amp;oacute;digo en la funci&amp;oacute;n de prueba no caus&amp;oacute; p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">No necesitamos anotar ning&amp;uacute;n c&amp;oacute;digo en &lt;em&gt;tests / integration_test.rs&lt;/em&gt; con &lt;code&gt;#[cfg(test)]&lt;/code&gt; . Cargo trata el directorio de &lt;code&gt;tests&lt;/code&gt; especial y compila archivos en este directorio solo cuando ejecutamos &lt;code&gt;cargo test&lt;/code&gt; . Ejecute la &lt;code&gt;cargo test&lt;/code&gt; ahora:</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">No somos due&amp;ntilde;os de la memoria en esta ubicaci&amp;oacute;n arbitraria, y no hay garant&amp;iacute;a de que el segmento que crea este c&amp;oacute;digo contenga valores &lt;code&gt;i32&lt;/code&gt; v&amp;aacute;lidos . Intentar utilizar el &lt;code&gt;slice&lt;/code&gt; como si fuera un segmento v&amp;aacute;lido da como resultado un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">No solo necesitamos crear una tabla de todas las implementaciones de todos los m&amp;eacute;todos de &lt;code&gt;Trait&lt;/code&gt; , necesitamos crear dicha tabla, para cada tipo diferente alimentado a &lt;code&gt;foo()&lt;/code&gt; . En este caso, resulta ser (10 tipos que implementan &lt;code&gt;Trait&lt;/code&gt; ) * (3 tipos que se alimentan a &lt;code&gt;foo()&lt;/code&gt; ) = 30 implementaciones.</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">Terminamos con una salida diferente:</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">&lt;code&gt;deref&lt;/code&gt; el cuerpo del m&amp;eacute;todo deref con &lt;code&gt;&amp;amp;self.0&lt;/code&gt; para que &lt;code&gt;deref&lt;/code&gt; devuelva una referencia al valor al que queremos acceder con el operador &lt;code&gt;*&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; Listado 15-9 que llama a &lt;code&gt;*&lt;/code&gt; en el valor &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; ahora se compila y las aserciones pasan.</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">Primero cubrimos los rasgos en la secci&amp;oacute;n &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&quot;Rasgos: Definici&amp;oacute;n del comportamiento compartido&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 10, pero al igual que con las vidas, no discutimos los detalles m&amp;aacute;s avanzados. Ahora que sabe m&amp;aacute;s sobre Rust, podemos entrar en el meollo de la cuesti&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">Arreglamos una serie de pequeños errores y una redacción imprecisa a lo largo del libro.¡Gracias a los lectores que los reportaron!</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">Obtenemos una instancia de estructura &lt;code&gt;Ident&lt;/code&gt; que contiene el nombre (identificador) del tipo anotado usando &lt;code&gt;ast.ident&lt;/code&gt; . La estructura del Listado 19-32 muestra que cuando ejecutamos la funci&amp;oacute;n &lt;code&gt;impl_hello_macro&lt;/code&gt; en el c&amp;oacute;digo del Listado 19-30, la &lt;code&gt;ident&lt;/code&gt; ificaci&amp;oacute;n que obtenemos tendr&amp;aacute; el campo &lt;code&gt;ident&lt;/code&gt; con un valor de &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; . Por lo tanto, la variable de &lt;code&gt;name&lt;/code&gt; en el Listado 19-33 contendr&amp;aacute; una instancia de estructura &lt;code&gt;Ident&lt;/code&gt; que, cuando se imprima, ser&amp;aacute; la cadena &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; , el nombre de la estructura en el Listado 19-30.</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">Recibimos un error que dice que se requiere &lt;code&gt;Display&lt;/code&gt; pero no est&amp;aacute; implementado:</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">Tenemos un error:</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">Obtenemos el índice para el final de la palabra de la misma manera que lo hicimos en la lista 4-7,buscando la primera ocurrencia de un espacio.Cuando encontramos un espacio,devolvemos un trozo de cadena usando el comienzo de la cadena y el índice del espacio como índices de comienzo y final.</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">Le damos a &lt;code&gt;Post&lt;/code&gt; un m&amp;eacute;todo p&amp;uacute;blico llamado &lt;code&gt;request_review&lt;/code&gt; que tomar&amp;aacute; una referencia mutable a &lt;code&gt;self&lt;/code&gt; . Luego llamamos a un m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; interno en el estado actual de &lt;code&gt;Post&lt;/code&gt; , y este segundo m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; consume el estado actual y devuelve un nuevo estado.</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">Tenemos un rasgo y su función.En este punto,nuestro usuario de la caja podría implementar el rasgo para lograr la funcionalidad deseada,así:</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">Tenemos otro patr&amp;oacute;n &amp;uacute;til que explota un detalle de implementaci&amp;oacute;n de estructuras de tupla y variantes de enumeraci&amp;oacute;n de estructura de tupla. Estos tipos usan &lt;code&gt;()&lt;/code&gt; como sintaxis de inicializador, que parece una llamada a funci&amp;oacute;n. Los inicializadores se implementan realmente como funciones que devuelven una instancia construida a partir de sus argumentos. Podemos usar estas funciones de inicializador como punteros de funci&amp;oacute;n que implementan los rasgos de cierre, lo que significa que podemos especificar las funciones de inicializador como argumentos para m&amp;eacute;todos que toman cierres, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">Tenemos la mayor parte del juego funcionando ahora, pero el usuario solo puede hacer una suposici&amp;oacute;n. &amp;iexcl;Cambiemos eso agregando un bucle!</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">Tenemos dos estructuras, &lt;code&gt;Millimeters&lt;/code&gt; y &lt;code&gt;Meters&lt;/code&gt; , con valores en diferentes unidades. Queremos agregar valores en mil&amp;iacute;metros a valores en metros y que la implementaci&amp;oacute;n de &lt;code&gt;Add&lt;/code&gt; haga la conversi&amp;oacute;n correctamente. Podemos implementar &lt;code&gt;Add&lt;/code&gt; por &lt;code&gt;Millimeters&lt;/code&gt; con &lt;code&gt;Meters&lt;/code&gt; como el &lt;code&gt;RHS&lt;/code&gt; , como se muestra en el Listado 19-15.</target>
        </trans-unit>
        <trans-unit id="d8a3dea7c52bc3f0b1a5887645fbfc3ac18bf504" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;Rhs&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160ceff2ab6cdd2b56a8bbd9402294ab3fbd2021" translate="yes" xml:space="preserve">
          <source>We have written an &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;async book&lt;/a&gt; detailing async/await and trade-offs compared to using threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="translated">Dimos a entender que este ejemplo no se compilar&amp;iacute;a. &amp;iexcl;Ahora averig&amp;uuml;emos por qu&amp;eacute;!</target>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="translated">Implementamos el rasgo &lt;code&gt;Iterator&lt;/code&gt; definiendo el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo, por lo que ahora podemos usar las implementaciones predeterminadas de cualquier m&amp;eacute;todo de rasgo &lt;code&gt;Iterator&lt;/code&gt; como se define en la biblioteca est&amp;aacute;ndar, porque todos usan la funcionalidad del &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="translated">Acabamos de construir un proyecto con &lt;code&gt;cargo build&lt;/code&gt; y lo &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt; con ./target/debug/hello_cargo , pero tambi&amp;eacute;n podemos usar &lt;code&gt;cargo run&lt;/code&gt; para compilar el c&amp;oacute;digo y luego ejecutar el ejecutable resultante todo en un comando:</target>
        </trans-unit>
        <trans-unit id="a56bd0b36b29e10cce98f9d35be1f611e5d93adf" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;add&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">Mantenemos la afirmaci&amp;oacute;n de que el &amp;iacute;ndice &lt;code&gt;mid&lt;/code&gt; est&amp;aacute; dentro del segmento. Luego llegamos al c&amp;oacute;digo inseguro: la funci&amp;oacute;n &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; toma un puntero sin procesar y una longitud, y crea un segmento. Usamos esta funci&amp;oacute;n para crear un segmento que comienza desde &lt;code&gt;ptr&lt;/code&gt; y tiene la &lt;code&gt;mid&lt;/code&gt; elementos. Luego llamamos al m&amp;eacute;todo de &lt;code&gt;offset&lt;/code&gt; en &lt;code&gt;ptr&lt;/code&gt; con &lt;code&gt;mid&lt;/code&gt; como argumento para obtener un puntero sin formato que comienza en &lt;code&gt;mid&lt;/code&gt; , y creamos un segmento usando ese puntero y el n&amp;uacute;mero restante de elementos despu&amp;eacute;s de &lt;code&gt;mid&lt;/code&gt; como longitud.</target>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="translated">Sabemos que queremos definir un m&amp;eacute;todo, por lo que estar&amp;aacute; dentro del bloque &lt;code&gt;impl Rectangle&lt;/code&gt; . El nombre del m&amp;eacute;todo ser&amp;aacute; &lt;code&gt;can_hold&lt;/code&gt; , y tomar&amp;aacute; un pr&amp;eacute;stamo inmutable de otro &lt;code&gt;Rectangle&lt;/code&gt; como par&amp;aacute;metro. Podemos saber cu&amp;aacute;l ser&amp;aacute; el tipo de par&amp;aacute;metro mirando el c&amp;oacute;digo que llama al m&amp;eacute;todo: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; pasa &lt;code&gt;&amp;amp;rect2&lt;/code&gt; , que es un pr&amp;eacute;stamo inmutable para &lt;code&gt;rect2&lt;/code&gt; , una instancia de &lt;code&gt;Rectangle&lt;/code&gt; . Esto tiene sentido porque solo necesitamos leer &lt;code&gt;rect2&lt;/code&gt; (en lugar de escribir, lo que significar&amp;iacute;a que necesitar&amp;iacute;amos un pr&amp;eacute;stamo mutable), y queremos que &lt;code&gt;main&lt;/code&gt; conserve la propiedad de &lt;code&gt;rect2&lt;/code&gt; para que podamos usarlo nuevamente despu&amp;eacute;s de llamar al m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; . El valor de retorno de &lt;code&gt;can_hold&lt;/code&gt; ser&amp;aacute; un booleano y la implementaci&amp;oacute;n comprobar&amp;aacute; si el ancho y el alto de &lt;code&gt;self&lt;/code&gt; son ambos mayores que el ancho y el alto del otro &lt;code&gt;Rectangle&lt;/code&gt; , respectivamente. &lt;code&gt;can_hold&lt;/code&gt; el nuevo m&amp;eacute;todo can_hold al bloque &lt;code&gt;impl&lt;/code&gt; del Listado 5-13, que se muestra en el Listado 5-15.</target>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="translated">Dejamos la &lt;code&gt;list&lt;/code&gt; a y los campos &lt;code&gt;average&lt;/code&gt; privado, por lo que no hay forma de que el c&amp;oacute;digo externo agregue o elimine elementos al campo de la &lt;code&gt;list&lt;/code&gt; a directamente; de lo contrario, es posible que el campo &lt;code&gt;average&lt;/code&gt; no est&amp;eacute; sincronizado cuando cambie la &lt;code&gt;list&lt;/code&gt; a . El m&amp;eacute;todo de &lt;code&gt;average&lt;/code&gt; devuelve el valor en el campo de &lt;code&gt;average&lt;/code&gt; , lo que permite que el c&amp;oacute;digo externo lea el &lt;code&gt;average&lt;/code&gt; pero no lo modifique.</target>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="translated">Dejamos un comentario en el bucle &lt;code&gt;for&lt;/code&gt; del Listado 20-14 con respecto a la creaci&amp;oacute;n de subprocesos. Aqu&amp;iacute;, veremos c&amp;oacute;mo creamos realmente los hilos. La biblioteca est&amp;aacute;ndar proporciona &lt;code&gt;thread::spawn&lt;/code&gt; como una forma de crear hilos, y &lt;code&gt;thread::spawn&lt;/code&gt; espera obtener alg&amp;uacute;n c&amp;oacute;digo que el hilo deber&amp;iacute;a ejecutar tan pronto como se cree el hilo. Sin embargo, en nuestro caso, queremos crear los hilos y hacer que &lt;em&gt;esperen el&lt;/em&gt; c&amp;oacute;digo que enviaremos m&amp;aacute;s tarde. La implementaci&amp;oacute;n de subprocesos de la biblioteca est&amp;aacute;ndar no incluye ninguna forma de hacerlo; tenemos que implementarlo manualmente.</target>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="translated">Tenemos una lista de la &lt;code&gt;x&lt;/code&gt; valor y luego s&amp;oacute;lo incluimos el &lt;code&gt;..&lt;/code&gt; patr&amp;oacute;n. Esto es m&amp;aacute;s r&amp;aacute;pido que tener que enumerar &lt;code&gt;y: _&lt;/code&gt; y &lt;code&gt;z: _&lt;/code&gt; , particularmente cuando trabajamos con estructuras que tienen muchos campos en situaciones en las que solo uno o dos campos son relevantes.</target>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="translated">Hacemos dos subprocesos y cambiamos los nombres de variables usados ​​con el segundo subproceso a &lt;code&gt;handle2&lt;/code&gt; y &lt;code&gt;num2&lt;/code&gt; . Cuando ejecutamos el c&amp;oacute;digo esta vez, la compilaci&amp;oacute;n nos da lo siguiente:</target>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="translated">Es posible que queramos escribir bytes en un &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; en nuestro c&amp;oacute;digo de producci&amp;oacute;n, pero usar un b&amp;uacute;fer en memoria en nuestras pruebas. Podemos hacer esto con &lt;code&gt;Cursor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Modificamos &lt;code&gt;a&lt;/code&gt; para que apunte &lt;code&gt;b&lt;/code&gt; lugar de &lt;code&gt;Nil&lt;/code&gt; , creando un ciclo. Lo hacemos usando el m&amp;eacute;todo &lt;code&gt;tail&lt;/code&gt; para obtener una referencia a &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; , que colocamos en el &lt;code&gt;link&lt;/code&gt; la variable . Luego usamos el m&amp;eacute;todo de &lt;code&gt;borrow_mut&lt;/code&gt; en el &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; para cambiar el valor dentro de un &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; que tiene un valor &lt;code&gt;Nil&lt;/code&gt; al &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; en &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="translated">Debemos llamar a la funci&amp;oacute;n &lt;code&gt;dangerous&lt;/code&gt; dentro de un bloque &lt;code&gt;unsafe&lt;/code&gt; separado . Si intentamos llamar a &lt;code&gt;dangerous&lt;/code&gt; sin el bloqueo &lt;code&gt;unsafe&lt;/code&gt; , obtendremos un error:</target>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="translated">Necesitamos un objeto simulado que, en lugar de enviar un correo electr&amp;oacute;nico o mensaje de texto cuando llamamos a &lt;code&gt;send&lt;/code&gt; , solo har&amp;aacute; un seguimiento de los mensajes que se le indique que env&amp;iacute;e. Podemos crear una nueva instancia del objeto de burla, crear un &lt;code&gt;LimitTracker&lt;/code&gt; que utiliza el objeto de burla, llamar a la &lt;code&gt;set_value&lt;/code&gt; m&amp;eacute;todo de &lt;code&gt;LimitTracker&lt;/code&gt; , y luego comprobar si el objeto maqueta tiene los mensajes que esperamos. El Listado 15-21 muestra un intento de implementar un objeto simulado para hacer precisamente eso, pero el verificador de pr&amp;eacute;stamos no lo permitir&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="a110963ca04d0182f8c4f733a600767ec4a8c414" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the allocator when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Necesitamos una forma de devolver esta memoria al sistema operativo cuando hayamos terminado con nuestro &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="translated">Necesitamos agregar una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; para traer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; al alcance porque no est&amp;aacute; en el preludio. En &lt;code&gt;main&lt;/code&gt; , creamos la lista que contiene 5 y 10 y la almacenamos en un nuevo &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; . Luego, cuando creamos &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; , llamamos a la &lt;code&gt;Rc::clone&lt;/code&gt; funci&amp;oacute;n y pasa una referencia a la &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; como un argumento.</target>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="translated">Necesitamos agregar al c&amp;oacute;digo en el Listado 9-3 para tomar diferentes acciones dependiendo del valor &lt;code&gt;File::open&lt;/code&gt; return. El Listado 9-4 muestra una forma de manejar el &lt;code&gt;Result&lt;/code&gt; ado usando una herramienta b&amp;aacute;sica, la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; que discutimos en el Cap&amp;iacute;tulo 6.</target>
        </trans-unit>
        <trans-unit id="1a52300a363f54affc64d905b97b32aef73e0083" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="translated">Necesitamos ajustar el canal para usar valores de tipo &lt;code&gt;Message&lt;/code&gt; lugar de tipo &lt;code&gt;Job&lt;/code&gt; , como se muestra en el Listado 20-24.</target>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="translated">Necesitamos declarar la caja &lt;code&gt;hello_macro_derive&lt;/code&gt; como una caja de macro de procedimiento. Tambi&amp;eacute;n necesitaremos la funcionalidad de las cajas &lt;code&gt;syn&lt;/code&gt; y &lt;code&gt;quote&lt;/code&gt; , como ver&amp;aacute; en un momento, por lo que debemos agregarlas como dependencias. A&amp;ntilde;adir lo siguiente a la &lt;em&gt;Cargo.toml&lt;/em&gt; archivo para &lt;code&gt;hello_macro_derive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="translated">Necesitamos establecer el &lt;code&gt;state&lt;/code&gt; en &lt;code&gt;None&lt;/code&gt; temporalmente en lugar de establecerlo directamente con un c&amp;oacute;digo como &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; para obtener la propiedad del valor &lt;code&gt;state&lt;/code&gt; . Esto garantiza que &lt;code&gt;Post&lt;/code&gt; no pueda usar el valor de &lt;code&gt;state&lt;/code&gt; despu&amp;eacute;s de que lo hayamos transformado en un nuevo estado.</target>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="translated">Necesit&amp;aacute;bamos &lt;code&gt;clone&lt;/code&gt; aqu&amp;iacute; porque tenemos un segmento con elementos &lt;code&gt;String&lt;/code&gt; en el par&amp;aacute;metro &lt;code&gt;args&lt;/code&gt; , pero la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n no posee &lt;code&gt;args&lt;/code&gt; . Para devolver la propiedad de una instancia de &lt;code&gt;Config&lt;/code&gt; , tuvimos que clonar los valores de los campos de &lt;code&gt;query&lt;/code&gt; y &lt;code&gt;filename&lt;/code&gt; de archivo de &lt;code&gt;Config&lt;/code&gt; uraci&amp;oacute;n para que la instancia de &lt;code&gt;Config&lt;/code&gt; pueda poseer sus valores.</target>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="translated">Ahora tenemos una API sencilla que es mucho m&amp;aacute;s dif&amp;iacute;cil de estropear, porque el compilador se asegurar&amp;aacute; de que las referencias a &lt;code&gt;String&lt;/code&gt; sigan siendo v&amp;aacute;lidas. &amp;iquest;Recuerda el error en el programa del Listado 4-8, cuando llevamos el &amp;iacute;ndice al final de la primera palabra pero luego borramos la cadena para que nuestro &amp;iacute;ndice no fuera v&amp;aacute;lido? Ese c&amp;oacute;digo era l&amp;oacute;gicamente incorrecto pero no mostr&amp;oacute; ning&amp;uacute;n error inmediato. Los problemas aparecer&amp;iacute;an m&amp;aacute;s tarde si segu&amp;iacute;amos intentando utilizar el &amp;iacute;ndice de la primera palabra con una cadena vac&amp;iacute;a. Las rebanadas hacen que este error sea imposible y nos hacen saber que tenemos un problema con nuestro c&amp;oacute;digo mucho antes. El uso de la versi&amp;oacute;n de &lt;code&gt;first_word&lt;/code&gt; de first_word arrojar&amp;aacute; un error en tiempo de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="translated">Ahora tenemos una forma de averiguar el &amp;iacute;ndice del final de la primera palabra de la cadena, pero hay un problema. &lt;code&gt;usize&lt;/code&gt; un usize por s&amp;iacute; solo, pero es solo un n&amp;uacute;mero significativo en el contexto de &lt;code&gt;&amp;amp;String&lt;/code&gt; . En otras palabras, debido a que es un valor separado de &lt;code&gt;String&lt;/code&gt; , no hay garant&amp;iacute;a de que seguir&amp;aacute; siendo v&amp;aacute;lido en el futuro. Considere el programa del Listado 4-8 que usa la funci&amp;oacute;n &lt;code&gt;first_word&lt;/code&gt; del Listado 4-7.</target>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="translated">Ahora necesitamos que nuestro alias de tipo de &lt;code&gt;Job&lt;/code&gt; sea ​​una &lt;code&gt;Box&lt;/code&gt; de cualquier cosa que implemente nuestro nuevo rasgo &lt;code&gt;FnBox&lt;/code&gt; . Esto nos permitir&amp;aacute; usar &lt;code&gt;call_box&lt;/code&gt; en &lt;code&gt;Worker&lt;/code&gt; cuando obtengamos un valor de &lt;code&gt;Job&lt;/code&gt; en lugar de invocar el cierre directamente. La implementaci&amp;oacute;n del rasgo &lt;code&gt;FnBox&lt;/code&gt; para cualquier cierre de &lt;code&gt;FnOnce()&lt;/code&gt; significa que no tenemos que cambiar nada sobre los valores reales que estamos enviando por el canal. Ahora Rust es capaz de reconocer que lo que queremos hacer est&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="translated">Pasamos el valor de la variable &lt;code&gt;case_sensitive&lt;/code&gt; a la instancia de &lt;code&gt;Config&lt;/code&gt; para que la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; pueda leer ese valor y decidir si llama a &lt;code&gt;search&lt;/code&gt; o &lt;code&gt;search_case_insensitive&lt;/code&gt; , como implementamos en el Listado 12-22.</target>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="translated">Colocamos la &lt;code&gt;#[should_panic]&lt;/code&gt; atributo despu&amp;eacute;s de la &lt;code&gt;#[test]&lt;/code&gt; atributo y antes de la funci&amp;oacute;n de prueba que se aplica. Veamos el resultado cuando pasa esta prueba:</target>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="translated">Ejecutamos un punto de referencia cargando todo el contenido de &lt;em&gt;Las aventuras de Sherlock Holmes&lt;/em&gt; de Sir Arthur Conan Doyle en una &lt;code&gt;String&lt;/code&gt; y buscando la palabra &lt;em&gt;the&lt;/em&gt; en el contenido. Estos son los resultados del punto de referencia en la versi&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; usa el bucle &lt;code&gt;for&lt;/code&gt; y la versi&amp;oacute;n que usa iteradores:</target>
        </trans-unit>
        <trans-unit id="3cb4438c8408ae587f40f74c3ab4a85a10a319c0" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a reference to a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Leemos esta definici&amp;oacute;n como: la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; es gen&amp;eacute;rico sobre alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; . Esta funci&amp;oacute;n tiene un par&amp;aacute;metro llamado &lt;code&gt;list&lt;/code&gt; a , que es un pedazo de valores de tipo &lt;code&gt;T&lt;/code&gt; . La &lt;code&gt;largest&lt;/code&gt; funci&amp;oacute;n devolver&amp;aacute; un valor del mismo tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="translated">Recibimos el siguiente error:</target>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="translated">Establecemos el tipo de &lt;code&gt;Item&lt;/code&gt; asociado para nuestro iterador en &lt;code&gt;u32&lt;/code&gt; , lo que significa que el iterador devolver&amp;aacute; valores &lt;code&gt;u32&lt;/code&gt; . Nuevamente, no se preocupe por los tipos asociados todav&amp;iacute;a, los cubriremos en el Cap&amp;iacute;tulo 19.</target>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="translated">Establecemos el n&amp;uacute;mero de subprocesos de prueba en &lt;code&gt;1&lt;/code&gt; , dici&amp;eacute;ndole al programa que no use ning&amp;uacute;n paralelismo. Ejecutar las pruebas usando un hilo llevar&amp;aacute; m&amp;aacute;s tiempo que ejecutarlas en paralelo, pero las pruebas no interferir&amp;aacute;n entre s&amp;iacute; si comparten el estado.</target>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="translated">Deber&amp;iacute;amos obtener l&amp;iacute;neas que contengan &quot;a&quot; que podr&amp;iacute;an tener letras may&amp;uacute;sculas:</target>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="translated">Seguimos habilitando la creaci&amp;oacute;n de nuevas publicaciones en el estado de borrador usando &lt;code&gt;Post::new&lt;/code&gt; y la capacidad de agregar texto al contenido de la publicaci&amp;oacute;n. Pero en lugar de tener un m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; en un borrador de publicaci&amp;oacute;n que devuelve una cadena vac&amp;iacute;a, lo haremos para que las publicaciones de borrador no tengan el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; en absoluto. De esa manera, si intentamos obtener el contenido de una publicaci&amp;oacute;n en borrador, obtendremos un error del compilador que nos indica que el m&amp;eacute;todo no existe. Como resultado, ser&amp;aacute; imposible para nosotros mostrar accidentalmente el contenido de la publicaci&amp;oacute;n en borrador en producci&amp;oacute;n, porque ese c&amp;oacute;digo ni siquiera se compilar&amp;aacute;. El Listado 17-19 muestra la definici&amp;oacute;n de una estructura &lt;code&gt;Post&lt;/code&gt; y una estructura &lt;code&gt;DraftPost&lt;/code&gt; , as&amp;iacute; como los m&amp;eacute;todos en cada una:</target>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="translated">Todav&amp;iacute;a tenemos una funci&amp;oacute;n &lt;code&gt;Post::new&lt;/code&gt; , pero en lugar de devolver una instancia de &lt;code&gt;Post&lt;/code&gt; , devuelve una instancia de &lt;code&gt;DraftPost&lt;/code&gt; . Debido a que el &lt;code&gt;content&lt;/code&gt; es privado y no hay funciones que devuelvan &lt;code&gt;Post&lt;/code&gt; , no es posible crear una instancia de &lt;code&gt;Post&lt;/code&gt; este momento.</target>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">Seguimos usando el &lt;code&gt;()&lt;/code&gt; despu&amp;eacute;s de &lt;code&gt;FnOnce&lt;/code&gt; porque este &lt;code&gt;FnOnce&lt;/code&gt; representa un cierre que no toma par&amp;aacute;metros y no devuelve un valor. Al igual que las definiciones de funciones, el tipo de retorno se puede omitir de la firma, pero incluso si no tenemos par&amp;aacute;metros, todav&amp;iacute;a necesitamos los par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="fb6760fff74f1d2184578db32de57a1297acba15" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and returns the unit type &lt;code&gt;()&lt;/code&gt;. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e44b48751025b1860e023a6de0b5d66e3d099ea" translate="yes" xml:space="preserve">
          <source>We still want to have our program stop running if the unimplemented methods are reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="translated">Hablamos de cadenas en el Cap&amp;iacute;tulo 4, pero las veremos con m&amp;aacute;s profundidad ahora. Los nuevos rust&amp;aacute;ceos com&amp;uacute;nmente se atascan en las cadenas por una combinaci&amp;oacute;n de tres razones: la propensi&amp;oacute;n de Rust a exponer posibles errores, las cadenas son una estructura de datos m&amp;aacute;s complicada de lo que muchos programadores les dan cr&amp;eacute;dito, y UTF-8. Estos factores se combinan de una manera que puede parecer dif&amp;iacute;cil cuando proviene de otros lenguajes de programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="translated">Imprimimos temporalmente los valores de estas variables para demostrar que el c&amp;oacute;digo est&amp;aacute; funcionando como pretendemos. &lt;code&gt;sample.txt&lt;/code&gt; este programa nuevamente con los argumentos &lt;code&gt;test&lt;/code&gt; y sample.txt :</target>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="translated">Luego llamamos al m&amp;eacute;todo de &lt;code&gt;unwrap&lt;/code&gt; , que sabemos que nunca entrar&amp;aacute; en p&amp;aacute;nico, porque sabemos que los m&amp;eacute;todos en &lt;code&gt;Post&lt;/code&gt; aseguran que el &lt;code&gt;state&lt;/code&gt; siempre contendr&amp;aacute; un valor &lt;code&gt;Some&lt;/code&gt; cuando esos m&amp;eacute;todos est&amp;eacute;n terminados. Este es uno de los casos de los que hablamos en la secci&amp;oacute;n &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Casos en los que tiene m&amp;aacute;s informaci&amp;oacute;n que el compilador&amp;rdquo;&lt;/a&gt; del Cap&amp;iacute;tulo 9, cuando sabemos que un valor &lt;code&gt;None&lt;/code&gt; nunca es posible, aunque el compilador no pueda entenderlo.</target>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="translated">&amp;iexcl;Entonces comenzamos la definici&amp;oacute;n de macro con &lt;code&gt;macro_rules!&lt;/code&gt; y el nombre de la macro que estamos definiendo &lt;em&gt;sin&lt;/em&gt; el signo de exclamaci&amp;oacute;n. El nombre, en este caso &lt;code&gt;vec&lt;/code&gt; , va seguido de corchetes que indican el cuerpo de la definici&amp;oacute;n de macro.</target>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="translated">Usamos &lt;code&gt;ThreadPool::new&lt;/code&gt; para crear un nuevo grupo de subprocesos con un n&amp;uacute;mero configurable de subprocesos, en este caso cuatro. Luego, en el bucle &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;pool.execute&lt;/code&gt; tiene una interfaz similar a &lt;code&gt;thread::spawn&lt;/code&gt; en el sentido de que requiere un cierre que el grupo deber&amp;iacute;a ejecutar para cada flujo. Necesitamos implementar &lt;code&gt;pool.execute&lt;/code&gt; para que tome el cierre y lo entregue a un hilo en el grupo para que se ejecute. Este c&amp;oacute;digo a&amp;uacute;n no se compilar&amp;aacute;, pero lo intentaremos para que el compilador pueda guiarnos sobre c&amp;oacute;mo solucionarlo.</target>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="translated">Usamos &lt;code&gt;expect&lt;/code&gt; de la misma manera que &lt;code&gt;unwrap&lt;/code&gt; : &amp;iexcl;para devolver el identificador del archivo o llamar al &lt;code&gt;panic!&lt;/code&gt; macro. El mensaje de error utilizado por &lt;code&gt;expect&lt;/code&gt; en su llamada al &lt;code&gt;panic!&lt;/code&gt; ser&amp;aacute; el par&amp;aacute;metro que pasamos a &lt;code&gt;expect&lt;/code&gt; , en lugar del &lt;code&gt;panic!&lt;/code&gt; predeterminado . mensaje que &lt;code&gt;unwrap&lt;/code&gt; utiliza. As&amp;iacute; es como se ve:</target>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Usamos &lt;code&gt;if let&lt;/code&gt; en lugar de &lt;code&gt;unwrap_or_else&lt;/code&gt; para verificar si &lt;code&gt;run&lt;/code&gt; devuelve un valor &lt;code&gt;Err&lt;/code&gt; y llamamos a &lt;code&gt;process::exit(1)&lt;/code&gt; si lo hace. La funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; no devuelve un valor que queramos &lt;code&gt;unwrap&lt;/code&gt; de la misma manera que &lt;code&gt;Config::new&lt;/code&gt; devuelve la instancia de &lt;code&gt;Config&lt;/code&gt; . Debido a que &lt;code&gt;run&lt;/code&gt; devuelve &lt;code&gt;()&lt;/code&gt; en el caso de &amp;eacute;xito, solo nos preocupamos por detectar un error, por lo que no necesitamos &lt;code&gt;unwrap_or_else&lt;/code&gt; para devolver el valor desenvuelto porque solo ser&amp;iacute;a &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="translated">Usamos estructuras para agregar significado al etiquetar los datos. Podemos transformar la tupla que estamos usando en un tipo de datos con un nombre para el todo y nombres para las partes, como se muestra en el Listado 5-10.</target>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="translated">Usamos el tipo &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; cuando queremos asignar algunos datos en el mont&amp;oacute;n para que se lean varias partes de nuestro programa y no podemos determinar en el momento de la compilaci&amp;oacute;n qu&amp;eacute; parte terminar&amp;aacute; de usar los datos en &amp;uacute;ltimo lugar. Si supi&amp;eacute;ramos qu&amp;eacute; parte terminar&amp;iacute;a en &amp;uacute;ltimo lugar, podr&amp;iacute;amos convertir esa parte en el propietario de los datos y las reglas de propiedad normales que se aplican en el momento de la compilaci&amp;oacute;n entrar&amp;iacute;an en vigencia.</target>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">Usamos el m&amp;eacute;todo &lt;code&gt;enumerate&lt;/code&gt; para adaptar un iterador para producir un valor y el &amp;iacute;ndice de ese valor en el iterador, colocado en una tupla. La primera llamada a &lt;code&gt;enumerate&lt;/code&gt; produce la tupla &lt;code&gt;(0, 'a')&lt;/code&gt; . Cuando este valor coincide con el patr&amp;oacute;n &lt;code&gt;(index, value)&lt;/code&gt; , el &lt;code&gt;index&lt;/code&gt; ser&amp;aacute; &lt;code&gt;0&lt;/code&gt; y el &lt;code&gt;value&lt;/code&gt; ser&amp;aacute; &lt;code&gt;'a'&lt;/code&gt; , imprimiendo la primera l&amp;iacute;nea de la salida.</target>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="translated">Utilizamos la abreviatura ANYTOKEN para denotar el conjunto de todas las fichas (incluyendo las simples NT).Por ejemplo,si alguna ficha es legal después de una M,entonces SEGUIDA(M)=ANYTOKEN.</target>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="translated">Usamos el encabezado &lt;code&gt;# Examples&lt;/code&gt; Markdown en el Listado 14-1 para crear una secci&amp;oacute;n en el HTML con el t&amp;iacute;tulo &quot;Ejemplos&quot;. Aqu&amp;iacute; hay algunas otras secciones que los autores de cajas usan com&amp;uacute;nmente en su documentaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="translated">Queremos que &lt;code&gt;Cacher&lt;/code&gt; administre los valores de los campos de estructura en lugar de permitir que el c&amp;oacute;digo de llamada cambie potencialmente los valores en estos campos directamente, por lo que estos campos son privados.</target>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Queremos que un &lt;code&gt;Node&lt;/code&gt; propietario de sus hijos y queremos compartir esa propiedad con variables para poder acceder a cada &lt;code&gt;Node&lt;/code&gt; en el &amp;aacute;rbol directamente. Para hacer esto, definimos los elementos &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; como valores de tipo &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; . Tambi&amp;eacute;n queremos modificar qu&amp;eacute; nodos son hijos de otro nodo, por lo que tenemos un &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; en los &lt;code&gt;children&lt;/code&gt; alrededor de &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe26c37f1d8e8931b2a537169f33a14c01a5d00" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 5, &lt;code&gt;next&lt;/code&gt; will increment &lt;code&gt;count&lt;/code&gt; and return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;. Once &lt;code&gt;count&lt;/code&gt; is 5, our iterator will stop incrementing &lt;code&gt;count&lt;/code&gt; and always return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Queremos que nuestro iterador agregue 1 al estado actual, por lo que inicializamos el &lt;code&gt;count&lt;/code&gt; en 0 para que devuelva 1 primero. Si el valor de &lt;code&gt;count&lt;/code&gt; es menor que 6, &lt;code&gt;next&lt;/code&gt; devolver&amp;aacute; el valor actual envuelto en &lt;code&gt;Some&lt;/code&gt; , pero si &lt;code&gt;count&lt;/code&gt; es 6 o mayor, nuestro iterador devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="translated">Queremos que nuestra macro de procedimiento genere una implementaci&amp;oacute;n de nuestro rasgo &lt;code&gt;HelloMacro&lt;/code&gt; para el tipo que anot&amp;oacute; el usuario, que podemos obtener usando &lt;code&gt;#name&lt;/code&gt; . La implementaci&amp;oacute;n del rasgo tiene una funci&amp;oacute;n, &lt;code&gt;hello_macro&lt;/code&gt; , cuyo cuerpo contiene la funcionalidad que queremos proporcionar: imprimiendo &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; y luego el nombre del tipo anotado.</target>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="translated">Queremos que nuestro grupo de subprocesos funcione de una manera similar y familiar, por lo que cambiar de subprocesos a un grupo de subprocesos no requiere grandes cambios en el c&amp;oacute;digo que usa nuestra API. El Listado 20-12 muestra la interfaz hipot&amp;eacute;tica para una estructura &lt;code&gt;ThreadPool&lt;/code&gt; que queremos usar en lugar de &lt;code&gt;thread::spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="translated">Queremos que las estructuras de &lt;code&gt;Worker&lt;/code&gt; que acabamos de crear para obtener c&amp;oacute;digo se ejecuten desde una cola contenida en el &lt;code&gt;ThreadPool&lt;/code&gt; y env&amp;iacute;en ese c&amp;oacute;digo a su hilo para que se ejecute.</target>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="translated">Queremos agregar una nueva funci&amp;oacute;n &lt;code&gt;search_case_insensitive&lt;/code&gt; que llamaremos cuando la variable de entorno est&amp;eacute; activada . Continuaremos siguiendo el proceso TDD, por lo que el primer paso es nuevamente escribir una prueba fallida. &lt;code&gt;search_case_insensitive&lt;/code&gt; una nueva prueba para la nueva funci&amp;oacute;n search_case_insensitive y cambiaremos el nombre de nuestra prueba anterior de &lt;code&gt;one_result&lt;/code&gt; a &lt;code&gt;case_sensitive&lt;/code&gt; para aclarar las diferencias entre las dos pruebas, como se muestra en el Listado 12-20.</target>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="translated">Queremos permitir que el usuario cree un nuevo borrador de publicaci&amp;oacute;n de blog con &lt;code&gt;Post::new&lt;/code&gt; . Luego, queremos permitir que se agregue texto a la publicaci&amp;oacute;n del blog mientras est&amp;aacute; en estado de borrador. Si intentamos obtener el contenido de la publicaci&amp;oacute;n de inmediato, antes de la aprobaci&amp;oacute;n, no deber&amp;iacute;a suceder nada porque la publicaci&amp;oacute;n sigue siendo un borrador. &amp;iexcl;Hemos agregado &lt;code&gt;assert_eq!&lt;/code&gt; en el c&amp;oacute;digo con fines de demostraci&amp;oacute;n. Una prueba unitaria excelente para esto ser&amp;iacute;a afirmar que un borrador de publicaci&amp;oacute;n de blog devuelve una cadena vac&amp;iacute;a del m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; , pero no vamos a escribir pruebas para este ejemplo.</target>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="translated">Queremos definir el c&amp;oacute;digo en un lugar de nuestro programa, pero solo &lt;em&gt;ejecutar&lt;/em&gt; ese c&amp;oacute;digo donde realmente necesitamos el resultado. &amp;iexcl;Este es un caso de uso para cierres!</target>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="translated">Queremos hacer algo con la coincidencia &lt;code&gt;Some(3)&lt;/code&gt; pero no hacer nada con ning&amp;uacute;n otro valor &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; o el valor &lt;code&gt;None&lt;/code&gt; . Para satisfacer la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; , tenemos que agregar &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; despu&amp;eacute;s de procesar solo una variante, que es una gran cantidad de c&amp;oacute;digo repetitivo para agregar.</target>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">Queremos expresar la restricci&amp;oacute;n de que Foo no deber&amp;iacute;a sobrevivir a &lt;code&gt;'a&lt;/code&gt; , porque los datos apuntados por &lt;code&gt;T&lt;/code&gt; solo son v&amp;aacute;lidos para esa vida. El problema es que no hay usos reales de &lt;code&gt;'a&lt;/code&gt; . Es posible solucionar esto agregando un tipo PhantomData a la estructura, us&amp;aacute;ndolo para decirle al compilador que act&amp;uacute;e como si la estructura contuviera una referencia prestada &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8096aefade4c17845a6c208281a849237f1210fa" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; for 'MyStruct', but for some reason it only makes sense to implement the &lt;code&gt;bar()&lt;/code&gt; function. &lt;code&gt;baz()&lt;/code&gt; and &lt;code&gt;qux()&lt;/code&gt; will still need to be defined in our implementation of &lt;code&gt;Foo&lt;/code&gt;, but we can use &lt;code&gt;unimplemented!&lt;/code&gt; in their definitions to allow our code to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="translated">Queremos implementar &lt;code&gt;Foo&lt;/code&gt; en uno de nuestros tipos, pero tambi&amp;eacute;n queremos trabajar solo en &lt;code&gt;bar()&lt;/code&gt; primero. Para que nuestro c&amp;oacute;digo se compile, necesitamos implementar &lt;code&gt;baz()&lt;/code&gt; , para que podamos usar &lt;code&gt;todo!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="translated">Queremos implementar &lt;code&gt;Foo&lt;/code&gt; en uno de nuestros tipos, pero tambi&amp;eacute;n queremos trabajar solo en &lt;code&gt;bar()&lt;/code&gt; primero. Para que nuestro c&amp;oacute;digo se compile, necesitamos implementar &lt;code&gt;baz()&lt;/code&gt; , &amp;iexcl;as&amp;iacute; podemos usar &lt;code&gt;unimplemented!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="translated">Queremos crear una biblioteca de agregaci&amp;oacute;n de medios que pueda mostrar res&amp;uacute;menes de datos que podr&amp;iacute;an almacenarse en una instancia de &lt;code&gt;NewsArticle&lt;/code&gt; o &lt;code&gt;Tweet&lt;/code&gt; . Para hacer esto, necesitamos un resumen de cada tipo, y necesitamos solicitar ese resumen llamando a un m&amp;eacute;todo de &lt;code&gt;summarize&lt;/code&gt; en una instancia. El Listado 10-12 muestra la definici&amp;oacute;n de un rasgo de &lt;code&gt;Summary&lt;/code&gt; que expresa este comportamiento.</target>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="translated">Agradecemos las contribuciones de todo tipo.</target>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="translated">Tenderemos a utilizar la variable &quot;M&quot; para referirnos a una pareja,las variables &quot;t&quot; y &quot;u&quot; para fichas individuales arbitrarias,y las variables &quot;tt&quot; y &quot;uu&quot; para árboles de fichas arbitrarias.(El uso de &quot;tt&quot; presenta una potencial ambigüedad con su papel adicional como especificador de fragmentos;pero quedará claro a partir del contexto cuál es la interpretación que se pretende).</target>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="translated">No implementaremos una biblioteca GUI completa para este ejemplo, pero mostraremos c&amp;oacute;mo encajar&amp;iacute;an las piezas. En el momento de escribir la biblioteca, no podemos conocer y definir todos los tipos que otros programadores podr&amp;iacute;an querer crear. Pero sabemos que la &lt;code&gt;gui&lt;/code&gt; usuario necesita realizar un seguimiento de muchos valores de diferentes tipos y debe llamar a un m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; en cada uno de estos valores de tipos diferentes . No necesita saber exactamente qu&amp;eacute; suceder&amp;aacute; cuando llamemos al m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; , solo que el valor tendr&amp;aacute; ese m&amp;eacute;todo disponible para que lo llamemos.</target>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="translated">No veremos ninguna salida en la terminal, y &lt;em&gt;output.txt&lt;/em&gt; contendr&amp;aacute; nuestros resultados:</target>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="translated">Nos daría este error:</target>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="translated">Hemos terminado la lista &lt;code&gt;a&lt;/code&gt; en una &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; de modo que cuando creamos listas &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; , pueden ambos se refieren a &lt;code&gt;a&lt;/code&gt; , que es lo que hicimos en el listado 15-18.</target>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="translated">Tambi&amp;eacute;n presentaremos brevemente cierres, iteradores y objetos de rasgo, que los Cap&amp;iacute;tulos &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; y &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; cubrir&amp;aacute;n en detalle.</target>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="translated">Cambiaremos el inicio de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; que ten&amp;iacute;amos en el Listado 12-24 al c&amp;oacute;digo del Listado 13-25. Esto no se compilar&amp;aacute; hasta que actualicemos &lt;code&gt;Config::new&lt;/code&gt; tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="translated">Verificaremos errores y los manejaremos usando una t&amp;eacute;cnica similar a la que usamos con &lt;code&gt;Config::new&lt;/code&gt; en el Listado 12-10, pero con una ligera diferencia:</target>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;Volveremos al &lt;code&gt;panic!&lt;/code&gt; y cuando debemos y no debemos usar &lt;code&gt;panic!&lt;/code&gt; para manejar las condiciones de error en el programa &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; o &lt;code&gt;panic!&lt;/code&gt; no cunda el p&amp;aacute;nico! &amp;rdquo;M&amp;aacute;s&lt;/a&gt; adelante en este cap&amp;iacute;tulo. A continuaci&amp;oacute;n, veremos c&amp;oacute;mo recuperarnos de un error usando &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">Seguiremos recibiendo advertencias porque no estamos haciendo nada con los par&amp;aacute;metros para &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;execute&lt;/code&gt; . Implementemos los cuerpos de estas funciones con el comportamiento que queremos. Para empezar, pensemos en &lt;code&gt;new&lt;/code&gt; . Anteriormente, elegimos un tipo sin firmar para el par&amp;aacute;metro de &lt;code&gt;size&lt;/code&gt; , porque un grupo con un n&amp;uacute;mero negativo de subprocesos no tiene sentido. Sin embargo, una piscina con cero hilos tambi&amp;eacute;n no tiene sentido, sin embargo, es un cero perfectamente v&amp;aacute;lido &lt;code&gt;usize&lt;/code&gt; . &lt;code&gt;ThreadPool&lt;/code&gt; c&amp;oacute;digo para verificar que el &lt;code&gt;size&lt;/code&gt; sea ​​mayor que cero antes de devolver una instancia de ThreadPool y hacer que el programa entre en p&amp;aacute;nico si recibe un cero al usar el comando &lt;code&gt;assert!&lt;/code&gt; macro, como se muestra en el Listado 20-13.</target>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="translated">Crearemos una nueva estructura de &lt;code&gt;Job&lt;/code&gt; que contendr&amp;aacute; los cierres que queremos enviar por el canal.</target>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="translated">Vamos a crear la lista &lt;code&gt;a&lt;/code&gt; que contiene 5 y 10. A continuaci&amp;oacute;n, vamos a hacer dos listas m&amp;aacute;s: &lt;code&gt;b&lt;/code&gt; que comienza con 3 y &lt;code&gt;c&lt;/code&gt; que se inicia con 4. Tanto &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; listas a continuaci&amp;oacute;n, seguir&amp;aacute;n a la primera &lt;code&gt;a&lt;/code&gt; lista que contiene 5 y 10. En otras palabras, ambas listas compartir&amp;aacute;n la primera lista que contiene 5 y 10.</target>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="translated">Definiremos el m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; en &lt;code&gt;ThreadPool&lt;/code&gt; para tomar un cierre como par&amp;aacute;metro. Recuerde de la secci&amp;oacute;n &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&quot;Almacenamiento de cierres usando par&amp;aacute;metros gen&amp;eacute;ricos y los rasgos &lt;code&gt;Fn&lt;/code&gt; &quot;&lt;/a&gt; del Cap&amp;iacute;tulo 13 que podemos tomar cierres como par&amp;aacute;metros con tres rasgos diferentes: &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; y &lt;code&gt;FnOnce&lt;/code&gt; . Necesitamos decidir qu&amp;eacute; tipo de cierre usar aqu&amp;iacute;. Sabemos que terminaremos haciendo algo similar a la implementaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar &lt;code&gt;thread::spawn&lt;/code&gt; , por lo que podemos ver qu&amp;eacute; l&amp;iacute;mites tiene la firma de &lt;code&gt;thread::spawn&lt;/code&gt; en su par&amp;aacute;metro. La documentaci&amp;oacute;n nos muestra lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="translated">Demostraremos la primera situaci&amp;oacute;n en la secci&amp;oacute;n &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&quot;Habilitaci&amp;oacute;n de tipos recursivos con cuadros&quot;&lt;/a&gt; . En el segundo caso, transferir la propiedad de una gran cantidad de datos puede llevar mucho tiempo porque los datos se copian en la pila. Para mejorar el rendimiento en esta situaci&amp;oacute;n, podemos almacenar la gran cantidad de datos en el mont&amp;oacute;n en una caja. Luego, solo la peque&amp;ntilde;a cantidad de datos de puntero se copia en la pila, mientras que los datos a los que hace referencia permanecen en un lugar en el mont&amp;oacute;n. El tercer caso se conoce como &lt;em&gt;objeto de rasgo&lt;/em&gt; , y el Cap&amp;iacute;tulo 17 dedica una secci&amp;oacute;n completa, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&quot;Uso de objetos de rasgo que permiten valores de diferentes tipos&quot;,&lt;/a&gt; solo a ese tema. &amp;iexcl;As&amp;iacute; que lo que aprenda aqu&amp;iacute; lo aplicar&amp;aacute; nuevamente en el Cap&amp;iacute;tulo 17!</target>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="translated">Discutiremos c&amp;oacute;mo crear y actualizar vectores, cadenas y mapas hash, as&amp;iacute; como qu&amp;eacute; hace que cada uno sea especial.</target>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="translated">Analizaremos los iteradores con m&amp;aacute;s detalle en el Cap&amp;iacute;tulo 13. Por ahora, sepa que &lt;code&gt;iter&lt;/code&gt; es un m&amp;eacute;todo que devuelve cada elemento de una colecci&amp;oacute;n y que &lt;code&gt;enumerate&lt;/code&gt; envuelve el resultado de &lt;code&gt;iter&lt;/code&gt; y devuelve cada elemento como parte de una tupla. El primer elemento de la tupla devuelto por &lt;code&gt;enumerate&lt;/code&gt; es el &amp;iacute;ndice y el segundo elemento es una referencia al elemento. Esto es un poco m&amp;aacute;s conveniente que calcular el &amp;iacute;ndice nosotros mismos.</target>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="translated">Exploraremos algunos aspectos de c&amp;oacute;mo funcionan las pruebas experimentando con la prueba de plantilla generada para nosotros sin realmente probar ning&amp;uacute;n c&amp;oacute;digo. Luego escribiremos algunas pruebas del mundo real que llamen a alg&amp;uacute;n c&amp;oacute;digo que hemos escrito y afirmen que su comportamiento es correcto.</target>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="translated">Vamos a extraer la funcionalidad para analizar argumentos a una funci&amp;oacute;n que &lt;code&gt;main&lt;/code&gt; llamada voluntad de prepararse para mover la l&amp;iacute;nea de comandos de an&amp;aacute;lisis de la l&amp;oacute;gica de &lt;em&gt;src / lib.rs&lt;/em&gt; . El Listado 12-5 muestra el nuevo inicio de &lt;code&gt;main&lt;/code&gt; que llama a una nueva funci&amp;oacute;n &lt;code&gt;parse_config&lt;/code&gt; , que definiremos en &lt;em&gt;src / main.rs&lt;/em&gt; por el momento.</target>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="translated">Primero definiremos lo que queremos decir con el t&amp;eacute;rmino &lt;em&gt;cadena&lt;/em&gt; . Rust solo tiene un tipo de cadena en el lenguaje principal, que es la secci&amp;oacute;n de cadena &lt;code&gt;str&lt;/code&gt; que generalmente se ve en su forma prestada &lt;code&gt;&amp;amp;str&lt;/code&gt; . En el Cap&amp;iacute;tulo 4, hablamos sobre &lt;em&gt;los cortes de cadena&lt;/em&gt; , que son referencias a algunos datos de cadena codificados en UTF-8 almacenados en otro lugar. Los literales de cadena, por ejemplo, se almacenan en el binario del programa y, por lo tanto, son segmentos de cadena.</target>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="translated">Obtendremos este error porque &lt;code&gt;String&lt;/code&gt; no implementa el rasgo &lt;code&gt;Draw&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="translated">Repasaremos la API b&amp;aacute;sica de mapas hash en esta secci&amp;oacute;n, pero muchas m&amp;aacute;s ventajas se esconden en las funciones definidas en &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; por la biblioteca est&amp;aacute;ndar. Como siempre, consulte la documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="translated">Tendremos m&amp;aacute;s ejemplos de cierres de &lt;code&gt;move&lt;/code&gt; en el Cap&amp;iacute;tulo 16 cuando hablemos de concurrencia. Por ahora, aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo del Listado 13-12 con la palabra clave &lt;code&gt;move&lt;/code&gt; agregada a la definici&amp;oacute;n de cierre y usando vectores en lugar de enteros, porque los enteros se pueden copiar en lugar de mover; tenga en cuenta que este c&amp;oacute;digo a&amp;uacute;n no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="translated">Implementaremos un flujo de trabajo de publicaci&amp;oacute;n de blog de manera incremental. La funcionalidad final del blog se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="translated">Implementaremos un problema cl&amp;aacute;sico de programaci&amp;oacute;n para principiantes: un juego de adivinanzas. As&amp;iacute; es como funciona: el programa generar&amp;aacute; un n&amp;uacute;mero entero aleatorio entre 1 y 100. Luego le pedir&amp;aacute; al jugador que ingrese una suposici&amp;oacute;n. Despu&amp;eacute;s de ingresar una conjetura, el programa indicar&amp;aacute; si la conjetura es demasiado baja o demasiado alta. Si la suposici&amp;oacute;n es correcta, el juego imprimir&amp;aacute; un mensaje de felicitaci&amp;oacute;n y saldr&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="translated">Implementaremos este comportamiento introduciendo una nueva estructura de datos entre &lt;code&gt;ThreadPool&lt;/code&gt; y los subprocesos que administrar&amp;aacute;n este nuevo comportamiento. A esta estructura de datos la llamaremos &lt;code&gt;Worker&lt;/code&gt; , que es un t&amp;eacute;rmino com&amp;uacute;n en las implementaciones de agrupaci&amp;oacute;n. Piense en las personas que trabajan en la cocina de un restaurante: los trabajadores esperan hasta que lleguen los pedidos de los clientes y luego son responsables de tomar esos pedidos y surtirlos.</target>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="translated">Mejoraremos &lt;code&gt;minigrep&lt;/code&gt; agregando una caracter&amp;iacute;stica adicional: una opci&amp;oacute;n para la b&amp;uacute;squeda que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas que el usuario puede activar mediante una variable de entorno. Podr&amp;iacute;amos hacer de esta funci&amp;oacute;n una opci&amp;oacute;n de l&amp;iacute;nea de comando y requerir que los usuarios la ingresen cada vez que quieran que se aplique, pero en su lugar usaremos una variable de entorno. Hacerlo permite a nuestros usuarios configurar la variable de entorno una vez y hacer que todas sus b&amp;uacute;squedas no distingan entre may&amp;uacute;sculas y min&amp;uacute;sculas en esa sesi&amp;oacute;n de terminal.</target>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="translated">Dejaremos el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; en &lt;code&gt;Post&lt;/code&gt; como est&amp;aacute;, devolviendo un segmento de cadena vac&amp;iacute;o. Ahora podemos tener una &lt;code&gt;Post&lt;/code&gt; en el estado &lt;code&gt;PendingReview&lt;/code&gt; as&amp;iacute; como en el estado &lt;code&gt;Draft&lt;/code&gt; , pero queremos el mismo comportamiento en el estado &lt;code&gt;PendingReview&lt;/code&gt; . &amp;iexcl;El listado 17-11 ahora funciona hasta la l&amp;iacute;nea 10!</target>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="translated">Limitaremos la cantidad de subprocesos en el grupo a una peque&amp;ntilde;a cantidad para protegernos de los ataques de denegaci&amp;oacute;n de servicio (DoS); Si hici&amp;eacute;ramos que nuestro programa creara un nuevo hilo para cada solicitud a medida que ingresa, alguien que haga 10 millones de solicitudes a nuestro servidor podr&amp;iacute;a crear un caos al usar todos los recursos de nuestro servidor y detener el procesamiento de solicitudes.</target>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="translated">Veremos c&amp;oacute;mo una solicitud de procesamiento lento puede afectar otras solicitudes realizadas a nuestra implementaci&amp;oacute;n de servidor actual. El listado 20-10 implementa el manejo de una solicitud para &lt;em&gt;/ dormir&lt;/em&gt; con una respuesta lenta simulada que har&amp;aacute; que el servidor se suspenda durante 5 segundos antes de responder.</target>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Recibiremos un error porque el valor de &lt;code&gt;s&lt;/code&gt; a&amp;uacute;n se mover&amp;aacute; a &lt;code&gt;_s&lt;/code&gt; , lo que nos impide usar &lt;code&gt;s&lt;/code&gt; nuevamente. Sin embargo, el uso del gui&amp;oacute;n bajo por s&amp;iacute; solo nunca se vincula al valor. El listado 18-22 se compilar&amp;aacute; sin errores porque &lt;code&gt;s&lt;/code&gt; no se mueve a &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="translated">Completaremos este cap&amp;iacute;tulo hablando sobre los rasgos de &lt;code&gt;Send&lt;/code&gt; y &lt;code&gt;Sync&lt;/code&gt; y c&amp;oacute;mo podemos usarlos con tipos personalizados.</target>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="translated">Le mostraremos c&amp;oacute;mo repensar el patr&amp;oacute;n estatal para obtener un conjunto diferente de compensaciones. En lugar de encapsular los estados y las transiciones por completo para que el c&amp;oacute;digo externo no los conozca, codificaremos los estados en diferentes tipos. En consecuencia, el sistema de verificaci&amp;oacute;n de tipos de Rust evitar&amp;aacute; los intentos de utilizar borradores de publicaciones donde solo se permiten publicaciones publicadas mediante la emisi&amp;oacute;n de un error de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="translated">Simularemos la llamada a este algoritmo hipot&amp;eacute;tico con la funci&amp;oacute;n &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; que se muestra en el Listado 13-1, que se imprimir&amp;aacute; &lt;code&gt;calculating slowly...&lt;/code&gt; , esperar&amp;aacute; dos segundos y luego devolver&amp;aacute; el n&amp;uacute;mero que ingresamos.</target>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="translated">Comenzaremos haciendo funcionar un servidor web de un solo subproceso. Antes de comenzar, veamos una descripci&amp;oacute;n general r&amp;aacute;pida de los protocolos involucrados en la construcci&amp;oacute;n de servidores web. Los detalles de estos protocolos est&amp;aacute;n m&amp;aacute;s all&amp;aacute; del alcance de este libro, pero una breve descripci&amp;oacute;n general le proporcionar&amp;aacute; la informaci&amp;oacute;n que necesita.</target>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="translated">Hablaremos de cada uno de estos a su vez, pero primero, veamos por qu&amp;eacute; incluso necesitamos macros cuando ya tenemos funciones.</target>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="translated">Probaremos la implementaci&amp;oacute;n de la funcionalidad que realmente buscar&amp;aacute; la cadena de consulta en el contenido del archivo y producir&amp;aacute; una lista de l&amp;iacute;neas que coincidan con la consulta. Agregaremos esta funcionalidad en una funci&amp;oacute;n llamada &lt;code&gt;search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">Usaremos &lt;code&gt;String&lt;/code&gt; como ejemplo aqu&amp;iacute; y nos concentraremos en las partes de &lt;code&gt;String&lt;/code&gt; que se relacionan con la propiedad. Estos aspectos tambi&amp;eacute;n se aplican a otros tipos de datos complejos proporcionados por la biblioteca est&amp;aacute;ndar y que usted crea. Hablaremos de &lt;code&gt;String&lt;/code&gt; con m&amp;aacute;s profundidad en el Cap&amp;iacute;tulo 8.</target>
        </trans-unit>
        <trans-unit id="5f26df7e74655da28655e14a9fc6315701535f09" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="translated">Usaremos el c&amp;oacute;digo del Listado 12-24 para cambiar la forma en que se imprimen los mensajes de error. Debido a la refactorizaci&amp;oacute;n que hicimos anteriormente en este cap&amp;iacute;tulo, todo el c&amp;oacute;digo que imprime mensajes de error est&amp;aacute; en una funci&amp;oacute;n, &lt;code&gt;main&lt;/code&gt; . La biblioteca est&amp;aacute;ndar proporciona &lt;code&gt;eprintln!&lt;/code&gt; macro que se imprime en el flujo de error est&amp;aacute;ndar, &amp;iexcl;as&amp;iacute; que cambiemos los dos lugares a los que llamamos &lt;code&gt;println!&lt;/code&gt; para imprimir errores para usar &lt;code&gt;eprintln!&lt;/code&gt; en lugar.</target>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="translated">Se nos permite cambiar el valor al que se une &lt;code&gt;x&lt;/code&gt; de &lt;code&gt;5&lt;/code&gt; a &lt;code&gt;6&lt;/code&gt; cuando se usa &lt;code&gt;mut&lt;/code&gt; . En algunos casos, querr&amp;aacute; hacer que una variable sea mutable porque hace que el c&amp;oacute;digo sea m&amp;aacute;s conveniente de escribir que si solo tuviera variables inmutables.</target>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="translated">Estamos creando una instancia de &lt;code&gt;IpAddr&lt;/code&gt; analizando una cadena codificada. Podemos ver que &lt;code&gt;127.0.0.1&lt;/code&gt; es una direcci&amp;oacute;n IP v&amp;aacute;lida, por lo que es aceptable usar &lt;code&gt;unwrap&lt;/code&gt; aqu&amp;iacute;. Sin embargo, tener una cadena v&amp;aacute;lida codificada no cambia el tipo de retorno del m&amp;eacute;todo de &lt;code&gt;parse&lt;/code&gt; : a&amp;uacute;n obtenemos un valor de &lt;code&gt;Result&lt;/code&gt; ado , y el compilador a&amp;uacute;n nos har&amp;aacute; manejar el &lt;code&gt;Result&lt;/code&gt; ado como si la variante &lt;code&gt;Err&lt;/code&gt; fuera una posibilidad porque el compilador no es ' t lo suficientemente inteligente como para ver que esta cadena es siempre una direcci&amp;oacute;n IP v&amp;aacute;lida. Si la cadena de direcci&amp;oacute;n IP proviene de un usuario en lugar de estar codificada en el programa y, por &lt;em&gt;lo&lt;/em&gt; tanto &lt;em&gt;,&lt;/em&gt; tiene la posibilidad de fallar, definitivamente querr&amp;iacute;amos manejar la &lt;code&gt;Result&lt;/code&gt; de una manera m&amp;aacute;s s&amp;oacute;lida.</target>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="translated">Estamos entrando en programas m&amp;aacute;s complejos en los que las operaciones pueden fallar, por lo que es el momento perfecto para discutir el manejo de errores. &amp;iexcl;Lo haremos a continuaci&amp;oacute;n!</target>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="translated">A&amp;uacute;n no hemos terminado con esta l&amp;iacute;nea de c&amp;oacute;digo. Aunque lo que hemos discutido hasta ahora es una sola l&amp;iacute;nea de texto, es solo la primera parte de la &amp;uacute;nica l&amp;iacute;nea l&amp;oacute;gica de c&amp;oacute;digo. La segunda parte es este m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="translated">Ahora estamos iterando sobre los trabajadores dos veces: una vez para enviar un mensaje &lt;code&gt;Terminate&lt;/code&gt; para cada trabajador y una vez para llamar a &lt;code&gt;join&lt;/code&gt; en el hilo de cada trabajador. Si intent&amp;aacute;ramos enviar un mensaje y &lt;code&gt;join&lt;/code&gt; inmediatamente en el mismo bucle, no podr&amp;iacute;amos garantizar que el trabajador en la iteraci&amp;oacute;n actual ser&amp;iacute;a el que recibir&amp;iacute;a el mensaje del canal.</target>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="translated">Le proporcionamos a Rust una anotaci&amp;oacute;n de tipo dentro de los corchetes angulares, lo que indica que queremos llamar al m&amp;eacute;todo &lt;code&gt;baby_name&lt;/code&gt; desde el rasgo &lt;code&gt;Animal&lt;/code&gt; tal como se implement&amp;oacute; en &lt;code&gt;Dog&lt;/code&gt; , diciendo que queremos tratar el tipo &lt;code&gt;Dog&lt;/code&gt; como un &lt;code&gt;Animal&lt;/code&gt; para esta llamada de funci&amp;oacute;n. Este c&amp;oacute;digo imprimir&amp;aacute; ahora lo que queremos:</target>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">Ahora solo recibimos advertencias, lo que significa que se compila. Pero tenga en cuenta que si prueba &lt;code&gt;cargo run&lt;/code&gt; y realiza una solicitud en el navegador, ver&amp;aacute; los errores en el navegador que vimos al principio del cap&amp;iacute;tulo. &amp;iexcl;Nuestra biblioteca a&amp;uacute;n no est&amp;aacute; llamando al cierre aprobado para &lt;code&gt;execute&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="translated">Todav&amp;iacute;a estamos recopilando los argumentos de la l&amp;iacute;nea de comando en un vector, pero en lugar de asignar el valor del argumento en el &amp;iacute;ndice 1 a la &lt;code&gt;query&lt;/code&gt; la variable y el valor del argumento en el &amp;iacute;ndice 2 al &lt;code&gt;filename&lt;/code&gt; la variable dentro de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; , pasamos el vector completo a la funci&amp;oacute;n &lt;code&gt;parse_config&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;parse_config&lt;/code&gt; entonces contiene la l&amp;oacute;gica que determina qu&amp;eacute; argumento va en qu&amp;eacute; variable y pasa los valores de nuevo a &lt;code&gt;main&lt;/code&gt; . Seguimos creando las variables de &lt;code&gt;query&lt;/code&gt; y &lt;code&gt;filename&lt;/code&gt; en &lt;code&gt;main&lt;/code&gt; , pero &lt;code&gt;main&lt;/code&gt; ya no tiene la responsabilidad de determinar c&amp;oacute;mo se corresponden los argumentos y las variables de la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="translated">Todav&amp;iacute;a estamos usando un bucle &lt;code&gt;for&lt;/code&gt; para devolver cada l&amp;iacute;nea de la &lt;code&gt;search&lt;/code&gt; e imprimirla.</target>
        </trans-unit>
        <trans-unit id="704d6708be51c898fd0ee7c005925dabd11417ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still working on this line of code. Although we&amp;rsquo;re now discussing a third line of text, it&amp;rsquo;s still part of a single logical line of code. The next part is this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="translated">Estamos utilizando otra variante de la &lt;code&gt;List&lt;/code&gt; definici&amp;oacute;n del listado 15-5. El segundo elemento en la variante &lt;code&gt;Cons&lt;/code&gt; es ahora &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; , lo que significa que en lugar de tener la capacidad de modificar el valor &lt;code&gt;i32&lt;/code&gt; como hicimos en el Listado 15-24, queremos modificar a qu&amp;eacute; valor &lt;code&gt;List&lt;/code&gt; apunta una variante &lt;code&gt;Cons&lt;/code&gt; a. Tambi&amp;eacute;n estamos agregando un m&amp;eacute;todo de &lt;code&gt;tail&lt;/code&gt; para que sea conveniente para nosotros acceder al segundo elemento si tenemos una variante de &lt;code&gt;Cons&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Estamos usando el m&amp;eacute;todo &lt;code&gt;is_err&lt;/code&gt; en el &lt;code&gt;Result&lt;/code&gt; para verificar si es un error y, por lo tanto, no est&amp;aacute; configurado, lo que significa que &lt;em&gt;debe&lt;/em&gt; hacer una b&amp;uacute;squeda sensible a may&amp;uacute;sculas y min&amp;uacute;sculas. Si la variable de entorno &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; se establece en cualquier valor, &lt;code&gt;is_err&lt;/code&gt; devolver&amp;aacute; falso y el programa realizar&amp;aacute; una b&amp;uacute;squeda que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas. No nos importa el &lt;em&gt;valor&lt;/em&gt; de la variable de entorno, solo si est&amp;aacute; configurada o no, por lo que estamos verificando &lt;code&gt;is_err&lt;/code&gt; en lugar de usar &lt;code&gt;unwrap&lt;/code&gt; , &lt;code&gt;expect&lt;/code&gt; o cualquiera de los otros m&amp;eacute;todos que hemos visto en &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="translated">De hecho, ya hemos utilizado declaraciones y expresiones. &lt;em&gt;Las declaraciones&lt;/em&gt; son instrucciones que realizan alguna acci&amp;oacute;n y no devuelven un valor. &lt;em&gt;Las expresiones se&lt;/em&gt; eval&amp;uacute;an a un valor resultante. Veamos algunos ejemplos.</target>
        </trans-unit>
        <trans-unit id="d8fc6748175101658632d95f9debdd96c25d44d2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each file in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">Hemos agregado &lt;code&gt;use adder&lt;/code&gt; en la parte superior del c&amp;oacute;digo, que no necesitamos en las pruebas unitarias. La raz&amp;oacute;n es que cada prueba en el directorio de &lt;code&gt;tests&lt;/code&gt; es una caja separada, por lo que necesitamos llevar nuestra biblioteca al alcance de cada caja de prueba.</target>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="translated">Hemos agregado una l&amp;iacute;nea en la parte superior para llevar el m&amp;oacute;dulo del sistema de archivos de la biblioteca est&amp;aacute;ndar al alcance. El c&amp;oacute;digo para leer el contenido de un archivo en una cadena deber&amp;iacute;a resultar familiar; lo usamos en el Cap&amp;iacute;tulo 12 cuando le&amp;iacute;mos el contenido de un archivo para nuestro proyecto de E / S en el Listado 12-4.</target>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="translated">Hemos agregado una nueva l&amp;iacute;nea de &lt;code&gt;use&lt;/code&gt; para llevar el &lt;code&gt;process&lt;/code&gt; de la biblioteca est&amp;aacute;ndar al alcance. El c&amp;oacute;digo en el cierre que se ejecutar&amp;aacute; en el caso de error es solo de dos l&amp;iacute;neas: imprimimos el valor de &lt;code&gt;err&lt;/code&gt; or y luego llamamos a &lt;code&gt;process::exit&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;process::exit&lt;/code&gt; detendr&amp;aacute; el programa inmediatamente y devolver&amp;aacute; el n&amp;uacute;mero que se pas&amp;oacute; como c&amp;oacute;digo de estado de salida. &amp;iexcl;Esto es similar al &lt;code&gt;panic!&lt;/code&gt; -basado en el manejo que usamos en el Listado 12-8, pero ya no obtenemos toda la salida adicional. Vamos a intentarlo:</target>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Hemos agregado una estructura llamada &lt;code&gt;Config&lt;/code&gt; definida para tener campos llamados &lt;code&gt;query&lt;/code&gt; y &lt;code&gt;filename&lt;/code&gt; . La firma de &lt;code&gt;parse_config&lt;/code&gt; ahora indica que devuelve un valor de &lt;code&gt;Config&lt;/code&gt; . En el cuerpo de &lt;code&gt;parse_config&lt;/code&gt; , donde sol&amp;iacute;amos devolver segmentos de cadena que hacen referencia a valores de &lt;code&gt;String&lt;/code&gt; en &lt;code&gt;args&lt;/code&gt; , ahora definimos &lt;code&gt;Config&lt;/code&gt; para contener valores de &lt;code&gt;String&lt;/code&gt; propios. La variable &lt;code&gt;args&lt;/code&gt; en &lt;code&gt;main&lt;/code&gt; es la propietaria de los valores del argumento y solo permite que la funci&amp;oacute;n &lt;code&gt;parse_config&lt;/code&gt; los tome prestados, lo que significa que violar&amp;iacute;amos las reglas de pr&amp;eacute;stamo de Rust si &lt;code&gt;Config&lt;/code&gt; intent&amp;oacute; tomar posesi&amp;oacute;n de los valores en &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="translated">Hemos agregado algo de documentaci&amp;oacute;n para nuestro &lt;code&gt;ThreadPool&lt;/code&gt; con comentarios de documentos. Tenga en cuenta que seguimos las buenas pr&amp;aacute;cticas de documentaci&amp;oacute;n agregando una secci&amp;oacute;n que menciona las situaciones en las que nuestra funci&amp;oacute;n puede entrar en p&amp;aacute;nico, como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 14. Intente ejecutar &lt;code&gt;cargo doc --open&lt;/code&gt; y haga clic en la estructura &lt;code&gt;ThreadPool&lt;/code&gt; para ver cu&amp;aacute;les son los documentos generados para una &lt;code&gt;new&lt;/code&gt; apariencia &amp;iexcl;me gusta!</target>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="translated">Hemos agregado el m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; al rasgo de &lt;code&gt;State&lt;/code&gt; ; todos los tipos que implementan el rasgo ahora necesitar&amp;aacute;n implementar el m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; . Tenga en cuenta que en lugar de tener &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self&lt;/code&gt; como el primer par&amp;aacute;metro del m&amp;eacute;todo, tenemos &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; . Esta sintaxis significa que el m&amp;eacute;todo solo es v&amp;aacute;lido cuando se llama en un &lt;code&gt;Box&lt;/code&gt; que contiene el tipo. Esta sintaxis toma posesi&amp;oacute;n de &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; , invalidando el estado anterior para que el valor de estado de la &lt;code&gt;Post&lt;/code&gt; pueda transformarse en un nuevo estado.</target>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="translated">Ya hemos encontrado algunos punteros inteligentes en este libro, como &lt;code&gt;String&lt;/code&gt; y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; en el Cap&amp;iacute;tulo 8, aunque no los llamamos punteros inteligentes en ese momento. Ambos tipos cuentan como punteros inteligentes porque poseen algo de memoria y le permiten manipularla. Tambi&amp;eacute;n tienen metadatos (como su capacidad) y capacidades o garant&amp;iacute;as adicionales (como con &lt;code&gt;String&lt;/code&gt; que garantiza que sus datos siempre ser&amp;aacute;n UTF-8 v&amp;aacute;lidos).</target>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="translated">Ya hemos visto literales de cadena, donde un valor de cadena est&amp;aacute; codificado en nuestro programa. Los literales de cadena son convenientes, pero no son adecuados para todas las situaciones en las que deseemos usar texto. Una raz&amp;oacute;n es que son inmutables. Otra es que no se pueden conocer todos los valores de cadena cuando escribimos nuestro c&amp;oacute;digo: por ejemplo, &amp;iquest;qu&amp;eacute; pasa si queremos tomar la entrada del usuario y almacenarla? Para estas situaciones, Rust tiene un segundo tipo de cadena, &lt;code&gt;String&lt;/code&gt; . Este tipo se asigna en el mont&amp;oacute;n y, como tal, puede almacenar una cantidad de texto que desconocemos en el momento de la compilaci&amp;oacute;n. Puede crear una &lt;code&gt;String&lt;/code&gt; partir de una cadena literal usando la funci&amp;oacute;n &lt;code&gt;from&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">Hemos tra&amp;iacute;do &lt;code&gt;std::thread&lt;/code&gt; al alcance en la caja de la biblioteca, porque estamos usando &lt;code&gt;thread::JoinHandle&lt;/code&gt; como el tipo de elementos en el vector en &lt;code&gt;ThreadPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">Hemos cambiado el nombre del campo en &lt;code&gt;ThreadPool&lt;/code&gt; de &lt;code&gt;threads&lt;/code&gt; a &lt;code&gt;workers&lt;/code&gt; porque ahora contiene instancias de &lt;code&gt;Worker&lt;/code&gt; lugar de instancias de &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; . Usamos el contador en el bucle &lt;code&gt;for&lt;/code&gt; como argumento para &lt;code&gt;Worker::new&lt;/code&gt; , y almacenamos cada &lt;code&gt;Worker&lt;/code&gt; nuevo en el vector llamado &lt;code&gt;workers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="translated">Hemos elegido &lt;code&gt;&amp;amp;self&lt;/code&gt; aqu&amp;iacute; por la misma raz&amp;oacute;n que usamos &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; en la versi&amp;oacute;n de la funci&amp;oacute;n: no queremos tomar posesi&amp;oacute;n, y solo queremos leer los datos en la estructura, no escribir en ellos. Si quisi&amp;eacute;ramos cambiar la instancia en la que hemos llamado al m&amp;eacute;todo como parte de lo que hace el m&amp;eacute;todo, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; como primer par&amp;aacute;metro. Es raro tener un m&amp;eacute;todo que se apropie de la instancia utilizando solo &lt;code&gt;self&lt;/code&gt; como primer par&amp;aacute;metro; esta t&amp;eacute;cnica se usa generalmente cuando el m&amp;eacute;todo se transforma a &lt;code&gt;self&lt;/code&gt; en otra cosa y desea evitar que la persona que llama use la instancia original despu&amp;eacute;s de la transformaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="translated">Hemos creado punteros sin procesar utilizando &lt;code&gt;as&lt;/code&gt; para convertir una referencia inmutable y mutable en sus correspondientes tipos de punteros sin procesar. Debido a que los creamos directamente a partir de referencias que se garantiza que son v&amp;aacute;lidas, sabemos que estos punteros en bruto en particular son v&amp;aacute;lidos, pero no podemos hacer esa suposici&amp;oacute;n sobre cualquier puntero en bruto.</target>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="translated">Hemos definido una macro que puede tomar cualquier n&amp;uacute;mero de argumentos de cualquier tipo y puede generar c&amp;oacute;digo para crear un vector que contenga los elementos especificados.</target>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="translated">En este cap&amp;iacute;tulo, describimos la mayor&amp;iacute;a de las funciones avanzadas como pocas veces necesarias. Los tipos asociados se encuentran en alg&amp;uacute;n punto intermedio: se usan con menos frecuencia que las caracter&amp;iacute;sticas explicadas en el resto del libro, pero con m&amp;aacute;s frecuencia que muchas de las otras caracter&amp;iacute;sticas discutidas en este cap&amp;iacute;tulo.</target>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="translated">Hemos desestructurado enumeraciones anteriormente en este libro, por ejemplo, cuando desestructuramos la &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; en el Listado 6-5 en el Cap&amp;iacute;tulo 6. Un detalle que no hemos mencionado expl&amp;iacute;citamente es que el patr&amp;oacute;n para desestructurar una enumeraci&amp;oacute;n debe corresponder a la forma los datos almacenados dentro de la enumeraci&amp;oacute;n est&amp;aacute;n definidos. Como ejemplo, en el Listado 18-15 usamos la enumeraci&amp;oacute;n de &lt;code&gt;Message&lt;/code&gt; del Listado 6-2 y escribimos una &lt;code&gt;match&lt;/code&gt; con patrones que desestructurar&amp;aacute;n cada valor interno.</target>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="translated">&amp;iexcl;Le hemos dado el c&amp;oacute;digo! Este c&amp;oacute;digo es perfectamente v&amp;aacute;lido, aunque significa que no podemos usar un patr&amp;oacute;n irrefutable sin recibir un error. Si damos &lt;code&gt;if let&lt;/code&gt; un patr&amp;oacute;n que siempre coincidir&amp;aacute;, como &lt;code&gt;x&lt;/code&gt; , como se muestra en el Listado 18-10, no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="78dee02791985c19ffc271569fd60c5a8fc8dade" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, the compiler will give a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="translated">Hemos codificado la variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; como 10 y la variable &lt;code&gt;simulated_random_number&lt;/code&gt; como 7 por simplicidad; en un programa real, obtendr&amp;iacute;amos el n&amp;uacute;mero de intensidad de la interfaz de la aplicaci&amp;oacute;n, y &lt;code&gt;rand&lt;/code&gt; caja rand para generar un n&amp;uacute;mero aleatorio, como hicimos en el ejemplo del Juego de adivinanzas en el Cap&amp;iacute;tulo 2. La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; llama a la funci&amp;oacute;n &lt;code&gt;generate_workout&lt;/code&gt; con los valores de entrada simulados.</target>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="translated">Hemos introducido tres cajas nuevas: &lt;code&gt;proc_macro&lt;/code&gt; , &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt; . La caja &lt;code&gt;proc_macro&lt;/code&gt; viene con Rust, por lo que no necesitamos agregar eso a las dependencias en &lt;em&gt;Cargo.toml&lt;/em&gt; . La caja &lt;code&gt;proc_macro&lt;/code&gt; es la API del compilador que nos permite leer y manipular el c&amp;oacute;digo Rust de nuestro c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="translated">Hemos hecho un uso liberal de la palabra clave &lt;code&gt;pub&lt;/code&gt; : en &lt;code&gt;Config&lt;/code&gt; , en sus campos y su &lt;code&gt;new&lt;/code&gt; m&amp;eacute;todo, y en la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; . &amp;iexcl;Ahora tenemos una caja de biblioteca que tiene una API p&amp;uacute;blica que podemos probar!</target>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="translated">Hemos realizado algunos cambios peque&amp;ntilde;os y sencillos: pasamos el extremo receptor del canal a &lt;code&gt;Worker::new&lt;/code&gt; y luego lo usamos dentro del cierre.</target>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="translated">Hemos realizado tres cambios importantes aqu&amp;iacute;. Primero, cambiamos el tipo de retorno de la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; a &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt; . Esta funci&amp;oacute;n devolvi&amp;oacute; previamente el tipo de unidad, &lt;code&gt;()&lt;/code&gt; , y lo mantenemos como el valor devuelto en el caso &lt;code&gt;Ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="translated">Hemos realizado dos cambios en el cuerpo de la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n: &amp;iexcl;en lugar de llamar al &lt;code&gt;panic!&lt;/code&gt; cuando el usuario no pasa suficientes argumentos, ahora devolvemos un valor &lt;code&gt;Err&lt;/code&gt; , y hemos envuelto el valor de retorno de &lt;code&gt;Config&lt;/code&gt; en un &lt;code&gt;Ok&lt;/code&gt; . Estos cambios hacen que la funci&amp;oacute;n se ajuste a su nueva firma de tipo.</target>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="translated">Hemos mencionado que en Rust, nos abstenemos de llamar a estructuras y enumeraciones &quot;objetos&quot; para distinguirlos de los objetos de otros lenguajes. En una estructura o enumeraci&amp;oacute;n, los datos en los campos de estructura y el comportamiento en los bloques &lt;code&gt;impl&lt;/code&gt; est&amp;aacute;n separados, mientras que en otros lenguajes, los datos y el comportamiento combinados en un concepto a menudo se etiquetan como un objeto. Sin embargo, los objetos de rasgo se &lt;em&gt;parecen&lt;/em&gt; m&amp;aacute;s a los objetos de otros lenguajes en el sentido de que combinan datos y comportamiento. Pero los objetos de rasgo se diferencian de los objetos tradicionales en que no podemos agregar datos a un objeto de rasgo. Los objetos de rasgo no son tan &amp;uacute;tiles en general como los objetos en otros lenguajes: su prop&amp;oacute;sito espec&amp;iacute;fico es permitir la abstracci&amp;oacute;n a trav&amp;eacute;s del comportamiento com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="translated">Hemos movido la creaci&amp;oacute;n de la nueva &lt;code&gt;String&lt;/code&gt; en &lt;code&gt;s&lt;/code&gt; al comienzo de la funci&amp;oacute;n; esa parte no ha cambiado. En lugar de crear una variable &lt;code&gt;f&lt;/code&gt; , hemos encadenado la llamada a &lt;code&gt;read_to_string&lt;/code&gt; directamente al resultado de &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt; . Todav&amp;iacute;a tenemos un &lt;code&gt;?&lt;/code&gt; al final de la llamada &lt;code&gt;read_to_string&lt;/code&gt; , y todav&amp;iacute;a devolvemos un valor &lt;code&gt;Ok&lt;/code&gt; que contiene el nombre de usuario en &lt;code&gt;s&lt;/code&gt; cuando tanto &lt;code&gt;File::open&lt;/code&gt; como &lt;code&gt;read_to_string&lt;/code&gt; tienen &amp;eacute;xito en lugar de devolver errores. La funcionalidad es nuevamente la misma que en el Listado 9-6 y el Listado 9-7; esta es solo una forma diferente y m&amp;aacute;s ergon&amp;oacute;mica de escribirlo.</target>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="translated">Hemos llamado a nuestra prueba &lt;code&gt;larger_can_hold_smaller&lt;/code&gt; y hemos creado las dos instancias de &lt;code&gt;Rectangle&lt;/code&gt; que necesitamos. &amp;iexcl;Entonces llamamos a la &lt;code&gt;assert!&lt;/code&gt; macro y le pas&amp;oacute; el resultado de llamar a &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt; . Se supone que esta expresi&amp;oacute;n devuelve &lt;code&gt;true&lt;/code&gt; , por lo que nuestra prueba deber&amp;iacute;a pasar. &amp;iexcl;Vamos a averiguar!</target>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="translated">Ahora hemos cubierto c&amp;oacute;mo usar enumeraciones para crear tipos personalizados que pueden ser uno de un conjunto de valores enumerados. Hemos mostrado c&amp;oacute;mo el tipo &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; la biblioteca est&amp;aacute;ndar le ayuda a utilizar el sistema de tipos para evitar errores. Cuando los valores de enumeraci&amp;oacute;n tienen datos dentro de ellos, puede usar la &lt;code&gt;match&lt;/code&gt; o &lt;code&gt;if let&lt;/code&gt; extraer y usar esos valores, dependiendo de cu&amp;aacute;ntos casos necesite manejar.</target>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="translated">Hemos visto que aunque Rust es capaz de implementar patrones de dise&amp;ntilde;o orientados a objetos, otros patrones, como el estado de codificaci&amp;oacute;n en el sistema de tipos, tambi&amp;eacute;n est&amp;aacute;n disponibles en Rust. Estos patrones tienen diferentes compensaciones. Aunque puede estar muy familiarizado con los patrones orientados a objetos, repensar el problema para aprovechar las caracter&amp;iacute;sticas de Rust puede proporcionar beneficios, como prevenir algunos errores en el momento de la compilaci&amp;oacute;n. Los patrones orientados a objetos no siempre ser&amp;aacute;n la mejor soluci&amp;oacute;n en Rust debido a ciertas caracter&amp;iacute;sticas, como la propiedad, que los lenguajes orientados a objetos no tienen.</target>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="translated">Hemos mostrado varias formas diferentes de definir estructuras de datos para almacenar direcciones IP de la versi&amp;oacute;n cuatro y la versi&amp;oacute;n seis. Sin embargo, resulta que querer almacenar direcciones IP y codificar de qu&amp;eacute; tipo son es tan com&amp;uacute;n que &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;la biblioteca est&amp;aacute;ndar tiene una definici&amp;oacute;n que podemos usar.&lt;/a&gt; Veamos c&amp;oacute;mo la biblioteca est&amp;aacute;ndar define &lt;code&gt;IpAddr&lt;/code&gt; : tiene la enumeraci&amp;oacute;n y las variantes exactas que hemos definido y usado, pero incorpora los datos de la direcci&amp;oacute;n dentro de las variantes en forma de dos estructuras diferentes, que se definen de manera diferente para cada variante:</target>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="translated">Hemos demostrado que Rust es capaz de implementar el patr&amp;oacute;n de estado orientado a objetos para encapsular los diferentes tipos de comportamiento que debe tener una publicaci&amp;oacute;n en cada estado. Los m&amp;eacute;todos de &lt;code&gt;Post&lt;/code&gt; no saben nada sobre los distintos comportamientos. La forma en que organizamos el c&amp;oacute;digo, tenemos que buscar en un solo lugar para conocer las diferentes formas en que una publicaci&amp;oacute;n publicada puede comportarse: la implementaci&amp;oacute;n del rasgo de &lt;code&gt;State&lt;/code&gt; en la estructura &lt;code&gt;Published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="translated">Hemos demostrado que puede crear un iterador llamando a &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;into_iter&lt;/code&gt; o &lt;code&gt;iter_mut&lt;/code&gt; en un vector. Puede crear iteradores a partir de otros tipos de colecciones en la biblioteca est&amp;aacute;ndar, como el mapa hash. Tambi&amp;eacute;n puede crear iteradores que hagan lo que quiera implementando el rasgo &lt;code&gt;Iterator&lt;/code&gt; en sus propios tipos. Como se mencion&amp;oacute; anteriormente, el &amp;uacute;nico m&amp;eacute;todo para el que debe proporcionar una definici&amp;oacute;n es el m&amp;eacute;todo &lt;code&gt;next&lt;/code&gt; . Una vez que haya hecho eso, puede usar todos los dem&amp;aacute;s m&amp;eacute;todos que tienen implementaciones predeterminadas proporcionadas por el rasgo &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="translated">Hemos hablado sobre c&amp;oacute;mo pasar los cierres a las funciones; &amp;iexcl;tambi&amp;eacute;n puede pasar funciones regulares a funciones! Esta t&amp;eacute;cnica es &amp;uacute;til cuando desea pasar una funci&amp;oacute;n que ya ha definido en lugar de definir un nuevo cierre. Hacer esto con punteros de funci&amp;oacute;n le permitir&amp;aacute; usar funciones como argumentos para otras funciones. Las funciones coaccionan al tipo &lt;code&gt;fn&lt;/code&gt; (con una f min&amp;uacute;scula), que no debe confundirse con el rasgo de cierre &lt;code&gt;Fn&lt;/code&gt; . El tipo &lt;code&gt;fn&lt;/code&gt; se denomina &lt;em&gt;puntero a funci&amp;oacute;n&lt;/em&gt; . La sintaxis para especificar que un par&amp;aacute;metro es un puntero de funci&amp;oacute;n es similar a la de los cierres, como se muestra en el Listado 19-27.</target>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="translated">Actualizamos &lt;code&gt;main&lt;/code&gt; para que coloque la instancia de &lt;code&gt;Config&lt;/code&gt; devuelta por &lt;code&gt;parse_config&lt;/code&gt; en una variable llamada &lt;code&gt;config&lt;/code&gt; , y actualizamos el c&amp;oacute;digo que anteriormente usaba la &lt;code&gt;query&lt;/code&gt; separada y las variables de &lt;code&gt;filename&lt;/code&gt; para que ahora use los campos en la estructura &lt;code&gt;Config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="translated">Actualizamos &lt;code&gt;main&lt;/code&gt; donde est&amp;aacute;bamos llamando a &lt;code&gt;parse_config&lt;/code&gt; para llamar a &lt;code&gt;Config::new&lt;/code&gt; . Hemos cambiado el nombre de &lt;code&gt;parse_config&lt;/code&gt; a &lt;code&gt;new&lt;/code&gt; y lo hemos movido dentro de un bloque &lt;code&gt;impl&lt;/code&gt; , que asocia la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n con &lt;code&gt;Config&lt;/code&gt; . Intente compilar este c&amp;oacute;digo nuevamente para asegurarse de que funcione.</target>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="translated">Hemos utilizado &lt;code&gt;recv&lt;/code&gt; en este ejemplo por simplicidad; no tenemos ning&amp;uacute;n otro trabajo para el hilo principal que no sea esperar mensajes, por lo que es apropiado bloquear el hilo principal.</target>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="translated">&amp;iexcl;Hemos usado macros como &lt;code&gt;println!&lt;/code&gt; a lo largo de este libro, pero no hemos explorado completamente qu&amp;eacute; es una macro y c&amp;oacute;mo funciona. El t&amp;eacute;rmino &lt;em&gt;macro se&lt;/em&gt; refiere a una familia de caracter&amp;iacute;sticas en Rust: macros &lt;em&gt;declarativas&lt;/em&gt; con &lt;code&gt;macro_rules!&lt;/code&gt; y tres tipos de macros de &lt;em&gt;procedimiento&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="translated">Hemos utilizado paquetes de &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; como dependencias de nuestro proyecto, pero tambi&amp;eacute;n puede compartir su c&amp;oacute;digo con otras personas publicando sus propios paquetes. El registro de cajas en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distribuye el c&amp;oacute;digo fuente de sus paquetes, por lo que principalmente aloja c&amp;oacute;digo que es de c&amp;oacute;digo abierto.</target>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="translated">Hemos utilizado el gui&amp;oacute;n bajo ( &lt;code&gt;_&lt;/code&gt; ) como patr&amp;oacute;n comod&amp;iacute;n que coincidir&amp;aacute; con cualquier valor pero no se vincular&amp;aacute; al valor. Aunque el patr&amp;oacute;n de subrayado &lt;code&gt;_&lt;/code&gt; es especialmente &amp;uacute;til como &amp;uacute;ltimo brazo en una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; , podemos usarlo en cualquier patr&amp;oacute;n, incluidos los par&amp;aacute;metros de funci&amp;oacute;n, como se muestra en el Listado 18-17.</target>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="translated">Ya hemos analizado un ejemplo de un programa Rust en el Cap&amp;iacute;tulo 2. Ahora que hemos pasado la sintaxis b&amp;aacute;sica, no incluiremos todo el c&amp;oacute;digo &lt;code&gt;fn main() {&lt;/code&gt; en los ejemplos, as&amp;iacute; que si lo est&amp;aacute; siguiendo, Tendr&amp;eacute; que poner los siguientes ejemplos dentro de una funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; manualmente. Como resultado, nuestros ejemplos ser&amp;aacute;n un poco m&amp;aacute;s concisos, lo que nos permitir&amp;aacute; centrarnos en los detalles reales en lugar del c&amp;oacute;digo est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="translated">Palabras clave débiles</target>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">&amp;iexcl;Bienvenido al libro &lt;em&gt;The Rust Programming Language&lt;/em&gt; ! Esta versi&amp;oacute;n del texto asume que est&amp;aacute;s usando Rust 1.31.0 o posterior con &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; en &lt;em&gt;Cargo.toml&lt;/em&gt; de todos los proyectos para usar modismos de la Edici&amp;oacute;n Rust 2018. Consulte la &lt;a href=&quot;book/ch01-01-installation&quot;&gt;secci&amp;oacute;n &quot;Instalaci&amp;oacute;n&quot; del Cap&amp;iacute;tulo 1&lt;/a&gt; para instalar o actualizar Rust, y consulte el nuevo &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Ap&amp;eacute;ndice E&lt;/a&gt; para obtener informaci&amp;oacute;n sobre las ediciones de Rust.</target>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">&amp;iexcl;Bienvenido al libro &lt;em&gt;The Rust Programming Language&lt;/em&gt; ! Esta versi&amp;oacute;n del texto asume que est&amp;aacute;s usando Rust 1.31.0 o posterior con &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; en &lt;em&gt;Cargo.toml&lt;/em&gt; de todos los proyectos para usar modismos de la Edici&amp;oacute;n Rust 2018. Consulte la &lt;a href=&quot;ch01-01-installation&quot;&gt;secci&amp;oacute;n &quot;Instalaci&amp;oacute;n&quot; del Cap&amp;iacute;tulo 1&lt;/a&gt; para instalar o actualizar Rust, y consulte el nuevo &lt;a href=&quot;appendix-05-editions&quot;&gt;Ap&amp;eacute;ndice E&lt;/a&gt; para obtener informaci&amp;oacute;n sobre las ediciones de Rust.</target>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="translated">Bienvenido a &lt;em&gt;The Rust Programming Language&lt;/em&gt; , un libro introductorio sobre Rust. El lenguaje de programaci&amp;oacute;n Rust le ayuda a escribir software m&amp;aacute;s r&amp;aacute;pido y confiable. La ergonom&amp;iacute;a de alto nivel y el control de bajo nivel a menudo est&amp;aacute;n en desacuerdo en el dise&amp;ntilde;o del lenguaje de programaci&amp;oacute;n; Rust desaf&amp;iacute;a ese conflicto. Al equilibrar una poderosa capacidad t&amp;eacute;cnica y una gran experiencia de desarrollador, Rust le brinda la opci&amp;oacute;n de controlar detalles de bajo nivel (como el uso de memoria) sin todas las molestias asociadas tradicionalmente con dicho control.</target>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="translated">&amp;iexcl;Bien hecho! &amp;iexcl;Has llegado al final del libro! Queremos agradecerle por acompa&amp;ntilde;arnos en esta gira por Rust. Ahora est&amp;aacute; listo para implementar sus propios proyectos de Rust y ayudar con los proyectos de otras personas. Tenga en cuenta que existe una comunidad acogedora de otros rust&amp;aacute;ceos a quienes les encantar&amp;iacute;a ayudarlo con cualquier desaf&amp;iacute;o que encuentre en su viaje a Rust.</target>
        </trans-unit>
        <trans-unit id="e51a9120a6d90f0f111fa29f2fe00c6bb7da9412" translate="yes" xml:space="preserve">
          <source>What &lt;em id=&quot;what-the-reference-is-not&quot;&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">Lo que no es la &lt;em&gt;referencia&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="translated">¿Qué es la propiedad?</target>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="translated">¿Qué es una cuerda?</target>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="translated">¿Qué hago?</target>
        </trans-unit>
        <trans-unit id="b31d036160b82937b3f747c02baff101759a7996" translate="yes" xml:space="preserve">
          <source>What expression to evaluate when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition evaluates to &lt;a href=&quot;keyword.false&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="translated">&amp;iquest;Que pas&amp;oacute;? Agregar la palabra clave &lt;code&gt;pub&lt;/code&gt; delante del &lt;code&gt;mod hosting&lt;/code&gt; del mod hace que el m&amp;oacute;dulo sea p&amp;uacute;blico. Con este cambio, si podemos acceder a &lt;code&gt;front_of_house&lt;/code&gt; , podemos acceder al &lt;code&gt;hosting&lt;/code&gt; . Pero el &lt;em&gt;contenido&lt;/em&gt; del &lt;code&gt;hosting&lt;/code&gt; sigue siendo privado; hacer p&amp;uacute;blico el m&amp;oacute;dulo no hace p&amp;uacute;blico su contenido. La palabra clave &lt;code&gt;pub&lt;/code&gt; en un m&amp;oacute;dulo solo permite que el c&amp;oacute;digo de sus m&amp;oacute;dulos ancestros se refiera a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="translated">¿Qué pasa si intentas acceder a un elemento de una matriz que está más allá del final de la matriz? Digamos que cambias el ejemplo al siguiente código,que se compilará pero saldrá con un error cuando se ejecute:</target>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="translated">Lo que la implementación del rasgo significa sobre el tipo</target>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="translated">¿Qué hay en la documentación estándar de la biblioteca?</target>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="translated">¿Qué es la seguridad de desenrollar?</target>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="translated">Lo que los operadores y los métodos que deriven de este rasgo permitirán</target>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;З&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;З&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l deber&amp;iacute;a ser el valor de la &lt;code&gt;answer&lt;/code&gt; ? &amp;iquest;Deber&amp;iacute;a ser &lt;code&gt;З&lt;/code&gt; , la primera letra? Cuando se codifica en UTF-8, el primer byte de &lt;code&gt;З&lt;/code&gt; es &lt;code&gt;208&lt;/code&gt; y el segundo es &lt;code&gt;151&lt;/code&gt; , por lo que la &lt;code&gt;answer&lt;/code&gt; deber&amp;iacute;a ser &lt;code&gt;208&lt;/code&gt; , pero &lt;code&gt;208&lt;/code&gt; no es un car&amp;aacute;cter v&amp;aacute;lido por s&amp;iacute; solo. Es probable que devolver &lt;code&gt;208&lt;/code&gt; no sea lo que un usuario desear&amp;iacute;a si solicitara la primera letra de esta cadena; sin embargo, esos son los &amp;uacute;nicos datos que Rust tiene en el &amp;iacute;ndice de bytes 0. Los usuarios generalmente no quieren que se devuelva el valor del byte, incluso si la cadena contiene solo letras latinas: si &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; fuera un c&amp;oacute;digo v&amp;aacute;lido que devolviera el valor del byte , devolver&amp;iacute;a &lt;code&gt;104&lt;/code&gt; , no &lt;code&gt;h&lt;/code&gt; . Para evitar devolver un valor inesperado y causar errores que podr&amp;iacute;an no descubrirse de inmediato, Rust no compila este c&amp;oacute;digo en absoluto y evita malentendidos al principio del proceso de desarrollo.</target>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="translated">Lo que la aplicaci&amp;oacute;n de la caracter&amp;iacute;stica proporcionada por &lt;code&gt;derive&lt;/code&gt; hace</target>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Lo que esto significa es que cualquier tipo de argumento que implemente el rasgo &lt;a href=&quot;trait.binary&quot;&gt; &lt;code&gt;fmt::Binary&lt;/code&gt; &lt;/a&gt; puede entonces formatearse con &lt;code&gt;{:b}&lt;/code&gt; . Tambi&amp;eacute;n se proporcionan implementaciones para estos rasgos para varios tipos primitivos en la biblioteca est&amp;aacute;ndar. Si no se especifica ning&amp;uacute;n formato (como en &lt;code&gt;{}&lt;/code&gt; o &lt;code&gt;{:6}&lt;/code&gt; ), entonces el rasgo de formato utilizado es el rasgo de &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="translated">Qu&amp;eacute; hacer cuando una condici&amp;oacute;n &lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; no se cumple.</target>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="translated">Lo que no podemos ver en este ejemplo es que cuando &lt;code&gt;b&lt;/code&gt; y luego &lt;code&gt;a&lt;/code&gt; salen del alcance al final de &lt;code&gt;main&lt;/code&gt; , el recuento es 0, y &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; se limpia completamente en ese punto. El uso de &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; permite que un &amp;uacute;nico valor tenga varios propietarios, y el recuento garantiza que el valor siga siendo v&amp;aacute;lido mientras exista alguno de los propietarios.</target>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="translated">¿Cómo sería la comunicación al compartir la memoria? Además,¿por qué los entusiastas del paso de mensajes no lo usarían y harían lo contrario?</target>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasar&amp;iacute;a si &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt; ? La respuesta: Rust entrar&amp;iacute;a en p&amp;aacute;nico en tiempo de ejecuci&amp;oacute;n de la misma manera que si se accediera a un &amp;iacute;ndice no v&amp;aacute;lido en un vector:</target>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasar&amp;iacute;a con el c&amp;oacute;digo del Listado 16-4 donde el hilo principal se llama &lt;code&gt;drop&lt;/code&gt; si usamos un cierre de &lt;code&gt;move&lt;/code&gt; ? &amp;iquest; &lt;code&gt;move&lt;/code&gt; arreglar ese caso? Lamentablemente no; obtendr&amp;iacute;amos un error diferente porque lo que el Listado 16-4 est&amp;aacute; intentando hacer no est&amp;aacute; permitido por una raz&amp;oacute;n diferente. Si agregamos &lt;code&gt;move&lt;/code&gt; r al cierre, mover&amp;iacute;amos &lt;code&gt;v&lt;/code&gt; al entorno del cierre y ya no podr&amp;iacute;amos llamar a &lt;code&gt;drop&lt;/code&gt; en el hilo principal. En su lugar, obtendr&amp;iacute;amos este error del compilador:</target>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre &lt;code&gt;Copy&lt;/code&gt; y &lt;code&gt;Clone&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="c8dcd460b2b3eb060b9c3f227627cad77273bd6e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; is omitted from &lt;code&gt;FunctionQualifiers&lt;/code&gt; in function items, the ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; is assigned. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="translated">Cuando &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; o &lt;code&gt;-&lt;/code&gt; crean un valor mayor que el valor m&amp;aacute;ximo o menor que el valor m&amp;iacute;nimo que se puede almacenar. Esto incluye unario &lt;code&gt;-&lt;/code&gt; en el valor m&amp;aacute;s peque&amp;ntilde;o de cualquier tipo de entero con signo.</target>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="translated">Cuando &lt;code&gt;Trait2&lt;/code&gt; es un sustrato de &lt;code&gt;Trait1&lt;/code&gt; (por ejemplo, cuando &lt;code&gt;Trait2&lt;/code&gt; tiene una definici&amp;oacute;n como &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt; ), no se permite implementar &lt;code&gt;Trait1&lt;/code&gt; para &lt;code&gt;Trait2&lt;/code&gt; . Esto se debe a que &lt;code&gt;Trait2&lt;/code&gt; ya implementa &lt;code&gt;Trait1&lt;/code&gt; por definici&amp;oacute;n, por lo que no es &amp;uacute;til hacer esto.</target>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="translated">Cuando el &lt;code&gt;Trait&lt;/code&gt; se trata como un tipo, el tipo no implementa el rasgo de &lt;code&gt;Sized&lt;/code&gt; especial , porque el tipo no tiene un tama&amp;ntilde;o conocido en el momento de la compilaci&amp;oacute;n y solo se puede acceder a &amp;eacute;l detr&amp;aacute;s de un puntero. As&amp;iacute;, si tenemos un rasgo como el siguiente:</target>
        </trans-unit>
        <trans-unit id="f4fcd22fdc939d17d3b6f99c714199ea75ee05bf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bar&lt;/code&gt; is the name of a function, then the expression &lt;code&gt;bar&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function &lt;code&gt;bar&lt;/code&gt;. The value is zero-sized because the type already identifies the function. This has the advantage that &quot;calling&quot; the value (it implements the &lt;code&gt;Fn*&lt;/code&gt; traits) does not require dynamic dispatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="translated">Cuando se encuentra una &lt;code&gt;break&lt;/code&gt; , la ejecuci&amp;oacute;n del cuerpo del bucle asociado se termina inmediatamente, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b790b4f62a35aeedd4f3d63c2da173a7ec837ca2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c791d46f518801c28641842a73515ec8d559a2ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration is terminated, returning control to the loop head, typically continuing with the next iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="translated">Cuando se encuentra &lt;code&gt;continue&lt;/code&gt; , la iteraci&amp;oacute;n actual del cuerpo del bucle asociado se termina inmediatamente, devolviendo el control al &lt;em&gt;cabezal del&lt;/em&gt; bucle . En el caso de un &lt;code&gt;while&lt;/code&gt; de bucle, la cabeza es la expresi&amp;oacute;n condicional que controla el bucle. En el caso de un bucle &lt;code&gt;for&lt;/code&gt; , el encabezado es la expresi&amp;oacute;n de llamada que controla el bucle.</target>
        </trans-unit>
        <trans-unit id="95185630ceafb190a6bbaa449dad38f0bceaa3df" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called by another attributed function &lt;code&gt;g&lt;/code&gt; which is in turn called by &lt;code&gt;calls_g&lt;/code&gt;, code in both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; observes &lt;code&gt;g&lt;/code&gt;'s callsite within &lt;code&gt;calls_g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3d8142d10bdab6df8f2b960ed3b5f595f6be33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called directly by &lt;code&gt;calls_f&lt;/code&gt;, code in &lt;code&gt;f&lt;/code&gt; observes its callsite within &lt;code&gt;calls_f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b714a909447f7628d7a5c65a1ec2d8d650053b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;g&lt;/code&gt; is called by another attributed function &lt;code&gt;h&lt;/code&gt; which is in turn called by &lt;code&gt;calls_h&lt;/code&gt;, all code in &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; observes &lt;code&gt;h&lt;/code&gt;'s callsite within &lt;code&gt;calls_h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="translated">Cuando lo &lt;code&gt;outer&lt;/code&gt; queda fuera del alcance, el m&amp;eacute;todo de &lt;code&gt;drop&lt;/code&gt; se llamar&amp;aacute; primero para &lt;code&gt;Outer&lt;/code&gt; , luego para &lt;code&gt;Inner&lt;/code&gt; . Por lo tanto, las impresiones &lt;code&gt;main&lt;/code&gt; &lt;code&gt;Dropping Outer!&lt;/code&gt; y luego &lt;code&gt;Dropping Inner!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="translated">Cuando &lt;code&gt;s&lt;/code&gt; entra &lt;em&gt;en el alcance&lt;/em&gt; , es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;security_qos_flags&lt;/code&gt; no est&amp;aacute; configurado, un programa malicioso puede obtener los privilegios elevados de un proceso Rust privilegiado cuando permite abrir rutas especificadas por el usuario, enga&amp;ntilde;&amp;aacute;ndolo para que abra una tuber&amp;iacute;a con nombre. As&amp;iacute; que podr&amp;iacute;a decirse que &lt;code&gt;security_qos_flags&lt;/code&gt; tambi&amp;eacute;n deber&amp;iacute;a establecerse al abrir rutas arbitrarias. Sin embargo, los bits pueden entrar en conflicto con otras banderas, espec&amp;iacute;ficamente &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6050c0d5bfa7ba1d59f28a5f8ace3a1e46fb76d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set, a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;ndo &lt;em&gt;no&lt;/em&gt; puedo &lt;code&gt;Copy&lt;/code&gt; mi tipo ?</target>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;ndo &lt;em&gt;deber&amp;iacute;a ser&lt;/em&gt; mi tipo &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="translated">Cuando Rust compila este c&amp;oacute;digo, realiza una monomorfizaci&amp;oacute;n. Durante ese proceso, el compilador lee los valores que se han utilizado en &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instancias de Option &amp;lt;T&amp;gt; e identifica dos tipos de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; : uno es &lt;code&gt;i32&lt;/code&gt; y el otro es &lt;code&gt;f64&lt;/code&gt; . Como tal, expande la definici&amp;oacute;n gen&amp;eacute;rica de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; en &lt;code&gt;Option_i32&lt;/code&gt; y &lt;code&gt;Option_f64&lt;/code&gt; , reemplazando as&amp;iacute; la definici&amp;oacute;n gen&amp;eacute;rica con las espec&amp;iacute;ficas.</target>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="translated">¿Cuándo deberías usar qué colección?</target>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="translated">Cuando un cierre captura un valor de su entorno, usa la memoria para almacenar los valores para su uso en el cuerpo del cierre. Este uso de memoria es una sobrecarga que no queremos pagar en casos m&amp;aacute;s comunes en los que queremos ejecutar c&amp;oacute;digo que no captura su entorno. Debido a que las funciones nunca pueden capturar su entorno, definir y usar funciones nunca incurrir&amp;aacute; en esta sobrecarga.</target>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="translated">Cuando una funci&amp;oacute;n requiere una alineaci&amp;oacute;n adecuada, lo hace incluso si el acceso tiene tama&amp;ntilde;o 0, es decir, incluso si la memoria no se toca realmente. Considere usar &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling&lt;/code&gt; &lt;/a&gt; en tales casos.</target>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="translated">Cuando una funci&amp;oacute;n devuelve &lt;code&gt;Pending&lt;/code&gt; , la funci&amp;oacute;n tambi&amp;eacute;n &lt;em&gt;debe&lt;/em&gt; asegurarse de que la tarea actual est&amp;eacute; programada para activarse cuando se pueda avanzar.</target>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="translated">Cuando un futuro a&amp;uacute;n no est&amp;aacute; listo, la &lt;code&gt;poll&lt;/code&gt; devuelve &lt;code&gt;Poll::Pending&lt;/code&gt; y almacena un clon de &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; copiado del &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; actual . Este &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; se despierta una vez que el futuro puede progresar. Por ejemplo, un futuro esperando a que un socket se vuelva legible llamar&amp;iacute;a &lt;code&gt;.clone()&lt;/code&gt; en el &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; y lo almacenar&amp;iacute;a. Cuando llega una se&amp;ntilde;al a otro lugar que indica que el socket es legible, se llama a &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt; &lt;code&gt;Waker::wake&lt;/code&gt; &lt;/a&gt; se despierta la tarea del futuro del socket. Una vez que se ha despertado una tarea, debe intentar &lt;code&gt;poll&lt;/code&gt; el futuro nuevamente, lo que puede producir o no un valor final.</target>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="translated">Cuando se hace referencia a una funci&amp;oacute;n gen&amp;eacute;rica, se crea una instancia de su tipo en funci&amp;oacute;n del contexto de la referencia. Por ejemplo, llamar a la funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="translated">Cuando se exporta una macro, el atributo &lt;code&gt;#[macro_export]&lt;/code&gt; puede tener la palabra clave &lt;code&gt;local_inner_macros&lt;/code&gt; agregada para prefijar autom&amp;aacute;ticamente todas las invocaciones de macro contenidas con &lt;code&gt;$crate::&lt;/code&gt; . Esto est&amp;aacute; pensado principalmente como una herramienta para migrar el c&amp;oacute;digo escrito antes &lt;code&gt;$crate&lt;/code&gt; se agregara $ crate al lenguaje para trabajar con las importaciones de macros basadas en rutas de Rust 2018. Se desaconseja su uso en c&amp;oacute;digo nuevo.</target>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="translated">Cuando se invoca una macro por un identificador no cualificado (que no forma parte de un camino de varias partes),se busca primero en el ámbito textual.Si esto no da ningún resultado,entonces se busca en el ámbito basado en la ruta.Si el nombre de la macro está calificado con un camino,entonces sólo se busca en el ámbito basado en el camino.</target>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="translated">Cuando se invoca una macro, el expansor de macros busca las invocaciones de macros por nombre y prueba cada regla de macro por turno. Transcribe la primera coincidencia exitosa; si esto da como resultado un error, no se intentar&amp;aacute;n futuras coincidencias. Al hacer coincidir, no se realiza una b&amp;uacute;squeda anticipada; si el compilador no puede determinar sin ambig&amp;uuml;edades c&amp;oacute;mo analizar la invocaci&amp;oacute;n de la macro, un token a la vez, entonces es un error. En el siguiente ejemplo, el compilador no mira m&amp;aacute;s all&amp;aacute; del identificador para ver si el siguiente token es a &lt;code&gt;)&lt;/code&gt; , aunque eso le permitir&amp;iacute;a analizar la invocaci&amp;oacute;n sin ambig&amp;uuml;edades:</target>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="translated">Cuando una expresi&amp;oacute;n de lugar se eval&amp;uacute;a en un contexto de expresi&amp;oacute;n de valor, o est&amp;aacute; limitada por un valor en un patr&amp;oacute;n, denota el valor que se mantiene &lt;em&gt;en&lt;/em&gt; esa ubicaci&amp;oacute;n de memoria. Si el tipo de ese valor implementa &lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , entonces se copiar&amp;aacute; el valor. En las situaciones restantes, si ese tipo es de &lt;a href=&quot;special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; , entonces es posible mover el valor. Solo se pueden quitar las siguientes expresiones de lugar:</target>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="translated">Cuando un programador tiene la convicci&amp;oacute;n suficiente de que una secuencia de operaciones potencialmente inseguras es realmente segura, puede encapsular esa secuencia (tomada como un todo) dentro de un bloque &lt;code&gt;unsafe&lt;/code&gt; . El compilador considerar&amp;aacute; seguros los usos de dicho c&amp;oacute;digo, en el contexto circundante.</target>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="translated">Cuando se sale de un marco de pila,se liberan todas sus asignaciones locales y se eliminan sus referencias a las cajas.</target>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="translated">Cuando se crea una expresi&amp;oacute;n de valor temporal que se asigna a una &lt;a href=&quot;statements#let-statements&quot;&gt;declaraci&amp;oacute;n &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; , sin embargo, la temporal se crea con la vida &amp;uacute;til del bloque adjunto, ya que usar la &lt;a href=&quot;statements#let-statements&quot;&gt;declaraci&amp;oacute;n &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; adjunta ser&amp;iacute;a un error garantizado (ya que un puntero al temporal ser&amp;iacute;a almacenarse en una variable, pero el temporal se liberar&amp;iacute;a antes de que se pudiera usar la variable). El compilador usa reglas sint&amp;aacute;cticas simples para decidir qu&amp;eacute; valores se asignan en un enlace &lt;code&gt;let&lt;/code&gt; y, por lo tanto, merecen una vida &amp;uacute;til temporal m&amp;aacute;s larga.</target>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="translated">Cuando una herramienta no está en uso,los atributos de la herramienta se aceptan sin previo aviso.Cuando la herramienta está en uso,la herramienta es responsable del procesamiento e interpretación de sus atributos.</target>
        </trans-unit>
        <trans-unit id="57dd9a0351b44496fecb16d4596f4a8247328e39" translate="yes" xml:space="preserve">
          <source>When a trait object is used as a type argument of a generic type, Rust will try to infer its lifetime if unspecified. However, this isn't possible when the containing type has more than one lifetime bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed6434b244126fa9e52f60dea8a8d6ab8918d34" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; does not take any argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746134148fbdc4bec37479d1ea67a6352b384088" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt; as argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="translated">Cuando un usuario llama &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt; , el mapa buscar&amp;aacute; la clave y luego producir&amp;aacute; una variante de &lt;code&gt;Entry&lt;/code&gt; enum.</target>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="translated">Cuando un valor sale del alcance, se llamar&amp;aacute; a su m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; si su tipo implementa &lt;code&gt;Drop&lt;/code&gt; . Luego, cualquier campo que contenga el valor tambi&amp;eacute;n se eliminar&amp;aacute; de forma recursiva.</target>
        </trans-unit>
        <trans-unit id="d7ba61b38031de6106df804542ee455b8b72fed7" translate="yes" xml:space="preserve">
          <source>When a value is no longer needed, Rust will run a &quot;destructor&quot; on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we're going to focus on scope for the examples here. To learn about some of those other cases, please see &lt;a href=&quot;../../reference/destructors&quot;&gt;the reference&lt;/a&gt; section on destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="translated">Cuando una variable es inmutable, una vez que un valor est&amp;aacute; vinculado a un nombre, no puede cambiar ese valor. Para ilustrar esto, generemos un nuevo proyecto llamado &lt;em&gt;variables&lt;/em&gt; en su directorio de &lt;em&gt;proyectos&lt;/em&gt; usando &lt;code&gt;cargo new variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">Cuando una &lt;a href=&quot;variables&quot;&gt;variable &lt;/a&gt;&lt;a href=&quot;glossary#initialized&quot;&gt;inicializada&lt;/a&gt; en Rust sale del alcance o ya no es necesaria una &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporal,&lt;/a&gt; se ejecuta su &lt;em&gt;destructor&lt;/em&gt; . &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; tambi&amp;eacute;n ejecuta el destructor de su operando de la izquierda, a menos que sea una variable no inicializada. Si una variable de &lt;a href=&quot;types/struct&quot;&gt;estructura&lt;/a&gt; se ha inicializado parcialmente, solo se descartan sus campos inicializados.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5a59a643bd12cd60c0f839e9c5140aa3d6d2e23" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; or &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt; goes out of &lt;a href=&quot;#drop-scopes&quot;&gt;scope&lt;/a&gt; its &lt;em&gt;destructor&lt;/em&gt; is run, or it is &lt;em&gt;dropped&lt;/em&gt;. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, if it's initialized. If a variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">Cuando una instancia de &lt;code&gt;ChildStderr&lt;/code&gt; se &lt;a href=&quot;../ops/trait.drop&quot;&gt;dej&amp;oacute; caer&lt;/a&gt; , el &lt;code&gt;ChildStderr&lt;/code&gt; identificador de archivo subyacente 's se cerrar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="translated">Cuando una instancia de &lt;code&gt;ChildStdin&lt;/code&gt; se &lt;a href=&quot;../ops/trait.drop&quot;&gt;dej&amp;oacute; caer&lt;/a&gt; , el &lt;code&gt;ChildStdin&lt;/code&gt; identificador de archivo subyacente 's se cerrar&amp;aacute;. Si el proceso hijo se bloque&amp;oacute; en la entrada antes de ser eliminado, se desbloquear&amp;aacute; despu&amp;eacute;s de eliminarlo.</target>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">Cuando una instancia de &lt;code&gt;ChildStdout&lt;/code&gt; se &lt;a href=&quot;../ops/trait.drop&quot;&gt;dej&amp;oacute; caer&lt;/a&gt; , el &lt;code&gt;ChildStdout&lt;/code&gt; identificador de archivo subyacente 's se cerrar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="translated">Cuando se anotan las vidas en las funciones,las anotaciones van en la firma de la función,no en el cuerpo de la función.El óxido puede analizar el código dentro de la función sin ninguna ayuda.Sin embargo,cuando una función tiene referencias a o del código fuera de esa función,se hace casi imposible para Rust calcular las vidas de los parámetros o devolver valores por sí mismo.Los tiempos de vida pueden ser diferentes cada vez que se llama a la función.Por eso necesitamos anotar las vidas manualmente.</target>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="translated">Al anticipar una gran afluencia de elementos, la familia de m&amp;eacute;todos de &lt;code&gt;reserve&lt;/code&gt; se puede utilizar para indicar a la colecci&amp;oacute;n cu&amp;aacute;nto espacio debe dejar para los pr&amp;oacute;ximos elementos. Al igual que con &lt;code&gt;with_capacity&lt;/code&gt; , el comportamiento preciso de estos m&amp;eacute;todos ser&amp;aacute; espec&amp;iacute;fico de la colecci&amp;oacute;n de inter&amp;eacute;s.</target>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando corresponda, se prefiere la clasificaci&amp;oacute;n inestable porque generalmente es m&amp;aacute;s r&amp;aacute;pida que la clasificaci&amp;oacute;n estable y no asigna memoria auxiliar. Consulte &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando corresponda, se prefiere la clasificaci&amp;oacute;n inestable porque generalmente es m&amp;aacute;s r&amp;aacute;pida que la clasificaci&amp;oacute;n estable y no asigna memoria auxiliar. Consulte &lt;a href=&quot;#method.sort_unstable_by&quot;&gt; &lt;code&gt;sort_unstable_by&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando corresponda, se prefiere la clasificaci&amp;oacute;n inestable porque generalmente es m&amp;aacute;s r&amp;aacute;pida que la clasificaci&amp;oacute;n estable y no asigna memoria auxiliar. Consulte &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt; &lt;code&gt;sort_unstable_by_key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9457ac5b05fa1acc97622737a2e6a54db8e47e30" translate="yes" xml:space="preserve">
          <source>When applied to a function in an &lt;code&gt;extern&lt;/code&gt; block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an &lt;code&gt;extern&lt;/code&gt; block, the declaration in the &lt;code&gt;extern&lt;/code&gt; block must also have the attribute, otherwise undefined behavior results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Cuando se aplica a valores del tipo &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , propaga &lt;code&gt;None&lt;/code&gt; s. Si el valor es &lt;code&gt;None&lt;/code&gt; , devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; . Si se aplica a &lt;code&gt;Some(x)&lt;/code&gt; , entonces desenvolver&amp;aacute; el valor para evaluar &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Cuando se aplica a valores del tipo &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , propaga errores. Si el valor es &lt;code&gt;Err(e)&lt;/code&gt; , devolver&amp;aacute; &lt;code&gt;Err(From::from(e))&lt;/code&gt; de la funci&amp;oacute;n o cierre adjunto. Si se aplica a &lt;code&gt;Ok(x)&lt;/code&gt; , entonces desenvolver&amp;aacute; el valor para evaluar &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="translated">Cuando se aplica dentro de una caja, los usuarios posteriores de la caja necesitar&amp;aacute;n usar el patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; al hacer coincidir enumeraciones y usar el patr&amp;oacute;n &lt;code&gt;..&lt;/code&gt; al hacer coincidir estructuras. Los cajones aguas abajo no pueden coincidir con variantes de enumeraci&amp;oacute;n no exhaustivas.</target>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="translated">¿Cuándo se convertirán estas advertencias en errores?</target>
        </trans-unit>
        <trans-unit id="93dc9e73dc6c00708f0214c1f73e691c8c3e8698" translate="yes" xml:space="preserve">
          <source>When associated with &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop. This is only valid with &lt;code&gt;loop&lt;/code&gt; and not with any other type of loop. If no value is specified, &lt;code&gt;break;&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt;. Every &lt;code&gt;break&lt;/code&gt; within a loop must return the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="translated">Cuando se asocia con un &lt;code&gt;loop&lt;/code&gt; , se puede usar una expresi&amp;oacute;n de ruptura para devolver un valor de ese bucle, a trav&amp;eacute;s de una de las formas &lt;code&gt;break EXPR&lt;/code&gt; o &lt;code&gt;break 'label EXPR&lt;/code&gt; , donde &lt;code&gt;EXPR&lt;/code&gt; es una expresi&amp;oacute;n cuyo resultado se devuelve desde el &lt;code&gt;loop&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4a763dfd452f118669800efdde464c1dbe786ee4" translate="yes" xml:space="preserve">
          <source>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;product()&lt;/code&gt; y se devuelve un tipo de entero primitivo, el m&amp;eacute;todo entrar&amp;aacute; en p&amp;aacute;nico si el c&amp;aacute;lculo se desborda y las aserciones de depuraci&amp;oacute;n est&amp;aacute;n habilitadas.</target>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;sum()&lt;/code&gt; y se devuelve un tipo entero primitivo, este m&amp;eacute;todo entrar&amp;aacute; en p&amp;aacute;nico si el c&amp;aacute;lculo se desborda y las aserciones de depuraci&amp;oacute;n est&amp;aacute;n habilitadas.</target>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="translated">Al llamar a m&amp;eacute;todos con el mismo nombre, deber&amp;aacute; decirle a Rust cu&amp;aacute;l desea usar. Considere el c&amp;oacute;digo del Listado 19-16 donde hemos definido dos caracter&amp;iacute;sticas, &lt;code&gt;Pilot&lt;/code&gt; o y &lt;code&gt;Wizard&lt;/code&gt; , que tienen un m&amp;eacute;todo llamado &lt;code&gt;fly&lt;/code&gt; . Luego implementamos ambos rasgos en un tipo &lt;code&gt;Human&lt;/code&gt; o que ya tiene implementado un m&amp;eacute;todo llamado &lt;code&gt;fly&lt;/code&gt; . Cada m&amp;eacute;todo de &lt;code&gt;fly&lt;/code&gt; hace algo diferente.</target>
        </trans-unit>
        <trans-unit id="09c7e5de85184f1e292948f95737d163821f3f97" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that &lt;em&gt;either&lt;/em&gt; the pointer is NULL &lt;em&gt;or&lt;/em&gt; all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5922155f29f105357a025f039108b9a7d5336187" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">Cuando se llama a este m&amp;eacute;todo, usted tiene que asegurarse de que si el puntero no es NULL, entonces est&amp;aacute; correctamente alineado, dereferencable (para todo el tama&amp;ntilde;o del &lt;code&gt;T&lt;/code&gt; ) y apunta a una instancia de inicializada &lt;code&gt;T&lt;/code&gt; . &amp;iexcl;Esto se aplica incluso si el resultado de este m&amp;eacute;todo no se utiliza! (La parte sobre la inicializaci&amp;oacute;n a&amp;uacute;n no est&amp;aacute; completamente decidida, pero hasta que sea el &amp;uacute;nico enfoque seguro es asegurarse de que est&amp;eacute;n realmente inicializados).</target>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">Cuando se llama a este m&amp;eacute;todo, usted tiene que asegurarse de que si el puntero no es NULL, entonces est&amp;aacute; correctamente alineado, dereferencable (para todo el tama&amp;ntilde;o del &lt;code&gt;T&lt;/code&gt; ) y apunta a una instancia de inicializada &lt;code&gt;T&lt;/code&gt; . &amp;iexcl;Esto se aplica incluso si el resultado de este m&amp;eacute;todo no se utiliza! (La parte sobre la inicializaci&amp;oacute;n a&amp;uacute;n no est&amp;aacute; completamente decidida, pero hasta que lo est&amp;eacute;, el &amp;uacute;nico enfoque seguro es asegurarse de que est&amp;eacute;n realmente inicializados).</target>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;ndo se puede &lt;code&gt;Copy&lt;/code&gt; mi tipo ?</target>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="translated">Al hacer el casting,tened en cuenta que sólo los tipos primitivos pueden ser castigados entre sí.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="translated">Al comparar punteros, se comparan por su direcci&amp;oacute;n, en lugar de por lo que apuntan. Al comparar punteros con &lt;a href=&quot;../dynamically-sized-types&quot;&gt;tipos de tama&amp;ntilde;o din&amp;aacute;mico&lt;/a&gt; , tambi&amp;eacute;n se comparan sus datos de adici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f2f745dfedc8e3dcf7cd93386db2954df66d81dc" translate="yes" xml:space="preserve">
          <source>When comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their additional data compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="translated">Cuando la comparación es imposible:</target>
        </trans-unit>
        <trans-unit id="09f829ddc19ecb8dff523da8b6aa0bd5c5c69a9a" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">Cuando se combina con una carga, si el valor cargado fue escrito por una operaci&amp;oacute;n de tienda con orden de &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; (o m&amp;aacute;s fuerte), todas las operaciones posteriores se ordenan despu&amp;eacute;s de esa tienda. En particular, todas las cargas posteriores ver&amp;aacute;n los datos escritos antes de la tienda.</target>
        </trans-unit>
        <trans-unit id="c91753b6ff7ee275cf69a5dce0e73e0bd2e33946" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">Cuando se combina con una tienda, todas las operaciones anteriores se ordenan antes de cualquier carga de este valor con pedidos de &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (o m&amp;aacute;s fuertes). En particular, todas las escrituras anteriores se vuelven visibles para todos los subprocesos que realizan una carga de &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (o m&amp;aacute;s fuerte) de este valor.</target>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="translated">Al crear referencias inmutables y mutables, usamos la sintaxis &lt;code&gt;&amp;amp;&lt;/code&gt; y &lt;code&gt;&amp;amp;mut&lt;/code&gt; , respectivamente. Con &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , usamos los m&amp;eacute;todos de &lt;code&gt;borrow&lt;/code&gt; y &lt;code&gt;borrow_mut&lt;/code&gt; , que son parte de la API segura que pertenece a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . El m&amp;eacute;todo de &lt;code&gt;borrow&lt;/code&gt; devuelve el tipo de puntero inteligente &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; y el &lt;code&gt;borrow_mut&lt;/code&gt; devuelve el tipo de puntero inteligente &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; . Ambos tipos implementan &lt;code&gt;Deref&lt;/code&gt; , por lo que podemos tratarlos como referencias regulares.</target>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="translated">Al crear macros de procedimiento, las definiciones deben residir en su propia caja con un tipo de caja especial. Esto se debe a complejas razones t&amp;eacute;cnicas que esperamos eliminar en el futuro. El uso de macros de procedimiento se parece al c&amp;oacute;digo del Listado 19-29, donde &lt;code&gt;some_attribute&lt;/code&gt; es un marcador de posici&amp;oacute;n para usar una macro espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="translated">Al definir una función que utiliza genéricos,colocamos los genéricos en la firma de la función donde normalmente especificaríamos los tipos de datos de los parámetros y el valor de retorno.Esto hace que nuestro código sea más flexible y proporciona más funcionalidad a quienes llaman a nuestra función,al tiempo que evita la duplicación de código.</target>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">Al definir una estructura o enumeraci&amp;oacute;n recursiva, cualquier uso del tipo que se define desde dentro de la definici&amp;oacute;n debe ocurrir detr&amp;aacute;s de un puntero (como &lt;code&gt;Box&lt;/code&gt; o &lt;code&gt;&amp;amp;&lt;/code&gt; ). Esto se debe a que las estructuras y las enumeraciones deben tener un tama&amp;ntilde;o bien definido, y sin el puntero, el tama&amp;ntilde;o del tipo deber&amp;iacute;a ser ilimitado.</target>
        </trans-unit>
        <trans-unit id="54e2930486f06054c79b2d368c2769ebefeaab63" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="translated">Cuando se deriva de estructuras, &lt;code&gt;PartialOrd&lt;/code&gt; compara dos instancias comparando el valor en cada campo en el orden en que aparecen los campos en la definici&amp;oacute;n de estructura. Cuando se derivan de enumeraciones, las variantes de la enumeraci&amp;oacute;n declaradas anteriormente en la definici&amp;oacute;n de enumeraci&amp;oacute;n se consideran menos que las variantes enumeradas m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="translated">Cuando está habilitado,este enchufe puede enviar paquetes a una dirección de emisión.</target>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="translated">Cuando se evalúa una expresión de bloque,cada declaración,excepto las de declaración de artículos,se ejecuta secuencialmente.Luego se ejecuta la expresión final,si se da.</target>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="translated">Al reenviar un fragmento coincidente a otra macro por ejemplo, los comparadores de la segunda macro ver&amp;aacute;n un AST opaco del tipo de fragmento. La segunda macro no puede usar tokens literales para hacer coincidir los fragmentos en el comparador, solo un especificador de fragmentos del mismo tipo. Los &lt;code&gt;ident&lt;/code&gt; , &lt;code&gt;lifetime&lt;/code&gt; , y &lt;code&gt;tt&lt;/code&gt; tipos de fragmentos son una excepci&amp;oacute;n, y &lt;em&gt;pueden&lt;/em&gt; ir acompa&amp;ntilde;adas de tokens literales. Lo siguiente ilustra esta restricci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9aca28029ce8b3b95a609b5e4ca6542143135bed" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="translated">Al implementar un combinador de &lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; , generalmente necesitar&amp;aacute; un anclaje estructural para los futuros anidados, ya que necesita obtener referencias ancladas a ellos para llamar a la &lt;code&gt;poll&lt;/code&gt; . Pero si su combinador contiene cualquier otro dato que no necesita ser anclado, puede hacer que esos campos no sean estructurales y, por lo tanto, acceder a ellos libremente con una referencia mutable incluso cuando solo tiene &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (como en su propia implementaci&amp;oacute;n de &lt;code&gt;poll&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3023d431ee0ca325e5e6237d2618e2a98462263f" translate="yes" xml:space="preserve">
          <source>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="translated">Al implementar un rasgo de formato para su propio tipo,tendrá que implementar un método de la firma:</target>
        </trans-unit>
        <trans-unit id="f71a495d94aa8ee98863b069031787f4cf122fc5" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">Al implementar un &lt;code&gt;ExactSizeIterator&lt;/code&gt; , tambi&amp;eacute;n debe implementar &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . Al hacerlo, la implementaci&amp;oacute;n de &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;&lt;em&gt; debe&lt;/em&gt; devolver el tama&amp;ntilde;o exacto del iterador.</target>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="translated">Al implementar tanto &lt;code&gt;Hash&lt;/code&gt; como &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; , es importante que se cumpla la siguiente propiedad:</target>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="translated">Al implementar este rasgo para &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; ,&lt;/a&gt; debemos elegir un tipo para &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . Y dado que convertir una cadena en una cadena nunca dar&amp;aacute; como resultado un error, &amp;iexcl;el tipo apropiado es &lt;code&gt;!&lt;/code&gt; . (Actualmente, el tipo que se usa actualmente es una enumeraci&amp;oacute;n sin variantes, aunque esto es solo porque &lt;code&gt;!&lt;/code&gt; Se agreg&amp;oacute; a Rust en una fecha posterior y puede cambiar en el futuro). Con un tipo &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; de &lt;code&gt;!&lt;/code&gt; , si tenemos que llamar a &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;String::from_str&lt;/code&gt; &lt;/a&gt; por alguna raz&amp;oacute;n, el resultado ser&amp;aacute; un &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt; &lt;/a&gt; que podemos descomprimir as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="translated">Al inicializar un &lt;code&gt;Slice&lt;/code&gt; , simplemente proporcione el valor &lt;code&gt;PhantomData&lt;/code&gt; para el campo &lt;code&gt;phantom&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="translated">Al inicializar una estructura de datos (estructura, enumeraci&amp;oacute;n, uni&amp;oacute;n) con los campos nombre (pero sin numerar), se le permite escribir &lt;code&gt;fieldname&lt;/code&gt; como una abreviatura de &lt;code&gt;fieldname: fieldname&lt;/code&gt; . Esto permite una sintaxis compacta con menos duplicaciones. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="translated">Cuando se invocan cierres u otras implementaciones de los rasgos de funci&amp;oacute;n &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; o &lt;code&gt;FnOnce&lt;/code&gt; usando la notaci&amp;oacute;n de llamada, el n&amp;uacute;mero de par&amp;aacute;metros pasados ​​a la funci&amp;oacute;n debe coincidir con su definici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="translated">Al buscar la implementaci&amp;oacute;n del rasgo, el compilador encuentra tanto el &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; donde T es todos los tipos y el &lt;code&gt;impl MyTrait for Foo&lt;/code&gt; . Dado que un rasgo no se puede implementar varias veces, esto es un error. Entonces, cuando escribe:</target>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="translated">Cuando se busca una llamada de método,el receptor puede ser automáticamente desviado o prestado para llamar a un método.Esto requiere un proceso de búsqueda más complejo que el de otras funciones,ya que puede haber varios métodos posibles para llamar.Se utiliza el siguiente procedimiento:</target>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="translated">Cuando se compara con un rango,el compilador verifica que el rango no está vacío.Los patrones de la gama incluyen ambos puntos finales,por lo que esto equivale a exigir que el inicio de la gama sea menor o igual que el final de la misma.</target>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="translated">Cuando se compara con una gama exclusiva,el compilador verifica que la gama no está vacía.Los patrones de rango exclusivo incluyen el punto de inicio pero no el punto final,por lo que esto equivale a requerir que el inicio del rango sea menor que el final del mismo.</target>
        </trans-unit>
        <trans-unit id="b0e0c88f0138777df9f95477c6fa805a498782e3" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="translated">Al coincidir en una variable no puede mutar en los protectores del fósforo,ya que esto podría causar que la coincidencia no sea exhaustiva:</target>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="translated">Al nombrar cajas de Rust, no se permiten guiones. Sin embargo, los paquetes Cargo pueden hacer uso de ellos. En tal caso, cuando &lt;code&gt;Cargo.toml&lt;/code&gt; no especifica un nombre de caj&amp;oacute;n, por carretera ser&amp;aacute; transparente reemplazar &lt;code&gt;-&lt;/code&gt; con &lt;code&gt;_&lt;/code&gt; (Consulte &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; para m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="translated">Cuando solo se trata de un hilo, los resultados son los esperados: se imprime la l&amp;iacute;nea &lt;code&gt;7 4 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">Cuando se opera en una consola,la implementación de Windows de esta corriente no soporta secuencias de bytes no UTF-8.Intentar leer bytes que no son UTF-8 válidos devolverá un error.</target>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">Cuando se opera en una consola,la implementación de Windows de esta corriente no soporta secuencias de bytes no UTF-8.Intentar escribir bytes que no sean UTF-8 válidos devolverá un error.</target>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="translated">Al analizar el camino,hay una pequeña cantidad de normalización:</target>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="translated">Cuando se reexporta un artículo privado,puede pensarse que se permite que la &quot;cadena de privacidad&quot; se cortocircuite a través de la reexportación en lugar de pasar por la jerarquía del espacio de nombres como lo haría normalmente.</target>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="translated">Cuando se hace referencia a ella, una &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; produce un &lt;em&gt;valor&lt;/em&gt; de primera clase del &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;tipo de elemento de funci&amp;oacute;n de&lt;/em&gt;&lt;/a&gt; tama&amp;ntilde;o cero correspondiente , que cuando se llama se eval&amp;uacute;a como una llamada directa a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="translated">Cuando se hace referencia a un elemento de funci&amp;oacute;n, o el constructor de una estructura de tipo tupla o una variante de enumeraci&amp;oacute;n, produce un valor de tama&amp;ntilde;o cero de su &lt;em&gt;tipo de elemento de funci&amp;oacute;n&lt;/em&gt; . Ese tipo identifica expl&amp;iacute;citamente la funci&amp;oacute;n: su nombre, sus argumentos de tipo y sus argumentos de duraci&amp;oacute;n de enlace temprano (pero no sus argumentos de duraci&amp;oacute;n de enlace tard&amp;iacute;o, que solo se asignan cuando se llama a la funci&amp;oacute;n), por lo que el valor no necesita contener un puntero de funci&amp;oacute;n real, y no se necesita indirecci&amp;oacute;n cuando se llama a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="translated">Cuando se trata de repeticiones,las reglas se aplican a cada número posible de expansiones,teniendo en cuenta los separadores.Esto significa que:</target>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="translated">Cuando solicita que un argumento sea formateado con un tipo en particular, en realidad est&amp;aacute; solicitando que un argumento se atribuya a un rasgo en particular. Esto permite formatear varios tipos reales mediante &lt;code&gt;{:x}&lt;/code&gt; (como &lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; ). El mapeo actual de tipos a rasgos es:</target>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="translated">Cuando el valor de retorno se desborda (es decir, &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; para el tipo &lt;code&gt;uN&lt;/code&gt; ), entra en p&amp;aacute;nico en el modo de depuraci&amp;oacute;n y el valor de retorno se ajusta a 0 en el modo de liberaci&amp;oacute;n (la &amp;uacute;nica situaci&amp;oacute;n en la que el m&amp;eacute;todo puede devolver 0) .</target>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="translated">Cuando el valor de retorno se desborda (es decir, &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; para el tipo &lt;code&gt;uN&lt;/code&gt; ), se desborda a &lt;code&gt;2^N = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="translated">Al devolver una referencia de una funci&amp;oacute;n, el par&amp;aacute;metro de duraci&amp;oacute;n del tipo de retorno debe coincidir con el par&amp;aacute;metro de duraci&amp;oacute;n de uno de los par&amp;aacute;metros. Si la referencia devuelta no &lt;em&gt;se&lt;/em&gt; refiere a uno de los par&amp;aacute;metros, debe referirse a un valor creado dentro de esta funci&amp;oacute;n, que ser&amp;iacute;a una referencia pendiente porque el valor saldr&amp;aacute; del alcance al final de la funci&amp;oacute;n. Considere este intento de implementaci&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; que no se compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="translated">Cuando se ejecuta el código en la Lista 16-10,debería ver la siguiente salida con una pausa de 1 segundo entre cada línea:</target>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="translated">Sin embargo, al buscar un valor en el mapa, tener que proporcionar una referencia a una &lt;code&gt;K&lt;/code&gt; como clave para buscar requerir&amp;iacute;a crear siempre ese valor propio. Para las claves de cadena, esto significar&amp;iacute;a que se debe crear un valor de &lt;code&gt;String&lt;/code&gt; solo para la b&amp;uacute;squeda de casos en los que solo una &lt;code&gt;str&lt;/code&gt; est&amp;eacute; disponible .</target>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;ndo se debe utilizar &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="translated">Cuando se parte de una rebanada en lugar de una matriz,se pueden utilizar API de conversión falibles:</target>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="translated">Cuando una cadena de este &lt;code&gt;monospace&lt;/code&gt; en fuente monoespaciada aparece dentro de la gram&amp;aacute;tica, es una referencia impl&amp;iacute;cita a un solo miembro de dicha producci&amp;oacute;n de tabla de cadenas. Consulte &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a52c1f9d28a81019545579685f71cebe8cd39993" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; on the same stream can cause data loss. Reading from the underlying reader after unwrapping the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt;&lt;code&gt;BufReader::into_inner&lt;/code&gt;&lt;/a&gt; can also cause data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="translated">Cuando se &lt;code&gt;BufReader&lt;/code&gt; el BufReader , el contenido de su b&amp;uacute;fer se descartar&amp;aacute;. Creando m&amp;uacute;ltiples instancias de un &lt;code&gt;BufReader&lt;/code&gt; en la misma secuencia puede provocar la p&amp;eacute;rdida de datos.</target>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="translated">Cuando se descarta el &lt;code&gt;BufWriter&lt;/code&gt; , se escribir&amp;aacute; el contenido de su b&amp;uacute;fer. Sin embargo, se ignorar&amp;aacute; cualquier error que ocurra en el proceso de vaciar el b&amp;uacute;fer cuando se quita el escritor. El c&amp;oacute;digo que desea manejar tales errores debe llamar manualmente a &lt;a href=&quot;#method.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; antes de que se elimine el escritor.</target>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="translated">Cuando el rasgo &lt;code&gt;Deref&lt;/code&gt; se define para los tipos involucrados, Rust analizar&amp;aacute; los tipos y usar&amp;aacute; &lt;code&gt;Deref::deref&lt;/code&gt; tantas veces como sea necesario para obtener una referencia que coincida con el tipo del par&amp;aacute;metro. El n&amp;uacute;mero de veces que se &lt;code&gt;Deref::deref&lt;/code&gt; se resuelve en tiempo de compilaci&amp;oacute;n, por lo que no hay penalizaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n por aprovechar la coerci&amp;oacute;n deref.</target>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="translated">Cuando al m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; se le pasa un &amp;iacute;ndice que est&amp;aacute; fuera del vector, devuelve &lt;code&gt;None&lt;/code&gt; sin entrar en p&amp;aacute;nico. Usar&amp;iacute;a este m&amp;eacute;todo si el acceso a un elemento fuera del rango del vector ocurre ocasionalmente en circunstancias normales. Su c&amp;oacute;digo entonces tendr&amp;aacute; l&amp;oacute;gica para manejar tener &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; o &lt;code&gt;None&lt;/code&gt; , como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 6. Por ejemplo, el &amp;iacute;ndice podr&amp;iacute;a provenir de una persona que ingresa un n&amp;uacute;mero. Si ingresan accidentalmente un n&amp;uacute;mero que es demasiado grande y el programa obtiene un valor &lt;code&gt;None&lt;/code&gt; , podr&amp;iacute;a decirle al usuario cu&amp;aacute;ntos elementos hay en el vector actual y darle otra oportunidad de ingresar un valor v&amp;aacute;lido. &amp;iexcl;Eso ser&amp;iacute;a m&amp;aacute;s f&amp;aacute;cil de usar que bloquear el programa debido a un error tipogr&amp;aacute;fico!</target>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="translated">Cuando se ejecuta la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; , compara el valor resultante con el patr&amp;oacute;n de cada brazo, en orden. Si un patr&amp;oacute;n coincide con el valor, se ejecuta el c&amp;oacute;digo asociado con ese patr&amp;oacute;n. Si ese patr&amp;oacute;n no coincide con el valor, la ejecuci&amp;oacute;n contin&amp;uacute;a con el siguiente brazo, como en una m&amp;aacute;quina clasificadora de monedas. Podemos tener tantos brazos como necesitemos: en el Listado 6-3, nuestro &lt;code&gt;match&lt;/code&gt; tiene cuatro brazos.</target>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="translated">Cuando finaliza la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; , su alcance finaliza, al igual que el alcance de la &lt;code&gt;y&lt;/code&gt; interna . &amp;iexcl;La &amp;uacute;ltima &lt;code&gt;println!&lt;/code&gt; produce &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="translated">Cuando la funci&amp;oacute;n asociada se declara en un rasgo, tambi&amp;eacute;n se puede llamar a la funci&amp;oacute;n con una &lt;a href=&quot;../paths&quot;&gt;ruta&lt;/a&gt; que es una ruta al rasgo adjuntada por el nombre del rasgo. Cuando esto sucede, se sustituye por &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="translated">Cuando el c&amp;oacute;digo de llamada necesita el resultado de evaluar el cierre, en lugar de llamar al cierre directamente, llamar&amp;aacute; al m&amp;eacute;todo de &lt;code&gt;value&lt;/code&gt; . Este m&amp;eacute;todo comprueba si ya tenemos un valor resultante en &lt;code&gt;self.value&lt;/code&gt; en &lt;code&gt;Some&lt;/code&gt; ; si lo hacemos, devuelve el valor dentro de &lt;code&gt;Some&lt;/code&gt; sin ejecutar el cierre nuevamente.</target>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">Cuando la l&amp;iacute;nea de comandos se inicia l&amp;oacute;gica de an&amp;aacute;lisis complicandonos, extraerlo de &lt;em&gt;main.rs&lt;/em&gt; y moverlo a &lt;em&gt;lib.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="translated">Cuando el predicado de configuraci&amp;oacute;n es verdadero, este atributo se expande a los atributos enumerados despu&amp;eacute;s del predicado. Por ejemplo, el siguiente m&amp;oacute;dulo se encontrar&amp;aacute; en &lt;code&gt;linux.rs&lt;/code&gt; o &lt;code&gt;windows.rs&lt;/code&gt; seg&amp;uacute;n el destino.</target>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="translated">Cuando se hace el borrador,se solicita una revisión del puesto.</target>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="translated">Cuando la cadena vacía se utiliza como separador,separa cada carácter de la cadena,junto con el principio y el final de la misma.</target>
        </trans-unit>
        <trans-unit id="8391463b3513744ada63d41c0e15df2b575fc578" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;../fs/struct.file#method.open&quot;&gt;&lt;code&gt;fs::File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt;&lt;code&gt;fs::OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b88e35933dd499afe9dc518b98a0ae7b4608c2" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="translated">Cuando finaliza el alcance interno, la &lt;code&gt;branch&lt;/code&gt; sale del alcance y el recuento fuerte de &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; disminuye a 0, por lo que su &lt;code&gt;Node&lt;/code&gt; se descarta. El recuento d&amp;eacute;bil de 1 de &lt;code&gt;leaf.parent&lt;/code&gt; no influye en si &lt;code&gt;Node&lt;/code&gt; se elimina o no , por lo que no tenemos p&amp;eacute;rdidas de memoria.</target>
        </trans-unit>
        <trans-unit id="92e09a21380ea98a48f9618974476f27f710a28e" translate="yes" xml:space="preserve">
          <source>When the iterator &lt;strong&gt;is&lt;/strong&gt; dropped, all elements in the range are removed from the vector, even if the iterator was not fully consumed. If the iterator &lt;strong&gt;is not&lt;/strong&gt; dropped (with &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; for example), it is unspecified how many elements are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="translated">Cuando la l&amp;oacute;gica que se va a realizar en el valor es m&amp;aacute;s compleja, simplemente podemos usar la API de &lt;code&gt;entry&lt;/code&gt; para asegurarnos de que el valor se inicialice y luego realizar la l&amp;oacute;gica.</target>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="translated">Cuando el hilo principal de un programa de Rust termina,el programa entero se apaga,incluso si otros hilos siguen funcionando.Sin embargo,este módulo proporciona facilidades convenientes para esperar automáticamente la terminación de un hilo hijo (es decir,unirse).</target>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="translated">Cuando el propietario se salga del ámbito de aplicación,el valor se reducirá.</target>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="translated">Cuando el patrón no coincide:</target>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="translated">Cuando el patr&amp;oacute;n coincide correctamente, se ejecuta la expresi&amp;oacute;n de protecci&amp;oacute;n de patr&amp;oacute;n. Si la expresi&amp;oacute;n se eval&amp;uacute;a como verdadera, el patr&amp;oacute;n se compara con &amp;eacute;xito. De lo contrario, el siguiente patr&amp;oacute;n, incluidas otras coincidencias con el &lt;code&gt;|&lt;/code&gt; operador en el mismo brazo, se prueba.</target>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="translated">Cuando el puesto es aprobado,se publica.</target>
        </trans-unit>
        <trans-unit id="41bc650167a3c0cb28cbdf2fe35163fe7bda095c" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work if we also try to refer to that element later in the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="translated">Cuando el programa tiene una referencia v&amp;aacute;lida, el verificador de pr&amp;eacute;stamos aplica las reglas de propiedad y pr&amp;eacute;stamo (cubiertas en el Cap&amp;iacute;tulo 4) para garantizar que esta referencia y cualquier otra referencia al contenido del vector sigan siendo v&amp;aacute;lidas. Recuerde la regla que establece que no puede tener referencias mutables e inmutables en el mismo &amp;aacute;mbito. Esa regla se aplica en el Listado 8-7, donde mantenemos una referencia inmutable al primer elemento en un vector e intentamos agregar un elemento al final, lo que no funcionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="translated">Cuando el programador ha habilitado &lt;code&gt;debug_assert!&lt;/code&gt; afirmaciones (por ejemplo, al habilitar una compilaci&amp;oacute;n no optimizada), las implementaciones deben insertar comprobaciones din&amp;aacute;micas que &lt;code&gt;panic&lt;/code&gt; en caso de desbordamiento. Otros tipos de compilaciones pueden provocar &lt;code&gt;panics&lt;/code&gt; o valores envueltos silenciosamente en desbordamiento, a discreci&amp;oacute;n de la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="translated">Cuando la expresi&amp;oacute;n del escrutinio es una &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresi&amp;oacute;n de lugar&lt;/a&gt; , la coincidencia no asigna una ubicaci&amp;oacute;n temporal; sin embargo, un enlace por valor puede copiar o moverse desde la ubicaci&amp;oacute;n de la memoria. Cuando sea posible, es preferible hacer coincidir expresiones de lugar, ya que la duraci&amp;oacute;n de estas coincidencias hereda la duraci&amp;oacute;n de la expresi&amp;oacute;n de lugar en lugar de limitarse al interior de la coincidencia.</target>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="translated">Cuando la lengüeta de la rebanada no se divide uniformemente por el tamaño del trozo,la última rebanada de la iteración será el resto.</target>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">Cuando la longitud del segmento no se divide uniformemente por el tama&amp;ntilde;o del fragmento, se &lt;code&gt;chunk_size-1&lt;/code&gt; los &amp;uacute;ltimos elementos hasta chunk_size-1 , pero se pueden recuperar de la funci&amp;oacute;n &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; del iterador.</target>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">Cuando la longitud del segmento no se divide uniformemente por el tama&amp;ntilde;o del fragmento, se &lt;code&gt;chunk_size-1&lt;/code&gt; los &amp;uacute;ltimos elementos hasta chunk_size-1 , pero se pueden recuperar de la funci&amp;oacute;n &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt; del iterador.</target>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Cuando se omite el punto y coma al final, el resultado debe ser type &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="translated">Cuando se elimina el vector, tambi&amp;eacute;n se elimina todo su contenido, lo que significa que los enteros que contiene se limpiar&amp;aacute;n. Esto puede parecer un punto sencillo, pero puede volverse un poco m&amp;aacute;s complicado cuando comienzas a introducir referencias a los elementos del vector. &amp;iexcl;Abordemos eso a continuaci&amp;oacute;n!</target>
        </trans-unit>
        <trans-unit id="d759cfed67550956f3c467a9677f59d40c90a085" translate="yes" xml:space="preserve">
          <source>When there isn't a &lt;code&gt;Self: Sized&lt;/code&gt; bound on a method, the type of a method receiver must be one of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="translated">Cuando se ejecuta este cierre,aspectos como los descriptores de los archivos stdio y el directorio de trabajo se han cambiado con éxito,por lo que es posible que la salida a estos lugares no aparezca en el lugar previsto.</target>
        </trans-unit>
        <trans-unit id="ad7769a3800701a3a043ec20084e499702706111" translate="yes" xml:space="preserve">
          <source>When this function is used during const evaluation, it may return &lt;code&gt;false&lt;/code&gt; for pointers that turn out to be null at runtime. Specifically, when a pointer to some memory is offset beyond its bounds in such a way that the resulting pointer is null, the function will still return &lt;code&gt;false&lt;/code&gt;. There is no way for CTFE to know the absolute position of that memory, so we cannot tell if the pointer is null or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="translated">Cuando esta función vuelve,se garantiza que se ha ejecutado y completado alguna inicialización (puede que no sea el cierre especificado).También se garantiza que cualquier escritura en memoria realizada por el cierre ejecutado puede ser observada con fiabilidad por otros hilos en este punto (existe una relación de &quot;sucede antes&quot; entre el cierre y el código que se ejecuta después del retorno).</target>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="translated">Cuando se ha llamado a este m&amp;eacute;todo, todav&amp;iacute;a no se ha desasignado &lt;code&gt;self&lt;/code&gt; . Eso solo sucede despu&amp;eacute;s de que termina el m&amp;eacute;todo. Si este no fuera el caso, el &lt;code&gt;self&lt;/code&gt; ser&amp;iacute;a una referencia pendiente.</target>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="translated">Cuando este programa se ejecuta, comprueba cada expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; a su vez y ejecuta el primer cuerpo para el que la condici&amp;oacute;n es verdadera. Tenga en cuenta que aunque 6 es divisible por 2, no vemos que el &lt;code&gt;number is divisible by 2&lt;/code&gt; salida sea ​​divisible por 2 , ni vemos que el &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; texto del bloque &lt;code&gt;else&lt;/code&gt; . Eso es porque Rust solo ejecuta el bloque para la primera condici&amp;oacute;n verdadera, y una vez que encuentra una, ni siquiera verifica el resto.</target>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="translated">Cuándo usar el código inseguro</target>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="translated">Cuándo elegir la mutabilidad interior</target>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="translated">Al intentar hacer que alg&amp;uacute;n tipo implemente un rasgo &lt;code&gt;Foo&lt;/code&gt; , debe, como m&amp;iacute;nimo, proporcionar implementaciones para todos los m&amp;eacute;todos requeridos por &lt;code&gt;Foo&lt;/code&gt; (es decir, los m&amp;eacute;todos que no tienen implementaciones predeterminadas), as&amp;iacute; como cualquier elemento de rasgo requerido como tipos asociados o constantes. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa como un &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;&amp;iacute;ndice de corte&lt;/a&gt; , &lt;code&gt;RangeTo&lt;/code&gt; produce un corte de todos los elementos de la matriz antes del &amp;iacute;ndice indicado por &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">Cuando se utiliza como &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;&amp;iacute;ndice de &lt;/a&gt; &lt;code&gt;RangeToInclusive&lt;/code&gt; , RangeToInclusive produce una divisi&amp;oacute;n de todos los elementos de la matriz hasta el &amp;iacute;ndice indicado por &lt;code&gt;end&lt;/code&gt; inclusive .</target>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="translated">Cuando se usa como un elemento o una declaraci&amp;oacute;n, la forma &lt;em&gt;MacroInvocationSemi&lt;/em&gt; se usa donde se requiere un punto y coma al final cuando no se usan llaves. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Los calificadores de visibilidad&lt;/a&gt; nunca se permiten antes de una invocaci&amp;oacute;n de macro o &lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;macro_rules&lt;/code&gt; &lt;/a&gt; definici&amp;oacute;n de macro_rules .</target>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="translated">Cuando se usa en una &lt;a href=&quot;../items/traits&quot;&gt;declaraci&amp;oacute;n de rasgo&lt;/a&gt; , una &lt;a href=&quot;../expressions/call-expr&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de llamada de una &lt;a href=&quot;../statements#expression-statements&quot;&gt;declaraci&amp;oacute;n de expresi&amp;oacute;n&lt;/a&gt; a una funci&amp;oacute;n que devuelve un &lt;a href=&quot;../types/impl-trait&quot;&gt;rasgo impl&amp;iacute;cito&lt;/a&gt; de ese rasgo viola el lint &lt;code&gt;unused_must_use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="translated">Cuando se usa en una función en una declaración de un rasgo,entonces el comportamiento también se aplica cuando la expresión de la llamada es una función de una implementación del rasgo.</target>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="translated">Cuando se usa en una función en la implementación de un rasgo,el atributo no hace nada.</target>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">Cuando se usa en una funci&amp;oacute;n, si la &lt;a href=&quot;../expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de una &lt;a href=&quot;../statements#expression-statements&quot;&gt;declaraci&amp;oacute;n de expresi&amp;oacute;n&lt;/a&gt; es una &lt;a href=&quot;../expressions/call-expr&quot;&gt;expresi&amp;oacute;n de llamada&lt;/a&gt; a esa funci&amp;oacute;n, entonces se &lt;code&gt;unused_must_use&lt;/code&gt; lint unused_must_use .</target>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">Cuando se usa en tipos compuestos definidos por el usuario, si la &lt;a href=&quot;../expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de una &lt;a href=&quot;../statements#expression-statements&quot;&gt;declaraci&amp;oacute;n de expresi&amp;oacute;n&lt;/a&gt; tiene ese tipo, entonces se &lt;code&gt;unused_must_use&lt;/code&gt; lint unused_must_use .</target>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="translated">Cuando se usa con el especificador de formato alternativo &lt;code&gt;#?&lt;/code&gt; , la salida est&amp;aacute; bastante impresa.</target>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="translated">Cuando se usa &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; , puede darse el caso de que algunas de las variables cerradas no se desenrollen de forma segura. Por ejemplo, si se captura &lt;code&gt;&amp;amp;mut T&lt;/code&gt; el compilador generar&amp;aacute; una advertencia que indica que no se puede desenrollar de forma segura. Sin embargo, puede que no sea el caso que esto sea realmente un problema debido al uso espec&amp;iacute;fico de &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; si se tiene en cuenta espec&amp;iacute;ficamente la seguridad de desenrollado. Esta estructura contenedora es &amp;uacute;til para una anotaci&amp;oacute;n r&amp;aacute;pida y ligera de que una variable es segura para desenrollarse.</target>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="translated">Cuando use un futuro, generalmente no llamar&amp;aacute; a la &lt;code&gt;poll&lt;/code&gt; directamente, sino que &lt;code&gt;.await&lt;/code&gt; el valor.</target>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="translated">Cuando se usa una vida &amp;uacute;til como &lt;code&gt;'a&lt;/code&gt; en un tipo, debe declararse antes de usarse.</target>
        </trans-unit>
        <trans-unit id="68d4836a866e67a5b4af384a8eb471ccacc77a13" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt; to a &lt;code&gt;static&lt;/code&gt;. The &lt;a href=&quot;destructors#drop-scopes&quot;&gt;drop scope&lt;/a&gt; of the temporary is usually the end of the enclosing statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="translated">Cuando se usa una expresi&amp;oacute;n de valor en la mayor&amp;iacute;a de los contextos de expresi&amp;oacute;n de lugar, se crea una ubicaci&amp;oacute;n de memoria temporal sin nombre inicializada a ese valor y la expresi&amp;oacute;n se eval&amp;uacute;a en esa ubicaci&amp;oacute;n en su lugar, excepto si se promueve a &lt;code&gt;'static&lt;/code&gt; . La promoci&amp;oacute;n de una expresi&amp;oacute;n de valor a un espacio &lt;code&gt;'static&lt;/code&gt; produce cuando la expresi&amp;oacute;n se puede escribir en una constante, prestada y desreferenciada que toma prestada donde se escribi&amp;oacute; originalmente la expresi&amp;oacute;n, sin cambiar el comportamiento del tiempo de ejecuci&amp;oacute;n. Es decir, la expresi&amp;oacute;n promocionada se puede evaluar en tiempo de compilaci&amp;oacute;n y el valor resultante no contiene &lt;a href=&quot;interior-mutability&quot;&gt;mutabilidad interior&lt;/a&gt; o &lt;a href=&quot;destructors&quot;&gt;destructores&lt;/a&gt; (estas propiedades se determinan en funci&amp;oacute;n del valor cuando sea posible, por ejemplo, &lt;code&gt;&amp;amp;None&lt;/code&gt; siempre tiene el tipo &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt; , ya que no contiene nada rechazado). De lo contrario, la vida &amp;uacute;til de los valores temporales suele ser</target>
        </trans-unit>
        <trans-unit id="7387e6f07d50e4b94b03c5027eaa0a1074379c4f" translate="yes" xml:space="preserve">
          <source>When using an alias over a function type, you cannot e.g. denote a parameter as being mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa un rango inclusivo para la iteraci&amp;oacute;n, los valores de &lt;a href=&quot;#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;end()&lt;/code&gt; no se especifican una vez finalizada la iteraci&amp;oacute;n. Para determinar si el rango inclusivo est&amp;aacute; vac&amp;iacute;o, use el m&amp;eacute;todo &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; lugar de comparar &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a518969d6cf8add6a83ea03a0b5649d4f43920f2" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa un rango inclusivo para la iteraci&amp;oacute;n, los valores de &lt;code&gt;start()&lt;/code&gt; y &lt;a href=&quot;#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; no se especifican una vez finalizada la iteraci&amp;oacute;n. Para determinar si el rango inclusivo est&amp;aacute; vac&amp;iacute;o, use el m&amp;eacute;todo &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; lugar de comparar &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb0c63c5182e2af20d41eccf36aeeeb95780341" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="translated">Cuando se utilizan generadores (o asíncronos)todas las variables de tipo deben estar vinculadas para que se pueda construir un generador.</target>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="translated">Cuando utilice iteradores, a menudo encadenar&amp;aacute; varios de ellos. Mientras trabaja en dicho c&amp;oacute;digo, es posible que desee comprobar lo que est&amp;aacute; sucediendo en varias partes del proceso. Para hacer eso, inserte una llamada a &lt;code&gt;inspect()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="translated">Cuando se usa el atributo &lt;code&gt;#[simd]&lt;/code&gt; en una estructura de tupla, los componentes de la estructura de tupla deben ser todos de un tipo concreto y no gen&amp;eacute;rico para que el compilador pueda razonar sobre c&amp;oacute;mo usar SIMD con ellos. Este error ocurrir&amp;aacute; si los tipos son gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="translated">Cuando se usa el atributo &lt;code&gt;#[simd]&lt;/code&gt; en una estructura de tupla, los elementos de la tupla deben ser tipos de m&amp;aacute;quina para que las operaciones SIMD se les puedan aplicar.</target>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="translated">Cuando se usa el atributo &lt;code&gt;#[simd]&lt;/code&gt; para usar autom&amp;aacute;ticamente operaciones SIMD en la estructura de tupla, los tipos en la estructura deben ser todos del mismo tipo, o el compilador activar&amp;aacute; este error.</target>
        </trans-unit>
        <trans-unit id="8dd63b3b5f84a11f65877d582b3cb17771f94809" translate="yes" xml:space="preserve">
          <source>When using/declaring an item with generic arguments, you must provide the exact same number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="translated">Cuando asignamos &lt;code&gt;s1&lt;/code&gt; a &lt;code&gt;s2&lt;/code&gt; , los datos de la &lt;code&gt;String&lt;/code&gt; se copian, lo que significa que copiamos el puntero, la longitud y la capacidad que est&amp;aacute;n en la pila. No copiamos los datos en el mont&amp;oacute;n al que se refiere el puntero. En otras palabras, la representaci&amp;oacute;n de datos en la memoria se parece a la Figura 4-2.</target>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="translated">Cuando traemos un nombre al alcance con la palabra clave &lt;code&gt;use&lt;/code&gt; , el nombre disponible en el nuevo alcance es privado. Para permitir que el c&amp;oacute;digo que llama a nuestro c&amp;oacute;digo se refiera a ese nombre como si se hubiera definido en el alcance de ese c&amp;oacute;digo, podemos combinar &lt;code&gt;pub&lt;/code&gt; y &lt;code&gt;use&lt;/code&gt; . Esta t&amp;eacute;cnica se denomina &lt;em&gt;reexportaci&amp;oacute;n&lt;/em&gt; porque incorporamos un elemento al alcance, pero tambi&amp;eacute;n lo ponemos a disposici&amp;oacute;n de otros para que lo incluyan en su alcance.</target>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="translated">Cuando llamamos a &lt;code&gt;fly&lt;/code&gt; en una instancia de &lt;code&gt;Human&lt;/code&gt; , el compilador por defecto llama al m&amp;eacute;todo que se implementa directamente en el tipo, como se muestra en el Listado 19-17.</target>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Cuando llamamos a esta macro con &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; , el patr&amp;oacute;n &lt;code&gt;$x&lt;/code&gt; coincide tres veces con las tres expresiones &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7bba3d9da7852f6359cc6e672864f837a98a14" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get an error with this core message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="translated">Cuando compilamos este código,obtenemos el siguiente mensaje de error:</target>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="translated">Cuando compilamos este código,obtenemos este error:</target>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="translated">Cuando compilamos este ejemplo,obtenemos este error:</target>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Cuando creamos una nueva &lt;code&gt;Post&lt;/code&gt; , establecemos su campo de &lt;code&gt;state&lt;/code&gt; en un valor &lt;code&gt;Some&lt;/code&gt; que contiene un &lt;code&gt;Box&lt;/code&gt; . Este &lt;code&gt;Box&lt;/code&gt; apunta a una nueva instancia de la estructura &lt;code&gt;Draft&lt;/code&gt; . Esto asegura que cada vez que creamos una nueva instancia de &lt;code&gt;Post&lt;/code&gt; , comenzar&amp;aacute; como un borrador. Porque el campo de &lt;code&gt;state&lt;/code&gt; de &lt;code&gt;Post&lt;/code&gt; es privado, no hay forma de crear una &lt;code&gt;Post&lt;/code&gt; en ning&amp;uacute;n otro estado. En la funci&amp;oacute;n &lt;code&gt;Post::new&lt;/code&gt; , configuramos el campo de &lt;code&gt;content&lt;/code&gt; en una nueva &lt;code&gt;String&lt;/code&gt; vac&amp;iacute;a .</target>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="translated">Cuando creamos el nodo de la &lt;code&gt;branch&lt;/code&gt; , tambi&amp;eacute;n tendr&amp;aacute; una nueva referencia de &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; en el campo &lt;code&gt;parent&lt;/code&gt; , porque la &lt;code&gt;branch&lt;/code&gt; no tiene un nodo principal. Todav&amp;iacute;a tenemos a la &lt;code&gt;leaf&lt;/code&gt; como uno de los hijos de la &lt;code&gt;branch&lt;/code&gt; . Una vez que tenemos la instancia de &lt;code&gt;Node&lt;/code&gt; en la &lt;code&gt;branch&lt;/code&gt; , podemos modificar la &lt;code&gt;leaf&lt;/code&gt; para darle una referencia de &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; a su padre. Usamos el &lt;code&gt;borrow_mut&lt;/code&gt; m&amp;eacute;todo de pr&amp;eacute;stamo_mut en la &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; en el campo &lt;code&gt;parent&lt;/code&gt; de la &lt;code&gt;leaf&lt;/code&gt; , y luego usamos el &lt;code&gt;Rc::downgrade&lt;/code&gt; para crear un &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; referencia a la &lt;code&gt;branch&lt;/code&gt; desde el &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; en la &lt;code&gt;branch.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="translated">Cuando ingresamos &lt;code&gt;*y&lt;/code&gt; en el Listado 15-9, detr&amp;aacute;s de escena Rust ejecut&amp;oacute; este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="translated">Cuando &lt;em&gt;ingresamos&lt;/em&gt; el comando, Cargo cre&amp;oacute; un archivo &lt;em&gt;Cargo.toml&lt;/em&gt; , d&amp;aacute;ndonos un paquete. En cuanto al contenido de &lt;em&gt;Cargo.toml&lt;/em&gt; , no se menciona &lt;em&gt;src / main.rs&lt;/em&gt; porque Cargo sigue la convenci&amp;oacute;n de que &lt;em&gt;src / main.rs&lt;/em&gt; es la ra&amp;iacute;z de una caja binaria con el mismo nombre que el paquete. Asimismo, Cargo sabe que si el directorio del paquete contiene &lt;em&gt;src / lib.rs&lt;/em&gt; , el paquete contiene una caja de biblioteca con el mismo nombre que el paquete, y &lt;em&gt;src / lib.rs&lt;/em&gt; es la ra&amp;iacute;z de la caja. Cargo pasa los archivos ra&amp;iacute;z de la caja a &lt;code&gt;rustc&lt;/code&gt; para construir la biblioteca o el binario.</target>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="translated">Cuando tenemos un valor de &lt;code&gt;Some&lt;/code&gt; , sabemos que hay un valor presente y el valor se mantiene dentro de &lt;code&gt;Some&lt;/code&gt; . Cuando tenemos un &lt;code&gt;None&lt;/code&gt; valor None , en cierto sentido, significa lo mismo que null: no tenemos un valor v&amp;aacute;lido. Entonces, &amp;iquest;por qu&amp;eacute; tener &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; mejor que tener null?</target>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="translated">Cuando implementamos m&amp;eacute;todos en una estructura con tiempos de vida, usamos la misma sintaxis que la de los par&amp;aacute;metros de tipo gen&amp;eacute;rico que se muestran en el Listado 10-11. El lugar donde declaramos y usamos los par&amp;aacute;metros de duraci&amp;oacute;n depende de si est&amp;aacute;n relacionados con los campos de estructura o los par&amp;aacute;metros del m&amp;eacute;todo y los valores de retorno.</target>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">Cuando implementamos &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; , usamos el valor predeterminado para &lt;code&gt;RHS&lt;/code&gt; porque quer&amp;iacute;amos agregar dos instancias de &lt;code&gt;Point&lt;/code&gt; . Veamos un ejemplo de implementaci&amp;oacute;n de &lt;code&gt;Add&lt;/code&gt; rasgo donde queremos personalizar el &lt;code&gt;RHS&lt;/code&gt; tipo de RHS en lugar de usar el predeterminado.</target>
        </trans-unit>
        <trans-unit id="bbeae0b47ec877c608d0d21b1b80a717b1578283" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;Rhs&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;Rhs&lt;/code&gt; type rather than using the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="translated">Cuando miramos &lt;em&gt;src / main.rs&lt;/em&gt; nuevo, veremos que &lt;code&gt;cargo fix&lt;/code&gt; ha cambiado el c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="translated">Cuando creamos un nuevo proyecto de biblioteca con Cargo, se genera autom&amp;aacute;ticamente un m&amp;oacute;dulo de prueba con una funci&amp;oacute;n de prueba. Este m&amp;oacute;dulo lo ayuda a comenzar a escribir sus pruebas para que no tenga que buscar la estructura y sintaxis exacta de las funciones de prueba cada vez que comienza un nuevo proyecto. &amp;iexcl;Puede agregar tantas funciones de prueba adicionales y tantos m&amp;oacute;dulos de prueba como desee!</target>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Cuando pasamos referencias concretas a &lt;code&gt;longest&lt;/code&gt; , la vida &amp;uacute;til concreta que sustituye a &lt;code&gt;'a&lt;/code&gt; es la parte del alcance de &lt;code&gt;x&lt;/code&gt; que se superpone con el alcance de &lt;code&gt;y&lt;/code&gt; . En otras palabras, la vida gen&amp;eacute;rica &lt;code&gt;'a&lt;/code&gt; obtendr&amp;aacute; la vida &amp;uacute;til concreta que es igual a la vida m&amp;aacute;s peque&amp;ntilde;a de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Debido a que hemos anotado la referencia devuelta con el mismo par&amp;aacute;metro tiempo de vida &lt;code&gt;'a&lt;/code&gt; , la referencia devuelta tambi&amp;eacute;n ser&amp;aacute; v&amp;aacute;lida para la longitud de la m&amp;aacute;s peque&amp;ntilde;a de las vidas de &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="translated">Al imprimir &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , y &lt;code&gt;c&lt;/code&gt; , podemos ver que todos ellos tienen el valor modificado de 15 en lugar de 5:</target>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="translated">Al imprimir el padre de &lt;code&gt;leaf&lt;/code&gt; nuevo, esta vez vamos a tener una &lt;code&gt;Some&lt;/code&gt; variante de la celebraci&amp;oacute;n de &lt;code&gt;branch&lt;/code&gt; : ahora &lt;code&gt;leaf&lt;/code&gt; puede acceder a su padre! Cuando imprimimos &lt;code&gt;leaf&lt;/code&gt; , tambi&amp;eacute;n evitamos el ciclo que finalmente termin&amp;oacute; en un desbordamiento de pila como el que ten&amp;iacute;amos en el Listado 15-26; las referencias de &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; se imprimen como &lt;code&gt;(Weak)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="translated">Cuando ejecutamos &lt;code&gt;cargo doc --open&lt;/code&gt; , estos comentarios se mostrar&amp;aacute;n en la p&amp;aacute;gina principal de la documentaci&amp;oacute;n de &lt;code&gt;my_crate&lt;/code&gt; encima de la lista de elementos p&amp;uacute;blicos en la caja, como se muestra en la Figura 14-2:</target>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="translated">Cuando ejecutamos el c&amp;oacute;digo en el Listado 16-8, veremos el valor impreso desde el hilo principal:</target>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="translated">Cuando ejecutamos el programa ahora,obtenemos esto:</target>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="translated">Cuando hagamos la prueba en la Lista 11-8,fallará:</target>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="translated">Cuando volvamos a ejecutar las pruebas, veremos una nueva secci&amp;oacute;n en el resultado de la prueba para el archivo &lt;em&gt;common.rs&lt;/em&gt; , aunque este archivo no contiene ninguna funci&amp;oacute;n de prueba ni llamamos a la funci&amp;oacute;n de &lt;code&gt;setup&lt;/code&gt; desde cualquier lugar:</target>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">Cuando ejecutamos las pruebas en el Listado 11-10 nuevamente con el indicador &lt;code&gt;--nocapture&lt;/code&gt; , vemos el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="35bd5db3d4e7561ab5f23e824a5b461601f0023a" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--show-output&lt;/code&gt; flag, we see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Cuando ejecutamos estas pruebas con &lt;code&gt;cargo test&lt;/code&gt; , veremos el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="translated">Cuando ejecutamos este c&amp;oacute;digo con el &lt;code&gt;main&lt;/code&gt; funci&amp;oacute;n Listado 5-14, obtendremos el resultado deseado. Los m&amp;eacute;todos pueden tomar m&amp;uacute;ltiples par&amp;aacute;metros que agregamos a la firma despu&amp;eacute;s del &lt;code&gt;self&lt;/code&gt; par&amp;aacute;metro , y esos par&amp;aacute;metros funcionan como los par&amp;aacute;metros de las funciones.</target>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="translated">Cuando ejecutamos este c&amp;oacute;digo, manteniendo el &amp;uacute;ltimo &lt;code&gt;println!&lt;/code&gt; comentado por el momento, obtendremos este resultado:</target>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="translated">Cuando ejecutamos este c&amp;oacute;digo, el primer m&amp;eacute;todo &lt;code&gt;[]&lt;/code&gt; har&amp;aacute; que el programa entre en p&amp;aacute;nico porque hace referencia a un elemento inexistente. Este m&amp;eacute;todo se usa mejor cuando desea que su programa se bloquee si hay un intento de acceder a un elemento m&amp;aacute;s all&amp;aacute; del final del vector.</target>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="translated">Cuando ejecutamos este código,obtenemos un error con este mensaje central:</target>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="translated">Cuando ejecutamos este c&amp;oacute;digo, veremos el mismo resultado que en el Listado 3-4. M&amp;aacute;s importante a&amp;uacute;n, ahora hemos aumentado la seguridad del c&amp;oacute;digo y eliminado la posibilidad de errores que podr&amp;iacute;an resultar de ir m&amp;aacute;s all&amp;aacute; del final de la matriz o no ir lo suficientemente lejos y perder algunos elementos.</target>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="translated">Cuando ejecutemos este programa, &amp;iexcl;veremos de &lt;code&gt;again!&lt;/code&gt; impreso una y otra vez continuamente hasta que detengamos el programa manualmente. La mayor&amp;iacute;a de los terminales admiten un atajo de teclado, ctrl-c, para interrumpir un programa que est&amp;aacute; atascado en un bucle continuo. Darle una oportunidad:</target>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Cuando ejecutamos este programa, veremos el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="translated">Cuando intentamos comprobar este código,obtenemos este error:</target>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="translated">Cuando intentemos compilar el c&amp;oacute;digo del Listado 19-5, obtendremos un error.</target>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="translated">Cuando intentemos compilar este c&amp;oacute;digo, obtendremos un error. Los brazos &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; tienen tipos de valor que son incompatibles, y Rust indica exactamente d&amp;oacute;nde encontrar el problema en el programa:</target>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Cuando intentemos compilar este c&amp;oacute;digo, obtendremos este error:</target>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="translated">Cuando usamos un par&amp;aacute;metro en el cuerpo de la funci&amp;oacute;n, tenemos que declarar el nombre del par&amp;aacute;metro en la firma para que el compilador sepa qu&amp;eacute; significa ese nombre. De manera similar, cuando usamos un nombre de par&amp;aacute;metro de tipo en la firma de una funci&amp;oacute;n, tenemos que declarar el nombre del par&amp;aacute;metro de tipo antes de usarlo. Para definir la funci&amp;oacute;n gen&amp;eacute;rica &lt;code&gt;largest&lt;/code&gt; , coloque las declaraciones de nombre de tipo dentro de los corchetes angulares, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , entre el nombre de la funci&amp;oacute;n y la lista de par&amp;aacute;metros, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="translated">Cuando usamos par&amp;aacute;metros de tipo gen&amp;eacute;rico, podemos especificar un tipo concreto predeterminado para el tipo gen&amp;eacute;rico. Esto elimina la necesidad de que los implementadores del rasgo especifiquen un tipo concreto si el tipo predeterminado funciona. La sintaxis para especificar un tipo predeterminado para un tipo gen&amp;eacute;rico es &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; al declarar el tipo gen&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="translated">Cuando usamos objetos de rasgo, Rust debe usar el despacho din&amp;aacute;mico. El compilador no conoce todos los tipos que podr&amp;iacute;an usarse con el c&amp;oacute;digo que usa objetos de rasgo, por lo que no sabe qu&amp;eacute; m&amp;eacute;todo implementado en qu&amp;eacute; tipo llamar. En cambio, en tiempo de ejecuci&amp;oacute;n, Rust usa los punteros dentro del objeto de rasgo para saber a qu&amp;eacute; m&amp;eacute;todo llamar. Hay un costo de tiempo de ejecuci&amp;oacute;n cuando ocurre esta b&amp;uacute;squeda que no ocurre con el env&amp;iacute;o est&amp;aacute;tico. El env&amp;iacute;o din&amp;aacute;mico tambi&amp;eacute;n evita que el compilador elija insertar el c&amp;oacute;digo de un m&amp;eacute;todo, lo que a su vez evita algunas optimizaciones. Sin embargo, obtuvimos una flexibilidad adicional en el c&amp;oacute;digo que escribimos en el Listado 17-5 y pudimos admitirlo en el Listado 17-9, por lo que es una compensaci&amp;oacute;n a considerar.</target>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="translated">Cuando escribimos la biblioteca, no sab&amp;iacute;amos que alguien podr&amp;iacute;a agregar el tipo &lt;code&gt;SelectBox&lt;/code&gt; , pero nuestra implementaci&amp;oacute;n de &lt;code&gt;Screen&lt;/code&gt; pudo operar en el nuevo tipo y dibujarlo porque &lt;code&gt;SelectBox&lt;/code&gt; implementa el rasgo &lt;code&gt;Draw&lt;/code&gt; , lo que significa que implementa el m&amp;eacute;todo &lt;code&gt;draw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="translated">Cuando definimos esta funci&amp;oacute;n, no conocemos los valores concretos que se pasar&amp;aacute;n a esta funci&amp;oacute;n, por lo que no sabemos si se ejecutar&amp;aacute; el caso &lt;code&gt;if&lt;/code&gt; o el caso &lt;code&gt;else&lt;/code&gt; . Tampoco conocemos la duraci&amp;oacute;n concreta de las referencias que se pasar&amp;aacute;n, por lo que no podemos mirar los alcances como hicimos en los listados 10-18 y 10-19 para determinar si la referencia que devolvemos siempre ser&amp;aacute; v&amp;aacute;lida. . El corrector de pr&amp;eacute;stamo no puede determinar esto tampoco, porque no sabe c&amp;oacute;mo las vidas de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; se refieren a la vida &amp;uacute;til del valor de retorno. Para corregir este error, agregaremos par&amp;aacute;metros de duraci&amp;oacute;n gen&amp;eacute;ricos que definen la relaci&amp;oacute;n entre las referencias para que el verificador de pr&amp;eacute;stamos pueda realizar su an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="2b0ee241a22dde4f8299858560fbc384d292c571" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">Cuando se trabaja con estructuras ancladas, surge la pregunta de c&amp;oacute;mo se puede acceder a los campos de esa estructura en un m&amp;eacute;todo que solo toma &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; . El enfoque habitual es escribir m&amp;eacute;todos auxiliares (las llamadas &lt;em&gt;proyecciones&lt;/em&gt; ) que convierten &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; en una referencia al campo, pero &amp;iquest;qu&amp;eacute; tipo deber&amp;iacute;a tener esa referencia? &amp;iquest;Es &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ? La misma pregunta surge con los campos de una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n , y tambi&amp;eacute;n cuando se consideran tipos de contenedor / envoltorio como &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;. (Esta pregunta se aplica tanto a referencias mutables como compartidas, solo usamos el caso m&amp;aacute;s com&amp;uacute;n de referencias mutables aqu&amp;iacute; como ilustraci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="translated">Cuando se escribe más allá del final del archivo,éste se extiende adecuadamente y los bytes intermedios se inicializan con el valor 0.</target>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="translated">Cuando se escribe más allá del final del archivo,éste se extiende apropiadamente y los bytes intermedios se dejan sin inicializar.</target>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">Al escribir c&amp;oacute;digo que llama a muchas funciones que devuelven el tipo de &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; , el manejo de errores puede ser tedioso. El operador de signo de interrogaci&amp;oacute;n, &lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;, esconde algunos de los est&amp;aacute;ndares de propagaci&amp;oacute;n de errores en la pila de llamadas.</target>
        </trans-unit>
        <trans-unit id="fd3f2291c33fd3018ecb6b461f1a771659ef7d7e" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="translated">Al escribir pruebas unitarias para un m&amp;oacute;dulo, a menudo es un idioma com&amp;uacute;n tener un hijo inmediato del m&amp;oacute;dulo que se va a probar llamado &lt;code&gt;mod test&lt;/code&gt; . Este m&amp;oacute;dulo podr&amp;iacute;a acceder a cualquier elemento del m&amp;oacute;dulo principal a trav&amp;eacute;s del segundo caso, lo que significa que los detalles de implementaci&amp;oacute;n interna tambi&amp;eacute;n podr&amp;iacute;an probarse sin problemas desde el m&amp;oacute;dulo secundario.</target>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">Al escribir sus propios rasgos &lt;code&gt;!&lt;/code&gt; &amp;iexcl;deber&amp;iacute;a tener un &lt;code&gt;impl&lt;/code&gt; siempre que haya un &lt;code&gt;impl&lt;/code&gt; obvio que no entre en &lt;code&gt;panic!&lt;/code&gt; . Como resultado, la mayor&amp;iacute;a de los rasgos pueden tener un &lt;code&gt;impl&lt;/code&gt; para &lt;code&gt;!&lt;/code&gt; . Tome &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b06c46c776108f6df59bce40c78afdd8aa807784" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. The reason is that functions returning an &lt;code&gt;impl Trait&lt;/code&gt; where &lt;code&gt;!&lt;/code&gt; does not have an &lt;code&gt;impl&lt;/code&gt; of &lt;code&gt;Trait&lt;/code&gt; cannot diverge as their only possible code path. In other words, they can't return &lt;code&gt;!&lt;/code&gt; from every code path. As an example, this code doesn't compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">Cuando &lt;em&gt;no&lt;/em&gt; desea actualizar una caja, Transporte proporciona otro comando, &lt;code&gt;update&lt;/code&gt; , que ignorar&amp;aacute; la &lt;em&gt;Cargo.lock&lt;/em&gt; archivo y averiguar todas las &amp;uacute;ltimas versiones que se ajusten a sus especificaciones en &lt;em&gt;Cargo.toml&lt;/em&gt; . Si eso funciona, Cargo escribir&amp;aacute; esas versiones en el archivo &lt;em&gt;Cargo.lock&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="translated">Cuando llama a un m&amp;eacute;todo con la sintaxis &lt;code&gt;.foo()&lt;/code&gt; , a menudo es aconsejable introducir una nueva l&amp;iacute;nea y otros espacios en blanco para ayudar a dividir las l&amp;iacute;neas largas. Podr&amp;iacute;amos haber escrito este c&amp;oacute;digo como:</target>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Cuando crea un cierre, Rust infiere qu&amp;eacute; rasgo usar en funci&amp;oacute;n de c&amp;oacute;mo el cierre usa los valores del entorno. Todos los cierres implementan &lt;code&gt;FnOnce&lt;/code&gt; porque todos se pueden llamar al menos una vez. Los cierres que no mueven las variables capturadas tambi&amp;eacute;n implementan &lt;code&gt;FnMut&lt;/code&gt; , y los cierres que no necesitan acceso mutable a las variables capturadas tambi&amp;eacute;n implementan &lt;code&gt;Fn&lt;/code&gt; . En el Listado 13-12, el cierre &lt;code&gt;equal_to_x&lt;/code&gt; toma prestado &lt;code&gt;x&lt;/code&gt; de manera inmutable (por lo que &lt;code&gt;equal_to_x&lt;/code&gt; tiene el rasgo &lt;code&gt;Fn&lt;/code&gt; ) porque el cuerpo del cierre solo necesita leer el valor en &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="translated">Cuando tiene una gran cantidad de datos y desea transferir la propiedad, pero aseg&amp;uacute;rese de que los datos no se copiar&amp;aacute;n cuando lo haga</target>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="translated">Cuando tiene un tipo cuyo tama&amp;ntilde;o no se puede conocer en tiempo de compilaci&amp;oacute;n y desea utilizar un valor de ese tipo en un contexto que requiere un tama&amp;ntilde;o exacto</target>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="translated">Cuando se reconocen situaciones en el código con múltiples definiciones de estructura o enumeración que difieren sólo en los tipos de los valores que contienen,se puede evitar la duplicación utilizando en su lugar tipos genéricos.</target>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="translated">Cuando vuelva a ejecutar &lt;code&gt;cargo check&lt;/code&gt; , recibir&amp;aacute; algunas advertencias m&amp;aacute;s, pero deber&amp;iacute;a tener &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="translated">Cuando lo ejecutes, no obtendr&amp;aacute;s la ruta del ejecutable original, obtendr&amp;aacute;s la ruta del enlace f&amp;iacute;sico:</target>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="translated">Cuando ejecuta varias pruebas, de forma predeterminada se ejecutan en paralelo mediante subprocesos. Esto significa que las pruebas terminar&amp;aacute;n de ejecutarse m&amp;aacute;s r&amp;aacute;pido para que pueda obtener comentarios m&amp;aacute;s r&amp;aacute;pido sobre si su c&amp;oacute;digo est&amp;aacute; funcionando o no. Debido a que las pruebas se ejecutan al mismo tiempo, aseg&amp;uacute;rese de que sus pruebas no dependan entre s&amp;iacute; ni de ning&amp;uacute;n estado compartido, incluido un entorno compartido, como el directorio de trabajo actual o las variables de entorno.</target>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="translated">Cuando ejecutas el código,tu salida debería ser algo como esto:</target>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="translated">Cuando ejecute el programa, ver&amp;aacute; algo como esto:</target>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="translated">Cuando ejecute este código,se compilará pero mostrará una advertencia:</target>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="translated">Cuando ejecuta este programa, el error que obtendr&amp;aacute; se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="translated">Cuando ve una llamada para &lt;code&gt;clone&lt;/code&gt; , sabe que se est&amp;aacute; ejecutando alg&amp;uacute;n c&amp;oacute;digo arbitrario y ese c&amp;oacute;digo puede ser costoso. Es un indicador visual de que est&amp;aacute; sucediendo algo diferente.</target>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="translated">Cuando comprenda la propiedad, tendr&amp;aacute; una base s&amp;oacute;lida para comprender las caracter&amp;iacute;sticas que hacen que Rust sea &amp;uacute;nico. En este cap&amp;iacute;tulo, aprender&amp;aacute; sobre la propiedad al trabajar con algunos ejemplos que se centran en una estructura de datos muy com&amp;uacute;n: cadenas.</target>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="translated">Cuando quiera que una función tenga varios parámetros,separe las declaraciones de los parámetros con comas,así:</target>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="translated">Cuando desea poseer un valor y solo le importa que sea un tipo que implemente un rasgo particular en lugar de ser de un tipo espec&amp;iacute;fico</target>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando compila en modo de lanzamiento con el indicador &lt;code&gt;--release&lt;/code&gt; , Rust &lt;em&gt;no&lt;/em&gt; incluye comprobaciones de desbordamiento de enteros que causan p&amp;aacute;nico. En cambio, si se produce un desbordamiento, Rust realiza &lt;em&gt;la envoltura en complemento a dos&lt;/em&gt; . En resumen, los valores mayores que el valor m&amp;aacute;ximo que el tipo puede contener &quot;envuelven&quot; al m&amp;iacute;nimo de los valores que el tipo puede contener. En el caso de a &lt;code&gt;u8&lt;/code&gt; , 256 se convierte en 0, 257 se convierte en 1, y as&amp;iacute; sucesivamente. El programa no entrar&amp;aacute; en p&amp;aacute;nico, pero la variable tendr&amp;aacute; un valor que probablemente no sea el que esperaba que tuviera. Confiar en el comportamiento de envoltura del desbordamiento de enteros se considera un error. Si desea ajustar expl&amp;iacute;citamente, puede utilizar el tipo de biblioteca est&amp;aacute;ndar &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt; &lt;code&gt;Wrapping&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="translated">Cuando haya terminado con los datos que protege el mutex, debe desbloquear los datos para que otros subprocesos puedan adquirir el bloqueo.</target>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="translated">Cuando est&amp;eacute; listo para seguir adelante, hablaremos sobre un concepto en Rust que &lt;em&gt;no&lt;/em&gt; existe com&amp;uacute;nmente en otros lenguajes de programaci&amp;oacute;n: propiedad.</target>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="translated">Cuando escribe una funci&amp;oacute;n cuya implementaci&amp;oacute;n llama a algo que podr&amp;iacute;a fallar, en lugar de manejar el error dentro de esta funci&amp;oacute;n, puede devolver el error al c&amp;oacute;digo de llamada para que pueda decidir qu&amp;eacute; hacer. Esto se conoce como &lt;em&gt;propagaci&amp;oacute;n&lt;/em&gt; del error y le da m&amp;aacute;s control al c&amp;oacute;digo de llamada, donde puede haber m&amp;aacute;s informaci&amp;oacute;n o l&amp;oacute;gica que dicta c&amp;oacute;mo se debe manejar el error que lo que tiene disponible en el contexto de su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="translated">Cuando escribe un programa, si no conoce el conjunto exhaustivo de tipos que el programa obtendr&amp;aacute; en tiempo de ejecuci&amp;oacute;n para almacenarlo en un vector, la t&amp;eacute;cnica de enumeraci&amp;oacute;n no funcionar&amp;aacute;. En su lugar, puede usar un objeto de rasgo, que cubriremos en el Cap&amp;iacute;tulo 17.</target>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="translated">Cuando est&amp;aacute; escribiendo un ejemplo para ilustrar alg&amp;uacute;n concepto, tener un c&amp;oacute;digo robusto de manejo de errores en el ejemplo tambi&amp;eacute;n puede hacer que el ejemplo sea menos claro. En los ejemplos, se entiende que una llamada a un m&amp;eacute;todo como &lt;code&gt;unwrap&lt;/code&gt; que podr&amp;iacute;a entrar en p&amp;aacute;nico se entiende como un marcador de posici&amp;oacute;n para la forma en que desea que su aplicaci&amp;oacute;n maneje los errores, que pueden diferir seg&amp;uacute;n lo que est&amp;aacute; haciendo el resto de su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="translated">Cuando haya realizado cambios en su caja y est&amp;eacute; listo para lanzar una nueva versi&amp;oacute;n, cambie el valor de &lt;code&gt;version&lt;/code&gt; especificado en su archivo &lt;em&gt;Cargo.toml&lt;/em&gt; y &lt;em&gt;vuelva a&lt;/em&gt; publicarlo. Utilice las &lt;a href=&quot;http://semver.org/&quot;&gt;reglas de control de versiones sem&amp;aacute;ntico&lt;/a&gt; para decidir cu&amp;aacute;l es el n&amp;uacute;mero de versi&amp;oacute;n siguiente apropiado seg&amp;uacute;n los tipos de cambios que ha realizado. Luego ejecute &lt;code&gt;cargo publish&lt;/code&gt; para cargar la nueva versi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a63fa0940baafe694284e32babae3f74d6ff198c" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a2affd429f9e55f7202252260760e859abffb5" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="translated">Cuando su c&amp;oacute;digo llama a una funci&amp;oacute;n, los valores pasados ​​a la funci&amp;oacute;n (incluidos, potencialmente, punteros a los datos en el mont&amp;oacute;n) y las variables locales de la funci&amp;oacute;n se insertan en la pila. Cuando la funci&amp;oacute;n termina, esos valores se eliminan de la pila.</target>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="translated">Cuando su c&amp;oacute;digo realiza operaciones con valores, su c&amp;oacute;digo debe verificar que los valores sean v&amp;aacute;lidos primero y entrar en p&amp;aacute;nico si los valores no son v&amp;aacute;lidos. Esto se debe principalmente a razones de seguridad: intentar operar con datos no v&amp;aacute;lidos puede exponer su c&amp;oacute;digo a vulnerabilidades. &amp;iexcl;Esta es la raz&amp;oacute;n principal por la que la biblioteca est&amp;aacute;ndar llamar&amp;aacute; &lt;code&gt;panic!&lt;/code&gt; si intenta un acceso a la memoria fuera de los l&amp;iacute;mites: intentar acceder a la memoria que no pertenece a la estructura de datos actual es un problema de seguridad com&amp;uacute;n. Las funciones suelen tener &lt;em&gt;contratos&lt;/em&gt;: su comportamiento solo est&amp;aacute; garantizado si las entradas cumplen unos requisitos particulares. Entrar en p&amp;aacute;nico cuando se viola el contrato tiene sentido porque una violaci&amp;oacute;n del contrato siempre indica un error del lado de la persona que llama y no es un tipo de error que desee que el c&amp;oacute;digo de llamada tenga que manejar expl&amp;iacute;citamente. De hecho, no existe una forma razonable de recuperar el c&amp;oacute;digo de llamada; los &lt;em&gt;programadores que&lt;/em&gt; llaman necesitan arreglar el c&amp;oacute;digo. Los contratos para una funci&amp;oacute;n, especialmente cuando una infracci&amp;oacute;n provocar&amp;aacute; p&amp;aacute;nico, deben explicarse en la documentaci&amp;oacute;n de la API para la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="translated">Cuando su proyecto est&amp;eacute; finalmente listo para su lanzamiento, puede usar &lt;code&gt;cargo build --release&lt;/code&gt; para compilarlo con optimizaciones. Este comando crear&amp;aacute; un ejecutable en &lt;em&gt;target / release en&lt;/em&gt; lugar de &lt;em&gt;target / debug&lt;/em&gt; . Las optimizaciones hacen que su c&amp;oacute;digo de Rust se ejecute m&amp;aacute;s r&amp;aacute;pido, pero activarlas alarga el tiempo que tarda su programa en compilarse. Es por eso que hay dos perfiles diferentes: uno para el desarrollo, cuando desea reconstruir r&amp;aacute;pidamente y con frecuencia, y otro para construir el programa final que le dar&amp;aacute; a un usuario que no se reconstruir&amp;aacute; repetidamente y que se ejecutar&amp;aacute; tan r&amp;aacute;pido como posible. Si est&amp;aacute; &lt;code&gt;cargo build --release&lt;/code&gt; tiempo de ejecuci&amp;oacute;n de su c&amp;oacute;digo, aseg&amp;uacute;rese de ejecutar cargo build --release y benchmark con el ejecutable en &lt;em&gt;target / release&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="translated">Siempre que se crea un temporal, se elimina (libera) autom&amp;aacute;ticamente de acuerdo con reglas fijas. Normalmente, el temporal se elimina al final de la declaraci&amp;oacute;n adjunta, en este caso, despu&amp;eacute;s de &lt;code&gt;let&lt;/code&gt; . Esto se ilustra en el ejemplo anterior mostrando que &lt;code&gt;tmp&lt;/code&gt; se liberar&amp;iacute;a cuando sali&amp;eacute;ramos del bloque.</target>
        </trans-unit>
        <trans-unit id="0d66101f5b82c22f64225217f832b8e7af03aba9" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3c7f91ce843a180fc6f430d195fed72f860109" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Siempre que sea posible, es preferible utilizar &lt;a href=&quot;#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; en su lugar, lo que evita duplicar el contenido de &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="translated">Donde las cláusulas</target>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="translated">&amp;iquest;D&amp;oacute;nde est&amp;aacute; el &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operador?</target>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="translated">La evaluación de las subexpresiones al evaluar la expresión</target>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="translated">&amp;iexcl;Uf! Ahora tiene algunas funciones de Rust en su caja de herramientas que no usar&amp;aacute; con frecuencia, pero sabr&amp;aacute; que est&amp;aacute;n disponibles en circunstancias muy particulares. Hemos introducido varios temas complejos para que cuando los encuentre en sugerencias de mensajes de error o en el c&amp;oacute;digo de otras personas, pueda reconocer estos conceptos y sintaxis. Utilice este cap&amp;iacute;tulo como referencia para encontrar soluciones.</target>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="translated">&amp;iexcl;Uf! Eso fue mucho trabajo, pero nos hemos preparado para el &amp;eacute;xito en el futuro. Ahora es mucho m&amp;aacute;s f&amp;aacute;cil manejar los errores y hemos hecho el c&amp;oacute;digo m&amp;aacute;s modular. Casi todo nuestro trabajo se realizar&amp;aacute; en &lt;em&gt;src / lib.rs&lt;/em&gt; de aqu&amp;iacute; en adelante.</target>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="translated">&amp;iexcl;Uf! Nosotros &lt;em&gt;tambi&amp;eacute;n&lt;/em&gt; no podemos tener una referencia mutable, mientras que tenemos una inmutable. &amp;iexcl;Los usuarios de una referencia inmutable no esperan que los valores cambien repentinamente por debajo de ellos! Sin embargo, varias referencias inmutables est&amp;aacute;n bien porque nadie que solo est&amp;eacute; leyendo los datos tiene la capacidad de afectar la lectura de los datos de otra persona.</target>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="translated">Las opciones de configuraci&amp;oacute;n establecidas se determinan est&amp;aacute;ticamente durante la compilaci&amp;oacute;n de la caja. Algunas opciones se establecen en el &lt;em&gt;compilador&lt;/em&gt; seg&amp;uacute;n los datos sobre la compilaci&amp;oacute;n. Otras opciones se establecen &lt;em&gt;arbitrariamente&lt;/em&gt; , se establecen en funci&amp;oacute;n de la entrada pasada al compilador fuera del c&amp;oacute;digo. No es posible establecer una opci&amp;oacute;n de configuraci&amp;oacute;n desde el c&amp;oacute;digo fuente de la caja que se est&amp;aacute; compilando.</target>
        </trans-unit>
        <trans-unit id="aec19e71f7245e5468afe6ba28062c55126000f9" translate="yes" xml:space="preserve">
          <source>Which kind of future are we turning this into?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e64a82a5b16af1f23a177677675bfbfea39f34c" translate="yes" xml:space="preserve">
          <source>Which kind of iterator are we turning this into?</source>
          <target state="translated">¿En qué clase de iterador estamos convirtiendo esto?</target>
        </trans-unit>
        <trans-unit id="0807125208cee959762c24f1a5a66bea0dc3bb1c" translate="yes" xml:space="preserve">
          <source>Which method works best depends on what kind of situation you're in.</source>
          <target state="translated">El método que mejor funciona depende de la situación en la que te encuentres.</target>
        </trans-unit>
        <trans-unit id="f77bbb1b800fe27a58f9b1a9edd741074b14ca16" translate="yes" xml:space="preserve">
          <source>Which of our two &lt;code&gt;HasDrop&lt;/code&gt; drops first, though? For structs, it's the same order that they're declared: first &lt;code&gt;one&lt;/code&gt;, then &lt;code&gt;two&lt;/code&gt;. If you'd like to try this yourself, you can modify &lt;code&gt;HasDrop&lt;/code&gt; above to contain some data, like an integer, and then use it in the &lt;code&gt;println!&lt;/code&gt; inside of &lt;code&gt;Drop&lt;/code&gt;. This behavior is guaranteed by the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381bdae639e5c41f0066a4ced8cdfc3fa580e603" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; is very useful for removing errors, &lt;code&gt;!&lt;/code&gt; can also be used to remove successes as well. If we think of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; as &quot;if this function returns, it has not errored,&quot; we get a very intuitive idea of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; as well: if the function returns, it &lt;em&gt;has&lt;/em&gt; errored.</source>
          <target state="translated">Mientras que &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; Es muy &amp;uacute;til para eliminar errores &lt;code&gt;!&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para eliminar &amp;eacute;xitos. Si pensamos en &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; Como &quot;si esta funci&amp;oacute;n regresa, no tiene errores&quot;, obtenemos una idea muy intuitiva de &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n: si la funci&amp;oacute;n regresa, &lt;em&gt;tiene&lt;/em&gt; errores.</target>
        </trans-unit>
        <trans-unit id="040144073c8f0dfdb2720a3a96450c0f97978b7d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;MaybeUninit&lt;/code&gt; is &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (indicating it guarantees the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;), this does &lt;em&gt;not&lt;/em&gt; change any of the previous caveats. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; may still have different sizes, and types containing a field of type &lt;code&gt;T&lt;/code&gt; may be laid out (and sized) differently than if that field were &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MaybeUninit&lt;/code&gt; is a union type, and &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions is unstable (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;the tracking issue&lt;/a&gt;). Over time, the exact guarantees of &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions may evolve, and &lt;code&gt;MaybeUninit&lt;/code&gt; may or may not remain &lt;code&gt;#[repr(transparent)]&lt;/code&gt;. That said, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; guarantee that it has the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;; it's just that the way &lt;code&gt;MaybeUninit&lt;/code&gt; implements that guarantee may evolve.</source>
          <target state="translated">Si bien &lt;code&gt;MaybeUninit&lt;/code&gt; es &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (lo que indica que garantiza el mismo tama&amp;ntilde;o, alineaci&amp;oacute;n y ABI que &lt;code&gt;T&lt;/code&gt; ), esto &lt;em&gt;no&lt;/em&gt; cambia ninguna de las advertencias anteriores. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; a&amp;uacute;n pueden tener diferentes tama&amp;ntilde;os, y los tipos que contienen un campo de tipo &lt;code&gt;T&lt;/code&gt; pueden tener un &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; (y tama&amp;ntilde;o) diferente que si ese campo fuera MaybeUninit &amp;lt;T&amp;gt; . &lt;code&gt;MaybeUninit&lt;/code&gt; es un tipo de uni&amp;oacute;n y &lt;code&gt;#[repr(transparent)]&lt;/code&gt; en las uniones es inestable (consulte &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;el problema de seguimiento&lt;/a&gt; ). Con el tiempo, las garant&amp;iacute;as exactas de &lt;code&gt;#[repr(transparent)]&lt;/code&gt; sobre los sindicatos pueden evolucionar, y &lt;code&gt;MaybeUninit&lt;/code&gt; puede o no permanecer &lt;code&gt;#[repr(transparent)]&lt;/code&gt; . Dicho esto, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; ser&amp;aacute; &lt;em&gt;siempre&lt;/em&gt; garantizar que tiene el mismo tama&amp;ntilde;o, alineaci&amp;oacute;n y ABI como &lt;code&gt;T&lt;/code&gt; ; es solo que la forma en que &lt;code&gt;MaybeUninit&lt;/code&gt; implementa esa garant&amp;iacute;a puede evolucionar.</target>
        </trans-unit>
        <trans-unit id="b5f05e101ccc42742a41d22d19ff794b2f1ec6bc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TypeId&lt;/code&gt; implements &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;, it is worth noting that the hashes and ordering will vary between Rust releases. Beware of relying on them inside of your code!</source>
          <target state="translated">Si bien &lt;code&gt;TypeId&lt;/code&gt; implementa &lt;code&gt;Hash&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; , vale la pena se&amp;ntilde;alar que los hash y el orden variar&amp;aacute;n entre las versiones de Rust. &amp;iexcl;Tenga cuidado de confiar en ellos dentro de su c&amp;oacute;digo!</target>
        </trans-unit>
        <trans-unit id="6d4c0b858b921a1aa9b09d6f6ffff138728f277d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;mem::forget&lt;/code&gt; can also be used to transfer &lt;em&gt;memory&lt;/em&gt; ownership, doing so is error-prone. &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; should be used instead. Consider, for example, this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef43e2f499fb4e7ebf44c6c96560fe3863b368a0" translate="yes" xml:space="preserve">
          <source>While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.</source>
          <target state="translated">Mientras que las cuerdas de óxido pueden contener nulos bytes en el medio,las cuerdas de Do no pueden,ya que ese byte truncaría efectivamente la cuerda.</target>
        </trans-unit>
        <trans-unit id="9b96c7bdcb6a7fde4fa090bcc724c51dcf154ff7" translate="yes" xml:space="preserve">
          <source>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be &quot;bridging&quot; some Windows APIs together, just passing &lt;code&gt;WCHAR&lt;/code&gt; strings among those APIs without ever really looking into the strings.</source>
          <target state="translated">Si bien no siempre es posible convertir una cadena de este tipo sin p&amp;eacute;rdidas en una cadena UTF-16 v&amp;aacute;lida (o incluso UTF-8), a menudo es deseable poder realizar un viaje de ida y vuelta desde y hacia las API de Windows sin p&amp;eacute;rdidas. Por ejemplo, algunos c&amp;oacute;digos de Rust pueden estar &quot;uniendo&quot; algunas API de Windows, simplemente pasando cadenas &lt;code&gt;WCHAR&lt;/code&gt; entre esas API sin siquiera mirar realmente las cadenas.</target>
        </trans-unit>
        <trans-unit id="94ebb9d6a417c21d0e98155c75c39327ba03733c" translate="yes" xml:space="preserve">
          <source>While it might seem strange to have a function that just returns back the input, there are some interesting uses.</source>
          <target state="translated">Aunque pueda parecer extraño tener una función que sólo devuelva la entrada,hay algunos usos interesantes.</target>
        </trans-unit>
        <trans-unit id="97e4502df2c17c97ddd6625eabaef88cae532a3d" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2427b468d47a7420d460c3c9434666519bb67a" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Mientras se itera, el iterador devuelto entrar&amp;aacute; en p&amp;aacute;nico si alguna clave o valor en el entorno no es unicode v&amp;aacute;lido. Si no lo desea, considere usar la funci&amp;oacute;n &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88abee318504f329611b88069221a80488cf9999" translate="yes" xml:space="preserve">
          <source>While performing error handling it is often useful to implement &lt;code&gt;From&lt;/code&gt; for your own error type. By converting underlying error types to our own custom error type that encapsulates the underlying error type, we can return a single error type without losing information on the underlying cause. The '?' operator automatically converts the underlying error type to our custom error type by calling &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; which is automatically provided when implementing &lt;code&gt;From&lt;/code&gt;. The compiler then infers which implementation of &lt;code&gt;Into&lt;/code&gt; should be used.</source>
          <target state="translated">Al realizar el manejo de errores, a menudo es &amp;uacute;til implementar &lt;code&gt;From&lt;/code&gt; para su propio tipo de error. Al convertir los tipos de error subyacentes a nuestro propio tipo de error personalizado que encapsula el tipo de error subyacente, podemos devolver un solo tipo de error sin perder informaci&amp;oacute;n sobre la causa subyacente. Los '?' El operador convierte autom&amp;aacute;ticamente el tipo de error subyacente en nuestro tipo de error personalizado llamando a &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; que se proporciona autom&amp;aacute;ticamente al implementar &lt;code&gt;From&lt;/code&gt; . A continuaci&amp;oacute;n, el compilador infiere qu&amp;eacute; implementaci&amp;oacute;n de &lt;code&gt;Into&lt;/code&gt; debe utilizarse.</target>
        </trans-unit>
        <trans-unit id="21a3472b42943360038c378154c72aeef876d83b" translate="yes" xml:space="preserve">
          <source>While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are &lt;a href=&quot;#primitives&quot;&gt;documented in the section on primitives&lt;/a&gt;.</source>
          <target state="translated">Mientras que el compilador implementa las primitivas, la biblioteca est&amp;aacute;ndar implementa m&amp;eacute;todos directamente en los tipos primitivos (y es la &amp;uacute;nica biblioteca que lo hace), que est&amp;aacute;n &lt;a href=&quot;#primitives&quot;&gt;documentados en la secci&amp;oacute;n sobre primitivas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2a8167e66f949c278500fe8a0d882045622dfbf" translate="yes" xml:space="preserve">
          <source>While the following example is sound, there is a memory leak since the inner vectors were not freed prior to the &lt;code&gt;set_len&lt;/code&gt; call:</source>
          <target state="translated">Si bien el siguiente ejemplo es correcto, hay una p&amp;eacute;rdida de memoria ya que los vectores internos no se liberaron antes de la llamada &lt;code&gt;set_len&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c01f6f794efd0c185cdbd0acdeb3770eddfc8772" translate="yes" xml:space="preserve">
          <source>While there could be a more fine-grained scheme in the future that allows mutable references if they are not &quot;leaked&quot; to the final value, a more conservative approach was chosen for now. &lt;code&gt;const fn&lt;/code&gt; do not have this problem, as the borrow checker will prevent the &lt;code&gt;const fn&lt;/code&gt; from returning new mutable references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce58c9d13deabade9d0031e57b5c561b8bbc9a7" translate="yes" xml:space="preserve">
          <source>While these:</source>
          <target state="translated">Mientras que estos:</target>
        </trans-unit>
        <trans-unit id="5d891980461c7894b78072e4c40fd8f0ee9d4fc4" translate="yes" xml:space="preserve">
          <source>While this means the &lt;code&gt;String&lt;/code&gt; will have a length of zero, it does not touch its capacity.</source>
          <target state="translated">Si bien esto significa que la &lt;code&gt;String&lt;/code&gt; tendr&amp;aacute; una longitud de cero, no toca su capacidad.</target>
        </trans-unit>
        <trans-unit id="1461d256887a81f77bef33d763313b5547fde61d" translate="yes" xml:space="preserve">
          <source>While this method and its mutable counterpart are useful for null-safety, it is important to note that this is still an unsafe operation because the returned value could be pointing to invalid memory.</source>
          <target state="translated">Si bien este método y su contraparte mutable son útiles para la seguridad nula,es importante señalar que sigue siendo una operación insegura porque el valor devuelto podría estar apuntando a una memoria inválida.</target>
        </trans-unit>
        <trans-unit id="ee1ba6c8d8e736d86285c52e19961693ec306982" translate="yes" xml:space="preserve">
          <source>While this trait is unstable, the methods are stable. &lt;code&gt;SliceConcatExt&lt;/code&gt; is included in the &lt;a href=&quot;../prelude/index&quot;&gt;standard library prelude&lt;/a&gt;, so you can use &lt;a href=&quot;#tymethod.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; as if they existed on &lt;code&gt;[T]&lt;/code&gt; itself.</source>
          <target state="translated">Si bien este rasgo es inestable, los m&amp;eacute;todos son estables. &lt;code&gt;SliceConcatExt&lt;/code&gt; se incluye en el &lt;a href=&quot;../prelude/index&quot;&gt;preludio de la biblioteca est&amp;aacute;ndar&lt;/a&gt; , por lo que puede usar &lt;a href=&quot;#tymethod.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#tymethod.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt; como si existieran en &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5f26a246fb02c7cc6b4b29c460a0d1e8dc7640" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the &lt;a href=&quot;../prelude/index&quot;&gt;prelude&lt;/a&gt;'s import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3f0c0f2ca43b389646c40f7923cc632b8f8da" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the prelude's import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si bien el estilo habitual de Rust es importar tipos directamente, los alias de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; a&lt;/a&gt; menudo no lo son, para que sea m&amp;aacute;s f&amp;aacute;cil distinguirlos. &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; se asume generalmente para ser &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; , y para que los usuarios de este alias utilizar&amp;aacute;n generalmente &lt;code&gt;io::Result&lt;/code&gt; lugar de sombra de importaci&amp;oacute;n de la antesala de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba71bc00b481e82beeb9921c07aacd0590f6bd1" translate="yes" xml:space="preserve">
          <source>While you are looking at that &lt;code&gt;[-]&lt;/code&gt; button also notice the &lt;code&gt;[src]&lt;/code&gt; button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.</source>
          <target state="translated">Mientras mira ese bot&amp;oacute;n &lt;code&gt;[-]&lt;/code&gt; , observe tambi&amp;eacute;n el bot&amp;oacute;n &lt;code&gt;[src]&lt;/code&gt; . La documentaci&amp;oacute;n de la API de Rust viene con el c&amp;oacute;digo fuente y le recomendamos que la lea. La fuente de biblioteca est&amp;aacute;ndar es generalmente de alta calidad y un vistazo detr&amp;aacute;s de las cortinas suele ser esclarecedor.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5bd6985bffedbe45212e5ed4b8d7b10e4e8bfe85" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;a href=&quot;https://www.unicode.org/reports/tr31/&quot;&gt;&lt;code&gt;Pattern_White_Space&lt;/code&gt;&lt;/a&gt; Unicode property, namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff785990fe44822be8ffd4354e290cef0c34c873" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode property, namely:</source>
          <target state="translated">El espacio en blanco es cualquier cadena no vac&amp;iacute;a que contiene solo caracteres que tienen la propiedad Unicode &lt;code&gt;Pattern_White_Space&lt;/code&gt; , a saber:</target>
        </trans-unit>
        <trans-unit id="9831741f3701cd2501051eea04df81e500fcac28" translate="yes" xml:space="preserve">
          <source>Who Rust Is For</source>
          <target state="translated">Para quién es el óxido</target>
        </trans-unit>
        <trans-unit id="73012c2e29394e650b32f0b4934e8028ea0802a0" translate="yes" xml:space="preserve">
          <source>Who This Book Is For</source>
          <target state="translated">¿Para quién es este libro?</target>
        </trans-unit>
        <trans-unit id="43d9a912852b85357d25bd06b5c4e243076f38d3" translate="yes" xml:space="preserve">
          <source>Who implements &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Qui&amp;eacute;n implementa &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e36799f202c4d0ce55f224011110c6d687f10837" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;filter_map&lt;/code&gt; and not just &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;? The key is in this part:</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; &lt;code&gt;filter_map&lt;/code&gt; y no solo &lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; ear&lt;/a&gt; ? La clave est&amp;aacute; en esta parte:</target>
        </trans-unit>
        <trans-unit id="f5b054d5badd7795d72a342651abfb7fc1f4dad9" translate="yes" xml:space="preserve">
          <source>Why do I get this message with code that doesn't involve borrowing?</source>
          <target state="translated">¿Por qué recibo este mensaje con un código que no implica un préstamo?</target>
        </trans-unit>
        <trans-unit id="996dd8b0e5f1405cbf0cea853468ae25180b7c3c" translate="yes" xml:space="preserve">
          <source>Why would you not want an executable? Often, &lt;code&gt;cargo check&lt;/code&gt; is much faster than &lt;code&gt;cargo build&lt;/code&gt;, because it skips the step of producing an executable. If you&amp;rsquo;re continually checking your work while writing the code, using &lt;code&gt;cargo check&lt;/code&gt; will speed up the process! As such, many Rustaceans run &lt;code&gt;cargo check&lt;/code&gt; periodically as they write their program to make sure it compiles. Then they run &lt;code&gt;cargo build&lt;/code&gt; when they&amp;rsquo;re ready to use the executable.</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; no querr&amp;iacute;as un ejecutable? A menudo, &lt;code&gt;cargo check&lt;/code&gt; es mucho m&amp;aacute;s r&amp;aacute;pida que &lt;code&gt;cargo build&lt;/code&gt; , porque omite el paso de producir un ejecutable. Si &lt;code&gt;cargo check&lt;/code&gt; continuamente su trabajo mientras escribe el c&amp;oacute;digo, &amp;iexcl;usar la verificaci&amp;oacute;n de carga acelerar&amp;aacute; el proceso! Como tal, muchos rust&amp;aacute;ceos ejecutan &lt;code&gt;cargo check&lt;/code&gt; peri&amp;oacute;dicamente mientras escriben su programa para asegurarse de que se compile. Luego ejecutan &lt;code&gt;cargo build&lt;/code&gt; cuando est&amp;aacute;n listos para usar el ejecutable.</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="a81276e6dfb0c035da01e2595ee9fa04fdc86e1e" translate="yes" xml:space="preserve">
          <source>Wildcard pattern</source>
          <target state="translated">Patrón de comodín</target>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="dd04e2ae06e0c22d6b8a5c4141451a441cf23045" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0843bf815a9dab90b0636f270db8d304e5915a96" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">Siempre devolver&amp;aacute; el mismo &lt;code&gt;&amp;amp;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74ce1cb06587f571c24b39c88c3261da8e964077" translate="yes" xml:space="preserve">
          <source>Will handle the pattern &lt;code&gt;&quot;&quot;&lt;/code&gt; as returning empty matches at each character boundary.</source>
          <target state="translated">Manejar&amp;aacute; el patr&amp;oacute;n &lt;code&gt;&quot;&quot;&lt;/code&gt; como si devolviera coincidencias vac&amp;iacute;as en cada l&amp;iacute;mite de car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="f2a58ab6d8aaaf56805d5dcc5d08104ca8722e51" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;../str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cfca1876affe8c210a04c4805938a5cb452282" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="translated">Devolver&amp;aacute; &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si no es posible analizar este segmento de cadena en el tipo deseado.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="17aebcc3873693512f66ff2029c56928afebc898" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf1c1efc2e097b96e98657a8262127bc226f8f4" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Prefijos de ruta de Windows, por ejemplo, &lt;code&gt;C:&lt;/code&gt; o &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b25b9078d1c6b5cf7d0c03d87923967058f5d7a" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f64162f505580122671f38419aea6835f8c68d" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="translated">Windows usa una variedad de estilos de prefijo de ruta, incluidas referencias a vol&amp;uacute;menes de unidad (como &lt;code&gt;C:&lt;/code&gt; :), carpetas compartidas de red (como &lt;code&gt;\server\share&lt;/code&gt; ) y otros. Adem&amp;aacute;s, algunos prefijos de ruta son &quot;Verbatim&quot; (es decir, con el prefijo &lt;code&gt;\?\&lt;/code&gt; ), En cuyo caso &lt;code&gt;/&lt;/code&gt; es &lt;em&gt;no&lt;/em&gt; tratado como un separador y esencialmente no se realiza ninguna normalizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7b773809bbe5f3adf18d472bfb1e18eaa3a7d486" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions for the primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para las primitivas en el m&amp;oacute;dulo &lt;code&gt;std::fs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965b862fd7707ea01407f5bde9d76c4b33887700" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="315ae7857105e3f47dabe009d9742ce6b255f1de" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e64c5541c43eacfdb85ccf07942595f788d2cb90" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para &lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a739bab05e923c90296481bb09cc25239dd40e0" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;fs::File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00024f75ddf677c52ec0b6d2810b742570a31c11" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c379abe31315129f29960307cac5c5a9ebe73ce4" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;fs::FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ae56a0a615ce91192a5ee5e6f95bfb7ba258a6" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45de75b6c03804d7df1abb9816158b688e268757" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94d3d733eec0453c12d54d6f46b9364d74ffa234" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6631cb576a83d66476aa6a96c888a47fea46888b" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to general I/O primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd50699b2495e189ba2c74247886850721ca3204" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para el &lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt; Generador de comandos .</target>
        </trans-unit>
        <trans-unit id="72c2a1cf40aca0e7999edbbce4beb69846664076" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas de Windows para las primitivas en el m&amp;oacute;dulo &lt;code&gt;std::ffi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a36d28de36794d012a45ca83704dfdf241f6fac" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives</source>
          <target state="translated">Primitivas específicas de Windows</target>
        </trans-unit>
        <trans-unit id="a29244317dd706a76b2545e981c947b9fe3e3b2c" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faf80579510e395a13fd315a37c59f2f038321b" translate="yes" xml:space="preserve">
          <source>Windows::all</source>
          <target state="translated">Windows::all</target>
        </trans-unit>
        <trans-unit id="6716af8ef731d4cbf5689fbdfb93409bf05643fa" translate="yes" xml:space="preserve">
          <source>Windows::any</source>
          <target state="translated">Windows::any</target>
        </trans-unit>
        <trans-unit id="700457e5baeb9db95e547cef9c74633bc4d41f0d" translate="yes" xml:space="preserve">
          <source>Windows::borrow</source>
          <target state="translated">Windows::borrow</target>
        </trans-unit>
        <trans-unit id="17164b9bb020d976e93adc4baa902877434e8dcf" translate="yes" xml:space="preserve">
          <source>Windows::borrow_mut</source>
          <target state="translated">Windows::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31908ffdddda768740e732a89602628774aabf19" translate="yes" xml:space="preserve">
          <source>Windows::by_ref</source>
          <target state="translated">Windows::by_ref</target>
        </trans-unit>
        <trans-unit id="f3d0e279ef4b7617f62329eac02e5ee30b537a4a" translate="yes" xml:space="preserve">
          <source>Windows::chain</source>
          <target state="translated">Windows::chain</target>
        </trans-unit>
        <trans-unit id="dc2580c31dfca64d3e4362d3193516de3088323f" translate="yes" xml:space="preserve">
          <source>Windows::clone</source>
          <target state="translated">Windows::clone</target>
        </trans-unit>
        <trans-unit id="a98bb41ccc08f765218084e917668531933467aa" translate="yes" xml:space="preserve">
          <source>Windows::clone_from</source>
          <target state="translated">Windows::clone_from</target>
        </trans-unit>
        <trans-unit id="561b1708f321b704fa9eba574176baec35025d94" translate="yes" xml:space="preserve">
          <source>Windows::clone_into</source>
          <target state="translated">Windows::clone_into</target>
        </trans-unit>
        <trans-unit id="9c9f0c0979265913d55cdfc2ebb0045f5a724bb0" translate="yes" xml:space="preserve">
          <source>Windows::cloned</source>
          <target state="translated">Windows::cloned</target>
        </trans-unit>
        <trans-unit id="a5b46f7f7dbd448b7a57c4223d0c87d1f200d2c6" translate="yes" xml:space="preserve">
          <source>Windows::cmp</source>
          <target state="translated">Windows::cmp</target>
        </trans-unit>
        <trans-unit id="fbb6b9c622af98d5a66bbf1cfbc26795253b7489" translate="yes" xml:space="preserve">
          <source>Windows::collect</source>
          <target state="translated">Windows::collect</target>
        </trans-unit>
        <trans-unit id="b4ad49bdadeff7d300af28e5eb3fa8051a92ccee" translate="yes" xml:space="preserve">
          <source>Windows::copied</source>
          <target state="translated">Windows::copied</target>
        </trans-unit>
        <trans-unit id="bd6d8af2e6984890043a2ffcecf64303ee4d2b67" translate="yes" xml:space="preserve">
          <source>Windows::count</source>
          <target state="translated">Windows::count</target>
        </trans-unit>
        <trans-unit id="a46aabac6f5fb33e90e0fa67da1b1c957391a4ba" translate="yes" xml:space="preserve">
          <source>Windows::cycle</source>
          <target state="translated">Windows::cycle</target>
        </trans-unit>
        <trans-unit id="54d929ec5d55c2868b2694194d22d67c995476cd" translate="yes" xml:space="preserve">
          <source>Windows::enumerate</source>
          <target state="translated">Windows::enumerate</target>
        </trans-unit>
        <trans-unit id="974003d8cd6730c68f798fb5852a1b8f66b8fc07" translate="yes" xml:space="preserve">
          <source>Windows::eq</source>
          <target state="translated">Windows::eq</target>
        </trans-unit>
        <trans-unit id="fcdcd8564c22f0d208d5887dca20b15981ed7eda" translate="yes" xml:space="preserve">
          <source>Windows::filter</source>
          <target state="translated">Windows::filter</target>
        </trans-unit>
        <trans-unit id="072316ad208e9676ec686940b97aee272075037a" translate="yes" xml:space="preserve">
          <source>Windows::filter_map</source>
          <target state="translated">Windows::filter_map</target>
        </trans-unit>
        <trans-unit id="c74c15ca962f2f3a44811fa2285bb43e26958f3d" translate="yes" xml:space="preserve">
          <source>Windows::find</source>
          <target state="translated">Windows::find</target>
        </trans-unit>
        <trans-unit id="786d8bedc7c35f14926b40554c0038bfc1b31ca1" translate="yes" xml:space="preserve">
          <source>Windows::find_map</source>
          <target state="translated">Windows::find_map</target>
        </trans-unit>
        <trans-unit id="643130ad01d792200f3136ea8c6e080f0365707e" translate="yes" xml:space="preserve">
          <source>Windows::flat_map</source>
          <target state="translated">Windows::flat_map</target>
        </trans-unit>
        <trans-unit id="f4d8fa17f7d4e22990b8c1303515ad7b41c0e51e" translate="yes" xml:space="preserve">
          <source>Windows::flatten</source>
          <target state="translated">Windows::flatten</target>
        </trans-unit>
        <trans-unit id="d2eb04619a69bf18cec3a67a06b479df0576a42c" translate="yes" xml:space="preserve">
          <source>Windows::fmt</source>
          <target state="translated">Windows::fmt</target>
        </trans-unit>
        <trans-unit id="d8a195c51acf16c6aadba984188c415f5441b6c3" translate="yes" xml:space="preserve">
          <source>Windows::fold</source>
          <target state="translated">Windows::fold</target>
        </trans-unit>
        <trans-unit id="01cdc502497ab9b03d2f83fa2d0871f8abb0994a" translate="yes" xml:space="preserve">
          <source>Windows::for_each</source>
          <target state="translated">Windows::for_each</target>
        </trans-unit>
        <trans-unit id="6108a137a74f4bd608fc702807fd0e17b7abd278" translate="yes" xml:space="preserve">
          <source>Windows::from</source>
          <target state="translated">Windows::from</target>
        </trans-unit>
        <trans-unit id="8f30f87a1c9a02e1fb27ac6fe719069f8e122330" translate="yes" xml:space="preserve">
          <source>Windows::fuse</source>
          <target state="translated">Windows::fuse</target>
        </trans-unit>
        <trans-unit id="67db02e23e968fbc8c51336185b95b9b96aec0fb" translate="yes" xml:space="preserve">
          <source>Windows::ge</source>
          <target state="translated">Windows::ge</target>
        </trans-unit>
        <trans-unit id="1b08a3c2211d2e64ecaa8d094412c20af26d6951" translate="yes" xml:space="preserve">
          <source>Windows::gt</source>
          <target state="translated">Windows::gt</target>
        </trans-unit>
        <trans-unit id="6a49da6e96f3901cd2e3f2a458b5df67e32fc1ac" translate="yes" xml:space="preserve">
          <source>Windows::inspect</source>
          <target state="translated">Windows::inspect</target>
        </trans-unit>
        <trans-unit id="dc89660cc21103f886ff9b7d6b842aa6ebb6eea2" translate="yes" xml:space="preserve">
          <source>Windows::into</source>
          <target state="translated">Windows::into</target>
        </trans-unit>
        <trans-unit id="7dc827a9516a85386bc0443ac7acf8dbdc207267" translate="yes" xml:space="preserve">
          <source>Windows::into_iter</source>
          <target state="translated">Windows::into_iter</target>
        </trans-unit>
        <trans-unit id="3bf9a277de1f84adeaec35fb62966d1d7c35ff91" translate="yes" xml:space="preserve">
          <source>Windows::is_empty</source>
          <target state="translated">Windows::is_empty</target>
        </trans-unit>
        <trans-unit id="0f4e75134f8d11b4a570702cb97bdd5515869f82" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted</source>
          <target state="translated">Windows::is_sorted</target>
        </trans-unit>
        <trans-unit id="e74da52cc5b534ed59329d25635be3609f0336ec" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by</source>
          <target state="translated">Windows::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="396da8bc74081a0a8716a03e2ec0b64081b2263f" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by_key</source>
          <target state="translated">Windows::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8bbf67cd900972eb007b6f354b425cc5682d90e0" translate="yes" xml:space="preserve">
          <source>Windows::last</source>
          <target state="translated">Windows::last</target>
        </trans-unit>
        <trans-unit id="edfebb32722bfb5c8d9922b27c21e2ad57bf0c3b" translate="yes" xml:space="preserve">
          <source>Windows::le</source>
          <target state="translated">Windows::le</target>
        </trans-unit>
        <trans-unit id="5b0f7e7a7b44222bd3e3f54b200e29b7293b2aa2" translate="yes" xml:space="preserve">
          <source>Windows::len</source>
          <target state="translated">Windows::len</target>
        </trans-unit>
        <trans-unit id="f84b680a03923cb8668b70cb3d48a10366b725cb" translate="yes" xml:space="preserve">
          <source>Windows::lt</source>
          <target state="translated">Windows::lt</target>
        </trans-unit>
        <trans-unit id="211653c7638da6256828c029f6bdbbd39290d614" translate="yes" xml:space="preserve">
          <source>Windows::map</source>
          <target state="translated">Windows::map</target>
        </trans-unit>
        <trans-unit id="da3645101a0d749919ba6caacb64cbf6bb5ab932" translate="yes" xml:space="preserve">
          <source>Windows::max</source>
          <target state="translated">Windows::max</target>
        </trans-unit>
        <trans-unit id="6faf7c5f10fa19e5856c7c741e0f6e00ec43ac89" translate="yes" xml:space="preserve">
          <source>Windows::max_by</source>
          <target state="translated">Windows::max_by</target>
        </trans-unit>
        <trans-unit id="a97eb7a3a210c7918ea8d0750c43c0be36a4f490" translate="yes" xml:space="preserve">
          <source>Windows::max_by_key</source>
          <target state="translated">Windows::max_by_key</target>
        </trans-unit>
        <trans-unit id="85afd294e1c8b3ac152c12583d70b807752d21c5" translate="yes" xml:space="preserve">
          <source>Windows::min</source>
          <target state="translated">Windows::min</target>
        </trans-unit>
        <trans-unit id="9851ad95c0803c7379f60e880e611d24b73dd771" translate="yes" xml:space="preserve">
          <source>Windows::min_by</source>
          <target state="translated">Windows::min_by</target>
        </trans-unit>
        <trans-unit id="d2ffacc1b47b99ed28eab58435af4f27856f1432" translate="yes" xml:space="preserve">
          <source>Windows::min_by_key</source>
          <target state="translated">Windows::min_by_key</target>
        </trans-unit>
        <trans-unit id="bd27f7b2dd977463e705864279f5215a8693dcf1" translate="yes" xml:space="preserve">
          <source>Windows::ne</source>
          <target state="translated">Windows::ne</target>
        </trans-unit>
        <trans-unit id="07ea4a2a4bc2affb3d5f44891b5f320bb57788cf" translate="yes" xml:space="preserve">
          <source>Windows::next</source>
          <target state="translated">Windows::next</target>
        </trans-unit>
        <trans-unit id="5df573867c1237a7c0cadeeaaef6362ce41599cb" translate="yes" xml:space="preserve">
          <source>Windows::next_back</source>
          <target state="translated">Windows::next_back</target>
        </trans-unit>
        <trans-unit id="884d14d5f8a19f0db064d5b33b9b17b75a3d8a57" translate="yes" xml:space="preserve">
          <source>Windows::nth</source>
          <target state="translated">Windows::nth</target>
        </trans-unit>
        <trans-unit id="d9ece61aa05f950e8c21d253603cec8c4927666f" translate="yes" xml:space="preserve">
          <source>Windows::nth_back</source>
          <target state="translated">Windows::nth_back</target>
        </trans-unit>
        <trans-unit id="e2337e7096b09ea74ce36d188b9ca860a5770051" translate="yes" xml:space="preserve">
          <source>Windows::partial_cmp</source>
          <target state="translated">Windows::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b234418f227a17c704174f2bef5739ac92992b03" translate="yes" xml:space="preserve">
          <source>Windows::partition</source>
          <target state="translated">Windows::partition</target>
        </trans-unit>
        <trans-unit id="9be20298e80cbaffa477f416ccc86f737f3f8d78" translate="yes" xml:space="preserve">
          <source>Windows::peekable</source>
          <target state="translated">Windows::peekable</target>
        </trans-unit>
        <trans-unit id="45529696a341be706214708f3fbab21c7d0b23fd" translate="yes" xml:space="preserve">
          <source>Windows::position</source>
          <target state="translated">Windows::position</target>
        </trans-unit>
        <trans-unit id="59fc20664973429ad195ba2d8aed0ddf546bb2a2" translate="yes" xml:space="preserve">
          <source>Windows::product</source>
          <target state="translated">Windows::product</target>
        </trans-unit>
        <trans-unit id="50734bb415bc20fe6568bfd1dd1f63f6b93fe949" translate="yes" xml:space="preserve">
          <source>Windows::rev</source>
          <target state="translated">Windows::rev</target>
        </trans-unit>
        <trans-unit id="530fe46767d842dcb4f66462626de45b73ad15f2" translate="yes" xml:space="preserve">
          <source>Windows::rfind</source>
          <target state="translated">Windows::rfind</target>
        </trans-unit>
        <trans-unit id="a36a85b42116649c6a0ad782c4af43ce9da0a6d2" translate="yes" xml:space="preserve">
          <source>Windows::rfold</source>
          <target state="translated">Windows::rfold</target>
        </trans-unit>
        <trans-unit id="6b46a39965804836e499e246c032f1e49efe2b08" translate="yes" xml:space="preserve">
          <source>Windows::rposition</source>
          <target state="translated">Windows::rposition</target>
        </trans-unit>
        <trans-unit id="3085a5deaa7e492e694960ff9a8bb11a44fea77b" translate="yes" xml:space="preserve">
          <source>Windows::scan</source>
          <target state="translated">Windows::scan</target>
        </trans-unit>
        <trans-unit id="600168ee422d0b4058643289d6f5f44a0cc41069" translate="yes" xml:space="preserve">
          <source>Windows::size_hint</source>
          <target state="translated">Windows::size_hint</target>
        </trans-unit>
        <trans-unit id="60a31deba53a9144f8f111c1a535404922718781" translate="yes" xml:space="preserve">
          <source>Windows::skip</source>
          <target state="translated">Windows::skip</target>
        </trans-unit>
        <trans-unit id="f0c88d1e74fd2619b821ca5f9314adc478f85906" translate="yes" xml:space="preserve">
          <source>Windows::skip_while</source>
          <target state="translated">Windows::skip_while</target>
        </trans-unit>
        <trans-unit id="43319d488bcd123c09eddf08cef6849d9980eba7" translate="yes" xml:space="preserve">
          <source>Windows::step_by</source>
          <target state="translated">Windows::step_by</target>
        </trans-unit>
        <trans-unit id="9672bcfc100f3ac44dec88d4d85716df442fe940" translate="yes" xml:space="preserve">
          <source>Windows::sum</source>
          <target state="translated">Windows::sum</target>
        </trans-unit>
        <trans-unit id="7df17ff1135505a96dab1d9f8ef57748282788e2" translate="yes" xml:space="preserve">
          <source>Windows::take</source>
          <target state="translated">Windows::take</target>
        </trans-unit>
        <trans-unit id="1e57647d418ad6082e9d4ee5291c1745f789d2e8" translate="yes" xml:space="preserve">
          <source>Windows::take_while</source>
          <target state="translated">Windows::take_while</target>
        </trans-unit>
        <trans-unit id="8f55f6ef559f032eb73be76c2b09a5737e416d5c" translate="yes" xml:space="preserve">
          <source>Windows::to_owned</source>
          <target state="translated">Windows::to_owned</target>
        </trans-unit>
        <trans-unit id="81cbe418ab3685420d683bda86fea704938b8a31" translate="yes" xml:space="preserve">
          <source>Windows::try_fold</source>
          <target state="translated">Windows::try_fold</target>
        </trans-unit>
        <trans-unit id="b4c27872e29ca09f92a33f4478a1eff0aea539bb" translate="yes" xml:space="preserve">
          <source>Windows::try_for_each</source>
          <target state="translated">Windows::try_for_each</target>
        </trans-unit>
        <trans-unit id="171fea351be781be4e02e711fd24294e453b5b91" translate="yes" xml:space="preserve">
          <source>Windows::try_from</source>
          <target state="translated">Windows::try_from</target>
        </trans-unit>
        <trans-unit id="9220c38d1fb3ec5be1fd9df5b83c243f1caa3ba1" translate="yes" xml:space="preserve">
          <source>Windows::try_into</source>
          <target state="translated">Windows::try_into</target>
        </trans-unit>
        <trans-unit id="92ba387998e4a086247665261fda5122f9f9029e" translate="yes" xml:space="preserve">
          <source>Windows::try_rfold</source>
          <target state="translated">Windows::try_rfold</target>
        </trans-unit>
        <trans-unit id="ff8171358582a1c7e6fe713b6c5031c85fcf7da9" translate="yes" xml:space="preserve">
          <source>Windows::type_id</source>
          <target state="translated">Windows::type_id</target>
        </trans-unit>
        <trans-unit id="ef934a80a8453f69945f5830a3ed61e3b0c17061" translate="yes" xml:space="preserve">
          <source>Windows::unzip</source>
          <target state="translated">Windows::unzip</target>
        </trans-unit>
        <trans-unit id="fc3d2052b8855f4dd5b69c5898112a4724165849" translate="yes" xml:space="preserve">
          <source>Windows::zip</source>
          <target state="translated">Windows::zip</target>
        </trans-unit>
        <trans-unit id="38dc69622ed00aee21cdcf0fd074e253d0cf7005" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">&amp;iexcl;Con &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;y &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;, estas macros proporcionan informaci&amp;oacute;n de depuraci&amp;oacute;n a los desarrolladores sobre la ubicaci&amp;oacute;n dentro de la fuente.</target>
        </trans-unit>
        <trans-unit id="0ec53663cefb4388138a07773bc9d9c40923307a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">&amp;iexcl;Con &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;y &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;, estas macros proporcionan informaci&amp;oacute;n de depuraci&amp;oacute;n a los desarrolladores sobre la ubicaci&amp;oacute;n dentro de la fuente.</target>
        </trans-unit>
        <trans-unit id="815b1bf6287da2f53b57957c1e78d170fa30a354" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">&amp;iexcl;Con &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;y &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;, estas macros proporcionan informaci&amp;oacute;n de depuraci&amp;oacute;n a los desarrolladores sobre la ubicaci&amp;oacute;n dentro de la fuente.</target>
        </trans-unit>
        <trans-unit id="04eb7504cabe503a97d0c1acdec5be3b9053e741" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Infallible&lt;/code&gt; being an enum, this code is valid. However when &lt;code&gt;Infallible&lt;/code&gt; becomes an alias for the never type, the two &lt;code&gt;impl&lt;/code&gt;s will start to overlap and therefore will be disallowed by the language&amp;rsquo;s trait coherence rules.</source>
          <target state="translated">Con &lt;code&gt;Infallible&lt;/code&gt; siendo una enumeraci&amp;oacute;n, este c&amp;oacute;digo es v&amp;aacute;lido. Sin embargo, cuando &lt;code&gt;Infallible&lt;/code&gt; convierte en un alias para el tipo never, las dos &lt;code&gt;impl&lt;/code&gt; icaciones comenzar&amp;aacute;n a superponerse y, por lo tanto, ser&amp;aacute;n rechazadas por las reglas de coherencia de rasgos del lenguaje.</target>
        </trans-unit>
        <trans-unit id="0eafffeebea0c3842266dddbb6f397a2037dca13" translate="yes" xml:space="preserve">
          <source>With CMD on Windows, you would enter the following:</source>
          <target state="translated">Con CMD en Windows,se introduciría lo siguiente:</target>
        </trans-unit>
        <trans-unit id="c67b427f4a43407481fdbe0434a6fd74d6c08115" translate="yes" xml:space="preserve">
          <source>With Rust&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; range syntax, if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:</source>
          <target state="translated">Con la sintaxis de rango &lt;code&gt;..&lt;/code&gt; de Rust , si desea comenzar en el primer &amp;iacute;ndice (cero), puede eliminar el valor antes de los dos puntos. En otras palabras, estos son iguales:</target>
        </trans-unit>
        <trans-unit id="e6848246eb0a467aba8b63d5b96e2ddd94bde183" translate="yes" xml:space="preserve">
          <source>With a basic understanding of threads and the thread API, let&amp;rsquo;s look at what we can &lt;em&gt;do&lt;/em&gt; with threads.</source>
          <target state="translated">Con una comprensi&amp;oacute;n b&amp;aacute;sica de los subprocesos y la API de subprocesos, veamos qu&amp;eacute; podemos &lt;em&gt;hacer&lt;/em&gt; con los subprocesos.</target>
        </trans-unit>
        <trans-unit id="b24837e9bbb4a3f319a132114baf06eda4b2e88c" translate="yes" xml:space="preserve">
          <source>With a method call:</source>
          <target state="translated">Con una llamada de método:</target>
        </trans-unit>
        <trans-unit id="5ec0502a02d896b78bc96b2798e0767135b5c8c9" translate="yes" xml:space="preserve">
          <source>With a pathname:</source>
          <target state="translated">Con un nombre:</target>
        </trans-unit>
        <trans-unit id="f37d3365310acb52cb4a4d469a50deacc72ef16e" translate="yes" xml:space="preserve">
          <source>With a unique name, the version, the author details that &lt;code&gt;cargo new&lt;/code&gt; added when you created the crate, your description, and a license added, the &lt;em&gt;Cargo.toml&lt;/em&gt; file for a project that is ready to publish might look like this:</source>
          <target state="translated">Con un nombre &amp;uacute;nico, la versi&amp;oacute;n, el autor, los detalles de la &lt;code&gt;cargo new&lt;/code&gt; que agreg&amp;oacute; cuando cre&amp;oacute; la caja, su descripci&amp;oacute;n y una licencia agregada, el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; de un proyecto que est&amp;aacute; listo para publicar podr&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="33d3ef8879647cae82afb7b344de4fdc8e49a8b3" translate="yes" xml:space="preserve">
          <source>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you&amp;rsquo;ll see in the next section, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;Calling an Unsafe Function or Method.&amp;rdquo;&lt;/a&gt; Another case is when building up safe abstractions that the borrow checker doesn&amp;rsquo;t understand. We&amp;rsquo;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</source>
          <target state="translated">Con todos estos peligros, &amp;iquest;por qu&amp;eacute; usar&amp;iacute;as punteros en bruto? Un caso de uso importante es cuando se interact&amp;uacute;a con c&amp;oacute;digo C, como ver&amp;aacute; en la siguiente secci&amp;oacute;n, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&quot;Llamar a una funci&amp;oacute;n o m&amp;eacute;todo no&lt;/a&gt; seguro &quot;. Otro caso es cuando se crean abstracciones seguras que el verificador de pr&amp;eacute;stamos no comprende. Introduciremos funciones inseguras y luego veremos un ejemplo de una abstracci&amp;oacute;n segura que usa c&amp;oacute;digo inseguro.</target>
        </trans-unit>
        <trans-unit id="a402171e60da25e2d20aa541a5e736d082a2894a" translate="yes" xml:space="preserve">
          <source>With all the changes we&amp;rsquo;ve made, our code compiles without any warnings. But the bad news is this code doesn&amp;rsquo;t function the way we want it to yet. The key is the logic in the closures run by the threads of the &lt;code&gt;Worker&lt;/code&gt; instances: at the moment, we call &lt;code&gt;join&lt;/code&gt;, but that won&amp;rsquo;t shut down the threads because they &lt;code&gt;loop&lt;/code&gt; forever looking for jobs. If we try to drop our &lt;code&gt;ThreadPool&lt;/code&gt; with our current implementation of &lt;code&gt;drop&lt;/code&gt;, the main thread will block forever waiting for the first thread to finish.</source>
          <target state="translated">Con todos los cambios que hemos realizado, nuestro c&amp;oacute;digo se compila sin advertencias. Pero la mala noticia es que este c&amp;oacute;digo a&amp;uacute;n no funciona de la manera que queremos. La clave es la l&amp;oacute;gica en los cierres ejecutados por los subprocesos de las instancias de &lt;code&gt;Worker&lt;/code&gt; : en este momento, llamamos &lt;code&gt;join&lt;/code&gt; , pero eso no cerrar&amp;aacute; los subprocesos porque se &lt;code&gt;loop&lt;/code&gt; para siempre en busca de trabajos. Si intentamos eliminar nuestro &lt;code&gt;ThreadPool&lt;/code&gt; con nuestra implementaci&amp;oacute;n actual de &lt;code&gt;drop&lt;/code&gt; , el hilo principal se bloquear&amp;aacute; para siempre esperando que termine el primer hilo.</target>
        </trans-unit>
        <trans-unit id="3e478a9c9aaa53e1f24932c1bf11ee27b2b756f9" translate="yes" xml:space="preserve">
          <source>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the &lt;code&gt;rlib&lt;/code&gt; format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</source>
          <target state="translated">Con todos estos tipos diferentes de salidas, si la caja A depende de la caja B, entonces el compilador podr&amp;iacute;a encontrar B en varias formas diferentes en todo el sistema. Sin embargo, las &amp;uacute;nicas formas que busca el compilador son el formato &lt;code&gt;rlib&lt;/code&gt; y el formato de biblioteca din&amp;aacute;mica. Con estas dos opciones para una biblioteca dependiente, el compilador debe en alg&amp;uacute;n momento elegir entre estos dos formatos. Con esto en mente, el compilador sigue estas reglas al determinar qu&amp;eacute; formato de dependencias se utilizar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="1b779befcd3540151b782d4543ae930ae53755ec" translate="yes" xml:space="preserve">
          <source>With all this information in mind, let&amp;rsquo;s rewrite &lt;code&gt;first_word&lt;/code&gt; to return a slice. The type that signifies &amp;ldquo;string slice&amp;rdquo; is written as &lt;code&gt;&amp;amp;str&lt;/code&gt;:</source>
          <target state="translated">Con toda esta informaci&amp;oacute;n en mente, reescribamos &lt;code&gt;first_word&lt;/code&gt; para devolver un segmento. El tipo que significa &quot;segmento de cadena&quot; se escribe como &lt;code&gt;&amp;amp;str&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb10c6677d4a9c4ac3a69e9072ac5b7bbbfc8ab3" translate="yes" xml:space="preserve">
          <source>With an associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e91fb00c7adb5b470a7e84f143a4420eb3479d" translate="yes" xml:space="preserve">
          <source>With associated types, we don&amp;rsquo;t need to annotate types because we can&amp;rsquo;t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of &lt;code&gt;Item&lt;/code&gt; will be once, because there can only be one &lt;code&gt;impl Iterator for Counter&lt;/code&gt;. We don&amp;rsquo;t have to specify that we want an iterator of &lt;code&gt;u32&lt;/code&gt; values everywhere that we call &lt;code&gt;next&lt;/code&gt; on &lt;code&gt;Counter&lt;/code&gt;.</source>
          <target state="translated">Con los tipos asociados, no necesitamos anotar tipos porque no podemos implementar un rasgo en un tipo varias veces. En el Listado 19-12 con la definici&amp;oacute;n que usa tipos asociados, solo podemos elegir cu&amp;aacute;l ser&amp;aacute; el tipo de &lt;code&gt;Item&lt;/code&gt; una vez, porque solo puede haber un &lt;code&gt;impl Iterator for Counter&lt;/code&gt; . No tenemos que especificar que queremos un iterador de valores &lt;code&gt;u32&lt;/code&gt; en todas partes que llamemos a &lt;code&gt;next&lt;/code&gt; en &lt;code&gt;Counter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a53dfae04bc081765c66dac442860f331c44aeb" translate="yes" xml:space="preserve">
          <source>With mutable data that is globally accessible, it&amp;rsquo;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it&amp;rsquo;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</source>
          <target state="translated">Con datos mutables a los que se puede acceder globalmente, es dif&amp;iacute;cil garantizar que no haya carreras de datos, raz&amp;oacute;n por la cual Rust considera que las variables est&amp;aacute;ticas mutables no son seguras. Siempre que sea posible, es preferible utilizar las t&amp;eacute;cnicas de concurrencia y los punteros inteligentes seguros para subprocesos que discutimos en el Cap&amp;iacute;tulo 16 para que el compilador verifique que los datos a los que se accede desde diferentes subprocesos se realicen de manera segura.</target>
        </trans-unit>
        <trans-unit id="ef733904e440fafdfd6f6cff1f3753a02bb10342" translate="yes" xml:space="preserve">
          <source>With our new knowledge about iterators, we can change the &lt;code&gt;new&lt;/code&gt; function to take ownership of an iterator as its argument instead of borrowing a slice. We&amp;rsquo;ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the &lt;code&gt;Config::new&lt;/code&gt; function is doing because the iterator will access the values.</source>
          <target state="translated">Con nuestro nuevo conocimiento sobre iteradores, podemos cambiar la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n para tomar posesi&amp;oacute;n de un iterador como argumento en lugar de tomar prestado un segmento. Usaremos la funcionalidad del iterador en lugar del c&amp;oacute;digo que verifica la longitud del segmento e indexa en ubicaciones espec&amp;iacute;ficas. Esto aclarar&amp;aacute; lo que est&amp;aacute; haciendo la funci&amp;oacute;n &lt;code&gt;Config::new&lt;/code&gt; porque el iterador acceder&amp;aacute; a los valores.</target>
        </trans-unit>
        <trans-unit id="813d416dedfb40190d58c273de8f8eb75ea3340b" translate="yes" xml:space="preserve">
          <source>With real world traits these numbers can grow drastically.</source>
          <target state="translated">Con los rasgos del mundo real estos números pueden crecer drásticamente.</target>
        </trans-unit>
        <trans-unit id="b72f5cb005021c9be16f1dc058fb74107683aac5" translate="yes" xml:space="preserve">
          <source>With references and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, the borrowing rules&amp;rsquo; invariants are enforced at compile time. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, these invariants are enforced &lt;em&gt;at runtime&lt;/em&gt;. With references, if you break these rules, you&amp;rsquo;ll get a compiler error. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, if you break these rules, your program will panic and exit.</source>
          <target state="translated">Con referencias y &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , los invariantes de las reglas de pr&amp;eacute;stamo se aplican en tiempo de compilaci&amp;oacute;n. Con &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , estos invariantes se aplican &lt;em&gt;en tiempo de ejecuci&amp;oacute;n&lt;/em&gt; . Con referencias, si rompe estas reglas, obtendr&amp;aacute; un error de compilaci&amp;oacute;n. Con &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , si rompe estas reglas, su programa entrar&amp;aacute; en p&amp;aacute;nico y se cerrar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9baf0229e3e9e6c893294479bb6fe3668b3a0c0e" translate="yes" xml:space="preserve">
          <source>With simple projects, Cargo doesn&amp;rsquo;t provide a lot of value over just using &lt;code&gt;rustc&lt;/code&gt;, but it will prove its worth as your programs become more intricate. With complex projects composed of multiple crates, it&amp;rsquo;s much easier to let Cargo coordinate the build.</source>
          <target state="translated">Con proyectos simples, Cargo no proporciona mucho valor sobre solo usar &lt;code&gt;rustc&lt;/code&gt; , pero demostrar&amp;aacute; su valor a medida que sus programas se vuelvan m&amp;aacute;s complejos. Con proyectos complejos compuestos por m&amp;uacute;ltiples cajas, es mucho m&amp;aacute;s f&amp;aacute;cil dejar que Cargo coordine la construcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="498cc75c7709fdab78e1cc82cb0379d4fbbfc2cc" translate="yes" xml:space="preserve">
          <source>With stdin:</source>
          <target state="translated">Con ETS:</target>
        </trans-unit>
        <trans-unit id="06224dc60392a0fce212359437fb5cee57ac9f42" translate="yes" xml:space="preserve">
          <source>With stdout:</source>
          <target state="translated">Con stdout:</target>
        </trans-unit>
        <trans-unit id="93ea5ac4258ad8d0735b4be8347a757702850e37" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;String&lt;/code&gt; type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</source>
          <target state="translated">Con el tipo &lt;code&gt;String&lt;/code&gt; , para admitir un fragmento de texto mutable y ampliable, necesitamos asignar una cantidad de memoria en el mont&amp;oacute;n, desconocida en el momento de la compilaci&amp;oacute;n, para contener el contenido. Esto significa:</target>
        </trans-unit>
        <trans-unit id="e41ed52cf940fa02215dfc776f98dffa8f13fd94" translate="yes" xml:space="preserve">
          <source>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</source>
          <target state="translated">Con la especificación anterior en la mano,podemos presentar argumentos de por qué determinadas parejas son legales y otras no.</target>
        </trans-unit>
        <trans-unit id="9c5fab965ba18f74e15ee6e594f51c165aae934a" translate="yes" xml:space="preserve">
          <source>With the closure defined, we can change the code in the &lt;code&gt;if&lt;/code&gt; blocks to call the closure to execute the code and get the resulting value. We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</source>
          <target state="translated">Con el cierre definido, podemos cambiar el c&amp;oacute;digo en los bloques &lt;code&gt;if&lt;/code&gt; para llamar al cierre para ejecutar el c&amp;oacute;digo y obtener el valor resultante. Llamamos a un cierre como hacemos una funci&amp;oacute;n: especificamos el nombre de la variable que contiene la definici&amp;oacute;n del cierre y lo seguimos con par&amp;eacute;ntesis que contienen los valores de los argumentos que queremos usar, como se muestra en el Listado 13-6.</target>
        </trans-unit>
        <trans-unit id="01c46a1d067cb86c80a793fada3c4bf6ccb8375e" translate="yes" xml:space="preserve">
          <source>With the implementation of this trick, our thread pool is in a working state! Give it a &lt;code&gt;cargo run&lt;/code&gt; and make some requests:</source>
          <target state="translated">Con la implementaci&amp;oacute;n de este truco, &amp;iexcl;nuestro grupo de subprocesos est&amp;aacute; funcionando! Dale un &lt;code&gt;cargo run&lt;/code&gt; y haz algunas solicitudes:</target>
        </trans-unit>
        <trans-unit id="24a7fa0675f3c1ff0574c22a8d3081db443c0de4" translate="yes" xml:space="preserve">
          <source>With the notion of an item being either public or private, Rust allows item accesses in two cases:</source>
          <target state="translated">Con la noción de que un artículo es público o privado,Rust permite el acceso al artículo en dos casos:</target>
        </trans-unit>
        <trans-unit id="bc6738ca71c4d0da46b8887fed6bda41f9aa0556" translate="yes" xml:space="preserve">
          <source>With the remaining program logic separated into the &lt;code&gt;run&lt;/code&gt; function, we can improve the error handling, as we did with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-9. Instead of allowing the program to panic by calling &lt;code&gt;expect&lt;/code&gt;, the &lt;code&gt;run&lt;/code&gt; function will return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; when something goes wrong. This will let us further consolidate into &lt;code&gt;main&lt;/code&gt; the logic around handling errors in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">Con la l&amp;oacute;gica del programa restante separada en la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; , podemos mejorar el manejo de errores, como hicimos con &lt;code&gt;Config::new&lt;/code&gt; en el Listado 12-9. En lugar de permitir que el programa entre en p&amp;aacute;nico llamando a &lt;code&gt;expect&lt;/code&gt; , la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; devolver&amp;aacute; un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; cuando algo salga mal. Esto nos permitir&amp;aacute; consolidar a&amp;uacute;n m&amp;aacute;s en la l&amp;oacute;gica &lt;code&gt;main&lt;/code&gt; en torno al manejo de errores de una manera f&amp;aacute;cil de usar. El Listado 12-12 muestra los cambios que debemos realizar en la firma y el cuerpo de la &lt;code&gt;run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34d45efbbc694df1116b7475884bd1d2fd47f1c6" translate="yes" xml:space="preserve">
          <source>With the state pattern, the &lt;code&gt;Post&lt;/code&gt; methods and the places we use &lt;code&gt;Post&lt;/code&gt; don&amp;rsquo;t need &lt;code&gt;match&lt;/code&gt; expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</source>
          <target state="translated">Con el patr&amp;oacute;n de estado, los m&amp;eacute;todos de &lt;code&gt;Post&lt;/code&gt; y los lugares que usamos &lt;code&gt;Post&lt;/code&gt; no necesitan expresiones de &lt;code&gt;match&lt;/code&gt; , y para agregar un nuevo estado, solo necesitar&amp;iacute;amos agregar una nueva estructura e implementar los m&amp;eacute;todos de rasgos en esa estructura.</target>
        </trans-unit>
        <trans-unit id="83ff23e8afd931a2cd544c6885efa1601bab61bb" translate="yes" xml:space="preserve">
          <source>With the text in place, edit &lt;em&gt;src/main.rs&lt;/em&gt; and add code to read the file, as shown in Listing 12-4.</source>
          <target state="translated">Con el texto en su lugar, editar &lt;em&gt; src / main.rs&lt;/em&gt; y agregue c&amp;oacute;digo para leer el archivo, como se muestra en el Listado 12-4.</target>
        </trans-unit>
        <trans-unit id="e0b0d0d55bb8949af2866594443ea68c01592e9d" translate="yes" xml:space="preserve">
          <source>With the two trait bounds specified, the body of &lt;code&gt;notify&lt;/code&gt; can call &lt;code&gt;summarize&lt;/code&gt; and use &lt;code&gt;{}&lt;/code&gt; to format &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">Con los dos l&amp;iacute;mites de rasgos especificados, el cuerpo de la &lt;code&gt;notify&lt;/code&gt; puede llamar a &lt;code&gt;summarize&lt;/code&gt; y usar &lt;code&gt;{}&lt;/code&gt; para dar formato al &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7deae3df9bc9dd91ed2ed3e73a23c867198988dd" translate="yes" xml:space="preserve">
          <source>With these changes, let&amp;rsquo;s run our code and make a request. We&amp;rsquo;re no longer printing any data to the terminal, so we won&amp;rsquo;t see any output other than the output from Cargo. When you load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser, you should get a blank page instead of an error. You&amp;rsquo;ve just hand-coded an HTTP request and response!</source>
          <target state="translated">Con estos cambios, ejecutemos nuestro c&amp;oacute;digo y hagamos una solicitud. Ya no imprimimos ning&amp;uacute;n dato en la terminal, por lo que no veremos ninguna salida que no sea la de Cargo. Cuando cargas&lt;em&gt; 127.0.0.1:7878&lt;/em&gt; en un navegador web, deber&amp;iacute;a obtener una p&amp;aacute;gina en blanco en lugar de un error. &amp;iexcl;Acaba de codificar manualmente una solicitud y respuesta HTTP!</target>
        </trans-unit>
        <trans-unit id="2b8a9662a9a062dbd858ec248c6bcfe6e17a1e8d" translate="yes" xml:space="preserve">
          <source>With these changes, run your server again. Requesting &lt;em&gt;127.0.0.1:7878&lt;/em&gt; should return the contents of &lt;em&gt;hello.html&lt;/em&gt;, and any other request, like &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;, should return the error HTML from &lt;em&gt;404.html&lt;/em&gt;.</source>
          <target state="translated">Con estos cambios, vuelva a ejecutar su servidor. Solicitar &lt;em&gt;127.0.0.1:7878&lt;/em&gt; deber&amp;iacute;a devolver el contenido de &lt;em&gt;hello.html&lt;/em&gt; , y cualquier otra solicitud, como &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt; , deber&amp;iacute;a devolver el HTML de error de&lt;em&gt; 404.html&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ea5830e4d89ce20b87325d5feaac7885edd633" translate="yes" xml:space="preserve">
          <source>With these changes, the code compiles! We&amp;rsquo;re getting there!</source>
          <target state="translated">&amp;iexcl;Con estos cambios, el c&amp;oacute;digo se compila! &amp;iexcl;Estamos llegando!</target>
        </trans-unit>
        <trans-unit id="64e9859cf60a37b6fd6185bea427eb35dd3442b4" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-20. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa98175f3edbe33adc271e61ac4777981eaf67" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-25.</source>
          <target state="translated">Con estos cambios, el c&amp;oacute;digo se compilar&amp;aacute; y seguir&amp;aacute; funcionando de la misma manera que lo hizo despu&amp;eacute;s del Listado 20-21. Pero recibiremos una advertencia porque no estamos creando ning&amp;uacute;n mensaje de la variedad &lt;code&gt;Terminate&lt;/code&gt; . Arreglemos esta advertencia cambiando nuestro &lt;code&gt;Drop&lt;/code&gt; implementaci&amp;oacute;n de Drop para que se parezca al Listado 20-25.</target>
        </trans-unit>
        <trans-unit id="86aa3b5dba5f873b63c48b4c86a229ed1fbfd4e1" translate="yes" xml:space="preserve">
          <source>With these extra few lines of code in &lt;code&gt;new&lt;/code&gt;, let&amp;rsquo;s run the program without any arguments again to see what the error looks like now:</source>
          <target state="translated">Con estas pocas l&amp;iacute;neas adicionales de c&amp;oacute;digo en &lt;code&gt;new&lt;/code&gt; , ejecutemos el programa sin argumentos nuevamente para ver c&amp;oacute;mo se ve el error ahora:</target>
        </trans-unit>
        <trans-unit id="96fe782e8597a2f8b432d3a608914c807144f829" translate="yes" xml:space="preserve">
          <source>With this added &lt;code&gt;content&lt;/code&gt; method, everything in Listing 17-11 up to line 7 works as intended.</source>
          <target state="translated">Con este &lt;code&gt;content&lt;/code&gt; agregado m&amp;eacute;todo de , todo en el Listado 17-11 hasta la l&amp;iacute;nea 7 funciona seg&amp;uacute;n lo previsto.</target>
        </trans-unit>
        <trans-unit id="6a69a998d97d76e52647bdd19719b61356e441e9" translate="yes" xml:space="preserve">
          <source>With this approach, x and y share ownership of the data via the &lt;code&gt;Rc&lt;/code&gt; (reference count type). &lt;code&gt;RefCell&lt;/code&gt; essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</source>
          <target state="translated">Con este enfoque, xey comparten la propiedad de los datos a trav&amp;eacute;s del &lt;code&gt;Rc&lt;/code&gt; (tipo de recuento de referencia). &lt;code&gt;RefCell&lt;/code&gt; esencialmente realiza la verificaci&amp;oacute;n de pr&amp;eacute;stamos en tiempo de ejecuci&amp;oacute;n: asegurando que como m&amp;aacute;ximo un escritor o varios lectores puedan acceder a los datos en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="e0294acc426b53e8eefb85526ce41c8bfef32085" translate="yes" xml:space="preserve">
          <source>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let&amp;rsquo;s look at how iterators can improve our implementation of the &lt;code&gt;Config::new&lt;/code&gt; function and the &lt;code&gt;search&lt;/code&gt; function.</source>
          <target state="translated">Con este nuevo conocimiento sobre iteradores, podemos mejorar el proyecto de E / S en el Cap&amp;iacute;tulo 12 usando iteradores para hacer lugares en el c&amp;oacute;digo m&amp;aacute;s claros y concisos. Veamos c&amp;oacute;mo los iteradores pueden mejorar nuestra implementaci&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;Config::new&lt;/code&gt; y la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2fb8bb90dda22d23945c9584750688009a769c8" translate="yes" xml:space="preserve">
          <source>With this:</source>
          <target state="translated">Con esto:</target>
        </trans-unit>
        <trans-unit id="f92b2fe5b7dcaebe110b80babf1c63cd9fdd43ef" translate="yes" xml:space="preserve">
          <source>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We&amp;rsquo;ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</source>
          <target state="translated">Con las anotaciones de tipo agregadas, la sintaxis de los cierres se parece m&amp;aacute;s a la sintaxis de las funciones. La siguiente es una comparaci&amp;oacute;n vertical de la sintaxis para la definici&amp;oacute;n de una funci&amp;oacute;n que agrega 1 a su par&amp;aacute;metro y un cierre que tiene el mismo comportamiento. Agregamos algunos espacios para alinear las partes relevantes. Esto ilustra c&amp;oacute;mo la sintaxis de cierre es similar a la sintaxis de funci&amp;oacute;n, excepto por el uso de canalizaciones y la cantidad de sintaxis que es opcional:</target>
        </trans-unit>
        <trans-unit id="e12bdc1ee24b9c9117113f7fd06a681041f0f8ca" translate="yes" xml:space="preserve">
          <source>With values that have many parts, we can use the &lt;code&gt;..&lt;/code&gt; syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. The &lt;code&gt;..&lt;/code&gt; pattern ignores any parts of a value that we haven&amp;rsquo;t explicitly matched in the rest of the pattern. In Listing 18-23, we have a &lt;code&gt;Point&lt;/code&gt; struct that holds a coordinate in three-dimensional space. In the &lt;code&gt;match&lt;/code&gt; expression, we want to operate only on the &lt;code&gt;x&lt;/code&gt; coordinate and ignore the values in the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; fields.</source>
          <target state="translated">Con valores que tienen muchas partes, podemos usar la sintaxis &lt;code&gt;..&lt;/code&gt; para usar solo unas pocas partes e ignorar el resto, evitando la necesidad de enumerar guiones bajos para cada valor ignorado. El patr&amp;oacute;n &lt;code&gt;..&lt;/code&gt; ignora las partes de un valor que no hemos hecho coincidir expl&amp;iacute;citamente en el resto del patr&amp;oacute;n. En el listado 18-23, tenemos una estructura &lt;code&gt;Point&lt;/code&gt; que contiene una coordenada en un espacio tridimensional. En la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; , queremos operar solo en la coordenada &lt;code&gt;x&lt;/code&gt; e ignorar los valores en los campos &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3392b1d08169948bc18f560cc78f42601ac7de77" translate="yes" xml:space="preserve">
          <source>Within a type definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bf9a3332dbb1aae191337d7acb72ccf285dc36" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, we list the names and signatures of external functions from another language we want to call. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; part defines which &lt;em&gt;application binary interface (ABI)&lt;/em&gt; the external function uses: the ABI defines how to call the function at the assembly level. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI is the most common and follows the C programming language&amp;rsquo;s ABI.</source>
          <target state="translated">Dentro del bloque &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; , enumeramos los nombres y firmas de funciones externas de otro idioma al que queramos llamar. La parte &lt;code&gt;&quot;C&quot;&lt;/code&gt; define qu&amp;eacute; &lt;em&gt;interfaz binaria de aplicaci&amp;oacute;n (ABI)&lt;/em&gt; utiliza la funci&amp;oacute;n externa: la ABI define c&amp;oacute;mo llamar a la funci&amp;oacute;n en el nivel de ensamblaje. La ABI &lt;code&gt;&quot;C&quot;&lt;/code&gt; es la m&amp;aacute;s com&amp;uacute;n y sigue la ABI del lenguaje de programaci&amp;oacute;n C.</target>
        </trans-unit>
        <trans-unit id="a3840b923c5773a4355bfcefff4121f0878713eb" translate="yes" xml:space="preserve">
          <source>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</source>
          <target state="translated">Dentro del cuerpo de un artículo que tiene declaraciones de parámetros de tipo,los nombres de sus parámetros de tipo son tipos:</target>
        </trans-unit>
        <trans-unit id="c6cad0f75b24acc004189d1ad1ae2454225184aa" translate="yes" xml:space="preserve">
          <source>Within this documentation's grammar, &quot;simple&quot; tokens are given in &lt;a href=&quot;notation#string-table-productions&quot;&gt;string table production&lt;/a&gt; form, and appear in &lt;code&gt;monospace&lt;/code&gt; font.</source>
          <target state="translated">Dentro de la gram&amp;aacute;tica de esta documentaci&amp;oacute;n, los tokens &quot;simples&quot; se dan en forma de &lt;a href=&quot;notation#string-table-productions&quot;&gt;producci&amp;oacute;n de tabla de cadenas&lt;/a&gt; y aparecen en fuente &lt;code&gt;monospace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f884881293efc9c1f179ad8b3973e698991d41" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;compiler_fence&lt;/code&gt;, the &lt;code&gt;assert_eq!&lt;/code&gt; in following code is &lt;em&gt;not&lt;/em&gt; guaranteed to succeed, despite everything happening in a single thread. To see why, remember that the compiler is free to swap the stores to &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; and &lt;code&gt;IS_READ&lt;/code&gt; since they are both &lt;code&gt;Ordering::Relaxed&lt;/code&gt;. If it does, and the signal handler is invoked right after &lt;code&gt;IS_READY&lt;/code&gt; is updated, then the signal handler will see &lt;code&gt;IS_READY=1&lt;/code&gt;, but &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt;. Using a &lt;code&gt;compiler_fence&lt;/code&gt; remedies this situation.</source>
          <target state="translated">Sin &lt;code&gt;compiler_fence&lt;/code&gt; , el valor de &lt;code&gt;assert_eq!&lt;/code&gt; en el siguiente c&amp;oacute;digo &lt;em&gt;no se&lt;/em&gt; garantiza que tenga &amp;eacute;xito, a pesar de que todo sucede en un solo hilo. Para ver por qu&amp;eacute;, recuerde que el compilador es libre de intercambiar las tiendas a &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; e &lt;code&gt;IS_READ&lt;/code&gt; ya que ambos son &lt;code&gt;Ordering::Relaxed&lt;/code&gt; . Si lo hace, y el manejador de se&amp;ntilde;ales se invoca justo despu&amp;eacute;s de que se actualice &lt;code&gt;IS_READY&lt;/code&gt; , entonces el manejador de se&amp;ntilde;ales ver&amp;aacute; &lt;code&gt;IS_READY=1&lt;/code&gt; , pero &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt; . El uso de &lt;code&gt;compiler_fence&lt;/code&gt; soluciona esta situaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6823be3ffd83b17bd9d63c393e81d5a41ffc52cc" translate="yes" xml:space="preserve">
          <source>Without a loop to break out of or continue in, no sensible action can be taken. Please verify that you are using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; only in loops. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2efdc6add8e970dc1865be96d1f867d6e1b60c" translate="yes" xml:space="preserve">
          <source>Without a pathname:</source>
          <target state="translated">Sin un nombre:</target>
        </trans-unit>
        <trans-unit id="90c928ad5c0a871061baee534c7a9a3eec8a4645" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;Deref&lt;/code&gt; trait, the compiler can only dereference &lt;code&gt;&amp;amp;&lt;/code&gt; references. The &lt;code&gt;deref&lt;/code&gt; method gives the compiler the ability to take a value of any type that implements &lt;code&gt;Deref&lt;/code&gt; and call the &lt;code&gt;deref&lt;/code&gt; method to get a &lt;code&gt;&amp;amp;&lt;/code&gt; reference that it knows how to dereference.</source>
          <target state="translated">Sin el rasgo &lt;code&gt;Deref&lt;/code&gt; , el compilador solo puede desreferenciar &lt;code&gt;&amp;amp;&lt;/code&gt; referencias. El m&amp;eacute;todo &lt;code&gt;deref&lt;/code&gt; le da al compilador la capacidad de tomar un valor de cualquier tipo que implemente &lt;code&gt;Deref&lt;/code&gt; y llamar al m&amp;eacute;todo &lt;code&gt;deref&lt;/code&gt; para obtener una referencia &lt;code&gt;&amp;amp;&lt;/code&gt; que sabe c&amp;oacute;mo desreferenciar.</target>
        </trans-unit>
        <trans-unit id="87160e17882870214c0775aca97bd35e735c34ab" translate="yes" xml:space="preserve">
          <source>Working with Environment Variables</source>
          <target state="translated">Trabajando con Variables del Medio Ambiente</target>
        </trans-unit>
        <trans-unit id="90e474d6c66232279cbf06723c1f38f471687b09" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</source>
          <target state="translated">Trabajar con punteros crudos en el óxido es poco común,típicamente limitado a unos pocos patrones.</target>
        </trans-unit>
        <trans-unit id="9a40e384f7f263637185bd19da70cd3d69e259e7" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns. Raw pointers can be unaligned or &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. However, when a raw pointer is dereferenced (using the &lt;code&gt;*&lt;/code&gt; operator), it must be non-null and aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727515b132b28daa88eb87eebc62a62072364288" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here are some important parts to focus on: the first inline error says &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The reason for this is in the next important part to focus on, the error message. The distilled error message says &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="translated">&amp;iexcl;Vaya, ese mensaje de error es muy extenso! Aqu&amp;iacute; hay algunas partes importantes en las que centrarse: el primer error en l&amp;iacute;nea dice que &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt; . La raz&amp;oacute;n de esto est&amp;aacute; en la siguiente parte importante en la que centrarse, el mensaje de error. El mensaje de error destilado dice que &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt; . Hablaremos de &lt;code&gt;Send&lt;/code&gt; en la siguiente secci&amp;oacute;n: es una de las caracter&amp;iacute;sticas que asegura que los tipos que usamos con subprocesos est&amp;aacute;n dise&amp;ntilde;ados para usarse en situaciones concurrentes.</target>
        </trans-unit>
        <trans-unit id="71aebd97d81f1f2a97e5f18bfd8c471204fa376d" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here&amp;rsquo;s the important part to focus on: &lt;code&gt;`Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The compiler is also telling us the reason why: &lt;code&gt;the trait `Send` is not implemented for `Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` &lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130acb06cdbaff87c403e521823abb94f422c9e0" translate="yes" xml:space="preserve">
          <source>Wrap a value to be manually dropped.</source>
          <target state="translated">Envuelve un valor para ser lanzado manualmente.</target>
        </trans-unit>
        <trans-unit id="744e431b88ea1a0035f05b8fb26571f5315f1927" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">Envuelva un valor OK para construir el resultado compuesto. Por ejemplo, &lt;code&gt;Result::Ok(x)&lt;/code&gt; y &lt;code&gt;Result::from_ok(x)&lt;/code&gt; son equivalentes.</target>
        </trans-unit>
        <trans-unit id="a120e7e89eaa3b758fd2407bf284e593ba7d4ab0" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Envuelva un valor OK para construir el resultado compuesto. Por ejemplo, &lt;code&gt;Result::Ok(x)&lt;/code&gt; y &lt;code&gt;Result::from_ok(x)&lt;/code&gt; son equivalentes. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd8c3f0758b57991ee8d44e4f6a9dc360915c844" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">Envuelva un valor de error para construir el resultado compuesto. Por ejemplo, &lt;code&gt;Result::Err(x)&lt;/code&gt; y &lt;code&gt;Result::from_error(x)&lt;/code&gt; son equivalentes.</target>
        </trans-unit>
        <trans-unit id="b038d6e7a645f366cbf4e437083304bafb6bb808" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Envuelva un valor de error para construir el resultado compuesto. Por ejemplo, &lt;code&gt;Result::Err(x)&lt;/code&gt; y &lt;code&gt;Result::from_error(x)&lt;/code&gt; son equivalentes. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="743cdade02c9bf9e30517f2de055980f9f8a86fb" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) absolute value. Computes &lt;code&gt;self.abs()&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Valor absoluto envolvente (modular). Calcula &lt;code&gt;self.abs()&lt;/code&gt; , rodeando el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="f4efecec7c636af1ead7e0409272bc8b700c5382" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Adici&amp;oacute;n de envoltura (modular). Calcula &lt;code&gt;self + rhs&lt;/code&gt; , envolviendo en el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="8112829180296558677473f537db1e33a076f93c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Divisi&amp;oacute;n de envoltura (modular). Calcula &lt;code&gt;self / rhs&lt;/code&gt; , envolviendo en el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="3f6391833e153cf10bdb32314ca04ce9ce43dbdd" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">Divisi&amp;oacute;n de envoltura (modular). Calcula &lt;code&gt;self / rhs&lt;/code&gt; . La divisi&amp;oacute;n envuelta en tipos sin firmar es simplemente una divisi&amp;oacute;n normal. No hay forma de que se pueda envolver. Esta funci&amp;oacute;n existe, por lo que todas las operaciones se contabilizan en las operaciones de envoltura.</target>
        </trans-unit>
        <trans-unit id="d6bb89dd7e6026b10f235fa3863c6339f2fb774c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) exponentiation. Computes &lt;code&gt;self.pow(exp)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Exponenciaci&amp;oacute;n envolvente (modular). Calcula &lt;code&gt;self.pow(exp)&lt;/code&gt; , envolviendo el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="e6b77bd3d8c54b47f23891885173c42858312a14" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Envoltura de multiplicaci&amp;oacute;n (modular). Calcula &lt;code&gt;self * rhs&lt;/code&gt; , envolviendo en el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="2ad719d382b4d16912e1a91a3a59d2c050db5a30" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) negation. Computes &lt;code&gt;-self&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Envoltura de negaci&amp;oacute;n (modular). Calcula &lt;code&gt;-self&lt;/code&gt; , envolviendo el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="88feadfab016809fcd2984cfd9226aba00462cae" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Envoltura (modular) resto. Calcula los &lt;code&gt;self % rhs&lt;/code&gt; , envolviendo en el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="bab7a7fcc721ce6448649830e7166d7008062fd3" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">Envoltura (modular) resto. Calcula los &lt;code&gt;self % rhs&lt;/code&gt; . El c&amp;aacute;lculo del resto envuelto en tipos sin firmar es solo el c&amp;aacute;lculo del resto normal. No hay forma de que se pueda envolver. Esta funci&amp;oacute;n existe, por lo que todas las operaciones se contabilizan en las operaciones de envoltura.</target>
        </trans-unit>
        <trans-unit id="0547792119ca778e4ded115060f8e8198122f4ee" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Resta envolvente (modular). Calcula &lt;code&gt;self - rhs&lt;/code&gt; , envolviendo en el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="9c70c48db93cbf30305f6f367392a85a748eb0d9" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Envolviendo la divisi&amp;oacute;n euclidiana. Calcula &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; , envolviendo en el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="0c397d89ed28af23471d1300df82f2628a5cc9eb" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt;.</source>
          <target state="translated">Envolviendo la divisi&amp;oacute;n euclidiana. Calcula &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; . La divisi&amp;oacute;n envuelta en tipos sin firmar es simplemente una divisi&amp;oacute;n normal. No hay forma de que se pueda envolver. Esta funci&amp;oacute;n existe, por lo que todas las operaciones se contabilizan en las operaciones de envoltura. Dado que, para los enteros positivos, todas las definiciones comunes de divisi&amp;oacute;n son iguales, esto es exactamente igual a &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a6d61ea92522854260430b74b8667bece5c095" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean modulo. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;. Wrapped modulo calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt;.</source>
          <target state="translated">Envolviendo el m&amp;oacute;dulo euclidiano. Calcula &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; . El c&amp;aacute;lculo de m&amp;oacute;dulo envuelto en tipos sin firmar es solo el c&amp;aacute;lculo de resto normal. No hay forma de que se pueda envolver. Esta funci&amp;oacute;n existe, por lo que todas las operaciones se contabilizan en las operaciones de envoltura. Dado que, para los enteros positivos, todas las definiciones comunes de divisi&amp;oacute;n son iguales, esto es exactamente igual a &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c3f54557cafd34a10c40361aa84b7aedc96050" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean remainder. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Envolviendo el resto euclidiano. Calcula &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; , envolviendo el l&amp;iacute;mite del tipo.</target>
        </trans-unit>
        <trans-unit id="c113027998f084fc650feeb5a7a7db8e8206e9c9" translate="yes" xml:space="preserve">
          <source>Wrapping arithmetic can be achieved either through methods like &lt;code&gt;wrapping_add&lt;/code&gt;, or through the &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</source>
          <target state="translated">La aritm&amp;eacute;tica de envoltura se puede lograr a trav&amp;eacute;s de m&amp;eacute;todos como &lt;code&gt;wrapping_add&lt;/code&gt; , o mediante el tipo &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; , que dice que todas las operaciones aritm&amp;eacute;ticas est&amp;aacute;ndar en el valor subyacente deben tener sem&amp;aacute;ntica de envoltura.</target>
        </trans-unit>
        <trans-unit id="67accd5f5a259bdba5036a1931f5ae6a264b08ff" translate="yes" xml:space="preserve">
          <source>Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe. This has the downside that if new captures are added in the future, they will also be considered unwind safe. Therefore, you may prefer to just wrap individual captures, as shown below. This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.</source>
          <target state="translated">Envolver todo el cierre equivale a una afirmación general de que todas las variables capturadas están a salvo.Esto tiene la desventaja de que si se añaden nuevas capturas en el futuro,también se considerarán seguras.Por lo tanto,puede que prefiera envolver sólo las capturas individuales,como se muestra a continuación.Esto es más una anotación,pero asegura que si se agrega una nueva captura que no es segura de desenrollar,obtendrá un error de compilación en ese momento,lo que le permitirá considerar si esa nueva captura representa de hecho un error o no.</target>
        </trans-unit>
        <trans-unit id="3012f027dfde83895278c2a37775ef7453b5a48e" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN % -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). In this case, this method returns 0.</source>
          <target state="translated">El ajuste solo ocurrir&amp;aacute; en &lt;code&gt;MIN % -1&lt;/code&gt; en un tipo con signo (donde &lt;code&gt;MIN&lt;/code&gt; es el valor m&amp;iacute;nimo negativo para el tipo). En este caso, este m&amp;eacute;todo devuelve 0.</target>
        </trans-unit>
        <trans-unit id="5d2a82c1ae568c2138fb6d4aab53c9ab79d15385" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). This is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In this case, this method returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">El ajuste solo ocurrir&amp;aacute; en &lt;code&gt;MIN / -1&lt;/code&gt; en un tipo con signo (donde &lt;code&gt;MIN&lt;/code&gt; es el valor m&amp;iacute;nimo negativo para el tipo). Esto es equivalente a &lt;code&gt;-MIN&lt;/code&gt; , un valor positivo que es demasiado grande para representarlo en el tipo. En este caso, este m&amp;eacute;todo devuelve &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44bf3ad335738a5732c68d1f5196155da8fafc7b" translate="yes" xml:space="preserve">
          <source>Wrapping::abs</source>
          <target state="translated">Wrapping::abs</target>
        </trans-unit>
        <trans-unit id="fc3cfb30e84b8ebe6925ae0fbbf5f0d863e96948" translate="yes" xml:space="preserve">
          <source>Wrapping::add</source>
          <target state="translated">Wrapping::add</target>
        </trans-unit>
        <trans-unit id="e4708fa03c855319c8e70d77b4d353eb63d863a1" translate="yes" xml:space="preserve">
          <source>Wrapping::add_assign</source>
          <target state="translated">Wrapping::add_assign</target>
        </trans-unit>
        <trans-unit id="6227b7b51ca5d41b66a8bd3e6ec7e706422dcd02" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand</source>
          <target state="translated">Wrapping::bitand</target>
        </trans-unit>
        <trans-unit id="50986c3cc68dd80bb41b112f5357a4b5cb0ac2fc" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand_assign</source>
          <target state="translated">Wrapping::bitand_assign</target>
        </trans-unit>
        <trans-unit id="b7da20cfd17d521397a2d0c4d7318400486ff1e3" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor</source>
          <target state="translated">Wrapping::bitor</target>
        </trans-unit>
        <trans-unit id="b1f50a490018b194e6eb7c8804a9e9492ca0ae9b" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor_assign</source>
          <target state="translated">Wrapping::bitor_assign</target>
        </trans-unit>
        <trans-unit id="fd32619eaf11a02453eca2921b2682dcb9909981" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor</source>
          <target state="translated">Wrapping::bitxor</target>
        </trans-unit>
        <trans-unit id="4ee45c7807828640fae4c2e2cbbd932b27eab127" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor_assign</source>
          <target state="translated">Wrapping::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="453a622aaaf4b4b2bd85589c0f8774be95ac4938" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow</source>
          <target state="translated">Wrapping::borrow</target>
        </trans-unit>
        <trans-unit id="7842f835a5fa6d18893907fa71602942c78be04d" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow_mut</source>
          <target state="translated">Wrapping::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4251a19204a74bbc8ead142e79f328751693afa6" translate="yes" xml:space="preserve">
          <source>Wrapping::clamp</source>
          <target state="translated">Wrapping::clamp</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
