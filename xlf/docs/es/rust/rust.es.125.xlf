<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="f18ea48cefb527612333927e42f98b5493e80a96" translate="yes" xml:space="preserve">
          <source>Ancestors::try_from</source>
          <target state="translated">Ancestors::try_from</target>
        </trans-unit>
        <trans-unit id="f07951de2fcfeba585ae159316c166c38d8606b4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_into</source>
          <target state="translated">Ancestors::try_into</target>
        </trans-unit>
        <trans-unit id="0008829b37e7881a29a429bd8ff5a7a5ef753374" translate="yes" xml:space="preserve">
          <source>Ancestors::type_id</source>
          <target state="translated">Ancestors::type_id</target>
        </trans-unit>
        <trans-unit id="04f137aff1969f866b7d2666a9252de9e0efa21b" translate="yes" xml:space="preserve">
          <source>Ancestors::unzip</source>
          <target state="translated">Ancestors::unzip</target>
        </trans-unit>
        <trans-unit id="55dbfc2c3d770eaac08b3c73d87bccce57c4f78d" translate="yes" xml:space="preserve">
          <source>Ancestors::zip</source>
          <target state="translated">Ancestors::zip</target>
        </trans-unit>
        <trans-unit id="49a40db56fe6180d9e3eb242542f45d2d3173d4f" translate="yes" xml:space="preserve">
          <source>AncillaryData</source>
          <target state="translated">AncillaryData</target>
        </trans-unit>
        <trans-unit id="8c3f77779f46bdbd3940ac1fe6a4e53f4cdfa790" translate="yes" xml:space="preserve">
          <source>AncillaryError</source>
          <target state="translated">AncillaryError</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="42b71964be13234f4cbc3e386af8045e5f37b66e" translate="yes" xml:space="preserve">
          <source>And &lt;em&gt;src/front_of_house.rs&lt;/em&gt; gets the definitions from the body of the &lt;code&gt;front_of_house&lt;/code&gt; module, as shown in Listing 7-22.</source>
          <target state="translated">Y &lt;em&gt;src / front_of_house.rs&lt;/em&gt; obtiene las definiciones del cuerpo del &lt;code&gt;front_of_house&lt;/code&gt; m&amp;oacute;dulo , como se muestra en el Listado 7-22.</target>
        </trans-unit>
        <trans-unit id="a66dda047400c5c52222e76fafe04295868d79a8" translate="yes" xml:space="preserve">
          <source>And a very common source of output is standard output:</source>
          <target state="translated">Y una fuente muy común de salida es la salida estándar:</target>
        </trans-unit>
        <trans-unit id="5cd52670a2b07449cbe1bd4abb403c682ccaf168" translate="yes" xml:space="preserve">
          <source>And finally, for the last example, only &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; work as explicit self parameters. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91a984e8eba980f8ed5afc44476d8d32720a1d5" translate="yes" xml:space="preserve">
          <source>And finally, let&amp;rsquo;s make sure that we don&amp;rsquo;t get any lines when we search for a word that isn&amp;rsquo;t anywhere in the poem, such as &amp;ldquo;monomorphization&amp;rdquo;:</source>
          <target state="translated">Y finalmente, asegur&amp;eacute;monos de no obtener ninguna l&amp;iacute;nea cuando buscamos una palabra que no est&amp;aacute; en ninguna parte del poema, como &quot;monomorfizaci&amp;oacute;n&quot;:</target>
        </trans-unit>
        <trans-unit id="8ddbbced7930dcaf198948383ed803d74e9323cf" translate="yes" xml:space="preserve">
          <source>And finally, the standard library exports a number of standard macros, and &lt;a href=&quot;#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.</source>
          <target state="translated">Y finalmente, la biblioteca est&amp;aacute;ndar exporta una serie de macros est&amp;aacute;ndar y las &lt;a href=&quot;#macros&quot;&gt;enumera en esta p&amp;aacute;gina&lt;/a&gt; (t&amp;eacute;cnicamente, no todas las macros est&amp;aacute;ndar est&amp;aacute;n definidas por la biblioteca est&amp;aacute;ndar, algunas las define el compilador, pero est&amp;aacute;n documentadas aqu&amp;iacute; de la misma manera) . Al igual que en el preludio, las macros est&amp;aacute;ndar se importan de forma predeterminada en todas las cajas.</target>
        </trans-unit>
        <trans-unit id="01c604c6cbed200d9271efd93c6961cdbaa99ebc" translate="yes" xml:space="preserve">
          <source>And now let's give working examples:</source>
          <target state="translated">Y ahora vamos a dar ejemplos de trabajo:</target>
        </trans-unit>
        <trans-unit id="076add01b447af4a01e4ff6b95c8cd6d23f8bbbe" translate="yes" xml:space="preserve">
          <source>And now some working examples:</source>
          <target state="translated">Y ahora algunos ejemplos de trabajo:</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965c5135f65b1edbef655afbf975cd109690bf20" translate="yes" xml:space="preserve">
          <source>And so, our final result, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">Y as&amp;iacute;, nuestro resultado final, &lt;code&gt;6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8576d009cd19a7310431c770ccd6d0477a9a38f5" translate="yes" xml:space="preserve">
          <source>And the expected output would look like the following, because both dimensions of &lt;code&gt;rect2&lt;/code&gt; are smaller than the dimensions of &lt;code&gt;rect1&lt;/code&gt; but &lt;code&gt;rect3&lt;/code&gt; is wider than &lt;code&gt;rect1&lt;/code&gt;:</source>
          <target state="translated">Y la salida esperada se ver&amp;iacute;a as&amp;iacute;, porque ambas dimensiones de &lt;code&gt;rect2&lt;/code&gt; son m&amp;aacute;s peque&amp;ntilde;as que las dimensiones de &lt;code&gt;rect1&lt;/code&gt; pero &lt;code&gt;rect3&lt;/code&gt; es m&amp;aacute;s ancho que &lt;code&gt;rect1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="304a9abb7c8dbb46b1cac5f34e7d81eb70527d19" translate="yes" xml:space="preserve">
          <source>And the following is the same example, except using &lt;a href=&quot;generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;.</source>
          <target state="translated">Y el siguiente es el mismo ejemplo, excepto el uso de &lt;a href=&quot;generics#where-clauses&quot;&gt;cl&amp;aacute;usulas where&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="913d407459e0226b150e7a70e74b4001bb096c87" translate="yes" xml:space="preserve">
          <source>And then usage on the derive macro on a struct:</source>
          <target state="translated">Y luego el uso de la macro derivada en una estructura:</target>
        </trans-unit>
        <trans-unit id="16869e8d4badcf1212b889f654db64e52cba8e49" translate="yes" xml:space="preserve">
          <source>And then using said derive macro:</source>
          <target state="translated">Y luego usando dicha macro derivada:</target>
        </trans-unit>
        <trans-unit id="fde456d658fb04a2082b8789148df9b0dd8dabdb" translate="yes" xml:space="preserve">
          <source>And then we use it a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">Y luego lo usamos una caja binaria para imprimir &quot;42&quot; a la salida estándar.</target>
        </trans-unit>
        <trans-unit id="57be02e986031e930e9bf37db6620140ea92c664" translate="yes" xml:space="preserve">
          <source>And then we use it in a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843c5d94071a4fae0f20d3e75ea70e29673c03d4" translate="yes" xml:space="preserve">
          <source>And we can call this function with either variant:</source>
          <target state="translated">Y podemos llamar a esta función con cualquier variante:</target>
        </trans-unit>
        <trans-unit id="406aea8920a159db743c7e055df50170c501f68e" translate="yes" xml:space="preserve">
          <source>And we&amp;rsquo;re done&amp;mdash;all of Listing 17-11 now works! We&amp;rsquo;ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">Y hemos terminado, &amp;iexcl;todo el Listado 17-11 ahora funciona! Hemos implementado el patr&amp;oacute;n de estado con las reglas del flujo de trabajo de la publicaci&amp;oacute;n de blog. La l&amp;oacute;gica relacionada con las reglas vive en los objetos de estado en lugar de estar esparcida por &lt;code&gt;Post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d71a2256704824ddf84d5c0504e7d9d40555e056" translate="yes" xml:space="preserve">
          <source>And you make a hard link of the program:</source>
          <target state="translated">Y tú haces un vínculo difícil del programa:</target>
        </trans-unit>
        <trans-unit id="1a652f499d8171d97dc8db68df0dbf0a99d7c3f2" translate="yes" xml:space="preserve">
          <source>AndAnd</source>
          <target state="translated">AndAnd</target>
        </trans-unit>
        <trans-unit id="bcffbb2710fb4ff9f2236988e5b2ed04ecff3723" translate="yes" xml:space="preserve">
          <source>AndEq</source>
          <target state="translated">AndEq</target>
        </trans-unit>
        <trans-unit id="c4af9f801ba386b4d95b5962fd0aee793823a0c6" translate="yes" xml:space="preserve">
          <source>Anonymous type parameters</source>
          <target state="translated">Parámetros de tipo anónimo</target>
        </trans-unit>
        <trans-unit id="f739dc0ff02bf7ebdbbaf543c53bc8d5f32aa9b9" translate="yes" xml:space="preserve">
          <source>Another aspect commonly associated with OOP is the idea of &lt;em&gt;encapsulation&lt;/em&gt;, which means that the implementation details of an object aren&amp;rsquo;t accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn&amp;rsquo;t be able to reach into the object&amp;rsquo;s internals and change data or behavior directly. This enables the programmer to change and refactor an object&amp;rsquo;s internals without needing to change the code that uses the object.</source>
          <target state="translated">Otro aspecto com&amp;uacute;nmente asociado con OOP es la idea de &lt;em&gt;encapsulaci&amp;oacute;n&lt;/em&gt; , lo que significa que los detalles de implementaci&amp;oacute;n de un objeto no son accesibles al c&amp;oacute;digo que usa ese objeto. Por lo tanto, la &amp;uacute;nica forma de interactuar con un objeto es a trav&amp;eacute;s de su API p&amp;uacute;blica; el c&amp;oacute;digo que usa el objeto no deber&amp;iacute;a poder llegar a las partes internas del objeto y cambiar los datos o el comportamiento directamente. Esto permite al programador cambiar y refactorizar las partes internas de un objeto sin necesidad de cambiar el c&amp;oacute;digo que usa el objeto.</target>
        </trans-unit>
        <trans-unit id="3244c196f26eb3ebda5753ab0aa6df5308b053cc" translate="yes" xml:space="preserve">
          <source>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or &lt;code&gt;use super::File;&lt;/code&gt; which will import the types from the parent namespace. An example that causes this error is below:</source>
          <target state="translated">Otro caso que causa este error es cuando se importa un tipo a un m&amp;oacute;dulo principal. Para solucionar este problema, puede seguir la sugerencia y utilizar Archivo directamente o &lt;code&gt;use super::File;&lt;/code&gt; que importar&amp;aacute; los tipos del espacio de nombres principal. A continuaci&amp;oacute;n, se muestra un ejemplo que causa este error:</target>
        </trans-unit>
        <trans-unit id="f5177285c1540f1a230a9212d6ad08c740059bb0" translate="yes" xml:space="preserve">
          <source>Another case where this error is emitted is when a value is expected, but something else is found:</source>
          <target state="translated">Otro caso en el que se emite este error es cuando se espera un valor,pero se encuentra algo más:</target>
        </trans-unit>
        <trans-unit id="583bae5ce904e4cf097b6105871c304a4243a347" translate="yes" xml:space="preserve">
          <source>Another common use case for hash maps is to look up a key&amp;rsquo;s value and then update it based on the old value. For instance, Listing 8-26 shows code that counts how many times each word appears in some text. We use a hash map with the words as keys and increment the value to keep track of how many times we&amp;rsquo;ve seen that word. If it&amp;rsquo;s the first time we&amp;rsquo;ve seen a word, we&amp;rsquo;ll first insert the value 0.</source>
          <target state="translated">Otro caso de uso com&amp;uacute;n para los mapas hash es buscar el valor de una clave y luego actualizarlo en funci&amp;oacute;n del valor anterior. Por ejemplo, el Listado 8-26 muestra un c&amp;oacute;digo que cuenta cu&amp;aacute;ntas veces aparece cada palabra en alg&amp;uacute;n texto. Usamos un mapa hash con las palabras como claves e incrementamos el valor para realizar un seguimiento de cu&amp;aacute;ntas veces hemos visto esa palabra. Si es la primera vez que vemos una palabra, primero insertaremos el valor 0.</target>
        </trans-unit>
        <trans-unit id="6faac33ab3de2071db8e2f1ae3893ca39a492717" translate="yes" xml:space="preserve">
          <source>Another common way to evaluate an iterator is to use the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4154c9de58b2e0fcab49a95a24b663a485fc7b" translate="yes" xml:space="preserve">
          <source>Another crate that depends on this library would need &lt;code&gt;use&lt;/code&gt; statements that bring the items from &lt;code&gt;art&lt;/code&gt; into scope, specifying the module structure that&amp;rsquo;s currently defined. Listing 14-4 shows an example of a crate that uses the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; items from the &lt;code&gt;art&lt;/code&gt; crate:</source>
          <target state="translated">Otra caja que depende de esta biblioteca necesitar&amp;iacute;a declaraciones de &lt;code&gt;use&lt;/code&gt; que traigan los elementos del &lt;code&gt;art&lt;/code&gt; e al alcance, especificando la estructura del m&amp;oacute;dulo que est&amp;aacute; definida actualmente. El Listado 14-4 muestra un ejemplo de una caja que usa &lt;code&gt;PrimaryColor&lt;/code&gt; y &lt;code&gt;mix&lt;/code&gt; elementos de la caja de &lt;code&gt;art&lt;/code&gt; e :</target>
        </trans-unit>
        <trans-unit id="36e9fb79f8131b77a6b5deaea1a5127794ef21b6" translate="yes" xml:space="preserve">
          <source>Another data type that does not have ownership is the &lt;em&gt;slice&lt;/em&gt;. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</source>
          <target state="translated">Otro tipo de datos que no tiene propiedad es el &lt;em&gt;segmento&lt;/em&gt; . Los sectores le permiten hacer referencia a una secuencia contigua de elementos en una colecci&amp;oacute;n en lugar de a toda la colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2188fdee49af653aee0e28e4ac63dee8849194f0" translate="yes" xml:space="preserve">
          <source>Another detail to note is that Rust can&amp;rsquo;t protect you from all kinds of logic errors when you use &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. Recall in Chapter 15 that using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; came with the risk of creating reference cycles, where two &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; values refer to each other, causing memory leaks. Similarly, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; comes with the risk of creating &lt;em&gt;deadlocks&lt;/em&gt;. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you&amp;rsquo;re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;MutexGuard&lt;/code&gt; offers useful information.</source>
          <target state="translated">Otro detalle a tener en cuenta es que Rust no puede protegerte de todo tipo de errores l&amp;oacute;gicos cuando usas &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; . Recuerde en el Cap&amp;iacute;tulo 15 que el uso de &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; conlleva el riesgo de crear ciclos de referencia, donde dos valores &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; se refieren entre s&amp;iacute;, lo que provoca p&amp;eacute;rdidas de memoria. Del mismo modo, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; conlleva el riesgo de crear &lt;em&gt;interbloqueos&lt;/em&gt;. Esto ocurre cuando una operaci&amp;oacute;n necesita bloquear dos recursos y dos subprocesos han adquirido cada uno de los bloqueos, lo que hace que se esperen el uno al otro para siempre. Si est&amp;aacute; interesado en los puntos muertos, intente crear un programa de Rust que tenga un punto muerto; luego, investigue estrategias de mitigaci&amp;oacute;n de puntos muertos para mutex en cualquier idioma y pruebe a implementarlas en Rust. La documentaci&amp;oacute;n API de la biblioteca est&amp;aacute;ndar para ofrece informaci&amp;oacute;n &amp;uacute;til. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;MutexGuard&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a89f510396bf7e7d6ce47105d5094f9ffdc43c0a" translate="yes" xml:space="preserve">
          <source>Another difference between constants and static variables is that static variables can be mutable. Accessing and modifying mutable static variables is &lt;em&gt;unsafe&lt;/em&gt;. Listing 19-10 shows how to declare, access, and modify a mutable static variable named &lt;code&gt;COUNTER&lt;/code&gt;.</source>
          <target state="translated">Otra diferencia entre constantes y variables est&amp;aacute;ticas es que las variables est&amp;aacute;ticas pueden ser mutables. Acceder y modificar variables est&amp;aacute;ticas mutables &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;seguro&lt;/em&gt; . El listado 19-10 muestra c&amp;oacute;mo declarar, acceder y modificar una variable est&amp;aacute;tica mutable llamada &lt;code&gt;COUNTER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e6b390982d432e5d51ecddfefa741ac598bed4a" translate="yes" xml:space="preserve">
          <source>Another downside is that we&amp;rsquo;ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on the &lt;code&gt;State&lt;/code&gt; trait that return &lt;code&gt;self&lt;/code&gt;; however, this would violate object safety, because the trait doesn&amp;rsquo;t know what the concrete &lt;code&gt;self&lt;/code&gt; will be exactly. We want to be able to use &lt;code&gt;State&lt;/code&gt; as a trait object, so we need its methods to be object safe.</source>
          <target state="translated">Otro inconveniente es que hemos duplicado cierta l&amp;oacute;gica. Para eliminar parte de la duplicaci&amp;oacute;n, podr&amp;iacute;amos intentar realizar implementaciones predeterminadas para &lt;code&gt;request_review&lt;/code&gt; y &lt;code&gt;approve&lt;/code&gt; m&amp;eacute;todos en el rasgo de &lt;code&gt;State&lt;/code&gt; que devuelven &lt;code&gt;self&lt;/code&gt; ; sin embargo, esto violar&amp;iacute;a la seguridad del objeto, porque el rasgo no sabe qu&amp;eacute; ser&amp;aacute; exactamente el &lt;code&gt;self&lt;/code&gt; concreto . Queremos poder utilizar &lt;code&gt;State&lt;/code&gt; como un objeto de rasgo, por lo que necesitamos que sus m&amp;eacute;todos sean seguros para los objetos.</target>
        </trans-unit>
        <trans-unit id="0b90ca84780d33c44fc3e74f14be69eb7fd048f1" translate="yes" xml:space="preserve">
          <source>Another erroneous code example:</source>
          <target state="translated">Otro ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="b9c6fc1e93014c21a06c17d750322f830024d1b0" translate="yes" xml:space="preserve">
          <source>Another example of a complex NT is &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt;, which matches any fragment of the form &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; where &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; occurs at least once. Note that this complex NT does not have a dedicated separator token.</source>
          <target state="translated">Otro ejemplo de una NT compleja es &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt; , que coincide con cualquier fragmento de la forma &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; donde &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; ocurre al menos una vez. Tenga en cuenta que este NT complejo no tiene un s&amp;iacute;mbolo separador dedicado.</target>
        </trans-unit>
        <trans-unit id="7ec0f590b55aa6269d2b833239d2434dfe2c8db0" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c5ab10f51e34387707bf7df6173ca28d162973" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">Otro ejemplo de un tipo no &lt;code&gt;Sync&lt;/code&gt; es el puntero de conteo de referencias &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt; . Dada cualquier referencia &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , puede clonar un nuevo &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , modificando los recuentos de referencia de una manera no at&amp;oacute;mica.</target>
        </trans-unit>
        <trans-unit id="5d9b32be0b7923daf9aadae8867f04bd738917c6" translate="yes" xml:space="preserve">
          <source>Another example showing how to keep &lt;code&gt;Cow&lt;/code&gt; in a struct:</source>
          <target state="translated">Otro ejemplo que muestra c&amp;oacute;mo mantener &lt;code&gt;Cow&lt;/code&gt; en una estructura:</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73dbef5057ac390e03a6e177bceb38dfa0e2cca7" translate="yes" xml:space="preserve">
          <source>Another implication of the 4-byte fixed size of a &lt;code&gt;char&lt;/code&gt; is that per-&lt;code&gt;char&lt;/code&gt; processing can end up using a lot more memory:</source>
          <target state="translated">Otra implicaci&amp;oacute;n del tama&amp;ntilde;o fijo de 4 bytes de un &lt;code&gt;char&lt;/code&gt; es que per- &lt;code&gt;char&lt;/code&gt; de procesamiento puede terminar usando una memoria mucho m&amp;aacute;s:</target>
        </trans-unit>
        <trans-unit id="8ab43d76c6773436cfee7acbc8b6406943d7ca07" translate="yes" xml:space="preserve">
          <source>Another important difference between macros and functions is that you must define macros or bring them into scope &lt;em&gt;before&lt;/em&gt; you call them in a file, as opposed to functions you can define anywhere and call anywhere.</source>
          <target state="translated">Otra diferencia importante entre macros y funciones es que debe definir macros o traerlas al alcance &lt;em&gt;antes de&lt;/em&gt; llamarlas en un archivo, a diferencia de las funciones que puede definir en cualquier lugar y llamar en cualquier lugar.</target>
        </trans-unit>
        <trans-unit id="6f8bbe73702fb41924bac262bfb8595f3c660f2c" translate="yes" xml:space="preserve">
          <source>Another indicator that shows there&amp;rsquo;s room for improvement is the &lt;code&gt;config&lt;/code&gt; part of &lt;code&gt;parse_config&lt;/code&gt;, which implies that the two values we return are related and are both part of one configuration value. We&amp;rsquo;re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we could put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.</source>
          <target state="translated">Otro indicador que muestra que hay margen de mejora es la parte de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n de &lt;code&gt;parse_config&lt;/code&gt; , lo que implica que los dos valores que devolvemos est&amp;aacute;n relacionados y ambos forman parte de un valor de configuraci&amp;oacute;n. Actualmente no estamos transmitiendo este significado en la estructura de los datos m&amp;aacute;s que agrupando los dos valores en una tupla; podr&amp;iacute;amos poner los dos valores en una estructura y darle a cada uno de los campos de la estructura un nombre significativo. Si lo hace, ser&amp;aacute; m&amp;aacute;s f&amp;aacute;cil para los futuros mantenedores de este c&amp;oacute;digo comprender c&amp;oacute;mo se relacionan los diferentes valores entre s&amp;iacute; y cu&amp;aacute;l es su prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="00e0685682ab1fea96a488f384eaf2fdca89f82c" translate="yes" xml:space="preserve">
          <source>Another kind of generic that we&amp;rsquo;ve already been using is called &lt;em&gt;lifetimes&lt;/em&gt;. Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be. Let&amp;rsquo;s look at how lifetimes do that.</source>
          <target state="translated">Otro tipo de gen&amp;eacute;rico que ya hemos estado usando se llama &lt;em&gt;vidas&lt;/em&gt; . En lugar de garantizar que un tipo tenga el comportamiento que deseamos, las vidas &amp;uacute;tiles garantizan que las referencias sean v&amp;aacute;lidas siempre que las necesitemos. Veamos c&amp;oacute;mo las vidas hacen eso.</target>
        </trans-unit>
        <trans-unit id="310cbb5c9fbbbdff4450ff99ffebe8e97470ef1e" translate="yes" xml:space="preserve">
          <source>Another method, &lt;code&gt;expect&lt;/code&gt;, which is similar to &lt;code&gt;unwrap&lt;/code&gt;, lets us also choose the &lt;code&gt;panic!&lt;/code&gt; error message. Using &lt;code&gt;expect&lt;/code&gt; instead of &lt;code&gt;unwrap&lt;/code&gt; and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of &lt;code&gt;expect&lt;/code&gt; looks like this:</source>
          <target state="translated">Otro m&amp;eacute;todo, &lt;code&gt;expect&lt;/code&gt; , que es similar a &lt;code&gt;unwrap&lt;/code&gt; , &amp;iexcl;nos permite tambi&amp;eacute;n elegir el &lt;code&gt;panic!&lt;/code&gt; mensaje de error. Usar &lt;code&gt;expect&lt;/code&gt; lugar de &lt;code&gt;unwrap&lt;/code&gt; y proporcionar buenos mensajes de error puede transmitir su intenci&amp;oacute;n y facilitar el rastreo de la fuente del p&amp;aacute;nico. La sintaxis de &lt;code&gt;expect&lt;/code&gt; ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f5499cba2c47a56c76648e5bfb00e8274cd4700a" translate="yes" xml:space="preserve">
          <source>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust&amp;rsquo;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call &lt;em&gt;letters&lt;/em&gt;).</source>
          <target state="translated">Otro punto sobre UTF-8 es que en realidad hay tres formas relevantes de ver las cadenas desde la perspectiva de Rust: como bytes, valores escalares y grupos de grafemas (lo m&amp;aacute;s parecido a lo que llamar&amp;iacute;amos &lt;em&gt;letras&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="81bb35319cfe55cae7a1b6f8b640c268f984543f" translate="yes" xml:space="preserve">
          <source>Another problem you might be facing is this: suppose you've overloaded the &lt;code&gt;+&lt;/code&gt; operator for some type &lt;code&gt;Foo&lt;/code&gt; by implementing the &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt;, but you find that using &lt;code&gt;+=&lt;/code&gt; does not work, as in this example:</source>
          <target state="translated">Otro problema al que podr&amp;iacute;a estar enfrentando es el siguiente: suponga que ha sobrecargado el operador &lt;code&gt;+&lt;/code&gt; para alg&amp;uacute;n tipo &lt;code&gt;Foo&lt;/code&gt; al implementar &lt;code&gt;std::ops::Add&lt;/code&gt; trait para &lt;code&gt;Foo&lt;/code&gt; , pero encuentra que usar &lt;code&gt;+=&lt;/code&gt; no funciona, como en este ejemplo :</target>
        </trans-unit>
        <trans-unit id="aac5c18dffed07c8f0aa7695dfba8d6c18e4b19b" translate="yes" xml:space="preserve">
          <source>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn&amp;rsquo;t let you do unsafe operations, you couldn&amp;rsquo;t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let&amp;rsquo;s explore what we can do with unsafe Rust and how to do it.</source>
          <target state="translated">Otra raz&amp;oacute;n por la que Rust tiene un alter ego inseguro es que el hardware inform&amp;aacute;tico subyacente es intr&amp;iacute;nsecamente inseguro. Si Rust no le permiti&amp;oacute; realizar operaciones inseguras, no podr&amp;iacute;a realizar ciertas tareas. Rust necesita permitirle realizar programaci&amp;oacute;n de sistemas de bajo nivel, como interactuar directamente con el sistema operativo o incluso escribir su propio sistema operativo. Trabajar con programaci&amp;oacute;n de sistemas de bajo nivel es uno de los objetivos del lenguaje. Exploremos qu&amp;eacute; podemos hacer con el inseguro Rust y c&amp;oacute;mo hacerlo.</target>
        </trans-unit>
        <trans-unit id="ea0e4d862c74d436d68a36a2f5a91a9f7ba71ea8" translate="yes" xml:space="preserve">
          <source>Another shortcut for struct instantiation is available, used when you need to make a new struct that has the same values as most of a previous struct of the same type, called struct update syntax:</source>
          <target state="translated">Existe otro atajo para la instanciación de estructuras,que se utiliza cuando se necesita hacer una nueva estructura que tenga los mismos valores que la mayoría de una estructura anterior del mismo tipo,llamada sintaxis de actualización de estructuras:</target>
        </trans-unit>
        <trans-unit id="f3ef4925d92f67dd0f9c6ef4b106d217ff19945f" translate="yes" xml:space="preserve">
          <source>Another situation where this might be encountered is when spawning threads:</source>
          <target state="translated">Otra situación en la que esto podría encontrarse es cuando se desovan los hilos:</target>
        </trans-unit>
        <trans-unit id="34208ffcc5dda542066ff03ecbdd472bf7d5f1c2" translate="yes" xml:space="preserve">
          <source>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don&amp;rsquo;t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want &lt;code&gt;Cons&lt;/code&gt; variants to own their list, so reorganizing the data structure isn&amp;rsquo;t possible. Let&amp;rsquo;s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</source>
          <target state="translated">Otra soluci&amp;oacute;n para evitar los ciclos de referencia es reorganizar sus estructuras de datos para que algunas referencias expresen propiedad y otras no. Como resultado, puede tener ciclos compuestos por algunas relaciones de propiedad y algunas relaciones de no propiedad, y solo las relaciones de propiedad afectan si un valor se puede eliminar o no. En el Listado 15-25, siempre queremos que las variantes de &lt;code&gt;Cons&lt;/code&gt; sean due&amp;ntilde;as de su lista, por lo que no es posible reorganizar la estructura de datos. Veamos un ejemplo que utiliza gr&amp;aacute;ficos formados por nodos principales y nodos secundarios para ver cu&amp;aacute;ndo las relaciones de no propiedad son una forma adecuada de evitar ciclos de referencia.</target>
        </trans-unit>
        <trans-unit id="561d97b6164c78f724fabd7e84d16f2ca6a5f05e" translate="yes" xml:space="preserve">
          <source>Another style of doc comment, &lt;code&gt;//!&lt;/code&gt;, adds documentation to the item that contains the comments rather than adding documentation to the items following the comments. We typically use these doc comments inside the crate root file (&lt;em&gt;src/lib.rs&lt;/em&gt; by convention) or inside a module to document the crate or the module as a whole.</source>
          <target state="translated">Otro estilo de comentario de documento, &lt;code&gt;//!&lt;/code&gt; , agrega documentaci&amp;oacute;n al elemento que contiene los comentarios en lugar de agregar documentaci&amp;oacute;n a los elementos que siguen a los comentarios. Normalmente usamos estos comentarios de documentos dentro del archivo ra&amp;iacute;z de la caja ( &lt;em&gt;src / lib.rs&lt;/em&gt; por convenci&amp;oacute;n) o dentro de un m&amp;oacute;dulo para documentar la caja o el m&amp;oacute;dulo como un todo.</target>
        </trans-unit>
        <trans-unit id="7c509361e45630a3070d0b558a9e089279230886" translate="yes" xml:space="preserve">
          <source>Another use case for &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe5186a552091b0c590be070139e735a13d8759" translate="yes" xml:space="preserve">
          <source>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</source>
          <target state="translated">Otro uso de la pauta del nuevo tipo consiste en abstraer algunos detalles de implementación de un tipo:el nuevo tipo puede exponer una API pública que sea diferente de la API del tipo interno privado si utilizamos el nuevo tipo directamente para restringir la funcionalidad disponible,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="5796386c80b53dfd4fee86ac2eb96a8dcc028b10" translate="yes" xml:space="preserve">
          <source>Another useful feature of &lt;code&gt;impl&lt;/code&gt; blocks is that we&amp;rsquo;re allowed to define functions within &lt;code&gt;impl&lt;/code&gt; blocks that &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as a parameter. These are called &lt;em&gt;associated functions&lt;/em&gt; because they&amp;rsquo;re associated with the struct. They&amp;rsquo;re still functions, not methods, because they don&amp;rsquo;t have an instance of the struct to work with. You&amp;rsquo;ve already used the &lt;code&gt;String::from&lt;/code&gt; associated function.</source>
          <target state="translated">Otra caracter&amp;iacute;stica &amp;uacute;til de los bloques &lt;code&gt;impl&lt;/code&gt; es que se nos permite definir funciones dentro de bloques &lt;code&gt;impl&lt;/code&gt; que &lt;em&gt;no&lt;/em&gt; toman &lt;code&gt;self&lt;/code&gt; como par&amp;aacute;metro. Estas se denominan &lt;em&gt;funciones asociadas&lt;/em&gt; porque est&amp;aacute;n asociadas con la estructura. Siguen siendo funciones, no m&amp;eacute;todos, porque no tienen una instancia de la estructura con la que trabajar. Ya us&amp;oacute; la funci&amp;oacute;n asociada &lt;code&gt;String::from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30235cc37ef7579d4a5373609eca2f1e91e01f9f" translate="yes" xml:space="preserve">
          <source>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</source>
          <target state="translated">Otra característica útil de los brazos de fósforo es que pueden unirse a las partes de los valores que coinciden con el patrón.Así es como podemos extraer valores de las variantes de enumeración.</target>
        </trans-unit>
        <trans-unit id="03644769062de97f25c38104b0372355c4a77983" translate="yes" xml:space="preserve">
          <source>Another way is to do away with the associated type in &lt;code&gt;Maker&lt;/code&gt; and use an input type parameter instead:</source>
          <target state="translated">Otra forma es eliminar el tipo asociado en &lt;code&gt;Maker&lt;/code&gt; y usar un par&amp;aacute;metro de tipo de entrada en su lugar:</target>
        </trans-unit>
        <trans-unit id="6f7bb901bc2f8efc6ca57a7f109d4ad53f1c9e20" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using iterators and the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. We&amp;rsquo;ll be going into more detail about iterators and their associated methods in the &lt;a href=&quot;ch13-02-iterators&quot;&gt;&amp;rdquo;Processing a Series of Items with Iterators&amp;rdquo; section of Chapter 13&lt;/a&gt;. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc69aa411fffd31870708506663671f3a6766b5" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">Otra forma de construir un mapa hash es utilizando el m&amp;eacute;todo de &lt;code&gt;collect&lt;/code&gt; en un vector de tuplas, donde cada tupla consta de una clave y su valor. El m&amp;eacute;todo de &lt;code&gt;collect&lt;/code&gt; recopila datos en varios tipos de recopilaci&amp;oacute;n, incluido &lt;code&gt;HashMap&lt;/code&gt; . Por ejemplo, si tuvi&amp;eacute;ramos los nombres de los equipos y las puntuaciones iniciales en dos vectores separados, podr&amp;iacute;amos usar el m&amp;eacute;todo &lt;code&gt;zip&lt;/code&gt; para crear un vector de tuplas donde &amp;ldquo;Azul&amp;rdquo; se empareja con 10, y as&amp;iacute; sucesivamente. Luego, podr&amp;iacute;amos usar el m&amp;eacute;todo de &lt;code&gt;collect&lt;/code&gt; para convertir ese vector de tuplas en un mapa hash, como se muestra en el Listado 8-21.</target>
        </trans-unit>
        <trans-unit id="56bc825abe2ef1255ee87da2e4f261c23258e491" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">Otra forma de pensar sobre &lt;code&gt;flat_map()&lt;/code&gt; : el cierre del &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; a&lt;/a&gt; devuelve un elemento para cada elemento, y el &lt;code&gt;flat_map()&lt;/code&gt; devuelve un iterador para cada elemento.</target>
        </trans-unit>
        <trans-unit id="d1f28d9b77a5082f5c9d67a87d7ff9fdc9ab88db" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590fe2daae703b4f29d9d514cb7fe9863489ba23" translate="yes" xml:space="preserve">
          <source>Another way to access union fields is to use pattern matching. Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field. Since pattern matching is like reading the union with a particular field, it has to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks as well.</source>
          <target state="translated">Otra forma de acceder a los campos de uni&amp;oacute;n es utilizar la coincidencia de patrones. La coincidencia de patrones en los campos de uni&amp;oacute;n usa la misma sintaxis que los patrones de estructura, excepto que el patr&amp;oacute;n debe especificar exactamente un campo. Dado que la coincidencia de patrones es como leer la uni&amp;oacute;n con un campo en particular, tambi&amp;eacute;n debe colocarse en bloques &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9e5f7972ceab35649387701cac506db165c92f" translate="yes" xml:space="preserve">
          <source>Another way to have a collection of multiple values is with an &lt;em&gt;array&lt;/em&gt;. Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.</source>
          <target state="translated">Otra forma de tener una colecci&amp;oacute;n de valores m&amp;uacute;ltiples es con una &lt;em&gt;matriz&lt;/em&gt; . A diferencia de una tupla, todos los elementos de una matriz deben tener el mismo tipo. Las matrices en Rust son diferentes de las matrices en algunos otros lenguajes porque las matrices en Rust tienen una longitud fija, como las tuplas.</target>
        </trans-unit>
        <trans-unit id="6b16dbbf7d35ba29c07c44408e5ca0fc777803bb" translate="yes" xml:space="preserve">
          <source>Another way to provide the compiler with enough information, is to specify the generic type parameter:</source>
          <target state="translated">Otra forma de proporcionar al compilador suficiente información,es especificar el parámetro de tipo genérico:</target>
        </trans-unit>
        <trans-unit id="9b14c4635b7e156ee560ca02ddafb5c338efe01a" translate="yes" xml:space="preserve">
          <source>Another way we could implement &lt;code&gt;largest&lt;/code&gt; is for the function to return a reference to a &lt;code&gt;T&lt;/code&gt; value in the slice. If we change the return type to &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;T&lt;/code&gt;, thereby changing the body of the function to return a reference, we wouldn&amp;rsquo;t need the &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Copy&lt;/code&gt; trait bounds and we could avoid heap allocations. Try implementing these alternate solutions on your own!</source>
          <target state="translated">Otra forma en que podr&amp;iacute;amos implementar &lt;code&gt;largest&lt;/code&gt; es que la funci&amp;oacute;n devuelva una referencia a un valor &lt;code&gt;T&lt;/code&gt; en el segmento. Si cambiamos el tipo de retorno a &lt;code&gt;&amp;amp;T&lt;/code&gt; lugar de &lt;code&gt;T&lt;/code&gt; , cambiando as&amp;iacute; el cuerpo de la funci&amp;oacute;n para devolver una referencia, no necesitar&amp;iacute;amos los l&amp;iacute;mites del rasgo &lt;code&gt;Clone&lt;/code&gt; o &lt;code&gt;Copy&lt;/code&gt; y podr&amp;iacute;amos evitar asignaciones de mont&amp;oacute;n. &amp;iexcl;Intente implementar estas soluciones alternativas por su cuenta!</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="28a9dd9802c2f2d457b2df1a706228a0fe1e9650" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">Cualquier &lt;code&gt;BuildHasherDefault&lt;/code&gt; tiene &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;tama&amp;ntilde;o cero&lt;/a&gt; . Se puede crear por &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; . Cuando se usa &lt;code&gt;BuildHasherDefault&lt;/code&gt; con &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; , no es necesario hacerlo, ya que ellos mismos implementan las instancias &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; apropiadas .</target>
        </trans-unit>
        <trans-unit id="39acf470f03d64f751336d22936382dc10cf66e8" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;struct.buildhasherdefault#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c0cc711bc6806236220ae14adf5485763a3373" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;enum&lt;/code&gt; value consumes as much memory as the largest variant for its corresponding &lt;code&gt;enum&lt;/code&gt; type, as well as the size needed to store a discriminant.</source>
          <target state="translated">Cualquier valor de &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n consume tanta memoria como la variante m&amp;aacute;s grande para su tipo de &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n correspondiente , as&amp;iacute; como el tama&amp;ntilde;o necesario para almacenar un discriminante.</target>
        </trans-unit>
        <trans-unit id="6ab54097a9523b84f57f773009ba255a131e3917" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use &lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.</source>
          <target state="translated">Cualquier constructor &lt;code&gt;with_capacity&lt;/code&gt; indicar&amp;aacute; a la colecci&amp;oacute;n que asigne espacio suficiente para el n&amp;uacute;mero especificado de elementos. Idealmente, esto ser&amp;aacute; exactamente para esa cantidad de elementos, pero algunos detalles de implementaci&amp;oacute;n pueden evitarlo. Consulte la documentaci&amp;oacute;n espec&amp;iacute;fica de la colecci&amp;oacute;n para obtener m&amp;aacute;s detalles. En general, use &lt;code&gt;with_capacity&lt;/code&gt; cuando sepa exactamente cu&amp;aacute;ntos elementos se insertar&amp;aacute;n, o al menos tenga un l&amp;iacute;mite superior razonable en ese n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="0b673eb46a7f5984769da2ecfe123198574739d4" translate="yes" xml:space="preserve">
          <source>Any I/O error not part of this list.</source>
          <target state="translated">Cualquier error de E/S que no sea parte de esta lista.</target>
        </trans-unit>
        <trans-unit id="49edcccea744a8f077751ea25c38d4fc4cfa0fe8" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6867ac894a456ea99c7c6870f309c422acaaf4df" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of the variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">Cualquier dirección IP puede ser una dirección de la versión cuatro o de la versión seis,pero no ambas al mismo tiempo.Esa propiedad de las direcciones IP hace que la estructura de los datos enum sea apropiada,porque los valores enum sólo pueden ser una de las variantes.Tanto las direcciones de la versión cuatro como las de la versión seis siguen siendo fundamentalmente direcciones IP,por lo que deben ser tratadas como el mismo tipo cuando el código está manejando situaciones que se aplican a cualquier tipo de dirección IP.</target>
        </trans-unit>
        <trans-unit id="771cc11d8125e00769bce8eb3a9472fcb3c21cb2" translate="yes" xml:space="preserve">
          <source>Any character in the 'printable ASCII' range &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; inclusive is not escaped.</source>
          <target state="translated">Cualquier car&amp;aacute;cter en el rango de 'ASCII imprimible' &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; inclusive no tiene escape.</target>
        </trans-unit>
        <trans-unit id="3e6eb82cfd1ccce10703d68820085fb1a0e36401" translate="yes" xml:space="preserve">
          <source>Any characters, except this sequence</source>
          <target state="translated">Cualquier personaje,excepto esta secuencia</target>
        </trans-unit>
        <trans-unit id="4cd23fb2001ef303a1bdb9cc4bb51ec0898b0bb8" translate="yes" xml:space="preserve">
          <source>Any characters, except those listed</source>
          <target state="translated">Cualquier personaje,excepto los que figuran en la lista</target>
        </trans-unit>
        <trans-unit id="cf63f064edae30139fdd89fa67002f6be993edd6" translate="yes" xml:space="preserve">
          <source>Any conversions allowed by coercion can also be explicitly performed by the &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;type cast operator&lt;/a&gt;, &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de99d379f5705cbf09c5d5e30200a62d7427ee91" translate="yes" xml:space="preserve">
          <source>Any excess capacity is removed:</source>
          <target state="translated">Se elimina cualquier exceso de capacidad:</target>
        </trans-unit>
        <trans-unit id="cfff92a36bb4f2aba0bfefa3df53467014699fa5" translate="yes" xml:space="preserve">
          <source>Any implementation where a type appears &lt;a href=&quot;#uncovered-type&quot;&gt;uncovered&lt;/a&gt;. &lt;code&gt;impl&amp;lt;T&amp;gt; Foo for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for T&lt;/code&gt;, and &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; are considered blanket impls. However, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; is not a blanket impl, as all instances of &lt;code&gt;T&lt;/code&gt; which appear in this &lt;code&gt;impl&lt;/code&gt; are covered by &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eba9dcc5c9c9c3a4fc6d9f7d5233af8a7847a24" translate="yes" xml:space="preserve">
          <source>Any kind of aggregate constructor (array, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, tuple, ...)</source>
          <target state="translated">Cualquier tipo de constructor agregado (matriz, &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n , tupla, ...)</target>
        </trans-unit>
        <trans-unit id="a2d418110b6f755d1311536fe4acdfee5af1facd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error.</source>
          <target state="translated">Cualquier tipo de literal (cadena,entero,etc.)con cualquier sufijo es válido como ficha,y puede ser pasado a una macro sin producir un error.</target>
        </trans-unit>
        <trans-unit id="6f537d5097da9afc6f346b4806da2a5f2a4e11dd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error. The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbac428240bad16fb03767cc5cca3e5e71622e2" translate="yes" xml:space="preserve">
          <source>Any non-Unicode sequences are replaced with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cualquier secuencia que no sea Unicode se reemplaza con &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3df46fe98310c858bb458ed2bc6017d791596b12" translate="yes" xml:space="preserve">
          <source>Any of the characters in the range</source>
          <target state="translated">Cualquiera de los personajes en el rango</target>
        </trans-unit>
        <trans-unit id="df4bb3c1fbc6102d5b31f44ab7298372090f0684" translate="yes" xml:space="preserve">
          <source>Any of the characters listed</source>
          <target state="translated">Cualquiera de los personajes de la lista</target>
        </trans-unit>
        <trans-unit id="e1fe17e124adf671f41a6bcdb30bc09a9767a019" translate="yes" xml:space="preserve">
          <source>Any of the methods provided by a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; trait implemented by &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a type parameter, methods provided by trait bounds on &lt;code&gt;T&lt;/code&gt; are looked up first. Then all remaining methods in scope are looked up.</source>
          <target state="translated">Cualquiera de los m&amp;eacute;todos proporcionados por una &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; rasgo implementado por &lt;code&gt;T&lt;/code&gt; . Si &lt;code&gt;T&lt;/code&gt; es un par&amp;aacute;metro de tipo, los m&amp;eacute;todos proporcionados por los l&amp;iacute;mites del rasgo en &lt;code&gt;T&lt;/code&gt; se buscan primero. Luego, se buscan todos los m&amp;eacute;todos restantes dentro del alcance.</target>
        </trans-unit>
        <trans-unit id="5c8d97ac8cad3dfb222e1fcec0cd986d681f1547" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Arc::new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c05e8f1c6956f4765a713498f6a6547d98317e6" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Rc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Rc::new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19f15fb75a4bf5f47bda7e931808400dd6bf097" translate="yes" xml:space="preserve">
          <source>Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we&amp;rsquo;ve requested a review, the post should remain an unpublished draft.</source>
          <target state="translated">Cualquier otro cambio que se intente en una publicaci&amp;oacute;n no deber&amp;iacute;a tener ning&amp;uacute;n efecto. Por ejemplo, si intentamos aprobar un borrador de una publicaci&amp;oacute;n de blog antes de solicitar una revisi&amp;oacute;n, la publicaci&amp;oacute;n debe seguir siendo un borrador no publicado.</target>
        </trans-unit>
        <trans-unit id="d6894150447e47d12e66ba741e1dc8f000de5b10" translate="yes" xml:space="preserve">
          <source>Any other chars are given hex escapes of the form '\xNN'.</source>
          <target state="translated">A cualquier otro personaje se le dan escapes hexagonales de la forma '\xNN'.</target>
        </trans-unit>
        <trans-unit id="c7e7ce7ad0344363614031d689f8048423505a67" translate="yes" xml:space="preserve">
          <source>Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state. However, it does not guarantee that pointers to this memory will remain valid.</source>
          <target state="translated">Cualquier recurso que el valor administre,como la memoria de pila o el manejo de un archivo,permanecerá para siempre en un estado inalcanzable.Sin embargo,no garantiza que los indicadores de esta memoria sigan siendo válidos.</target>
        </trans-unit>
        <trans-unit id="4582f1278b61140a4c03b6946eaab9c9e43377c3" translate="yes" xml:space="preserve">
          <source>Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">Los sufijos se rechazan en las fichas literales no numéricas,y las fichas literales numéricas se aceptan sólo con los sufijos de la lista que figura a continuación.</target>
        </trans-unit>
        <trans-unit id="31bced9874925b40b1709b82b080279f57f95fc4" translate="yes" xml:space="preserve">
          <source>Any time a type &lt;code&gt;T&lt;/code&gt; is considered &lt;a href=&quot;#local-type&quot;&gt;local&lt;/a&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; are also considered local. Fundamental type constructors cannot &lt;a href=&quot;#uncovered-type&quot;&gt;cover&lt;/a&gt; other types. Any time the term &quot;covered type&quot; is used, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972a6afc1089fd19efd410e0369cd9e91a4ef0f3" translate="yes" xml:space="preserve">
          <source>Any time a type or function is provided by the standard library and you&amp;rsquo;re not sure what it does or how to use it, use the application programming interface (API) documentation to find out!</source>
          <target state="translated">Siempre que la biblioteca est&amp;aacute;ndar proporcione un tipo o funci&amp;oacute;n y no est&amp;eacute; seguro de qu&amp;eacute; hace o c&amp;oacute;mo usarlo, utilice la documentaci&amp;oacute;n de la interfaz de programaci&amp;oacute;n de aplicaciones (API) para averiguarlo.</target>
        </trans-unit>
        <trans-unit id="76deb7250dd43b06f05ef65522ed5c978849b0e5" translate="yes" xml:space="preserve">
          <source>Any type composed entirely of &lt;code&gt;Send&lt;/code&gt; types is automatically marked as &lt;code&gt;Send&lt;/code&gt; as well. Almost all primitive types are &lt;code&gt;Send&lt;/code&gt;, aside from raw pointers, which we&amp;rsquo;ll discuss in Chapter 19.</source>
          <target state="translated">Cualquier tipo compuesto completamente por tipos de &lt;code&gt;Send&lt;/code&gt; se marca autom&amp;aacute;ticamente como &lt;code&gt;Send&lt;/code&gt; . Casi todos los tipos primitivos son &lt;code&gt;Send&lt;/code&gt; , aparte de los punteros en bruto, que discutiremos en el Cap&amp;iacute;tulo 19.</target>
        </trans-unit>
        <trans-unit id="af69a2cb47235b6ee090b2e8285120ce18b240b2" translate="yes" xml:space="preserve">
          <source>Any type parameter or lifetime parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">Cualquier par&amp;aacute;metro de tipo o par&amp;aacute;metro de duraci&amp;oacute;n de un &lt;code&gt;impl&lt;/code&gt; debe cumplir al menos uno de los siguientes criterios:</target>
        </trans-unit>
        <trans-unit id="4b06ed0f2a9b9712d1ad4ec6082f1ea5cba3b543" translate="yes" xml:space="preserve">
          <source>Any type parameter parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f149c09f36db068ab34499979d351f1c8d5f7f1e" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788cf861093b3924fc04a0b5f4dac3cbdc3bb2d9" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfadd00c3ae966bd61c993066771bfd5d6d8d45d" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;PartialEq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07027ef0df88ca520ae158040613bfcdb04fbd90" translate="yes" xml:space="preserve">
          <source>Any types with interior mutability must also use the &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;cell::UnsafeCell&lt;/code&gt;&lt;/a&gt; wrapper around the value(s) which can be mutated through a shared reference. Failing to doing this is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. For example, &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt;-ing from &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is invalid.</source>
          <target state="translated">Cualquier tipo con mutabilidad interior tambi&amp;eacute;n debe usar la envoltura &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;cell::UnsafeCell&lt;/code&gt; &lt;/a&gt; alrededor de los valores que se pueden mutar a trav&amp;eacute;s de una referencia compartida. No hacer esto es &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;un comportamiento indefinido&lt;/a&gt; . Por ejemplo, &lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt; -ing de &lt;code&gt;&amp;amp;T&lt;/code&gt; a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="4098bab2016a26a2da921c6a4c090c6509eb5934" translate="yes" xml:space="preserve">
          <source>Any use other than with &lt;code&gt;if&lt;/code&gt; statements will probably not have an effect.</source>
          <target state="translated">Cualquier uso que no sea con declaraciones &lt;code&gt;if&lt;/code&gt; probablemente no tendr&amp;aacute; ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="910dd93279c47bcced2d261d2b21071bc5cf465a" translate="yes" xml:space="preserve">
          <source>Any::downcast_mut</source>
          <target state="translated">Any::downcast_mut</target>
        </trans-unit>
        <trans-unit id="3142933cd2ff31b31d3f631fe20ea508e96ad05b" translate="yes" xml:space="preserve">
          <source>Any::downcast_ref</source>
          <target state="translated">Any::downcast_ref</target>
        </trans-unit>
        <trans-unit id="47853f41e226da1c34d9eedcdb8b975ed79ec7bc" translate="yes" xml:space="preserve">
          <source>Any::fmt</source>
          <target state="translated">Any::fmt</target>
        </trans-unit>
        <trans-unit id="63f0fc770b243d87075e5d22567fc12df96b560f" translate="yes" xml:space="preserve">
          <source>Any::is</source>
          <target state="translated">Any::is</target>
        </trans-unit>
        <trans-unit id="153b1345e60af7ce7872d3438b64b0f7f8addb2c" translate="yes" xml:space="preserve">
          <source>Any::type_id</source>
          <target state="translated">Any::type_id</target>
        </trans-unit>
        <trans-unit id="4cde3fadbf976f0b359d3c2a1968c555ccde759f" translate="yes" xml:space="preserve">
          <source>Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There&amp;rsquo;s a full list of the teams &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;on Rust&amp;rsquo;s website&lt;/a&gt;, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there&amp;rsquo;s consensus to accept or reject the feature.</source>
          <target state="translated">Cualquiera puede escribir RFC para mejorar Rust, y las propuestas son revisadas y discutidas por el equipo de Rust, que est&amp;aacute; compuesto por muchos subequipos de temas. Hay una lista completa de los equipos &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;en el sitio web de Rust&lt;/a&gt; , que incluye equipos para cada &amp;aacute;rea del proyecto: dise&amp;ntilde;o del lenguaje, implementaci&amp;oacute;n del compilador, infraestructura, documentaci&amp;oacute;n y m&amp;aacute;s. El equipo apropiado lee la propuesta y los comentarios, escribe algunos comentarios propios y, finalmente, hay consenso para aceptar o rechazar la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="53fc70bfdc4b06ea1c2fe17e53fbb9c43726838e" translate="yes" xml:space="preserve">
          <source>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</source>
          <target state="translated">Aparte de un método o función con un parámetro de tipo genérico,este error puede producirse cuando no se puede inferir un parámetro de tipo de una estructura o rasgo.En ese caso no siempre es posible utilizar una anotación de tipo,porque todos los candidatos tienen el mismo tipo de retorno.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b813c448dbc23e1f367ecbf1266f8f07cadc0bab" translate="yes" xml:space="preserve">
          <source>Apart from lifetime extension, the temporary scope of an expression is the smallest scope that contains the expression and is for one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="56e2c591df0fef929570597dca64284006730141" translate="yes" xml:space="preserve">
          <source>Appending to a String with &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;</source>
          <target state="translated">Agregar a una cadena con &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; y &lt;code&gt;push&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3f60044b06335eb6c4230e3c39f5e0218445878" translate="yes" xml:space="preserve">
          <source>Appendix</source>
          <target state="translated">Appendix</target>
        </trans-unit>
        <trans-unit id="4c40c194c9cdc4d680691d4aa8fa1913dc98b2c3" translate="yes" xml:space="preserve">
          <source>Appendix A, &amp;ldquo;Keywords,&amp;rdquo; also explains the new raw identifiers feature that enables code written in the 2015 Edition and the 2018 Edition to interoperate.</source>
          <target state="translated">El Ap&amp;eacute;ndice A, &quot;Palabras clave&quot;, tambi&amp;eacute;n explica la nueva funci&amp;oacute;n de identificadores sin procesar que permite que el c&amp;oacute;digo escrito en la edici&amp;oacute;n 2015 y la edici&amp;oacute;n 2018 interoperen.</target>
        </trans-unit>
        <trans-unit id="8415247b515164394b09f1335fc5dabc83b9e17a" translate="yes" xml:space="preserve">
          <source>Appendix A: Keywords</source>
          <target state="translated">Apéndice A:Palabras clave</target>
        </trans-unit>
        <trans-unit id="540243de89d6ff78feccd1151f1eeb23d45eae75" translate="yes" xml:space="preserve">
          <source>Appendix B: Operators and Symbols</source>
          <target state="translated">Apéndice B:Operadores y símbolos</target>
        </trans-unit>
        <trans-unit id="e440a4e5c41dd9d1d57a9a1afc26c19786ef345a" translate="yes" xml:space="preserve">
          <source>Appendix C: Derivable Traits</source>
          <target state="translated">Apéndice C:Características derivadas</target>
        </trans-unit>
        <trans-unit id="41116b5529dd9b48afe443e282c8edc6aed9a707" translate="yes" xml:space="preserve">
          <source>Appendix D - Useful Development Tools</source>
          <target state="translated">Apéndice D-Herramientas útiles para el desarrollo</target>
        </trans-unit>
        <trans-unit id="707523bd94a1c061f370a00dc35452edc4f5ca2b" translate="yes" xml:space="preserve">
          <source>Appendix D is now titled &amp;ldquo;Useful Development Tools&amp;rdquo; and covers recently released tools that help you write Rust code.</source>
          <target state="translated">El Ap&amp;eacute;ndice D ahora se titula &quot;Herramientas de desarrollo &amp;uacute;tiles&quot; y cubre las herramientas lanzadas recientemente que lo ayudan a escribir c&amp;oacute;digo Rust.</target>
        </trans-unit>
        <trans-unit id="e50a67316708bcdc8cd3a1c83a15ee617b6e1717" translate="yes" xml:space="preserve">
          <source>Appendix E - Editions</source>
          <target state="translated">Apéndice E-Ediciones</target>
        </trans-unit>
        <trans-unit id="db95e2a46f6e17f889e1ec8cb84b232b2ac6a554" translate="yes" xml:space="preserve">
          <source>Appendix F: Translations of the Book</source>
          <target state="translated">Apéndice F:Traducciones del libro</target>
        </trans-unit>
        <trans-unit id="cd9cd2e1d4c917e818f77ba2a0d93ffcdf7874d2" translate="yes" xml:space="preserve">
          <source>Appendix G - How Rust is Made and &amp;ldquo;Nightly Rust&amp;rdquo;</source>
          <target state="translated">Ap&amp;eacute;ndice G - C&amp;oacute;mo se produce el &amp;oacute;xido y &quot;&amp;oacute;xido nocturno&quot;</target>
        </trans-unit>
        <trans-unit id="7ea8d3526ea6b8af40ac97da94b0ad40d6cea127" translate="yes" xml:space="preserve">
          <source>Appendix chapters providing rationale and references to languages that influenced the design.</source>
          <target state="translated">Los capítulos del apéndice proporcionan la justificación y las referencias a los idiomas que influyeron en el diseño.</target>
        </trans-unit>
        <trans-unit id="0d6a0bfa8816321ae3291d75b6bf84f8077fe48b" translate="yes" xml:space="preserve">
          <source>Appendix: Macro Follow-Set Ambiguity Formal Specification</source>
          <target state="translated">Apéndice:Especificación formal de la ambigüedad del conjunto de seguimiento de macros</target>
        </trans-unit>
        <trans-unit id="54e814d184dccc0b7473b24d35812b283adff9c0" translate="yes" xml:space="preserve">
          <source>Appends a given string slice onto the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Agrega un segmento de cadena determinado al final de esta &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5ef47a12f2696c33dc462f202e22f6e229647a" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a collection.</source>
          <target state="translated">Añade un elemento al fondo de una colección.</target>
        </trans-unit>
        <trans-unit id="ddf4cf8edbc5fa033e85502f0a84bfe8b2914aec" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a list.</source>
          <target state="translated">Añade un elemento al final de la lista.</target>
        </trans-unit>
        <trans-unit id="9427717eceb820f7ae4720310e1343f09df153f2" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of the &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">Agrega un elemento a la parte posterior de &lt;code&gt;VecDeque&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="373311f9bb46882cd119d03cfc2b6fa19fdf5ba3" translate="yes" xml:space="preserve">
          <source>Appends the given &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Agrega el &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; dado al final de esta &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f88d43733a3d3b030bf7286e9ed4c303cc3a7d2b" translate="yes" xml:space="preserve">
          <source>Application Binary Interface (ABI)</source>
          <target state="translated">Interfaz binaria de aplicación (ABI)</target>
        </trans-unit>
        <trans-unit id="9a4440ced79c9610e5a61ec32030ae30f58d9a8c" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;), or returns the provided default (if &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed8e79e380caf3902110314a704f53a22b3ecbe" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or computes a default (if not).</source>
          <target state="translated">Aplica una función al valor contenido (si lo hay),o calcula un valor por defecto (si no lo hay).</target>
        </trans-unit>
        <trans-unit id="ef8795473614177b83e201e3db900beeef41c1e2" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or returns the provided default (if not).</source>
          <target state="translated">Aplica una función al valor contenido (si lo hay),o devuelve el valor predeterminado proporcionado (si no lo hay).</target>
        </trans-unit>
        <trans-unit id="a6be2123eb22e6f1506885d0c1439a3655475eac" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result.</source>
          <target state="translated">Aplica la función a los elementos del iterador y devuelve el primer resultado no nulo.</target>
        </trans-unit>
        <trans-unit id="2f579750efee0b6f5e959f71ab15df216a9fb1b9" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Aplica la funci&amp;oacute;n a los elementos del iterador y devuelve el primer resultado que no es ninguno. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7da1899028718ec8a07b6c08455d63f4e3489b90" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Aplica la funci&amp;oacute;n a los elementos del iterador y devuelve el primer resultado que no es ninguno. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f3002a1274a5209b380bd8bf18387ed22cf040f" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Aplica la funci&amp;oacute;n a los elementos del iterador y devuelve el primer resultado que no es ninguno. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67cbbc3631a3803076e70ec9a10a8358879f6e02" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Aplica la funci&amp;oacute;n a los elementos del iterador y devuelve el primer resultado que no es ninguno. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8819d96feaef2f02cd8965c68d9eb2580ebfc977" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Aplica la funci&amp;oacute;n a los elementos del iterador y devuelve el primer resultado que no es ninguno. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c71f5fd4b8bc9dae7fc6bb52c696f533ce8ed924" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd078bc0e6ebca661ba36b845bc2f34f79671219" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f3965e6fc53b243d5a7c2dc2282a44cca3805a" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb07d601f2efbf0db36543c96f74916e4858345" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe6a04d1d11293ba9f6db79767b686fae8501d1" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813b671e50d44d7d39a003bdb093dc2cdbf235f8" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff8e99aa0f8295d1776562bee993cb0a364606b" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function.</source>
          <target state="translated">Aplica el &quot;?&quot; operador. Un retorno de &lt;code&gt;Ok(t)&lt;/code&gt; significa que la ejecuci&amp;oacute;n deber&amp;iacute;a continuar normalmente, y el resultado de &lt;code&gt;?&lt;/code&gt; es el valor &lt;code&gt;t&lt;/code&gt; . Un retorno de &lt;code&gt;Err(e)&lt;/code&gt; significa que la ejecuci&amp;oacute;n debe bifurcarse al &lt;code&gt;catch&lt;/code&gt; que lo encierra m&amp;aacute;s interno , o regresar de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d771dbfeb7c050dea75fe4d6749833e3ae20e4ae" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Aplica el &quot;?&quot; operador. Un retorno de &lt;code&gt;Ok(t)&lt;/code&gt; significa que la ejecuci&amp;oacute;n deber&amp;iacute;a continuar normalmente, y el resultado de &lt;code&gt;?&lt;/code&gt; es el valor &lt;code&gt;t&lt;/code&gt; . Un retorno de &lt;code&gt;Err(e)&lt;/code&gt; significa que la ejecuci&amp;oacute;n debe bifurcarse al &lt;code&gt;catch&lt;/code&gt; que lo encierra m&amp;aacute;s interno , o regresar de la funci&amp;oacute;n. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84c127ccde0ff66daa4ff755926ef467d8ab1d62" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6233fb9390747dc2f23a28899738d6cc6a72590f" translate="yes" xml:space="preserve">
          <source>Applying the attribute to a function &lt;code&gt;f&lt;/code&gt; allows code within &lt;code&gt;f&lt;/code&gt; to get a hint of the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the &quot;topmost&quot; tracked call that led to &lt;code&gt;f&lt;/code&gt;'s invocation. At the point of observation, an implementation behaves as if it walks up the stack from &lt;code&gt;f&lt;/code&gt;'s frame to find the nearest frame of an &lt;em&gt;unattributed&lt;/em&gt; function &lt;code&gt;outer&lt;/code&gt;, and it returns the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the tracked call in &lt;code&gt;outer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8404e9317204d7715d2f49a56717841155af3a5d" translate="yes" xml:space="preserve">
          <source>Approximate desugaring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e15c6fd69af4acca9c9f459c798f3ae0c37890f" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10.</source>
          <target state="translated">Número aproximado de dígitos significativos en la base 10.</target>
        </trans-unit>
        <trans-unit id="741aa1a23115e831e460da0298845488131bda9a" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f32#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f32::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8912ed7e59aeef6ce8c4355dd3b80515ddbd4f1" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f64#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f64::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="59cfa485c658b8f9969a88c2eb92540fdf722cfd" translate="yes" xml:space="preserve">
          <source>Arc::as_ref</source>
          <target state="translated">Arc::as_ref</target>
        </trans-unit>
        <trans-unit id="2f1c5ec3613e810179b1dde9e1ff629a07f45de3" translate="yes" xml:space="preserve">
          <source>Arc::borrow</source>
          <target state="translated">Arc::borrow</target>
        </trans-unit>
        <trans-unit id="e6381920a9fbe9f6076603c436d6eef9b74e1f24" translate="yes" xml:space="preserve">
          <source>Arc::borrow_mut</source>
          <target state="translated">Arc::borrow_mut</target>
        </trans-unit>
        <trans-unit id="de0c16869f1a3fad5d726dc3e3fba2293f156861" translate="yes" xml:space="preserve">
          <source>Arc::clamp</source>
          <target state="translated">Arc::clamp</target>
        </trans-unit>
        <trans-unit id="9fa492e8fa6e20e1b52a4de7403dbe55ec1b79bf" translate="yes" xml:space="preserve">
          <source>Arc::clone</source>
          <target state="translated">Arc::clone</target>
        </trans-unit>
        <trans-unit id="39cf0d205cd739521ce28938f9a2250155c1bac4" translate="yes" xml:space="preserve">
          <source>Arc::clone_from</source>
          <target state="translated">Arc::clone_from</target>
        </trans-unit>
        <trans-unit id="773d06cfd159d4606ff3014fee5f9931067cf220" translate="yes" xml:space="preserve">
          <source>Arc::clone_into</source>
          <target state="translated">Arc::clone_into</target>
        </trans-unit>
        <trans-unit id="7561059135cbd0c5fbb5238091fd429a9e1b09c1" translate="yes" xml:space="preserve">
          <source>Arc::cmp</source>
          <target state="translated">Arc::cmp</target>
        </trans-unit>
        <trans-unit id="b73ea8e602ed4ab4007a418f3f6cee6a05a73996" translate="yes" xml:space="preserve">
          <source>Arc::default</source>
          <target state="translated">Arc::default</target>
        </trans-unit>
        <trans-unit id="cdd18aaa5e1ccdcb1656e6b3c539ea6dd22d2613" translate="yes" xml:space="preserve">
          <source>Arc::deref</source>
          <target state="translated">Arc::deref</target>
        </trans-unit>
        <trans-unit id="3d5ef1d21d6636272bbb1c82a7af354e776cadde" translate="yes" xml:space="preserve">
          <source>Arc::downcast</source>
          <target state="translated">Arc::downcast</target>
        </trans-unit>
        <trans-unit id="8f4a9849100a7720ad47a02d98c3cc428143986f" translate="yes" xml:space="preserve">
          <source>Arc::downgrade</source>
          <target state="translated">Arc::downgrade</target>
        </trans-unit>
        <trans-unit id="4d05d06001426353e874710f4e01911168266628" translate="yes" xml:space="preserve">
          <source>Arc::drop</source>
          <target state="translated">Arc::drop</target>
        </trans-unit>
        <trans-unit id="d616628ce7e2e600feb8196c85f5e01fa37ae824" translate="yes" xml:space="preserve">
          <source>Arc::eq</source>
          <target state="translated">Arc::eq</target>
        </trans-unit>
        <trans-unit id="541daae394114016fc018c7425373988b033cde5" translate="yes" xml:space="preserve">
          <source>Arc::fmt</source>
          <target state="translated">Arc::fmt</target>
        </trans-unit>
        <trans-unit id="c5939b1aa685e46bfb67eeb83668be8ab9a5dab1" translate="yes" xml:space="preserve">
          <source>Arc::from</source>
          <target state="translated">Arc::from</target>
        </trans-unit>
        <trans-unit id="dea799f19377ba936fa669465a1dea313ae3aa7a" translate="yes" xml:space="preserve">
          <source>Arc::from_raw</source>
          <target state="translated">Arc::from_raw</target>
        </trans-unit>
        <trans-unit id="6910e0ecb20317c068e1ba9e8ebf007d417f95a2" translate="yes" xml:space="preserve">
          <source>Arc::ge</source>
          <target state="translated">Arc::ge</target>
        </trans-unit>
        <trans-unit id="7e24d2d9f75e2ea02439ac0bd0d3b07ceaa736e4" translate="yes" xml:space="preserve">
          <source>Arc::get_mut</source>
          <target state="translated">Arc::get_mut</target>
        </trans-unit>
        <trans-unit id="e94b486a276abc7bcb5888a4d6fc97a6fa8eebaa" translate="yes" xml:space="preserve">
          <source>Arc::gt</source>
          <target state="translated">Arc::gt</target>
        </trans-unit>
        <trans-unit id="f233cce03a62c687a1d4be5e670e3be37d179359" translate="yes" xml:space="preserve">
          <source>Arc::hash</source>
          <target state="translated">Arc::hash</target>
        </trans-unit>
        <trans-unit id="963937d635066d272a6f67596279f6b16956abdb" translate="yes" xml:space="preserve">
          <source>Arc::hash_slice</source>
          <target state="translated">Arc::hash_slice</target>
        </trans-unit>
        <trans-unit id="2b8954f29938fa3429d664d59b2922996301d34a" translate="yes" xml:space="preserve">
          <source>Arc::into</source>
          <target state="translated">Arc::into</target>
        </trans-unit>
        <trans-unit id="24e83cc9b0b264818fc7b3695d912fc8e4d9e845" translate="yes" xml:space="preserve">
          <source>Arc::into_raw</source>
          <target state="translated">Arc::into_raw</target>
        </trans-unit>
        <trans-unit id="921d5aa53e181c2612da9bf23381db35c63bd321" translate="yes" xml:space="preserve">
          <source>Arc::into_raw_non_null</source>
          <target state="translated">Arc::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="f3473006930ab6b55f7aef32c93c0af0f87e7790" translate="yes" xml:space="preserve">
          <source>Arc::le</source>
          <target state="translated">Arc::le</target>
        </trans-unit>
        <trans-unit id="34b95793d03cc8c6cef222cea98c6e99dc74e9e2" translate="yes" xml:space="preserve">
          <source>Arc::lt</source>
          <target state="translated">Arc::lt</target>
        </trans-unit>
        <trans-unit id="eab1ca96353cac811bc765a502fbbe1723278950" translate="yes" xml:space="preserve">
          <source>Arc::make_mut</source>
          <target state="translated">Arc::make_mut</target>
        </trans-unit>
        <trans-unit id="0a9a2e87881627fae4b58af4ea1e4cdaa0c36395" translate="yes" xml:space="preserve">
          <source>Arc::max</source>
          <target state="translated">Arc::max</target>
        </trans-unit>
        <trans-unit id="431ba8a8a73b16f867d8367c027605d9a9f25a4e" translate="yes" xml:space="preserve">
          <source>Arc::min</source>
          <target state="translated">Arc::min</target>
        </trans-unit>
        <trans-unit id="a700586ffae96fc24dca7f29fd88b64a47bae03d" translate="yes" xml:space="preserve">
          <source>Arc::ne</source>
          <target state="translated">Arc::ne</target>
        </trans-unit>
        <trans-unit id="1311cfe952a5208cf9ab108dab2eb693395bbca1" translate="yes" xml:space="preserve">
          <source>Arc::new</source>
          <target state="translated">Arc::new</target>
        </trans-unit>
        <trans-unit id="2c2d4efc7b27aae2edec462666037bcaf500cae7" translate="yes" xml:space="preserve">
          <source>Arc::partial_cmp</source>
          <target state="translated">Arc::partial_cmp</target>
        </trans-unit>
        <trans-unit id="41a523a445899356c297537c4b72fff018176305" translate="yes" xml:space="preserve">
          <source>Arc::pin</source>
          <target state="translated">Arc::pin</target>
        </trans-unit>
        <trans-unit id="1d09dbe8f647daf2ca429c9d36141d61d7d2799f" translate="yes" xml:space="preserve">
          <source>Arc::ptr_eq</source>
          <target state="translated">Arc::ptr_eq</target>
        </trans-unit>
        <trans-unit id="ec8427607c6875d57c1cbb7ae116c8a1b2bc9f8b" translate="yes" xml:space="preserve">
          <source>Arc::strong_count</source>
          <target state="translated">Arc::strong_count</target>
        </trans-unit>
        <trans-unit id="12f7dc5817d10cbbabc6ff3c697a1ca67ff339d5" translate="yes" xml:space="preserve">
          <source>Arc::to_owned</source>
          <target state="translated">Arc::to_owned</target>
        </trans-unit>
        <trans-unit id="dd1da4e8925e8953dfb4aef0354dd388c867af08" translate="yes" xml:space="preserve">
          <source>Arc::to_string</source>
          <target state="translated">Arc::to_string</target>
        </trans-unit>
        <trans-unit id="b36b4607ae74c4708612a87739b787ab550df768" translate="yes" xml:space="preserve">
          <source>Arc::try_from</source>
          <target state="translated">Arc::try_from</target>
        </trans-unit>
        <trans-unit id="450b59e4892b86614294b44b39674630d4067a1f" translate="yes" xml:space="preserve">
          <source>Arc::try_into</source>
          <target state="translated">Arc::try_into</target>
        </trans-unit>
        <trans-unit id="8cc0a8e7a4fa3ddf0be44f0e2f8210b7538bff4d" translate="yes" xml:space="preserve">
          <source>Arc::try_unwrap</source>
          <target state="translated">Arc::try_unwrap</target>
        </trans-unit>
        <trans-unit id="e60b417105d1b796fbb9108c579b5a5a3f60ab78" translate="yes" xml:space="preserve">
          <source>Arc::type_id</source>
          <target state="translated">Arc::type_id</target>
        </trans-unit>
        <trans-unit id="6623270e41b383306513b26dd0972d02a62dabdc" translate="yes" xml:space="preserve">
          <source>Arc::weak_count</source>
          <target state="translated">Arc::weak_count</target>
        </trans-unit>
        <trans-unit id="bcef6163f2366764b97712c1e02d4e8de8728060" translate="yes" xml:space="preserve">
          <source>Archimedes' constant (&amp;pi;)</source>
          <target state="translated">Constante de Arqu&amp;iacute;medes (&amp;pi;)</target>
        </trans-unit>
        <trans-unit id="02d36a6ada7ba4a678771b24dc19a1d26e06d584" translate="yes" xml:space="preserve">
          <source>Are allowed to be null</source>
          <target state="translated">Se les permite ser nulos</target>
        </trans-unit>
        <trans-unit id="7bcd778277bf4c00f69bda3256c3718425635b4a" translate="yes" xml:space="preserve">
          <source>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</source>
          <target state="translated">Se les permite ignorar las reglas de préstamo al tener tanto punteros inmutables como mutables o múltiples punteros mutables a la misma ubicación</target>
        </trans-unit>
        <trans-unit id="79232b3ded8b7d0b1c86ea5d989ec5b302602c26" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t guaranteed to point to valid memory</source>
          <target state="translated">No se garantiza que apunten a una memoria v&amp;aacute;lida</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="11997e344b54f51ca26eed6c34abb35c17719846" translate="yes" xml:space="preserve">
          <source>Args::all</source>
          <target state="translated">Args::all</target>
        </trans-unit>
        <trans-unit id="834e48f2681bde9c6de2a1d6fe4ea459480940da" translate="yes" xml:space="preserve">
          <source>Args::any</source>
          <target state="translated">Args::any</target>
        </trans-unit>
        <trans-unit id="852de3f0c6270398ac654986a4377df5f50c393c" translate="yes" xml:space="preserve">
          <source>Args::borrow</source>
          <target state="translated">Args::borrow</target>
        </trans-unit>
        <trans-unit id="8aa2c84655d80e6196471b5bce3e6eb8f9d79f61" translate="yes" xml:space="preserve">
          <source>Args::borrow_mut</source>
          <target state="translated">Args::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6235293cd6910b3c74977e8687ec90afadb03077" translate="yes" xml:space="preserve">
          <source>Args::by_ref</source>
          <target state="translated">Args::by_ref</target>
        </trans-unit>
        <trans-unit id="4438640d50dfd08974f7aac6bf0d2aecb461c3f5" translate="yes" xml:space="preserve">
          <source>Args::chain</source>
          <target state="translated">Args::chain</target>
        </trans-unit>
        <trans-unit id="fd443c43e63db2a659b5f263c42823b6b670bd44" translate="yes" xml:space="preserve">
          <source>Args::cloned</source>
          <target state="translated">Args::cloned</target>
        </trans-unit>
        <trans-unit id="46277936c8445a042e94cc3a26942468f91253e9" translate="yes" xml:space="preserve">
          <source>Args::cmp</source>
          <target state="translated">Args::cmp</target>
        </trans-unit>
        <trans-unit id="48dd95fc8d6a07728f5a1cf7809d55524bf20034" translate="yes" xml:space="preserve">
          <source>Args::collect</source>
          <target state="translated">Args::collect</target>
        </trans-unit>
        <trans-unit id="9d0c9a3a72db97b3f6cab2b952f231796f20a50c" translate="yes" xml:space="preserve">
          <source>Args::copied</source>
          <target state="translated">Args::copied</target>
        </trans-unit>
        <trans-unit id="4fbeb4376f2e8b5f2155e6dbdec8f0740c8c04c9" translate="yes" xml:space="preserve">
          <source>Args::count</source>
          <target state="translated">Args::count</target>
        </trans-unit>
        <trans-unit id="4a06de4989ebe4016d146a0bb3c59a627e816965" translate="yes" xml:space="preserve">
          <source>Args::cycle</source>
          <target state="translated">Args::cycle</target>
        </trans-unit>
        <trans-unit id="dbd2a1eb1e566bd90b7919caa38a19ccb4685bdf" translate="yes" xml:space="preserve">
          <source>Args::enumerate</source>
          <target state="translated">Args::enumerate</target>
        </trans-unit>
        <trans-unit id="d22f2ebcc4f66631a8b99dffd5e42317b95a23c3" translate="yes" xml:space="preserve">
          <source>Args::eq</source>
          <target state="translated">Args::eq</target>
        </trans-unit>
        <trans-unit id="825fef0560348f1a6b9c4b27b6c58018c4f453ef" translate="yes" xml:space="preserve">
          <source>Args::filter</source>
          <target state="translated">Args::filter</target>
        </trans-unit>
        <trans-unit id="ab08ac4972fbd0c43add6cedcff53d5b9d40bc35" translate="yes" xml:space="preserve">
          <source>Args::filter_map</source>
          <target state="translated">Args::filter_map</target>
        </trans-unit>
        <trans-unit id="86056472eedb8eee7dbef63077919c7204cfa67b" translate="yes" xml:space="preserve">
          <source>Args::find</source>
          <target state="translated">Args::find</target>
        </trans-unit>
        <trans-unit id="e877bf0f63fb53fe48a38a7b49bdba91724d4dc9" translate="yes" xml:space="preserve">
          <source>Args::find_map</source>
          <target state="translated">Args::find_map</target>
        </trans-unit>
        <trans-unit id="09774b60a814c8b4104b1538a3d2232fe023f569" translate="yes" xml:space="preserve">
          <source>Args::flat_map</source>
          <target state="translated">Args::flat_map</target>
        </trans-unit>
        <trans-unit id="5eeb63d240af1b2ec0ce621fdcebe38dd652ee35" translate="yes" xml:space="preserve">
          <source>Args::flatten</source>
          <target state="translated">Args::flatten</target>
        </trans-unit>
        <trans-unit id="2824f41303961ce133138bbb9cdb7c73c49c034e" translate="yes" xml:space="preserve">
          <source>Args::fmt</source>
          <target state="translated">Args::fmt</target>
        </trans-unit>
        <trans-unit id="bdc321df53c7563363bb091073cc745371fec866" translate="yes" xml:space="preserve">
          <source>Args::fold</source>
          <target state="translated">Args::fold</target>
        </trans-unit>
        <trans-unit id="0bfb713bd78f482e7b1b8ccad2fb85c3059b45d0" translate="yes" xml:space="preserve">
          <source>Args::for_each</source>
          <target state="translated">Args::for_each</target>
        </trans-unit>
        <trans-unit id="bf62c774de1d7877320ea0fd8f640a1da6f668ae" translate="yes" xml:space="preserve">
          <source>Args::from</source>
          <target state="translated">Args::from</target>
        </trans-unit>
        <trans-unit id="4b2d02be4c99f1b285f809b3bada4d6e1d5de2c4" translate="yes" xml:space="preserve">
          <source>Args::fuse</source>
          <target state="translated">Args::fuse</target>
        </trans-unit>
        <trans-unit id="e9d47e65f07958eb4c539e9aa4794d4c91301d74" translate="yes" xml:space="preserve">
          <source>Args::ge</source>
          <target state="translated">Args::ge</target>
        </trans-unit>
        <trans-unit id="41716a498dc92ecead97571d6a7701faab3446af" translate="yes" xml:space="preserve">
          <source>Args::gt</source>
          <target state="translated">Args::gt</target>
        </trans-unit>
        <trans-unit id="ffe407b598fd64603f4cdfacf4c22332227c8373" translate="yes" xml:space="preserve">
          <source>Args::inspect</source>
          <target state="translated">Args::inspect</target>
        </trans-unit>
        <trans-unit id="4982b89e7bce55b901b94270e4e00a5ac09ba3e0" translate="yes" xml:space="preserve">
          <source>Args::into</source>
          <target state="translated">Args::into</target>
        </trans-unit>
        <trans-unit id="2fc7d02ccfe30c7d6decfb090f0a5dcabb2e0c43" translate="yes" xml:space="preserve">
          <source>Args::into_iter</source>
          <target state="translated">Args::into_iter</target>
        </trans-unit>
        <trans-unit id="0cc324954d5e5cfc9f0640a45fd39c06463171c8" translate="yes" xml:space="preserve">
          <source>Args::is_empty</source>
          <target state="translated">Args::is_empty</target>
        </trans-unit>
        <trans-unit id="9320ccfba6fb85da2cd8f4ea07146d9e90d55e69" translate="yes" xml:space="preserve">
          <source>Args::is_sorted</source>
          <target state="translated">Args::is_sorted</target>
        </trans-unit>
        <trans-unit id="18a7ac322b2479e407afbb8da7a0d6e559099523" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by</source>
          <target state="translated">Args::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d806d23a84355aca10dbfd0171313e44075d284" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by_key</source>
          <target state="translated">Args::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c6efefb9b080afb608e934c39e299c62aaaa6fc0" translate="yes" xml:space="preserve">
          <source>Args::last</source>
          <target state="translated">Args::last</target>
        </trans-unit>
        <trans-unit id="04a547ce59955db8d408e3c98a9edc55fc1c82e5" translate="yes" xml:space="preserve">
          <source>Args::le</source>
          <target state="translated">Args::le</target>
        </trans-unit>
        <trans-unit id="f88c3621988f7c3fdb34fd16f1e9ea82cfbcea71" translate="yes" xml:space="preserve">
          <source>Args::len</source>
          <target state="translated">Args::len</target>
        </trans-unit>
        <trans-unit id="01c7bcbbd63e3d113fbbd64d77442cb638b835d1" translate="yes" xml:space="preserve">
          <source>Args::lt</source>
          <target state="translated">Args::lt</target>
        </trans-unit>
        <trans-unit id="039581be23b84f6e55f8a2add1bc6bfa811639f2" translate="yes" xml:space="preserve">
          <source>Args::map</source>
          <target state="translated">Args::map</target>
        </trans-unit>
        <trans-unit id="994f671b6e95e4ae34dd6e2c082281ea8ea61313" translate="yes" xml:space="preserve">
          <source>Args::max</source>
          <target state="translated">Args::max</target>
        </trans-unit>
        <trans-unit id="74a4e2d3f00af26f6a0ad2245e073d3b5a0cd3d2" translate="yes" xml:space="preserve">
          <source>Args::max_by</source>
          <target state="translated">Args::max_by</target>
        </trans-unit>
        <trans-unit id="deb310f6f85b56ebc7fe38e266f44493563fc6cf" translate="yes" xml:space="preserve">
          <source>Args::max_by_key</source>
          <target state="translated">Args::max_by_key</target>
        </trans-unit>
        <trans-unit id="dde4047d67a5b16733c51e9703c57fbdf575a4e4" translate="yes" xml:space="preserve">
          <source>Args::min</source>
          <target state="translated">Args::min</target>
        </trans-unit>
        <trans-unit id="403ed2480b700e9a65c715919e29b948e24f4b97" translate="yes" xml:space="preserve">
          <source>Args::min_by</source>
          <target state="translated">Args::min_by</target>
        </trans-unit>
        <trans-unit id="61041884b34bb5182aa5504e5448d5bac7a830ec" translate="yes" xml:space="preserve">
          <source>Args::min_by_key</source>
          <target state="translated">Args::min_by_key</target>
        </trans-unit>
        <trans-unit id="254900be5bd6dab1a3e1e8f2d8135ce517862048" translate="yes" xml:space="preserve">
          <source>Args::ne</source>
          <target state="translated">Args::ne</target>
        </trans-unit>
        <trans-unit id="d7cb929a8cedef153a932b274a4aba45b153fd66" translate="yes" xml:space="preserve">
          <source>Args::next</source>
          <target state="translated">Args::next</target>
        </trans-unit>
        <trans-unit id="2dcb9f5424d93dea8b755e44bed8488448308f48" translate="yes" xml:space="preserve">
          <source>Args::next_back</source>
          <target state="translated">Args::next_back</target>
        </trans-unit>
        <trans-unit id="7117eeb7949ae721ac3782d5eedc483a09ccac61" translate="yes" xml:space="preserve">
          <source>Args::nth</source>
          <target state="translated">Args::nth</target>
        </trans-unit>
        <trans-unit id="920bfede689288166976e1de3db01783fca343a2" translate="yes" xml:space="preserve">
          <source>Args::nth_back</source>
          <target state="translated">Args::nth_back</target>
        </trans-unit>
        <trans-unit id="827560f3761313e8fff14e1e90ac372f2bcfaccc" translate="yes" xml:space="preserve">
          <source>Args::partial_cmp</source>
          <target state="translated">Args::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fd69506fed5f2e3f675c8f01ed77c7a8573ed9f" translate="yes" xml:space="preserve">
          <source>Args::partition</source>
          <target state="translated">Args::partition</target>
        </trans-unit>
        <trans-unit id="0f80b2cd77c5343960cc6f37513564b206a6f770" translate="yes" xml:space="preserve">
          <source>Args::peekable</source>
          <target state="translated">Args::peekable</target>
        </trans-unit>
        <trans-unit id="d35d46b1d259e3d81a7c87e03f05934ae588d4a7" translate="yes" xml:space="preserve">
          <source>Args::position</source>
          <target state="translated">Args::position</target>
        </trans-unit>
        <trans-unit id="4ed9e8e605899d2c4c96340af8f07ac7b263210f" translate="yes" xml:space="preserve">
          <source>Args::product</source>
          <target state="translated">Args::product</target>
        </trans-unit>
        <trans-unit id="eb295f32cccde70f35d8df7df01c50708f27bd93" translate="yes" xml:space="preserve">
          <source>Args::rev</source>
          <target state="translated">Args::rev</target>
        </trans-unit>
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">Argumento y elemento separador</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">Tipos de argumentos</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">Argumentos para las llamadas de función</target>
        </trans-unit>
        <trans-unit id="599f9cef30e51c86c0307365f585d93f4615d4d0" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b13e1e9de1f734ef5d809e601926031419d1d8" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">Los argumentos que se pasan a &lt;code&gt;ok_or&lt;/code&gt; se eval&amp;uacute;an con entusiasmo; si est&amp;aacute; pasando el resultado de una llamada a una funci&amp;oacute;n, se recomienda utilizar &lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt; , que se eval&amp;uacute;a de forma perezosa.</target>
        </trans-unit>
        <trans-unit id="c72e63e8acf76e2210299bb8523a4d987e02e598" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">Los argumentos se transmiten &lt;code&gt;or&lt;/code&gt; se eval&amp;uacute;an con entusiasmo; si est&amp;aacute; pasando el resultado de una llamada a una funci&amp;oacute;n, se recomienda utilizar &lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; , que se eval&amp;uacute;a de forma perezosa.</target>
        </trans-unit>
        <trans-unit id="e8e3ad3f9d440f41a4bced3ec981aa2d05bd534c" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb2e5d47e33897712d4dff15280a3a0c997b492" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">Los argumentos que se pasan a &lt;code&gt;unwrap_or&lt;/code&gt; se eval&amp;uacute;an con entusiasmo; si est&amp;aacute; pasando el resultado de una llamada a una funci&amp;oacute;n, se recomienda utilizar &lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; , que se eval&amp;uacute;a de forma perezosa.</target>
        </trans-unit>
        <trans-unit id="15ac6e3ce55f8f212059dc3a36cc981d9be8aca1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935c37b281819663d093edd0e6a0df21fc148074" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">Adición aritmética</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">Suma y asignación de aritmética</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">Operadores binarios aritméticos y lógicos</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">Operadores aritméticos y de comparación sobre números enteros</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">División aritmética</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">División y asignación de aritmética</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">Multiplicación aritmética</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">Multiplicación y asignación aritmética</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">Negación aritmética</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">Restos aritméticos</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">Resto de aritmética y asignación</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">Sustracción aritmética</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">Sustracción y asignación aritmética</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">Arity se refiere al n&amp;uacute;mero de argumentos que toma una funci&amp;oacute;n u operador. Para algunos ejemplos, &lt;code&gt;f(2, 3)&lt;/code&gt; y &lt;code&gt;g(4, 6)&lt;/code&gt; tienen aridad 2, mientras que &lt;code&gt;h(8, 2, 6)&lt;/code&gt; tiene aridad 3. El &lt;code&gt;!&lt;/code&gt; El operador tiene aridad 1.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">Disposición de la matriz</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">Expresiones de índices de matrices y matrices</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">Expresiones de indexación de arreglos y cortes</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">Atributos de la expresión de los arreglos</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">Expresiones de la matriz</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">Array literal</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">Array literal que contiene copias &lt;code&gt;len&lt;/code&gt; de &lt;code&gt;expr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Array literales con sintaxis repetida, donde el arreglo tiene tipo &lt;code&gt;[U; n]&lt;/code&gt; . El sub-expresi&amp;oacute;n repetida es un sitio de coacci&amp;oacute;n para la coacci&amp;oacute;n para escribir &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Literales de matriz, donde la matriz tiene el tipo &lt;code&gt;[U; n]&lt;/code&gt; . Cada sub-expresi&amp;oacute;n en el literal de matriz es un sitio de coacci&amp;oacute;n para la coacci&amp;oacute;n para escribir &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5de52c0cb2ce4e0eb71f0c098408cbd13a499a61" translate="yes" xml:space="preserve">
          <source>Array repeat length expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">Matriz a molde de puntero</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">Tipo de matriz que contiene instancias de &lt;code&gt;type&lt;/code&gt; &lt;code&gt;len&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">Expresiones de longitudes de tipos de matrices</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">Tipos de matrices</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">Tipos de matriz, para todos los tama&amp;ntilde;os, si el tipo de elemento tambi&amp;eacute;n implementa &lt;code&gt;Clone&lt;/code&gt; (p. Ej., &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">Tipos de matriz, para todos los tama&amp;ntilde;os, si el tipo de elemento tambi&amp;eacute;n implementa &lt;code&gt;Copy&lt;/code&gt; (p. Ej., &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95c5c33f29f0547a430b0665b6ac583648900bd6" translate="yes" xml:space="preserve">
          <source>ArrayChunks</source>
          <target state="translated">ArrayChunks</target>
        </trans-unit>
        <trans-unit id="5d42cc662a1c24ca3713c4fbd65f30d1d4685e7c" translate="yes" xml:space="preserve">
          <source>ArrayChunksMut</source>
          <target state="translated">ArrayChunksMut</target>
        </trans-unit>
        <trans-unit id="f83b691df0418afaddc970026f4eccfa1541c51f" translate="yes" xml:space="preserve">
          <source>ArrayWindows</source>
          <target state="translated">ArrayWindows</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Las matrices se distribuyen de modo que el &lt;code&gt;nth&lt;/code&gt; elemento de la matriz est&amp;eacute; desplazado desde el inicio de la matriz &lt;code&gt;n * the size of the type&lt;/code&gt; bytes de tipo . Una matriz de &lt;code&gt;[T; n]&lt;/code&gt; tiene un tama&amp;ntilde;o de &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; y la misma alineaci&amp;oacute;n de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">Las matrices son &amp;uacute;tiles cuando desea que sus datos se asignen en la pila en lugar de en el mont&amp;oacute;n (discutiremos la pila y el mont&amp;oacute;n m&amp;aacute;s en el Cap&amp;iacute;tulo 4) o cuando quiere asegurarse de tener siempre un n&amp;uacute;mero fijo de elementos. Sin embargo, una matriz no es tan flexible como el tipo de vector. Un vector es un tipo de colecci&amp;oacute;n similar proporcionada por la biblioteca est&amp;aacute;ndar que &lt;em&gt;se&lt;/em&gt; deja crecer o reducirse de tama&amp;ntilde;o. Si no est&amp;aacute; seguro de si usar una matriz o un vector, probablemente deber&amp;iacute;a usar un vector. El cap&amp;iacute;tulo 8 analiza los vectores con m&amp;aacute;s detalle.</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">Las matrices se convierten en &lt;a href=&quot;primitive.slice&quot;&gt;cortes ( &lt;code&gt;[T]&lt;/code&gt; )&lt;/a&gt; , por lo que se puede llamar a un m&amp;eacute;todo de corte en una matriz. De hecho, esto proporciona la mayor parte de la API para trabajar con matrices. Los cortes tienen un tama&amp;ntilde;o din&amp;aacute;mico y no se adaptan a las matrices.</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">Las matrices de &lt;em&gt;cualquier&lt;/em&gt; tama&amp;ntilde;o son &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; si el tipo de elemento es &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; si el tipo de elemento es &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; . Esto funciona porque los rasgos &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; son especialmente conocidos por el compilador.</target>
        </trans-unit>
        <trans-unit id="44fcd591dcf7f314f13f655158af04cf8a3c0c81" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size implement the following traits if the element type allows it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6563ac44bbb67213c7a3f6f4eeedf9dc732e3220" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9eb669ece946f30cfd95add30aac8bad032e42" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">Las matrices de tamaños de 0 a 32 (inclusive)implementan los siguientes rasgos si el tipo de elemento lo permite:</target>
        </trans-unit>
        <trans-unit id="3520f70ba3a61ccc1286dbddd33fb0815248aa0b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;if&lt;/code&gt; expressions have their pattern matching variant in &lt;code&gt;if let&lt;/code&gt;, so too do &lt;code&gt;while&lt;/code&gt; expressions with &lt;code&gt;while let&lt;/code&gt;. The &lt;code&gt;while let&lt;/code&gt; expression matches the pattern against the expression, then runs the loop body if pattern matching succeeds, or exits the loop otherwise. We can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; expressions just like in &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">A medida que la IANA asigne nuevas direcciones,este método será actualizado.Esto puede dar lugar a que las direcciones no reservadas sean tratadas como reservadas en un código que se basa en una versión anticuada de este método.</target>
        </trans-unit>
        <trans-unit id="204e461bb880d4d3e097aeac5f123e90d90ae7f0" translate="yes" xml:space="preserve">
          <source>As Rust automatically calls the destructors of all contained fields, you don't have to implement &lt;code&gt;Drop&lt;/code&gt; in most cases. But there are some cases where it is useful, for example for types which directly manage a resource. That resource may be memory, it may be a file descriptor, it may be a network socket. Once a value of that type is no longer going to be used, it should &quot;clean up&quot; its resource by freeing the memory or closing the file or socket. This is the job of a destructor, and therefore the job of &lt;code&gt;Drop::drop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">Como complemento de &lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; este rasgo permite que un tipo tome prestado como tipo subyacente al proporcionar una referencia mutable. Consulte &lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo pedir prestado como otro tipo.</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">Como consecuencia, la correlaci&amp;oacute;n hash rompe si es un &lt;code&gt;K&lt;/code&gt; de envolver un &lt;code&gt;Q&lt;/code&gt; valor produce un hash de diferente que &lt;code&gt;Q&lt;/code&gt; . Por ejemplo, imagina que tienes un tipo que envuelve una cadena pero compara letras ASCII ignorando su caso:</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">Como recopilaci&amp;oacute;n de datos, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt; posee tanto claves como valores. Si los datos reales de la clave est&amp;aacute;n envueltos en un tipo de gesti&amp;oacute;n de alg&amp;uacute;n tipo, a&amp;uacute;n deber&amp;iacute;a ser posible buscar un valor utilizando una referencia a los datos de la clave. Por ejemplo, si la clave es una cadena, es probable que se almacene con el mapa hash como una &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , mientras que deber&amp;iacute;a ser posible buscar usando un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; . Por lo tanto, &lt;code&gt;insert&lt;/code&gt; necesita operar en una &lt;code&gt;String&lt;/code&gt; mientras que &lt;code&gt;get&lt;/code&gt; necesita poder usar a &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">Como primer ejemplo de propiedad, veremos el &lt;em&gt;alcance&lt;/em&gt; de algunas variables. Un alcance es el rango dentro de un programa para el que un elemento es v&amp;aacute;lido. Digamos que tenemos una variable que se parece a esto:</target>
        </trans-unit>
        <trans-unit id="ec757385247cd107e43eba2a3f4a658f211a87a6" translate="yes" xml:space="preserve">
          <source>As a hack to work around this, we use two separate traits injected by each of the two derives (&lt;code&gt;#[derive(PartialEq)]&lt;/code&gt; and &lt;code&gt;#[derive(Eq)]&lt;/code&gt;) and check that both of them are present as part of structural-match checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">Como lenguaje, Rust se preocupa &lt;em&gt;mucho&lt;/em&gt; por la estabilidad de su c&amp;oacute;digo. Queremos que Rust sea una base s&amp;oacute;lida como una roca sobre la que pueda construir, y si las cosas cambiaran constantemente, eso ser&amp;iacute;a imposible. Al mismo tiempo, si no podemos experimentar con nuevas funciones, es posible que no descubramos fallas importantes hasta despu&amp;eacute;s de su lanzamiento, cuando ya no podamos cambiar las cosas.</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">Como autor de una biblioteca, siempre deber&amp;iacute;a preferir implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; lugar de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; , ya que &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; proporcionan una mayor flexibilidad y ofrecen equivalentes a &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;implementaciones TryInto de forma gratuita, gracias a una implementaci&amp;oacute;n general en la biblioteca est&amp;aacute;ndar. Solo implemente&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; cuando se requiera una conversi&amp;oacute;n a un tipo fuera de la caja actual.</target>
        </trans-unit>
        <trans-unit id="c688289e645266d022bd25b11abee98bf47d494f" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. When targeting a version prior to Rust 1.41, it may be necessary to implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; directly when converting to a type outside the current crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">Como alternativa m&amp;aacute;s concisa, puede utilizar un bucle &lt;code&gt;for&lt;/code&gt; y ejecutar c&amp;oacute;digo para cada elemento de una colecci&amp;oacute;n. Un bucle &lt;code&gt;for&lt;/code&gt; se parece al c&amp;oacute;digo del Listado 3-5.</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">Como resultado de este c&amp;oacute;digo, &lt;code&gt;s&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;lol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b710b8f0107d2ffba9437950b5808cd39ab806b4" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Como resultado, este m&amp;eacute;todo considera direcciones como &lt;code&gt;fe80:0:0:1::&lt;/code&gt; o &lt;code&gt;fe81::&lt;/code&gt; direcciones locales de enlace de unidifusi&amp;oacute;n, mientras que &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; no lo hace. Si necesita una validaci&amp;oacute;n estricta totalmente compatible con el RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">Como una rebanada de cuerda consiste en una secuencia de bytes,podemos iterar a través de una rebanada de cuerda por byte.Este método devuelve tal iterador.</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">Como un segmento de cadena consta de UTF-8 v&amp;aacute;lido, podemos iterar a trav&amp;eacute;s de un segmento de cadena por &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo devuelve un iterador de ambos estos&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s, as&amp;iacute; como sus posiciones de bytes.</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">Como un segmento de cadena consta de UTF-8 v&amp;aacute;lido, podemos iterar a trav&amp;eacute;s de un segmento de cadena por &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo devuelve tal iterador.</target>
        </trans-unit>
        <trans-unit id="5e4e8ad23ff47badf3452433750942f67bdc2881" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b276d81f1ebeb72ef92a468ba3b31b82b8dbf57a" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">Como un segmento de cadena consta de UTF-8 v&amp;aacute;lido, podemos iterar a trav&amp;eacute;s de un segmento de cadena por &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo devuelve un iterador de ambos estos&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s, as&amp;iacute; como sus posiciones de bytes.</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">Como un segmento de cadena consta de UTF-8 v&amp;aacute;lido, podemos iterar a trav&amp;eacute;s de un segmento de cadena por &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo devuelve tal iterador.</target>
        </trans-unit>
        <trans-unit id="047a0a2f69f724c14716efaa0063a5ea83e459c4" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d408364fefca0ab968a9b16914cf4b387f8e95e" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">Como siempre, recuerde que una intuici&amp;oacute;n humana para 'car&amp;aacute;cter' puede no corresponder con las definiciones de Unicode. Por ejemplo, a pesar de parecer similar, el car&amp;aacute;cter '&amp;eacute;' es un punto de c&amp;oacute;digo Unicode mientras que '&amp;eacute;' son dos puntos de c&amp;oacute;digo Unicode:</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">Como siempre, podemos usar llaves para crear un nuevo alcance, permitiendo m&amp;uacute;ltiples referencias mutables, pero no &lt;em&gt; simult&amp;aacute;neas&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">Como ejemplo de c&amp;oacute;mo usar un mutex, comencemos usando un mutex en un contexto de un solo hilo, como se muestra en el Listado 16-12:</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">Como ejemplo de métodos sobre un rasgo,considere lo siguiente:</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">Como ejemplo de d&amp;oacute;nde podr&amp;iacute;a usar un cierre definido en l&amp;iacute;nea o una funci&amp;oacute;n con nombre, veamos un uso de &lt;code&gt;map&lt;/code&gt; . Para usar el &lt;code&gt;map&lt;/code&gt; a funci&amp;oacute;n de para convertir un vector de n&amp;uacute;meros en un vector de cadenas, podr&amp;iacute;amos usar un cierre, como este:</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">Como ejemplo,la lista 11-10 tiene una función tonta que imprime el valor de su parámetro y devuelve 10,así como una prueba que pasa y otra que falla.</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">Como ejemplo, un comparador de macros como &lt;code&gt;$i:expr [ , ]&lt;/code&gt; podr&amp;iacute;a ser aceptado en teor&amp;iacute;a en Rust hoy, ya que &lt;code&gt;[,]&lt;/code&gt; no puede ser parte de una expresi&amp;oacute;n legal y por lo tanto el an&amp;aacute;lisis siempre ser&amp;iacute;a inequ&amp;iacute;voco. Sin embargo, debido a que &lt;code&gt;[&lt;/code&gt; puede comenzar a arrastrar expresiones, &lt;code&gt;[&lt;/code&gt; no es un car&amp;aacute;cter que pueda descartarse con seguridad como posterior a una expresi&amp;oacute;n. Si se aceptara &lt;code&gt;[,]&lt;/code&gt; en una versi&amp;oacute;n posterior de Rust, este comparador se volver&amp;iacute;a ambiguo o se confundir&amp;iacute;a, rompiendo el c&amp;oacute;digo de trabajo. Coincidencias como &lt;code&gt;$i:expr,&lt;/code&gt; o &lt;code&gt;$i:expr;&lt;/code&gt; ser&amp;iacute;a legal, sin embargo, porque &lt;code&gt;,&lt;/code&gt; y &lt;code&gt;;&lt;/code&gt; son separadores de expresiones legales. Las reglas espec&amp;iacute;ficas son:</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">Como ejemplo, cambie el archivo &lt;em&gt;src / main.rs&lt;/em&gt; en sus &lt;em&gt;bucles&lt;/em&gt; directorio de para que se vea as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">Como ejemplo, cambiemos una de nuestras variantes de enumeraci&amp;oacute;n para contener datos dentro de ella. Desde 1999 hasta 2008, Estados Unidos acu&amp;ntilde;&amp;oacute; monedas de veinticinco centavos con diferentes dise&amp;ntilde;os para cada uno de los 50 estados de un lado. Ninguna otra moneda tiene dise&amp;ntilde;os estatales, por lo que solo las monedas de veinticinco centavos tienen este valor adicional. Podemos agregar esta informaci&amp;oacute;n a nuestra &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n cambiando la variante &lt;code&gt;Quarter&lt;/code&gt; para incluir un valor &lt;code&gt;UsState&lt;/code&gt; almacenado en su interior, lo que hemos hecho aqu&amp;iacute; en el Listado 6-4.</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">Como ejemplo, digamos que queremos implementar &lt;code&gt;Display&lt;/code&gt; en &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , lo que la regla hu&amp;eacute;rfana nos impide hacer directamente porque el rasgo &lt;code&gt;Display&lt;/code&gt; y el tipo &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute;n definidos fuera de nuestra caja. Podemos hacer una estructura &lt;code&gt;Wrapper&lt;/code&gt; que contenga una instancia de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ; luego podemos implementar &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; y usar &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , como se muestra en el Listado 19-23.</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">Como ejemplo, escribamos una caja de biblioteca que proporcione la funcionalidad de un restaurante. Definiremos las firmas de las funciones, pero dejaremos sus cuerpos vac&amp;iacute;os para concentrarse en la organizaci&amp;oacute;n del c&amp;oacute;digo, en lugar de implementar un restaurante en el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">Como ejemplo, en lugar de utilizar una lista cuyos elementos solo conocen el siguiente elemento, crearemos un &amp;aacute;rbol cuyos elementos conocen sus elementos secundarios &lt;em&gt;y&lt;/em&gt; sus elementos principales.</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">Como ejemplo, recuerde los rasgos de marcador de &lt;code&gt;Sync&lt;/code&gt; y &lt;code&gt;Send&lt;/code&gt; que discutimos en la secci&amp;oacute;n &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&quot;Concurrencia extensible con los rasgos de &lt;code&gt;Sync&lt;/code&gt; y &lt;code&gt;Send&lt;/code&gt; &quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 16: el compilador implementa estos rasgos autom&amp;aacute;ticamente si nuestros tipos est&amp;aacute;n compuestos completamente de tipos de &lt;code&gt;Send&lt;/code&gt; y &lt;code&gt;Sync&lt;/code&gt; . Si implementamos un tipo que contiene un tipo que no es &lt;code&gt;Send&lt;/code&gt; o &lt;code&gt;Sync&lt;/code&gt; , como punteros sin formato, y queremos marcar ese tipo como &lt;code&gt;Send&lt;/code&gt; o &lt;code&gt;Sync&lt;/code&gt; , debemos usar &lt;code&gt;unsafe&lt;/code&gt; . Rust no puede verificar que nuestro tipo mantenga las garant&amp;iacute;as de que se puede enviar de forma segura a trav&amp;eacute;s de subprocesos o acceder desde varios subprocesos; por lo tanto, debemos hacer esas comprobaciones manualmente e indicarlas como &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">Como ejemplo, digamos que escribimos una funci&amp;oacute;n llamada &lt;code&gt;add_two&lt;/code&gt; que suma 2 a cualquier n&amp;uacute;mero que se le pase. La firma de esta funci&amp;oacute;n acepta un n&amp;uacute;mero entero como par&amp;aacute;metro y devuelve un n&amp;uacute;mero entero como resultado. Cuando implementamos y compilamos esa funci&amp;oacute;n, Rust realiza todas las comprobaciones de tipos y las comprobaciones prestadas que ha aprendido hasta ahora para asegurarse de que, por ejemplo, no estamos pasando un valor de &lt;code&gt;String&lt;/code&gt; o una referencia no v&amp;aacute;lida a esta funci&amp;oacute;n. Pero Rust &lt;em&gt;no puede&lt;/em&gt; comprobar que esta funci&amp;oacute;n har&amp;aacute; precisamente lo que pretendemos, que es devolver el par&amp;aacute;metro m&amp;aacute;s 2 en lugar de, digamos, el par&amp;aacute;metro m&amp;aacute;s 10 o el par&amp;aacute;metro menos 50. Ah&amp;iacute; es donde entran las pruebas.</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">Por ejemplo, el patr&amp;oacute;n &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; y el pajar &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; pueden producir la secuencia &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">Por ejemplo, el patr&amp;oacute;n &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; y el pajar &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; pueden producir la secuencia &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd3fe41e9f9da754b12e58c1b62e309d7fedd0" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">Como un iterador:</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">Como otro ejemplo, supongamos que tenemos un rasgo &lt;code&gt;Maker&lt;/code&gt; y queremos establecer un tipo &lt;code&gt;FooMaker&lt;/code&gt; que haga &lt;code&gt;Foo&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">Como otro ejemplo, el siguiente c&amp;oacute;digo se toma de un decodificador de audio. El algoritmo de decodificaci&amp;oacute;n utiliza la operaci&amp;oacute;n matem&amp;aacute;tica de predicci&amp;oacute;n lineal para estimar valores futuros bas&amp;aacute;ndose en una funci&amp;oacute;n lineal de las muestras anteriores. Este c&amp;oacute;digo usa una cadena de iteradores para hacer algunos c&amp;aacute;lculos matem&amp;aacute;ticos en tres variables en el alcance: un segmento de datos del &lt;code&gt;buffer&lt;/code&gt; , una matriz de 12 &lt;code&gt;coefficients&lt;/code&gt; y una cantidad por la cual cambiar los datos en &lt;code&gt;qlp_shift&lt;/code&gt; . Hemos declarado las variables en este ejemplo, pero no les hemos dado ning&amp;uacute;n valor; aunque este c&amp;oacute;digo no tiene mucho significado fuera de su contexto, sigue siendo un ejemplo conciso del mundo real de c&amp;oacute;mo Rust traduce ideas de alto nivel en c&amp;oacute;digo de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="50430e10a27b5bcf53132a5539fdc175dfb8f896" translate="yes" xml:space="preserve">
          <source>As can be seen below, &lt;code&gt;else&lt;/code&gt; must be followed by either: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;if let&lt;/code&gt;, or a block &lt;code&gt;{}&lt;/code&gt; and it will return the value of that expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Como se describe, &lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; implementos &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7af5c30f33f1fda6dc417defcc8e46844e2584e3" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">Como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 10, para implementar un rasgo, necesitamos proporcionar implementaciones para los m&amp;eacute;todos requeridos del rasgo. El &lt;code&gt;Deref&lt;/code&gt; rasgo, proporcionado por la biblioteca est&amp;aacute;ndar, nos exige poner en pr&amp;aacute;ctica un m&amp;eacute;todo llamado &lt;code&gt;deref&lt;/code&gt; que toma prestado &lt;code&gt;self&lt;/code&gt; y devuelve una referencia a los datos internos. El Listado 15-10 contiene una implementaci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; para agregar a la definici&amp;oacute;n de &lt;code&gt;MyBox&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">Como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 17, el m&amp;eacute;todo &lt;code&gt;take&lt;/code&gt; en &lt;code&gt;Option&lt;/code&gt; elimina la variante &lt;code&gt;Some&lt;/code&gt; y deja &lt;code&gt;None&lt;/code&gt; en su lugar. Estamos usando &lt;code&gt;if let&lt;/code&gt; para desestructurar &lt;code&gt;Some&lt;/code&gt; y obtener el hilo; luego llamamos a &lt;code&gt;join&lt;/code&gt; en el hilo. Si el hilo de un trabajador ya es &lt;code&gt;None&lt;/code&gt; , sabemos que ese trabajador ya ha limpiado su hilo, por lo que no sucede nada en ese caso.</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">Como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 6, usamos patrones en los brazos de las expresiones de &lt;code&gt;match&lt;/code&gt; . Formalmente, las expresiones de &lt;code&gt;match&lt;/code&gt; se definen como la &lt;code&gt;match&lt;/code&gt; palabras clave , un valor con el que hacer coincidir y uno o m&amp;aacute;s brazos de coincidencia que constan de un patr&amp;oacute;n y una expresi&amp;oacute;n para ejecutar si el valor coincide con el patr&amp;oacute;n de ese brazo, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">En cuanto a lo que ocurre entre bastidores,cuando se activan las optimizaciones,el código máquina final generado puede parecer muy diferente del código:</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">Como funciones,deben devolver sintaxis,pánico o bucles sin fin.La sintaxis devuelta reemplaza o añade la sintaxis dependiendo del tipo de macro de procedimiento.El pánico es atrapado por el compilador y se convierte en un error del compilador.Los bucles interminables no son capturados por el compilador que lo cuelga.</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">Como humanos, podemos mirar este c&amp;oacute;digo y ver que &lt;code&gt;string1&lt;/code&gt; es m&amp;aacute;s largo que &lt;code&gt;string2&lt;/code&gt; y, por &lt;code&gt;result&lt;/code&gt; tanto, el resultado contendr&amp;aacute; una referencia a &lt;code&gt;string1&lt;/code&gt; . Debido a que &lt;code&gt;string1&lt;/code&gt; a&amp;uacute;n no ha salido del alcance, una referencia a &lt;code&gt;string1&lt;/code&gt; seguir&amp;aacute; siendo v&amp;aacute;lida para &lt;code&gt;println!&lt;/code&gt; declaraci&amp;oacute;n. Sin embargo, el compilador no puede ver que la referencia sea v&amp;aacute;lida en este caso. Le hemos dicho a Rust que la vida &amp;uacute;til de la referencia devuelta por la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; es la misma que la vida &amp;uacute;til m&amp;aacute;s peque&amp;ntilde;a de las referencias pasadas. Por lo tanto, el verificador de pr&amp;eacute;stamos no permite que el c&amp;oacute;digo del Listado 10-24 posiblemente tenga una referencia no v&amp;aacute;lida. .</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">Como en la mayor&amp;iacute;a de los otros lenguajes de programaci&amp;oacute;n, un tipo booleano en Rust tiene dos valores posibles: &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; . Los booleanos tienen un tama&amp;ntilde;o de un byte. El tipo booleano en Rust se especifica mediante &lt;code&gt;bool&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="45c7aa166fa09685143658300364b92158ea06fe" translate="yes" xml:space="preserve">
          <source>As is the case in &lt;a href=&quot;if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt; expressions&lt;/a&gt;, the scrutinee cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118d39ec67253c2f49ef6f0a1ef21526ef7b61b3" translate="yes" xml:space="preserve">
          <source>As it turns out, though, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">Mientras la l&amp;oacute;gica de la l&amp;iacute;nea de comandos de an&amp;aacute;lisis es peque&amp;ntilde;a, puede permanecer en &lt;em&gt;main.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">Como se mencion&amp;oacute; al comienzo del cap&amp;iacute;tulo, las pruebas son una disciplina compleja y diferentes personas usan terminolog&amp;iacute;a y organizaci&amp;oacute;n diferentes. La comunidad de Rust piensa en las pruebas en t&amp;eacute;rminos de dos categor&amp;iacute;as principales: &lt;em&gt;pruebas unitarias&lt;/em&gt; y &lt;em&gt;pruebas de integraci&amp;oacute;n&lt;/em&gt; . Las pruebas unitarias son peque&amp;ntilde;as y m&amp;aacute;s enfocadas, prueban un m&amp;oacute;dulo aislado a la vez y pueden probar interfaces privadas. Las pruebas de integraci&amp;oacute;n son completamente externas a su biblioteca y usan su c&amp;oacute;digo de la misma manera que lo har&amp;iacute;a cualquier otro c&amp;oacute;digo externo, usando solo la interfaz p&amp;uacute;blica y potencialmente ejercitando m&amp;uacute;ltiples m&amp;oacute;dulos por prueba.</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">Como se mencionó antes,los objetos de rasgo contienen punteros a las tablas de métodos.Así que,si tenemos:</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, &lt;code&gt;read_line&lt;/code&gt; pone lo que el usuario escribe en la cadena que le estamos pasando, pero tambi&amp;eacute;n devuelve un valor, en este caso, un &lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; . Rust tiene varios tipos denominados &lt;code&gt;Result&lt;/code&gt; en su biblioteca est&amp;aacute;ndar: un &lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; gen&amp;eacute;rico y versiones espec&amp;iacute;ficas para subm&amp;oacute;dulos, como &lt;code&gt;io::Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">Como se mencionó anteriormente,debido a que muy poco de la forma en que Rust maneja la concurrencia es parte del lenguaje,muchas soluciones de concurrencia se implementan como cajas.Éstas evolucionan más rápidamente que la biblioteca estándar,así que asegúrese de buscar en línea las cajas actuales,de última generación,para usarlas en situaciones de múltiples hilos.</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">Como se mencion&amp;oacute; en el Cap&amp;iacute;tulo 2, las variables predeterminadas son inmutables. Este es uno de los muchos empujones que Rust le da para escribir su c&amp;oacute;digo de una manera que aproveche la seguridad y la simultaneidad que ofrece Rust. Sin embargo, todav&amp;iacute;a tiene la opci&amp;oacute;n de hacer que sus variables sean mutables. Exploremos c&amp;oacute;mo y por qu&amp;eacute; Rust lo alienta a favorecer la inmutabilidad y por qu&amp;eacute; a veces es posible que desee optar por no participar.</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">Como se menciona en la documentaci&amp;oacute;n del m&amp;oacute;dulo, los hilos generalmente se hacen para comunicarse usando &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt; , as&amp;iacute; es como se ve generalmente.</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">Como las convenciones de llamada no oxidada no apoyan la anulación,la anulación más allá del final de una función externa causará que el proceso aborte.En la LLVM,esto se implementa ejecutando una instrucción ilegal.</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">Como se se&amp;ntilde;al&amp;oacute; anteriormente, las coacciones significan que la mayor&amp;iacute;a del c&amp;oacute;digo no tiene que preocuparse por esta distinci&amp;oacute;n. Sin embargo, puede notar la diferencia al usar &lt;strong&gt;transmutar&lt;/strong&gt; para convertir un elemento fn en un puntero fn.</target>
        </trans-unit>
        <trans-unit id="a5cb1839eab079676f60d9f52ac6387e18acb792" translate="yes" xml:space="preserve">
          <source>As noted in the documentation for the type itself, it is essentially an opaque ID, but is guaranteed to be unique for each thread. The returned value is entirely opaque -- only equality testing is stable. Note that it is not guaranteed which values new threads will return, and this may change across Rust versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7018b1edbbce45316477bb25e1ffd907f9a0adb" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; for their container to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">Como era de esperar, los tipos primitivos como &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; son todos &lt;code&gt;Sync&lt;/code&gt; , y tambi&amp;eacute;n lo son los tipos de agregados simples que los contienen, como tuplas, estructuras y enumeraciones. M&amp;aacute;s ejemplos de tipos de &lt;code&gt;Sync&lt;/code&gt; b&amp;aacute;sicos incluyen tipos &quot;inmutables&quot; como &lt;code&gt;&amp;amp;T&lt;/code&gt; , y aquellos con mutabilidad heredada simple, como &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y la mayor&amp;iacute;a de los otros tipos de colecci&amp;oacute;n. (Los par&amp;aacute;metros gen&amp;eacute;ricos deben estar &lt;code&gt;Sync&lt;/code&gt; para que su contenedor est&amp;eacute; &lt;code&gt;Sync&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">Seg&amp;uacute;n &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt; , todo el &lt;code&gt;FEC0::/10&lt;/code&gt; est&amp;aacute; obsoleto. El nuevo software no debe admitir direcciones locales del sitio.</target>
        </trans-unit>
        <trans-unit id="a8a04accdf6a8ca9fa81bf61cc029868f206046f" translate="yes" xml:space="preserve">
          <source>As said above, the &lt;code&gt;derive&lt;/code&gt; attribute is only allowed on structs, unions or enums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">Como se muestra en el ejemplo anterior, los bucles &lt;code&gt;for&lt;/code&gt; (junto con todos los dem&amp;aacute;s bucles) se pueden etiquetar, utilizando una sintaxis similar a la de las vidas (solo visualmente similar, completamente distinto en la pr&amp;aacute;ctica). Dar la misma etiqueta para &lt;code&gt;break&lt;/code&gt; rompe el bucle etiquetado, que es &amp;uacute;til para los bucles internos. Definitivamente no es un goto.</target>
        </trans-unit>
        <trans-unit id="ea3901788f56444df8cfba46d8496b7c3ef215ae" translate="yes" xml:space="preserve">
          <source>As slices store the length of the sequence they refer to, they have twice the size of pointers to &lt;a href=&quot;marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; types. Also see the reference on &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">Como se indica en la especificaci&amp;oacute;n del Protocolo de datagramas de usuario en &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt; , UDP es un protocolo desordenado y poco confiable; consulte &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; para conocer las primitivas de TCP.</target>
        </trans-unit>
        <trans-unit id="5379cc453111a9586b0e6132f3432e2017bb8946" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">Como los segmentos de cadena son segmentos de bytes, el puntero sin &lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; apunta a u8 . Este puntero apuntar&amp;aacute; al primer byte del segmento de cadena.</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">Como tal, la familia &lt;code&gt;from_utf8&lt;/code&gt; de funciones y m&amp;eacute;todos para &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; sy &lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; s hace uso de este error, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">Como autor de una estructura de datos,usted puede decidir para cada campo si la fijación &quot;se propaga&quot; a este campo o no.La fijación que se propaga también se llama &quot;estructural&quot;,porque sigue la estructura del tipo.En las siguientes subsecciones,describimos las consideraciones que hay que hacer para cualquier elección.</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">Como indica el mensaje de error, solo &lt;code&gt;u8&lt;/code&gt; se puede convertir en &lt;code&gt;char&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">A medida que se usa el endianness nativo de la plataforma de destino, es probable que el c&amp;oacute;digo port&amp;aacute;til desee usar &lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt; , seg&amp;uacute;n corresponda.</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">A medida que se usa el endianness nativo de la plataforma de destino, el c&amp;oacute;digo port&amp;aacute;til debe usar &lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; &lt;/a&gt; , seg&amp;uacute;n corresponda, en su lugar.</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">Como este es el &amp;uacute;nico m&amp;eacute;todo para este rasgo, los documentos de &lt;a href=&quot;trait.extend&quot;&gt;nivel de rasgo&lt;/a&gt; contienen m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="3b3bf99d81b548977e24e38bef4df0cf86423b5b" translate="yes" xml:space="preserve">
          <source>As this is the only required method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">Como de costumbre,esta salida nos dice exactamente lo que ha salido mal.</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">Como hicimos con las estructuras, podemos definir enumeraciones para contener tipos de datos gen&amp;eacute;ricos en sus variantes. Echemos otro vistazo a la enumeraci&amp;oacute;n &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; que proporciona la biblioteca est&amp;aacute;ndar, que usamos en el Cap&amp;iacute;tulo 6:</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">Como vimos cuando imprimimos el vector, el nombre del programa toma el primer valor en el vector en &lt;code&gt;args[0]&lt;/code&gt; , entonces comenzamos en el &amp;iacute;ndice &lt;code&gt;1&lt;/code&gt; . El primer argumento que toma &lt;code&gt;minigrep&lt;/code&gt; es la cadena que estamos buscando, as&amp;iacute; que colocamos una referencia al primer argumento en la &lt;code&gt;query&lt;/code&gt; variables . El segundo argumento ser&amp;aacute; el nombre del archivo, por lo que ponemos una referencia al segundo argumento en la variable &lt;code&gt;filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de sobrecargar al operador unario &lt;code&gt;*&lt;/code&gt; ,&lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; y&lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n se utilizan en la&lt;a href=&quot;expressions/method-call-expr&quot;&gt; resoluci&amp;oacute;n de m&amp;eacute;todos&lt;/a&gt; y&lt;a href=&quot;type-coercions#coercion-types&quot;&gt; las coerciones deref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">Al igual que con &lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt; , esto no es seguro porque no puede verificar la validez del puntero devuelto, ni puede garantizar que el tiempo de vida &lt;code&gt;'a&lt;/code&gt; devuelta es de hecho una vida v&amp;aacute;lido de los datos contenidos.</target>
        </trans-unit>
        <trans-unit id="700b249dcaa7ad65d8fbe7b2f99bd14fed03c63b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b569f01826b7a489e1b0df46d3df2feea0987b31" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a160954fc2e5db9027a60b41aea2242946a496" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the values really are in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">Al igual que con las &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;importaciones de subrayado&lt;/a&gt; , las macros pueden emitir con seguridad la misma constante sin nombre en el mismo &amp;aacute;mbito m&amp;aacute;s de una vez. Por ejemplo, lo siguiente no deber&amp;iacute;a producir un error:</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">Al igual que con los enlaces &lt;code&gt;let&lt;/code&gt; , los argumentos de la funci&amp;oacute;n son &lt;a href=&quot;../patterns&quot;&gt;patrones&lt;/a&gt; irrefutables , por lo que cualquier patr&amp;oacute;n que sea v&amp;aacute;lido en un enlace let tambi&amp;eacute;n es v&amp;aacute;lido como argumento:</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">Al igual que con &lt;code&gt;split()&lt;/code&gt; , si el primer o &amp;uacute;ltimo elemento coincide, un segmento vac&amp;iacute;o ser&amp;aacute; el primer (o &amp;uacute;ltimo) elemento devuelto por el iterador.</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">Como con cualquier variable, si queremos poder cambiar su valor, necesitamos hacerla mutable usando la palabra clave &lt;code&gt;mut&lt;/code&gt; , como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 3. Los n&amp;uacute;meros que colocamos dentro son todos de tipo &lt;code&gt;i32&lt;/code&gt; , y Rust lo infiere de la datos, por lo que no necesitamos la anotaci&amp;oacute;n &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">Como con muchos tipos, creamos un &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; usando la funci&amp;oacute;n asociada &lt;code&gt;new&lt;/code&gt; . Para acceder a los datos dentro del mutex, usamos el m&amp;eacute;todo de &lt;code&gt;lock&lt;/code&gt; para adquirir el bloqueo. Esta llamada bloquear&amp;aacute; el hilo actual para que no pueda hacer ning&amp;uacute;n trabajo hasta que sea nuestro turno de bloquearlo.</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">Al igual que con las variables regulares, especificamos la mutabilidad usando la palabra clave &lt;code&gt;mut&lt;/code&gt; . Cualquier c&amp;oacute;digo que lea o escriba desde &lt;code&gt;COUNTER&lt;/code&gt; debe estar dentro de un bloque &lt;code&gt;unsafe&lt;/code&gt; . Este c&amp;oacute;digo compila e imprime &lt;code&gt;COUNTER: 3&lt;/code&gt; como era de esperar porque es de un solo hilo. Tener m&amp;uacute;ltiples subprocesos que accedan a &lt;code&gt;COUNTER&lt;/code&gt; probablemente resulte en carreras de datos.</target>
        </trans-unit>
        <trans-unit id="d8272d2e249bc06a5d6f6ca737f5c0ac8a4d70c5" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db9d1e08dae612689e0b7adf381cac76d2a83bc" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484bca70aea1a557734e7bf929079e6ee00fa7d3" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">Al igual que con el tipo &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; , un &lt;code&gt;HashSet&lt;/code&gt; requiere que los elementos implementen &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; rasgos . Esto se puede lograr con frecuencia usando &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; . Si los implementa usted mismo, es importante que se mantenga la siguiente propiedad:</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">Al igual que con el tipo &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; , un &lt;code&gt;HashSet&lt;/code&gt; requiere que los elementos implementen los rasgos &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Esto se puede lograr con frecuencia usando &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; . Si los implementa usted mismo, es importante que se mantenga la siguiente propiedad:</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">Al igual que con las variables,podemos añadir anotaciones tipográficas si queremos aumentar la claridad y la claridad a costa de ser más verbosos de lo estrictamente necesario.Anotar los tipos para el cierre que definimos en el Listado 13-5 se parecería a la definición mostrada en el Listado 13-7.</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">A medida que agrega m&amp;aacute;s pruebas de integraci&amp;oacute;n, es posible que desee crear m&amp;aacute;s de un archivo en el directorio de &lt;em&gt;pruebas&lt;/em&gt; para ayudar a organizarlas; por ejemplo, puede agrupar las funciones de prueba por la funcionalidad que est&amp;aacute;n probando. Como se mencion&amp;oacute; anteriormente, cada archivo en el directorio de &lt;em&gt;pruebas&lt;/em&gt; se compila como su propia caja separada.</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">Como tambi&amp;eacute;n aprendi&amp;oacute; en el Cap&amp;iacute;tulo 1, &lt;code&gt;println!&lt;/code&gt; es una macro que imprime una cadena en la pantalla:</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">Como puede ver en la firma de &lt;code&gt;spawn&lt;/code&gt; hay dos restricciones tanto en el cierre dado al &lt;code&gt;spawn&lt;/code&gt; como en su valor de retorno, vamos a explicarlas:</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">Como puede ver, la cadena de herramientas estable es la predeterminada. La mayor&amp;iacute;a de los usuarios de Rust usan estable la mayor parte del tiempo. Es posible que desee utilizar estable la mayor parte del tiempo, pero utilizar todas las noches en un proyecto espec&amp;iacute;fico, porque le importa una funci&amp;oacute;n de vanguardia. Para hacerlo, puede usar la &lt;code&gt;rustup override&lt;/code&gt; en el directorio de ese proyecto para configurar la cadena de herramientas nocturna como la &amp;uacute;nica &lt;code&gt;rustup&lt;/code&gt; debe usar rustup cuando est&amp;eacute; en ese directorio:</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">Como pueden ver,esto devolverá los artículos esperados y válidos.</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Como puede ver, el uso de los m&amp;oacute;dulos principales distingue los dos tipos de &lt;code&gt;Result&lt;/code&gt; . Si, en cambio, especificamos &lt;code&gt;use std::fmt::Result&lt;/code&gt; y &lt;code&gt;use std::io::Result&lt;/code&gt; , tendr&amp;iacute;amos dos tipos de &lt;code&gt;Result&lt;/code&gt; en el mismo alcance y Rust no sabr&amp;iacute;a a cu&amp;aacute;l nos referimos cuando usamos &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">Como puede ver, hemos movido todo en un ciclo desde el indicador de entrada de adivinanzas en adelante. Aseg&amp;uacute;rese de sangrar las l&amp;iacute;neas dentro del bucle otros cuatro espacios cada una y ejecute el programa nuevamente. Observe que hay un nuevo problema porque el programa est&amp;aacute; haciendo exactamente lo que le dijimos que hiciera: &amp;iexcl;solicite otra conjetura para siempre! &amp;iexcl;No parece que el usuario pueda salir!</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">Como puede ver, puede especificar par&amp;aacute;metros de tipo entre llaves para sustituirlos por los tipos reales (utilizando la sintaxis de cadena de formato normal) en una situaci&amp;oacute;n determinada. Adem&amp;aacute;s, &lt;code&gt;{Self}&lt;/code&gt; sustituir&amp;aacute; al tipo (en este caso, &lt;code&gt;bool&lt;/code&gt; ) que intentamos usar.</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">Como se puede ver,en muchos aspectos (excepto en lo que respecta a la disposición,la seguridad y la propiedad)las uniones se comportan exactamente como estructuras,en gran parte como consecuencia de la herencia de su forma sintáctica de las estructuras.Esto también es cierto para muchos aspectos no mencionados del lenguaje de Rust (como la privacidad,la resolución de nombres,la inferencia de tipos,los genéricos,las implementaciones de rasgos,las implementaciones inherentes,la coherencia,la comprobación de patrones,etc.,etc.).</target>
        </trans-unit>
        <trans-unit id="82fa816a0b7088673d7a49e7db89040e62362916" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">Como aprendi&amp;oacute; en el Cap&amp;iacute;tulo 16, &lt;code&gt;thread::spawn&lt;/code&gt; crear&amp;aacute; un nuevo hilo y luego ejecutar&amp;aacute; el c&amp;oacute;digo en el cierre del nuevo hilo. Si ejecuta este c&amp;oacute;digo y carga &lt;em&gt;/ duerme&lt;/em&gt; en su navegador, entonces &lt;em&gt;/&lt;/em&gt; en dos pesta&amp;ntilde;as m&amp;aacute;s del navegador, ver&amp;aacute; que las solicitudes a &lt;em&gt;/&lt;/em&gt; no tienen que esperar&lt;em&gt;&lt;/em&gt; a que finalice &lt;em&gt;/ dormir&lt;/em&gt; . Pero como mencionamos, esto eventualmente abrumar&amp;aacute; al sistema porque estar&amp;iacute;a creando nuevos hilos sin ning&amp;uacute;n l&amp;iacute;mite.</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">Como habr&amp;aacute;s adivinado, &lt;code&gt;continue&lt;/code&gt; tiene un &lt;code&gt;!&lt;/code&gt; valor. Es decir, cuando Rust calcula el tipo de &lt;code&gt;guess&lt;/code&gt; , mira ambos brazos coincidentes, el primero con un valor de &lt;code&gt;u32&lt;/code&gt; y el segundo con un &lt;code&gt;!&lt;/code&gt; valor. Porque &lt;code&gt;!&lt;/code&gt; nunca puede tener un valor, Rust decide que el tipo de &lt;code&gt;guess&lt;/code&gt; es &lt;code&gt;u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">Como puede sospechar, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; es un puntero inteligente. M&amp;aacute;s precisamente, la llamada a &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;devuelve&lt;/em&gt; un puntero inteligente llamado &lt;code&gt;MutexGuard&lt;/code&gt; , envuelto en un &lt;code&gt;LockResult&lt;/code&gt; que manejamos con la llamada para &lt;code&gt;unwrap&lt;/code&gt; . El puntero inteligente &lt;code&gt;MutexGuard&lt;/code&gt; implementa &lt;code&gt;Deref&lt;/code&gt; para apuntar a nuestros datos internos; el puntero inteligente tambi&amp;eacute;n tiene una implementaci&amp;oacute;n &lt;code&gt;Drop&lt;/code&gt; que libera el bloqueo autom&amp;aacute;ticamente cuando un &lt;code&gt;MutexGuard&lt;/code&gt; sale del alcance, lo que ocurre al final del alcance interno en el Listado 16-12. Como resultado, no corremos el riesgo de olvidarnos de liberar el bloqueo y bloquear el mutex para que no sea utilizado por otros subprocesos porque la liberaci&amp;oacute;n del bloqueo ocurre autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">Como viste en el Cap&amp;iacute;tulo 1, la &lt;code&gt;cargo new&lt;/code&gt; genera un &quot;&amp;iexcl;Hola, mundo!&quot; programa para usted. Echa un vistazo a &lt;em&gt;src / main.rs&lt;/em&gt; archivo :</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">Como vio en el Cap&amp;iacute;tulo 1, la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; es el punto de entrada al programa:</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">Como viste en el capítulo 6,puedes comparar los patrones con los literales directamente.El siguiente código da algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Como vio en el Listado 17-15, podemos escribir m&amp;eacute;todos que usen la sintaxis &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; , que permite que el m&amp;eacute;todo tome posesi&amp;oacute;n de un valor &lt;code&gt;Self&lt;/code&gt; almacenado en un &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . Eso es exactamente lo que queremos hacer aqu&amp;iacute;, pero desafortunadamente Rust no nos lo permite: la parte de Rust que implementa el comportamiento cuando se llama a un cierre no se implementa usando &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; . Entonces Rust a&amp;uacute;n no comprende que podr&amp;iacute;a usar &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; en esta situaci&amp;oacute;n para tomar posesi&amp;oacute;n del cierre y sacar el cierre del &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">Como vio en el tutorial del juego de adivinanzas en la secci&amp;oacute;n &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;Comparaci&amp;oacute;n de la conjetura con el n&amp;uacute;mero secreto&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 2, puede declarar una nueva variable con el mismo nombre que una variable anterior, y la nueva variable sombrea la variable anterior. Los rust&amp;aacute;ceos dicen que la primera variable est&amp;aacute; &lt;em&gt;sombreada&lt;/em&gt; por la segunda, lo que significa que el valor de la segunda variable es lo que aparece cuando se usa la variable. Podemos sombrear una variable usando el mismo nombre de variable y repitiendo el uso de &lt;code&gt;let&lt;/code&gt; palabra clave siguiente manera:</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">A medida que escribe programas grandes, organizar su c&amp;oacute;digo ser&amp;aacute; importante porque llevar un registro de todo su programa en su cabeza ser&amp;aacute; imposible. Al agrupar la funcionalidad relacionada y separar el c&amp;oacute;digo con caracter&amp;iacute;sticas distintas, aclarar&amp;aacute; d&amp;oacute;nde encontrar c&amp;oacute;digo que implemente una caracter&amp;iacute;stica en particular y ad&amp;oacute;nde ir para cambiar c&amp;oacute;mo funciona una caracter&amp;iacute;stica.</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">A medida que su proyecto crezca, considere usar un espacio de trabajo: es m&amp;aacute;s f&amp;aacute;cil comprender componentes individuales m&amp;aacute;s peque&amp;ntilde;os que una gran cantidad de c&amp;oacute;digo. Adem&amp;aacute;s, mantener las cajas en un espacio de trabajo puede facilitar la coordinaci&amp;oacute;n entre ellas si se cambian a menudo al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="1b3c2291de90fba8268fb52f3659391950c3a127" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly bracket, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">Aparte de las llaves de cierre, solo hay una l&amp;iacute;nea m&amp;aacute;s para discutir en el c&amp;oacute;digo agregado hasta ahora, que es la siguiente:</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">Cuando se le pregunte cu&amp;aacute;nto mide la cadena, podr&amp;iacute;a responder 12. Sin embargo, la respuesta de Rust es 24: esa es la cantidad de bytes que se necesitan para codificar &quot;Здравствуйте&quot; en UTF-8, porque cada valor escalar Unicode en esa cadena ocupa 2 bytes de almacenamiento. Por lo tanto, un &amp;iacute;ndice en los bytes de la cadena no siempre se correlacionar&amp;aacute; con un valor escalar Unicode v&amp;aacute;lido. Para demostrarlo, considere este c&amp;oacute;digo de Rust no v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">Afirma que los resultados son los que esperas.</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">Las afirmaciones siempre se comprueban tanto en versiones de depuraci&amp;oacute;n como de versiones, y no se pueden deshabilitar. &amp;iexcl;Ver &lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt;para las afirmaciones que no est&amp;aacute;n habilitadas en las versiones de versiones de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">Afirma que una expresi&amp;oacute;n booleana es &lt;code&gt;true&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Afirma que dos expresiones son iguales entre s&amp;iacute; (usando &lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">Afirma que dos expresiones son iguales entre sí.</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Afirma que dos expresiones no son iguales entre s&amp;iacute; (usando &lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">Afirma que dos expresiones no son iguales entre sí.</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">Expresiones de asignación</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">La asignaci&amp;oacute;n de &lt;code&gt;A + B&lt;/code&gt; a &lt;code&gt;A&lt;/code&gt; podr&amp;iacute;a eliminarse, ya que la suma se puede almacenar en una ubicaci&amp;oacute;n temporal hasta que se imprima, y ​​la variable global nunca se actualiza.</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">Las asignaciones no están permitidas en los patrones de guardia,porque el emparejamiento no puede tener efectos secundarios.Los efectos secundarios podrían alterar el objeto emparejado o el entorno del que depende el emparejamiento de tal manera,que el emparejamiento no sería exhaustivo.Por ejemplo,lo siguiente no coincidiría con ningún brazo si se permitieran las asignaciones:</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">Asigna un nuevo valor a la memoria detrás de la referencia fijada.</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">Constantes asociadas</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">Constantes asociadas Ejemplos</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">Funciones asociadas</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">Artículos asociados</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">Tipos asociados</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">Tipos asociados Ejemplo de contenedor</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">Constantes,funciones y tipos asociados</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">Funciones y métodos asociados</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">Las funciones asociadas se utilizan a menudo para constructores que devolver&amp;aacute;n una nueva instancia de la estructura. Por ejemplo, podr&amp;iacute;amos proporcionar una funci&amp;oacute;n asociada que tendr&amp;iacute;a un par&amp;aacute;metro de dimensi&amp;oacute;n y usarlo como ancho y alto, lo que facilitar&amp;iacute;a la creaci&amp;oacute;n de un &lt;code&gt;Rectangle&lt;/code&gt; cuadrado en lugar de tener que especificar el mismo valor dos veces:</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">Las funciones asociadas cuyo primer par&amp;aacute;metro se denomina &lt;code&gt;self&lt;/code&gt; se denominan &lt;em&gt;m&amp;eacute;todos&lt;/em&gt; y pueden invocarse utilizando el &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;operador de llamada&lt;/a&gt; al m&amp;eacute;todo , por ejemplo, &lt;code&gt;x.foo()&lt;/code&gt; , as&amp;iacute; como la notaci&amp;oacute;n habitual de llamada a funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">Elemento asociado...</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">Elemento asociado para un tipo que no se puede nombrar directamente (por ejemplo, &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; , &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; , etc.)</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">Los elementos asociados son &amp;uacute;tiles cuando el elemento asociado est&amp;aacute; l&amp;oacute;gicamente relacionado con el elemento asociado. Por ejemplo, el m&amp;eacute;todo &lt;code&gt;is_some&lt;/code&gt; en &lt;code&gt;Option&lt;/code&gt; est&amp;aacute; intr&amp;iacute;nsecamente relacionado con Options, por lo que deber&amp;iacute;a estar asociado.</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">Buscador asociado para este patrón</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Tipo asociado para &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Tipo asociado para &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Tipo asociado para &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Tipo asociado para &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">Se pueden usar tipos asociados de &lt;code&gt;Trait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">Los tipos asociados podrían parecer un concepto similar al de los genéricos,en el sentido de que estos últimos permiten definir una función sin especificar qué tipos puede manejar.Entonces,¿por qué usar tipos asociados?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">Supongamos que hay dos archivos en el mismo directorio con el siguiente contenido:</target>
        </trans-unit>
        <trans-unit id="a7203654194ae4db3f1b4a3c121163c9fc8267f3" translate="yes" xml:space="preserve">
          <source>Assumes that the &lt;code&gt;VecDeque&lt;/code&gt; is sorted by the key, for instance with &lt;a href=&quot;#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous().sort_by_key()&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">Asume que el segmento est&amp;aacute; ordenado por clave, por ejemplo con &lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt; usando la misma funci&amp;oacute;n de extracci&amp;oacute;n de clave.</target>
        </trans-unit>
        <trans-unit id="7da83b920d859bea1ef24ff98129cc3f739b791b" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a mutable slice to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d70f82d569a6dc638a5854fc3e366cb50b91e26" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a slice to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">Suponiendo que hay un archivo llamado &lt;code&gt;foo.txt&lt;/code&gt; con contenido &lt;code&gt;abcdef\n&lt;/code&gt; , cree dos identificadores, busque uno de ellos y lea los bytes restantes del otro identificador:</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">Las importaciones globales de Asterisk importar&amp;aacute;n los elementos importados con &lt;code&gt;_&lt;/code&gt; en su forma innominable.</target>
        </trans-unit>
        <trans-unit id="940e0ca02bfde86559dac73ad0f3397300f703e1" translate="yes" xml:space="preserve">
          <source>Async blocks act like a function boundary, much like closures. Therefore, the &lt;code&gt;?&lt;/code&gt; operator and &lt;code&gt;return&lt;/code&gt; expressions both affect the output of the future, not the enclosing function or other context. That is, &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; from within a closure will return the result of &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; as the output of the future. Similarly, if &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; propagates an error, that error is propagated as the result of the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214d7973c7382a6a34b11e3f97cf5442c859fb3e" translate="yes" xml:space="preserve">
          <source>Async blocks capture variables from their environment using the same &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;capture modes&lt;/a&gt; as closures. Like closures, when written &lt;code&gt;async { .. }&lt;/code&gt; the capture mode for each variable will be inferred from the content of the block. &lt;code&gt;async move { .. }&lt;/code&gt; blocks however will move all referenced variables into the resulting future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f9a16fc928066d87c71b1e0690e9ad26edea0a" translate="yes" xml:space="preserve">
          <source>Async context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99471e2fa36e20e9d7193c5529dfbf6f52a711a2" translate="yes" xml:space="preserve">
          <source>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function's body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">Valores asíncronos.</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="6aa8b3387e6ffd75791adbf0065888a4924635f2" translate="yes" xml:space="preserve">
          <source>At a high level, a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;. Things get more subtle when discussing types that combine pinned with non-pinned data; &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;see below&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">En todo momento, debes evitar las carreras de datos. Si varios subprocesos tienen acceso al mismo &lt;code&gt;UnsafeCell&lt;/code&gt; , todas las escrituras deben tener una relaci&amp;oacute;n adecuada de suceder antes de todos los dem&amp;aacute;s accesos (o usar atomics).</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">En un momento dado, puede tener &lt;em&gt;o bien&lt;/em&gt; (pero no ambos) una referencia mutable o cualquier n&amp;uacute;mero de referencias inmutables.</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">En un momento dado, puede tener &lt;em&gt;ya sea&lt;/em&gt; una referencia mutable &lt;em&gt;o&lt;/em&gt; cualquier n&amp;uacute;mero de referencias inmutables.</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">En el momento de la compilaci&amp;oacute;n, cada implementaci&amp;oacute;n de &lt;code&gt;Trait&lt;/code&gt; producir&amp;aacute; una tabla que contiene los diversos m&amp;eacute;todos (y otros elementos) relacionados con la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">En tiempo de compilaci&amp;oacute;n, Rust necesita saber cu&amp;aacute;nto espacio ocupa un tipo. Un tipo cuyo tama&amp;ntilde;o no se puede conocer en tiempo de compilaci&amp;oacute;n es un &lt;em&gt;tipo recursivo&lt;/em&gt; , donde un valor puede tener como parte de s&amp;iacute; mismo otro valor del mismo tipo. Debido a que este anidamiento de valores podr&amp;iacute;a te&amp;oacute;ricamente continuar infinitamente, Rust no sabe cu&amp;aacute;nto espacio necesita un valor de tipo recursivo. Sin embargo, los cuadros tienen un tama&amp;ntilde;o conocido, por lo que al insertar un cuadro en una definici&amp;oacute;n de tipo recursivo, puede tener tipos recursivos.</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">En cada punto del programa donde cambia el recuento de referencias, imprimimos el recuento de referencias, que podemos obtener llamando a la funci&amp;oacute;n &lt;code&gt;Rc::strong_count&lt;/code&gt; . Esta funci&amp;oacute;n se denomina &lt;code&gt;strong_count&lt;/code&gt; lugar de &lt;code&gt;count&lt;/code&gt; porque el tipo &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; tambi&amp;eacute;n tiene una &lt;code&gt;weak_count&lt;/code&gt; ; veremos para qu&amp;eacute; se usa &lt;code&gt;weak_count&lt;/code&gt; en la secci&amp;oacute;n &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&quot;Prevenci&amp;oacute;n de ciclos de referencia: convertir un &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; en un &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; &quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">Al principio, no tenemos ninguna memoria asignada, pero a medida que agregamos a la cadena, aumenta su capacidad de manera adecuada. Si en cambio usamos el m&amp;eacute;todo &lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; para asignar la capacidad correcta inicialmente:</target>
        </trans-unit>
        <trans-unit id="dc05814fc863fd7b76fdcfe7f779c72f9533e270" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">En su forma m&amp;aacute;s simple, una prueba en Rust es una funci&amp;oacute;n que se anota con el atributo de &lt;code&gt;test&lt;/code&gt; . Los atributos son metadatos sobre partes del c&amp;oacute;digo de Rust; un ejemplo es el atributo &lt;code&gt;derive&lt;/code&gt; que usamos con las estructuras en el Cap&amp;iacute;tulo 5. Para cambiar una funci&amp;oacute;n en una funci&amp;oacute;n de prueba, agregue &lt;code&gt;#[test]&lt;/code&gt; en la l&amp;iacute;nea antes de &lt;code&gt;fn&lt;/code&gt; . Cuando ejecuta sus pruebas con el comando de &lt;code&gt;cargo test&lt;/code&gt; , Rust crea un binario de corredor de prueba que ejecuta las funciones anotadas con el atributo de &lt;code&gt;test&lt;/code&gt; e informa si cada funci&amp;oacute;n de prueba pasa o falla.</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">Al menos uno de &lt;code&gt;Self&lt;/code&gt; o un par&amp;aacute;metro de tipo gen&amp;eacute;rico del rasgo debe cumplir con la siguiente gram&amp;aacute;tica, donde &lt;code&gt;C&lt;/code&gt; es un tipo nominal definido dentro de la caja contenedora:</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">Al menos uno de los punteros se está usando para escribir en los datos.</target>
        </trans-unit>
        <trans-unit id="5724aa0694940a76277017d916e0999814aa1912" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a &lt;a href=&quot;../glossary#local-type&quot;&gt;local type&lt;/a&gt;. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87e525060c2b4080d7c34755a062916a4109c19" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a local type. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a139025cd9d3b2fee71807f78a3b49ac15b212ef" translate="yes" xml:space="preserve">
          <source>At present few predefined ABI's (like Rust, C, system, etc.) can be used in Rust. Verify that the ABI is predefined. For example you can replace the given ABI from 'Rust'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">En la actualidad,no se permite tener un rendimiento que se produzca mientras un préstamo está todavía en el ámbito de aplicación.Para resolver este error,el empréstito debe ser &quot;contenido&quot; a un alcance menor que no se superponga al rendimiento o bien eliminado de otra manera.Así,por ejemplo,podríamos resolver el ejemplo anterior eliminando el empréstito y almacenando simplemente el número entero por valor:</target>
        </trans-unit>
        <trans-unit id="c58aa6f87c5fb2f5db7b812c6bc9a21b048e36a1" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to pass more than one explicit parameter for a generator.This can be fixed by using at most 1 parameter for the generator. For example, we might resolve the previous example by passing only one parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e36fb08191e884058237321d264d01b5dc6a45f" translate="yes" xml:space="preserve">
          <source>At run-time, when a method needs to be called on the &lt;code&gt;dyn Trait&lt;/code&gt;, the vtable is consulted to get the function pointer and then that function pointer is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf3e76f07038198aca7a45dd9300fbaa0a3ed8a" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self != other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine the inequality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be unequal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddac349169d1a744bfbed1eee12e4790040330f" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self == other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine equality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be equal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">Al principio de este capítulo,dijimos que los vectores sólo pueden almacenar valores del mismo tipo.Esto puede ser un inconveniente;definitivamente hay casos de uso para necesitar almacenar una lista de elementos de diferentes tipos.Afortunadamente,las variantes de un enum se definen bajo el mismo tipo de enum,por lo que cuando necesitamos almacenar elementos de un tipo diferente en un vector,podemos definir y utilizar un enum!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">Por el momento, los bloques &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; tienen mucha repetici&amp;oacute;n: est&amp;aacute;n leyendo archivos y escribiendo el contenido de los archivos en la transmisi&amp;oacute;n. Las &amp;uacute;nicas diferencias son la l&amp;iacute;nea de estado y el nombre del archivo. Hagamos el c&amp;oacute;digo m&amp;aacute;s conciso extrayendo esas diferencias en l&amp;iacute;neas &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; separadas que asignar&amp;aacute;n los valores de la l&amp;iacute;nea de estado y el nombre de archivo a las variables; luego podemos usar esas variables incondicionalmente en el c&amp;oacute;digo para leer el archivo y escribir la respuesta. El Listado 20-9 muestra el c&amp;oacute;digo resultante despu&amp;eacute;s de reemplazar los grandes bloques &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1fe5f0e39ec55eb0cd362275db96ad9cd1656e2" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;.await&lt;/code&gt;, and the &lt;code&gt;Try&lt;/code&gt; operator (&lt;code&gt;?&lt;/code&gt;) are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929c7d4e23e7e49a6c726514ca62a32c23fbe8e1" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt;, as well as the looping constructs &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt;, are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">&amp;iexcl;Por el momento, estamos escribiendo toda nuestra salida en la terminal usando &lt;code&gt;println!&lt;/code&gt; funci&amp;oacute;n. La mayor&amp;iacute;a de los terminales proporcionan dos tipos de salida: salida &lt;em&gt;est&amp;aacute;ndar&lt;/em&gt; ( &lt;code&gt;stdout&lt;/code&gt; ) para informaci&amp;oacute;n general y &lt;em&gt;error est&amp;aacute;ndar&lt;/em&gt; ( &lt;code&gt;stderr&lt;/code&gt; ) para mensajes de error. Esta distinci&amp;oacute;n permite a los usuarios elegir dirigir la salida exitosa de un programa a un archivo pero a&amp;uacute;n as&amp;iacute; imprimir mensajes de error en la pantalla.</target>
        </trans-unit>
        <trans-unit id="8d5aa8f95e2e92d8aada8f026371cf7b990b2775" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; macro. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">En el momento de escribir este art&amp;iacute;culo, se est&amp;aacute; desarrollando una herramienta de &lt;code&gt;rustfmt&lt;/code&gt; autom&amp;aacute;tica llamada rustfmt . Si desea ce&amp;ntilde;irse a un estilo est&amp;aacute;ndar en todos los proyectos de Rust, &lt;code&gt;rustfmt&lt;/code&gt; formatear&amp;aacute; su c&amp;oacute;digo en un estilo particular. El equipo de Rust planea eventualmente incluir esta herramienta con la distribuci&amp;oacute;n est&amp;aacute;ndar de Rust, como &lt;code&gt;rustc&lt;/code&gt; . Entonces, dependiendo de cu&amp;aacute;ndo lea este libro, &amp;iexcl;es posible que ya est&amp;eacute; instalado en su computadora! Consulte la documentaci&amp;oacute;n en l&amp;iacute;nea para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">En el momento de escribir esto,hay dos ediciones de Rust disponibles:Rust 2015 y Rust 2018.Este libro está escrito usando los modismos de la edición Rust 2018.</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">En ese momento, dijimos que no se preocupara por las llamadas de &lt;code&gt;clone&lt;/code&gt; ineficientes porque las eliminar&amp;iacute;amos en el futuro. Bueno, &amp;iexcl;ese momento es ahora!</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">En ese momento, omitimos algunos detalles en este c&amp;oacute;digo. En el cap&amp;iacute;tulo 6 de &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;El &lt;code&gt;match&lt;/code&gt; de control del operador Flow&amp;rdquo;&lt;/a&gt; secci&amp;oacute;n, discutimos que los &lt;code&gt;match&lt;/code&gt; brazos de retornar todos del mismo tipo. Entonces, por ejemplo, el siguiente c&amp;oacute;digo no funciona:</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">En este punto, &lt;code&gt;cargo build&lt;/code&gt; deber&amp;iacute;a completarse correctamente tanto en &lt;code&gt;hello_macro&lt;/code&gt; como en &lt;code&gt;hello_macro_derive&lt;/code&gt; . &amp;iexcl;Conectemos estas cajas al c&amp;oacute;digo del Listado 19-30 para ver la macro de procedimiento en acci&amp;oacute;n! Crea un nuevo proyecto binario en tu directorio de &lt;em&gt;proyectos&lt;/em&gt; usando &lt;code&gt;cargo new pancakes&lt;/code&gt; . Tenemos que a&amp;ntilde;adir &lt;code&gt;hello_macro&lt;/code&gt; y &lt;code&gt;hello_macro_derive&lt;/code&gt; como dependencias en el &lt;code&gt;pancakes&lt;/code&gt; de caj&amp;oacute;n &lt;em&gt;Cargo.toml&lt;/em&gt; . Si est&amp;aacute; publicando sus versiones de &lt;code&gt;hello_macro&lt;/code&gt; y &lt;code&gt;hello_macro_derive&lt;/code&gt; en las dependencias de &lt;code&gt;path&lt;/code&gt; &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io de la&lt;/a&gt; , ser&amp;iacute;an dependencias regulares; si no, puede especificarlos como siguiente manera:</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">En este punto, &lt;code&gt;s&lt;/code&gt; ser&amp;aacute; &lt;code&gt;tic-tac-toe&lt;/code&gt; . Con todos los caracteres &lt;code&gt;+&lt;/code&gt; y &lt;code&gt;&quot;&lt;/code&gt; , es dif&amp;iacute;cil ver qu&amp;eacute; est&amp;aacute; pasando. Para una combinaci&amp;oacute;n de cadenas m&amp;aacute;s complicada, podemos usar la macro &lt;code&gt;format!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">En este punto, la primera parte del juego est&amp;aacute; lista: recibimos informaci&amp;oacute;n del teclado y luego la imprimimos.</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">En este punto, la relaci&amp;oacute;n entre &amp;aacute;mbitos y cu&amp;aacute;ndo las variables son v&amp;aacute;lidas es similar a la de otros lenguajes de programaci&amp;oacute;n. Ahora nos basaremos en este conocimiento introduciendo el tipo &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">En este punto, podemos construir el espacio de trabajo ejecutando &lt;code&gt;cargo build&lt;/code&gt; . Los archivos en su directorio de &lt;em&gt;adici&amp;oacute;n&lt;/em&gt; deber&amp;iacute;an verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f644530959c577881d3641aeacacd055e0614725" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">En este punto, podr&amp;iacute;amos considerar oportunidades para refactorizar la implementaci&amp;oacute;n de la funci&amp;oacute;n de b&amp;uacute;squeda mientras se mantienen las pruebas aprobadas para mantener la misma funcionalidad. El c&amp;oacute;digo de la funci&amp;oacute;n de b&amp;uacute;squeda no es tan malo, pero no aprovecha algunas caracter&amp;iacute;sticas &amp;uacute;tiles de los iteradores. Volveremos a este ejemplo en el [Cap&amp;iacute;tulo 13] [ch13], donde exploraremos los iteradores en detalle y veremos c&amp;oacute;mo mejorarlo.</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">En este punto, cuando invocamos &lt;code&gt;content&lt;/code&gt; en &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; , la coerci&amp;oacute;n deref entrar&amp;aacute; en vigor en &lt;code&gt;&amp;amp;&lt;/code&gt; y &lt;code&gt;Box&lt;/code&gt; , por lo que el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; se llamar&amp;aacute; finalmente en el tipo que implementa el rasgo de &lt;code&gt;State&lt;/code&gt; . Eso significa que necesitamos agregar &lt;code&gt;content&lt;/code&gt; a la definici&amp;oacute;n del rasgo de &lt;code&gt;State&lt;/code&gt; , y ah&amp;iacute; es donde pondremos la l&amp;oacute;gica de qu&amp;eacute; contenido devolver&amp;aacute; dependiendo del estado que tengamos, como se muestra en el Listado 17-18:</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">En este punto, cuando intentamos obtener una referencia al padre de la &lt;code&gt;leaf&lt;/code&gt; mediante el m&amp;eacute;todo de &lt;code&gt;upgrade&lt;/code&gt; , obtenemos un valor &lt;code&gt;None&lt;/code&gt; . &amp;iexcl;Vemos esto en la salida de la primera &lt;code&gt;println!&lt;/code&gt; declaraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">En este punto, tambi&amp;eacute;n notar&amp;aacute;s un cambio en tu archivo &lt;em&gt;Cargo.lock y notar&amp;aacute;s&lt;/em&gt; que la versi&amp;oacute;n de la caja &lt;code&gt;rand&lt;/code&gt; que est&amp;aacute;s usando ahora es &lt;code&gt;0.3.15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="980ca773a0cc1c507c75dc787b2ebd61a83c58ee" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.5.6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">En este punto, ha visto varias formas de usar patrones, pero los patrones no funcionan igual en todos los lugares donde podemos usarlos. En algunos lugares, los patrones deben ser irrefutables; en otras circunstancias, pueden ser refutables. A continuaci&amp;oacute;n, discutiremos estos dos conceptos.</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">En este punto, ha construido con &amp;eacute;xito el juego de adivinanzas. &amp;iexcl;Felicidades!</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Recuento de referencias at&amp;oacute;micas con &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">Los ordenamientos de la memoria atómica</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">Las operaciones at&amp;oacute;micas se pueden implementar en la capa de instrucci&amp;oacute;n con at&amp;oacute;micas de mayor tama&amp;ntilde;o. Por ejemplo, algunas plataformas usan instrucciones at&amp;oacute;micas de 4 bytes para implementar &lt;code&gt;AtomicI8&lt;/code&gt; . Tenga en cuenta que esta emulaci&amp;oacute;n no deber&amp;iacute;a tener un impacto en la correcci&amp;oacute;n del c&amp;oacute;digo, es algo que debe tener en cuenta.</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">Las operaciones at&amp;oacute;micas con sem&amp;aacute;ntica &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n pueden sincronizarse con una valla.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">Los tipos atómicos</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">Los tipos at&amp;oacute;micos se pueden almacenar en variables est&amp;aacute;ticas, inicializadas usando los inicializadores constantes como &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt; . La est&amp;aacute;tica at&amp;oacute;mica se utiliza a menudo para la inicializaci&amp;oacute;n global perezosa.</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">Los tipos atómicos proporcionan una primitiva comunicación de memoria compartida entre hilos,y son los bloques de construcción de otros tipos concurrentes.</target>
        </trans-unit>
        <trans-unit id="489ec10910f60409e46dc7b2401064ba30bfb22a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of Rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">Las variables at&amp;oacute;micas son seguras para compartir entre subprocesos (implementan &lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; ) pero no proporcionan por s&amp;iacute; mismas el mecanismo para compartir y siguen el &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;modelo&lt;/a&gt; de subprocesos de rust. La forma m&amp;aacute;s com&amp;uacute;n de compartir una variable at&amp;oacute;mica es ponerla en un &lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; (un puntero compartido contado por referencia at&amp;oacute;mica).</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">Atómicamente hace que la ficha del mango esté disponible si no lo está ya.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">Intente bajar el &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; a un tipo concreto.</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">Intente rebajar el &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; a un tipo concreto.</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">Intenta bajar la caja a un tipo concreto.</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">Intentar resolver el futuro hasta un valor final,registrando la tarea actual para el despertar si el valor no está todavía disponible.</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intente resolver el futuro a un valor final, registrando la tarea actual para reactivarla si el valor a&amp;uacute;n no est&amp;aacute; disponible. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intente resolver el futuro a un valor final, registrando la tarea actual para reactivarla si el valor a&amp;uacute;n no est&amp;aacute; disponible. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dc2a85c8ec42aea412c46625d0258c82f5009a" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">Se intentó importar un artículo mientras que ya se ha importado una caja externa con este nombre.</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">Se intentó importar un valor no importable.Esto puede suceder cuando se intenta importar un método de un rasgo.</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">Intentó acceder a un campo de un tipo primitivo.</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">Intentó acceder a un método como un campo.</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">Intentó acceder a un campo inexistente en una estructura.</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">Intentó acceder a un campo privado en una estructura.</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">Intentó llamar a algo que no es una función ni un método.</target>
        </trans-unit>
        <trans-unit id="19e440b538f0d8907b6a787acfc5bb52be0236f7" translate="yes" xml:space="preserve">
          <source>Attempted to cast to/from a pointer with an unknown kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">Intentó derivar una variable que no se puede derivar.</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">Intentó pasar un tipo de variable inválida a una función variádica.</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">Intentar compilar ahora nos da la siguiente salida:</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">Intentar compilar este código da como resultado este tipo de error:</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">Intentando crear un iterador &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; a&lt;/a&gt; partir de una direcci&amp;oacute;n de socket &lt;code&gt;&amp;amp;str&lt;/code&gt; formateada incorrectamente (falta el puerto):</target>
        </trans-unit>
        <trans-unit id="ef35b76897ce014407ed31f4f40475dbcd2bb582" translate="yes" xml:space="preserve">
          <source>Attempting to create a raw pointer to an &lt;code&gt;unaligned&lt;/code&gt; struct field with an expression such as &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; creates an intermediate unaligned reference before converting that to a raw pointer. That this reference is temporary and immediately cast is inconsequential as the compiler always expects references to be properly aligned. As a result, using &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; causes immediate &lt;em&gt;undefined behavior&lt;/em&gt; in your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">El intento de crear un objeto de rasgo para un rasgo no seguro del objeto desencadenará este error.</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">Intenta adquirir esta cerradura.</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">Intenta adquirir este reloj con acceso de lectura compartido.</target>
        </trans-unit>
        <trans-unit id="60ca78e1d1551297af7765e326760c4a38aa394c" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943f34bb668f31f44c32b4ace4e03989407198f9" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855d837817da86285b7a962a1f7fe2fb0ca3b0f2" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c43d8666b34161b53b0b2ccf4916af8bde88930" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba17f171bdff89eb9e4d13d3205c5589ee7c0ea" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">Intenta recoger el estado de salida del niño si ya ha salido.</target>
        </trans-unit>
        <trans-unit id="c1be452e1098fe5e2ba823c663805fe4f191d856" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f700a71652c58da7326026511c609bb65c78a5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b8bfe658e12622625c1e875a019db8830b0989" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a76479bea9155fc85828e929db52c84fd63e6c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97a798e91eb0541c3e3c246eb5e2ac5797cb455" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed691c14807b35b2f2548e2bc752f978c9b573b3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468a506dd2d83e7c4d19f2315c61b797dc6e4d81" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501645681c486dcfde763f239c9dbc39c9a89e74" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87e26b0a7cd242115748e46f0ec96044936078e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0d914b6e10991069d8605388d14c2b1ca592cd" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958ed88b5c4639ba37034945d4fa7653d11ec14d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be612cdd6f48c673bcc19746b3317e990d42bddc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c356c6158c8679c2d029abe3620f468bf5b9b89" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ea0a6247bb234c0382208391062366c8d45afa" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4b3bab90d338dc97a29e174b6ac89affad0eee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3306b6d8338537145c4e522fa6d3095a838e24ed" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8c226a4f3a2e9faf3bd2edc42cfa8c056aa1dc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2350a1a3377e42242cdfb3bcc58bf4230d39faee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616abf596e103379ba7981d5f1e76f05a2ea5666" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f894e5fc7159364d10324e42a2aabd76a1311686" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ae0dea78c18426532483b357c55d9190d0c56e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef3839c406eb138bd48f980d20053dec4a89576" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c41b12b6a5c51bf92010b091987428554830e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5448bf065e3955c9eea9670b86f542b60f1a0d99" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5994e4c20d71914f91892cc5ecb435c7068406" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c142214aae8a432d7a06e49f1095d64d5abcf8e1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6debd548d7dfbbbf4dd441963174cff21d7cdf02" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5bd3db3824015309ca5994329cb635606bb61e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e3ad073d959cecc0ef2f46909df5654f941abe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27970ce49dac2a260596044481b8209701cc6df9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc731c548e3edd60d482acb352eb954334d827f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf1693e06446e1b570049dea824ca2f5de4f983" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf21f7180107143b1c2df0ada7adb608ce576f5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933cccb563bf70c8384b3537cf5d53af66522f2f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1923808fa8774e72e6b98f0d83b066dadba4e2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354ab0355cf5bb942ae945004201e3e00a7b805c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1efb3585f71154fa405501c22aeb01a824f8ab1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c157007b3ce40ab86f83ee061270c2516fbee74c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3363ae51b3ea763ca696b60555078ab17bcbb4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c1a1e7cdabd9277cf3f6090aec0cbb69fbae9d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fa909a8d07ec9bebd2c3a4ba3244aa21e756ab" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc706f3890ff34068fa3987549fc9e943e12ee7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9406edc100eab7a11042f495f5605472cde3da93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9302879ee5829e1588c324186708b8a56fd80bf6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b776a75cae811bf723255d190f55f89b79a29f17" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332b91f901664ebad9ee86d115e69f5a7a3b4d2e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f1ac4806f54fa95041af1e83978837424908c0" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9382ddfacff70da4aaa8665a550fdda9aeffbdbe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cfff31cec5836c2d435b155797b06f97a88b5a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e1a0344dcbdab94d2a5a137db0b6fe3077cc05" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5d4e575e612dc8137f25de68e1c8c2bca6bb80" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0813f21e382c2efbc0af883a820eed2568b9960b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fb19758341f597fd85cf5eff51cea75139832f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec588e739f156798bddcb79b1a4f397464f2ee1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cb3c9348ff015679d375f740e5de8691a989ad" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78453501b58efe0df37ba60dce757e854979bf0b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1754f440af8e327e3628892e889e890ca0fdfa7a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f7b535be0370cddd62901980eb0ddf9e3fbcef" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99899bbe257c97c7294c60c8cbb6dcdaba0937c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ffacd53f0d563c90eca54db4e3068e8ac7bc58" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32f0af0599976a74621043264a001a3e32ccab3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99847ce375f1c7bf52ad9dbf9cbe8ebc71c7e0d1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abc78a9982271a77eb82cbdd6f2e2a5c397b7e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c394131db124e9071401792a8209e92dd32cde6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0859484eecde175859b2793704416213e22b608" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72fdb2a4fa84fd42a73a35812e8216884b62fceb" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fdd2383cf95915cfbafeedd94c6cf3ece1cda1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8ba1870526b34b3010dfda32d9e6ef25b46c3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609415cf60341744050aa964021a2dbc6757bce9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3cfcd25580562f26787f2a4ece451df14e3410" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e09395ec650cc77cefa22bbdfa6829f42f4235" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6c92d747eecea95deef0df11e2de577f89b584" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6a16a046a47e51b8dbbc17c05fb83363da4079" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681e0c5dd009397d090a42219e25007f044800b1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbde01dde5e3f3012cf4334646a7f5ef28b672b2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4a8de77e7ee61e1fc27cc89dab1a66ef82bc93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ce329fa4a9ee415c158ac8a1274f6e57fb2e20" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1abe67a3e4364a619efb676e5daa3d020ddb2d3f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bf65adb8592efb46990546bc8cbe35b0283a56" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6551a1616534f8c2d695ae7db8375e577d6398" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c2cbaf513eb994bd548c282a61f57637c77f67" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6851d41e88cb2aaa40c97ac167640ba1262eb3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ddc3e3dfd9a428705e36e86a5e0594a1b9eff7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60905ee844e93f0259575760c3d1354fd6ee0145" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b553e368c520708ccfbe33c562a7aac19b19ea" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbbce1f0f87a53359eb132f6a57b8badd4665c5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc18f3bf4b5cd397ebe0fa08f9b0234fe5f4691" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8feff95241828b618a9f8f2cedee35cf34dbc2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ef28f0274fbbc17ccd2ed7051a33a172b5845b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bee2c6e9925f66c4b7aa5fa6a1b124e2eb59e5e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f97a59c56e1d9e1b3d6440f468bdeaa5169d29a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915108f700cb0a82a36eec28483bf51e615c31a7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d60598f796fd4c7d2797827f8cc377d4829f91" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a888711092f4db9142baf49d1d094a1588d95bc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96596905fbde7e740d6654a8d248b25e64e80725" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42cd22a3bffa9bab2837c2ad66ee139ebc73564" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d1fb95e25a0fa6c34caf0d382246658d283ed6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba2351b2e57e9559c0f3714a76ac923ea85c4c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2730452bbdf6d0154f196dd3387e5268fcbaae6d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a676b16e76690126c8c689d7093c8a36a6dc3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2f75ee1f964bb69b3471df2010cd26d4f8b3c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93de3bc4194ab8f5cef5b860227606b9963f2e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6042fa62c1123d272cfaedcf34e40785b595efa5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;isize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44685c697bf86bf627255f318a92026c3067b36" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f6c21bb3f0a85bb02b720c0facffc143df545d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f25fe04e2aca5c5faadb4cc9021f2c2472cc8a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf97d063f75afad6228d1db287eb0de45a1ab04" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d08d408000b79c0c0f0951f917eed73ebef3a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cee9eaea9548154103d038cde6240ee1cc68830" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;usize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9e42b5d35e242781f009f21f3c5ea257d9b8d7" translate="yes" xml:space="preserve">
          <source>Attempts to converts a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; to a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d17c0e55fb5767927f25b2be2aaccc4cffbef7d" translate="yes" xml:space="preserve">
          <source>Attempts to downcast the box to a concrete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">Intenta extender la asignaci&amp;oacute;n a la que hace referencia &lt;code&gt;ptr&lt;/code&gt; para que se ajuste a &lt;code&gt;new_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intenta extender la asignaci&amp;oacute;n a la que hace referencia &lt;code&gt;ptr&lt;/code&gt; para que se ajuste a &lt;code&gt;new_size&lt;/code&gt; . &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="610fb844291f2a525fe83689f6eb20dc7f8fe95f" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa5063683af7571841f72f0953d587299850850" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c873a148fefc84fd64a13dc7df4ae1e7fa3719" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54633b194aa39ce8f38436cb1feb8f160a116984" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adef0a0225d086130a40a297ad3ad900429332c4" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">Intenta bloquear este reloj con acceso exclusivo de escritura.</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">Intenta abrir un archivo en modo de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">Intenta devolver un valor pendiente en este receptor sin bloquearlo.</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">Intenta enviar un valor en este canal sin bloquearlo.</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">Intenta enviar un valor en este canal,devolviéndolo si no puede ser enviado.</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">Intenta reducir la asignaci&amp;oacute;n a la que hace referencia &lt;code&gt;ptr&lt;/code&gt; para que se ajuste a &lt;code&gt;new_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intenta reducir la asignaci&amp;oacute;n a la que hace referencia &lt;code&gt;ptr&lt;/code&gt; para que se ajuste a &lt;code&gt;new_size&lt;/code&gt; . &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08f5853268ae278f691eb7a82a1231c55496e49d" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c648c706ee8142ae651a14916b0ab8f1c626c9d5" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70a3bb894ec313a60c83cc036390a2df8753cb7" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1e6da2468f6f1396385de5f3580dfdb6c5c166" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e65f083a95479e0e7fff8e23938d5ab69fdc1f" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">Intenta sincronizar todos los metadatos internos del sistema operativo con el disco.</target>
        </trans-unit>
        <trans-unit id="bd1357cf9c16c8860cced8547ac6ac2266fff48b" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">Intenta actualizar el puntero &lt;code&gt;Weak&lt;/code&gt; a un &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; o&lt;/a&gt; , extendiendo la vida &amp;uacute;til del valor si tiene &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="3f7dd7ca12e8b115613fa365887978f9fb146c24" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">Intenta actualizar el puntero &lt;code&gt;Weak&lt;/code&gt; a un &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; , extendiendo la vida &amp;uacute;til del valor si tiene &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">Intenta esperar un valor en este receptor, devolviendo un error si el canal correspondiente ha colgado o si se alcanza la &lt;code&gt;deadline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">Intenta esperar un valor en este receptor, devolviendo un error si el canal correspondiente ha colgado o si espera m&amp;aacute;s del &lt;code&gt;timeout&lt;/code&gt; de espera .</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">Intenta esperar un valor en este receptor,devolviendo un error si el canal correspondiente se ha colgado.</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">Intenta escribir una memoria intermedia completa en este escritor.</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intenta escribir un b&amp;uacute;fer completo en este escritor. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intenta escribir un b&amp;uacute;fer completo en este escritor. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intenta escribir un b&amp;uacute;fer completo en este escritor. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intenta escribir un b&amp;uacute;fer completo en este escritor. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">Intenta escribir un buffer entero a partir de un determinado desplazamiento.</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Intenta escribir un b&amp;uacute;fer completo a partir de un desplazamiento determinado. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd154a661d834b07894c77674ab8ed918e6d062" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc422df0d6aeefc153e9d11191c7acdab0fee066" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef049b1e411811d76553b0e75329cbd0d79e8485" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59af638438e522a4fe5eaeba810e068e6c90b8b0" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6a58aa82ce87e3367d27cafec071fe08afba77" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">El atributo contiene el mismo meta-artículo más de una vez.</target>
        </trans-unit>
        <trans-unit id="645ef54c5f28a9cf578382e9466764d3ebe4899c" translate="yes" xml:space="preserve">
          <source>Attribute macros</source>
          <target state="translated">Macros de atributos</target>
        </trans-unit>
        <trans-unit id="1a7e3b192d591463acc213e348e2d3be95158e41" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859156ebbcd8a20df68582e72c9cb8ebb2f8d6d9" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">Las macros de atributos se definen mediante una &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n &lt;/a&gt;&lt;a href=&quot;visibility-and-privacy&quot;&gt;p&amp;uacute;blica&lt;/a&gt; con el &lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;proc_macro_attribute&lt;/code&gt; que tiene una firma de &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; . El primer &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; es el &amp;aacute;rbol de tokens delimitado que sigue al nombre del atributo, sin incluir los delimitadores externos. Si el atributo est&amp;aacute; escrito como un nombre de atributo &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; , el atributo TokenStream est&amp;aacute; vac&amp;iacute;o. El segundo &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; es el resto del &lt;a href=&quot;items&quot;&gt;elemento,&lt;/a&gt; incluidos otros &lt;a href=&quot;attributes&quot;&gt;atributos&lt;/a&gt; del &lt;a href=&quot;items&quot;&gt;elemento&lt;/a&gt; . El &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; devuelto reemplaza el &lt;a href=&quot;items&quot;&gt;elemento&lt;/a&gt; con un n&amp;uacute;mero arbitrario de&lt;a href=&quot;items&quot;&gt; elementos&lt;/a&gt; . Estas macros no pueden expandirse a la sintaxis que define nuevos &lt;code&gt;macro_rules&lt;/code&gt; macros de estilo .</target>
        </trans-unit>
        <trans-unit id="e9cdb4472ce392123fa434d8e8286aab92c7c80b" translate="yes" xml:space="preserve">
          <source>Attribute-like macros</source>
          <target state="translated">Macros de atributos</target>
        </trans-unit>
        <trans-unit id="59290a10bc07737a4a9b4b98cbfa7a104e8da35e" translate="yes" xml:space="preserve">
          <source>Attribute-like macros are similar to custom derive macros, but instead of generating code for the &lt;code&gt;derive&lt;/code&gt; attribute, they allow you to create new attributes. They&amp;rsquo;re also more flexible: &lt;code&gt;derive&lt;/code&gt; only works for structs and enums; attributes can be applied to other items as well, such as functions. Here&amp;rsquo;s an example of using an attribute-like macro: say you have an attribute named &lt;code&gt;route&lt;/code&gt; that annotates functions when using a web application framework:</source>
          <target state="translated">Las macros de tipo atributo son similares a las macros de derivaci&amp;oacute;n personalizadas, pero en lugar de generar c&amp;oacute;digo para el atributo de &lt;code&gt;derive&lt;/code&gt; , le permiten crear nuevos atributos. Tambi&amp;eacute;n son m&amp;aacute;s flexibles: &lt;code&gt;derive&lt;/code&gt; solo funciona para estructuras y enumeraciones; Los atributos tambi&amp;eacute;n se pueden aplicar a otros elementos, como funciones. Aqu&amp;iacute; hay un ejemplo del uso de una macro similar a un atributo: digamos que tiene un atributo llamado &lt;code&gt;route&lt;/code&gt; que anota funciones cuando usa un marco de aplicaci&amp;oacute;n web:</target>
        </trans-unit>
        <trans-unit id="ec087a512ee5c8fbe6233f1c1cc119ebd6524585" translate="yes" xml:space="preserve">
          <source>Attribute-like macros that define custom attributes usable on any item</source>
          <target state="translated">Macros de tipo atributo que definen atributos personalizados utilizables en cualquier elemento</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="873679be0cfb954acbd8355a7b353607aec111e8" translate="yes" xml:space="preserve">
          <source>Attributes can be classified into the following kinds:</source>
          <target state="translated">Los atributos pueden clasificarse en los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="f75246581fb116635159a5829418eadb80ff6d3d" translate="yes" xml:space="preserve">
          <source>Attributes may be applied to many things in the language:</source>
          <target state="translated">Los atributos pueden aplicarse a muchas cosas en el lenguaje:</target>
        </trans-unit>
        <trans-unit id="54528912cd579e0bc00be1a8a68e351287624bb1" translate="yes" xml:space="preserve">
          <source>Attributes on Implementations</source>
          <target state="translated">Atributos de las implementaciones</target>
        </trans-unit>
        <trans-unit id="37b3e9d71f1e2b7a16d851acde890909a1eeac05" translate="yes" xml:space="preserve">
          <source>Attributes on Modules</source>
          <target state="translated">Atributos de los módulos</target>
        </trans-unit>
        <trans-unit id="bd970fc906dcf4e6b3d5342f7f8f7b6b3fc07d29" translate="yes" xml:space="preserve">
          <source>Attributes on Statements</source>
          <target state="translated">Atributos de las declaraciones</target>
        </trans-unit>
        <trans-unit id="002821d69ecf6475cc851545267b8d3000e1ad75" translate="yes" xml:space="preserve">
          <source>Attributes on block expressions</source>
          <target state="translated">Atributos de las expresiones de bloque</target>
        </trans-unit>
        <trans-unit id="9c665fd3a622574987a78d02ed515c34731bae9e" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9724999b0840379dc53e44bc7f9fc3b9f933c5" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceeb23e9fab4cfc5da27d608e1b53f610954cf73" translate="yes" xml:space="preserve">
          <source>Attributes on extern blocks</source>
          <target state="translated">Atributos de los bloques externos</target>
        </trans-unit>
        <trans-unit id="2b100159215337704a6b1e09760f5eccf7526a5d" translate="yes" xml:space="preserve">
          <source>Attributes on extern function parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c13f89c0293ca7012e37e58c92591846eac3f7" translate="yes" xml:space="preserve">
          <source>Attributes on function parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed27ab14062c4e9a4e3408735f20ce008b94ed1f" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19964d112392f9f4c6dafbc3caa5ef3b3d5eb10" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cccaf98e2daf69778514e782644b524ef8bcdb7" translate="yes" xml:space="preserve">
          <source>Attributes on functions</source>
          <target state="translated">Atributos de las funciones</target>
        </trans-unit>
        <trans-unit id="05e9060a13a0e0d138adc8680df67a664480dcc8" translate="yes" xml:space="preserve">
          <source>Attributes on match arms</source>
          <target state="translated">Atributos de las armas de fósforo</target>
        </trans-unit>
        <trans-unit id="2af6ac2f621f1343b06367e7a182dd005ff55bf7" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d4e80c9597ea7a33de2f4472d2c8f5b6ac76e0" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4692270821bce03e7c9c56f2250b4d84c0ed4e73" translate="yes" xml:space="preserve">
          <source>Augments &lt;code&gt;AllocErr&lt;/code&gt; with a CapacityOverflow variant.</source>
          <target state="translated">Augments &lt;code&gt;AllocErr&lt;/code&gt; con una variante CapacityOverflow.</target>
        </trans-unit>
        <trans-unit id="18a0388aaf485c373d9fa2601ae76a1e2a8efdf4" translate="yes" xml:space="preserve">
          <source>Austin Group Bugzilla</source>
          <target state="translated">Grupo de Austin Bugzilla</target>
        </trans-unit>
        <trans-unit id="e84cdcfde23e335b70dccbea7484975e25932774" translate="yes" xml:space="preserve">
          <source>Auto Trait Implementations</source>
          <target state="translated">Implementación de Auto Trait</target>
        </trans-unit>
        <trans-unit id="3210ce5fd6c71ac203dc3858abcda035931c425a" translate="yes" xml:space="preserve">
          <source>Auto implementors</source>
          <target state="translated">Implementadores de automóviles</target>
        </trans-unit>
        <trans-unit id="883a358e80c549bb53d94b1393e3b00efd025f86" translate="yes" xml:space="preserve">
          <source>Auto traits</source>
          <target state="translated">Rasgos de auto</target>
        </trans-unit>
        <trans-unit id="907a84f140f8fccdc36e6967fab33354d93f68e0" translate="yes" xml:space="preserve">
          <source>Auto traits can also have negative implementations, shown as &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; in the standard library documentation, that override the automatic implementations. For example &lt;code&gt;*mut T&lt;/code&gt; has a negative implementation of &lt;code&gt;Send&lt;/code&gt;, and so &lt;code&gt;*mut T&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;, even if &lt;code&gt;T&lt;/code&gt; is. There is currently no stable way to specify additional negative implementations; they exist only in the standard library.</source>
          <target state="translated">Los rasgos autom&amp;aacute;ticos tambi&amp;eacute;n pueden tener implementaciones negativas, que se muestran como &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; en la documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar, que anulan las implementaciones autom&amp;aacute;ticas. Por ejemplo, &lt;code&gt;*mut T&lt;/code&gt; tiene una implementaci&amp;oacute;n negativa de &lt;code&gt;Send&lt;/code&gt; , por lo que &lt;code&gt;*mut T&lt;/code&gt; no es &lt;code&gt;Send&lt;/code&gt; , incluso si &lt;code&gt;T&lt;/code&gt; es. Actualmente no existe una forma estable de especificar implementaciones negativas adicionales; existen solo en la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="eed6125b479d147f9973b57bfcd959c6cdf11e7c" translate="yes" xml:space="preserve">
          <source>Auto traits cannot have methods or associated items. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">Los rasgos autom&amp;aacute;ticos no pueden tener m&amp;eacute;todos ni elementos asociados. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte el &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;RFC de caracter&amp;iacute;sticas incorporadas para participar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="589d3531f6899aa76d5a037b26ecc86cf31af6da" translate="yes" xml:space="preserve">
          <source>Auto traits may be added as an additional bound to any &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt;, even though normally only one trait is allowed. For instance, &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; is a valid type.</source>
          <target state="translated">Los rasgos autom&amp;aacute;ticos se pueden agregar como un v&amp;iacute;nculo adicional a cualquier &lt;a href=&quot;types/trait-object&quot;&gt;objeto de rasgo&lt;/a&gt; , aunque normalmente solo se permite un rasgo. Por ejemplo, &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; es un tipo v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="7ab019d8f27eff675f0469b46eedbbd5bc764f0c" translate="yes" xml:space="preserve">
          <source>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</source>
          <target state="translated">Los rasgos automáticos como el envío y la sincronización son una excepción a esta regla:es posible tener límites de un rasgo no construido,además de cualquier número de rasgos automáticos.Por ejemplo,lo siguiente se compila correctamente:</target>
        </trans-unit>
        <trans-unit id="291824a57cec52e3b37ba600a0c8891145191849" translate="yes" xml:space="preserve">
          <source>Auto-&lt;code&gt;deref&lt;/code&gt; is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent</source>
          <target state="translated">Auto- &lt;code&gt;deref&lt;/code&gt; no es deseable; por ejemplo, distinguir entre m&amp;eacute;todos en un puntero inteligente y el referente del puntero</target>
        </trans-unit>
        <trans-unit id="07a06ac20697a76a3d6c77f425115fda11438cdd" translate="yes" xml:space="preserve">
          <source>Automatic Formatting with &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</source>
          <target state="translated">Formateo autom&amp;aacute;tico con &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd22060c7b367de18d29110de1ffaa7a8381ad30" translate="yes" xml:space="preserve">
          <source>Available features</source>
          <target state="translated">Características disponibles</target>
        </trans-unit>
        <trans-unit id="67ac2af5490a5a8399786f2d57a2cb9f4e9a1f32" translate="yes" xml:space="preserve">
          <source>Await expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e627821b85e700b6a817bfb93d0fa75ca6938994" translate="yes" xml:space="preserve">
          <source>Await expressions are legal only within an &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt;, like an &lt;a href=&quot;../items/functions#async-functions&quot;&gt;&lt;code&gt;async fn&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;block-expr#async-blocks&quot;&gt;&lt;code&gt;async&lt;/code&gt; block&lt;/a&gt;. They operate on a &lt;a href=&quot;../../std/future/trait.future&quot;&gt;future&lt;/a&gt;. Their effect is to suspend the current computation until the given future is ready to produce a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bea30bca4696d831be0e14c1144f604b2efac9" translate="yes" xml:space="preserve">
          <source>Awesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.</source>
          <target state="translated">¡Impresionante! Ahora tenemos un simple servidor web en aproximadamente 40 líneas de código Rust que responde a una petición con una página de contenido y responde a todas las demás peticiones con una respuesta 404.</target>
        </trans-unit>
        <trans-unit id="799c6a1aafdeb5752f0a6da17b30526204336545" translate="yes" xml:space="preserve">
          <source>Awesome! With one tiny final tweak, we will finish the guessing game. Recall that the program is still printing the secret number. That worked well for testing, but it ruins the game. Let&amp;rsquo;s delete the &lt;code&gt;println!&lt;/code&gt; that outputs the secret number. Listing 2-6 shows the final code.</source>
          <target state="translated">&amp;iexcl;Incre&amp;iacute;ble! Con un peque&amp;ntilde;o ajuste final, terminaremos el juego de adivinanzas. Recuerde que el programa todav&amp;iacute;a est&amp;aacute; imprimiendo el n&amp;uacute;mero secreto. Eso funcion&amp;oacute; bien para las pruebas, pero arruina el juego. &amp;iexcl; &lt;code&gt;println!&lt;/code&gt; el println! que genera el n&amp;uacute;mero secreto. El listado 2-6 muestra el c&amp;oacute;digo final.</target>
        </trans-unit>
        <trans-unit id="358de401329e3394893b21243300f3a3bf6b4d17" translate="yes" xml:space="preserve">
          <source>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.</source>
          <target state="translated">Los B-Trees representan un compromiso fundamental entre la eficiencia de la cach&amp;eacute; y la minimizaci&amp;oacute;n de la cantidad de trabajo realizado en una b&amp;uacute;squeda. En teor&amp;iacute;a, un &amp;aacute;rbol de b&amp;uacute;squeda binario (BST) es la opci&amp;oacute;n &amp;oacute;ptima para un mapa ordenado, ya que un BST perfectamente equilibrado realiza la cantidad m&amp;iacute;nima te&amp;oacute;rica de comparaciones necesarias para encontrar un elemento (log &lt;sub&gt;2&lt;/sub&gt; n). Sin embargo, en la pr&amp;aacute;ctica, la forma en que se hace es &lt;em&gt;muy&lt;/em&gt; ineficaz para las arquitecturas inform&amp;aacute;ticas modernas. En particular, cada elemento se almacena en su propio nodo asignado individualmente al mont&amp;oacute;n. Esto significa que cada inserci&amp;oacute;n desencadena una asignaci&amp;oacute;n de almacenamiento din&amp;aacute;mico y cada comparaci&amp;oacute;n debe ser un error de cach&amp;eacute;. Dado que estas son dos cosas notablemente caras de hacer en la pr&amp;aacute;ctica, nos vemos obligados a al menos reconsiderar la estrategia BST.</target>
        </trans-unit>
        <trans-unit id="4ce046eb7e16ef9995c1ff852988df751464fa48" translate="yes" xml:space="preserve">
          <source>BIN_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;]</source>
          <target state="translated">BIN_DIGIT: [ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="93c309eceddcd432100b37d2f21aed97ad5516a1" translate="yes" xml:space="preserve">
          <source>BIN_LITERAL :</source>
          <target state="translated">BIN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="1ce23e42f8a0fadda89f03bff4138edc76257e9f" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT</source>
          <target state="translated">BLOCK_COMMENT</target>
        </trans-unit>
        <trans-unit id="54d41dd6d7f607cbfdbd93df26df009dd384ea37" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT :</source>
          <target state="translated">COMENTARIO_BLOQUEADO :</target>
        </trans-unit>
        <trans-unit id="46a2a0792f35fba20ff9af816bd7d67867d91ee5" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL</source>
          <target state="translated">BOOLEAN_LITERAL</target>
        </trans-unit>
        <trans-unit id="984b539364047c18d12aa2a5107f4ca7034f1745" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL :</source>
          <target state="translated">BOOLEANO_LITERAL :</target>
        </trans-unit>
        <trans-unit id="25ed99c15ff33b077d8ef4f89cfb12043f799e5c" translate="yes" xml:space="preserve">
          <source>BTreeMap</source>
          <target state="translated">BTreeMap</target>
        </trans-unit>
        <trans-unit id="14b812dd3cb5eae3767a2df53640bea358a44ec3" translate="yes" xml:space="preserve">
          <source>BTreeMap::append</source>
          <target state="translated">BTreeMap::append</target>
        </trans-unit>
        <trans-unit id="4439b2dd76bd007a7ee702af3eca0f027a45eb09" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow</source>
          <target state="translated">BTreeMap::borrow</target>
        </trans-unit>
        <trans-unit id="a411a7ebcb50db356ed987a9d5f1ea3e6fb40efd" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow_mut</source>
          <target state="translated">BTreeMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0e1837335635833d079465e2a07ece32097ef9ee" translate="yes" xml:space="preserve">
          <source>BTreeMap::clamp</source>
          <target state="translated">BTreeMap::clamp</target>
        </trans-unit>
        <trans-unit id="a5095900a69512f07d67a4318ed72ed754b7ec9a" translate="yes" xml:space="preserve">
          <source>BTreeMap::clear</source>
          <target state="translated">BTreeMap::clear</target>
        </trans-unit>
        <trans-unit id="d9dc0be9a162cd4c9a8d0d87ef461b431cc2996f" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone</source>
          <target state="translated">BTreeMap::clone</target>
        </trans-unit>
        <trans-unit id="b18aa414095cedffcf379ff71fa52f0f3e5a2e30" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_from</source>
          <target state="translated">BTreeMap::clone_from</target>
        </trans-unit>
        <trans-unit id="94cc1d51e045cecb444cb20cb07a89d16ef1abae" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_into</source>
          <target state="translated">BTreeMap::clone_into</target>
        </trans-unit>
        <trans-unit id="7fc5895f7f2221a66d3e8ff613cbb9e54a398512" translate="yes" xml:space="preserve">
          <source>BTreeMap::cmp</source>
          <target state="translated">BTreeMap::cmp</target>
        </trans-unit>
        <trans-unit id="10f80450d5f9791627fc6f70e8eea8d607e5abc1" translate="yes" xml:space="preserve">
          <source>BTreeMap::contains_key</source>
          <target state="translated">BTreeMap::contains_key</target>
        </trans-unit>
        <trans-unit id="237ebd61fd35b922ed92337aaeb092096989c551" translate="yes" xml:space="preserve">
          <source>BTreeMap::default</source>
          <target state="translated">BTreeMap::default</target>
        </trans-unit>
        <trans-unit id="67360895fa8faeb3288ff2a48f56ac5fb63f6cfa" translate="yes" xml:space="preserve">
          <source>BTreeMap::drop</source>
          <target state="translated">BTreeMap::drop</target>
        </trans-unit>
        <trans-unit id="e35986d9fdbf3de52b6c707270d8af046337a4b7" translate="yes" xml:space="preserve">
          <source>BTreeMap::entry</source>
          <target state="translated">BTreeMap::entry</target>
        </trans-unit>
        <trans-unit id="1fd856b6f3486469ed5b9716d4c0ef16fd26570a" translate="yes" xml:space="preserve">
          <source>BTreeMap::eq</source>
          <target state="translated">BTreeMap::eq</target>
        </trans-unit>
        <trans-unit id="2eb6b59d7803ce34a4aebcb1a5cebd29ebb2ace1" translate="yes" xml:space="preserve">
          <source>BTreeMap::extend</source>
          <target state="translated">BTreeMap::extend</target>
        </trans-unit>
        <trans-unit id="14a4894c2a33cba6f17b28aab882b15d8fa0507e" translate="yes" xml:space="preserve">
          <source>BTreeMap::fmt</source>
          <target state="translated">BTreeMap::fmt</target>
        </trans-unit>
        <trans-unit id="f8ff830626694a395da9bcdf07413636ef382d2a" translate="yes" xml:space="preserve">
          <source>BTreeMap::from</source>
          <target state="translated">BTreeMap::from</target>
        </trans-unit>
        <trans-unit id="40d5df351e6a78b82beed9049802e2600890cdef" translate="yes" xml:space="preserve">
          <source>BTreeMap::from_iter</source>
          <target state="translated">BTreeMap::from_iter</target>
        </trans-unit>
        <trans-unit id="42bc9380f48558951feaee861f324b3e97cc339c" translate="yes" xml:space="preserve">
          <source>BTreeMap::ge</source>
          <target state="translated">BTreeMap::ge</target>
        </trans-unit>
        <trans-unit id="fdc4bec6666f5d3bd604897331fbae31d76e02c5" translate="yes" xml:space="preserve">
          <source>BTreeMap::get</source>
          <target state="translated">BTreeMap::get</target>
        </trans-unit>
        <trans-unit id="10123fe58d4d51981db653bb17bb2c5bd1739f48" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_key_value</source>
          <target state="translated">BTreeMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="77ed844b0571d2308549c11d94f75218d5fc647d" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_mut</source>
          <target state="translated">BTreeMap::get_mut</target>
        </trans-unit>
        <trans-unit id="5aeca596bd768adcad438b3384e1977cf6475276" translate="yes" xml:space="preserve">
          <source>BTreeMap::gt</source>
          <target state="translated">BTreeMap::gt</target>
        </trans-unit>
        <trans-unit id="aef92c85a8fd215fe067e91d2cc54253d395041e" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash</source>
          <target state="translated">BTreeMap::hash</target>
        </trans-unit>
        <trans-unit id="cf9f5d8139a53420363c542bee60960cfdf4b73f" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash_slice</source>
          <target state="translated">BTreeMap::hash_slice</target>
        </trans-unit>
        <trans-unit id="9d0f58d76739deb0afae24d930afc89e886727c1" translate="yes" xml:space="preserve">
          <source>BTreeMap::index</source>
          <target state="translated">BTreeMap::index</target>
        </trans-unit>
        <trans-unit id="495b083c76694857a7d488aae7997ecc9b65b8fd" translate="yes" xml:space="preserve">
          <source>BTreeMap::insert</source>
          <target state="translated">BTreeMap::insert</target>
        </trans-unit>
        <trans-unit id="df183dd97d9b53936c9da9b18c544dcca3159f96" translate="yes" xml:space="preserve">
          <source>BTreeMap::into</source>
          <target state="translated">BTreeMap::into</target>
        </trans-unit>
        <trans-unit id="fc4dae35af80d2a787e9d9736c90c00c41315ce5" translate="yes" xml:space="preserve">
          <source>BTreeMap::into_iter</source>
          <target state="translated">BTreeMap::into_iter</target>
        </trans-unit>
        <trans-unit id="34464fef785cdf817cc72448c6950077bd889a22" translate="yes" xml:space="preserve">
          <source>BTreeMap::is_empty</source>
          <target state="translated">BTreeMap::is_empty</target>
        </trans-unit>
        <trans-unit id="f0cc7817b62e10040c3cb5b80461b8e39c5f0f79" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter</source>
          <target state="translated">BTreeMap::iter</target>
        </trans-unit>
        <trans-unit id="db8aca8da8288f53fcb308f1bc4fd2b4cacd2358" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter_mut</source>
          <target state="translated">BTreeMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="17e2b2189c6d71bc1225646a44b2dd0dedd8f47e" translate="yes" xml:space="preserve">
          <source>BTreeMap::keys</source>
          <target state="translated">BTreeMap::keys</target>
        </trans-unit>
        <trans-unit id="9d8ea9a92f24bfb8408ae08918cf32d255567986" translate="yes" xml:space="preserve">
          <source>BTreeMap::le</source>
          <target state="translated">BTreeMap::le</target>
        </trans-unit>
        <trans-unit id="69fcce80124f37da2a3264b3eb42f4416e80e515" translate="yes" xml:space="preserve">
          <source>BTreeMap::len</source>
          <target state="translated">BTreeMap::len</target>
        </trans-unit>
        <trans-unit id="9d226dd3e31bc04059d6780da00c779d71a0c07b" translate="yes" xml:space="preserve">
          <source>BTreeMap::lt</source>
          <target state="translated">BTreeMap::lt</target>
        </trans-unit>
        <trans-unit id="28cb2cc6fd2d128843e6d248dab95763d1010e94" translate="yes" xml:space="preserve">
          <source>BTreeMap::max</source>
          <target state="translated">BTreeMap::max</target>
        </trans-unit>
        <trans-unit id="e204c8d42ea76d6a7764ea9e58274fe5c3bb002d" translate="yes" xml:space="preserve">
          <source>BTreeMap::min</source>
          <target state="translated">BTreeMap::min</target>
        </trans-unit>
        <trans-unit id="b1f505e6c5b1bc5d067a0962eaa8081602c15a7a" translate="yes" xml:space="preserve">
          <source>BTreeMap::ne</source>
          <target state="translated">BTreeMap::ne</target>
        </trans-unit>
        <trans-unit id="553eafd890c40ffaf003fe540a734e36e0e18621" translate="yes" xml:space="preserve">
          <source>BTreeMap::new</source>
          <target state="translated">BTreeMap::new</target>
        </trans-unit>
        <trans-unit id="145a5aeffe19ab72f79646e0207cf635764ce346" translate="yes" xml:space="preserve">
          <source>BTreeMap::partial_cmp</source>
          <target state="translated">BTreeMap::partial_cmp</target>
        </trans-unit>
        <trans-unit id="db1a963168ea048f3f16233197ab263e60b2b507" translate="yes" xml:space="preserve">
          <source>BTreeMap::range</source>
          <target state="translated">BTreeMap::range</target>
        </trans-unit>
        <trans-unit id="3fee919f6744bdc9b2c87f1284d03bd737c587e9" translate="yes" xml:space="preserve">
          <source>BTreeMap::range_mut</source>
          <target state="translated">BTreeMap::range_mut</target>
        </trans-unit>
        <trans-unit id="f730581dfe02c1cd76fc7cd5f47e7e1ec7741713" translate="yes" xml:space="preserve">
          <source>BTreeMap::remove</source>
          <target state="translated">BTreeMap::remove</target>
        </trans-unit>
        <trans-unit id="a37cec31f9d8447344a2cb11b02572d5369eaecb" translate="yes" xml:space="preserve">
          <source>BTreeMap::split_off</source>
          <target state="translated">BTreeMap::split_off</target>
        </trans-unit>
        <trans-unit id="dd1d37326d92e085a2131397045e5968a461a29d" translate="yes" xml:space="preserve">
          <source>BTreeMap::to_owned</source>
          <target state="translated">BTreeMap::to_owned</target>
        </trans-unit>
        <trans-unit id="f4b12905aac1d13f63c54fa99e15b6d767c0949a" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_from</source>
          <target state="translated">BTreeMap::try_from</target>
        </trans-unit>
        <trans-unit id="8714974f74a34a38551f441ede21c0f7c7518766" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_into</source>
          <target state="translated">BTreeMap::try_into</target>
        </trans-unit>
        <trans-unit id="a562c087f2e1443045e2342f53c040d13fff0500" translate="yes" xml:space="preserve">
          <source>BTreeMap::type_id</source>
          <target state="translated">BTreeMap::type_id</target>
        </trans-unit>
        <trans-unit id="fef95975d5290dbd397d0e8018f6118b5b3445f8" translate="yes" xml:space="preserve">
          <source>BTreeMap::values</source>
          <target state="translated">BTreeMap::values</target>
        </trans-unit>
        <trans-unit id="b2e013070087a41fefec42e8c8812a309f157c48" translate="yes" xml:space="preserve">
          <source>BTreeMap::values_mut</source>
          <target state="translated">BTreeMap::values_mut</target>
        </trans-unit>
        <trans-unit id="529df1988796f2371c28af38a10631626e30c033" translate="yes" xml:space="preserve">
          <source>BTreeSet</source>
          <target state="translated">BTreeSet</target>
        </trans-unit>
        <trans-unit id="8863be2c232d70a5eeb4560459b4be5b2c0073a8" translate="yes" xml:space="preserve">
          <source>BTreeSet::append</source>
          <target state="translated">BTreeSet::append</target>
        </trans-unit>
        <trans-unit id="208528633622bb579ebc99572c1cd5b23c0ff3fe" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitand</source>
          <target state="translated">BTreeSet::bitand</target>
        </trans-unit>
        <trans-unit id="8c7f6d7d0bd709c67b308f34e3fdea1982987576" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitor</source>
          <target state="translated">BTreeSet::bitor</target>
        </trans-unit>
        <trans-unit id="b50a2f00b4df89c4fc2d8b38a2151e87a882ff0b" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitxor</source>
          <target state="translated">BTreeSet::bitxor</target>
        </trans-unit>
        <trans-unit id="cccc4bace80a38b5837fc997cc5c49754d796ac4" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow</source>
          <target state="translated">BTreeSet::borrow</target>
        </trans-unit>
        <trans-unit id="c3906f6d078061570593f2fe7b73fa2840328771" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow_mut</source>
          <target state="translated">BTreeSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4aa030ae00992ccd9a53652df9153409be56a2a2" translate="yes" xml:space="preserve">
          <source>BTreeSet::clamp</source>
          <target state="translated">BTreeSet::clamp</target>
        </trans-unit>
        <trans-unit id="7dbd4b9a7ec2f778cf457d4c27e677b1357aa7da" translate="yes" xml:space="preserve">
          <source>BTreeSet::clear</source>
          <target state="translated">BTreeSet::clear</target>
        </trans-unit>
        <trans-unit id="5b30f459964be9100787e5939f482cd8d7073397" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone</source>
          <target state="translated">BTreeSet::clone</target>
        </trans-unit>
        <trans-unit id="050795ce2f3842fb14df3b7b6623ddb813ac2ad6" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_from</source>
          <target state="translated">BTreeSet::clone_from</target>
        </trans-unit>
        <trans-unit id="53b99dc8a6c6498122bd0b00e8114abe2667c8af" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_into</source>
          <target state="translated">BTreeSet::clone_into</target>
        </trans-unit>
        <trans-unit id="de2ebfb73a4bfaed7ca14354db78235b93dbbcb9" translate="yes" xml:space="preserve">
          <source>BTreeSet::cmp</source>
          <target state="translated">BTreeSet::cmp</target>
        </trans-unit>
        <trans-unit id="3e582a8879cbba7048152fe7baf6d319ff38bc16" translate="yes" xml:space="preserve">
          <source>BTreeSet::contains</source>
          <target state="translated">BTreeSet::contains</target>
        </trans-unit>
        <trans-unit id="21aa5487bfe6b638ff9a362eaa67cb633fc82867" translate="yes" xml:space="preserve">
          <source>BTreeSet::default</source>
          <target state="translated">BTreeSet::default</target>
        </trans-unit>
        <trans-unit id="d7c44959c458f0838dfab77ed6b6f2add8735a14" translate="yes" xml:space="preserve">
          <source>BTreeSet::difference</source>
          <target state="translated">BTreeSet::difference</target>
        </trans-unit>
        <trans-unit id="16f9dc4e686355d372b64a80e877507f0084b34a" translate="yes" xml:space="preserve">
          <source>BTreeSet::eq</source>
          <target state="translated">BTreeSet::eq</target>
        </trans-unit>
        <trans-unit id="9edee760d67dfee35cacd64d97c0b93bcecc3eb7" translate="yes" xml:space="preserve">
          <source>BTreeSet::extend</source>
          <target state="translated">BTreeSet::extend</target>
        </trans-unit>
        <trans-unit id="afc2d0e53bf4c5f63abce2f83b8f542897205aac" translate="yes" xml:space="preserve">
          <source>BTreeSet::fmt</source>
          <target state="translated">BTreeSet::fmt</target>
        </trans-unit>
        <trans-unit id="50633916fcf03b37e42d17b8960dc21b40ef24a7" translate="yes" xml:space="preserve">
          <source>BTreeSet::from</source>
          <target state="translated">BTreeSet::from</target>
        </trans-unit>
        <trans-unit id="caf6d0db82051ce20ec56dd44cb0a17ec0b98d23" translate="yes" xml:space="preserve">
          <source>BTreeSet::from_iter</source>
          <target state="translated">BTreeSet::from_iter</target>
        </trans-unit>
        <trans-unit id="be2acc08fadae340b24bbbb5601dcd11b43af4ff" translate="yes" xml:space="preserve">
          <source>BTreeSet::ge</source>
          <target state="translated">BTreeSet::ge</target>
        </trans-unit>
        <trans-unit id="eebfcd72f45c81fa6bcc82833412cbba7e8dc9f6" translate="yes" xml:space="preserve">
          <source>BTreeSet::get</source>
          <target state="translated">BTreeSet::get</target>
        </trans-unit>
        <trans-unit id="692fcfa52c7940ed1e980094be254853ea4f2c35" translate="yes" xml:space="preserve">
          <source>BTreeSet::gt</source>
          <target state="translated">BTreeSet::gt</target>
        </trans-unit>
        <trans-unit id="0546ef8f63c560e2610c71f5ad1ae889cfa00795" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash</source>
          <target state="translated">BTreeSet::hash</target>
        </trans-unit>
        <trans-unit id="4f6fe8cde85490c116cbac4ed558e1916281d86a" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash_slice</source>
          <target state="translated">BTreeSet::hash_slice</target>
        </trans-unit>
        <trans-unit id="eda956eff955ffd9727eb53f2bf7e0715817c65d" translate="yes" xml:space="preserve">
          <source>BTreeSet::insert</source>
          <target state="translated">BTreeSet::insert</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
