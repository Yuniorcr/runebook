<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">La conexión fue abortada (terminada)por el servidor remoto.</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">La conexión fue rechazada por el servidor remoto.</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">La conexión fue restablecida por el servidor remoto.</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">La conexi&amp;oacute;n se cerrar&amp;aacute; cuando se elimine el valor. Las partes de lectura y escritura de la conexi&amp;oacute;n tambi&amp;eacute;n se pueden apagar individualmente con el m&amp;eacute;todo de &lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee6719cfaf61adca10461f2b171bde13e23a4a41" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">El concepto de funci&amp;oacute;n de contras se ha abierto camino hacia una jerga de programaci&amp;oacute;n funcional m&amp;aacute;s general: &amp;ldquo;cons &lt;em&gt;x&lt;/em&gt; sobre &lt;em&gt;y&lt;/em&gt; &amp;rdquo; significa informalmente construir una nueva instancia de contenedor colocando el elemento &lt;em&gt;x&lt;/em&gt; al comienzo de este nuevo contenedor, seguido del contenedor &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">El contenido de &lt;em&gt;src / lib.rs&lt;/em&gt; debe tener las firmas que se muestran en el Listado 12-13 (hemos omitido los cuerpos de las funciones por brevedad). Tenga en cuenta que esto no se compilar&amp;aacute; hasta que modifiquemos &lt;em&gt;src / main.rs&lt;/em&gt; en el Listado 12-14.</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">El contenido del archivo &lt;em&gt;src / lib.rs&lt;/em&gt; en su biblioteca de &lt;code&gt;adder&lt;/code&gt; debe verse como el Listado 11-1.</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">El contenido de la repetición debe ser capaz de seguir lo que viene antes,y lo que viene después debe ser capaz de seguir el contenido de la repetición.</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">El contenido de la regresado &lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; son &lt;strong&gt;no&lt;/strong&gt; coherente en plataformas Unix. El rasgo &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; contiene las abstracciones cruzadas de Unix contenidas en la estad&amp;iacute;stica en bruto.</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">La conversi&amp;oacute;n asigna en el mont&amp;oacute;n y mueve &lt;code&gt;t&lt;/code&gt; de la pila a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">La conversi&amp;oacute;n consume &lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; y elimina el byte NUL de terminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">La conversi&amp;oacute;n consume &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; y elimina el byte NUL de terminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">La conversión copia los datos,e incluye una asignación en el montón.</target>
        </trans-unit>
        <trans-unit id="cbdea02b60597ccd54b5d9dbad9b3681336b3420" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;, which is a handle for waking up the current task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">El m&amp;eacute;todo central del futuro, la &lt;code&gt;poll&lt;/code&gt; , &lt;em&gt;intenta&lt;/em&gt; resolver el futuro en un valor final. Este m&amp;eacute;todo no se bloquea si el valor no est&amp;aacute; listo. En cambio, la tarea actual est&amp;aacute; programada para que se active cuando sea posible avanzar m&amp;aacute;s al &lt;code&gt;poll&lt;/code&gt; nuevamente. El &lt;code&gt;context&lt;/code&gt; o pasado al m&amp;eacute;todo de &lt;code&gt;poll&lt;/code&gt; puede proporcionar un &lt;code&gt;Waker&lt;/code&gt; , que es un identificador para despertar la tarea actual.</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">El n&amp;uacute;cleo del error indica que hay &lt;em&gt;tipos&lt;/em&gt; que no &lt;em&gt;coinciden&lt;/em&gt; . El &amp;oacute;xido tiene un sistema de tipo est&amp;aacute;tico fuerte. Sin embargo, tambi&amp;eacute;n tiene inferencia de tipos. Cuando escribimos &lt;code&gt;let mut guess = String::new()&lt;/code&gt; , Rust pudo inferir que la &lt;code&gt;guess&lt;/code&gt; deber&amp;iacute;a ser una &lt;code&gt;String&lt;/code&gt; y no nos oblig&amp;oacute; a escribir el tipo. El &lt;code&gt;secret_number&lt;/code&gt; , por otro lado, es un tipo de n&amp;uacute;mero. Algunos tipos de n&amp;uacute;meros pueden tener un valor entre 1 y 100: &lt;code&gt;i32&lt;/code&gt; , un n&amp;uacute;mero de 32 bits; &lt;code&gt;u32&lt;/code&gt; , un n&amp;uacute;mero de 32 bits sin signo; &lt;code&gt;i64&lt;/code&gt; , un n&amp;uacute;mero de 64 bits; as&amp;iacute; como otros. Rust tiene por defecto un &lt;code&gt;i32&lt;/code&gt; , que es el tipo de &lt;code&gt;secret_number&lt;/code&gt; a menos que agregue informaci&amp;oacute;n de tipo en otro lugar que har&amp;iacute;a que Rust infiera un tipo num&amp;eacute;rico diferente. La raz&amp;oacute;n del error es que Rust no puede comparar una cadena y un tipo de n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">El núcleo primitivo para la mutabilidad interior en el óxido.</target>
        </trans-unit>
        <trans-unit id="e23a80c74457fb7f3e04241567981840f6b6a5f0" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt;. The corresponding const implementations are in &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">Las definiciones correspondientes se encuentran en &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46698ed84aa8c683839a27c0dd70bde9fa62d21c" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Arc&lt;/code&gt; is not consumed. The pointer is valid for as long as there are strong counts in the &lt;code&gt;Arc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f706694dca621192d20fdc480b2fbc8fb70f49" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Rc&lt;/code&gt; is not consumed. The pointer is valid for as long there are strong counts in the &lt;code&gt;Rc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">El nombre de la caja no debe estar vac&amp;iacute;o y solo debe contener caracteres &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;alfanum&amp;eacute;ricos Unicode&lt;/a&gt; o &lt;code&gt;-&lt;/code&gt; (U + 002D).</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">El mapa creado tiene la capacidad inicial predeterminada.</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">El algoritmo actual es un tipo de fusi&amp;oacute;n iterativo y adaptativo inspirado en &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt; . Est&amp;aacute; dise&amp;ntilde;ado para ser muy r&amp;aacute;pido en los casos en que el segmento est&amp;aacute; casi ordenado o consta de dos o m&amp;aacute;s secuencias ordenadas concatenadas una tras otra.</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">El algoritmo actual se basa en la clasificaci&amp;oacute;n &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;r&amp;aacute;pida que derrota&lt;/a&gt; a los patrones de Orson Peters, que combina el caso promedio r&amp;aacute;pido de clasificaci&amp;oacute;n r&amp;aacute;pida aleatoria con el peor caso r&amp;aacute;pido de clasificaci&amp;oacute;n en pilas, al tiempo que logra un tiempo lineal en los cortes con ciertos patrones. Utiliza cierta aleatorizaci&amp;oacute;n para evitar casos degenerados, pero con una semilla fija para proporcionar siempre un comportamiento determinista.</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El algoritmo actual se basa en la parte de selecci&amp;oacute;n r&amp;aacute;pida del mismo algoritmo de &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; r&amp;aacute;pida utilizado para sort_unstable .</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">El cursor de archivo actual no se ve afectado por esta función.</target>
        </trans-unit>
        <trans-unit id="b3777ab23f3b1144c9a96d550ee493d6bc6e2d44" translate="yes" xml:space="preserve">
          <source>The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">La ruta actual de los módulos puede ser pensada como la jerarquía de módulos que llevan de vuelta a la raíz de la caja.El primer componente de la ruta devuelta es el nombre de la caja que se está compilando actualmente.</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">El proceso actual no tiene los derechos de permiso para acceder &lt;code&gt;from&lt;/code&gt; o escribir &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9c6f166ff606296d138016ea8392f66f7ed63a" translate="yes" xml:space="preserve">
          <source>The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">La versi&amp;oacute;n actual del preludio (versi&amp;oacute;n 1) vive en &lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt; y reexporta lo siguiente.</target>
        </trans-unit>
        <trans-unit id="c9ba6afb3853703b17e8a712fa55252cfe708a67" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912528c0cfbd7646c08850f1e407245a6bf7145e" translate="yes" xml:space="preserve">
          <source>The cursor is pointing to the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">Los datos no se pudieron enviar en &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; porque requerir&amp;iacute;a que el destinatario se bloquee para enviar los datos.</target>
        </trans-unit>
        <trans-unit id="caac8e332d6bed98dbe6a446c232bbf7ded49130" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">Los miembros de datos que expone este rasgo corresponden a los miembros de la estructura &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">Se puede acceder a los datos protegidos por el mutex a trav&amp;eacute;s de esta protecci&amp;oacute;n a trav&amp;eacute;s de sus implementaciones &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">Los datos que el proceso escribió para stderr.</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">Los datos que el proceso escribió a stdout.</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;another_function&lt;/code&gt; tiene un par&amp;aacute;metro llamado &lt;code&gt;x&lt;/code&gt; . El tipo de &lt;code&gt;x&lt;/code&gt; se especifica como &lt;code&gt;i32&lt;/code&gt; . Cuando se pasa &lt;code&gt;5&lt;/code&gt; a otra &lt;code&gt;another_function&lt;/code&gt; , el &lt;code&gt;println!&lt;/code&gt; macro pone &lt;code&gt;5&lt;/code&gt; donde el par de llaves estaban en la cadena de formato.</target>
        </trans-unit>
        <trans-unit id="f3e2b77707e4042bb7d326cf080f9fda22d6fd02" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag (see below) is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">El &lt;a href=&quot;#fillalignment&quot;&gt;relleno / alineaci&amp;oacute;n&lt;/a&gt; predeterminado para los no num&amp;eacute;ricos es un espacio y est&amp;aacute; alineado a la izquierda. Los valores predeterminados para los formateadores num&amp;eacute;ricos tambi&amp;eacute;n son un espacio pero con alineaci&amp;oacute;n a la derecha. Si se especifica la bandera &lt;code&gt;0&lt;/code&gt; para n&amp;uacute;meros, entonces el car&amp;aacute;cter de relleno impl&amp;iacute;cito es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; predeterminado utilizado por &lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El comportamiento predeterminado de esta funci&amp;oacute;n es imprimir un mensaje de error est&amp;aacute;ndar y abortar el proceso. Se puede reemplazar con &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">El tipo gen&amp;eacute;rico predeterminado en este c&amp;oacute;digo est&amp;aacute; dentro del rasgo &lt;code&gt;Add&lt;/code&gt; . Aqu&amp;iacute; est&amp;aacute; su definici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">El algoritmo hash predeterminado es actualmente SipHash 1-3, aunque est&amp;aacute; sujeto a cambios en cualquier momento en el futuro. Si bien su rendimiento es muy competitivo para claves de tama&amp;ntilde;o mediano, otros algoritmos de hash lo superar&amp;aacute;n para claves peque&amp;ntilde;as como n&amp;uacute;meros enteros y claves grandes como cadenas largas, aunque esos algoritmos normalmente &lt;em&gt;no&lt;/em&gt; proteger&amp;aacute;n contra ataques como HashDoS.</target>
        </trans-unit>
        <trans-unit id="80e587164750efd5907b562bcc2c0ec8621ca1dc" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Las llamadas de implementaci&amp;oacute;n predeterminadas &lt;code&gt;read&lt;/code&gt; con el primer b&amp;uacute;fer no vac&amp;iacute;o proporcionado, o uno vac&amp;iacute;o si no existe.</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Las llamadas de implementaci&amp;oacute;n predeterminadas &lt;code&gt;write&lt;/code&gt; con el primer b&amp;uacute;fer no vac&amp;iacute;o proporcionado o uno vac&amp;iacute;o si no existe ninguno.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">La implementaci&amp;oacute;n predeterminada devuelve &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; que es correcta para cualquier iterador.</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">La implementación por defecto devuelve un inicializador que pondrá a cero los buffers.</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">Las implementaciones predeterminadas devuelven &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; para indicar una ejecuci&amp;oacute;n exitosa. En caso de falla, se devuelve &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">El valor por defecto se elige con un sesgo hacia la producción de literales que son legales en una variedad de idiomas,incluyendo C++11 y otros idiomas similares de la familia C.Las reglas exactas son:</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">El asignador de memoria por defecto proporcionado por el sistema operativo.</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">El tamaño de pila por defecto para los hilos engendrados es de 2 MiB,aunque este tamaño de pila en particular está sujeto a cambios en el futuro.Hay dos maneras de especificar manualmente el tamaño de pila para los hilos engendrados:</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">La definici&amp;oacute;n de NT complejos merece alguna justificaci&amp;oacute;n. SEP_SET (M) define la posibilidad de que el separador pueda ser un primer token v&amp;aacute;lido para M, lo que ocurre cuando hay un separador definido y el fragmento repetido puede estar vac&amp;iacute;o. ALPHA_SET (M) define la posibilidad de que el NT complejo pueda estar vac&amp;iacute;o, lo que significa que los primeros tokens v&amp;aacute;lidos de M son los de las siguientes secuencias &lt;code&gt;&amp;alpha;&lt;/code&gt; del &amp;aacute;rbol de tokens . Esto ocurre cuando &lt;code&gt;\*&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; se utiliza, en cuyo caso podr&amp;iacute;a haber cero repeticiones. En teor&amp;iacute;a, esto tambi&amp;eacute;n podr&amp;iacute;a ocurrir si se usara &lt;code&gt;+&lt;/code&gt; con un fragmento repetido potencialmente vac&amp;iacute;o, pero esto est&amp;aacute; prohibido por el tercer invariante.</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">La definici&amp;oacute;n de &lt;code&gt;Config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">El operador de la desreferenciación</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">El comportamiento deseado de la funci&amp;oacute;n &lt;code&gt;generate_workout&lt;/code&gt; es verificar primero si el usuario desea un entrenamiento de baja intensidad (indicado por un n&amp;uacute;mero menor que 25) o un entrenamiento de alta intensidad (un n&amp;uacute;mero de 25 o mayor).</target>
        </trans-unit>
        <trans-unit id="f11d06267e33f3ae0370e1b473dace96a1d49d65" translate="yes" xml:space="preserve">
          <source>The destructor of a type &lt;code&gt;T&lt;/code&gt; consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">El destructor de un tipo consiste en</target>
        </trans-unit>
        <trans-unit id="c9c60944e1a21001c2063c93ac3b0f4cb46946e2" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">El destructor de la estructura no debe sacar los campos estructurales de su argumento. Este es el punto exacto en el que se cri&amp;oacute; en la &lt;a href=&quot;#drop-implementation&quot;&gt;secci&amp;oacute;n anterior&lt;/a&gt; : &lt;code&gt;drop&lt;/code&gt; toma &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , pero la estructura (y, por tanto, sus campos) podr&amp;iacute;a haber sido fijado antes. Debe garantizar que no mueva un campo dentro de su implementaci&amp;oacute;n de &lt;code&gt;Drop&lt;/code&gt; . En particular, como se explic&amp;oacute; anteriormente, esto significa que su estructura &lt;em&gt;no&lt;/em&gt; debe ser &lt;code&gt;#[repr(packed)]&lt;/code&gt; . Consulte esa secci&amp;oacute;n para saber c&amp;oacute;mo escribir &lt;code&gt;drop&lt;/code&gt; de una manera que el compilador pueda ayudarlo a no romper accidentalmente la fijaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">La diferencia entre 'el preludio' y estos otros preludios es que no se &lt;code&gt;use&lt;/code&gt; autom&amp;aacute;ticamente 'd, y deben importarse manualmente. Esto sigue siendo m&amp;aacute;s f&amp;aacute;cil que importar todos sus componentes constituyentes.</target>
        </trans-unit>
        <trans-unit id="505a24f6c966bf30ebbdd0623555d0248f90c11b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;macro.unimplemented&quot;&gt;&lt;code&gt;unimplemented!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;todo!&lt;/code&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03297ced74ba958f935a37ee67580ef54eeb9a79" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;unimplemented!&lt;/code&gt; and &lt;a href=&quot;macro.todo&quot;&gt;&lt;code&gt;todo!&lt;/code&gt;&lt;/a&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">La diferencia es que cuando usamos gen&amp;eacute;ricos, como en el Listado 19-13, debemos anotar los tipos en cada implementaci&amp;oacute;n; debido a que tambi&amp;eacute;n podemos implementar &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; o cualquier otro tipo, podr&amp;iacute;amos tener m&amp;uacute;ltiples implementaciones de &lt;code&gt;Iterator&lt;/code&gt; para &lt;code&gt;Counter&lt;/code&gt; . En otras palabras, cuando un rasgo tiene un par&amp;aacute;metro gen&amp;eacute;rico, se puede implementar para un tipo varias veces, cambiando los tipos concretos de los par&amp;aacute;metros de tipo gen&amp;eacute;rico cada vez. Cuando usemos el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo en &lt;code&gt;Counter&lt;/code&gt; , tendr&amp;iacute;amos que proporcionar anotaciones de tipo para indicar qu&amp;eacute; implementaci&amp;oacute;n de &lt;code&gt;Iterator&lt;/code&gt; queremos usar.</target>
        </trans-unit>
        <trans-unit id="5d4f5e1a47f10d66452650a5f161fd164ebd410d" translate="yes" xml:space="preserve">
          <source>The differences about paths and the &lt;code&gt;use&lt;/code&gt; keyword between the 2015 and 2018 editions can also be found in the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">El comportamiento diferente de los archivos en el directorio de &lt;em&gt;pruebas&lt;/em&gt; es m&amp;aacute;s notable cuando tiene un conjunto de funciones auxiliares que ser&amp;iacute;an &amp;uacute;tiles en varios archivos de prueba de integraci&amp;oacute;n e intenta seguir los pasos de la secci&amp;oacute;n &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&quot;Separaci&amp;oacute;n de m&amp;oacute;dulos en archivos diferentes&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 7 para extraerlos en un m&amp;oacute;dulo com&amp;uacute;n. Por ejemplo, si creamos &lt;em&gt;tests / common.rs&lt;/em&gt; y colocamos una funci&amp;oacute;n llamada &lt;code&gt;setup&lt;/code&gt; en &amp;eacute;l, podemos agregar un c&amp;oacute;digo a la &lt;code&gt;setup&lt;/code&gt; que queremos llamar desde m&amp;uacute;ltiples funciones de prueba en m&amp;uacute;ltiples archivos de prueba:</target>
        </trans-unit>
        <trans-unit id="d5be1c02c26fe5ef598a5696a274160d696e7977" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">Los directorios y archivos utilizados para cargar m&amp;oacute;dulos de archivos externos se pueden influir con el atributo de &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">El directorio no está vacío.</target>
        </trans-unit>
        <trans-unit id="8e9718c5436468359091854f47e29ace6b258c73" translate="yes" xml:space="preserve">
          <source>The discriminant enum from the example &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;earlier&lt;/a&gt; then becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">El discriminante de una variante del enum puede cambiar si cambia la definición del enum.El discriminante de una variante no cambiará entre compilaciones con el mismo compilador.</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">La distancia que se encuentra en los límites no puede depender de &quot;envolver&quot; el espacio de direcciones.</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">La distancia entre los punteros, &lt;strong&gt;en bytes&lt;/strong&gt; , no puede desbordar un &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">La distancia entre los punteros, en bytes, debe ser un m&amp;uacute;ltiplo exacto del tama&amp;ntilde;o de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de divisi&amp;oacute;n &lt;code&gt;/=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">El operador de divisi&amp;oacute;n &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">La documentaci&amp;oacute;n de esta palabra clave &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;a&amp;uacute;n no&lt;/a&gt; est&amp;aacute; completa . &amp;iexcl;Solicitudes de extracci&amp;oacute;n bienvenidas!</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">El doble signo de dos puntos ( &lt;code&gt;::&lt;/code&gt; &lt;code&gt;string_from&lt;/code&gt; es un operador que nos permite asignar un espacio de nombres a esta funci&amp;oacute;n &lt;code&gt;from&lt;/code&gt; en particular bajo el tipo &lt;code&gt;String&lt;/code&gt; en lugar de usar alg&amp;uacute;n tipo de nombre como string_from . Discutiremos esta sintaxis m&amp;aacute;s en la secci&amp;oacute;n &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&quot;Sintaxis del m&amp;eacute;todo&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 5 y cuando hablemos sobre el espacio de nombres con m&amp;oacute;dulos en &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&quot;Rutas para hacer referencia a un elemento en el &amp;aacute;rbol de m&amp;oacute;dulos&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 7.</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">La desventaja de usar expresiones &lt;code&gt;if let&lt;/code&gt; es que el compilador no verifica la exhaustividad, mientras que con las expresiones &lt;code&gt;match&lt;/code&gt; s&amp;iacute; lo hace. Si omitimos el &amp;uacute;ltimo bloque &lt;code&gt;else&lt;/code&gt; y por lo tanto no manejamos algunos casos, el compilador no nos alertar&amp;iacute;a del posible error l&amp;oacute;gico.</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">La desventaja de usar esta t&amp;eacute;cnica es que &lt;code&gt;Wrapper&lt;/code&gt; es un tipo nuevo, por lo que no tiene los m&amp;eacute;todos del valor que tiene. Tendr&amp;iacute;amos que implementar todos los m&amp;eacute;todos de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directamente en &lt;code&gt;Wrapper&lt;/code&gt; de manera que los m&amp;eacute;todos se deleguen en &lt;code&gt;self.0&lt;/code&gt; , lo que nos permitir&amp;iacute;a tratar a &lt;code&gt;Wrapper&lt;/code&gt; exactamente como un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Si quisi&amp;eacute;ramos que el nuevo tipo tuviera todos los m&amp;eacute;todos que tiene el tipo interno, implementar el rasgo &lt;code&gt;Deref&lt;/code&gt; (discutido en el Cap&amp;iacute;tulo 15 en la secci&amp;oacute;n &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&quot;Tratar los punteros inteligentes como referencias regulares con el rasgo &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; ) en el &lt;code&gt;Wrapper&lt;/code&gt; devolver el tipo interno ser&amp;iacute;a una soluci&amp;oacute;n. Si no queremos que el tipo &lt;code&gt;Wrapper&lt;/code&gt; tenga todos los m&amp;eacute;todos del tipo interno, por ejemplo, para restringir el comportamiento del tipo &lt;code&gt;Wrapper&lt;/code&gt; , tendr&amp;iacute;amos que implementar solo los m&amp;eacute;todos que deseamos manualmente.</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">La desventaja de implementar una macro en lugar de una funci&amp;oacute;n es que las definiciones de macro son m&amp;aacute;s complejas que las definiciones de funciones porque est&amp;aacute; escribiendo c&amp;oacute;digo Rust que escribe c&amp;oacute;digo Rust. Debido a esta indirecta, las definiciones de macros son generalmente m&amp;aacute;s dif&amp;iacute;ciles de leer, comprender y mantener que las definiciones de funciones.</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">La duración de un microsegundo.</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">La duración de un milisegundo.</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">La duración de un nanosegundo.</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">La duración de un segundo.</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">La soluci&amp;oacute;n m&amp;aacute;s f&amp;aacute;cil es reescribir su cierre en una funci&amp;oacute;n de nivel superior o en un m&amp;eacute;todo. En algunos casos, tambi&amp;eacute;n puede hacer que su cierre se llame a s&amp;iacute; mismo capturando un objeto &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; o un puntero &lt;code&gt;fn()&lt;/code&gt; que se refiera a s&amp;iacute; mismo. Eso est&amp;aacute; permitido, ya que el cierre se invocar&amp;iacute;a a s&amp;iacute; mismo mediante una llamada virtual y, por lo tanto, no hace referencia directamente a su propio &lt;em&gt;tipo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashMap&lt;/code&gt; con un tipo de clave personalizado es derivar &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashMap&lt;/code&gt; con un tipo de clave personalizado es derivar &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashSet&lt;/code&gt; con un tipo personalizado es derivar &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , esto en el futuro estar&amp;aacute; impl&amp;iacute;cito en la &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashSet&lt;/code&gt; con un tipo personalizado es derivar &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , esto en el futuro estar&amp;aacute; impl&amp;iacute;cito en la &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">El rango de elementos se elimina aunque el iterador no se consuma hasta el final.</target>
        </trans-unit>
        <trans-unit id="857f1367d5858bf310bc19ad475cfec76822e623" translate="yes" xml:space="preserve">
          <source>The element that was removed is returned, and the cursor is moved to point to the next element in the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">Los elementos se eliminan en un orden arbitrario.</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">Los elementos en &lt;code&gt;old_len..new_len&lt;/code&gt; deben inicializarse.</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">Los elementos de una &lt;a href=&quot;types/array&quot;&gt;matriz&lt;/a&gt; o un &lt;a href=&quot;types/array&quot;&gt;segmento propio&lt;/a&gt; se eliminan del primer elemento al &amp;uacute;ltimo. *</target>
        </trans-unit>
        <trans-unit id="1e3e69cc26857f9c1293b40c529b047e54164338" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9bb19de05cfdf90da669db74c8f4ff87b16d5" translate="yes" xml:space="preserve">
          <source>The elements yielded by &lt;code&gt;DoubleEndedIterator&lt;/code&gt;'s methods may differ from the ones yielded by &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;'s methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">Las reglas de elisi&amp;oacute;n no proporcionan una inferencia completa. Si Rust aplica las reglas de manera determinista, pero a&amp;uacute;n existe ambig&amp;uuml;edad en cuanto a la duraci&amp;oacute;n de las referencias, el compilador no adivinar&amp;aacute; cu&amp;aacute;l deber&amp;iacute;a ser la duraci&amp;oacute;n de las referencias restantes. En este caso, en lugar de adivinar, el compilador le dar&amp;aacute; un error que puede resolver agregando las anotaciones de por vida que especifican c&amp;oacute;mo se relacionan las referencias entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">Toda la expresi&amp;oacute;n usa los valores dados para los campos que se especificaron y mueve o copia los campos restantes de la expresi&amp;oacute;n base. Al igual que con todas las expresiones de estructura, todos los campos de la estructura deben estar &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibles&lt;/a&gt; , incluso aquellos que no se nombran expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">El nombre completo del archivo si el nombre del archivo comienza con &lt;code&gt;.&lt;/code&gt; y no tiene otro &lt;code&gt;.&lt;/code&gt; s dentro;</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">El nombre completo del archivo si no hay ning&amp;uacute;n &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3fa274546f438640798ab62aae39ac18398db5cc" translate="yes" xml:space="preserve">
          <source>The entire function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5d709e7f69a77cb8061cae38e47a941e97332f" translate="yes" xml:space="preserve">
          <source>The entire function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c15c39c685d0906fec325e3d5c2bea1c6eb708a" translate="yes" xml:space="preserve">
          <source>The entire function scope is the outer most scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">Todo el mapa hash es gen&amp;eacute;rico sobre un tipo de clave &lt;code&gt;K&lt;/code&gt; . Debido a que estas claves se almacenan con el mapa hash, este tipo debe poseer los datos de la clave. Al insertar un par clave-valor, el mapa se da un ejemplo &lt;code&gt;K&lt;/code&gt; y necesita encontrar el cubo de hash correcto y compruebe si la memoria ya est&amp;aacute; presente sobre la base de que &lt;code&gt;K&lt;/code&gt; . Por lo tanto, requiere &lt;code&gt;K: Hash + Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0297c1c788a21e67f6b7fde15406ec3888485937" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d250d768cfabd095635656557072ab76a1e3cbad" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects. See &lt;a href=&quot;#incorrect-usage&quot;&gt;below&lt;/a&gt; for an example incorrectly not taking this into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97dea0260f138033ef7cf2f5ca57a634d6eea616" translate="yes" xml:space="preserve">
          <source>The entry point of the program was marked as &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">El error y la nota cuentan la historia: las cadenas de Rust no admiten la indexaci&amp;oacute;n. &amp;iquest;Pero por qu&amp;eacute; no? Para responder a esa pregunta, debemos analizar c&amp;oacute;mo Rust almacena cadenas en la memoria.</target>
        </trans-unit>
        <trans-unit id="41a72aa86a9d9e55bed7f9841f1b9fdc25696e6c" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals and on numeric bindings without an identified concrete type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">El error se produce en los literales numéricos:</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">El error indica que Rust esperaba un &lt;code&gt;bool&lt;/code&gt; pero obtuvo un n&amp;uacute;mero entero. A diferencia de lenguajes como Ruby y JavaScript, Rust no intentar&amp;aacute; convertir autom&amp;aacute;ticamente los tipos no booleanos en booleanos. Debe ser expl&amp;iacute;cito y siempre proporcionar &lt;code&gt;if&lt;/code&gt; con un booleano como condici&amp;oacute;n. Si queremos que el bloque de c&amp;oacute;digo &lt;code&gt;if&lt;/code&gt; se ejecute solo cuando un n&amp;uacute;mero no es igual a &lt;code&gt;0&lt;/code&gt; , por ejemplo, podemos cambiar la expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">El mensaje de error indica que la causa del error es que no &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; , porque intent&amp;oacute; asignar un segundo valor a la variable &lt;code&gt;x&lt;/code&gt; inmutable .</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">El mensaje de error indica que el valor del &lt;code&gt;counter&lt;/code&gt; se mueve al cierre y luego se captura cuando llamamos al &lt;code&gt;lock&lt;/code&gt; . Esa descripci&amp;oacute;n suena como lo que quer&amp;iacute;amos, &amp;iexcl;pero no est&amp;aacute; permitido!</target>
        </trans-unit>
        <trans-unit id="5bb7a0ad71457e0f1d6ce226ce7b55ec5697ceba" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value was moved in the previous iteration of the loop. So Rust is telling us that we can&amp;rsquo;t move the ownership of lock &lt;code&gt;counter&lt;/code&gt; into multiple threads. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">Los mensajes de error dicen que el &lt;code&gt;hosting&lt;/code&gt; m&amp;oacute;dulo es privado. En otras palabras, tenemos las rutas correctas para el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; y la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; , pero Rust no nos deja usarlas porque no tiene acceso a las secciones privadas.</target>
        </trans-unit>
        <trans-unit id="8eb6e3e38ad85be87f507639136fdec21b108288" translate="yes" xml:space="preserve">
          <source>The error occurs because &lt;code&gt;foo&lt;/code&gt; accepts a closure that takes an &lt;code&gt;i32&lt;/code&gt; argument, but in &lt;code&gt;main&lt;/code&gt;, it is passed a closure with a &lt;code&gt;&amp;amp;str&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df536d23e48c26eec2d844083fbc5169ab15de6" translate="yes" xml:space="preserve">
          <source>The error occurs because keyword &lt;code&gt;yield&lt;/code&gt; can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">&amp;iexcl;El error hace referencia al rasgo &lt;code&gt;Sized&lt;/code&gt; nuevamente! Rust no sabe cu&amp;aacute;nto espacio necesitar&amp;aacute; para almacenar el cierre. Vimos una soluci&amp;oacute;n a este problema antes. Podemos usar un objeto de rasgo:</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">El error dice que no podemos mutar el tipo de una variable:</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">El error muestra que para que el &lt;code&gt;result&lt;/code&gt; ado sea ​​v&amp;aacute;lido para &lt;code&gt;println!&lt;/code&gt; declaraci&amp;oacute;n, &lt;code&gt;string2&lt;/code&gt; deber&amp;iacute;a ser v&amp;aacute;lida hasta el final del alcance externo. Rust lo sabe porque anotamos la vida &amp;uacute;til de los par&amp;aacute;metros de la funci&amp;oacute;n y los valores de retorno utilizando el mismo par&amp;aacute;metro de vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">El error muestra que no puede utilizar la &lt;code&gt;match&lt;/code&gt; palabras clave como identificador de funci&amp;oacute;n. Para usar la &lt;code&gt;match&lt;/code&gt; como nombre de funci&amp;oacute;n, debe usar la sintaxis de identificador sin formato, como esta:</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">El error muestra que este tipo &quot;tiene un tama&amp;ntilde;o infinito&quot;. La raz&amp;oacute;n es que hemos definido &lt;code&gt;List&lt;/code&gt; con una variante que es recursiva: tiene otro valor de s&amp;iacute; mismo directamente. Como resultado, Rust no puede calcular cu&amp;aacute;nto espacio necesita para almacenar un valor de &lt;code&gt;List&lt;/code&gt; . Analicemos un poco por qu&amp;eacute; obtenemos este error. Primero, veamos c&amp;oacute;mo Rust decide cu&amp;aacute;nto espacio necesita para almacenar un valor de tipo no recursivo.</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">El error nos dice que no podemos llamar a &lt;code&gt;join&lt;/code&gt; porque solo tenemos un pr&amp;eacute;stamo mutable de cada &lt;code&gt;worker&lt;/code&gt; y &lt;code&gt;join&lt;/code&gt; toma posesi&amp;oacute;n de su argumento. Para resolver este problema, necesitamos mover el subproceso fuera de la instancia de &lt;code&gt;Worker&lt;/code&gt; que posee el &lt;code&gt;thread&lt;/code&gt; para que &lt;code&gt;join&lt;/code&gt; pueda consumir el subproceso. Hicimos esto en el Listado 17-15: si &lt;code&gt;Worker&lt;/code&gt; tiene una &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; lugar, podemos llamar al m&amp;eacute;todo &lt;code&gt;take&lt;/code&gt; en la &lt;code&gt;Option&lt;/code&gt; para mover el valor fuera de la variante &lt;code&gt;Some&lt;/code&gt; y dejar una variante &lt;code&gt;None&lt;/code&gt; en su lugar. En otras palabras, un &lt;code&gt;Worker&lt;/code&gt; que se est&amp;aacute; ejecutando tendr&amp;aacute; una variante &lt;code&gt;Some&lt;/code&gt; en &lt;code&gt;thread&lt;/code&gt; , y cuando queramos limpiar un &lt;code&gt;Worker&lt;/code&gt; , reemplazaremos &lt;code&gt;Some&lt;/code&gt; con &lt;code&gt;None&lt;/code&gt; para que el &lt;code&gt;Worker&lt;/code&gt; no tenga un subproceso para ejecutar.</target>
        </trans-unit>
        <trans-unit id="58b8d8f068cf467e7f55c896bbdf137f3a755bf5" translate="yes" xml:space="preserve">
          <source>The error type for &lt;code&gt;try_reserve&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">El tipo de error para las operaciones de E / S de &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; y caracter&amp;iacute;sticas asociadas.</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">El tipo de error para los errores que nunca pueden ocurrir.</target>
        </trans-unit>
        <trans-unit id="fdb319ec59d1f1964ec642ac851b7301cdf60e57" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">El tipo de error para operaciones que interact&amp;uacute;an con variables de entorno. Posiblemente devuelto de la funci&amp;oacute;n &lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11ea1ae6c021101c095eab4ba4b755be8b16c063" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">El tipo de error para operaciones en la variable &lt;code&gt;PATH&lt;/code&gt; . Posiblemente devuelto por la funci&amp;oacute;n &lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">El tipo de error regresó cuando una conversión de tipo integral comprobada falla.</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">El tipo de error regresó cuando una conversión de una rebanada a un arreglo falla.</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">El tipo de error regresó cuando una conversión de u32 a char falla.</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">El tipo de error que resulta de aplicar el operador try ( &lt;code&gt;?&lt;/code&gt; ) A un valor &lt;code&gt;None&lt;/code&gt; . Si desea permitir &lt;code&gt;x?&lt;/code&gt; (donde &lt;code&gt;x&lt;/code&gt; es una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ) para convertirla en su tipo de error, puede implementar &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; para &lt;code&gt;YourErrorType&lt;/code&gt; . En ese caso, &lt;code&gt;x?&lt;/code&gt; dentro de una funci&amp;oacute;n que devuelve &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; traducir&amp;aacute; un valor &lt;code&gt;None&lt;/code&gt; en un resultado &lt;code&gt;Err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">El tipo de error que se devuelve al formatear un mensaje en un flujo.</target>
        </trans-unit>
        <trans-unit id="de3d4a50ecffe879839aa645e297acf63f3f41e3" translate="yes" xml:space="preserve">
          <source>The error type which is returned from parsing the type a control message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">Los errores del Listado 7-6 dicen que la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; es privada. Las reglas de privacidad se aplican a estructuras, enumeraciones, funciones y m&amp;eacute;todos, as&amp;iacute; como a m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">El comportamiento exacto al bloquear un mutex en el hilo que ya sujeta el cierre se deja sin especificar.Sin embargo,esta función no regresará en la segunda llamada (podría entrar en pánico o en un punto muerto,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">El personaje o personajes exactos</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">El orden exacto puede ser útil para rastrear el estado externo,como un índice.</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">La salida exacta impresa por esta macro no debe ser confiable y está sujeta a futuros cambios.</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">El texto exacto, por supuesto, depende de los archivos que tenga &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">El ejemplo del Listado 13-14 separa la creaci&amp;oacute;n del iterador del uso del iterador en el bucle &lt;code&gt;for&lt;/code&gt; . El iterador se almacena en la variable &lt;code&gt;v1_iter&lt;/code&gt; y no tiene lugar ninguna iteraci&amp;oacute;n en ese momento. Cuando se llama &lt;code&gt;for&lt;/code&gt; bucle for usando el iterador en &lt;code&gt;v1_iter&lt;/code&gt; , cada elemento del iterador se usa en una iteraci&amp;oacute;n del bucle, que imprime cada valor.</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">La excepci&amp;oacute;n a este modismo es si traemos dos elementos con el mismo nombre al alcance con declaraciones de &lt;code&gt;use&lt;/code&gt; , porque Rust no lo permite. El Listado 7-15 muestra c&amp;oacute;mo traer dos tipos de &lt;code&gt;Result&lt;/code&gt; al alcance que tienen el mismo nombre pero diferentes m&amp;oacute;dulos principales y c&amp;oacute;mo hacer referencia a ellos.</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">La excepci&amp;oacute;n a esto es la tupla unitaria ( &lt;code&gt;()&lt;/code&gt; ) que se garantiza como tipo de tama&amp;ntilde;o cero para tener un tama&amp;ntilde;o de 0 y una alineaci&amp;oacute;n de 1.</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">La expresi&amp;oacute;n expandida tiene el tipo &lt;code&gt;&amp;amp;'static str&lt;/code&gt; , &amp;iexcl;y el archivo devuelto no es la invocaci&amp;oacute;n del &lt;code&gt;file!&lt;/code&gt; macro en s&amp;iacute;, sino la primera invocaci&amp;oacute;n de macro que lleva a la invocaci&amp;oacute;n del &lt;code&gt;file!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">La expresi&amp;oacute;n expandida tiene el tipo &lt;code&gt;u32&lt;/code&gt; y est&amp;aacute; basada en 1, por lo que la primera columna de cada l&amp;iacute;nea se eval&amp;uacute;a como 1, la segunda como 2, etc. Esto es consistente con los mensajes de error de compiladores comunes o editores populares. &amp;iexcl;La columna devuelta &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;necesariamente&lt;/em&gt; la l&amp;iacute;nea de la &lt;code&gt;column!&lt;/code&gt; invocaci&amp;oacute;n en s&amp;iacute;, sino m&amp;aacute;s bien la primera macro invocaci&amp;oacute;n que conduce a la invocaci&amp;oacute;n de la &lt;code&gt;column!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">La expresi&amp;oacute;n expandida tiene el tipo &lt;code&gt;u32&lt;/code&gt; y est&amp;aacute; basada en 1, por lo que la primera l&amp;iacute;nea de cada archivo se eval&amp;uacute;a como 1, la segunda como 2, etc. Esto es consistente con los mensajes de error de compiladores comunes o editores populares. &amp;iexcl;La l&amp;iacute;nea devuelta &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;necesariamente&lt;/em&gt; la l&amp;iacute;nea de la &lt;code&gt;line!&lt;/code&gt; invocaci&amp;oacute;n en s&amp;iacute;, sino m&amp;aacute;s bien la primera macro invocaci&amp;oacute;n que conduce a la invocaci&amp;oacute;n de la &lt;code&gt;line!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="6dec360ada9c00c421ed26b5b352f032e17122ed" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is &lt;em&gt;O&lt;/em&gt;(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">El costo esperado de &lt;code&gt;push&lt;/code&gt; , promediado sobre cada posible orden de los elementos empujados, y sobre un n&amp;uacute;mero suficientemente grande de empujes, es O (1). Esta es la m&amp;eacute;trica de costos m&amp;aacute;s significativa cuando se empujan elementos que a&amp;uacute;n &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n en ning&amp;uacute;n patr&amp;oacute;n ordenado.</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">La expresi&amp;oacute;n anterior crea un valor de tipo &lt;code&gt;MyUnion&lt;/code&gt; e inicializa el almacenamiento usando el campo &lt;code&gt;f1&lt;/code&gt; . Se puede acceder a la uni&amp;oacute;n usando la misma sintaxis que los campos de estructura:</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">La expresi&amp;oacute;n no puede ser una &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;expresi&amp;oacute;n de operador booleano perezoso&lt;/a&gt; . El uso de un operador booleano perezoso es ambiguo con un cambio de caracter&amp;iacute;stica planificado del lenguaje (la implementaci&amp;oacute;n de cadenas if-let - ver &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt; ). Cuando se desea una expresi&amp;oacute;n de operador booleano perezoso, esto se puede lograr usando par&amp;eacute;ntesis como se muestra a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a608f321648c235bb5c3f09a506a153d6d9a7fa1" translate="yes" xml:space="preserve">
          <source>The expression for a match arm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc402eeeb9a7639cb3c026b59f168e6cd732965" translate="yes" xml:space="preserve">
          <source>The expression immediately following &lt;code&gt;in&lt;/code&gt; must implement the &lt;a href=&quot;../book/ch13-04-performance&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">La expresi&amp;oacute;n en el bloque &lt;code&gt;if&lt;/code&gt; se eval&amp;uacute;a como un n&amp;uacute;mero entero y la expresi&amp;oacute;n en el bloque &lt;code&gt;else&lt;/code&gt; se eval&amp;uacute;a como una cadena. Esto no funcionar&amp;aacute; porque las variables deben tener un solo tipo. Rust necesita saber en el momento de la compilaci&amp;oacute;n qu&amp;eacute; tipo es la variable &lt;code&gt;number&lt;/code&gt; , definitivamente, para poder verificar en el momento de la compilaci&amp;oacute;n que su tipo es v&amp;aacute;lido en todos los lugares donde usamos el &lt;code&gt;number&lt;/code&gt; . Rust no podr&amp;iacute;a hacer eso si el tipo de &lt;code&gt;number&lt;/code&gt; solo se determinara en tiempo de ejecuci&amp;oacute;n; el compilador ser&amp;iacute;a m&amp;aacute;s complejo y ofrecer&amp;iacute;a menos garant&amp;iacute;as sobre el c&amp;oacute;digo si tuviera que realizar un seguimiento de m&amp;uacute;ltiples tipos hipot&amp;eacute;ticos para cualquier variable.</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">La extensión es:</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">La caja externa se resuelve en un &lt;code&gt;soname&lt;/code&gt; espec&amp;iacute;fico en tiempo de compilaci&amp;oacute;n, y un requisito de vinculaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n para ese &lt;code&gt;soname&lt;/code&gt; se pasa al enlazador para cargar en tiempo de ejecuci&amp;oacute;n. El &lt;code&gt;soname&lt;/code&gt; se resuelve en el momento de la compilaci&amp;oacute;n escaneando la ruta de la biblioteca del compilador y &lt;code&gt;crateid&lt;/code&gt; el crateid opcional proporcionado con los atributos &lt;code&gt;crateid&lt;/code&gt; que se declararon en la caja externa cuando se compil&amp;oacute;. Si no se proporciona &lt;code&gt;crateid&lt;/code&gt; , se asume un atributo de &lt;code&gt;name&lt;/code&gt; predeterminado , igual al &lt;a href=&quot;../identifiers&quot;&gt;identificador&lt;/a&gt; dado en la declaraci&amp;oacute;n de &lt;code&gt;extern crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">El mensaje de error indica que esta prueba realmente entr&amp;oacute; en p&amp;aacute;nico como esper&amp;aacute;bamos, pero el mensaje de p&amp;aacute;nico no inclu&amp;iacute;a la cadena esperada &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; suposici&amp;oacute;n debe ser menor o igual a 100' . El mensaje de p&amp;aacute;nico que recibimos en este caso fue &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Ahora podemos comenzar a averiguar d&amp;oacute;nde est&amp;aacute; nuestro error!</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">La familia del sistema operativo. El valor de ejemplo es &lt;code&gt;unix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">Los nombres de los campos pueden ser valores enteros decimales para especificar índices para construir estructuras tuplicadas.Esto puede utilizarse con estructuras de base para rellenar los índices restantes no especificados:</target>
        </trans-unit>
        <trans-unit id="0bbc5c6747805ec7b206ff1d7bd4fc19a67e98d4" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">Los campos de una &lt;a href=&quot;types/struct&quot;&gt;estructura&lt;/a&gt; , &lt;a href=&quot;types/tuple&quot;&gt;tupla&lt;/a&gt; o &lt;a href=&quot;types/enum&quot;&gt;variante enum&lt;/a&gt; se eliminan en el orden de declaraci&amp;oacute;n. *</target>
        </trans-unit>
        <trans-unit id="ad3f74fe8b6e787f7b7254796fcea650c623bbf0" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; are dropped in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">Los campos de una &lt;code&gt;struct&lt;/code&gt; se pueden calificar mediante &lt;a href=&quot;../visibility-and-privacy&quot;&gt;modificadores de visibilidad&lt;/a&gt; , para permitir el acceso a los datos en una estructura fuera de un m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="d44253ff03665f86e16760d6d12a49f11125c4e2" translate="yes" xml:space="preserve">
          <source>The fields of the active &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Los campos de esta estructura muestran que el c&amp;oacute;digo de Rust que hemos analizado es una estructura de unidad con el &lt;code&gt;ident&lt;/code&gt; (identificador, es decir, el nombre) de &lt;code&gt;Pancakes&lt;/code&gt; . Hay m&amp;aacute;s campos en esta estructura para describir todo tipo de c&amp;oacute;digo Rust; comprobar el &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; documentaci&amp;oacute;n para &lt;code&gt;DeriveInput&lt;/code&gt; &lt;/a&gt; para m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b0794c80e766c7ef30098e79990a99a126d86062" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f21e4814cce1d92447f83c7dd9a65499d60626" translate="yes" xml:space="preserve">
          <source>The file doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">El archivo se ubica en relación con el archivo actual (de manera similar a como se encuentran los módulos).</target>
        </trans-unit>
        <trans-unit id="0630128fbb4da19cb239333b356fc43bbab7e18f" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes &lt;code&gt;\&lt;/code&gt; would not compile correctly on Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">El archivo está ubicado en relación con el archivo actual.(de manera similar a como se encuentran los módulos)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">El archivo debe abrirse con acceso de escritura para que el truncamiento funcione.</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">El archivo debe abrirse con acceso de escritura o adición para crear un nuevo archivo.</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">El cursor del archivo no ha cambiado.En particular,si el cursor estaba al final y el archivo se encoge usando esta operación,el cursor ahora estará más allá del final.</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">El car&amp;aacute;cter de relleno se proporciona normalmente junto con el par&amp;aacute;metro de &lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; . Esto indica que si el valor que se est&amp;aacute; formateando es menor que el &lt;code&gt;width&lt;/code&gt; , se imprimir&amp;aacute;n algunos caracteres adicionales a su alrededor. Los caracteres adicionales se especifican por &lt;code&gt;fill&lt;/code&gt; y la alineaci&amp;oacute;n puede ser una de las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="85f2c169cb253978c0bcbcb827b4f9bdee23de08" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is accessing fields of a &lt;em&gt;union&lt;/em&gt;. A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">La acci&amp;oacute;n final que funciona solo con &lt;code&gt;unsafe&lt;/code&gt; es implementar un rasgo inseguro. Un rasgo no es seguro cuando al menos uno de sus m&amp;eacute;todos tiene alguna invariante que el compilador no puede verificar. Podemos declarar que un rasgo &lt;code&gt;unsafe&lt;/code&gt; es seguro agregando la palabra clave &lt;code&gt;unsafe&lt;/code&gt; antes del &lt;code&gt;trait&lt;/code&gt; y marcando la implementaci&amp;oacute;n del rasgo como &lt;code&gt;unsafe&lt;/code&gt; tambi&amp;eacute;n, como se muestra en el Listado 19-11.</target>
        </trans-unit>
        <trans-unit id="49a4f7cf0e0e66e3c555d75f0978be5130fe5dec" translate="yes" xml:space="preserve">
          <source>The final expression of any extending &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">El final de la línea es opcional.</target>
        </trans-unit>
        <trans-unit id="7bcad5659fa398bc4723e1a1e4ec534359f32934" translate="yes" xml:space="preserve">
          <source>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">El final de la línea no es necesario:</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">El resultado final podr&amp;iacute;a determinarse simplemente mirando el c&amp;oacute;digo en tiempo de compilaci&amp;oacute;n, por lo que el &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;plegado constante&lt;/a&gt; podr&amp;iacute;a convertir todo el bloque en un simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">El primer valor de &lt;code&gt;Cons&lt;/code&gt; contiene &lt;code&gt;1&lt;/code&gt; y otro valor de &lt;code&gt;List&lt;/code&gt; a . Este valor de &lt;code&gt;List&lt;/code&gt; es otro valor de &lt;code&gt;Cons&lt;/code&gt; que contiene &lt;code&gt;2&lt;/code&gt; y otro valor de &lt;code&gt;List&lt;/code&gt; . Este valor de &lt;code&gt;List&lt;/code&gt; a es un valor de &lt;code&gt;Cons&lt;/code&gt; m&amp;aacute;s que contiene &lt;code&gt;3&lt;/code&gt; y un valor de &lt;code&gt;List&lt;/code&gt; a , que finalmente es &lt;code&gt;Nil&lt;/code&gt; , la variante no recursiva que se&amp;ntilde;ala el final de la lista.</target>
        </trans-unit>
        <trans-unit id="b8427aa75fccc52f421b7262b47d3cb66ca8ba99" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;length&lt;/code&gt; bytes at &lt;code&gt;buf&lt;/code&gt; need to be valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">&amp;iexcl;El primer &lt;code&gt;format!&lt;/code&gt; argumento ! recibe es una cadena de formato. Debe ser una cadena literal. El poder de la cadena de formato est&amp;aacute; en los &lt;code&gt;{}&lt;/code&gt; s contenidos.</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">El primer argumento que le dimos a &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt; , es igual al resultado de llamar a &lt;code&gt;add_two(2)&lt;/code&gt; . La l&amp;iacute;nea para esta prueba es &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; , y el texto &lt;code&gt;ok&lt;/code&gt; indica que nuestra prueba pas&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">El primer brazo coincidir&amp;aacute; con cualquier punto que se encuentre en el eje &lt;code&gt;x&lt;/code&gt; especificando que el campo &lt;code&gt;y&lt;/code&gt; coincide si su valor coincide con el literal &lt;code&gt;0&lt;/code&gt; . El patr&amp;oacute;n a&amp;uacute;n crea una variable &lt;code&gt;x&lt;/code&gt; que podemos usar en el c&amp;oacute;digo para este brazo.</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">El primer car&amp;aacute;cter es &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">El primer personaje es una letra.</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">El primer tipo de colecci&amp;oacute;n que veremos es &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , tambi&amp;eacute;n conocido como &lt;em&gt;vector&lt;/em&gt; . Los vectores le permiten almacenar m&amp;aacute;s de un valor en una &amp;uacute;nica estructura de datos que coloca todos los valores uno al lado del otro en la memoria. Los vectores solo pueden almacenar valores del mismo tipo. Son &amp;uacute;tiles cuando tiene una lista de art&amp;iacute;culos, como las l&amp;iacute;neas de texto en un archivo o los precios de los art&amp;iacute;culos en un carrito de compras.</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">El primer comando crea un nuevo directorio llamado &lt;em&gt;hello_cargo&lt;/em&gt; . Hemos nombrado a nuestro proyecto &lt;em&gt;hello_cargo&lt;/em&gt; y Cargo crea sus archivos en un directorio con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">El primer comando, &lt;code&gt;cargo new&lt;/code&gt; , toma el nombre del proyecto ( juego de &lt;code&gt;guessing_game&lt;/code&gt; ) como primer argumento. El segundo comando cambia al directorio del nuevo proyecto.</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">El primer elemento es tradicionalmente el camino del ejecutable,pero puede establecerse en un texto arbitrario,y puede incluso no existir,por lo que no se debe confiar en esta propiedad para fines de seguridad.</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">El primer elemento es tradicionalmente el camino del ejecutable,pero puede establecerse en un texto arbitrario,y puede incluso no existir.Esto significa que no se debe confiar en esta propiedad por motivos de seguridad.</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">El primer elemento se movi&amp;oacute; fuera de la matriz, pero esto no es posible porque &lt;code&gt;NonCopy&lt;/code&gt; no implementa el rasgo &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">La primera enumeraci&amp;oacute;n que se muestra es el tipo habitual de enumeraci&amp;oacute;n que encontrar&amp;iacute;a en un lenguaje de estilo C. El segundo muestra un ejemplo hipot&amp;eacute;tico de algo que almacena datos de ubicaci&amp;oacute;n, siendo &lt;code&gt;Coord&lt;/code&gt; cualquier otro tipo que se necesite, por ejemplo, una estructura. El tercer ejemplo demuestra el tipo de datos que puede almacenar una variante, que van desde nada, a una tupla, a una estructura an&amp;oacute;nima.</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">El primer error est&amp;aacute; en nuestra implementaci&amp;oacute;n de &lt;code&gt;Drop&lt;/code&gt; . Mencionamos anteriormente que ten&amp;iacute;amos la intenci&amp;oacute;n de llamar a &lt;code&gt;take&lt;/code&gt; el valor de &lt;code&gt;Option&lt;/code&gt; para mover el &lt;code&gt;thread&lt;/code&gt; fuera del &lt;code&gt;worker&lt;/code&gt; . Los siguientes cambios lo har&amp;aacute;n:</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">El primer invariante dice que cualquier token real que venga despu&amp;eacute;s de un emparejador, si lo hay, debe estar en alg&amp;uacute;n lugar del conjunto de seguimiento predeterminado. Esto asegura que una macrodefinici&amp;oacute;n legal continuar&amp;aacute; asignando la misma determinaci&amp;oacute;n en cuanto a d&amp;oacute;nde &lt;code&gt;... tt&lt;/code&gt; termina y &lt;code&gt;uu ...&lt;/code&gt; comienza, incluso cuando se agregan nuevas formas sint&amp;aacute;cticas al lenguaje.</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">La primera es que es la cantidad de memoria que debe asignarse para almacenar ese valor.</target>
        </trans-unit>
        <trans-unit id="beaa6fcb1bf59defe3de830f4f2763f9980dd889" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporaries&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">El primero es responder a una pregunta espec&amp;iacute;fica. Si sabe qu&amp;eacute; cap&amp;iacute;tulo responde a esa pregunta, puede saltar a ese cap&amp;iacute;tulo en la tabla de contenido. De lo contrario, puede presionar &lt;code&gt;s&lt;/code&gt; o hacer clic en la lupa en la barra superior para buscar palabras clave relacionadas con su pregunta. Por ejemplo, supongamos que desea saber cu&amp;aacute;ndo se elimina un valor temporal creado en una instrucci&amp;oacute;n let. Si a&amp;uacute;n no sab&amp;iacute;a que la &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;vida &amp;uacute;til de los temporales&lt;/a&gt; se define en el &lt;a href=&quot;expressions&quot;&gt;cap&amp;iacute;tulo de expresiones&lt;/a&gt; , puede buscar &quot;permiso temporal&quot; y el primer resultado de la b&amp;uacute;squeda lo llevar&amp;aacute; a esa secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">La primera l&amp;iacute;nea es una &lt;em&gt;l&amp;iacute;nea de estado&lt;/em&gt; que contiene la versi&amp;oacute;n HTTP utilizada en la respuesta, un c&amp;oacute;digo de estado num&amp;eacute;rico que resume el resultado de la solicitud y una frase de motivo que proporciona una descripci&amp;oacute;n de texto del c&amp;oacute;digo de estado. Despu&amp;eacute;s de la secuencia CRLF est&amp;aacute;n los encabezados, otra secuencia CRLF y el cuerpo de la respuesta.</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">La primera l&amp;iacute;nea es la &lt;em&gt;l&amp;iacute;nea de solicitud&lt;/em&gt; que contiene informaci&amp;oacute;n sobre lo que solicita el cliente. La primera parte de la l&amp;iacute;nea de solicitud indica el &lt;em&gt;m&amp;eacute;todo que se&lt;/em&gt; est&amp;aacute; utilizando, como &lt;code&gt;GET&lt;/code&gt; o &lt;code&gt;POST&lt;/code&gt; , que describe c&amp;oacute;mo el cliente realiza esta solicitud. Nuestro cliente utiliz&amp;oacute; una solicitud &lt;code&gt;GET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">La primera l&amp;iacute;nea muestra una definici&amp;oacute;n de funci&amp;oacute;n y la segunda l&amp;iacute;nea muestra una definici&amp;oacute;n de cierre completamente anotada. La tercera l&amp;iacute;nea elimina las anotaciones de tipo de la definici&amp;oacute;n de cierre y la cuarta l&amp;iacute;nea elimina los corchetes, que son opcionales porque el cuerpo del cierre solo tiene una expresi&amp;oacute;n. Todas estas son definiciones v&amp;aacute;lidas que producir&amp;aacute;n el mismo comportamiento cuando se las llame.</target>
        </trans-unit>
        <trans-unit id="ee8e9ca51bced15f598c9116a158790ff9d282d7" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called. Calling the closures is required for &lt;code&gt;add_one_v3&lt;/code&gt; and &lt;code&gt;add_one_v4&lt;/code&gt; to be able to compile because the types will be inferred from their usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">La primera l&amp;iacute;nea, &lt;code&gt;[package]&lt;/code&gt; , es un encabezado de secci&amp;oacute;n que indica que las siguientes declaraciones est&amp;aacute;n configurando un paquete. A medida que agreguemos m&amp;aacute;s informaci&amp;oacute;n a este archivo, agregaremos otras secciones.</target>
        </trans-unit>
        <trans-unit id="b65c034b9a1653c1664e07497c1d14736ba472ab" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which sequence is lexicographically less or greater than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">El primer bit nuevo aqu&amp;iacute; es otra declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; , que trae un tipo llamado &lt;code&gt;std::cmp::Ordering&lt;/code&gt; al alcance de la biblioteca est&amp;aacute;ndar. Al igual que &lt;code&gt;Result&lt;/code&gt; , &lt;code&gt;Ordering&lt;/code&gt; es otra enumeraci&amp;oacute;n, pero las variantes de &lt;code&gt;Ordering&lt;/code&gt; son &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Greater&lt;/code&gt; e &lt;code&gt;Equal&lt;/code&gt; . Estos son los tres resultados que son posibles cuando compara dos valores.</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">La primera l&amp;iacute;nea nueva define la variable de &lt;code&gt;response&lt;/code&gt; que contiene los datos del mensaje de &amp;eacute;xito. Luego llamamos a &lt;code&gt;as_bytes&lt;/code&gt; en nuestra &lt;code&gt;response&lt;/code&gt; para convertir los datos de la cadena en bytes. El m&amp;eacute;todo de &lt;code&gt;write&lt;/code&gt; en la &lt;code&gt;stream&lt;/code&gt; toma un &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; y env&amp;iacute;a esos bytes directamente por la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">El primero parece mucho m&amp;aacute;s limpio. Este comportamiento de referencia autom&amp;aacute;tica funciona porque los m&amp;eacute;todos tienen un receptor claro: el tipo de &lt;code&gt;self&lt;/code&gt; . Dado el receptor y el nombre de un m&amp;eacute;todo, Rust puede determinar definitivamente si el m&amp;eacute;todo est&amp;aacute; leyendo ( &lt;code&gt;&amp;amp;self&lt;/code&gt; ), mutando ( &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ) o consumiendo ( &lt;code&gt;self&lt;/code&gt; ). El hecho de que Rust haga impl&amp;iacute;cito el uso de pr&amp;eacute;stamos para los receptores de m&amp;eacute;todos es una parte importante para que la propiedad sea ergon&amp;oacute;mica en la pr&amp;aacute;ctica.</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">La primera parte del programa del juego de adivinanzas solicitar&amp;aacute; la entrada del usuario, procesar&amp;aacute; esa entrada y verificar&amp;aacute; que la entrada est&amp;eacute; en la forma esperada. Para comenzar, permitiremos que el jugador ingrese una suposici&amp;oacute;n. Introducir el c&amp;oacute;digo en el Listado 2-1 en &lt;em&gt;src / main.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2750d61c6d5f6fdb7cf8539aba812571a959c619" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt; section). A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">Las primeras partes del sistema de m&amp;oacute;dulos que cubriremos son paquetes y cajas. Una caja es un binario o una biblioteca. La &lt;em&gt;ra&amp;iacute;z de la caja&lt;/em&gt; es un archivo de origen desde el que parte el compilador de Rust y constituye el m&amp;oacute;dulo ra&amp;iacute;z de su caja (explicaremos los m&amp;oacute;dulos en profundidad en la secci&amp;oacute;n &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&quot;Definici&amp;oacute;n de m&amp;oacute;dulos para controlar el alcance y la privacidad&quot;&lt;/a&gt; ). Un &lt;em&gt;paquete&lt;/em&gt; es una o m&amp;aacute;s cajas que proporcionan un conjunto de funciones. Un paquete contiene un archivo &lt;em&gt;Cargo.toml&lt;/em&gt; que describe c&amp;oacute;mo construir esas cajas.</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">El primer problema es que una instancia de &lt;code&gt;Cacher&lt;/code&gt; asume que siempre obtendr&amp;aacute; el mismo valor para el par&amp;aacute;metro &lt;code&gt;arg&lt;/code&gt; que el m&amp;eacute;todo &lt;code&gt;value&lt;/code&gt; . Es decir, esta prueba de &lt;code&gt;Cacher&lt;/code&gt; fallar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">El primer propósito es similar al segundo pero a la inversa:si se quiere añadir un parámetro de tipo a un rasgo existente,se le puede dar un valor por defecto para permitir la extensión de la funcionalidad del rasgo sin romper el código de implementación existente.</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">La primera regla es que cada par&amp;aacute;metro que es una referencia obtiene su propio par&amp;aacute;metro de duraci&amp;oacute;n. En otras palabras, una funci&amp;oacute;n con un par&amp;aacute;metro obtiene un par&amp;aacute;metro de por vida: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ; una funci&amp;oacute;n con dos par&amp;aacute;metros obtiene dos par&amp;aacute;metros de duraci&amp;oacute;n separados: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ; y as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">La primera secci&amp;oacute;n de la salida muestra que &lt;code&gt;it_works&lt;/code&gt; prueba it_works en la caja &lt;code&gt;add-one&lt;/code&gt; . La siguiente secci&amp;oacute;n muestra que no se encontraron pruebas en la caja del &lt;code&gt;adder&lt;/code&gt; , y luego la &amp;uacute;ltima secci&amp;oacute;n muestra que no se encontraron pruebas de documentaci&amp;oacute;n en la caja &lt;code&gt;add-one&lt;/code&gt; . Ejecutar la &lt;code&gt;cargo test&lt;/code&gt; en un espacio de trabajo estructurado como este ejecutar&amp;aacute; las pruebas para todas las cajas en el espacio de trabajo.</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El primer paso es crear una lista de tipos de receptores candidatos. Cons&amp;iacute;galos &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;desreferenciando&lt;/a&gt; repetidamente el tipo de expresi&amp;oacute;n del receptor, agregando cada tipo encontrado a la lista, luego intente finalmente una &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;coerci&amp;oacute;n sin tama&amp;ntilde;o&lt;/a&gt; al final y agregando el tipo de resultado si tiene &amp;eacute;xito. A continuaci&amp;oacute;n, para cada candidato &lt;code&gt;T&lt;/code&gt; , a&amp;ntilde;adir &lt;code&gt;&amp;amp;T&lt;/code&gt; y &lt;code&gt;&amp;amp;mut T&lt;/code&gt; a la lista inmediatamente despu&amp;eacute;s de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">El primer paso es instalar Rust. Descargaremos Rust a trav&amp;eacute;s de &lt;code&gt;rustup&lt;/code&gt; , una herramienta de l&amp;iacute;nea de comandos para administrar versiones de Rust y herramientas asociadas. Necesitar&amp;aacute; una conexi&amp;oacute;n a Internet para la descarga.</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">La primera tienda a &lt;code&gt;C&lt;/code&gt; podr&amp;iacute;a moverse antes que la tienda a &lt;code&gt;A&lt;/code&gt; o &lt;code&gt;B&lt;/code&gt; , &lt;em&gt;como si&lt;/em&gt; hubi&amp;eacute;ramos escrito &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">La primera tarea es hacer que &lt;code&gt;minigrep&lt;/code&gt; acepte sus dos argumentos de l&amp;iacute;nea de comando: el nombre del archivo y una cadena para buscar. Es decir, queremos poder ejecutar nuestro programa con &lt;code&gt;cargo run&lt;/code&gt; , una cadena para buscar y una ruta a un archivo para buscar, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">La primera vez que llamamos &lt;code&gt;example_closure&lt;/code&gt; con el valor &lt;code&gt;String&lt;/code&gt; , el compilador infiere que el tipo de &lt;code&gt;x&lt;/code&gt; y el tipo de retorno del cierre es &lt;code&gt;String&lt;/code&gt; . Luego, esos tipos se bloquean en el cierre en &lt;code&gt;example_closure&lt;/code&gt; , y obtenemos un error de tipo si intentamos usar un tipo diferente con el mismo cierre.</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">La primera vez que llamamos el &lt;code&gt;add_to_waitlist&lt;/code&gt; funci&amp;oacute;n en &lt;code&gt;eat_at_restaurant&lt;/code&gt; , se utiliza una ruta absoluta. El &lt;code&gt;add_to_waitlist&lt;/code&gt; funci&amp;oacute;n se define de la misma caja como &lt;code&gt;eat_at_restaurant&lt;/code&gt; , lo que significa que podemos usar el &lt;code&gt;crate&lt;/code&gt; palabra clave para iniciar una ruta absoluta.</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">Los dos primeros casos son iguales excepto por la mutabilidad. El primer caso establece que si tiene una &lt;code&gt;&amp;amp;T&lt;/code&gt; , y &lt;code&gt;T&lt;/code&gt; implementa &lt;code&gt;Deref&lt;/code&gt; en alg&amp;uacute;n tipo &lt;code&gt;U&lt;/code&gt; , puede obtener una &lt;code&gt;&amp;amp;U&lt;/code&gt; transparente. El segundo caso establece que la misma coerci&amp;oacute;n deref ocurre para referencias mutables.</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">La primera versión del preludio de la Biblioteca del Estándar del Óxido.</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">El primero contendr&amp;aacute; todos los &amp;iacute;ndices de &lt;code&gt;[0, mid)&lt;/code&gt; (excluyendo el &amp;iacute;ndice &lt;code&gt;mid&lt;/code&gt; en s&amp;iacute;) y el segundo contendr&amp;aacute; todos los &amp;iacute;ndices de &lt;code&gt;[mid, len)&lt;/code&gt; (excluyendo el &amp;iacute;ndice &lt;code&gt;len&lt;/code&gt; en s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; afectan los l&amp;iacute;mites de tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1c0907607a038e19917ef67594e99ddd26567897" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for changing how a type can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; se utilizan para controlar la generaci&amp;oacute;n de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; se utilizan para controlar o generar mensajes de diagn&amp;oacute;stico durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; se utilizan para especificar funciones para realizar pruebas. Compilar una caja en modo &quot;prueba&quot; permite construir las funciones de prueba junto con un arn&amp;eacute;s de prueba para ejecutar las pruebas. Habilitar el modo de prueba tambi&amp;eacute;n habilita la &lt;a href=&quot;../conditional-compilation#test&quot;&gt;opci&amp;oacute;n de compilaci&amp;oacute;n condicional de &lt;/a&gt; &lt;code&gt;test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; controlan el comportamiento de los bloques externos.</target>
        </trans-unit>
        <trans-unit id="e4c3204613b4a8b1aeaa7e0d193d03d0b636c5e8" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;join_slices&lt;/code&gt; function is &lt;strong&gt;unsound&lt;/strong&gt; ⚠️</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">Los siguientes son ejemplos de expresiones estructurales:</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">El siguiente c&amp;oacute;digo intenta devolver un cierre directamente, pero no se compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">Las siguientes coacciones se denominan &lt;code&gt;unsized coercions&lt;/code&gt; , ya que se relacionan con la conversi&amp;oacute;n de tipos con tama&amp;ntilde;o en tipos sin tama&amp;ntilde;o, y est&amp;aacute;n permitidas en unos pocos casos donde otras coacciones no lo son, como se describi&amp;oacute; anteriormente. Todav&amp;iacute;a pueden suceder en cualquier otro lugar donde pueda ocurrir una coerci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">Los siguientes contextos son contextos de &lt;em&gt;expresi&amp;oacute;n de lugar&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">El siguiente ejemplo contiene una dependencia circular entre dos rasgos:</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">El siguiente ejemplo implementa &lt;code&gt;Index&lt;/code&gt; en un contenedor &lt;code&gt;NucleotideCount&lt;/code&gt; de solo lectura , lo que permite recuperar recuentos individuales con sintaxis de &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="1e6d78aaf2b8415e3caf24e2fa8603dbd9c8a54c" translate="yes" xml:space="preserve">
          <source>The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">El siguiente ejemplo usa &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; para crear una caja opcional de &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que con el fin de utilizar el interior &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; valor primero, los &lt;code&gt;check_optional&lt;/code&gt; necesidades de funci&amp;oacute;n a uso coincidencia de patrones para determinar si la caja tiene un valor (es decir, es &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; &lt;/a&gt; ) o no ( &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">Las siguientes expresiones son expresiones constantes, siempre que los operandos sean tambi&amp;eacute;n expresiones constantes y no hagan que se ejecute ninguna llamada &lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">Las siguientes expresiones son equivalentes.</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">Las siguientes expresiones pueden ser contextos de expresión de lugares mutables:</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">A continuaci&amp;oacute;n se ilustra c&amp;oacute;mo se pueden hacer coincidir los tokens directamente despu&amp;eacute;s de hacer coincidir un fragmento &lt;code&gt;tt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">A continuación figura una lista de los nombres de las características disponibles.</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">El siguiente es un ejemplo de una macro derivada. En lugar de hacer algo &amp;uacute;til con su entrada, simplemente agrega una &lt;code&gt;answer&lt;/code&gt; funci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo de &lt;code&gt;Shape&lt;/code&gt; declarar que Shape es un superretrato de &lt;code&gt;Circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">A continuación se presenta un índice de todos los atributos incorporados.</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">A continuación se presenta un resumen de los objetos de sincronización disponibles:</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">Las siguientes palabras clave están reservadas a partir de la edición de 2018.</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">Las siguientes palabras clave tienen actualmente la funcionalidad descrita.</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">Las siguientes palabras clave no tienen ninguna funcionalidad pero están reservadas por Rust para un posible uso futuro.</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">Las siguientes palabras clave fueron añadidas a partir de la edición de 2018.</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">Las siguientes características del nivel de lenguaje no se pueden utilizar en el subconjunto seguro de Rust:</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">La siguiente lista contiene todas las no letras que no funcionan como operadores; es decir, no se comportan como una funci&amp;oacute;n o llamada a un m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">La siguiente lista contiene palabras clave que est&amp;aacute;n reservadas para uso actual o futuro por el lenguaje Rust. Como tales, no se pueden utilizar como identificadores (excepto como identificadores sin procesar, como veremos en la secci&amp;oacute;n &quot; &lt;a href=&quot;#raw-identifiers&quot;&gt;Identificadores sin procesar&lt;/a&gt; &quot;), incluidos los nombres de funciones, variables, par&amp;aacute;metros, campos de estructura, m&amp;oacute;dulos, cajas, constantes, macros, valores est&amp;aacute;ticos , atributos, tipos, rasgos o vidas.</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">Los fragmentos gramaticales de &lt;em&gt;Lexer&lt;/em&gt; y &lt;em&gt;Syntax&lt;/em&gt; utilizan las siguientes notaciones :</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Lo siguiente devuelve &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c03f7174ac895e9b31fae2f8cfc928f6b6b192e" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">El siguiente retorno es falso:</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">La siguiente versi&amp;oacute;n reescrita de &lt;code&gt;another_function&lt;/code&gt; muestra c&amp;oacute;mo se ven los par&amp;aacute;metros en Rust:</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">Las siguientes secciones contienen material de referencia que puede serle útil en su viaje a la Óxido.</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">Los siguientes pasos instalan la &amp;uacute;ltima versi&amp;oacute;n estable del compilador de Rust. Las garant&amp;iacute;as de estabilidad de Rust aseguran que todos los ejemplos en el libro que compilan continuar&amp;aacute;n compil&amp;aacute;ndose con versiones m&amp;aacute;s recientes de Rust. El resultado puede diferir ligeramente entre versiones, porque Rust a menudo mejora los mensajes de error y las advertencias. En otras palabras, cualquier versi&amp;oacute;n estable m&amp;aacute;s nueva de Rust que instale siguiendo estos pasos deber&amp;iacute;a funcionar como se esperaba con el contenido de este libro.</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">La siguiente tabla da el tamaño para los primitivos.</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">Los siguientes rasgos se implementan para todos &lt;code&gt;&amp;amp;T&lt;/code&gt; , independientemente del tipo de su referente:</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">Los siguientes rasgos se implementan en referencias &lt;code&gt;&amp;amp;T&lt;/code&gt; si la &lt;code&gt;T&lt;/code&gt; subyacente tambi&amp;eacute;n implementa ese rasgo:</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">A continuación se imprimirá &quot;Gancho de pánico personalizado&quot;:</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">Lo siguiente imprimirá &quot;Pánico normal&quot;:</target>
        </trans-unit>
        <trans-unit id="7ed71896f2a34a4014ac80c7f9efbde1c744961e" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">La forma formal de describir este comportamiento es que las expresiones de tipo &lt;code&gt;!&lt;/code&gt; puede ser coaccionado a cualquier otro tipo. Se nos permite finalizar este brazo de &lt;code&gt;match&lt;/code&gt; con &lt;code&gt;continue&lt;/code&gt; porque &lt;code&gt;continue&lt;/code&gt; no devuelve un valor; en cambio, mueve el control a la parte superior del ciclo, por lo que en el caso &lt;code&gt;Err&lt;/code&gt; , nunca asignamos un valor para &lt;code&gt;guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99bcb45d13b51e9ae5259463fdd2a32bb1c9a90e" translate="yes" xml:space="preserve">
          <source>The full circle constant (&amp;tau;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">La ruta completa se crea uniendo la ruta original a &lt;code&gt;read_dir&lt;/code&gt; con el nombre de archivo de esta entrada.</target>
        </trans-unit>
        <trans-unit id="32f32b59c17ac39e46a137b79b14f93e65ff40c1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;inner_drop&lt;/code&gt; tiene el tipo que &lt;em&gt;deber&amp;iacute;a&lt;/em&gt; tener &lt;code&gt;drop&lt;/code&gt; , por lo que esto asegura que no use accidentalmente &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; de una manera que est&amp;eacute; en conflicto con la fijaci&amp;oacute;n.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf14d5d5cd860e1137527a26dcf1970a6fdcd6cb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; no es segura porque toma un puntero sin formato y debe confiar en que este puntero es v&amp;aacute;lido. El m&amp;eacute;todo de &lt;code&gt;offset&lt;/code&gt; en punteros sin formato tampoco es seguro, porque debe confiar en que la ubicaci&amp;oacute;n de desplazamiento tambi&amp;eacute;n es un puntero v&amp;aacute;lido. Por lo tanto, tuvimos que poner un bloque &lt;code&gt;unsafe&lt;/code&gt; alrededor de nuestras llamadas para &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; y &lt;code&gt;offset&lt;/code&gt; para poder llamarlas. Al observar el c&amp;oacute;digo y agregar la afirmaci&amp;oacute;n de que &lt;code&gt;mid&lt;/code&gt; debe ser menor o igual que &lt;code&gt;len&lt;/code&gt; , podemos decir que todos los punteros sin procesar usados ​​dentro del bloque &lt;code&gt;unsafe&lt;/code&gt; ser&amp;aacute;n punteros v&amp;aacute;lidos a datos dentro del segmento. Este es un uso aceptable y apropiado de &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e2ea4196275fb1f06fa7661da10e384c365aa9f" translate="yes" xml:space="preserve">
          <source>The function body block is contained within the scope of the entire function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">El cuerpo de la funci&amp;oacute;n usa el valor de &lt;code&gt;assert_eq!&lt;/code&gt; macro para afirmar que 2 + 2 es igual a 4. Esta afirmaci&amp;oacute;n sirve como ejemplo del formato de una prueba t&amp;iacute;pica. Ejec&amp;uacute;telo para ver si esta prueba pasa.</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">La funci&amp;oacute;n debe llamarse con una matriz de bytes v&amp;aacute;lida &lt;code&gt;buf&lt;/code&gt; de tama&amp;ntilde;o suficiente para contener los bytes del mensaje. Si un mensaje es demasiado largo para caber en el b&amp;uacute;fer proporcionado, los bytes sobrantes pueden descartarse.</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">La funci&amp;oacute;n entra en p&amp;aacute;nico si &lt;code&gt;align&lt;/code&gt; no es una potencia de dos.</target>
        </trans-unit>
        <trans-unit id="b268ef11b8c08ae232cf81ee855904ac47e81a51" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if there was enough space in the buffer. If there was not enough space then no credentials was appended. Technically, that means this operation adds a control message with the level &lt;code&gt;SOL_SOCKET&lt;/code&gt; and type &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; or &lt;code&gt;SCM_CREDS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571e08cd267873dac614b1a31157ac35e6c1e16a" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if there was enough space in the buffer. If there was not enough space then no file descriptors was appended. Technically, that means this operation adds a control message with the level &lt;code&gt;SOL_SOCKET&lt;/code&gt; and type &lt;code&gt;SCM_RIGHTS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">La firma de la funci&amp;oacute;n ahora le dice a Rust que durante un tiempo &lt;code&gt;'a&lt;/code&gt; vida 'a , la funci&amp;oacute;n toma dos par&amp;aacute;metros, los cuales son segmentos de cadena que viven al menos tanto como la vida &lt;code&gt;'a&lt;/code&gt; . La firma de la funci&amp;oacute;n tambi&amp;eacute;n le dice a Rust que el segmento de cadena devuelto por la funci&amp;oacute;n vivir&amp;aacute; al menos mientras dure &lt;code&gt;'a&lt;/code&gt; . En la pr&amp;aacute;ctica, significa que la vida &amp;uacute;til de la referencia devuelta por el &lt;code&gt;longest&lt;/code&gt; La funci&amp;oacute;n es la misma que la menor de las duraciones de las referencias pasadas. Estas restricciones son las que queremos que Rust aplique. Recuerde, cuando especificamos los par&amp;aacute;metros de duraci&amp;oacute;n en esta firma de funci&amp;oacute;n, no cambiamos la duraci&amp;oacute;n de los valores pasados ​​o devueltos. M&amp;aacute;s bien, estamos especificando que el verificador de pr&amp;eacute;stamos debe rechazar cualquier valor que no se adhiera a estas restricciones. Tenga en cuenta que la &lt;code&gt;longest&lt;/code&gt; funci&amp;oacute;n no necesita saber exactamente cu&amp;aacute;nto tiempo &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; sobrevivir&amp;aacute;n, pero s&amp;oacute;lo eso cierto margen puede ser sustituido por &lt;code&gt;'a&lt;/code&gt; que satisfaga a esta firma.</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">La funci&amp;oacute;n que define una macro de procedimiento toma un &lt;code&gt;TokenStream&lt;/code&gt; como entrada y produce un &lt;code&gt;TokenStream&lt;/code&gt; como salida. El tipo &lt;code&gt;TokenStream&lt;/code&gt; est&amp;aacute; definido por la caja &lt;code&gt;proc_macro&lt;/code&gt; que se incluye con Rust y representa una secuencia de tokens. Este es el n&amp;uacute;cleo de la macro: el c&amp;oacute;digo fuente en el que opera la macro constituye el &lt;code&gt;TokenStream&lt;/code&gt; de entrada , y el c&amp;oacute;digo que produce la macro es el &lt;code&gt;TokenStream&lt;/code&gt; de salida . La funci&amp;oacute;n tambi&amp;eacute;n tiene un atributo adjunto que especifica qu&amp;eacute; tipo de macro de procedimiento estamos creando. Podemos tener varios tipos de macros de procedimiento en la misma caja.</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">La función nunca volverá y terminará inmediatamente el proceso actual de una manera &quot;anormal&quot; específica de la plataforma.</target>
        </trans-unit>
        <trans-unit id="0c78d2fcec6d6debbe4ef0124bd9c3f517852fce" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">La sintaxis de actualización del registro funcional sólo se permite para las estructuras.(Las variantes de enumeración de las estructuras no califican,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="771371fc3674c285662522a3ce8c91121a8eb8d5" translate="yes" xml:space="preserve">
          <source>The functional record update syntax was used on something other than a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">La funcionalidad y la sintaxis de Rust se pueden ampliar con definiciones personalizadas llamadas macros. Se les da nombres y se les invoca mediante una sintaxis coherente: &lt;code&gt;some_extension!(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">Las funciones dentro de esta estructura solo deben llamarse en el puntero de &lt;code&gt;data&lt;/code&gt; de un objeto &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; construido correctamente desde dentro de la implementaci&amp;oacute;n de &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; . Llamar a una de las funciones contenidas utilizando cualquier otro puntero de &lt;code&gt;data&lt;/code&gt; provocar&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="5d3fe931a60678fe761ffe2bfb5b03361ca50257" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0966ed788f9044d3bbbf28ed214b74382d234e" translate="yes" xml:space="preserve">
          <source>The general case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44389c2bb8540f5071dbf79b16d89782c82ab1a7" translate="yes" xml:space="preserve">
          <source>The general categories for numbers (&lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">El generado &lt;code&gt;impl&lt;/code&gt; para &lt;code&gt;PartialEq&lt;/code&gt; es equivalente a</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">El generador se completó con un valor de retorno.</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">El generador se suspendió con un valor.</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">El tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; especifica como el tipo de la &lt;code&gt;item1&lt;/code&gt; y &lt;code&gt;item2&lt;/code&gt; Par&amp;aacute;metros limita la funci&amp;oacute;n tal que el tipo de hormig&amp;oacute;n del valor pasa como argumento para &lt;code&gt;item1&lt;/code&gt; y &lt;code&gt;item2&lt;/code&gt; debe ser el mismo.</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">El tipo genérico tiene que ser un tipo SIMD.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="e58faf99c3204433210564e65725762b8514494f" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">El bloque dado debe haber sido producido por este asignador, y debe ser adecuado para almacenar una &lt;code&gt;T&lt;/code&gt; (en t&amp;eacute;rminos de alineaci&amp;oacute;n y tama&amp;ntilde;o m&amp;iacute;nimo y m&amp;aacute;ximo); de lo contrario, produce un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">El operador glob se usa a menudo cuando se prueba para poner todo bajo prueba en el m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; ; hablaremos de eso en la secci&amp;oacute;n &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;C&amp;oacute;mo escribir pruebas&amp;rdquo;&lt;/a&gt; en el Cap&amp;iacute;tulo 11. El operador glob tambi&amp;eacute;n se usa a veces como parte del patr&amp;oacute;n de preludio: consulte &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;la documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre ese patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">El asignador de memoria global.</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">La buena noticia es que si la estructura &lt;em&gt;no es&lt;/em&gt; conveniente para que otros la usen desde otra biblioteca, no tiene que reorganizar su organizaci&amp;oacute;n interna: en cambio, puede reexportar elementos para hacer una estructura p&amp;uacute;blica que sea diferente de su estructura privada. mediante el uso de &lt;code&gt;pub use&lt;/code&gt; . La reexportaci&amp;oacute;n toma un elemento p&amp;uacute;blico en una ubicaci&amp;oacute;n y lo hace p&amp;uacute;blico en otra ubicaci&amp;oacute;n, como si estuviera definido en la otra ubicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">La estructura gramatical y l&amp;eacute;xica est&amp;aacute; entre comillas en bloque con &quot;Lexer&quot; o &quot;Sintaxis&quot; en &lt;sup&gt;&lt;strong&gt;super&amp;iacute;ndice&lt;/strong&gt;&lt;/sup&gt; en &lt;sup&gt;&lt;strong&gt;negrita&lt;/strong&gt;&lt;/sup&gt; como primera l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">La producci&amp;oacute;n gramatical para patrones de referencia tiene que coincidir con el token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; para hacer coincidir una referencia con una referencia porque es un token en s&amp;iacute; mismo, no dos &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">El modelo M:N de hilos verdes requiere un mayor tiempo de ejecución del lenguaje para manejar los hilos.Por lo tanto,la biblioteca estándar de Rust sólo proporciona una implementación de hilos 1:1.Dado que Rust es un lenguaje de tan bajo nivel,hay cajas que implementan el roscado M:N si se prefiere cambiar los gastos generales por aspectos como un mayor control sobre qué hilos se ejecutan cuándo y menores costes de cambio de contexto,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">La manija para leer del error estándar del niño (stderr),si ha sido capturado.</target>
        </trans-unit>
        <trans-unit id="71a4cc891c9774ed993ea2778e2ec4e78d46aa4f" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">La manija para leer de la salida estándar del niño (stdout),si ha sido capturada.</target>
        </trans-unit>
        <trans-unit id="5b65d5fd43c0bfac48d483d2399323a0f40fd595" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">La manija para escribir en la entrada estándar del niño (stdin),si ha sido capturada.</target>
        </trans-unit>
        <trans-unit id="1008f723c1fd717a94e8a77d7bc5c5ff92ef4700" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt;, you might find it helpful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">El mapa hash se crea inicialmente con una capacidad de 0,por lo que no se asignará hasta que se inserte por primera vez en él.</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">El mapa hash podr&amp;aacute; contener al menos elementos de &lt;code&gt;capacity&lt;/code&gt; sin reasignar. Si la &lt;code&gt;capacity&lt;/code&gt; es 0, el mapa hash no se asignar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">El conjunto de hash también se crea con la capacidad inicial predeterminada.</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">El conjunto de hash se crea inicialmente con una capacidad de 0,por lo que no se asignará hasta que se inserte por primera vez.</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">El conjunto de hash podr&amp;aacute; contener al menos elementos de &lt;code&gt;capacity&lt;/code&gt; sin reasignar. Si la &lt;code&gt;capacity&lt;/code&gt; es 0, el conjunto hash no se asignar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">La implementaci&amp;oacute;n de la tabla hash es un puerto Rust de &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt; de Google . La versi&amp;oacute;n original en C ++ de SwissTable se puede encontrar &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;aqu&amp;iacute;&lt;/a&gt; , y esta &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;charla CppCon&lt;/a&gt; ofrece una descripci&amp;oacute;n general de c&amp;oacute;mo funciona el algoritmo.</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">El algoritmo de hash se puede reemplazar por &lt;code&gt;HashMap&lt;/code&gt; utilizando los m&amp;eacute;todos &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; . Muchos algoritmos alternativos est&amp;aacute;n disponibles en crates.io, como &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; crate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="142488b9261462c1e559bf3f2ad49337e31e2ac1" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc423f45ad76627b7f09d1c195dab7e2c377478" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12087b42b0b99fc1565d3b697e609feca661351" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hash_map/struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;hash_map/struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d67f06aec820d5f0416a0fabba770f0ab5392" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">El coraz&amp;oacute;n y el alma de este m&amp;oacute;dulo es el rasgo &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . El n&amp;uacute;cleo de &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; se&lt;/a&gt; ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">El meollo del cambio es que donde &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; sol&amp;iacute;a ser &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; , ahora tiene como valor predeterminado &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (aqu&amp;iacute;, &lt;code&gt;SomeTrait&lt;/code&gt; es el nombre de alg&amp;uacute;n tipo de rasgo). Tenga en cuenta que los &amp;uacute;nicos tipos que se ven afectados son las referencias a cuadros, como &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; . Los tipos m&amp;aacute;s comunes como &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; o &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; no se ven afectados.</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">El texto de ayuda revela que el tipo de retorno necesita un par&amp;aacute;metro de tiempo de vida gen&amp;eacute;rica en &amp;eacute;l porque Rust no puede decir si la referencia de ser devuelto se refiere a &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; . En realidad, tampoco lo sabemos, porque el bloque &lt;code&gt;if&lt;/code&gt; en el cuerpo de esta funci&amp;oacute;n devuelve una referencia a &lt;code&gt;x&lt;/code&gt; y el bloque &lt;code&gt;else&lt;/code&gt; devuelve una referencia a &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">El punto de c&amp;oacute;digo v&amp;aacute;lido m&amp;aacute;s alto que puede tener un &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">El gancho se proporciona con una estructura &lt;code&gt;Layout&lt;/code&gt; que contiene informaci&amp;oacute;n sobre la asignaci&amp;oacute;n que fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">El gancho se proporciona con una estructura &lt;code&gt;PanicInfo&lt;/code&gt; que contiene informaci&amp;oacute;n sobre el origen del p&amp;aacute;nico, incluida la carga &amp;uacute;til que se pasa al &lt;code&gt;panic!&lt;/code&gt; y la ubicaci&amp;oacute;n del c&amp;oacute;digo fuente desde donde se origin&amp;oacute; el p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">El identificador tiene m&amp;aacute;s de un car&amp;aacute;cter. &lt;code&gt;_&lt;/code&gt; solo no es un identificador.</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">El identificador es el nombre de la constante utilizada en el camino.El tipo es el tipo que la definición tiene que implementar.</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">El identificador es el nombre del alias de tipo declarado.Los límites de los rasgos opcionales deben ser cumplidos por las implementaciones del alias de tipo.</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">El identificador es el nombre de la función.Los genéricos,la lista de parámetros,el tipo de retorno y la cláusula de dónde de la función asociada deben ser los mismos que los de las declaraciones de la función asociada.</target>
        </trans-unit>
        <trans-unit id="c54b94a826db4a7c6ce8d411476041b69555f1aa" translate="yes" xml:space="preserve">
          <source>The identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">La forma idiom&amp;aacute;tica de escribir un &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; a&lt;/a&gt; para sus efectos secundarios es usar un bucle &lt;code&gt;for&lt;/code&gt; en su lugar:</target>
        </trans-unit>
        <trans-unit id="20b4ace5ebaf142e4e8addc0656248d8010dca32" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc3122c538d92098d293869587f4b3a0100941a" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; usa &lt;code&gt;self.0&lt;/code&gt; para acceder al &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; interno , porque &lt;code&gt;Wrapper&lt;/code&gt; es una estructura de tupla y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; es el elemento en el &amp;iacute;ndice 0 en la tupla. Entonces podemos usar la funcionalidad del tipo de &lt;code&gt;Display&lt;/code&gt; en &lt;code&gt;Wrapper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;get&lt;/code&gt; se basa, en particular, en implementaciones id&amp;eacute;nticas de &lt;code&gt;Hash&lt;/code&gt; determinando el dep&amp;oacute;sito de hash de la clave llamando a &lt;code&gt;Hash::hash&lt;/code&gt; en el valor &lt;code&gt;Q&lt;/code&gt; , aunque insert&amp;oacute; la clave en funci&amp;oacute;n del valor hash calculado a partir del valor &lt;code&gt;K&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">La implementaci&amp;oacute;n de esta funci&amp;oacute;n debe asegurarse de liberar todos los recursos asociados con esta instancia de &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; y la tarea asociada.</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n de esta funci&amp;oacute;n debe conservar todos los recursos necesarios para esta instancia adicional de &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; y la tarea asociada. Llamar a &lt;code&gt;wake&lt;/code&gt; en el &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; resultante deber&amp;iacute;a resultar en un despertar de la misma tarea que el &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; original habr&amp;iacute;a despertado .</target>
        </trans-unit>
        <trans-unit id="497d98f3948b6fc88a56b8970a7685389e682fb3" translate="yes" xml:space="preserve">
          <source>The implementation of waking a task on an executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">La implementación usando el patrón de estado es fácil de extender para añadir más funcionalidad.Para ver la simplicidad de mantener el código que utiliza el patrón de estado,pruebe algunas de estas sugerencias:</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">El tipo de implementaci&amp;oacute;n dentro de un &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; o bloque &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &amp;iacute;cito&lt;/a&gt; , o el tipo actual dentro de una definici&amp;oacute;n de tipo.</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">Los rangos de índice devueltos por este rasgo no se requieren para que coincidan exactamente con los de la búsqueda hacia adelante en reversa.</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">El operando indexado de una expresión de indexación de matrices.</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">El tipo inferido pide al compilador que infiera el tipo si es posible basándose en la información disponible del entorno.No puede ser usado en firmas de artículos.Se utiliza a menudo en argumentos genéricos:</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Los m&amp;eacute;todos inherentes de &lt;code&gt;Rc&lt;/code&gt; son todas funciones asociadas, lo que significa que debe llamarlas como, por ejemplo, &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt; lugar de &lt;code&gt;value.get_mut()&lt;/code&gt; . Esto evita conflictos con m&amp;eacute;todos del tipo interior &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd48be31dd031602338fabd7f9987080846befd" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;struct.rc#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">El valor inicial es el valor que el acumulador tendrá en la primera llamada.</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">El valor inicial es el valor que tendr&amp;aacute; el acumulador en la primera llamada. Si la aplicaci&amp;oacute;n del cierre tuvo &amp;eacute;xito contra cada elemento del iterador, &lt;code&gt;try_fold()&lt;/code&gt; devuelve el acumulador final como exitoso.</target>
        </trans-unit>
        <trans-unit id="3215ce085488e89e5b23ed55a5028caf27292850" translate="yes" xml:space="preserve">
          <source>The initializer expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">El inicializador de</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">El inicializador de una &lt;a href=&quot;statements#let-statements&quot;&gt;sentencia let&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">El &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; de&lt;/a&gt; entrada es el flujo de tokens del elemento que tiene el atributo &lt;code&gt;derive&lt;/code&gt; . El &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; de&lt;/a&gt; salida debe ser un conjunto de elementos que luego se adjuntan al &lt;a href=&quot;items/modules&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; o &lt;a href=&quot;expressions/block-expr&quot;&gt;bloque en el&lt;/a&gt; que se encuentra el elemento del &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; de&lt;/a&gt; entrada .</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">El iterador de entrada &lt;code&gt;replace_with&lt;/code&gt; solo se consume cuando se elimina el valor de &lt;code&gt;Splice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b45dbdf7cc3adb9c8ff29ad732df76183eebf5c" translate="yes" xml:space="preserve">
          <source>The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">El script de instalación añade automáticamente Rust a tu sistema PATH después de tu próximo ingreso.Si desea comenzar a usar Rust de inmediato en lugar de reiniciar su terminal,ejecute el siguiente comando en su shell para agregar Rust al PATH del sistema manualmente:</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">El instalador tambi&amp;eacute;n incluye una copia de la documentaci&amp;oacute;n localmente, para que pueda leerla sin conexi&amp;oacute;n. Ejecute &lt;code&gt;rustup doc&lt;/code&gt; para abrir la documentaci&amp;oacute;n local en su navegador.</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">Los tipos integrales proporcionan m&amp;eacute;todos inherentes para permitir a los programadores realizar expl&amp;iacute;citamente aritm&amp;eacute;tica de envoltura. Por ejemplo, &lt;code&gt;i32::wrapping_add&lt;/code&gt; proporciona complemento de dos, suma de envoltura.</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">La secci&amp;oacute;n de pruebas de integraci&amp;oacute;n comienza con la l&amp;iacute;nea &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (el hash al final de tu salida ser&amp;aacute; diferente). A continuaci&amp;oacute;n, hay una l&amp;iacute;nea para cada funci&amp;oacute;n de prueba en esa prueba de integraci&amp;oacute;n y una l&amp;iacute;nea de resumen para los resultados de la prueba de integraci&amp;oacute;n justo antes de que comience la secci&amp;oacute;n &lt;code&gt;Doc-tests adder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">La intenci&amp;oacute;n es que los datos subyacentes solo sean v&amp;aacute;lidos durante la vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; , por lo que &lt;code&gt;Slice&lt;/code&gt; no deber&amp;iacute;a sobrevivir a &lt;code&gt;'a&lt;/code&gt; . Sin embargo, esta intenci&amp;oacute;n no se expresa en el c&amp;oacute;digo, ya que no hay usos de la vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; ay, por lo tanto, no est&amp;aacute; claro a qu&amp;eacute; datos se aplica. Podemos corregir esto dici&amp;eacute;ndole al compilador que act&amp;uacute;e &lt;em&gt;como si&lt;/em&gt; la estructura &lt;code&gt;Slice&lt;/code&gt; contuviera una referencia &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">El algoritmo interno no está especificado,por lo que no se debe confiar en él ni en sus hashes por encima de las liberaciones.</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">El buffer interno se escribe antes de devolver al escritor.</target>
        </trans-unit>
        <trans-unit id="06716cd4a735b362271ebfeb2853eaa89b39ee1b" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">El iterador interno sobre el argumento no ha avanzado en el momento en que se ve el primer &lt;code&gt;{}&lt;/code&gt; , por lo que imprime el primer argumento. Luego, al llegar al segundo &lt;code&gt;{}&lt;/code&gt; , el iterador avanz&amp;oacute; hasta el segundo argumento. Esencialmente, los par&amp;aacute;metros que nombran expl&amp;iacute;citamente su argumento no afectan los par&amp;aacute;metros que no nombran un argumento en t&amp;eacute;rminos de especificadores posicionales.</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El inverso de este m&amp;eacute;todo es &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El inverso de este m&amp;eacute;todo es &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ef5a2c8bf418a538796f28bdc7b3ed8b4214bec" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00033d91f205bb0450cf7878d82bad2da288007b" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5754a49ec3bccb9874e0108120d01b2fee9ec9" translate="yes" xml:space="preserve">
          <source>The issue can be resolved by changing the associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">El problema en este caso es que &lt;code&gt;foo&lt;/code&gt; se define como la aceptaci&amp;oacute;n de una &lt;code&gt;Fn&lt;/code&gt; con un argumento de tipo &lt;code&gt;String&lt;/code&gt; , pero el cierre que intentamos pasar requiere un argumento de tipo &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">El problema con el c&amp;oacute;digo de tupla en el Listado 4-5 es que tenemos que devolver la &lt;code&gt;String&lt;/code&gt; a la funci&amp;oacute;n de llamada para que podamos seguir usando la &lt;code&gt;String&lt;/code&gt; despu&amp;eacute;s de la llamada a &lt;code&gt;calculate_length&lt;/code&gt; , porque la &lt;code&gt;String&lt;/code&gt; se movi&amp;oacute; a &lt;code&gt;calculate_length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">El problema con este c&amp;oacute;digo es evidente en la firma del &lt;code&gt;area&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">Los elementos de los rasgos marcadores no pueden ser anulados,por lo que no hay necesidad de tenerlos cuando no pueden ser cambiados por tipo de todos modos.Si los quieres por razones ergonómicas,considera hacer un rasgo de extensión en su lugar.</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de elemento iterador es &lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">El iterador debe producir exactamente el número de elementos que ha reportado o divergir antes de llegar al final.</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">El patr&amp;oacute;n de iterador le permite realizar alguna tarea en una secuencia de elementos a su vez. Un iterador es responsable de la l&amp;oacute;gica de iterar sobre cada elemento y determinar cu&amp;aacute;ndo ha terminado la secuencia. Cuando usa iteradores, no tiene que volver a implementar esa l&amp;oacute;gica usted mismo.</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">El iterador informa una sugerencia de tama&amp;ntilde;o donde es exacto (el l&amp;iacute;mite inferior es igual al l&amp;iacute;mite superior) o el l&amp;iacute;mite superior es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . El l&amp;iacute;mite superior solo debe ser &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; si la longitud real del iterador es mayor que &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; . En ese caso, el l&amp;iacute;mite inferior debe ser &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; , lo que da como resultado un &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; de &lt;code&gt;(usize::MAX, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761f99bb11c75b1d69af8441ba4ad3812f9ffc53" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">El iterador devuelto por esta funci&amp;oacute;n devolver&amp;aacute; instancias de &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Cada vector devuelto &lt;em&gt;no&lt;/em&gt; tendr&amp;aacute; el byte delimitador al final.</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">El iterador devuelto por esta funci&amp;oacute;n producir&amp;aacute; instancias de &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Cada cadena devuelta &lt;em&gt;no&lt;/em&gt; tendr&amp;aacute; un byte de nueva l&amp;iacute;nea (el byte 0xA) o CRLF (0xD, 0xA bytes) al final.</target>
        </trans-unit>
        <trans-unit id="11be39dc954e81f8e71f68fa0b756ad22ee17df7" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; (&lt;code&gt;0xD&lt;/code&gt;, &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">El iterador devuelto devolverá rebanadas de cadena que son sub-rebanadas de la rebanada de cadena original,separadas por cualquier cantidad de espacio blanco ASCII.</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">El iterador devuelto devolverá rebanadas de cadena que son sub-rebanadas de la rebanada de cadena original,separadas por cualquier cantidad de espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">El iterador devuelto produce pares &lt;code&gt;(i, val)&lt;/code&gt; , donde &lt;code&gt;i&lt;/code&gt; es el &amp;iacute;ndice actual de iteraci&amp;oacute;n y &lt;code&gt;val&lt;/code&gt; es el valor devuelto por el iterador.</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">El iterador comienza con el primer elemento dado (si lo hay) y llama al &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; dado para calcular el sucesor de cada elemento.</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">&amp;iexcl;La versi&amp;oacute;n iteradora fue un poco m&amp;aacute;s r&amp;aacute;pida! No explicaremos el c&amp;oacute;digo de referencia aqu&amp;iacute;, porque el punto no es demostrar que las dos versiones son equivalentes, sino tener una idea general de c&amp;oacute;mo estas dos implementaciones se comparan en t&amp;eacute;rminos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">El iterador nunca devolver&amp;aacute; &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; y tampoco &lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; estructura SocketAddr del par .</target>
        </trans-unit>
        <trans-unit id="1eb81e5b136891ec83f03fa70901b0982c774c3e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">El iterador producir&amp;aacute; instancias de &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Se pueden encontrar nuevos errores despu&amp;eacute;s de la construcci&amp;oacute;n inicial de un iterador.</target>
        </trans-unit>
        <trans-unit id="fea22bab4e7d7d638613556e79b891a323ca2ee5" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54667f9a5f59c23223b23e9276c48f67c43aae4e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">El iterador producir&amp;aacute; instancias de &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Se pueden encontrar nuevos errores despu&amp;eacute;s de la construcci&amp;oacute;n inicial de un iterador.</target>
        </trans-unit>
        <trans-unit id="6720eac87f145ca4ebd08c14afcbc3e18eb5bc63" translate="yes" xml:space="preserve">
          <source>The iterator will yield the &lt;code&gt;Path&lt;/code&gt; that is returned if the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method is used zero or more times. That means, the iterator will yield &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; and so on. If the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will do likewise. The iterator will always yield at least one value, namely &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">El iterador producir&amp;aacute; la &lt;code&gt;Path&lt;/code&gt; que se devuelve si el m&amp;eacute;todo &lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt; se usa cero o m&amp;aacute;s veces. Eso significa que el iterador producir&amp;aacute; &lt;code&gt;&amp;amp;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt; , &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; y as&amp;iacute; sucesivamente. Si el m&amp;eacute;todo &lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt; devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , el iterador har&amp;aacute; lo mismo. El iterador siempre producir&amp;aacute; al menos un valor, a saber, &lt;code&gt;&amp;amp;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36ed296a3da7075e704c60a55541d4eefcc61a2e" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">El iterador produce un valor si la &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; es un&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; , de lo contrario, ninguno.</target>
        </trans-unit>
        <trans-unit id="33a7221657feedb4eb9bdbc29b15b1cfdbff0941" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">El iterador produce un valor si el resultado es &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , de lo contrario, ninguno.</target>
        </trans-unit>
        <trans-unit id="98fcd488b58bec9ba13c409525786e8e34d2f3d0" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908b09e4328c560c75c00a1be9bba8fa3c1792fa" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">El iterador produce un valor si el resultado es &lt;a href=&quot;enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , de lo contrario, ninguno.</target>
        </trans-unit>
        <trans-unit id="8fd298b9ad5df85747acb6e44bba1366e3481860" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">El iterador produce un valor si el resultado es &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; , de lo contrario, ninguno.</target>
        </trans-unit>
        <trans-unit id="41c263ba9c3e1377bcbb306e69ddac6adfb8f150" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80110840b4186388c3ebdd6fff4960efb23a3ca" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">El iterador produce tuplas. La posici&amp;oacute;n es primero, el &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; es la segunda.</target>
        </trans-unit>
        <trans-unit id="6ec1542f766c1ecbdef3897acebe4cebd30ca6ee" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787f68c0ad38019edb27d78451a4d5831f65e4ab" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">El iterador produce tuplas. La posici&amp;oacute;n es primero, el &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; es la segunda.</target>
        </trans-unit>
        <trans-unit id="10db2a64e13645a875ad4c150b72d85dec4465d0" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6814fb791ef3836a2e395759e70c2ff3a369ee11" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;read_line&lt;/code&gt; is to take whatever the user types into standard input and place that into a string, so it takes that string as an argument. The string argument needs to be mutable so the method can change the string&amp;rsquo;s content by adding the user input.</source>
          <target state="translated">El trabajo de &lt;code&gt;read_line&lt;/code&gt; es tomar lo que el usuario escriba en la entrada est&amp;aacute;ndar y colocarlo en una cadena, por lo que toma esa cadena como argumento. El argumento de la cadena debe ser mutable para que el m&amp;eacute;todo pueda cambiar el contenido de la cadena agregando la entrada del usuario.</target>
        </trans-unit>
        <trans-unit id="41c36730094f242762fc2db352770667844d977d" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7b114b0c6414134b72184594654a5acaffb577" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El identificador de combinaci&amp;oacute;n &lt;em&gt;separar&amp;aacute;&lt;/em&gt; impl&amp;iacute;citamente el subproceso secundario al soltarse. En este caso, el hilo secundario puede sobrevivir al padre (a menos que el hilo principal sea el hilo principal; todo el proceso finaliza cuando finaliza el hilo principal). Adem&amp;aacute;s, el identificador de combinaci&amp;oacute;n proporciona un m&amp;eacute;todo de &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; que se puede utilizar para unir el subproceso secundario. Si el subproceso secundario entra en p&amp;aacute;nico, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; un &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; que&lt;/a&gt; contiene el argumento dado a&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="099a2e1e2bdb72897b42735f9f375efdb1e2c049" translate="yes" xml:space="preserve">
          <source>The key line in this error is &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt;. With our non-generic versions of the &lt;code&gt;largest&lt;/code&gt; function, we were only trying to find the largest &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. As discussed in the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4, types like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; that have a known size can be stored on the stack, so they implement the &lt;code&gt;Copy&lt;/code&gt; trait. But when we made the &lt;code&gt;largest&lt;/code&gt; function generic, it became possible for the &lt;code&gt;list&lt;/code&gt; parameter to have types in it that don&amp;rsquo;t implement the &lt;code&gt;Copy&lt;/code&gt; trait. Consequently, we wouldn&amp;rsquo;t be able to move the value out of &lt;code&gt;list[0]&lt;/code&gt; and into the &lt;code&gt;largest&lt;/code&gt; variable, resulting in this error.</source>
          <target state="translated">La l&amp;iacute;nea clave de este error es &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt; se puede mover fuera del tipo [T], un segmento sin copia . Con nuestras versiones no gen&amp;eacute;ricas de la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; , solo intent&amp;aacute;bamos encontrar el &lt;code&gt;i32&lt;/code&gt; o &lt;code&gt;char&lt;/code&gt; m&amp;aacute;s grande . Como se discuti&amp;oacute; en la secci&amp;oacute;n &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Datos solo apilados: Copiar&amp;rdquo;&lt;/a&gt; en el Cap&amp;iacute;tulo 4, tipos como &lt;code&gt;i32&lt;/code&gt; y &lt;code&gt;char&lt;/code&gt; que tienen un tama&amp;ntilde;o conocido pueden almacenarse en la pila, por lo que implementan el rasgo &lt;code&gt;Copy&lt;/code&gt; . Pero cuando hicimos gen&amp;eacute;rica la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; , se hizo posible para el rasgo de &lt;code&gt;list&lt;/code&gt; a par&amp;aacute;metro de tuviera tipos que no implementan la &lt;code&gt;Copy&lt;/code&gt; . En consecuencia, no podr&amp;iacute;amos mover el valor de la &lt;code&gt;list[0]&lt;/code&gt; al &lt;code&gt;largest&lt;/code&gt; variable, lo que resulta en este error.</target>
        </trans-unit>
        <trans-unit id="bceeadadeee15f4a164537fd341fe02f08db51ce" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">La clave puede ser cualquier forma prestada del tipo de clave del mapa, pero &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; en la forma prestada &lt;em&gt;deben&lt;/em&gt; coincidir con los del tipo de clave.</target>
        </trans-unit>
        <trans-unit id="1967c0afcde1ba185b21a2a66c76557126c2a896" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">La clave puede ser cualquier forma prestada del tipo de clave del mapa, pero &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; en la forma prestada &lt;em&gt;deben&lt;/em&gt; coincidir con los del tipo de clave.</target>
        </trans-unit>
        <trans-unit id="25f3fabcbbf37a65231d46a27fb9b7a82a76e913" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">La clave puede ser cualquier forma prestada del tipo de clave del mapa, pero el orden en el formulario prestado &lt;em&gt;debe&lt;/em&gt; coincidir con el orden en el tipo de clave.</target>
        </trans-unit>
        <trans-unit id="5794a7e2452d7c2d7acdcd9ca75f9f681dde7e71" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">La propiedad clave de las uniones es que todos los campos de una unión comparten un almacenamiento común.Como resultado,los escritos de un campo de una unión pueden sobrescribir sus otros campos,y el tamaño de una unión se determina por el tamaño de su campo más grande.</target>
        </trans-unit>
        <trans-unit id="af36c49ed669c54fb87fd9d4d2b45f5df4d5de97" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730d38429c1bd8714c2ac7995eb67557271f3b30" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;pub&lt;/code&gt; makes any module, function, or data structure accessible from inside of external modules. The &lt;code&gt;pub&lt;/code&gt; keyword may also be used in a &lt;code&gt;use&lt;/code&gt; declaration to re-export an identifier from a namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6097954d2b4ff2c7af7f3ee3f3f7074587267681" translate="yes" xml:space="preserve">
          <source>The kinds of patterns for parameters is limited to one of the following:</source>
          <target state="translated">Los tipos de patrones de los parámetros se limitan a uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="9150d911250adb9488a9891d8d1a7dd89c179545" translate="yes" xml:space="preserve">
          <source>The lack of infinite output indicates that this code didn&amp;rsquo;t create a reference cycle. We can also tell this by looking at the values we get from calling &lt;code&gt;Rc::strong_count&lt;/code&gt; and &lt;code&gt;Rc::weak_count&lt;/code&gt;.</source>
          <target state="translated">La falta de salida infinita indica que este c&amp;oacute;digo no cre&amp;oacute; un ciclo de referencia. Tambi&amp;eacute;n podemos saber esto mirando los valores que obtenemos al llamar a &lt;code&gt;Rc::strong_count&lt;/code&gt; y &lt;code&gt;Rc::weak_count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0cd1d95a878dd3fb3eb033669531c63a686db3" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e53524d7493db6ac00628d4141587167732e22" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</source>
          <target state="translated">El atributo lang est&amp;aacute; destinado a marcar elementos especiales que est&amp;aacute;n integrados en el propio Rust. Esto incluye rasgos especiales (como &lt;code&gt;Copy&lt;/code&gt; y &lt;code&gt;Sized&lt;/code&gt; ) que afectan el comportamiento del compilador, as&amp;iacute; como funciones especiales que pueden invocarse autom&amp;aacute;ticamente (como el controlador para accesos fuera de l&amp;iacute;mites al indexar un segmento). Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="080a1610af4bccfcd8725cb110cddf449fbd60f7" translate="yes" xml:space="preserve">
          <source>The lang attribute was used in an invalid context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d001aa0e948f210ef67db3ed9f1079f66965d658" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type.</source>
          <target state="translated">El mayor valor que puede ser representado por este tipo de entero.</target>
        </trans-unit>
        <trans-unit id="55a17e21fb4394b20facf75f686648a8590b11f1" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73325de7bc5986e41ec8d92ed9701ddacd280f3" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7bb87b47e7f2c22de123ec199f4be989c0dcaf2" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf18dde926e284162a660a1b1a2a30b118d1c49a" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22c4dd542e2ceff2527d706e65d0c5acc6f4d52" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2e67766c1f950d1a3f862bddde0bc78e36aacd" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697ca9e8dc5fcb1feb5a529df70222ec030c2428" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23128039031afffa375e1d18e6f18c10d1470457" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cead8aa8b3423346a603591b8a3bb3bb38de07d" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdca1f692589c69870c6eba29a4be248c639ebc" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1cfd44e67cca085f5a9478c1e9579b369e52ad" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c52af57b6ca83f430b64beb1abd9c9176989341" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bab83aeec1382113d53e6e7d14863dd49ec843d" translate="yes" xml:space="preserve">
          <source>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call &lt;code&gt;borrow&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; to get an immutable reference to the vector.</source>
          <target state="translated">El &amp;uacute;ltimo cambio que tenemos que hacer es en la aserci&amp;oacute;n: para ver cu&amp;aacute;ntos elementos hay en el vector interno, llamamos a &lt;code&gt;borrow&lt;/code&gt; en &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; para obtener una referencia inmutable al vector.</target>
        </trans-unit>
        <trans-unit id="b92b068be4c2b594134000422ae50b8df0c8bac3" translate="yes" xml:space="preserve">
          <source>The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</source>
          <target state="translated">La última diferencia es que las constantes pueden fijarse sólo a una expresión constante,no al resultado de una llamada a una función o a cualquier otro valor que sólo pueda ser computado en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="293474ffe041aff8a994854d8cad3ac993cf31b4" translate="yes" xml:space="preserve">
          <source>The last element returned, if any, will contain the remainder of the slice.</source>
          <target state="translated">El último elemento devuelto,si es que hay alguno,contendrá el resto de la rebanada.</target>
        </trans-unit>
        <trans-unit id="8d491eebdf550e16362be621e1476cb5ece9206f" translate="yes" xml:space="preserve">
          <source>The last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El &amp;uacute;ltimo campo de &lt;code&gt;Foo&lt;/code&gt; tiene un tipo que involucra a &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf70627b4e81c57a3ddc9f76311bc0b01f381dcd" translate="yes" xml:space="preserve">
          <source>The last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">La &amp;uacute;ltima l&amp;iacute;nea de la salida muestra la ubicaci&amp;oacute;n y el nombre del binario instalado, que en el caso de &lt;code&gt;ripgrep&lt;/code&gt; es &lt;code&gt;rg&lt;/code&gt; . Siempre que el directorio de instalaci&amp;oacute;n est&amp;eacute; en su &lt;code&gt;$PATH&lt;/code&gt; , como se mencion&amp;oacute; anteriormente, puede ejecutar &lt;code&gt;rg --help&lt;/code&gt; y comenzar a usar una herramienta m&amp;aacute;s r&amp;aacute;pida y oxidada para buscar archivos.</target>
        </trans-unit>
        <trans-unit id="3dc7b6a27a6191be06711a90615e83b643711efc" translate="yes" xml:space="preserve">
          <source>The last line shows that &lt;code&gt;&amp;amp;bar&lt;/code&gt; is not a function pointer either. Rather, it is a reference to the function-specific ZST. &lt;code&gt;&amp;amp;bar&lt;/code&gt; is basically never what you want when &lt;code&gt;bar&lt;/code&gt; is a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982060970609630bdcfd3dbdc543a9a98b2de24a" translate="yes" xml:space="preserve">
          <source>The last line, &lt;code&gt;[dependencies]&lt;/code&gt;, is the start of a section for you to list any of your project&amp;rsquo;s dependencies. In Rust, packages of code are referred to as &lt;em&gt;crates&lt;/em&gt;. We won&amp;rsquo;t need any other crates for this project, but we will in the first project in Chapter 2, so we&amp;rsquo;ll use this dependencies section then.</source>
          <target state="translated">La &amp;uacute;ltima l&amp;iacute;nea, &lt;code&gt;[dependencies]&lt;/code&gt; , es el comienzo de una secci&amp;oacute;n para que enumere cualquiera de las dependencias de su proyecto. En Rust, los paquetes de c&amp;oacute;digo se denominan &lt;em&gt;cajas&lt;/em&gt; . No necesitaremos ninguna otra caja para este proyecto, pero lo haremos en el primer proyecto del Cap&amp;iacute;tulo 2, as&amp;iacute; que usaremos esta secci&amp;oacute;n de dependencias.</target>
        </trans-unit>
        <trans-unit id="c8d286da9b3987ef73f4d9e79523c9888a168257" translate="yes" xml:space="preserve">
          <source>The last of our common collections is the &lt;em&gt;hash map&lt;/em&gt;. The type &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; stores a mapping of keys of type &lt;code&gt;K&lt;/code&gt; to values of type &lt;code&gt;V&lt;/code&gt;. It does this via a &lt;em&gt;hashing function&lt;/em&gt;, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.</source>
          <target state="translated">La &amp;uacute;ltima de nuestras colecciones comunes es el &lt;em&gt;mapa hash&lt;/em&gt; . El tipo &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; tiendas de un mapeo de teclas de tipo &lt;code&gt;K&lt;/code&gt; para valores de tipo &lt;code&gt;V&lt;/code&gt; . Lo hace mediante una &lt;em&gt;funci&amp;oacute;n hash&lt;/em&gt; , que determina c&amp;oacute;mo coloca estas claves y valores en la memoria. Muchos lenguajes de programaci&amp;oacute;n admiten este tipo de estructura de datos, pero a menudo usan un nombre diferente, como hash, mapa, objeto, tabla hash, diccionario o matriz asociativa, solo por nombrar algunos.</target>
        </trans-unit>
        <trans-unit id="e50377e1cc3271006121b6b6e503348b95075085" translate="yes" xml:space="preserve">
          <source>The last part is the HTTP version the client uses, and then the request line ends in a &lt;em&gt;CRLF sequence&lt;/em&gt;. (CRLF stands for &lt;em&gt;carriage return&lt;/em&gt; and &lt;em&gt;line feed&lt;/em&gt;, which are terms from the typewriter days!) The CRLF sequence can also be written as &lt;code&gt;\r\n&lt;/code&gt;, where &lt;code&gt;\r&lt;/code&gt; is a carriage return and &lt;code&gt;\n&lt;/code&gt; is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">La &amp;uacute;ltima parte es la versi&amp;oacute;n HTTP que usa el cliente, y luego la l&amp;iacute;nea de solicitud termina en una &lt;em&gt;secuencia CRLF&lt;/em&gt; . (&amp;iexcl;CRLF significa &lt;em&gt;retorno de carro&lt;/em&gt; y &lt;em&gt;salto de l&amp;iacute;nea&lt;/em&gt; , que son t&amp;eacute;rminos de los d&amp;iacute;as de la m&amp;aacute;quina de escribir!) La secuencia CRLF tambi&amp;eacute;n se puede escribir como &lt;code&gt;\r\n&lt;/code&gt; , donde &lt;code&gt;\r&lt;/code&gt; es un retorno de carro y &lt;code&gt;\n&lt;/code&gt; es un salto de l&amp;iacute;nea. La secuencia CRLF separa la l&amp;iacute;nea de solicitud del resto de los datos de la solicitud. Tenga en cuenta que cuando se imprime el CRLF, vemos que comienza una nueva l&amp;iacute;nea en lugar de &lt;code&gt;\r\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f87628bb5e91d33e6ee47cc631179039d310fa" translate="yes" xml:space="preserve">
          <source>The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</source>
          <target state="translated">La disposición de un tipo es su tamaño,su alineación y las compensaciones relativas de sus campos.Para los enums,la forma en que el discriminante se presenta e interpreta es también parte de la disposición del tipo.</target>
        </trans-unit>
        <trans-unit id="bb7242c48b73507f4d4792c2cb29fe84ab3a4519" translate="yes" xml:space="preserve">
          <source>The layout of allocation request that failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81ce81ead59e71cfd072129a8c87907148c562c" translate="yes" xml:space="preserve">
          <source>The left operand of an &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;assignment&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt; expression.</source>
          <target state="translated">El operando izquierdo de una &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;asignaci&amp;oacute;n&lt;/a&gt; o expresi&amp;oacute;n de &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;asignaci&amp;oacute;n compuesta&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c0d113ddd28e543817cdc902e3988c72a15e13a" translate="yes" xml:space="preserve">
          <source>The left shift assignment operator &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de turno izquierdo &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="553d8d3f55b49cb8907e0699dd0a3d9c13298c80" translate="yes" xml:space="preserve">
          <source>The left shift operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; and &lt;code&gt;a.shl(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">El operador de cambio a la izquierda &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; . Tenga en cuenta que debido a que este rasgo se implementa para todos los tipos de enteros con m&amp;uacute;ltiples tipos del lado derecho, el verificador de tipo de Rust tiene un manejo especial para &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt; , estableciendo el tipo de resultado para operaciones enteras en el tipo del operando del lado izquierdo . Esto significa que aunque &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; y &lt;code&gt;a.shl(b)&lt;/code&gt; son una y la misma desde un punto de vista de evaluaci&amp;oacute;n, que son diferentes cuando se trata de la inferencia de tipos.</target>
        </trans-unit>
        <trans-unit id="abb83d0dbf2481e1c0cc0aff75ee4837acd9c8fb" translate="yes" xml:space="preserve">
          <source>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</source>
          <target state="translated">El lado izquierdo de una expresión de asignación compuesta debe ser una expresión de lugar.Una expresión de lugar representa una ubicación de memoria e incluye rutas de elementos (es decir,variables con nombres),derivaciones,expresiones de indexación y referencias de campo.</target>
        </trans-unit>
        <trans-unit id="9df6999a3c0f46759818b5fb8abefef29f79e559" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</source>
          <target state="translated">El lado izquierdo de un operador de asignación debe ser una expresión del lugar.Una expresión espacial representa un lugar de memoria y puede ser una variable (con espaciado de nombres opcional),una derivación,una expresión de indexación o una referencia de campo.</target>
        </trans-unit>
        <trans-unit id="e2c37a7f1d5752be8f4a3cd4c10444c370f709c8" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583ea3cae577825fe984e0b2dabdc2098e762a9c" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the operating system. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">La longitud es la cantidad de memoria, en bytes, que utiliza actualmente el contenido de &lt;code&gt;String&lt;/code&gt; . La capacidad es la cantidad total de memoria, en bytes, que &lt;code&gt;String&lt;/code&gt; ha recibido del sistema operativo. La diferencia entre longitud y capacidad es importante, pero no en este contexto, por lo que, por ahora, est&amp;aacute; bien ignorar la capacidad.</target>
        </trans-unit>
        <trans-unit id="bec01c75ecf9080484e0035ecb4817690e9d17fa" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;other&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">La longitud del &lt;code&gt;other&lt;/code&gt; debe ser la misma que la de &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d3c6c04d874a34e3f73cf44da542c5ee7d39510" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;src&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">La longitud de &lt;code&gt;src&lt;/code&gt; debe ser la misma que &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ae40e336b72c0149684750f73301547acc7603" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b0bfaafe677ff19be99641d06a9d0388b357ef" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified. Erroneous code example:</source>
          <target state="translated">No se especific&amp;oacute; la longitud de la funci&amp;oacute;n intr&amp;iacute;nseca de la plataforma &lt;code&gt;simd_shuffle&lt;/code&gt; . Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="2e4dc711d20d353ed60fc2eb7d0105870f230a29" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;. As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe8cad4da628228b8d9a6730b144662e5d5b147" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;; As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">La longitud devuelta es la del almacenamiento subyacente utilizado por &lt;code&gt;OsStr&lt;/code&gt; ; Como se discuti&amp;oacute; en la introducci&amp;oacute;n de &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;OsStr&lt;/code&gt; almacenan cadenas en una forma m&amp;aacute;s adecuada para la interconversi&amp;oacute;n barata entre la plataforma nativa y las formas de cadena Rust, que pueden diferir significativamente de ambas, incluso en tama&amp;ntilde;o de almacenamiento y codificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f60b6a38bf38c34c5675869a8bbe49e47496b10f" translate="yes" xml:space="preserve">
          <source>The level is equal to &lt;code&gt;SOL_SOCKET&lt;/code&gt; and the type is equal to &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; or &lt;code&gt;SCM_CREDS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be4076f729c77100ef1624a826253f7fce0e4b7" translate="yes" xml:space="preserve">
          <source>The level is equal to &lt;code&gt;SOL_SOCKET&lt;/code&gt; and the type is equal to &lt;code&gt;SCM_RIGHTS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a0d51daa7130da604f883d5259ae5835cb10c2" translate="yes" xml:space="preserve">
          <source>The lifetime bound for this object type cannot be deduced from context and must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71866b1db7de253967c22f08d6dc545dfcd4182b" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for &lt;code&gt;bar()&lt;/code&gt; implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30238ceba60deefc79cfa25b4649d1a595edd0d8" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">La restricci&amp;oacute;n de tiempo de vida &lt;code&gt;'b&lt;/code&gt; para la implementaci&amp;oacute;n de bar () no coincide con la declaraci&amp;oacute;n del rasgo. Aseg&amp;uacute;rese de que las declaraciones de por vida coincidan exactamente tanto en la declaraci&amp;oacute;n de caracter&amp;iacute;sticas como en la implementaci&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="61076c57b01b556a6cbf075ae8202a67124b97eb" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have</source>
          <target state="translated">Las reglas de elisión de vida requieren que cualquier firma de función con una vida de salida eludida debe tener</target>
        </trans-unit>
        <trans-unit id="15fb2549a777717fb62ea70833166d18eb32b15d" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7914129f994f43353c3efa7974019d9a960355fb" translate="yes" xml:space="preserve">
          <source>The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation.</source>
          <target state="translated">La vida útil de la rebanada devuelta se deduce de su uso.Para evitar un uso indebido accidental,se sugiere vincular la vida útil con la vida útil de la fuente que sea segura en el contexto,por ejemplo,proporcionando una función de ayuda que tome la vida útil de un valor huésped para la rebanada,o mediante una anotación explícita.</target>
        </trans-unit>
        <trans-unit id="af0f1e1de97ff5087fa423eab95c1e381b7b3ee8" translate="yes" xml:space="preserve">
          <source>The lifetime of the returned &lt;code&gt;Cursor&lt;/code&gt; is bound to that of the &lt;code&gt;CursorMut&lt;/code&gt;, which means it cannot outlive the &lt;code&gt;CursorMut&lt;/code&gt; and that the &lt;code&gt;CursorMut&lt;/code&gt; is frozen for the lifetime of the &lt;code&gt;Cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57046a8e7fbf89990ae303fb2235f525d1c99061" translate="yes" xml:space="preserve">
          <source>The lifetime parameter declaration after &lt;code&gt;impl&lt;/code&gt; and its use after the type name are required, but we&amp;rsquo;re not required to annotate the lifetime of the reference to &lt;code&gt;self&lt;/code&gt; because of the first elision rule.</source>
          <target state="translated">Se requiere la declaraci&amp;oacute;n del par&amp;aacute;metro de duraci&amp;oacute;n despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; y su uso despu&amp;eacute;s del nombre del tipo, pero no estamos obligados a anotar la duraci&amp;oacute;n de la referencia a &lt;code&gt;self&lt;/code&gt; debido a la primera regla de elisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="37f7629efc4022ff5cf0b561478f77607b602987" translate="yes" xml:space="preserve">
          <source>The lifetime parameters of the method do not match the trait declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f07422d02861a626046c58ce643a2a52da0ac8" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; is an error message intended for programmers. It won&amp;rsquo;t help our end users understand what happened and what they should do instead. Let&amp;rsquo;s fix that now.</source>
          <target state="translated">El &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; l&amp;iacute;nea est&amp;aacute; fuera de l&amp;iacute;mites: el len es 1 pero el &amp;iacute;ndice es 1 es un mensaje de error destinado a los programadores. No ayudar&amp;aacute; a nuestros usuarios finales a comprender qu&amp;eacute; sucedi&amp;oacute; y qu&amp;eacute; deber&amp;iacute;an hacer en su lugar. Arreglemos eso ahora.</target>
        </trans-unit>
        <trans-unit id="5a0147b8f24f32bab15f7fb8959607d1c4391ac2" translate="yes" xml:space="preserve">
          <source>The line is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1c3b88f137cbbbccea4f427174e92d6650dd55" translate="yes" xml:space="preserve">
          <source>The lines execute in the order in which they appear in the &lt;code&gt;main&lt;/code&gt; function. First, the &amp;ldquo;Hello, world!&amp;rdquo; message prints, and then &lt;code&gt;another_function&lt;/code&gt; is called and its message is printed.</source>
          <target state="translated">Las l&amp;iacute;neas se ejecutan en el orden en que aparecen en la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; . Primero, el mensaje &quot;&amp;iexcl;Hola, mundo!&quot; imprime el mensaje y, a continuaci&amp;oacute;n &lt;code&gt;another_function&lt;/code&gt; se llama y se imprime su mensaje.</target>
        </trans-unit>
        <trans-unit id="a2f50a40f788fe52620261459fe43b43f06256a8" translate="yes" xml:space="preserve">
          <source>The linkage of the C runtime is configured to respect the &lt;code&gt;crt-static&lt;/code&gt; target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</source>
          <target state="translated">El enlace del tiempo de ejecuci&amp;oacute;n de C est&amp;aacute; configurado para respetar la funci&amp;oacute;n de destino &lt;code&gt;crt-static&lt;/code&gt; . Estas caracter&amp;iacute;sticas de destino generalmente se configuran desde la l&amp;iacute;nea de comandos a trav&amp;eacute;s de indicadores hasta el propio compilador. Por ejemplo, para habilitar un tiempo de ejecuci&amp;oacute;n est&amp;aacute;tico, ejecutar&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="efca89d0995e1ff0c39cef27089410685b77deb1" translate="yes" xml:space="preserve">
          <source>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement &lt;code&gt;derive&lt;/code&gt; for their own traits, making the list of traits you can use &lt;code&gt;derive&lt;/code&gt; with truly open-ended. Implementing &lt;code&gt;derive&lt;/code&gt; involves using a procedural macro, which is covered in the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section of Chapter 19.</source>
          <target state="translated">La lista de rasgos derivables proporcionada en este ap&amp;eacute;ndice no es exhaustiva: las bibliotecas pueden implementar &lt;code&gt;derive&lt;/code&gt; para sus propios rasgos, haciendo que la lista de rasgos que puede usar &lt;code&gt;derive&lt;/code&gt; sea verdaderamente abierta. La implementaci&amp;oacute;n de &lt;code&gt;derive&lt;/code&gt; implica el uso de una macro de procedimiento, que se trata en la secci&amp;oacute;n &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&quot;Macros&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 19.</target>
        </trans-unit>
        <trans-unit id="e9a2965c85bdbd082d28a62c5ab1cef15f730b46" translate="yes" xml:space="preserve">
          <source>The list of types is:</source>
          <target state="translated">La lista de tipos es:</target>
        </trans-unit>
        <trans-unit id="91f214c30e2ceb29652b72be6f5c77765c1026b7" translate="yes" xml:space="preserve">
          <source>The literal characters &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; may be included in a string by preceding them with the same character. For example, the &lt;code&gt;{&lt;/code&gt; character is escaped with &lt;code&gt;{{&lt;/code&gt; and the &lt;code&gt;}&lt;/code&gt; character is escaped with &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">Los caracteres literales &lt;code&gt;{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; pueden incluirse en una cadena precedi&amp;eacute;ndolos con el mismo car&amp;aacute;cter. Por ejemplo, el car&amp;aacute;cter &lt;code&gt;{&lt;/code&gt; se escapa con &lt;code&gt;{{&lt;/code&gt; y el car&amp;aacute;cter &lt;code&gt;}&lt;/code&gt; se escapa con &lt;code&gt;}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5be7b0512e1a505e9266eb524c4b5165ed24536" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired at this time because the operation would otherwise block.</source>
          <target state="translated">La cerradura no se pudo adquirir en este momento porque la operación se bloquearía de otra manera.</target>
        </trans-unit>
        <trans-unit id="ca27685a95f0186521159c6d95fa9cb158ac3333" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired because another thread failed while holding the lock.</source>
          <target state="translated">El candado no pudo ser adquirido porque otro hilo falló al sujetar el candado.</target>
        </trans-unit>
        <trans-unit id="e835ab2030797bd0af68c5e546090096d0ef15ed" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits for accessing the underlying data.</source>
          <target state="translated">El bloqueo se libera cuando el bloqueo devuelto se sale de su alcance. El guardia devuelto tambi&amp;eacute;n implementa los rasgos &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; para acceder a los datos subyacentes.</target>
        </trans-unit>
        <trans-unit id="ca99507e16c078ed3bf090ad447532972842294c" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait for writing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f3d5bdf30a84c247ddb912c9e27503ec850ddb" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;code&gt;Write&lt;/code&gt; trait for writing data.</source>
          <target state="translated">El bloqueo se libera cuando el bloqueo devuelto se sale de su alcance. La protecci&amp;oacute;n devuelta tambi&amp;eacute;n implementa el rasgo &lt;code&gt;Write&lt;/code&gt; para escribir datos.</target>
        </trans-unit>
        <trans-unit id="9fbc8134425c3ce849c012cee6ed6bdb948d21a6" translate="yes" xml:space="preserve">
          <source>The logic around the &lt;code&gt;value&lt;/code&gt; field we&amp;rsquo;ve just described is defined in Listing 13-10.</source>
          <target state="translated">La l&amp;oacute;gica en torno al campo de &lt;code&gt;value&lt;/code&gt; que acabamos de describir se define en el Listado 13-10.</target>
        </trans-unit>
        <trans-unit id="f2cf3737106dde9e749616b8670f272a444680a9" translate="yes" xml:space="preserve">
          <source>The lower bound of the range (inclusive).</source>
          <target state="translated">El límite inferior de la gama (inclusive).</target>
        </trans-unit>
        <trans-unit id="0766d14228f909fbfdac3f3dca197e2a666359ec" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any.</source>
          <target state="translated">La causa de nivel inferior de este error,si la hay.</target>
        </trans-unit>
        <trans-unit id="4b8803f6ab5b8d7b772e6a580f89ee4b72aef2f4" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">La causa de nivel inferior de este error, si existe. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5980cf0091c024091baef1d2b8180b13d7e8fb92" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">La causa de nivel inferior de este error, si existe. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f757a43bf56678673d64a896a7ea59d83e9d1668" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">La causa de nivel inferior de este error, si existe. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828185ce8f6bedf0299995b3c4e9cb20b7a41ecd" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any.</source>
          <target state="translated">La fuente de nivel inferior de este error,si la hay.</target>
        </trans-unit>
        <trans-unit id="ea0a6930dc7de4d466ce55f6448d31ae162ca38c" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">La fuente de nivel inferior de este error, si existe. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb0a1822fe706b0e16bb4cab78928338d81339e3" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">La fuente de nivel inferior de este error, si existe. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccd557ca491cf82db4f740ce89716ec64f4fabf" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">La fuente de nivel inferior de este error, si existe. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6b9226fd8ae01998a5ebc10002aa19b3691743f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0846c263b7366386582dfe4d412a3ad4ba7b9f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</source>
          <target state="translated">El c&amp;oacute;digo de m&amp;aacute;quina para &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; , o cualquier otra sustituci&amp;oacute;n de tipo es diferente. Por tanto, el compilador genera la implementaci&amp;oacute;n bajo demanda. Si llama a &lt;code&gt;foo()&lt;/code&gt; con un par&amp;aacute;metro &lt;code&gt;bool&lt;/code&gt; , el compilador solo generar&amp;aacute; c&amp;oacute;digo para &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; . Cuando tenemos par&amp;aacute;metros de tipo adicionales, el n&amp;uacute;mero de implementaciones monomorfizadas que genera el compilador no aumenta dr&amp;aacute;sticamente, ya que el compilador solo generar&amp;aacute; una implementaci&amp;oacute;n si la funci&amp;oacute;n se llama con sustituciones no parametrizadas (es decir, sustituciones donde ninguno de los tipos sustituidos est&amp;aacute; parametrizado) .</target>
        </trans-unit>
        <trans-unit id="ec5d54a07ee0f8ac568e82f61b376d035a168bca" translate="yes" xml:space="preserve">
          <source>The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">La propia macro decidirá cómo interpretar tal señal y si produce un error o no.</target>
        </trans-unit>
        <trans-unit id="8db5958c7dabf9cedcc4db6e6fa16a59d45c2565" translate="yes" xml:space="preserve">
          <source>The macro works by using the &lt;code&gt;Debug&lt;/code&gt; implementation of the type of the given expression to print the value to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; along with the source location of the macro invocation as well as the source code of the expression.</source>
          <target state="translated">La macro funciona utilizando la implementaci&amp;oacute;n de &lt;code&gt;Debug&lt;/code&gt; del tipo de la expresi&amp;oacute;n dada para imprimir el valor en &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; junto con la ubicaci&amp;oacute;n de origen de la invocaci&amp;oacute;n de la macro, as&amp;iacute; como el c&amp;oacute;digo fuente de la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9498e8eb390e83cb5dbd448b585676f4b5c37123" translate="yes" xml:space="preserve">
          <source>The macro wraps any number of static declarations and makes them thread local. Publicity and attributes for each static are allowed. Example:</source>
          <target state="translated">La macro envuelve cualquier número de declaraciones estáticas y las hace hilo local.Se permite publicidad y atributos para cada estática.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="2eb59c956ec6e4722a7e8cfdea3a410b913da22e" translate="yes" xml:space="preserve">
          <source>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&amp;rsquo;s intended to reference. Consider the program in Listing 10-17, which has an outer scope and an inner scope.</source>
          <target state="translated">El objetivo principal de la vida &amp;uacute;til es evitar referencias colgantes, lo que hace que un programa haga referencia a datos distintos de los datos a los que pretende hacer referencia. Considere el programa del Listado 10-17, que tiene un alcance externo y un alcance interno.</target>
        </trans-unit>
        <trans-unit id="c087688652f35bf8ea7f8323996c74d4edfcf197" translate="yes" xml:space="preserve">
          <source>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of &lt;code&gt;self&lt;/code&gt; in every method&amp;rsquo;s signature, is for organization. We&amp;rsquo;ve put all the things we can do with an instance of a type in one &lt;code&gt;impl&lt;/code&gt; block rather than making future users of our code search for capabilities of &lt;code&gt;Rectangle&lt;/code&gt; in various places in the library we provide.</source>
          <target state="translated">El principal beneficio de usar m&amp;eacute;todos en lugar de funciones, adem&amp;aacute;s de usar la sintaxis del m&amp;eacute;todo y no tener que repetir el tipo de &lt;code&gt;self&lt;/code&gt; en la firma de cada m&amp;eacute;todo, es para la organizaci&amp;oacute;n. Hemos puesto todas las cosas que podemos hacer con una instancia de un tipo en un bloque &lt;code&gt;impl&lt;/code&gt; &amp;iacute;cito en lugar de hacer que los futuros usuarios de nuestro c&amp;oacute;digo busquen capacidades de &lt;code&gt;Rectangle&lt;/code&gt; en varios lugares de la biblioteca que proporcionamos.</target>
        </trans-unit>
        <trans-unit id="8008407990a4be341211e8be036085a004b45e43" translate="yes" xml:space="preserve">
          <source>The main error message, &amp;ldquo;mismatched types,&amp;rdquo; reveals the core issue with this code. The definition of the function &lt;code&gt;plus_one&lt;/code&gt; says that it will return an &lt;code&gt;i32&lt;/code&gt;, but statements don&amp;rsquo;t evaluate to a value, which is expressed by &lt;code&gt;()&lt;/code&gt;, an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.</source>
          <target state="translated">El mensaje de error principal, &quot;tipos no coincidentes&quot;, revela el problema principal de este c&amp;oacute;digo. La definici&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;plus_one&lt;/code&gt; dice que devolver&amp;aacute; un &lt;code&gt;i32&lt;/code&gt; , pero las declaraciones no se eval&amp;uacute;an a un valor, que se expresa mediante &lt;code&gt;()&lt;/code&gt; , una tupla vac&amp;iacute;a. Por lo tanto, no se devuelve nada, lo que contradice la definici&amp;oacute;n de la funci&amp;oacute;n y da como resultado un error. En este resultado, Rust proporciona un mensaje para posiblemente ayudar a rectificar este problema: sugiere eliminar el punto y coma, lo que solucionar&amp;iacute;a el error.</target>
        </trans-unit>
        <trans-unit id="573ea76510aaa810e82bed4691dcc0e4c2771be9" translate="yes" xml:space="preserve">
          <source>The main place you'll see &lt;code&gt;!&lt;/code&gt; used explicitly is in generic code. Consider the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">&amp;iexcl;El lugar principal que ver&amp;aacute;s &lt;code&gt;!&lt;/code&gt; utilizado expl&amp;iacute;citamente est&amp;aacute; en c&amp;oacute;digo gen&amp;eacute;rico. Considere el rasgo &lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3347fce894ee36b7a76776d17f6b05d7ee4e0c6f" translate="yes" xml:space="preserve">
          <source>The main thread will wait for the spawned thread to finish and then run its &lt;code&gt;for&lt;/code&gt; loop, so the output won&amp;rsquo;t be interleaved anymore, as shown here:</source>
          <target state="translated">El subproceso principal esperar&amp;aacute; a que termine el subproceso generado y luego ejecutar&amp;aacute; su bucle &lt;code&gt;for&lt;/code&gt; , por lo que la salida ya no se intercalar&amp;aacute;, como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d7af4b9befadab1a133dab8d7948b44dbc8d708d" translate="yes" xml:space="preserve">
          <source>The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.</source>
          <target state="translated">El hilo principal esperará con un tiempo de espera en el condvar y luego saldrá una vez que el booleano haya sido actualizado y notificado.</target>
        </trans-unit>
        <trans-unit id="2f4d9785a094ac7050147e12df1b0f82f8cae6fe" translate="yes" xml:space="preserve">
          <source>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</source>
          <target state="translated">El principal caso de uso de los sinónimos de tipo es reducir la repetición.Por ejemplo,podríamos tener un tipo largo como este:</target>
        </trans-unit>
        <trans-unit id="e1aa73c2c8bcfa6f25fb308f2154aee4987ca459" translate="yes" xml:space="preserve">
          <source>The main way to use Boolean values is through conditionals, such as an &lt;code&gt;if&lt;/code&gt; expression. We&amp;rsquo;ll cover how &lt;code&gt;if&lt;/code&gt; expressions work in Rust in the &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;Control Flow&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">La forma principal de utilizar valores booleanos es a trav&amp;eacute;s de condicionales, como una expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; . Vamos a cubrir c&amp;oacute;mo &lt;code&gt;if&lt;/code&gt; las expresiones funcionan en Rust en el &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;control de flujo&amp;rdquo;&lt;/a&gt; secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="67f97a592dc5c37dc58d2c3fd741d8753b33f60e" translate="yes" xml:space="preserve">
          <source>The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">El mapeo a &lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt; s no es parte del contrato de compatibilidad de la funci&amp;oacute;n, especialmente el &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt; tipo podr&amp;iacute;a cambiar a tipos m&amp;aacute;s espec&amp;iacute;ficos en el futuro.</target>
        </trans-unit>
        <trans-unit id="f8fda3a6ce0d45625dd9cd044a1a98a742c97014" translate="yes" xml:space="preserve">
          <source>The match condition states that the arm only matches if the value of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, or &lt;code&gt;6&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. When this code runs, the pattern of the first arm matches because &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, but the match guard &lt;code&gt;if y&lt;/code&gt; is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints &lt;code&gt;no&lt;/code&gt;. The reason is that the &lt;code&gt;if&lt;/code&gt; condition applies to the whole pattern &lt;code&gt;4 | 5 | 6&lt;/code&gt;, not only to the last value &lt;code&gt;6&lt;/code&gt;. In other words, the precedence of a match guard in relation to a pattern behaves like this:</source>
          <target state="translated">La condici&amp;oacute;n de coincidencia establece que el brazo solo coincide si el valor de &lt;code&gt;x&lt;/code&gt; es igual a &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;5&lt;/code&gt; o &lt;code&gt;6&lt;/code&gt; &lt;em&gt;y&lt;/em&gt; si &lt;code&gt;y&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; . Cuando se ejecuta este c&amp;oacute;digo, el patr&amp;oacute;n del primer brazo coincide porque &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;4&lt;/code&gt; , pero la protecci&amp;oacute;n del f&amp;oacute;sforo &lt;code&gt;if y&lt;/code&gt; es falsa, por lo que no se elige el primer brazo. El c&amp;oacute;digo pasa al segundo brazo, que coincide, y este programa imprime &lt;code&gt;no&lt;/code&gt; . La raz&amp;oacute;n es que la condici&amp;oacute;n &lt;code&gt;if&lt;/code&gt; se aplica a todo el patr&amp;oacute;n &lt;code&gt;4 | 5 | 6&lt;/code&gt; , no solo hasta el &amp;uacute;ltimo valor &lt;code&gt;6&lt;/code&gt; . En otras palabras, la precedencia de un escolta en relaci&amp;oacute;n con un patr&amp;oacute;n se comporta as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="6477b3c15cf1efd2f96aba3a277d7e0dd00d128c" translate="yes" xml:space="preserve">
          <source>The match guard &lt;code&gt;if n == y&lt;/code&gt; is not a pattern and therefore doesn&amp;rsquo;t introduce new variables. This &lt;code&gt;y&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; the outer &lt;code&gt;y&lt;/code&gt; rather than a new shadowed &lt;code&gt;y&lt;/code&gt;, and we can look for a value that has the same value as the outer &lt;code&gt;y&lt;/code&gt; by comparing &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">El match guard &lt;code&gt;if n == y&lt;/code&gt; no es un patr&amp;oacute;n y por lo tanto no introduce nuevas variables. Esta &lt;code&gt;y&lt;/code&gt; &lt;em&gt;es&lt;/em&gt; la &lt;code&gt;y&lt;/code&gt; externa en lugar de una nueva &lt;code&gt;y&lt;/code&gt; sombreada , y podemos buscar un valor que tenga el mismo valor que la &lt;code&gt;y&lt;/code&gt; externa comparando &lt;code&gt;n&lt;/code&gt; con &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a68bad7489889370013d2c1b380ae26eafd0a34" translate="yes" xml:space="preserve">
          <source>The matched value was assigned in a match guard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4a7cee97aca95b9c65ea2bcda5404ae104d4f6" translate="yes" xml:space="preserve">
          <source>The maximum duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639334ee92fbc7d55384c7ec82527ac8487a080f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444f3162cb088de418eba38f4a421be7235eea6f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</source>
          <target state="translated">Se alcanzó el valor máximo de un enum,por lo que no se puede establecer automáticamente en el siguiente valor de enum.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="69d28668979329993270aea55163f780c2136684" translate="yes" xml:space="preserve">
          <source>The memory allocator returned an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f691ffd885b1cdd7c3aced4e660ea6b5f2bc5114" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;buf&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297bebe1d80f3b348c7c8e6094a67afc0f518766" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;ptr&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses.</source>
          <target state="translated">La memoria en &lt;code&gt;ptr&lt;/code&gt; debe haber sido asignada previamente por el mismo asignador que usa la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="533d683a4cce37c267e983c916aea2694b115c42" translate="yes" xml:space="preserve">
          <source>The memory block will contain the following contents after a successful call to &lt;code&gt;grow_zeroed&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4c6be6867180c56169b0ceb625f117dffee9cb" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;struct&lt;/code&gt; is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;. In either case, fields may be given in any order in a corresponding struct &lt;em&gt;expression&lt;/em&gt;; the resulting &lt;code&gt;struct&lt;/code&gt; value will always have the same memory layout.</source>
          <target state="translated">El dise&amp;ntilde;o de memoria de una &lt;code&gt;struct&lt;/code&gt; no est&amp;aacute; definido por defecto para permitir optimizaciones del compilador como el reordenamiento de campos, pero se puede arreglar con el &lt;a href=&quot;../type-layout#representations&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;repr&lt;/code&gt; . En cualquier caso, los campos se pueden proporcionar en cualquier orden en una &lt;em&gt;expresi&amp;oacute;n de&lt;/em&gt; estructura correspondiente ; el valor de &lt;code&gt;struct&lt;/code&gt; resultante siempre tendr&amp;aacute; el mismo dise&amp;ntilde;o de memoria.</target>
        </trans-unit>
        <trans-unit id="613a15d193cb4b5b9d7d2448a0d26f441bad60d3" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;union&lt;/code&gt; is undefined by default, but the &lt;code&gt;#[repr(...)]&lt;/code&gt; attribute can be used to fix a layout.</source>
          <target state="translated">El dise&amp;ntilde;o de memoria de una &lt;code&gt;union&lt;/code&gt; no est&amp;aacute; definido por defecto, pero el atributo &lt;code&gt;#[repr(...)]&lt;/code&gt; se puede usar para arreglar un dise&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="62988640c5b4ea3199910497b4399a06d9aa4bb8" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the memory allocator at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5158117ae58dde222908d602ad3b6cfbc19fbd1b" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the operating system at runtime.</source>
          <target state="translated">La memoria debe ser solicitada al sistema operativo en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="5fb7e987a9654eee8114bb60b92e8b3cf5d47151" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;. Both read and write accesses are forbidden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff115e1f60568ae547418e535b08f2a38631c573" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be mutated for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;, except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6139b94477b7472bd857c001d753b72d8df9f27e" translate="yes" xml:space="preserve">
          <source>The message can be of any (&lt;code&gt;Any + Send&lt;/code&gt;) type, not just strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d782721b766f719dd5b6d817f0d6bb437eb7d6a" translate="yes" xml:space="preserve">
          <source>The message is wrapped in a &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt;, which can be accessed later using &lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt;&lt;code&gt;PanicInfo::payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86a2a43ba3e98f03e1d643c5eb2cb7bce34d7c4" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so counting elements of an iterator with more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">El m&amp;eacute;todo no protege contra desbordamientos, por lo que contar elementos de un iterador con m&amp;aacute;s de &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; elementos produce un resultado incorrecto o entra en p&amp;aacute;nico. Si las aserciones de depuraci&amp;oacute;n est&amp;aacute;n habilitadas, se garantiza un p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="177a5c2ea6344ea77e9ae3a6db8fc74469cc253c" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">El m&amp;eacute;todo no protege contra desbordamientos, por lo que enumerar m&amp;aacute;s elementos que &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; produce un resultado incorrecto o entra en p&amp;aacute;nico. Si las aserciones de depuraci&amp;oacute;n est&amp;aacute;n habilitadas, se garantiza un p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="3a1826392947e9b9a700c20663562183cfe20bf1" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;code&gt;usize::MAX&lt;/code&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">El m&amp;eacute;todo no protege contra desbordamientos, por lo que enumerar m&amp;aacute;s elementos que &lt;code&gt;usize::MAX&lt;/code&gt; produce un resultado incorrecto o entra en p&amp;aacute;nico. Si las aserciones de depuraci&amp;oacute;n est&amp;aacute;n habilitadas, se garantiza un p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="19d8816b84fe470f79cf77755eeb8ee64e555da5" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so if there are more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">El m&amp;eacute;todo no protege contra desbordamientos, por lo que si hay m&amp;aacute;s de &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; elementos que no coinciden, produce el resultado incorrecto o entra en p&amp;aacute;nico. Si las aserciones de depuraci&amp;oacute;n est&amp;aacute;n habilitadas, se garantiza un p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="1be550addda456adee08f228dc9b4f31db12dda4" translate="yes" xml:space="preserve">
          <source>The method will panic if the given step is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">El m&amp;eacute;todo entrar&amp;aacute; en p&amp;aacute;nico si el paso dado es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18a6ab41791924ffc3860ab7c005689a5ace692a" translate="yes" xml:space="preserve">
          <source>The minimum alignment of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61a28fc808f2bb8277ab6d2dda14e2b5dc3214d" translate="yes" xml:space="preserve">
          <source>The minimum byte alignment for a memory block of this layout.</source>
          <target state="translated">La alineación mínima de bytes para un bloque de memoria de esta disposición.</target>
        </trans-unit>
        <trans-unit id="e621ea6ab30e14c7bfa77e4fee05fb852bfe464d" translate="yes" xml:space="preserve">
          <source>The minimum duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b04e5eee8d92581fabe61b454bd932d16d3b4ee" translate="yes" xml:space="preserve">
          <source>The minimum size in bytes for a memory block of this layout.</source>
          <target state="translated">El tamaño mínimo en bytes para un bloque de memoria de esta disposición.</target>
        </trans-unit>
        <trans-unit id="4650b1470ff8fe4b9a6a554cb10a84ba4229b041" translate="yes" xml:space="preserve">
          <source>The mirror use case of FFI is also done via the &lt;code&gt;extern&lt;/code&gt; keyword:</source>
          <target state="translated">El caso de uso espejo de FFI tambi&amp;eacute;n se realiza mediante la palabra clave &lt;code&gt;extern&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a82559d5a04edc93a72fe140de851778ee358fc2" translate="yes" xml:space="preserve">
          <source>The module tree might remind you of the filesystem&amp;rsquo;s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.</source>
          <target state="translated">El &amp;aacute;rbol de m&amp;oacute;dulos puede recordarle el &amp;aacute;rbol de directorios del sistema de archivos en su computadora; &amp;iexcl;Esta es una comparaci&amp;oacute;n muy adecuada! Al igual que los directorios en un sistema de archivos, usa m&amp;oacute;dulos para organizar su c&amp;oacute;digo. Y al igual que los archivos en un directorio, necesitamos una forma de encontrar nuestros m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="ea4c9b3e2b6f858a3799aa18909b3e42f1061d3e" translate="yes" xml:space="preserve">
          <source>The module tree remains the same, and the function calls in &lt;code&gt;eat_at_restaurant&lt;/code&gt; will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</source>
          <target state="translated">El &amp;aacute;rbol del m&amp;oacute;dulo sigue siendo el mismo, y las llamadas a funciones en &lt;code&gt;eat_at_restaurant&lt;/code&gt; funcionar&amp;aacute;n sin ninguna modificaci&amp;oacute;n, aunque las definiciones vivan en archivos diferentes. Esta t&amp;eacute;cnica le permite mover m&amp;oacute;dulos a nuevos archivos a medida que aumentan de tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="fb5cf295cab45b30e8f8d196e49ec369e86db99a" translate="yes" xml:space="preserve">
          <source>The monomorphized version of the code looks like the following. The generic &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is replaced with the specific definitions created by the compiler:</source>
          <target state="translated">La versi&amp;oacute;n monomorfizada del c&amp;oacute;digo se parece a la siguiente. La &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; gen&amp;eacute;rica &amp;lt;T&amp;gt; se reemplaza con las definiciones espec&amp;iacute;ficas creadas por el compilador:</target>
        </trans-unit>
        <trans-unit id="75cf509b67ca81925881254de671f6530c684e13" translate="yes" xml:space="preserve">
          <source>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even &lt;em&gt;must&lt;/em&gt; be used, e.g.</source>
          <target state="translated">La mutabilidad heredada m&amp;aacute;s com&amp;uacute;n, donde uno debe tener acceso &amp;uacute;nico para mutar un valor, es uno de los elementos clave del lenguaje que le permite a Rust razonar fuertemente sobre el alias de puntero, previniendo est&amp;aacute;ticamente errores de bloqueo. Por eso, se prefiere la mutabilidad heredada, y la mutabilidad interior es un &amp;uacute;ltimo recurso. Dado que los tipos de c&amp;eacute;lulas permiten la mutaci&amp;oacute;n donde de otro modo no estar&amp;iacute;a permitida, hay ocasiones en las que la mutabilidad interior podr&amp;iacute;a ser apropiada, o incluso &lt;em&gt;debe&lt;/em&gt; usarse, p.</target>
        </trans-unit>
        <trans-unit id="22b87181f4af9bcd4494ede540e86fdd7af786b7" translate="yes" xml:space="preserve">
          <source>The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one collection into another. You take a collection, call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it, do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.</source>
          <target state="translated">El patr&amp;oacute;n m&amp;aacute;s b&amp;aacute;sico en el que se usa &lt;code&gt;collect()&lt;/code&gt; es convertir una colecci&amp;oacute;n en otra. Tomas una colecci&amp;oacute;n, la llamas &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; , haces un mont&amp;oacute;n de transformaciones y luego &lt;code&gt;collect()&lt;/code&gt; al final.</target>
        </trans-unit>
        <trans-unit id="8acfa5660545764d445a8a9080882c9972414cad" translate="yes" xml:space="preserve">
          <source>The most basic usage of the keyword is &lt;code&gt;use path::to::item;&lt;/code&gt;, though a number of convenient shortcuts are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524cfe2dc48693915271c90c3e4b7d15d2163d53" translate="yes" xml:space="preserve">
          <source>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</source>
          <target state="translated">La fuente más probable de este error es el uso de la notación de paréntesis angulares sin envolver el tipo de argumento de la función en una tupla,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f1fae4bef53f01c296ad8cf52cd2f776bcb2545a" translate="yes" xml:space="preserve">
          <source>The most straightforward smart pointer is a &lt;em&gt;box&lt;/em&gt;, whose type is written &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</source>
          <target state="translated">El puntero inteligente m&amp;aacute;s sencillo es un &lt;em&gt;cuadro&lt;/em&gt; , cuyo tipo se escribe &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . Las cajas le permiten almacenar datos en el mont&amp;oacute;n en lugar de en la pila. Lo que queda en la pila es el puntero a los datos del mont&amp;oacute;n. Consulte el Cap&amp;iacute;tulo 4 para revisar la diferencia entre la pila y el mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c84503d5e594d47f23b7b930df844dc25ee59200" translate="yes" xml:space="preserve">
          <source>The most surprising behavior occurs when &quot;the same&quot; file is reachable via multiple paths in the module system (usually using the &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; attribute or similar), which can cause what appears to be identical code to return differing values from this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224b0446b4293b35c3feb8b386382ff2882bd862" translate="yes" xml:space="preserve">
          <source>The most widely used form of macros in Rust is &lt;em&gt;declarative macros&lt;/em&gt;. These are also sometimes referred to as &amp;ldquo;macros by example,&amp;rdquo; &amp;ldquo;&lt;code&gt;macro_rules!&lt;/code&gt; macros,&amp;rdquo; or just plain &amp;ldquo;macros.&amp;rdquo; At their core, declarative macros allow you to write something similar to a Rust &lt;code&gt;match&lt;/code&gt; expression. As discussed in Chapter 6, &lt;code&gt;match&lt;/code&gt; expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</source>
          <target state="translated">La forma m&amp;aacute;s utilizada de macros en Rust son las &lt;em&gt;macros declarativas&lt;/em&gt; . A veces tambi&amp;eacute;n se les llama &amp;ldquo;macros por ejemplo&amp;rdquo;, &amp;ldquo; &lt;code&gt;macro_rules!&lt;/code&gt; macros &quot;o simplemente&quot; macros &quot;. En esencia, las macros declarativas le permiten escribir algo similar a una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; Rust . Como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 6, &lt;code&gt;match&lt;/code&gt; Las expresiones son estructuras de control que toman una expresi&amp;oacute;n, comparan el valor resultante de la expresi&amp;oacute;n con los patrones y luego ejecutan el c&amp;oacute;digo asociado con el patr&amp;oacute;n coincidente. Las macros tambi&amp;eacute;n comparan un valor con los patrones que est&amp;aacute;n asociados con un c&amp;oacute;digo en particular: en esta situaci&amp;oacute;n, el valor es el c&amp;oacute;digo fuente literal de Rust pasado a la macro; los patrones se comparan con la estructura de ese c&amp;oacute;digo fuente; y el c&amp;oacute;digo asociado con cada patr&amp;oacute;n, cuando coincide, reemplaza el c&amp;oacute;digo pasado a la macro. Todo esto sucede durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5c8119cbdd49364e9c5037e1b8a03abc1bccdb46" translate="yes" xml:space="preserve">
          <source>The motivation for this design is twofold:</source>
          <target state="translated">La motivación para este diseño es doble:</target>
        </trans-unit>
        <trans-unit id="6fd4e131dbce656fa77aa6dbacb12fee04853072" translate="yes" xml:space="preserve">
          <source>The multi-argument form of this macro panics with a string and has the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax for building a string.</source>
          <target state="translated">La forma de m&amp;uacute;ltiples argumentos de esta macro entra en p&amp;aacute;nico con una cadena y tiene el &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;sintaxis para construir una cadena.</target>
        </trans-unit>
        <trans-unit id="ff7a3f839c4dac34de65c2bfcbc13d6c2f460e6c" translate="yes" xml:space="preserve">
          <source>The multiplication assignment operator &lt;code&gt;*=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de multiplicaci&amp;oacute;n &lt;code&gt;*=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945e202ccc3f817f464a16a52710aeff055613cc" translate="yes" xml:space="preserve">
          <source>The multiplication operator &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">El operador de multiplicaci&amp;oacute;n &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395bf55779b3f4b37031c67eb2f13567f6e766a4" translate="yes" xml:space="preserve">
          <source>The mutability of a pointer does not change its size. As such, &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; have the same size. Likewise for &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">La mutabilidad de un puntero no cambia su tama&amp;ntilde;o. Como tal, &lt;code&gt;&amp;amp;T&lt;/code&gt; y &lt;code&gt;&amp;amp;mut T&lt;/code&gt; tienen el mismo tama&amp;ntilde;o. Lo mismo sucede con &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f42a8b27f0c72155ef0f3b14d7be6cafaaf62841" translate="yes" xml:space="preserve">
          <source>The mutable slice yields mutable references to the elements:</source>
          <target state="translated">La rebanada mutable produce referencias mutables a los elementos:</target>
        </trans-unit>
        <trans-unit id="3c3cbd1ab17a10688ead5cf4d56f2dfc9e512608" translate="yes" xml:space="preserve">
          <source>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).</source>
          <target state="translated">Los mutex de este módulo implementan una estrategia llamada &quot;envenenamiento&quot; en la que se considera que un mutex está envenenado cuando un hilo entra en pánico mientras lo sujeta.Una vez envenenado un mutex,todos los demás hilos no pueden acceder a los datos por defecto ya que es probable que estén contaminados (no se mantiene alguna invariante).</target>
        </trans-unit>
        <trans-unit id="d8b50303b0747d7e3abc95898503b5bde7711980" translate="yes" xml:space="preserve">
          <source>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</source>
          <target state="translated">El nombre elegido para un cajón externo entra en conflicto con otro cajón externo que se ha importado al módulo actual.</target>
        </trans-unit>
        <trans-unit id="d94375d609f70bc0ddb2da1f070fd5b681c30cc1" translate="yes" xml:space="preserve">
          <source>The name for an item declaration conflicts with an external crate's name.</source>
          <target state="translated">El nombre de una declaración de artículos entra en conflicto con el nombre de una caja externa.</target>
        </trans-unit>
        <trans-unit id="286d59804da04e407ec36eb2be39e9e0c7ff3343" translate="yes" xml:space="preserve">
          <source>The name must not contain null bytes (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">El nombre no debe contener bytes nulos ( &lt;code&gt;\0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6584162ced4a99e7d4548e6dfca0a1b5adbdbd8e" translate="yes" xml:space="preserve">
          <source>The need for synchronization</source>
          <target state="translated">La necesidad de sincronización</target>
        </trans-unit>
        <trans-unit id="9491a60a88ee503552e1418886a35e38dd1f594f" translate="yes" xml:space="preserve">
          <source>The need for this type arises from the fact that:</source>
          <target state="translated">La necesidad de este tipo surge del hecho de que:</target>
        </trans-unit>
        <trans-unit id="3e795b9b16f895fca00c98b1df11fc0d63c7301f" translate="yes" xml:space="preserve">
          <source>The network operation failed because it was not connected yet.</source>
          <target state="translated">La operación de la red falló porque no estaba conectada todavía.</target>
        </trans-unit>
        <trans-unit id="7c5a2cc50c7976456054417007ed08f73bfd9e80" translate="yes" xml:space="preserve">
          <source>The never type &lt;code&gt;!&lt;/code&gt; is a type with no values, representing the result of computations that never complete. Expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type.</source>
          <target state="translated">&amp;iexcl;El tipo nunca &lt;code&gt;!&lt;/code&gt; es un tipo sin valores, que representa el resultado de c&amp;aacute;lculos que nunca se completan. &amp;iexcl;Expresiones de tipo &lt;code&gt;!&lt;/code&gt; puede ser coaccionado a cualquier otro tipo.</target>
        </trans-unit>
        <trans-unit id="2876200ee40ea0a4251130e3bb42070db01f59e5" translate="yes" xml:space="preserve">
          <source>The never type is useful with the &lt;code&gt;panic!&lt;/code&gt; macro as well. Remember the &lt;code&gt;unwrap&lt;/code&gt; function that we call on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; values to produce a value or panic? Here is its definition:</source>
          <target state="translated">&amp;iexcl;El tipo nunca es &amp;uacute;til con el &lt;code&gt;panic!&lt;/code&gt; macro tambi&amp;eacute;n. &amp;iquest;Recuerda la funci&amp;oacute;n de &lt;code&gt;unwrap&lt;/code&gt; que llamamos a &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; valores Option &amp;lt;T&amp;gt; para producir un valor o p&amp;aacute;nico? Aqu&amp;iacute; est&amp;aacute; su definici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="56b6326e5da7a2c1bad08c52fe9675cb30d6fc5f" translate="yes" xml:space="preserve">
          <source>The new test for the case-&lt;em&gt;insensitive&lt;/em&gt; search uses &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; as its query. In the &lt;code&gt;search_case_insensitive&lt;/code&gt; function we&amp;rsquo;re about to add, the query &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; should match the line containing &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; with a capital R and match the line &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven&amp;rsquo;t yet defined the &lt;code&gt;search_case_insensitive&lt;/code&gt; function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the &lt;code&gt;search&lt;/code&gt; function in Listing 12-16 to see the test compile and fail.</source>
          <target state="translated">La nueva prueba para la b&amp;uacute;squeda que no &lt;em&gt;distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas&lt;/em&gt; utiliza &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; como consulta. En la funci&amp;oacute;n &lt;code&gt;search_case_insensitive&lt;/code&gt; que vamos a agregar, la consulta &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; debe coincidir con la l&amp;iacute;nea que contiene &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; con una R may&amp;uacute;scula y coincidir con la l&amp;iacute;nea &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; aunque ambos tienen una carcasa diferente a la de la consulta. Esta es nuestra prueba fallida y no se podr&amp;aacute; compilar porque todav&amp;iacute;a no hemos definido la funci&amp;oacute;n &lt;code&gt;search_case_insensitive&lt;/code&gt; . Si&amp;eacute;ntase libre de agregar una implementaci&amp;oacute;n esqueleto que siempre devuelva un vector vac&amp;iacute;o, similar a la forma en que lo hicimos para la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; en el Listado 12-16 para ver la compilaci&amp;oacute;n de la prueba y fallar.</target>
        </trans-unit>
        <trans-unit id="9a3696a40107bd6d0870f3607ce5d6e5073b6d6b" translate="yes" xml:space="preserve">
          <source>The newtype pattern is useful for tasks beyond those we&amp;rsquo;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structs wrapped &lt;code&gt;u32&lt;/code&gt; values in a newtype. If we wrote a function with a parameter of type &lt;code&gt;Millimeters&lt;/code&gt;, we couldn&amp;rsquo;t compile a program that accidentally tried to call that function with a value of type &lt;code&gt;Meters&lt;/code&gt; or a plain &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">El patr&amp;oacute;n newtype es &amp;uacute;til para tareas m&amp;aacute;s all&amp;aacute; de las que hemos discutido hasta ahora, incluida la aplicaci&amp;oacute;n est&amp;aacute;tica de que los valores nunca se confunden e indica las unidades de un valor. Viste un ejemplo del uso de nuevos tipos para indicar unidades en el Listado 19-15: recuerda que las estructuras &lt;code&gt;Millimeters&lt;/code&gt; y &lt;code&gt;Meters&lt;/code&gt; envuelven los valores &lt;code&gt;u32&lt;/code&gt; en un nuevo tipo. Si escribimos una funci&amp;oacute;n con un par&amp;aacute;metro de tipo &lt;code&gt;Millimeters&lt;/code&gt; , no podr&amp;iacute;amos compilar un programa que accidentalmente intent&amp;oacute; llamar a esa funci&amp;oacute;n con un valor de tipo &lt;code&gt;Meters&lt;/code&gt; o un &lt;code&gt;u32&lt;/code&gt; simple .</target>
        </trans-unit>
        <trans-unit id="b591edfc8b3d018e277499297a4856c76a36dc2a" translate="yes" xml:space="preserve">
          <source>The next four lines set the configuration information Cargo needs to compile your program: the name, the version, who wrote it, and the edition of Rust to use. Cargo gets your name and email information from your environment, so if that information is not correct, fix the information now and then save the file. We&amp;rsquo;ll talk about the &lt;code&gt;edition&lt;/code&gt; key in Appendix E.</source>
          <target state="translated">Las siguientes cuatro l&amp;iacute;neas establecen la informaci&amp;oacute;n de configuraci&amp;oacute;n que Cargo necesita para compilar su programa: el nombre, la versi&amp;oacute;n, qui&amp;eacute;n lo escribi&amp;oacute; y la edici&amp;oacute;n de Rust que debe usar. Cargo obtiene su nombre y la informaci&amp;oacute;n de correo electr&amp;oacute;nico de su entorno, por lo que si esa informaci&amp;oacute;n no es correcta, corrija la informaci&amp;oacute;n ahora y luego guarde el archivo. Hablaremos de la clave de &lt;code&gt;edition&lt;/code&gt; en el Ap&amp;eacute;ndice E.</target>
        </trans-unit>
        <trans-unit id="6a7a2603b03740bcea191aea3d000fd9f48ffbb9" translate="yes" xml:space="preserve">
          <source>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-28 or the version using iterators in Listing 13-29. Most Rust programmers prefer to use the iterator style. It&amp;rsquo;s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it&amp;rsquo;s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</source>
          <target state="translated">La siguiente pregunta l&amp;oacute;gica es qu&amp;eacute; estilo debe elegir en su propio c&amp;oacute;digo y por qu&amp;eacute;: la implementaci&amp;oacute;n original en el Listado 13-28 o la versi&amp;oacute;n que usa iteradores en el Listado 13-29. La mayor&amp;iacute;a de los programadores de Rust prefieren usar el estilo iterador. Es un poco m&amp;aacute;s dif&amp;iacute;cil de entender al principio, pero una vez que se familiariza con los distintos adaptadores de iteradores y lo que hacen, los iteradores pueden ser m&amp;aacute;s f&amp;aacute;ciles de entender. En lugar de jugar con los diversos bits de bucle y construir nuevos vectores, el c&amp;oacute;digo se centra en el objetivo de alto nivel del bucle. Esto abstrae parte del c&amp;oacute;digo com&amp;uacute;n para que sea m&amp;aacute;s f&amp;aacute;cil ver los conceptos que son exclusivos de este c&amp;oacute;digo, como la condici&amp;oacute;n de filtrado que debe pasar cada elemento del iterador.</target>
        </trans-unit>
        <trans-unit id="57f6548988daa34617ffdf2e9ca86d7e443df79f" translate="yes" xml:space="preserve">
          <source>The next note line tells us that we can set the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to get a backtrace of exactly what happened to cause the error. A &lt;em&gt;backtrace&lt;/em&gt; is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That&amp;rsquo;s the spot where the problem originated. The lines above the lines mentioning your files are code that your code called; the lines below are code that called your code. These lines might include core Rust code, standard library code, or crates that you&amp;rsquo;re using. Let&amp;rsquo;s try getting a backtrace by setting the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to any value except 0. Listing 9-2 shows output similar to what you&amp;rsquo;ll see.</source>
          <target state="translated">La siguiente l&amp;iacute;nea de nota nos dice que podemos configurar la variable de entorno &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; para obtener un seguimiento de lo que sucedi&amp;oacute; exactamente para causar el error. Un &lt;em&gt;backtrace&lt;/em&gt; es una lista de todas las funciones que se han llamado para llegar a este punto. Los backtraces en Rust funcionan como lo hacen en otros idiomas: la clave para leer el backtrace es comenzar desde arriba y leer hasta que veas los archivos que escribiste. Ese es el lugar donde se origin&amp;oacute; el problema. Las l&amp;iacute;neas sobre las l&amp;iacute;neas que mencionan sus archivos son el c&amp;oacute;digo que llam&amp;oacute; su c&amp;oacute;digo; las l&amp;iacute;neas siguientes son el c&amp;oacute;digo que llam&amp;oacute; a su c&amp;oacute;digo. Estas l&amp;iacute;neas pueden incluir c&amp;oacute;digo b&amp;aacute;sico de Rust, c&amp;oacute;digo de biblioteca est&amp;aacute;ndar o cajas que est&amp;eacute; utilizando. Intentemos obtener un &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; mediante la configuraci&amp;oacute;n de RUST_BACKTRACE variable de entorno a cualquier valor excepto 0. El Listado 9-2 muestra un resultado similar al que ver&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="771993487043dfd3c7aa5a2390e7d9f0063dbedb" translate="yes" xml:space="preserve">
          <source>The next part of the code, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt;, calls the &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method on the standard input handle to get input from the user. We&amp;rsquo;re also passing one argument to &lt;code&gt;read_line&lt;/code&gt;: &lt;code&gt;&amp;amp;mut guess&lt;/code&gt;.</source>
          <target state="translated">La siguiente parte del c&amp;oacute;digo, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt; , llama al m&amp;eacute;todo &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt; en el identificador de entrada est&amp;aacute;ndar para obtener la entrada del usuario. Tambi&amp;eacute;n estamos pasando un argumento a &lt;code&gt;read_line&lt;/code&gt; : &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3a0383282eca508bd91153f03681dc6f1973f4" translate="yes" xml:space="preserve">
          <source>The next part of the request line is &lt;em&gt;/&lt;/em&gt;, which indicates the &lt;em&gt;Uniform Resource Identifier&lt;/em&gt;&lt;em&gt;(URI)&lt;/em&gt; the client is requesting: a URI is almost, but not quite, the same as a &lt;em&gt;Uniform Resource Locator&lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt;. The difference between URIs and URLs isn&amp;rsquo;t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.</source>
          <target state="translated">La siguiente parte de la l&amp;iacute;nea de solicitud es &lt;em&gt;/&lt;/em&gt; , que indica el &lt;em&gt;Identificador uniforme de recursos &lt;/em&gt;&lt;em&gt;(URI) que&lt;/em&gt; solicita el cliente: un URI es casi, pero no exactamente, lo mismo que un &lt;em&gt;Localizador uniforme de recursos &lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt; . La diferencia entre URI y URL no es importante para nuestros prop&amp;oacute;sitos en este cap&amp;iacute;tulo, pero la especificaci&amp;oacute;n HTTP usa el t&amp;eacute;rmino URI, por lo que podemos sustituir mentalmente URL por URI aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="504232041214e8dae75346e3d17c4c0bf4814b9b" translate="yes" xml:space="preserve">
          <source>The next part of the test output, which starts with &lt;code&gt;Doc-tests adder&lt;/code&gt;, is for the results of any documentation tests. We don&amp;rsquo;t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps us keep our docs and our code in sync! We&amp;rsquo;ll discuss how to write documentation tests in the &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Documentation Comments as Tests&amp;rdquo;&lt;/a&gt; section of Chapter 14. For now, we&amp;rsquo;ll ignore the &lt;code&gt;Doc-tests&lt;/code&gt; output.</source>
          <target state="translated">La siguiente parte del resultado de la prueba, que comienza con el &lt;code&gt;Doc-tests adder&lt;/code&gt; , es para los resultados de las pruebas de documentaci&amp;oacute;n. A&amp;uacute;n no tenemos pruebas de documentaci&amp;oacute;n, pero Rust puede compilar cualquier ejemplo de c&amp;oacute;digo que aparezca en la documentaci&amp;oacute;n de nuestra API. &amp;iexcl;Esta funci&amp;oacute;n nos ayuda a mantener nuestros documentos y nuestro c&amp;oacute;digo sincronizados! Discutiremos c&amp;oacute;mo escribir pruebas de documentaci&amp;oacute;n en la secci&amp;oacute;n &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Comentarios de documentaci&amp;oacute;n como pruebas&amp;rdquo;&lt;/a&gt; del Cap&amp;iacute;tulo 14. Por ahora, ignoraremos el resultado de las &lt;code&gt;Doc-tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ac4585430b879637fa9bf73df289a63ff5c8c8c" translate="yes" xml:space="preserve">
          <source>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named &lt;code&gt;foo&lt;/code&gt;, a custom derive procedural macro crate is called &lt;code&gt;foo_derive&lt;/code&gt;. Let&amp;rsquo;s start a new crate called &lt;code&gt;hello_macro_derive&lt;/code&gt; inside our &lt;code&gt;hello_macro&lt;/code&gt; project:</source>
          <target state="translated">El siguiente paso es definir la macro de procedimiento. En el momento de escribir este art&amp;iacute;culo, las macros de procedimiento deben estar en su propia caja. Eventualmente, esta restricci&amp;oacute;n podr&amp;iacute;a levantarse. La convenci&amp;oacute;n para estructurar cajas y macrocajas es la siguiente: para una caja llamada &lt;code&gt;foo&lt;/code&gt; , una macro caja de procedimiento de &lt;code&gt;foo_derive&lt;/code&gt; personalizada se llama foo_derive . Comencemos una nueva caja llamada &lt;code&gt;hello_macro_derive&lt;/code&gt; dentro de nuestro proyecto &lt;code&gt;hello_macro&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86c376c4d2f9126074dd6023a007174609449704" translate="yes" xml:space="preserve">
          <source>The next time you run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will update the registry of crates available and reevaluate your &lt;code&gt;rand&lt;/code&gt; requirements according to the new version you have specified.</source>
          <target state="translated">La pr&amp;oacute;xima vez que ejecute &lt;code&gt;cargo build&lt;/code&gt; , Cargo actualizar&amp;aacute; el registro de cajas disponibles y reevaluar&amp;aacute; sus requisitos de &lt;code&gt;rand&lt;/code&gt; de acuerdo con la nueva versi&amp;oacute;n que haya especificado.</target>
        </trans-unit>
        <trans-unit id="14f1a8115e3ecc473c296ccb90a19424fd7f3781" translate="yes" xml:space="preserve">
          <source>The nightly feature &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;Arbitrary self types&lt;/a&gt; extends the accepted set of receiver types to also include any type that can dereference to &lt;code&gt;Self&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e15e37e03d384e681f27ce15aeb9d3bb4095a8" translate="yes" xml:space="preserve">
          <source>The node that was removed is returned as a new &lt;code&gt;LinkedList&lt;/code&gt; containing only this node. The cursor is moved to point to the next element in the current &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145ccdcfae9c0bd6f7e5de42ea443500c786c639" translate="yes" xml:space="preserve">
          <source>The nominal type is called the &lt;em&gt;implementing type&lt;/em&gt; and the associable items are the &lt;em&gt;associated items&lt;/em&gt; to the implementing type.</source>
          <target state="translated">El tipo nominal se denomina &lt;em&gt;tipo de implementaci&amp;oacute;n&lt;/em&gt; y los elementos asociables son los &lt;em&gt;elementos asociados&lt;/em&gt; al tipo de implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a450d39487d717bce9613fc2953a92eb80b07994" translate="yes" xml:space="preserve">
          <source>The note mentions &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, which is a &lt;em&gt;trait&lt;/em&gt;. We&amp;rsquo;ll talk about traits in the next section. For now, this error states that the body of &lt;code&gt;largest&lt;/code&gt; won&amp;rsquo;t work for all possible types that &lt;code&gt;T&lt;/code&gt; could be. Because we want to compare values of type &lt;code&gt;T&lt;/code&gt; in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; trait that you can implement on types (see Appendix C for more on this trait). You&amp;rsquo;ll learn how to specify that a generic type has a particular trait in the &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;Traits as Parameters&amp;rdquo;&lt;/a&gt; section, but let&amp;rsquo;s first explore other ways of using generic type parameters.</source>
          <target state="translated">La nota menciona &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; , que es un &lt;em&gt;rasgo&lt;/em&gt; . Hablaremos de los rasgos en la siguiente secci&amp;oacute;n. Por ahora, este error indica que el cuerpo &lt;code&gt;largest&lt;/code&gt; no funcionar&amp;aacute; para todos los tipos posibles que podr&amp;iacute;a ser &lt;code&gt;T&lt;/code&gt; . Como queremos comparar valores de tipo &lt;code&gt;T&lt;/code&gt; en el cuerpo, solo podemos usar tipos cuyos valores se pueden ordenar. Para habilitar las comparaciones, la biblioteca est&amp;aacute;ndar tiene el rasgo &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; que puede implementar en tipos (consulte el Ap&amp;eacute;ndice C para obtener m&amp;aacute;s informaci&amp;oacute;n sobre este rasgo). Aprender&amp;aacute; a especificar que un tipo gen&amp;eacute;rico tiene un rasgo particular en la secci&amp;oacute;n &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&quot;Rasgos como par&amp;aacute;metros&quot;&lt;/a&gt; , pero primero exploremos otras formas de usar par&amp;aacute;metros de tipo gen&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="39a86e3fff1f9b2a932559db164eca88c47636bb" translate="yes" xml:space="preserve">
          <source>The number of arguments passed to a function must match the number of arguments specified in the function signature.</source>
          <target state="translated">El número de argumentos pasados a una función debe coincidir con el número de argumentos especificados en la firma de la función.</target>
        </trans-unit>
        <trans-unit id="1499b95664ab693551effdfbf1800a214feda909" translate="yes" xml:space="preserve">
          <source>The number of elements determines the arity of the tuple. A tuple with &lt;code&gt;n&lt;/code&gt; elements is called an &lt;code&gt;n-ary tuple&lt;/code&gt;. For example, a tuple with 2 elements is a 2-ary tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5008d92a3f283390aac2066e3363b4399cff1" translate="yes" xml:space="preserve">
          <source>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</source>
          <target state="translated">El número de elementos de una matriz o patrón de rebanadas difería del número de elementos de la matriz que se emparejaban.</target>
        </trans-unit>
        <trans-unit id="110544a8e2a789b8a0779516d37df0cd0dba8ad5" translate="yes" xml:space="preserve">
          <source>The number of operands is the arity of the constructed tuple. Tuple expressions without operands produce the unit tuple. For other tuple expressions, the first written operand initializes the 0th element and subsequent operands initializes the next highest element. For example, in the tuple expression &lt;code&gt;('a', 'b', 'c')&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; initializes the value of the 0th element, &lt;code&gt;'b'&lt;/code&gt; the 1st, and &lt;code&gt;'c'&lt;/code&gt; the 2nd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7202e21ed0c94540f8855e2b43b5089a13dd9685" translate="yes" xml:space="preserve">
          <source>The number of supplied arguments must exactly match the number of defined type parameters.</source>
          <target state="translated">El número de argumentos suministrados debe coincidir exactamente con el número de parámetros de tipo definidos.</target>
        </trans-unit>
        <trans-unit id="1505278c99d9fb45d4f4157fc24b25e9be942498" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">El desplazamiento dentro de los l&amp;iacute;mites no puede depender de &quot;envolver&quot; el espacio de direcciones. Es decir, la suma de precisi&amp;oacute;n infinita debe caber en un &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0b1c110f4f91ff6afa42a1772303d08fd7f686" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a usize.</source>
          <target state="translated">El desplazamiento que está en los límites no puede depender de &quot;envolver&quot; el espacio de direcciones.Es decir,la suma de precisión infinita debe caber en un tamaño de usuario.</target>
        </trans-unit>
        <trans-unit id="dec85f2a58c1002de0f34de579c15b9ae5dcc5c3" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum, &lt;strong&gt;in bytes&lt;/strong&gt; must fit in a usize.</source>
          <target state="translated">El desplazamiento dentro de los l&amp;iacute;mites no puede depender de &quot;envolver&quot; el espacio de direcciones. Es decir, la suma de precisi&amp;oacute;n infinita, &lt;strong&gt;en bytes,&lt;/strong&gt; debe caber en un usize.</target>
        </trans-unit>
        <trans-unit id="b405bb6eb2033937b629bd683503a6e77a48009c" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;offset_to&lt;/code&gt; methods.</source>
          <target state="translated">El desplazamiento se expresa en n&amp;uacute;mero de elementos &lt;code&gt;T&lt;/code&gt; y no en bytes. El valor devuelto se puede utilizar con los m&amp;eacute;todos &lt;code&gt;offset&lt;/code&gt; o &lt;code&gt;offset_to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85ba9b2d34ef606ffd767c5e393592519fd3aa95" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;wrapping_add&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be821c2089924c0d18d107c2c27f16675f5ac1c" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor.</source>
          <target state="translated">El desplazamiento es relativo al inicio del archivo y por lo tanto independiente del cursor actual.</target>
        </trans-unit>
        <trans-unit id="084e82e27a45f945c98a971924845d2bbfc865a4" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the read.</source>
          <target state="translated">El desplazamiento es relativo al inicio del archivo y, por lo tanto, es independiente del cursor actual. El cursor actual &lt;strong&gt;se&lt;/strong&gt; ve afectado por esta funci&amp;oacute;n, se establece al final de la lectura.</target>
        </trans-unit>
        <trans-unit id="caf802013d8abd4267e3b977c2a718d4ec2a76b7" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the write.</source>
          <target state="translated">El desplazamiento es relativo al inicio del archivo y, por lo tanto, es independiente del cursor actual. El cursor actual &lt;strong&gt;se&lt;/strong&gt; ve afectado por esta funci&amp;oacute;n, se establece al final de la escritura.</target>
        </trans-unit>
        <trans-unit id="e661f5d3042445d2052a045a18f9872b66b5bc29" translate="yes" xml:space="preserve">
          <source>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</source>
          <target state="translated">El viejo revisor de préstamos ha conocido problemas de solidez que son básicamente imposibles de arreglar.El nuevo chequeador de préstamos basado en NLL es el arreglo.</target>
        </trans-unit>
        <trans-unit id="ff9f5d5ca24724dc4d44a56e5f4a630aa34c4326" translate="yes" xml:space="preserve">
          <source>The one exception is the implicit &lt;code&gt;Self&lt;/code&gt; type of a trait. A trait does not have an implicit &lt;code&gt;Sized&lt;/code&gt; bound as this is incompatible with &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.</source>
          <target state="translated">La &amp;uacute;nica excepci&amp;oacute;n es el tipo de rasgo del &lt;code&gt;Self&lt;/code&gt; impl&amp;iacute;cito . Un rasgo no tiene un l&amp;iacute;mite de &lt;code&gt;Sized&lt;/code&gt; impl&amp;iacute;cito, ya que es incompatible con los &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;objetos de rasgo&lt;/a&gt; donde, por definici&amp;oacute;n, el rasgo debe funcionar con todos los implementadores posibles y, por lo tanto, podr&amp;iacute;a tener cualquier tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="251eb8c6b3ec1dc5000df1aa3f1d9769e8fc67e3" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one divides &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">El &amp;uacute;nico caso en el que puede ocurrir tal envoltura es cuando se divide &lt;code&gt;MIN / -1&lt;/code&gt; en un tipo con signo (donde &lt;code&gt;MIN&lt;/code&gt; es el valor m&amp;iacute;nimo negativo para el tipo); esto es equivalente a &lt;code&gt;-MIN&lt;/code&gt; , un valor positivo que es demasiado grande para representarlo en el tipo. En tal caso, esta funci&amp;oacute;n devuelve &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76c053c143fda09cee97a50ed7a5afba7b9b021c" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one negates &lt;code&gt;MIN&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">El &amp;uacute;nico caso donde puede ocurrir tal envoltura es cuando uno niega &lt;code&gt;MIN&lt;/code&gt; en un tipo con signo (donde &lt;code&gt;MIN&lt;/code&gt; es el valor m&amp;iacute;nimo negativo para el tipo); este es un valor positivo que es demasiado grande para representarlo en el tipo. En tal caso, esta funci&amp;oacute;n devuelve &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f6de3ab26de46b22b8646658bc86041ba8f3d5e" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">El &amp;uacute;nico caso en el que puede ocurrir tal envoltura es cuando se toma el valor absoluto del valor m&amp;iacute;nimo negativo para el tipo, este es un valor positivo que es demasiado grande para representarlo en el tipo. En tal caso, esta funci&amp;oacute;n devuelve &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d6aabe4740755ea8f6332847150daa44a43b07" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type; this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e8e964be307b9ddc1a920575e78207b9d44077" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to a copied value of &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b5a7f2069f2def348d2148cbc38445c3e27f4c" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to the value in &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">La &amp;uacute;nica diferencia entre el Listado 15-7 y el Listado 15-6 es que aqu&amp;iacute; establecemos &lt;code&gt;y&lt;/code&gt; para que sea una instancia de un cuadro que apunta al valor en &lt;code&gt;x&lt;/code&gt; en lugar de una referencia que apunta al valor de &lt;code&gt;x&lt;/code&gt; . En la &amp;uacute;ltima afirmaci&amp;oacute;n, podemos usar el operador de desreferencia para seguir el puntero del cuadro de la misma manera que lo hicimos cuando &lt;code&gt;y&lt;/code&gt; era una referencia. A continuaci&amp;oacute;n, exploraremos qu&amp;eacute; tiene de especial &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; que nos permite usar el operador de desreferencia al definir nuestro propio tipo de cuadro.</target>
        </trans-unit>
        <trans-unit id="f7b8368bfb1b8c79cdb7d78152517d184d409bdd" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7a3f715132d2845165ebc499ef1753bb78d047" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors. &lt;code&gt;const&lt;/code&gt; functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</source>
          <target state="translated">Las &amp;uacute;nicas funciones que se pueden llamar en expresiones est&amp;aacute;ticas o constantes son las funciones &lt;code&gt;const&lt;/code&gt; y los constructores struct / enum. &lt;code&gt;const&lt;/code&gt; funciones const solo est&amp;aacute;n disponibles en un compilador nocturno. Actualmente, Rust no admite la ejecuci&amp;oacute;n de funciones en tiempo de compilaci&amp;oacute;n m&amp;aacute;s generales.</target>
        </trans-unit>
        <trans-unit id="f7c42c506a124c9ffe70241d1844e481774b0efe" translate="yes" xml:space="preserve">
          <source>The only lifetime allowed in a constant is &lt;code&gt;'static&lt;/code&gt;, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</source>
          <target state="translated">La &amp;uacute;nica vida &amp;uacute;til permitida en una constante es &lt;code&gt;'static&lt;/code&gt; , que es la vida &amp;uacute;til que abarca todas las dem&amp;aacute;s en un programa de Rust. Por ejemplo, si quisiera definir una cadena constante, se ver&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="c90e7627a1475de1daf664c395cb8fc220c2a179" translate="yes" xml:space="preserve">
          <source>The operand of a field expression.</source>
          <target state="translated">La operando de una expresión de campo.</target>
        </trans-unit>
        <trans-unit id="c815094584bba28655815f7e3484796d5b4ac295" translate="yes" xml:space="preserve">
          <source>The operand of a unary &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference&lt;/a&gt; operator.</source>
          <target state="translated">El operando de un operador unario de &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;pr&amp;eacute;stamo&lt;/a&gt; o &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;desreferencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfdf71c707b06cc703ce65b9173f06d5346346a9" translate="yes" xml:space="preserve">
          <source>The operand of an extending &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f114bcdcaebb0db94cec84309f6c6e9289e758" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8300616806da6883f068d3a939bb5817283d75af" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">El operando de cualquier &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;pr&amp;eacute;stamo impl&amp;iacute;cito&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13205f7dcdf1bb624db42e4217ccc5c5fe9a6c93" translate="yes" xml:space="preserve">
          <source>The operand of any extending borrow expression has its temporary scope extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0018d918b5db8fa5a5c40594da4082243e89b941" translate="yes" xml:space="preserve">
          <source>The operand(s) of an extending &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;, &lt;a href=&quot;expressions/struct-expr&quot;&gt;braced struct&lt;/a&gt;, or &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02413f33b0997a467453e2cc175754042613115c" translate="yes" xml:space="preserve">
          <source>The operation failed because a pipe was closed.</source>
          <target state="translated">La operación fracasó porque se cerró una tubería.</target>
        </trans-unit>
        <trans-unit id="e0b6b6bb05edcbe700535a8a02fd6257faeb1085" translate="yes" xml:space="preserve">
          <source>The operation lacked the necessary privileges to complete.</source>
          <target state="translated">La operación carecía de los privilegios necesarios para completarla.</target>
        </trans-unit>
        <trans-unit id="d56bd5ac430688946f617fddd5ff8737ea77aabc" translate="yes" xml:space="preserve">
          <source>The operation needs to block to complete, but the blocking operation was requested to not occur.</source>
          <target state="translated">La operación debe bloquearse para completarse,pero se pidió que la operación de bloqueo no se produjera.</target>
        </trans-unit>
        <trans-unit id="554600e43876fa49fe1808261768a1599008a1a5" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; may be applied to operands of boolean type. The &lt;code&gt;||&lt;/code&gt; operator denotes logical 'or', and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator denotes logical 'and'. They differ from &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, &lt;code&gt;||&lt;/code&gt; only evaluates its right-hand operand when the left-hand operand evaluates to &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; only when it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Los operadores &lt;code&gt;||&lt;/code&gt; y &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; se puede aplicar a operandos de tipo booleano. El &lt;code&gt;||&lt;/code&gt; El operador denota una 'o' l&amp;oacute;gica, y el operador &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; denota una 'y' l&amp;oacute;gica. Se diferencian de &lt;code&gt;|&lt;/code&gt; y &lt;code&gt;&amp;amp;&lt;/code&gt; en que el operando de la derecha solo se eval&amp;uacute;a cuando el operando de la izquierda no determina ya el resultado de la expresi&amp;oacute;n. Es decir, &lt;code&gt;||&lt;/code&gt; solo eval&amp;uacute;a su operando de la derecha cuando el operando de la izquierda se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; , y &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; solo cuando se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a90205d7a5e5f5664d5fdcbd09052010d467f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 byte order mark&lt;/em&gt;&lt;/a&gt; (UTF8BOM production) indicates that the file is encoded in UTF8. It can only occur at the beginning of the file and is ignored by the compiler.</source>
          <target state="translated">La &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;marca de orden de bytes UTF8&lt;/em&gt;&lt;/a&gt; opcional (producci&amp;oacute;n UTF8BOM) indica que el archivo est&amp;aacute; codificado en UTF8. Solo puede ocurrir al principio del archivo y el compilador lo ignora.</target>
        </trans-unit>
        <trans-unit id="22d7081f01819ecc0a53443b4c5e3e1a4e2c048a" translate="yes" xml:space="preserve">
          <source>The optional fill character and alignment is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. It must be defined before &lt;code&gt;width&lt;/code&gt;, right after the &lt;code&gt;:&lt;/code&gt;. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. Filling comes in the following variants for different alignments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef92817d2fa5638a8f8e4bfed63d30ce997249b" translate="yes" xml:space="preserve">
          <source>The order in which this iterator returns entries is platform and filesystem dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60297fe01f4f2a21350a894e6ee139ac8e93f1b8" translate="yes" xml:space="preserve">
          <source>The order in which to evaluate the sub-expressions</source>
          <target state="translated">El orden en que se evalúan las subexpresiones</target>
        </trans-unit>
        <trans-unit id="61bedc7c16635e05c26ee08451d7e761461ef5bb" translate="yes" xml:space="preserve">
          <source>The organizational problem of allocating responsibility for multiple tasks to the &lt;code&gt;main&lt;/code&gt; function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when &lt;code&gt;main&lt;/code&gt; starts getting large. The process has the following steps:</source>
          <target state="translated">El problema organizativo de asignar la responsabilidad de m&amp;uacute;ltiples tareas a la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; es com&amp;uacute;n a muchos proyectos binarios. Como resultado, la comunidad de Rust ha desarrollado un proceso para usar como gu&amp;iacute;a para dividir las preocupaciones separadas de un programa binario cuando &lt;code&gt;main&lt;/code&gt; comienza a crecer. El proceso tiene los siguientes pasos:</target>
        </trans-unit>
        <trans-unit id="41be0c260fec224b2719e05df384f73991bede1b" translate="yes" xml:space="preserve">
          <source>The other arm of the &lt;code&gt;match&lt;/code&gt; handles the case where we get an &lt;code&gt;Err&lt;/code&gt; value from &lt;code&gt;File::open&lt;/code&gt;. In this example, we&amp;rsquo;ve chosen to call the &lt;code&gt;panic!&lt;/code&gt; macro. If there&amp;rsquo;s no file named &lt;em&gt;hello.txt&lt;/em&gt; in our current directory and we run this code, we&amp;rsquo;ll see the following output from the &lt;code&gt;panic!&lt;/code&gt; macro:</source>
          <target state="translated">El otro brazo del &lt;code&gt;match&lt;/code&gt; maneja el caso donde obtenemos un valor &lt;code&gt;Err&lt;/code&gt; de &lt;code&gt;File::open&lt;/code&gt; . En este ejemplo, &amp;iexcl;hemos elegido llamar al &lt;code&gt;panic!&lt;/code&gt; macro. Si no hay un archivo llamado &lt;em&gt;hello.txt&lt;/em&gt; en nuestro directorio actual y ejecutamos este c&amp;oacute;digo, &amp;iexcl;veremos la siguiente salida del &lt;code&gt;panic!&lt;/code&gt; macro:</target>
        </trans-unit>
        <trans-unit id="a7bf4938ef9d644fa6590a14199d49f21d906882" translate="yes" xml:space="preserve">
          <source>The other difference between &lt;code&gt;mut&lt;/code&gt; and shadowing is that because we&amp;rsquo;re effectively creating a new variable when we use the &lt;code&gt;let&lt;/code&gt; keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</source>
          <target state="translated">La otra diferencia entre &lt;code&gt;mut&lt;/code&gt; y shadowing es que debido a que estamos creando efectivamente una nueva variable cuando usamos la palabra clave &lt;code&gt;let&lt;/code&gt; nuevamente, podemos cambiar el tipo de valor pero reutilizar el mismo nombre. Por ejemplo, digamos que nuestro programa le pide a un usuario que muestre cu&amp;aacute;ntos espacios quiere entre un texto ingresando caracteres de espacio, pero realmente queremos almacenar esa entrada como un n&amp;uacute;mero:</target>
        </trans-unit>
        <trans-unit id="df7669a1bf85d9740015e4131e57d2cd1eb9d9d3" translate="yes" xml:space="preserve">
          <source>The other main use of the &lt;code&gt;const&lt;/code&gt; keyword is in &lt;code&gt;const fn&lt;/code&gt;. This marks a function as being callable in the body of a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; item and in array initializers (commonly called &quot;const contexts&quot;). &lt;code&gt;const fn&lt;/code&gt; are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time. See the &lt;a href=&quot;../reference/const_eval&quot;&gt;Reference&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27877809931e30e4d816c929aaf44550dc13948" translate="yes" xml:space="preserve">
          <source>The other option is to decide that pinning is &quot;structural&quot; for &lt;code&gt;field&lt;/code&gt;, meaning that if the struct is pinned then so is the field.</source>
          <target state="translated">La otra opci&amp;oacute;n es decidir que la fijaci&amp;oacute;n es &quot;estructural&quot; para el &lt;code&gt;field&lt;/code&gt; , lo que significa que si la estructura est&amp;aacute; fijada, tambi&amp;eacute;n lo ser&amp;aacute; el campo.</target>
        </trans-unit>
        <trans-unit id="0642ecd58583a2694ae6dacfe0a415f63c694440" translate="yes" xml:space="preserve">
          <source>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called &lt;em&gt;polymorphism&lt;/em&gt;, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</source>
          <target state="translated">La otra raz&amp;oacute;n para usar la herencia se relaciona con el sistema de tipos: permitir que un tipo hijo se use en los mismos lugares que el tipo padre. Esto tambi&amp;eacute;n se denomina &lt;em&gt;polimorfismo&lt;/em&gt; , lo que significa que puede sustituir varios objetos entre s&amp;iacute; en tiempo de ejecuci&amp;oacute;n si comparten determinadas caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="89dc389d4ca8b1b17999395cda6f46045ddfd179" translate="yes" xml:space="preserve">
          <source>The other use of the &lt;code&gt;impl&lt;/code&gt; keyword is in &lt;code&gt;impl Trait&lt;/code&gt; syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.</source>
          <target state="translated">El otro uso de la palabra clave &lt;code&gt;impl&lt;/code&gt; es en la sintaxis de &lt;code&gt;impl Trait&lt;/code&gt; , que puede verse como una abreviatura de &quot;un tipo concreto que implementa este rasgo&quot;. Su uso principal es trabajar con cierres, que tienen definiciones de tipo generadas en tiempo de compilaci&amp;oacute;n que no se pueden escribir simplemente.</target>
        </trans-unit>
        <trans-unit id="5fa7bdd2f67d8992d16557677350c79fe148aa6f" translate="yes" xml:space="preserve">
          <source>The other way to solve this error is to make the private type public. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b16008db0e7fefb3576376fa59c7cdb24bc4ca" translate="yes" xml:space="preserve">
          <source>The outer scope declares a variable named &lt;code&gt;r&lt;/code&gt; with no initial value, and the inner scope declares a variable named &lt;code&gt;x&lt;/code&gt; with the initial value of 5. Inside the inner scope, we attempt to set the value of &lt;code&gt;r&lt;/code&gt; as a reference to &lt;code&gt;x&lt;/code&gt;. Then the inner scope ends, and we attempt to print the value in &lt;code&gt;r&lt;/code&gt;. This code won&amp;rsquo;t compile because the value &lt;code&gt;r&lt;/code&gt; is referring to has gone out of scope before we try to use it. Here is the error message:</source>
          <target state="translated">El alcance externo declara una variable llamada &lt;code&gt;r&lt;/code&gt; sin valor inicial, y el alcance interno declara una variable llamada &lt;code&gt;x&lt;/code&gt; con el valor inicial de 5. Dentro del alcance interno, intentamos establecer el valor de &lt;code&gt;r&lt;/code&gt; como una referencia a &lt;code&gt;x&lt;/code&gt; . Luego, el alcance interno termina e intentamos imprimir el valor en &lt;code&gt;r&lt;/code&gt; . Este c&amp;oacute;digo no se compilar&amp;aacute; porque el valor al que se refiere &lt;code&gt;r&lt;/code&gt; ha salido del alcance antes de que intentemos usarlo. Aqu&amp;iacute; est&amp;aacute; el mensaje de error:</target>
        </trans-unit>
        <trans-unit id="ee4813584901b6edf7255c9100533eb924eb1e04" translate="yes" xml:space="preserve">
          <source>The output of a finished process.</source>
          <target state="translated">La salida de un proceso terminado.</target>
        </trans-unit>
        <trans-unit id="7091d6ad7f032d028b64c465cb0226168ae0e89e" translate="yes" xml:space="preserve">
          <source>The output of this function should not be used in anything that might have security implications. For example:</source>
          <target state="translated">El resultado de esta función no debe utilizarse en nada que pueda tener implicaciones para la seguridad.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c978821bc364ab92333f8a77fd4cf50814193dc4" translate="yes" xml:space="preserve">
          <source>The output that the future will produce on completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5a226f1cb2eaa0ff96072c4caeb2fee856332d" translate="yes" xml:space="preserve">
          <source>The output type returned by methods.</source>
          <target state="translated">El tipo de salida devuelto por los métodos.</target>
        </trans-unit>
        <trans-unit id="b3fedfd8280044a357b6d9f266e6194249a97d9a" translate="yes" xml:space="preserve">
          <source>The output will be the recommended workout plan. Listing 13-2 shows the &lt;code&gt;main&lt;/code&gt; function we&amp;rsquo;ll use.</source>
          <target state="translated">El resultado ser&amp;aacute; el plan de entrenamiento recomendado. El Listado 13-2 muestra la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; que usaremos.</target>
        </trans-unit>
        <trans-unit id="884c1b47c0faf2e5f38e29c6c1a9622d7629d70c" translate="yes" xml:space="preserve">
          <source>The overall goal of these requirements is to let the consumer of a pipeline use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c750221db5bde24f0432e5395fa0e7d6b2249e8f" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;buf&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39c88ef6b933b61e4ea4a039f34870326ac716b" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">La propiedad de &lt;code&gt;ptr&lt;/code&gt; se transfiere efectivamente a la &lt;code&gt;String&lt;/code&gt; que luego puede desasignar, reasignar o cambiar el contenido de la memoria apuntado por el puntero a voluntad. Aseg&amp;uacute;rese de que nada m&amp;aacute;s use el puntero despu&amp;eacute;s de llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0c5ac2aeb05d71a34b822c034365a66e97f5d90e" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">La propiedad de &lt;code&gt;ptr&lt;/code&gt; se transfiere efectivamente al &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; que luego puede desasignar, reasignar o cambiar el contenido de la memoria apuntado por el puntero a voluntad. Aseg&amp;uacute;rese de que nada m&amp;aacute;s use el puntero despu&amp;eacute;s de llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="459d615a7b443b2b18398d7b4e4094d21aa9904a" translate="yes" xml:space="preserve">
          <source>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by &lt;code&gt;drop&lt;/code&gt; unless the data has been moved to be owned by another variable.</source>
          <target state="translated">La propiedad de una variable sigue el mismo patr&amp;oacute;n cada vez: asignar un valor a otra variable la mueve. Cuando una variable que incluye datos en el mont&amp;oacute;n sale del alcance, el valor se borrar&amp;aacute; por &lt;code&gt;drop&lt;/code&gt; menos que los datos se hayan movido para ser propiedad de otra variable.</target>
        </trans-unit>
        <trans-unit id="8158170312c35ad0b4ff632e830474174c9789f6" translate="yes" xml:space="preserve">
          <source>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let&amp;rsquo;s do an experiment to show how channels and ownership work together to prevent problems: we&amp;rsquo;ll try to use a &lt;code&gt;val&lt;/code&gt; value in the spawned thread &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn&amp;rsquo;t allowed:</source>
          <target state="translated">Las reglas de propiedad juegan un papel vital en el env&amp;iacute;o de mensajes porque lo ayudan a escribir c&amp;oacute;digo concurrente y seguro. La prevenci&amp;oacute;n de errores en la programaci&amp;oacute;n concurrente es la ventaja de pensar en la propiedad en todos sus programas de Rust. Hagamos un experimento para mostrar c&amp;oacute;mo los canales y la propiedad funcionan juntos para evitar problemas: intentaremos usar un valor &lt;code&gt;val&lt;/code&gt; en el hilo generado &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; enviarlo por el canal. Intente compilar el c&amp;oacute;digo en el Listado 16-9 para ver por qu&amp;eacute; este c&amp;oacute;digo no est&amp;aacute; permitido:</target>
        </trans-unit>
        <trans-unit id="58f56a016b810f8287c744364955b1ffc32f9240" translate="yes" xml:space="preserve">
          <source>The panic hook is a global resource.</source>
          <target state="translated">El gancho del pánico es un recurso global.</target>
        </trans-unit>
        <trans-unit id="684aef30b999855f4bf1399a43d22fd82b7e6c9d" translate="yes" xml:space="preserve">
          <source>The panic hook is invoked when a thread panics, but before the panic runtime is invoked. As such, the hook will run with both the aborting and unwinding runtimes. The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the &lt;code&gt;set_hook&lt;/code&gt; and &lt;a href=&quot;fn.take_hook&quot;&gt;&lt;code&gt;take_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">El gancho de p&amp;aacute;nico se invoca cuando un hilo entra en p&amp;aacute;nico, pero antes de que se invoca el tiempo de ejecuci&amp;oacute;n de p&amp;aacute;nico. Como tal, el gancho se ejecutar&amp;aacute; con los tiempos de ejecuci&amp;oacute;n de aborto y desenrollado. El gancho predeterminado imprime un mensaje de error est&amp;aacute;ndar y genera un seguimiento si se solicita, pero este comportamiento se puede personalizar con las funciones &lt;code&gt;set_hook&lt;/code&gt; y &lt;a href=&quot;fn.take_hook&quot;&gt; &lt;code&gt;take_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="563c97e45aeee516b45222324d4cc368e8c084ba" translate="yes" xml:space="preserve">
          <source>The parameters given to &lt;code&gt;Layout::from_size_align&lt;/code&gt; or some other &lt;code&gt;Layout&lt;/code&gt; constructor do not satisfy its documented constraints.</source>
          <target state="translated">Los par&amp;aacute;metros dados a &lt;code&gt;Layout::from_size_align&lt;/code&gt; o alg&amp;uacute;n otro constructor de &lt;code&gt;Layout&lt;/code&gt; no satisfacen sus restricciones documentadas.</target>
        </trans-unit>
        <trans-unit id="3c2a54faaf19386dc2b06158bf3003e146fc0f45" translate="yes" xml:space="preserve">
          <source>The parameters of any trait method must match between a trait implementation and the trait definition.</source>
          <target state="translated">Los parámetros de cualquier método de rasgos deben coincidir entre la implementación de un rasgo y la definición del mismo.</target>
        </trans-unit>
        <trans-unit id="df3b8f99f35d92ad550b740bf7dc9171d35b97ed" translate="yes" xml:space="preserve">
          <source>The parent of a statement scope is the scope of the block that contains the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46091b9f972d668faf65caa23b2e09a8a170568" translate="yes" xml:space="preserve">
          <source>The parent of all other scopes is the scope of the immediately enclosing expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04065a98d4b38354b6e3e4d4abb130f6c621783" translate="yes" xml:space="preserve">
          <source>The parent of the arm scope is the scope of the &lt;code&gt;match&lt;/code&gt; expression that it belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a327800a21f08b5d4e1948e88aac172c2121be" translate="yes" xml:space="preserve">
          <source>The parent of the current &lt;a href=&quot;../reference/items/modules&quot;&gt;module&lt;/a&gt;.</source>
          <target state="translated">El padre del &lt;a href=&quot;../reference/items/modules&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; actual .</target>
        </trans-unit>
        <trans-unit id="529eb4e30d49293a9076afc4b5e1cde599b49562" translate="yes" xml:space="preserve">
          <source>The parent of the expression after the &lt;code&gt;=&amp;gt;&lt;/code&gt; in a &lt;code&gt;match&lt;/code&gt; expression is the scope of the arm that it's in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf69b726f2264b18f25a14f0c4351943f8d4d50" translate="yes" xml:space="preserve">
          <source>The parent of the expression for a &lt;code&gt;match&lt;/code&gt; guard is the scope of the arm that the guard is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e7154b1118c2abd23aedcc36e2f4febf44487b" translate="yes" xml:space="preserve">
          <source>The parent of the expression in an expression statement is the scope of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1edfebb91e8c5be33d3f8d00037717971d53a2" translate="yes" xml:space="preserve">
          <source>The parent of the initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt; is the &lt;code&gt;let&lt;/code&gt; statement's scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7896dc490ba78587890c7c602aaea52ff1e61a5" translate="yes" xml:space="preserve">
          <source>The parent thread can also wait on the completion of the child thread; a call to &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; produces a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, which provides a &lt;code&gt;join&lt;/code&gt; method for waiting:</source>
          <target state="translated">El hilo principal tambi&amp;eacute;n puede esperar a que se complete el hilo secundario; una llamada para &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; produce un &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; , que proporciona un m&amp;eacute;todo de &lt;code&gt;join&lt;/code&gt; para esperar:</target>
        </trans-unit>
        <trans-unit id="46e80e0e5a125dc6b093687f5b3dfa680a2d94d7" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;inline&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">El atributo en &lt;code&gt;inline&lt;/code&gt; entre par&amp;eacute;ntesis requiere que se especifique el par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="15c1964228f17e3bf48dc3c0a27f630dfed2aef1" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;instruction_set&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2172d9db47abf995cf78b6d1056e43a62f663b4" translate="yes" xml:space="preserve">
          <source>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</source>
          <target state="translated">El analizador utilizado por el macrosistema es razonablemente potente,pero está limitado para evitar la ambigüedad en las versiones actuales o futuras del idioma.En particular,además de la regla sobre las expansiones ambiguas,un no terminal emparejado con una metavariable debe ir seguido de una ficha que se ha decidido que puede utilizarse con seguridad después de ese tipo de emparejamiento.</target>
        </trans-unit>
        <trans-unit id="72524139620fe5680057ec138f1bc4009c442555" translate="yes" xml:space="preserve">
          <source>The path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets. For &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt;, it is the canonical path of the item being implemented followed by &lt;code&gt;as&lt;/code&gt; followed by the canonical path to the trait all surrounded in angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets.</source>
          <target state="translated">El prefijo de ruta de los m&amp;oacute;dulos es la ruta can&amp;oacute;nica a ese m&amp;oacute;dulo. Para implementaciones simples, es la ruta can&amp;oacute;nica del elemento que se implementa rodeada de corchetes angulares ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ). Para &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;las implementaciones de rasgo&lt;/a&gt; , es la ruta can&amp;oacute;nica del elemento siendo implementado seguido de &lt;code&gt;as&lt;/code&gt; seguido de la ruta can&amp;oacute;nica para el rasgo todo rodeado en &amp;aacute;ngulo ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) entre par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="c6a4fb9e71adbfcd1bb4598c90adf218d993dcba" translate="yes" xml:space="preserve">
          <source>The path to the associated items is &lt;code&gt;&amp;lt;&lt;/code&gt; followed by a path to the implementing type followed by &lt;code&gt;as&lt;/code&gt; followed by a path to the trait followed by &lt;code&gt;&amp;gt;&lt;/code&gt; as a path component followed by the associated item's path component.</source>
          <target state="translated">La ruta de los elementos asociados se &lt;code&gt;&amp;lt;&lt;/code&gt; seguido por un camino a la implementaci&amp;oacute;n del tipo seguido por &lt;code&gt;as&lt;/code&gt; seguido por un camino con el rasgo seguido de &lt;code&gt;&amp;gt;&lt;/code&gt; como un componente de la ruta seguida por el componente ruta del elemento asociado.</target>
        </trans-unit>
        <trans-unit id="e791bfe4c14128fe94a9448b536323c040235679" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">El patr&amp;oacute;n puede ser un &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; o un cierre que determina si un personaje coincide.</target>
        </trans-unit>
        <trans-unit id="9b997b2f72267455f266b90593be72c411299620" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">El patr&amp;oacute;n puede ser un &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; o un cierre que determina si un personaje coincide.</target>
        </trans-unit>
        <trans-unit id="d7a545179141a5b3642800fa8e44597af1f79a17" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">El patr&amp;oacute;n puede ser un &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; o un cierre que determina si un personaje coincide.</target>
        </trans-unit>
        <trans-unit id="eab1bd44108e3c6ec8d1d8c6acc9fac3b5f45a9e" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">El patr&amp;oacute;n puede ser un &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; o un cierre que determina si un personaje coincide.</target>
        </trans-unit>
        <trans-unit id="b3313c804137756973c3dae6df1f5d957a288624" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">El patr&amp;oacute;n puede ser un &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; o un cierre que determina si un personaje coincide.</target>
        </trans-unit>
        <trans-unit id="bfcc6e07c89f929bc9a9b9157ac58712686768e0" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">El patr&amp;oacute;n puede ser de cualquier tipo que implemente el rasgo del Patr&amp;oacute;n. Ejemplos notables son &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; y los cierres que determinan la divisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb766e07c7ab39fe3b62bc217205480afe2f8cd2" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">El patr&amp;oacute;n puede ser de cualquier tipo que implemente el rasgo del Patr&amp;oacute;n. Ejemplos notables son &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; y los cierres que determinan la divisi&amp;oacute;n. Las bibliotecas adicionales pueden proporcionar patrones m&amp;aacute;s complejos, como expresiones regulares.</target>
        </trans-unit>
        <trans-unit id="53665fb10463c2a5a8c8a6c23b4c3d2013b572a7" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">El patr&amp;oacute;n puede ser de cualquier tipo que implemente el rasgo del Patr&amp;oacute;n. Ejemplos notables son &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; y los cierres que determinan la divisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8059c918e0a15a39f2f09be5faf1d4cb011e74e6" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">El patr&amp;oacute;n puede ser de cualquier tipo que implemente el rasgo del Patr&amp;oacute;n. Ejemplos notables son &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; y los cierres que determinan la divisi&amp;oacute;n. Las bibliotecas adicionales pueden proporcionar patrones m&amp;aacute;s complejos, como expresiones regulares.</target>
        </trans-unit>
        <trans-unit id="70fe7a4be65487325b69a6e9166bdb513323e0b5" translate="yes" xml:space="preserve">
          <source>The pattern in the following example does four things:</source>
          <target state="translated">El patrón del siguiente ejemplo hace cuatro cosas:</target>
        </trans-unit>
        <trans-unit id="5a181811e45dbf2fc9dddcbe8e2017ec7127d78e" translate="yes" xml:space="preserve">
          <source>The pattern in the second match arm introduces a new variable named &lt;code&gt;y&lt;/code&gt; that will match any value inside a &lt;code&gt;Some&lt;/code&gt; value. Because we&amp;rsquo;re in a new scope inside the &lt;code&gt;match&lt;/code&gt; expression, this is a new &lt;code&gt;y&lt;/code&gt; variable, not the &lt;code&gt;y&lt;/code&gt; we declared at the beginning with the value 10. This new &lt;code&gt;y&lt;/code&gt; binding will match any value inside a &lt;code&gt;Some&lt;/code&gt;, which is what we have in &lt;code&gt;x&lt;/code&gt;. Therefore, this new &lt;code&gt;y&lt;/code&gt; binds to the inner value of the &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. That value is &lt;code&gt;5&lt;/code&gt;, so the expression for that arm executes and prints &lt;code&gt;Matched, y = 5&lt;/code&gt;.</source>
          <target state="translated">El patr&amp;oacute;n en el segundo brazo de coincidencia introduce una nueva variable llamada &lt;code&gt;y&lt;/code&gt; que coincidir&amp;aacute; con cualquier valor dentro de un valor &lt;code&gt;Some&lt;/code&gt; . Debido a que estamos en un nuevo &amp;aacute;mbito en el interior del &lt;code&gt;match&lt;/code&gt; expresi&amp;oacute;n, esta es una nueva &lt;code&gt;y&lt;/code&gt; variables, no el &lt;code&gt;y&lt;/code&gt; declaramos al principio con el valor 10. Este nuevo &lt;code&gt;y&lt;/code&gt; vinculante coincidir&amp;aacute; con cualquier valor dentro de un &lt;code&gt;Some&lt;/code&gt; , que es lo que tenemos en &lt;code&gt;x&lt;/code&gt; . Por lo tanto, esta nueva &lt;code&gt;y&lt;/code&gt; se une al valor interno de &lt;code&gt;Some&lt;/code&gt; en &lt;code&gt;x&lt;/code&gt; . Ese valor es &lt;code&gt;5&lt;/code&gt; , por lo que la expresi&amp;oacute;n para ese brazo se ejecuta e imprime &lt;code&gt;Matched, y = 5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1b310fb5c60706a33dc63407dcff2f0de81ecd" translate="yes" xml:space="preserve">
          <source>The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable. Apart from that, patterns used in &lt;code&gt;let&lt;/code&gt; bindings can be as complicated as needed, given that the pattern is exhaustive. See the &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust book&lt;/a&gt; for more information on pattern matching. The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.</source>
          <target state="translated">Por lo general, el patr&amp;oacute;n es una sola variable, lo que significa que no se realiza ninguna coincidencia de patrones y la expresi&amp;oacute;n dada est&amp;aacute; vinculada a la variable. Aparte de eso, los patrones utilizados en &lt;code&gt;let&lt;/code&gt; fijaciones pueden ser tan complicado como sea necesario, teniendo en cuenta que el patr&amp;oacute;n es exhaustiva. Consulte el &lt;a href=&quot;../book/ch06-02-match&quot;&gt;libro de Rust&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la coincidencia de patrones. El tipo de patr&amp;oacute;n se da opcionalmente despu&amp;eacute;s, pero si se deja en blanco, el compilador lo infiere autom&amp;aacute;ticamente si es posible.</target>
        </trans-unit>
        <trans-unit id="c2459ac3b35f7ffa8e048896d3c16ca10cfe1608" translate="yes" xml:space="preserve">
          <source>The pattern of the first arm in the &lt;code&gt;match&lt;/code&gt; expression matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant that contains a &lt;code&gt;Color::Rgb&lt;/code&gt; variant; then the pattern binds to the three inner &lt;code&gt;i32&lt;/code&gt; values. The pattern of the second arm also matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant, but the inner enum matches the &lt;code&gt;Color::Hsv&lt;/code&gt; variant instead. We can specify these complex conditions in one &lt;code&gt;match&lt;/code&gt; expression, even though two enums are involved.</source>
          <target state="translated">El patr&amp;oacute;n del primer brazo en el &lt;code&gt;match&lt;/code&gt; la expresi&amp;oacute;n coincide con un &lt;code&gt;Message::ChangeColor&lt;/code&gt; enumeraci&amp;oacute;n variante que contiene un &lt;code&gt;Color::Rgb&lt;/code&gt; variante; luego el patr&amp;oacute;n se une a los tres valores internos de &lt;code&gt;i32&lt;/code&gt; . El patr&amp;oacute;n del segundo brazo tambi&amp;eacute;n coincide con una variante de enumeraci&amp;oacute;n &lt;code&gt;Message::ChangeColor&lt;/code&gt; , pero la enumeraci&amp;oacute;n interna coincide con la variante &lt;code&gt;Color::Hsv&lt;/code&gt; lugar. Podemos especificar estas condiciones complejas en una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; , aunque hay dos enumeraciones involucradas.</target>
        </trans-unit>
        <trans-unit id="a42d62f0f2bbc370e10f35406b8b10d13fb51143" translate="yes" xml:space="preserve">
          <source>The patterns programmed into Rust&amp;rsquo;s analysis of references are called the &lt;em&gt;lifetime elision rules&lt;/em&gt;. These aren&amp;rsquo;t rules for programmers to follow; they&amp;rsquo;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&amp;rsquo;t need to write the lifetimes explicitly.</source>
          <target state="translated">Los patrones programados en el an&amp;aacute;lisis de referencias de Rust se denominan &lt;em&gt;reglas de elisi&amp;oacute;n de por vida&lt;/em&gt; . Estas no son reglas que los programadores deben seguir; son un conjunto de casos particulares que el compilador considerar&amp;aacute;, y si su c&amp;oacute;digo se ajusta a estos casos, no es necesario que escriba las vidas de forma expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="012a0566d4550e7174697625c83965140d98cc31" translate="yes" xml:space="preserve">
          <source>The peer address may be set by the &lt;code&gt;connect&lt;/code&gt; method, and this method will return an error if the socket has not already been connected.</source>
          <target state="translated">La direcci&amp;oacute;n del par se puede establecer mediante el m&amp;eacute;todo de &lt;code&gt;connect&lt;/code&gt; , y este m&amp;eacute;todo devolver&amp;aacute; un error si el enchufe a&amp;uacute;n no se ha conectado.</target>
        </trans-unit>
        <trans-unit id="c7338ebe0eb2e257ec72f81d23df2b1d8ecc7ce7" translate="yes" xml:space="preserve">
          <source>The performance of these two features (Spoiler alert: they&amp;rsquo;re faster than you might think!)</source>
          <target state="translated">El rendimiento de estas dos funciones (alerta de spoiler: &amp;iexcl;son m&amp;aacute;s r&amp;aacute;pidas de lo que piensas!)</target>
        </trans-unit>
        <trans-unit id="b42828007b197505190540700b376ffcea8793e7" translate="yes" xml:space="preserve">
          <source>The pointer is valid only if there are some strong references. The pointer may be dangling, unaligned or even &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c13daf063b9e605b83028dc0feae2167ff80511" translate="yes" xml:space="preserve">
          <source>The pointer may be &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or be dangling in case the object has already been destroyed.</source>
          <target state="translated">El puntero puede ser &lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; o estar colgando en caso de que el objeto ya haya sido destruido.</target>
        </trans-unit>
        <trans-unit id="c51f7cfe5691f3edc0397a76000e0e31815c58dc" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6cc95e7b609b2c158e2115aa97ef7549141c5d" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab75a519555d7d953b751dc8250587661100bb4" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032bd62f596d84915c186de815c7e316435955e0" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada677800eded9f5bb09a12d4c9272e1a48a79a4" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6efbb545be55e13f893ac7dc6eaebbf999874a" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7882f94a6f87dc84506e67cf6e6f86cd53b02982" translate="yes" xml:space="preserve">
          <source>The pointer must be properly aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3de011a05d32ff014b1d75b10f32cd8a5ceea0c" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97c31e45ac08eaf340466af2855c1d69a8c822f" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final &lt;code&gt;Arc&lt;/code&gt; and backing storage, but &lt;strong&gt;should not&lt;/strong&gt; be called after the final &lt;code&gt;Arc&lt;/code&gt; has been released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b7d63adfc51a7db20582294688b5c6c47a0e5f" translate="yes" xml:space="preserve">
          <source>The pointer must have originated from the &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; and must still own its potential weak reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561496e3426c59f66cb3091efa83ade648ff436f" translate="yes" xml:space="preserve">
          <source>The pointer must point to an initialized instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d562cc44e11330190c6c67edae5c28019986b445" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">El puntero debe representar un recuento d&amp;eacute;bil v&amp;aacute;lido. En otras palabras, debe apuntar a &lt;code&gt;T&lt;/code&gt; que es o &lt;em&gt;fue&lt;/em&gt; administrado por un &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; o&lt;/a&gt; y la cuenta d&amp;eacute;bil de ese &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; o.&lt;/a&gt; no debe haber llegado a 0. Se permite que la cuenta fuerte sea 0.</target>
        </trans-unit>
        <trans-unit id="20794b93602408cab637197663bf6c675231f221" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">El puntero debe representar un recuento d&amp;eacute;bil v&amp;aacute;lido. En otras palabras, debe apuntar a &lt;code&gt;T&lt;/code&gt; que es o &lt;em&gt;fue&lt;/em&gt; manejado por un &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; y el conteo d&amp;eacute;bil de ese &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; no debe haber llegado a 0. Se permite que el conteo fuerte sea 0.</target>
        </trans-unit>
        <trans-unit id="d6200eb92cc97fc1d9fec6dde1612acc6fca320f" translate="yes" xml:space="preserve">
          <source>The pointer passed to all functions inside the vtable is the &lt;code&gt;data&lt;/code&gt; pointer from the enclosing &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">El puntero que se pasa a todas las funciones dentro de vtable es el puntero de &lt;code&gt;data&lt;/code&gt; del &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; adjunto&lt;/a&gt; objeto .</target>
        </trans-unit>
        <trans-unit id="1edb65c05d4061d65ef7c599b48750ef7ff50704" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">El puntero que devuelve esta funci&amp;oacute;n debe devolverse a Rust y reconstituirse utilizando &lt;a href=&quot;#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt; para desasignarlo correctamente. Espec&amp;iacute;ficamente, &lt;em&gt;no se&lt;/em&gt; debe usar la funci&amp;oacute;n est&amp;aacute;ndar de C &lt;code&gt;free()&lt;/code&gt; para desasignar esta cadena.</target>
        </trans-unit>
        <trans-unit id="80c5d8a7d931f08c90875d736c69378d02a8b64f" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33be8edf304b61e5005625c2c6aab855fc0ce0b3" translate="yes" xml:space="preserve">
          <source>The pointer will be properly aligned and non-null.</source>
          <target state="translated">El puntero estará bien alineado y no será nulo.</target>
        </trans-unit>
        <trans-unit id="0c49a977fe21d66debc9a4c8b7d4cbbf312c9ff9" translate="yes" xml:space="preserve">
          <source>The pointer-sized signed integer type.</source>
          <target state="translated">El tipo entero firmado del tamaño de un puntero.</target>
        </trans-unit>
        <trans-unit id="aebc6996cd3e6c3ef507e0e5f263e13ad4dcb04b" translate="yes" xml:space="preserve">
          <source>The pointer-sized unsigned integer type.</source>
          <target state="translated">El tipo entero sin signo del tamaño de un puntero.</target>
        </trans-unit>
        <trans-unit id="589a00e779c762d350b4058d583ec6c935c455c7" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; had no internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef48aecfebe1bd9e6f96a0939bb1d8fec84054" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">La posici&amp;oacute;n utilizada para buscar con &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; es la posici&amp;oacute;n en la que estar&amp;iacute;a el lector subyacente si el &lt;code&gt;BufReader&lt;/code&gt; no tuviera un b&amp;uacute;fer interno.</target>
        </trans-unit>
        <trans-unit id="6f1678b0e093177e7620807a9112f4ef7365e563" translate="yes" xml:space="preserve">
          <source>The positive difference of two numbers.</source>
          <target state="translated">La diferencia positiva de dos números.</target>
        </trans-unit>
        <trans-unit id="e0a83025808dfefbef9f39106ce5fafd89bb2f1c" translate="yes" xml:space="preserve">
          <source>The practical use cases for &lt;code&gt;forget&lt;/code&gt; are rather specialized and mainly come up in unsafe or FFI code.</source>
          <target state="translated">Los casos de uso pr&amp;aacute;cticos para el &lt;code&gt;forget&lt;/code&gt; son bastante especializados y se presentan principalmente en c&amp;oacute;digo inseguro o FFI.</target>
        </trans-unit>
        <trans-unit id="fb2efbc552f75b7ae8fe422ecdae2c87a030f044" translate="yes" xml:space="preserve">
          <source>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</source>
          <target state="translated">La precedencia de los operadores y expresiones de Rust se ordena de la siguiente manera,yendo de fuerte a débil.Los operadores binarios del mismo nivel de precedencia se agrupan en el orden que les da su asociatividad.</target>
        </trans-unit>
        <trans-unit id="5ed57a298428ca0f7395d0616c5eb17f0804c549" translate="yes" xml:space="preserve">
          <source>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</source>
          <target state="translated">Las reglas precisas de aliasing de Rust están un poco en flujo,pero los puntos principales no son polémicos:</target>
        </trans-unit>
        <trans-unit id="b19f5cee233892caf5ddceb163f25862486da448" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40bd8a03d88e20d491263cadc1752cd72c99258" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">La definici&amp;oacute;n precisa es: un tipo &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; si y solo si &lt;code&gt;&amp;amp;T&lt;/code&gt; es &lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; . En otras palabras, si no hay posibilidad de &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;un comportamiento indefinido&lt;/a&gt; (incluidas las carreras de datos) al pasar &lt;code&gt;&amp;amp;T&lt;/code&gt; referencias entre hilos.</target>
        </trans-unit>
        <trans-unit id="f47fdb8c6eff67732e48f22a8373d2422de700a9" translate="yes" xml:space="preserve">
          <source>The precise memory layout of a struct is not specified. One can specify a particular layout using the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">No se especifica el dise&amp;ntilde;o de memoria preciso de una estructura. Se puede especificar un dise&amp;ntilde;o particular utilizando el &lt;a href=&quot;../type-layout#representations&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;repr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18073d476ac74d19109a41401163857e8cd5056d" translate="yes" xml:space="preserve">
          <source>The precise rules for validity are not determined yet. The guarantees that are provided at this point are very minimal:</source>
          <target state="translated">Las normas precisas de validez no están aún determinadas.Las garantías que se ofrecen en este momento son mínimas:</target>
        </trans-unit>
        <trans-unit id="4933f50236b0c7e48edc0beedb70199f13c5e285" translate="yes" xml:space="preserve">
          <source>The predicate passed to &lt;code&gt;partition()&lt;/code&gt; can return &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;partition()&lt;/code&gt; returns a pair, all of the elements for which it returned &lt;code&gt;true&lt;/code&gt;, and all of the elements for which it returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">El predicado pasado a la &lt;code&gt;partition()&lt;/code&gt; puede devolver &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;partition()&lt;/code&gt; devuelve un par, todos los elementos para los que devolvi&amp;oacute; &lt;code&gt;true&lt;/code&gt; y todos los elementos para los que devolvi&amp;oacute; &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb4a93626b0bdb54fdbc20512bf4f76ed5cc7cd" translate="yes" xml:space="preserve">
          <source>The preferred alignment of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc19e95dcebc744b29e267ad8d2ebfde2e212c0" translate="yes" xml:space="preserve">
          <source>The prelude can be changed to the &lt;em&gt;core prelude&lt;/em&gt; by using the &lt;code&gt;no_std&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; on the root crate module. The linked crate is &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt;&lt;code&gt;core::prelude::v1&lt;/code&gt;&lt;/a&gt;. Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. &lt;code&gt;Box&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt;) and file and network capabilities (e.g. &lt;code&gt;std::fs&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt;).</source>
          <target state="translated">El preludio se puede cambiar al &lt;em&gt;preludio principal&lt;/em&gt; utilizando el &lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;no_std&lt;/code&gt; en el m&amp;oacute;dulo de caja ra&amp;iacute;z. La caja vinculada es &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt; &lt;code&gt;core&lt;/code&gt; &lt;/a&gt; y el m&amp;oacute;dulo preludio es &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt; &lt;code&gt;core::prelude::v1&lt;/code&gt; &lt;/a&gt; . El uso del preludio principal sobre el preludio est&amp;aacute;ndar es &amp;uacute;til cuando la caja est&amp;aacute; apuntando a una plataforma que no es compatible con la biblioteca est&amp;aacute;ndar o no est&amp;aacute; utilizando intencionalmente las capacidades de la biblioteca est&amp;aacute;ndar. Esas capacidades son principalmente la asignaci&amp;oacute;n de memoria din&amp;aacute;mica (por ejemplo, &lt;code&gt;Box&lt;/code&gt; y &lt;code&gt;Vec&lt;/code&gt; ) y las capacidades de archivo y red (por ejemplo, &lt;code&gt;std::fs&lt;/code&gt; y &lt;code&gt;std::io&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="97af9d37776d235cea4e5a19d84cc2b3492bd088" translate="yes" xml:space="preserve">
          <source>The previous Appendix D, &amp;ldquo;Macros,&amp;rdquo; has been expanded to include procedural macros and was moved to the &amp;ldquo;Macros&amp;rdquo; section in Chapter 19.</source>
          <target state="translated">El Ap&amp;eacute;ndice D anterior, &quot;Macros&quot;, se ha ampliado para incluir macros de procedimiento y se ha movido a la secci&amp;oacute;n &quot;Macros&quot; en el Cap&amp;iacute;tulo 19.</target>
        </trans-unit>
        <trans-unit id="757bcf5f0a1b2e7c263eb1294cae88079f56068e" translate="yes" xml:space="preserve">
          <source>The previous code example fixed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0414a5a5139b7f4e08b6a8b19dea661159e39f" translate="yes" xml:space="preserve">
          <source>The previous example contains a circular dependency between two traits: &lt;code&gt;FirstTrait&lt;/code&gt; depends on &lt;code&gt;SecondTrait&lt;/code&gt; which itself depends on &lt;code&gt;FirstTrait&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a02be48083e6dc1dccc9a7d07cadacc4a53e7c" translate="yes" xml:space="preserve">
          <source>The previously duplicated code is now outside the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks and uses the &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.</source>
          <target state="translated">El c&amp;oacute;digo previamente duplicado ahora est&amp;aacute; fuera de los bloques &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; y usa las variables &lt;code&gt;status_line&lt;/code&gt; y &lt;code&gt;filename&lt;/code&gt; . Esto hace que sea m&amp;aacute;s f&amp;aacute;cil ver la diferencia entre los dos casos, y significa que solo tenemos un lugar para actualizar el c&amp;oacute;digo si queremos cambiar c&amp;oacute;mo funcionan la lectura del archivo y la escritura de respuestas. El comportamiento del c&amp;oacute;digo del Listado 20-9 ser&amp;aacute; el mismo que el del Listado 20-8.</target>
        </trans-unit>
        <trans-unit id="3c5b34498a69e2cebc3edcacf3022a159fa0d3cf" translate="yes" xml:space="preserve">
          <source>The primary separator of path components for the current platform.</source>
          <target state="translated">El separador primario de los componentes del camino para la plataforma actual.</target>
        </trans-unit>
        <trans-unit id="d6d94c1dd4c2a4fb7b30d949d7313e70926e43b0" translate="yes" xml:space="preserve">
          <source>The primary use for the &lt;code&gt;let&lt;/code&gt; keyword is in &lt;code&gt;let&lt;/code&gt; statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.</source>
          <target state="translated">El uso principal de la palabra clave &lt;code&gt;let&lt;/code&gt; es en las sentencias &lt;code&gt;let&lt;/code&gt; , que se utilizan para introducir un nuevo conjunto de variables en el &amp;aacute;mbito actual, como lo indica un patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="14d97c2e9b793134fb211ba0f8484d81636a707d" translate="yes" xml:space="preserve">
          <source>The primary use of the &lt;code&gt;crate&lt;/code&gt; keyword is as a part of &lt;code&gt;extern crate&lt;/code&gt; declarations, which are used to specify a dependency on a crate external to the one it's declared in. Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can be read about crates in the &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">El uso principal de la palabra clave &lt;code&gt;crate&lt;/code&gt; es como parte de las declaraciones de &lt;code&gt;extern crate&lt;/code&gt; , que se utilizan para especificar una dependencia de una caja externa a aquella en la que est&amp;aacute; declarada. Las cajas son la unidad de compilaci&amp;oacute;n fundamental del c&amp;oacute;digo de Rust y pueden verse como bibliotecas o proyectos. Se puede leer m&amp;aacute;s sobre las cajas en la &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="229057a153cb547539a5140063be86de4fd5f109" translate="yes" xml:space="preserve">
          <source>The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.</source>
          <target state="translated">La política de prioridad de la cerradura depende de la implementación del sistema operativo subyacente,y este tipo no garantiza que se utilice ninguna política en particular.</target>
        </trans-unit>
        <trans-unit id="aa4bf60f4fab6128150a2cced20eb507a73f2223" translate="yes" xml:space="preserve">
          <source>The private address ranges are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; and include:</source>
          <target state="translated">Los rangos de direcciones privadas se definen en &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; e incluyen:</target>
        </trans-unit>
        <trans-unit id="66e536d148965eb5f5f66293b59e6e08d6c64117" translate="yes" xml:space="preserve">
          <source>The problem above can be solved by using the &lt;code&gt;ref&lt;/code&gt; keyword.</source>
          <target state="translated">El problema anterior se puede resolver utilizando la palabra clave &lt;code&gt;ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b09f11dabd510af2bfd7f547ade1211b4999bd" translate="yes" xml:space="preserve">
          <source>The problem here is that foo is defined as accepting a parameter of type &lt;code&gt;Fn&lt;/code&gt;. Closures passed into foo will thus be inferred to be of type &lt;code&gt;Fn&lt;/code&gt;, meaning that they capture their context immutably.</source>
          <target state="translated">El problema aqu&amp;iacute; es que foo se define aceptando un par&amp;aacute;metro de tipo &lt;code&gt;Fn&lt;/code&gt; . Por tanto, se inferir&amp;aacute; que los cierres pasados ​​a foo son de tipo &lt;code&gt;Fn&lt;/code&gt; , lo que significa que capturan su contexto de forma inmutable.</target>
        </trans-unit>
        <trans-unit id="31cdd55efce31c6be1cacdfc4b62449817b4add1" translate="yes" xml:space="preserve">
          <source>The problem here is that if the given type or one of its fields implements the &lt;code&gt;Drop&lt;/code&gt; trait, this &lt;code&gt;Drop&lt;/code&gt; implementation cannot be called within a const context since it may run arbitrary, non-const-checked code. To prevent this issue, ensure all values with custom a custom &lt;code&gt;Drop&lt;/code&gt; implementation escape the initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0a1b6d65ca057a3fdc49e919abfbdd1b60d9bd" translate="yes" xml:space="preserve">
          <source>The problem here is that the lifetime isn't contrained by any of the arguments, making it impossible to determine how long it's supposed to live.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe892e0206a6e32b9668f223826cd09ae2236ca9" translate="yes" xml:space="preserve">
          <source>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</source>
          <target state="translated">El problema aquí es que estamos tratando de tomar el tipo de X de Mi Trato.Desafortunadamente,el tipo de X no está definido,porque sólo se concreta en implementaciones del rasgo.Una versión funcional de este código podría parecerse a:</target>
        </trans-unit>
        <trans-unit id="e5cbbff1b6bec23be456b36b8e81795c5a5d74a0" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;result&lt;/code&gt; goes out of scope and gets cleaned up at the end of the &lt;code&gt;longest&lt;/code&gt; function. We&amp;rsquo;re also trying to return a reference to &lt;code&gt;result&lt;/code&gt; from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&amp;rsquo;t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</source>
          <target state="translated">El problema es que el &lt;code&gt;result&lt;/code&gt; ado se sale del alcance y se limpia al final de la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; . Tambi&amp;eacute;n estamos intentando devolver una referencia al &lt;code&gt;result&lt;/code&gt; ado de la funci&amp;oacute;n. No hay forma de que podamos especificar par&amp;aacute;metros de por vida que cambiar&amp;iacute;an la referencia colgante, y Rust no nos permitir&amp;aacute; crear una referencia colgante. En este caso, la mejor soluci&amp;oacute;n ser&amp;iacute;a devolver un tipo de datos propio en lugar de una referencia para que la funci&amp;oacute;n de llamada sea responsable de limpiar el valor.</target>
        </trans-unit>
        <trans-unit id="967a587dbf080c4427ca5b25acc74fdfbb85e443" translate="yes" xml:space="preserve">
          <source>The problem is that the first time we called &lt;code&gt;c.value&lt;/code&gt; with 1, the &lt;code&gt;Cacher&lt;/code&gt; instance saved &lt;code&gt;Some(1)&lt;/code&gt; in &lt;code&gt;self.value&lt;/code&gt;. Thereafter, no matter what we pass in to the &lt;code&gt;value&lt;/code&gt; method, it will always return 1.</source>
          <target state="translated">El problema es que la primera vez que llamamos a &lt;code&gt;c.value&lt;/code&gt; con 1, la instancia de &lt;code&gt;Cacher&lt;/code&gt; guard&amp;oacute; &lt;code&gt;Some(1)&lt;/code&gt; en &lt;code&gt;self.value&lt;/code&gt; . A partir de entonces, no importa lo que pasemos al &lt;code&gt;value&lt;/code&gt; m&amp;eacute;todo de , siempre devolver&amp;aacute; 1.</target>
        </trans-unit>
        <trans-unit id="833738d2692abe453105a9ed609d8a8bc820fa2a" translate="yes" xml:space="preserve">
          <source>The problem is that the parameter &lt;code&gt;T&lt;/code&gt; does not appear in the implementing type (&lt;code&gt;Foo&lt;/code&gt;) of the impl. In this case, we can fix the error by moving the type parameter from the &lt;code&gt;impl&lt;/code&gt; to the method &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">El problema es que el par&amp;aacute;metro &lt;code&gt;T&lt;/code&gt; no aparece en el tipo de implementaci&amp;oacute;n ( &lt;code&gt;Foo&lt;/code&gt; ) del impl. En este caso, podemos corregir el error moviendo el par&amp;aacute;metro type del &lt;code&gt;impl&lt;/code&gt; al m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="457d0fe3119f86c660d95b413dfdd79fba1ea792" translate="yes" xml:space="preserve">
          <source>The problem isn&amp;rsquo;t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, and it is &lt;a href=&quot;../std/option/enum.option&quot;&gt;defined by the standard library&lt;/a&gt; as follows:</source>
          <target state="translated">El problema no es realmente con el concepto, sino con la implementaci&amp;oacute;n particular. Como tal, Rust no tiene nulos, pero tiene una enumeraci&amp;oacute;n que puede codificar el concepto de un valor presente o ausente. Esta enumeraci&amp;oacute;n es &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , y est&amp;aacute; &lt;a href=&quot;../std/option/enum.option&quot;&gt;definida por la biblioteca est&amp;aacute;ndar de la&lt;/a&gt; siguiente manera:</target>
        </trans-unit>
        <trans-unit id="11afe9c5b7d3b341c43395982cbb657bcfedf0f3" translate="yes" xml:space="preserve">
          <source>The problem with null values is that if you try to use a null value as a not-null value, you&amp;rsquo;ll get an error of some kind. Because this null or not-null property is pervasive, it&amp;rsquo;s extremely easy to make this kind of error.</source>
          <target state="translated">El problema con los valores nulos es que si intenta utilizar un valor nulo como valor no nulo, obtendr&amp;aacute; un error de alg&amp;uacute;n tipo. Debido a que esta propiedad nula o no nula es omnipresente, es extremadamente f&amp;aacute;cil cometer este tipo de error.</target>
        </trans-unit>
        <trans-unit id="c7ffb82b1f0d51caf9c86374d324e2fb9ccac1dd" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the contents.</source>
          <target state="translated">El proceso carece de permisos para ver el contenido.</target>
        </trans-unit>
        <trans-unit id="475777e2dbe3eb987a1fdf9f7258e8744d697a33" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the number of hardware threads available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a1f341aa82ec15ad62b2ae6744edcef123d4a7" translate="yes" xml:space="preserve">
          <source>The process may be in a &quot;broken state&quot; if this function returns in error. For example the working directory, environment variables, signal handling settings, various user/group information, or aspects of stdio file descriptors may have changed. If a &quot;transactional spawn&quot; is required to gracefully handle errors it is recommended to use the cross-platform &lt;code&gt;spawn&lt;/code&gt; instead.</source>
          <target state="translated">El proceso puede estar en un &quot;estado roto&quot; si esta funci&amp;oacute;n regresa por error. Por ejemplo, es posible que hayan cambiado el directorio de trabajo, las variables de entorno, la configuraci&amp;oacute;n de manejo de se&amp;ntilde;ales, informaci&amp;oacute;n de varios usuarios / grupos o aspectos de los descriptores de archivos stdio. Si se requiere un &quot;spawn transaccional&quot; para manejar correctamente los errores, se recomienda utilizar el &lt;code&gt;spawn&lt;/code&gt; multiplataforma .</target>
        </trans-unit>
        <trans-unit id="68c2b04d8256c338d13f147c4eb19b87b45d4040" translate="yes" xml:space="preserve">
          <source>The programs we&amp;rsquo;ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we&amp;rsquo;ll cover in the &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Cargo Workspaces&amp;rdquo;&lt;/a&gt; section in Chapter 14.</source>
          <target state="translated">Los programas que hemos escrito hasta ahora han estado en un m&amp;oacute;dulo en un archivo. A medida que un proyecto crece, puede organizar el c&amp;oacute;digo dividi&amp;eacute;ndolo en varios m&amp;oacute;dulos y luego en varios archivos. Un paquete puede contener varias cajas binarias y, opcionalmente, una caja de biblioteca. A medida que un paquete crece, puede extraer piezas en cajas separadas que se convierten en dependencias externas. Este cap&amp;iacute;tulo cubre todas estas t&amp;eacute;cnicas. Para proyectos muy grandes de un conjunto de paquetes interrelacionados que evolucionan juntos, Cargo proporciona espacios de trabajo, que cubriremos en la secci&amp;oacute;n &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Espacios de trabajo de carga&amp;rdquo;&lt;/a&gt; en el Cap&amp;iacute;tulo 14.</target>
        </trans-unit>
        <trans-unit id="5cc2497d5ed1d06060f022ff65bd8b3ff66c60a9" translate="yes" xml:space="preserve">
          <source>The provided &lt;a href=&quot;struct.layout#method.size&quot;&gt;&lt;code&gt;layout.size()&lt;/code&gt;&lt;/a&gt; must fall in the range &lt;code&gt;min ..= max&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1cd28ce339784f890d38adb07a623811959d09" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;path&lt;/code&gt; doesn't exist.</source>
          <target state="translated">La &lt;code&gt;path&lt;/code&gt; proporcionada no existe.</target>
        </trans-unit>
        <trans-unit id="a99e10f876c8ad74bd47e22ac1f9e01fe1760d28" translate="yes" xml:space="preserve">
          <source>The public methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are the only ways to access or modify data in an instance of &lt;code&gt;AveragedCollection&lt;/code&gt;. When an item is added to &lt;code&gt;list&lt;/code&gt; using the &lt;code&gt;add&lt;/code&gt; method or removed using the &lt;code&gt;remove&lt;/code&gt; method, the implementations of each call the private &lt;code&gt;update_average&lt;/code&gt; method that handles updating the &lt;code&gt;average&lt;/code&gt; field as well.</source>
          <target state="translated">Los m&amp;eacute;todos p&amp;uacute;blicos &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; y &lt;code&gt;average&lt;/code&gt; son las &amp;uacute;nicas formas de acceder o modificar datos en una instancia de &lt;code&gt;AveragedCollection&lt;/code&gt; . Cuando un elemento se agrega a la &lt;code&gt;list&lt;/code&gt; a usando el m&amp;eacute;todo &lt;code&gt;add&lt;/code&gt; o se quita usando el m&amp;eacute;todo &lt;code&gt;remove&lt;/code&gt; , las implementaciones de cada uno llaman al m&amp;eacute;todo privado &lt;code&gt;update_average&lt;/code&gt; que tambi&amp;eacute;n maneja la actualizaci&amp;oacute;n del campo &lt;code&gt;average&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c64a2ba34c09d4f2e756bf0b0db2bf928ce82f04" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is called&lt;/em&gt;. Only once &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; returns or panics, the memory may be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a93f31254516d6844f82cc6e94b5893fc7d6231" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;code&gt;drop&lt;/code&gt; is called&lt;/em&gt;. Memory can be invalidated by deallocation, but also by replacing a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, or calling &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt; to &quot;kill&quot; some elements off of a vector. It can be repurposed by using &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;ptr::write&lt;/code&gt;&lt;/a&gt; to overwrite it without calling the destructor first.</source>
          <target state="translated">El prop&amp;oacute;sito de la fijaci&amp;oacute;n es poder confiar en la ubicaci&amp;oacute;n de algunos datos en la memoria. Para que esto funcione, no solo se restringe el movimiento de los datos; La desasignaci&amp;oacute;n, reutilizaci&amp;oacute;n o invalidaci&amp;oacute;n de la memoria utilizada para almacenar los datos tambi&amp;eacute;n est&amp;aacute; restringida. Concretamente, para los datos anclados, debe mantener el invariante de que &lt;em&gt;su memoria no se invalidar&amp;aacute; ni se reutilizar&amp;aacute; desde el momento en que se fija hasta que se llama a &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt; . La memoria se puede invalidar mediante la desasignaci&amp;oacute;n, pero tambi&amp;eacute;n reemplazando &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt; por &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , o llamando a &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt; &lt;code&gt;Vec::set_len&lt;/code&gt; &lt;/a&gt; para &quot;matar&quot; algunos elementos de un vector. Se puede reutilizar usando &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;ptr::write&lt;/code&gt; &lt;/a&gt; para sobrescribirlo sin llamar primero al destructor.</target>
        </trans-unit>
        <trans-unit id="dadde1acddaa4f2663e0f0f8fe2f53b8bd256d16" translate="yes" xml:space="preserve">
          <source>The purpose of these &lt;code&gt;Result&lt;/code&gt; types is to encode error-handling information. Values of the &lt;code&gt;Result&lt;/code&gt; type, like values of any type, have methods defined on them. An instance of &lt;code&gt;io::Result&lt;/code&gt; has an &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; method&lt;/a&gt; that you can call. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Err&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will cause the program to crash and display the message that you passed as an argument to &lt;code&gt;expect&lt;/code&gt;. If the &lt;code&gt;read_line&lt;/code&gt; method returns an &lt;code&gt;Err&lt;/code&gt;, it would likely be the result of an error coming from the underlying operating system. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will take the return value that &lt;code&gt;Ok&lt;/code&gt; is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in what the user entered into standard input.</source>
          <target state="translated">El prop&amp;oacute;sito de estos tipos de &lt;code&gt;Result&lt;/code&gt; es codificar la informaci&amp;oacute;n de manejo de errores. Los valores del tipo de &lt;code&gt;Result&lt;/code&gt; , como los valores de cualquier tipo, tienen m&amp;eacute;todos definidos. Una instancia de &lt;code&gt;io::Result&lt;/code&gt; tiene un &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;m&amp;eacute;todo de &lt;/a&gt; &lt;code&gt;expect&lt;/code&gt; que puede llamar. Si esta instancia de &lt;code&gt;io::Result&lt;/code&gt; es un valor &lt;code&gt;Err&lt;/code&gt; , &lt;code&gt;expect&lt;/code&gt; har&amp;aacute; que el programa se bloquee y muestre el mensaje que pas&amp;oacute; como argumento &lt;code&gt;expect&lt;/code&gt; . Si el m&amp;eacute;todo &lt;code&gt;read_line&lt;/code&gt; devuelve &lt;code&gt;Err&lt;/code&gt; , probablemente sea el resultado de un error proveniente del sistema operativo subyacente. Si esta instancia de &lt;code&gt;io::Result&lt;/code&gt; es una &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; tomar&amp;aacute; el valor de retorno que &lt;code&gt;Ok&lt;/code&gt; tiene y le devolver&amp;aacute; solo ese valor para que pueda usarlo. En este caso, ese valor es el n&amp;uacute;mero de bytes que el usuario ingres&amp;oacute; en la entrada est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="17a957e4dd15537d9df26e9cd567ee8ac4ab9c24" translate="yes" xml:space="preserve">
          <source>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with &lt;code&gt;impl&lt;/code&gt; and some are declared with the method definition. Here, the generic parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are declared after &lt;code&gt;impl&lt;/code&gt;, because they go with the struct definition. The generic parameters &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; are declared after &lt;code&gt;fn mixup&lt;/code&gt;, because they&amp;rsquo;re only relevant to the method.</source>
          <target state="translated">El prop&amp;oacute;sito de este ejemplo es demostrar una situaci&amp;oacute;n en la que algunos par&amp;aacute;metros gen&amp;eacute;ricos se declaran con &lt;code&gt;impl&lt;/code&gt; y otros con la definici&amp;oacute;n del m&amp;eacute;todo. Aqu&amp;iacute;, los par&amp;aacute;metros gen&amp;eacute;ricos &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; se declaran despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; , porque van con la definici&amp;oacute;n de la estructura. Los par&amp;aacute;metros gen&amp;eacute;ricos &lt;code&gt;V&lt;/code&gt; y &lt;code&gt;W&lt;/code&gt; se declaran despu&amp;eacute;s de la &lt;code&gt;fn mixup&lt;/code&gt; , porque solo son relevantes para el m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="83464f6d897f3cf3890af3a243744932372ed118" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:</source>
          <target state="translated">El propósito de este módulo es aliviar las importaciones de muchos rasgos comunes de E/S añadiendo una importación global a la parte superior de los módulos pesados de E/S:</target>
        </trans-unit>
        <trans-unit id="c5176304cb4e1480563977bff5f9fc8f29f52bf7" translate="yes" xml:space="preserve">
          <source>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</source>
          <target state="translated">El propósito de los objetos de rasgo es permitir la &quot;encuadernación tardía&quot; de los métodos.Llamar a un método en un objeto de rasgo da como resultado un envío virtual en tiempo de ejecución:es decir,un puntero de función se carga desde el objeto de rasgo vtable y se invoca indirectamente.La aplicación real de cada entrada del vtable puede variar en función de cada objeto.</target>
        </trans-unit>
        <trans-unit id="f15fea39e76fdfafefd43bfce074d20361154e36" translate="yes" xml:space="preserve">
          <source>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&amp;rsquo;t working as expected. You&amp;rsquo;ll put unit tests in the &lt;em&gt;src&lt;/em&gt; directory in each file with the code that they&amp;rsquo;re testing. The convention is to create a module named &lt;code&gt;tests&lt;/code&gt; in each file to contain the test functions and to annotate the module with &lt;code&gt;cfg(test)&lt;/code&gt;.</source>
          <target state="translated">El prop&amp;oacute;sito de las pruebas unitarias es probar cada unidad de c&amp;oacute;digo de forma aislada del resto del c&amp;oacute;digo para identificar r&amp;aacute;pidamente d&amp;oacute;nde est&amp;aacute; y d&amp;oacute;nde no funciona el c&amp;oacute;digo como se esperaba. Colocar&amp;aacute; pruebas unitarias en el directorio &lt;em&gt;src&lt;/em&gt; en cada archivo con el c&amp;oacute;digo que est&amp;aacute;n probando. La convenci&amp;oacute;n es crear un m&amp;oacute;dulo llamado &lt;code&gt;tests&lt;/code&gt; en cada archivo para contener las funciones de prueba y anotar el m&amp;oacute;dulo con &lt;code&gt;cfg(test)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60cba1f37e61726b832a14d7f1500e4426e9a5cc" translate="yes" xml:space="preserve">
          <source>The question mark operator</source>
          <target state="translated">El operador del signo de interrogación</target>
        </trans-unit>
        <trans-unit id="018537889ded2ab112f094946b8612c9a86b99ba" translate="yes" xml:space="preserve">
          <source>The question mark operator (&lt;code&gt;?&lt;/code&gt;) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El operador de signo de interrogaci&amp;oacute;n ( &lt;code&gt;?&lt;/code&gt; ) Desenvuelve valores v&amp;aacute;lidos o devuelve valores err&amp;oacute;neos, propag&amp;aacute;ndolos a la funci&amp;oacute;n de llamada. Es un operador de sufijo unario que solo se puede aplicar a los tipos &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; y &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea5d63d0d5a319dd6d9072a4460aea03a494584" translate="yes" xml:space="preserve">
          <source>The question mark operator, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">El operador de signo de interrogaci&amp;oacute;n, &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61208bdae8b221a09aba4f839d74c11c2925c51c" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;.</source>
          <target state="translated">La ra&amp;iacute;z o base de la representaci&amp;oacute;n interna de &lt;code&gt;f32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea313a35fa236b37b46428fb2657491b2e33dea3" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f32::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc170d8fddda3392ca3bbfeb02d09cfb7f6a80ce" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">La ra&amp;iacute;z o base de la representaci&amp;oacute;n interna de &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb77af93de4b13de0ebcbd9266a033e54a3960fe" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f64::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9457bd197a286afc52dbcebb942e61605b222d" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt;. It is empty if &lt;code&gt;start &amp;gt;= end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510a943d569cb4f1080072d01ababcb91699bcc6" translate="yes" xml:space="preserve">
          <source>The range is empty if either side is incomparable:</source>
          <target state="translated">El rango está vacío si cualquiera de los dos lados es incomparable:</target>
        </trans-unit>
        <trans-unit id="a7d43b8cf204eefd21645fceff96d69cfb297982" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2067413bc1879d44bf7542436c24e1555ca1bc" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc134868dea70688318900dea4fb56c096c2fce" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El puntero sin formato debe haber sido devuelto previamente por una llamada a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc::into_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb442a6e9f4c3ea3ad88f7d20cbb90e50f086583" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El puntero sin formato debe haber sido devuelto previamente por una llamada a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc::into_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61edb86c6e775bcbcc090bf0b2354d8086752aee" translate="yes" xml:space="preserve">
          <source>The re-ordering prevented by the different ordering semantics are:</source>
          <target state="translated">El reordenamiento impedido por la diferente semántica de ordenamiento es:</target>
        </trans-unit>
        <trans-unit id="db75fd7d163698847a2930407a821664ef9dc7a1" translate="yes" xml:space="preserve">
          <source>The reading portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">La parte de lectura de &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; debe apagarse.</target>
        </trans-unit>
        <trans-unit id="bb2e18a8faa1f91810d19956a7143af41d8b7e9f" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">El motivo de la desaprobaci&amp;oacute;n es que la funci&amp;oacute;n b&amp;aacute;sicamente no se puede utilizar correctamente: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;el compilador de Rust asume&lt;/a&gt; que los valores se inicializan correctamente. Como consecuencia, llamar, por ejemplo, &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; provoca un comportamiento indefinido inmediato para devolver un &lt;code&gt;bool&lt;/code&gt; que no es definitivamente ni &lt;code&gt;true&lt;/code&gt; ni &lt;code&gt;false&lt;/code&gt; . Peor a&amp;uacute;n, la memoria verdaderamente no inicializada como la que se devuelve aqu&amp;iacute; es especial porque el compilador sabe que no tiene un valor fijo. Esto hace que sea un comportamiento indefinido tener datos sin inicializar en una variable incluso si esa variable tiene un tipo entero. (Tenga en cuenta que las reglas sobre los enteros no inicializados a&amp;uacute;n no est&amp;aacute;n finalizadas, pero hasta que lo est&amp;eacute;n, es aconsejable evitarlas).</target>
        </trans-unit>
        <trans-unit id="0a840dd2de2cd2ee34a26f979453151250b4e843" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as &lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt;&lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt;&lt;/a&gt;. As the &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt; documentation&lt;/a&gt; explains, &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d0c9e3177e947296d0e4cad464419f6391db88" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;rlib&lt;/code&gt; files do not contain any of their upstream dependencies. It wouldn't be very efficient for all &lt;code&gt;rlib&lt;/code&gt; files to contain a copy of &lt;code&gt;libstd.rlib&lt;/code&gt;!</source>
          <target state="translated">La raz&amp;oacute;n de esto es que los archivos &lt;code&gt;rlib&lt;/code&gt; no contienen ninguna de sus dependencias ascendentes. &amp;iexcl;No ser&amp;iacute;a muy eficiente que todos los archivos &lt;code&gt;rlib&lt;/code&gt; contuvieran una copia de &lt;code&gt;libstd.rlib&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="f95aa7105ee4000143fc92462b837053383a52a0" translate="yes" xml:space="preserve">
          <source>The reason for this is that there are two appearances of type parameter &lt;code&gt;T&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; header, both as parameters for &lt;code&gt;ForeignTrait2&lt;/code&gt;. The first appearance is uncovered, and so runs afoul of the orphan rule.</source>
          <target state="translated">La raz&amp;oacute;n de esto es que hay dos aspectos del par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; en el encabezado &lt;code&gt;impl&lt;/code&gt; , ambos como par&amp;aacute;metros para &lt;code&gt;ForeignTrait2&lt;/code&gt; . La primera aparici&amp;oacute;n queda al descubierto, por lo que entra en conflicto con la regla de los hu&amp;eacute;rfanos.</target>
        </trans-unit>
        <trans-unit id="ef37c27a4f0dd2645ce86c85a75eac6a77fa29d9" translate="yes" xml:space="preserve">
          <source>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there&amp;rsquo;s no reason we would want to prevent &lt;code&gt;x&lt;/code&gt; from being valid after we create the variable &lt;code&gt;y&lt;/code&gt;. In other words, there&amp;rsquo;s no difference between deep and shallow copying here, so calling &lt;code&gt;clone&lt;/code&gt; wouldn&amp;rsquo;t do anything different from the usual shallow copying and we can leave it out.</source>
          <target state="translated">La raz&amp;oacute;n es que los tipos como los enteros que tienen un tama&amp;ntilde;o conocido en el momento de la compilaci&amp;oacute;n se almacenan completamente en la pila, por lo que las copias de los valores reales son r&amp;aacute;pidas de hacer. Eso significa que no hay ninguna raz&amp;oacute;n por la que queramos evitar que &lt;code&gt;x&lt;/code&gt; sea ​​v&amp;aacute;lido despu&amp;eacute;s de crear la variable &lt;code&gt;y&lt;/code&gt; . En otras palabras, no hay diferencia entre la copia superficial y profunda aqu&amp;iacute;, por lo que llamar a &lt;code&gt;clone&lt;/code&gt; no har&amp;iacute;a nada diferente de la copia superficial habitual y podemos omitirlo.</target>
        </trans-unit>
        <trans-unit id="5c1ca57165d895e7b5a9a07fb8f81dd8e653560f" translate="yes" xml:space="preserve">
          <source>The reason is that you&amp;rsquo;re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. To rectify this error, you need to include this information in the &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">La raz&amp;oacute;n es que le falta informaci&amp;oacute;n crucial: se requiere una descripci&amp;oacute;n y una licencia para que la gente sepa qu&amp;eacute; hace su caja y bajo qu&amp;eacute; t&amp;eacute;rminos pueden usarla. Para rectificar este error, debe incluir esta informaci&amp;oacute;n en el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="87dec969a1d8a7fd52229930c681793b58499b7c" translate="yes" xml:space="preserve">
          <source>The reason is that, in the first example, there are many possible types that &lt;code&gt;!&lt;/code&gt; could coerce to, because many types implement &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt;. However, in the second example, the &lt;code&gt;else&lt;/code&gt; branch returns a &lt;code&gt;0&lt;/code&gt;, which the compiler infers from the return type to be of type &lt;code&gt;u32&lt;/code&gt;. Since &lt;code&gt;u32&lt;/code&gt; is a concrete type, &lt;code&gt;!&lt;/code&gt; can and will be coerced to it. See issue &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;#36375&lt;/a&gt; for more information on this quirk of &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725753993f38910ecfb713203cf3afe96ff590f2" translate="yes" xml:space="preserve">
          <source>The reason that this matter is that the type &lt;code&gt;fn(S)&lt;/code&gt; is not specific to any particular function: it's a function &lt;em&gt;pointer&lt;/em&gt;. So calling &lt;code&gt;x()&lt;/code&gt; results in a virtual call, whereas &lt;code&gt;foo()&lt;/code&gt; is statically dispatched, because the type of &lt;code&gt;foo&lt;/code&gt; tells us precisely what function is being called.</source>
          <target state="translated">La raz&amp;oacute;n por la que esto importa es que el tipo &lt;code&gt;fn(S)&lt;/code&gt; no es espec&amp;iacute;fico de ninguna funci&amp;oacute;n en particular: es un &lt;em&gt;puntero de&lt;/em&gt; funci&amp;oacute;n . Entonces, llamar a &lt;code&gt;x()&lt;/code&gt; da como resultado una llamada virtual, mientras que &lt;code&gt;foo()&lt;/code&gt; se env&amp;iacute;a est&amp;aacute;ticamente, porque el tipo de &lt;code&gt;foo&lt;/code&gt; nos dice con precisi&amp;oacute;n qu&amp;eacute; funci&amp;oacute;n se est&amp;aacute; llamando.</target>
        </trans-unit>
        <trans-unit id="2f71ddaa6e32a7d6efaff9da8a4ddd4766615cbe" translate="yes" xml:space="preserve">
          <source>The reason the &lt;code&gt;deref&lt;/code&gt; method returns a reference to a value, and that the plain dereference outside the parentheses in &lt;code&gt;*(y.deref())&lt;/code&gt; is still necessary, is the ownership system. If the &lt;code&gt;deref&lt;/code&gt; method returned the value directly instead of a reference to the value, the value would be moved out of &lt;code&gt;self&lt;/code&gt;. We don&amp;rsquo;t want to take ownership of the inner value inside &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in this case or in most cases where we use the dereference operator.</source>
          <target state="translated">La raz&amp;oacute;n por la que el m&amp;eacute;todo &lt;code&gt;deref&lt;/code&gt; devuelve una referencia a un valor, y que la desreferencia simple fuera del par&amp;eacute;ntesis en &lt;code&gt;*(y.deref())&lt;/code&gt; sigue siendo necesaria, es el sistema de propiedad. Si el m&amp;eacute;todo &lt;code&gt;deref&lt;/code&gt; devolvi&amp;oacute; el valor directamente en lugar de una referencia al valor, el valor se mover&amp;iacute;a fuera de &lt;code&gt;self&lt;/code&gt; . No queremos tomar posesi&amp;oacute;n del valor interno dentro de &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; en este caso o en la mayor&amp;iacute;a de los casos en los que usamos el operador de desreferencia.</target>
        </trans-unit>
        <trans-unit id="1d62bb1a32655921533dae07c7931836afe25a19" translate="yes" xml:space="preserve">
          <source>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&amp;rsquo;t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</source>
          <target state="translated">La raz&amp;oacute;n por la que esta funci&amp;oacute;n se compila sin anotaciones de por vida es hist&amp;oacute;rica: en las primeras versiones (pre-1.0) de Rust, este c&amp;oacute;digo no se habr&amp;iacute;a compilado porque cada referencia necesitaba una vida expl&amp;iacute;cita. En ese momento, la firma de la funci&amp;oacute;n se habr&amp;iacute;a escrito as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="bedb5e3116e5d92919b43a452878e5db1b96099b" translate="yes" xml:space="preserve">
          <source>The reason we&amp;rsquo;re able to use &lt;code&gt;&amp;amp;s2&lt;/code&gt; in the call to &lt;code&gt;add&lt;/code&gt; is that the compiler can &lt;em&gt;coerce&lt;/em&gt; the &lt;code&gt;&amp;amp;String&lt;/code&gt; argument into a &lt;code&gt;&amp;amp;str&lt;/code&gt;. When we call the &lt;code&gt;add&lt;/code&gt; method, Rust uses a &lt;em&gt;deref coercion&lt;/em&gt;, which here turns &lt;code&gt;&amp;amp;s2&lt;/code&gt; into &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt;. We&amp;rsquo;ll discuss deref coercion in more depth in Chapter 15. Because &lt;code&gt;add&lt;/code&gt; does not take ownership of the &lt;code&gt;s&lt;/code&gt; parameter, &lt;code&gt;s2&lt;/code&gt; will still be a valid &lt;code&gt;String&lt;/code&gt; after this operation.</source>
          <target state="translated">La raz&amp;oacute;n por la que somos capaces de utilizar &lt;code&gt;&amp;amp;s2&lt;/code&gt; en la llamada a &lt;code&gt;add&lt;/code&gt; es que el compilador puede &lt;em&gt;coaccionar&lt;/em&gt; el &lt;code&gt;&amp;amp;String&lt;/code&gt; argumento en una &lt;code&gt;&amp;amp;str&lt;/code&gt; . Cuando llamamos al m&amp;eacute;todo &lt;code&gt;add&lt;/code&gt; , Rust usa una &lt;em&gt;coerci&amp;oacute;n deref&lt;/em&gt; , que aqu&amp;iacute; convierte &lt;code&gt;&amp;amp;s2&lt;/code&gt; en &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt; . Discutiremos la coerci&amp;oacute;n deref con m&amp;aacute;s profundidad en el Cap&amp;iacute;tulo 15. Debido a que &lt;code&gt;add&lt;/code&gt; no se apropia del par&amp;aacute;metro &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; seguir&amp;aacute; siendo un &lt;code&gt;String&lt;/code&gt; v&amp;aacute;lido despu&amp;eacute;s de esta operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f3cfdfa90a10325648e4c2eb952b413419929140" translate="yes" xml:space="preserve">
          <source>The receiver of a method, or the current module.</source>
          <target state="translated">El receptor de un método,o el módulo actual.</target>
        </trans-unit>
        <trans-unit id="d73164a885c270ed79f7ee9c783984160bde564d" translate="yes" xml:space="preserve">
          <source>The receiving end of a channel has two useful methods: &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;try_recv&lt;/code&gt;. We&amp;rsquo;re using &lt;code&gt;recv&lt;/code&gt;, short for &lt;em&gt;receive&lt;/em&gt;, which will block the main thread&amp;rsquo;s execution and wait until a value is sent down the channel. Once a value is sent, &lt;code&gt;recv&lt;/code&gt; will return it in a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When the sending end of the channel closes, &lt;code&gt;recv&lt;/code&gt; will return an error to signal that no more values will be coming.</source>
          <target state="translated">El extremo receptor de un canal tiene dos m&amp;eacute;todos &amp;uacute;tiles: &lt;code&gt;recv&lt;/code&gt; y &lt;code&gt;try_recv&lt;/code&gt; . Estamos usando &lt;code&gt;recv&lt;/code&gt; , abreviatura de &lt;em&gt;recibir&lt;/em&gt; , que bloquear&amp;aacute; la ejecuci&amp;oacute;n del hilo principal y esperar&amp;aacute; hasta que se env&amp;iacute;e un valor por el canal. Una vez que se env&amp;iacute;a un valor, &lt;code&gt;recv&lt;/code&gt; lo devolver&amp;aacute; en un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . Cuando se cierra el extremo de env&amp;iacute;o del canal, &lt;code&gt;recv&lt;/code&gt; devolver&amp;aacute; un error para indicar que no habr&amp;aacute; m&amp;aacute;s valores.</target>
        </trans-unit>
        <trans-unit id="bb4caae3b66529c5330d18c3a08329f2bc2f3deb" translate="yes" xml:space="preserve">
          <source>The receiving half of Rust's &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) type. This half can only be owned by one thread.</source>
          <target state="translated">La mitad receptora del tipo de &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; (o &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; ) de Rust . Esta mitad solo puede ser propiedad de un hilo.</target>
        </trans-unit>
        <trans-unit id="6ebe525b659c768099f112d22bb95117877daf2e" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust drops the variable &lt;code&gt;b&lt;/code&gt;, which decreases the reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance from 2 to 1. The memory that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped at this point, because its reference count is 1, not 0. Then Rust drops &lt;code&gt;a&lt;/code&gt;, which decreases the reference count of the &lt;code&gt;a&lt;/code&gt;&lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance from 2 to 1 as well. This instance's memory can&amp;rsquo;t be dropped either, because the other &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance still refers to it. The memory allocated to the list will remain uncollected forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2bfb185407e4c60c25d227a4ff77b2cda29f86" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust will try to drop &lt;code&gt;b&lt;/code&gt; first, which will decrease the count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance in &lt;code&gt;b&lt;/code&gt; by 1.</source>
          <target state="translated">El c&amp;oacute;mputo de referencia de la &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; casos, tanto en &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son 2 despu&amp;eacute;s cambiamos la lista en &lt;code&gt;a&lt;/code&gt; a punto de &lt;code&gt;b&lt;/code&gt; . Al final de &lt;code&gt;main&lt;/code&gt; , Rust intentar&amp;aacute; eliminar &lt;code&gt;b&lt;/code&gt; primero, lo que reducir&amp;aacute; el recuento de la instancia &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; en &lt;code&gt;b&lt;/code&gt; en 1.</target>
        </trans-unit>
        <trans-unit id="ae6db410fc6a6a00a988df7e277d31526670b6dd" translate="yes" xml:space="preserve">
          <source>The reference to the moved key is provided so that cloning or copying the key is unnecessary, unlike with &lt;code&gt;.or_insert_with(|| ... )&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0309be91bd54044d4044342a0389163de0a934e4" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;src&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;dst&lt;/code&gt; with the same size.</source>
          <target state="translated">La regi&amp;oacute;n de memoria que comienza en &lt;code&gt;src&lt;/code&gt; con un tama&amp;ntilde;o de &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes &lt;em&gt;no&lt;/em&gt; debe superponerse con la regi&amp;oacute;n de memoria que comienza en &lt;code&gt;dst&lt;/code&gt; con el mismo tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="5dcc17f2dc1b8084d38071ff6ddcb2865d4ada36" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;x&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;y&lt;/code&gt; with the same size.</source>
          <target state="translated">La regi&amp;oacute;n de memoria que comienza en &lt;code&gt;x&lt;/code&gt; con un tama&amp;ntilde;o de &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes &lt;em&gt;no&lt;/em&gt; debe superponerse con la regi&amp;oacute;n de memoria que comienza en &lt;code&gt;y&lt;/code&gt; con el mismo tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="6e24cbd3ed4b7a19863f8c010bc7cecf513544b8" translate="yes" xml:space="preserve">
          <source>The relative order of partitioned items is not maintained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d262cc92a6d55445ae1cc06ba8d24d6a4bfc8a" translate="yes" xml:space="preserve">
          <source>The relevant &lt;code&gt;use&lt;/code&gt; statements</source>
          <target state="translated">Las declaraciones de &lt;code&gt;use&lt;/code&gt; relevantes</target>
        </trans-unit>
        <trans-unit id="92055677c3977ae45c2e91b99d3cb2b7bc2e7a00" translate="yes" xml:space="preserve">
          <source>The remainder assignment operator &lt;code&gt;%=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de resto &lt;code&gt;%=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1e6181542061352f1920b8d99d81207a670f7f" translate="yes" xml:space="preserve">
          <source>The remainder from the division of two floats.</source>
          <target state="translated">El resto de la división de dos flotadores.</target>
        </trans-unit>
        <trans-unit id="054039eee5819e5face98778f38bf1e0291c343e" translate="yes" xml:space="preserve">
          <source>The remainder has the same sign as the dividend and is computed as: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt;.</source>
          <target state="translated">El resto tiene el mismo signo que el dividendo y se calcula como: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5654d619adf6380504b572e1ea12d7691a4525f9" translate="yes" xml:space="preserve">
          <source>The remainder operator &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">El resto del operador &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b313ceee14929f12b1b754da920f2c480594a9a" translate="yes" xml:space="preserve">
          <source>The remaining characters are alphanumeric or &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Los caracteres restantes son alfanum&amp;eacute;ricos o &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db31fc17b3b16891bdde4b2e11c17a8b55001a20" translate="yes" xml:space="preserve">
          <source>The removed element is replaced by the last element of the vector.</source>
          <target state="translated">El elemento eliminado es reemplazado por el último elemento del vector.</target>
        </trans-unit>
        <trans-unit id="bdcb1bbcfc5506185f4dcdac6bb92b93d0ea27b3" translate="yes" xml:space="preserve">
          <source>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the &lt;code&gt;$( $i:ident ),*&lt;/code&gt; example above matches &lt;code&gt;$i&lt;/code&gt; to all of the identifiers in the list.</source>
          <target state="translated">El fragmento repetido coincide y se transcribe al n&amp;uacute;mero especificado del fragmento, separado por el token de separaci&amp;oacute;n. Las metavariables se corresponden con cada repetici&amp;oacute;n de su fragmento correspondiente. Por ejemplo, el ejemplo anterior de &lt;code&gt;$( $i:ident ),*&lt;/code&gt; coincidir &lt;code&gt;$i&lt;/code&gt; con todos los identificadores de la lista.</target>
        </trans-unit>
        <trans-unit id="12103d0e7fb92d8d3b9ddae239cdf39dea7eeb65" translate="yes" xml:space="preserve">
          <source>The repetition operators are:</source>
          <target state="translated">Los operadores de repetición son:</target>
        </trans-unit>
        <trans-unit id="bfcbf2851f89edd4f300f9b36ba95aadb203f98e" translate="yes" xml:space="preserve">
          <source>The representation does &lt;em&gt;not&lt;/em&gt; look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation &lt;code&gt;s2 = s1&lt;/code&gt; could be very expensive in terms of runtime performance if the data on the heap were large.</source>
          <target state="translated">La representaci&amp;oacute;n no &lt;em&gt;se&lt;/em&gt; parece a la de la Figura 4-3, que es como se ver&amp;iacute;a la memoria si Rust copiara tambi&amp;eacute;n los datos del mont&amp;oacute;n. Si Rust hiciera esto, la operaci&amp;oacute;n &lt;code&gt;s2 = s1&lt;/code&gt; podr&amp;iacute;a ser muy costosa en t&amp;eacute;rminos de rendimiento en tiempo de ejecuci&amp;oacute;n si los datos en el mont&amp;oacute;n fueran grandes.</target>
        </trans-unit>
        <trans-unit id="0b1df299f3611946c8ad866e3a9d4772fabb543c" translate="yes" xml:space="preserve">
          <source>The representation of a &lt;code&gt;repr(C)&lt;/code&gt; enum with fields is a &lt;code&gt;repr(C)&lt;/code&gt; struct with two fields, also called a &quot;tagged union&quot; in C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3948c1d71b2273d20d352ff100e99a529e9f18b" translate="yes" xml:space="preserve">
          <source>The representation of a primitive representation enum is a &lt;code&gt;repr(C)&lt;/code&gt; union of &lt;code&gt;repr(C)&lt;/code&gt; structs for each variant with a field. The first field of each struct in the union is the primitive representation version of the enum with all fields removed (&quot;the tag&quot;) and the remaining fields are the fields of that variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3b4092c2efea2b55e7548a736c3333a566aec1" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt;.</source>
          <target state="translated">La representaci&amp;oacute;n de un objeto de rasgo como &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4110c125de481ad527206c93b01dbedc11c02bc7" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84fd9c512efc7dcedf9b018795fbba5c08fc5ad5" translate="yes" xml:space="preserve">
          <source>The representation of a type can be changed by applying the &lt;code&gt;repr&lt;/code&gt; attribute to it. The following example shows a struct with a &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">La representaci&amp;oacute;n de un tipo se puede cambiar aplic&amp;aacute;ndole el atributo &lt;code&gt;repr&lt;/code&gt; . El siguiente ejemplo muestra una estructura con una representaci&amp;oacute;n en &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a8aa6aa295a219e257360fdb9ca2113bb7bc323" translate="yes" xml:space="preserve">
          <source>The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a &lt;code&gt;C&lt;/code&gt; representation that contains a struct &lt;code&gt;Inner&lt;/code&gt; with the default representation will not change the layout of &lt;code&gt;Inner&lt;/code&gt;.</source>
          <target state="translated">La representaci&amp;oacute;n de un tipo puede cambiar el relleno entre campos, pero no cambia el dise&amp;ntilde;o de los campos en s&amp;iacute;. Por ejemplo, una estructura con una representaci&amp;oacute;n en &lt;code&gt;C&lt;/code&gt; que contiene una estructura &lt;code&gt;Inner&lt;/code&gt; con la representaci&amp;oacute;n predeterminada no cambiar&amp;aacute; el dise&amp;ntilde;o de &lt;code&gt;Inner&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8de668564b1808c69c7a252869635782239a849b" translate="yes" xml:space="preserve">
          <source>The representation semantics of floating-point numbers are described in &lt;a href=&quot;types/numeric&quot;&gt;&quot;Machine Types&quot;&lt;/a&gt;.</source>
          <target state="translated">La sem&amp;aacute;ntica de representaci&amp;oacute;n de n&amp;uacute;meros de coma flotante se describe en &lt;a href=&quot;types/numeric&quot;&gt;&quot;Tipos de m&amp;aacute;quina&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="568b4d39b3d684710e1069cdb58107435b4ee105" translate="yes" xml:space="preserve">
          <source>The requested ABI is unsupported by the current target.</source>
          <target state="translated">El ABI solicitado no está respaldado por el objetivo actual.</target>
        </trans-unit>
        <trans-unit id="6079a0a7d416189b9655a6ad531ff1787c361185" translate="yes" xml:space="preserve">
          <source>The required alignment of the referenced value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f41ba31da382f1ab342b312f6ebecf708e0a4f" translate="yes" xml:space="preserve">
          <source>The required inputs are these:</source>
          <target state="translated">Los insumos requeridos son estos:</target>
        </trans-unit>
        <trans-unit id="f6ffffcc1dc56ad2b07c96ba04b8dfcf628fd050" translate="yes" xml:space="preserve">
          <source>The requirements for this program haven&amp;rsquo;t been agreed upon yet, and we&amp;rsquo;re pretty sure the &lt;code&gt;Hello&lt;/code&gt; text at the beginning of the greeting will change. We decided we don&amp;rsquo;t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the &lt;code&gt;greeting&lt;/code&gt; function, we&amp;rsquo;ll just assert that the output contains the text of the input parameter.</source>
          <target state="translated">Los requisitos para este programa no se han acordado todav&amp;iacute;a, y estamos seguros de la &lt;code&gt;Hello&lt;/code&gt; texto al principio del saludo va a cambiar. Decidimos que no queremos tener que actualizar la prueba cuando cambian los requisitos, por lo que en lugar de verificar la igualdad exacta con el valor devuelto por la funci&amp;oacute;n de &lt;code&gt;greeting&lt;/code&gt; , simplemente afirmaremos que la salida contiene el texto del par&amp;aacute;metro de entrada.</target>
        </trans-unit>
        <trans-unit id="0cbf837e1937a12c606036644e82391851dc8756" translate="yes" xml:space="preserve">
          <source>The responsibilities that remain in the &lt;code&gt;main&lt;/code&gt; function after this process should be limited to the following:</source>
          <target state="translated">Las responsabilidades que permanecen en la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; despu&amp;eacute;s de este proceso deben limitarse a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="fb88378aaf4cdd384feeec625a8c476a227f1fe6" translate="yes" xml:space="preserve">
          <source>The rest of the traits defined in the standard library can&amp;rsquo;t be implemented on your types using &lt;code&gt;derive&lt;/code&gt;. These traits don&amp;rsquo;t have sensible default behavior, so it&amp;rsquo;s up to you to implement them in the way that makes sense for what you&amp;rsquo;re trying to accomplish.</source>
          <target state="translated">El resto de los rasgos definidos en la biblioteca est&amp;aacute;ndar no se pueden implementar en sus tipos usando &lt;code&gt;derive&lt;/code&gt; . Estos rasgos no tienen un comportamiento predeterminado sensible, por lo que depende de usted implementarlos de la manera que tenga sentido para lo que est&amp;aacute; tratando de lograr.</target>
        </trans-unit>
        <trans-unit id="3a3c86e891d6ad8a6d17dd1936fd9bfccb1b62f4" translate="yes" xml:space="preserve">
          <source>The rest of this book uses commands that work in both &lt;em&gt;cmd.exe&lt;/em&gt; and PowerShell. If there are specific differences, we&amp;rsquo;ll explain which to use.</source>
          <target state="translated">El resto de este libro utiliza comandos que funcionan tanto en &lt;em&gt;cmd.exe&lt;/em&gt; como en PowerShell. Si hay diferencias espec&amp;iacute;ficas, le explicaremos cu&amp;aacute;l usar.</target>
        </trans-unit>
        <trans-unit id="00dd9e9169ec993decc3de54bbe98c364e0e7806" translate="yes" xml:space="preserve">
          <source>The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.</source>
          <target state="translated">El resto de la documentación de la caja está dedicada a señalar las características notables de la Biblioteca Estándar del Óxido.</target>
        </trans-unit>
        <trans-unit id="ac1c550b13307d7f1181fa4746cc5e5943901d94" translate="yes" xml:space="preserve">
          <source>The rest pattern is always irrefutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cd0ab16fb284f9bcdd09aeae886a98592a2f2d" translate="yes" xml:space="preserve">
          <source>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54e546283bfd6f5bb35e08c8e91500e43fa3efb" translate="yes" xml:space="preserve">
          <source>The result is allocated on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f60835a1f670fd1068b73e7310483f7414303f8" translate="yes" xml:space="preserve">
          <source>The result may not be correctly rounded owing to implementation details; &lt;code&gt;self.log2()&lt;/code&gt; can produce more accurate results for base 2, and &lt;code&gt;self.log10()&lt;/code&gt; can produce more accurate results for base 10.</source>
          <target state="translated">Es posible que el resultado no se redondee correctamente debido a los detalles de implementaci&amp;oacute;n; &lt;code&gt;self.log2()&lt;/code&gt; puede producir resultados m&amp;aacute;s precisos para la base 2, y &lt;code&gt;self.log10()&lt;/code&gt; puede producir resultados m&amp;aacute;s precisos para la base 10.</target>
        </trans-unit>
        <trans-unit id="c4dbebfb961a1bddcfad953b06a027b749fbba28" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; an expression with type &lt;a href=&quot;../std/boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and that can also be moved out of.</source>
          <target state="translated">El resultado de &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;eliminar la referencia a&lt;/a&gt; una expresi&amp;oacute;n con el tipo &lt;a href=&quot;../std/boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y que tambi&amp;eacute;n se puede mover fuera de.</target>
        </trans-unit>
        <trans-unit id="fe2526308745be82b19ed557143eb06c9172e9c2" translate="yes" xml:space="preserve">
          <source>The result of a generator resumption.</source>
          <target state="translated">El resultado de la reanudación del generador.</target>
        </trans-unit>
        <trans-unit id="d471d20c06ef14c004fab8262f7528514deaa1c4" translate="yes" xml:space="preserve">
          <source>The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.</source>
          <target state="translated">El resultado de lanzar una referencia a un puntero es válido mientras el objeto subyacente esté vivo y no se utilice ninguna referencia (sólo punteros en bruto)para acceder a la misma memoria.</target>
        </trans-unit>
        <trans-unit id="ac56fae426229e4d543dba38661557fbee8bb52d" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing with formatting strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cd246d6c4827dc128a4e9ac189ceccd07f4e85" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.</source>
          <target state="translated">&amp;iexcl;El resultado de &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;macro es un valor de tipo&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; . Esta estructura se puede pasar luego a lasfunciones de&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; y&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; o&lt;/a&gt; dentro de este m&amp;oacute;dulo para procesar la cadena de formato. El objetivo de esta macro es prevenir a&amp;uacute;n m&amp;aacute;s las asignaciones intermedias cuando se trata de cadenas de formato.</target>
        </trans-unit>
        <trans-unit id="1c32345d3d6f612f235d03a8cd84044465cbfeea" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt;.</source>
          <target state="translated">El resultado representar&amp;aacute; la direcci&amp;oacute;n IP &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99c7c63b15fc6ea4f165265a5fd114fc5db86d31" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;b&lt;/code&gt;.&lt;code&gt;c&lt;/code&gt;.&lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">El resultado representar&amp;aacute; la direcci&amp;oacute;n IP &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7373e6f7caa0a9dff8d78cf60558cf221157bd80" translate="yes" xml:space="preserve">
          <source>The resulting layout will be the same as that of a C struct containing two fields with the layouts of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in that order.</source>
          <target state="translated">El dise&amp;ntilde;o resultante ser&amp;aacute; el mismo que el de una estructura C que contiene dos campos con los dise&amp;ntilde;os de &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;next&lt;/code&gt; , en ese orden.</target>
        </trans-unit>
        <trans-unit id="99a0997f56bdadd8bd20428a4a2ef3bbae789fac" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">La vida resultante est&amp;aacute; ligada a uno mismo, por lo que se comporta &quot;como si&quot; en realidad fuera una instancia de T que est&amp;aacute; siendo prestada. Si se necesita una vida &amp;uacute;til m&amp;aacute;s larga (sin consolidar), use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f78e2e736259493757a0ced96e6b992b486267c6" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">La vida resultante est&amp;aacute; ligada a uno mismo, por lo que se comporta &quot;como si&quot; en realidad fuera una instancia de T que est&amp;aacute; siendo prestada. Si se necesita una vida &amp;uacute;til m&amp;aacute;s larga (sin consolidar), utilice &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9220ca335fae6d1972b4901944a1126d0f38ae8e" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;).</source>
          <target state="translated">No es necesario que el puntero resultante est&amp;eacute; dentro de los l&amp;iacute;mites, pero es potencialmente peligroso eliminar la referencia (lo que requiere que sea &lt;code&gt;unsafe&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="81b4f59283eb3ce773831a86dd58d26e19da85b4" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;). In particular, the resulting pointer may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object than the one &lt;code&gt;self&lt;/code&gt; points to. In other words, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">No es necesario que el puntero resultante est&amp;eacute; dentro de los l&amp;iacute;mites, pero es potencialmente peligroso eliminar la referencia (lo que requiere que sea &lt;code&gt;unsafe&lt;/code&gt; ). En particular, el puntero resultante &lt;em&gt;no se&lt;/em&gt; puede utilizar para acceder a un objeto asignado diferente al que apunta uno &lt;code&gt;self&lt;/code&gt; . En otras palabras, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; es &lt;em&gt;no&lt;/em&gt; el mismo que &lt;code&gt;y&lt;/code&gt; , y eliminaci&amp;oacute;n de referencias es un comportamiento indefinido a menos que &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; punto en el mismo objeto asignado.</target>
        </trans-unit>
        <trans-unit id="52dcba8fc55d983793d49be111c09fcb50eb3b76" translate="yes" xml:space="preserve">
          <source>The resulting pointer will have provenance of &lt;code&gt;val&lt;/code&gt;, i.e., for a fat pointer, this operation is semantically the same as creating a new fat pointer with the data pointer value of &lt;code&gt;val&lt;/code&gt; but the metadata of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277fa9ca5234a7d85c4310d360b586b5679536d7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;!&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el &lt;code&gt;!&lt;/code&gt; operador.</target>
        </trans-unit>
        <trans-unit id="e0fff7e85f4e0422c5e3edd89994815fd0fa33fe" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb2df529c05fcb3e3ae1db4ab5bf5c9f054fbf92" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36522abccd158f4a83c30f6cbe7b1f733a467a76" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe31e03010cc02b7a70dec74838acc1bf92f653" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49f0b7e4d4d9571dc029b144b407d2d00db70bde" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;*&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5440b4202f92f92a6ad5f44ab02bb1836dc990f2" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a8bf360ec637ebc225332beb0f574739bca97a7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;-&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541f705e1fd40afef0d79bd7f0f4268fa7398a27" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fff5e225b75cdf382af9bb7542d50be9c4363ed" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;^&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el operador &lt;code&gt;^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fee8ba95ad793c2c7dda2e8911dcb02800ab8ed4" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">El tipo resultante despu&amp;eacute;s de aplicar el &lt;code&gt;|&lt;/code&gt; operador.</target>
        </trans-unit>
        <trans-unit id="0473503cf115b2a975e15da3f35244db7bce3d66" translate="yes" xml:space="preserve">
          <source>The resulting type after concatenation</source>
          <target state="translated">El tipo resultante después de la concatenación</target>
        </trans-unit>
        <trans-unit id="dbf5bd29abfe066aae072317675dfaca543c15fe" translate="yes" xml:space="preserve">
          <source>The resulting type after dereferencing.</source>
          <target state="translated">El tipo resultante después de la desreferenciación.</target>
        </trans-unit>
        <trans-unit id="76a4c8bb9eba17c026c554fa00db407a4ed92a09" translate="yes" xml:space="preserve">
          <source>The resulting type after obtaining ownership.</source>
          <target state="translated">El tipo resultante después de obtener la propiedad.</target>
        </trans-unit>
        <trans-unit id="04c53e531d342d2fc7cb2f6812bb0980d9b695cc" translate="yes" xml:space="preserve">
          <source>The resulting vector can be converted back into a box via &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;'s &lt;code&gt;into_boxed_slice&lt;/code&gt; method.</source>
          <target state="translated">El vector resultante puede ser de nuevo convertida en una caja a trav&amp;eacute;s de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 's &lt;code&gt;into_boxed_slice&lt;/code&gt; m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="c631dfaa5b94e5b7afa0d3baba880ecf32c3c788" translate="yes" xml:space="preserve">
          <source>The return type in the desugaring is assumed to capture all lifetime parameters from the &lt;code&gt;async fn&lt;/code&gt; declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3c91f66fb428df18fd8a3b968cf270fb22e4f6" translate="yes" xml:space="preserve">
          <source>The return type isn&amp;rsquo;t &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno no es &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87f17fcd6dd95b0936e246de85107f7f76aa4067" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt;&lt;code&gt;str::escape_debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt; &lt;code&gt;str::escape_debug&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db39743b7e18afb4b0cbc402d05c64c31d6c2284" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt;&lt;code&gt;str::escape_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt; &lt;code&gt;str::escape_default&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d7f1d5c28f55e7c46b28c80bf7c947a04177ba0" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt;&lt;code&gt;str::escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt; &lt;code&gt;str::escape_unicode&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46984a9d3d93237d6af0b4171b9091187f1fd40f" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;read_input()&lt;/code&gt;, &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt;&lt;/a&gt;, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;read_input()&lt;/code&gt; , &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt; &lt;/a&gt; , es un tipo muy com&amp;uacute;n para funciones que no tienen un valor de retorno 'real', pero que quieren devolver errores si ocurren. En este caso, el &amp;uacute;nico prop&amp;oacute;sito de esta funci&amp;oacute;n es leer la l&amp;iacute;nea e imprimirla, as&amp;iacute; que usamos &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8688a274902ed01a0ecc5033bf35069d5bb391" translate="yes" xml:space="preserve">
          <source>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">El valor de retorno es un resultado que indica si el nuevo valor se escribi&amp;oacute; y contiene el valor anterior. En caso de &amp;eacute;xito, se garantiza que este valor ser&amp;aacute; igual a &lt;code&gt;current&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1ea39b856b2d5fee30e6b97044d7752b536c14" translate="yes" xml:space="preserve">
          <source>The return value is always the previous value. If it is equal to &lt;code&gt;current&lt;/code&gt;, then the value was updated.</source>
          <target state="translated">El valor de retorno es siempre el valor anterior. Si es igual a la &lt;code&gt;current&lt;/code&gt; , entonces se actualiz&amp;oacute; el valor.</target>
        </trans-unit>
        <trans-unit id="fc0a38af017feefeb9d3ecc2b64620f7588f7e32" translate="yes" xml:space="preserve">
          <source>The return value may change depending on the compiler version and unsafe code may not rely on the result of this function for soundness. It is suggested to only use this function for performance optimizations where spurious &lt;code&gt;false&lt;/code&gt; return values by this function do not affect the outcome, but just the performance. The consequences of using this method to make runtime and compile-time code behave differently have not been explored. This method should not be used to introduce such differences, and it should also not be stabilized before we have a better understanding of this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bec0cf03017a322224afce0dc723c8da3b1c3f8" translate="yes" xml:space="preserve">
          <source>The return value of this function has no meaning if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">El valor de retorno de esta funci&amp;oacute;n no tiene significado si &lt;code&gt;align&lt;/code&gt; no es una potencia de dos.</target>
        </trans-unit>
        <trans-unit id="60b397a9e27c756600834e9e8bc999da0f2e38e6" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9e4888166c03a2354c980d922cf25c13eb44d0" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">El valor de 64 bits devuelto es equivalente a una estructura &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt; , que representa el n&amp;uacute;mero de intervalos de 100 nanosegundos desde el 1 de enero de 1601 (UTC). La estructura se convierte autom&amp;aacute;ticamente a un valor &lt;code&gt;u64&lt;/code&gt; , ya que esa es la forma recomendada de usarla.</target>
        </trans-unit>
        <trans-unit id="f17e579c0925b04170923132b19bbc2e328718e7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is safe to pass to &lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt;&lt;code&gt;slice::get_unchecked&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt;&lt;code&gt;slice::get_unchecked_mut&lt;/code&gt;&lt;/a&gt; for slices of the given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9caf07f01ab2822f3d6ed99758b9360c5c26af" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">El retorno &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;es una referencia al mismo socket al que hace referencia este objeto. Ambos identificadores se pueden usar para aceptar conexiones entrantes y las opciones establecidas en un oyente afectar&amp;aacute;n al otro.</target>
        </trans-unit>
        <trans-unit id="ded74a0ee30df2ab90178bc7d8c79f6560c92452" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed without the condition being met.</source>
          <target state="translated">El &lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt; devuelto valor indica si se sabe que el tiempo de espera ha transcurrido sin que se cumpla la condici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38736111afdf682fcdb07c273e755038e1599f59" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed.</source>
          <target state="translated">El &lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt; devuelto valor indica si se sabe que ha transcurrido el tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="a4d3afc22fc51194d42ebf97c4d4c71d6cf8d193" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Read&lt;/code&gt; instance will first read all bytes from this object until EOF is encountered. Afterwards the output is equivalent to the output of &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">La instancia de &lt;code&gt;Read&lt;/code&gt; devuelta primero leer&amp;aacute; todos los bytes de este objeto hasta que se encuentre EOF. Posteriormente, la salida es equivalente a la salida de la &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c46cae45e911aa3ffb2e82c2b8df4d3f09691f8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TcpStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">El &lt;code&gt;TcpStream&lt;/code&gt; devuelto es una referencia al mismo flujo al que hace referencia este objeto. Ambos identificadores leer&amp;aacute;n y escribir&amp;aacute;n el mismo flujo de datos, y las opciones establecidas en un flujo se propagar&amp;aacute;n al otro flujo.</target>
        </trans-unit>
        <trans-unit id="f1bab9e66e16ee3bc6f8eaaaaca9a4320b7da4d4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UdpSocket&lt;/code&gt; is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</source>
          <target state="translated">El &lt;code&gt;UdpSocket&lt;/code&gt; devuelto es una referencia al mismo socket al que hace referencia este objeto. Ambos identificadores leer&amp;aacute;n y escribir&amp;aacute;n en el mismo puerto, y las opciones establecidas en un socket se propagar&amp;aacute;n al otro.</target>
        </trans-unit>
        <trans-unit id="c1a563924be47f2135363b13913bddb8d81845c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixDatagram&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.</source>
          <target state="translated">El &lt;code&gt;UnixDatagram&lt;/code&gt; devuelto es una referencia al mismo socket al que hace referencia este objeto. Ambos identificadores se pueden usar para aceptar conexiones entrantes y las opciones establecidas en un lado afectar&amp;aacute;n al otro.</target>
        </trans-unit>
        <trans-unit id="3a69722b38c150ace8c17a0ad6c7500758c624a4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixListener&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">El &lt;code&gt;UnixListener&lt;/code&gt; devuelto es una referencia al mismo socket al que hace referencia este objeto. Ambos identificadores se pueden usar para aceptar conexiones entrantes y las opciones establecidas en un oyente afectar&amp;aacute;n al otro.</target>
        </trans-unit>
        <trans-unit id="144b7ef360f6249426bb7be199321625b6985707" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">El &lt;code&gt;UnixStream&lt;/code&gt; devuelto es una referencia al mismo flujo al que hace referencia este objeto. Ambos identificadores leer&amp;aacute;n y escribir&amp;aacute;n el mismo flujo de datos, y las opciones establecidas en un flujo se propagar&amp;aacute;n al otro flujo.</target>
        </trans-unit>
        <trans-unit id="cb880b11df63d1e3077076bea22bb8b51ec8054d" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;AllocRef&lt;/code&gt; and will simply borrow this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae8d8d70f6a5dbf383ce8f90712add3666ba1c3" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Allocator&lt;/code&gt; and will simply borrow this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3560a746a4c0e2ffb1141c7abaa941ae137d7b4" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Read&lt;/code&gt; and will simply borrow this current reader.</source>
          <target state="translated">El adaptador devuelto tambi&amp;eacute;n implementa &lt;code&gt;Read&lt;/code&gt; y simplemente tomar&amp;aacute; prestado este lector actual.</target>
        </trans-unit>
        <trans-unit id="facac298df7b4792f8b8fe4cbcbc0a4967c70852" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Write&lt;/code&gt; and will simply borrow this current writer.</source>
          <target state="translated">El adaptador devuelto tambi&amp;eacute;n implementa &lt;code&gt;Write&lt;/code&gt; y simplemente tomar&amp;aacute; prestado este escritor actual.</target>
        </trans-unit>
        <trans-unit id="e389b4884c363b3fc760ebd7d93cdcb95de946c0" translate="yes" xml:space="preserve">
          <source>The returned block is suitable for passing to the &lt;code&gt;alloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt; methods of this allocator.</source>
          <target state="translated">El bloque devuelto es adecuado para pasar a los m&amp;eacute;todos &lt;code&gt;alloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; de este asignador.</target>
        </trans-unit>
        <trans-unit id="c91d87a8c74843f84b212121082c194e485a54b8" translate="yes" xml:space="preserve">
          <source>The returned block may have a larger size than specified by &lt;code&gt;layout.size()&lt;/code&gt;, and may or may not have its contents initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d367aab1faeec6de58c9c9955a240781bdbe40" translate="yes" xml:space="preserve">
          <source>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g., to ensure initialization to particular sets of bit patterns.)</source>
          <target state="translated">El bloque de almacenamiento devuelto puede o no tener su contenido inicializado.(Los subretratos de extensión podrían restringir este comportamiento,por ejemplo,para asegurar la inicialización a conjuntos particulares de patrones de bits).</target>
        </trans-unit>
        <trans-unit id="ba2ebcfc4f605284f02edd68881e9753988594f5" translate="yes" xml:space="preserve">
          <source>The returned boolean is &lt;code&gt;false&lt;/code&gt; only if the timeout is known to have elapsed.</source>
          <target state="translated">El booleano devuelto es &lt;code&gt;false&lt;/code&gt; solo si se sabe que ha transcurrido el tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="ef190a0092cd801a89bd32ca6438155668c7c711" translate="yes" xml:space="preserve">
          <source>The returned buffer does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.</source>
          <target state="translated">El b&amp;uacute;fer devuelto &lt;strong&gt;no&lt;/strong&gt; contiene el terminador nulo final y se garantiza que no tendr&amp;aacute; bytes nulos interiores.</target>
        </trans-unit>
        <trans-unit id="c21f9df3ca074ffdfcc498df18bd9b3644edeb21" translate="yes" xml:space="preserve">
          <source>The returned iterator contains a snapshot of the process's environment variables at the time of this invocation. Modifications to environment variables afterwards will not be reflected in the returned iterator.</source>
          <target state="translated">El iterador devuelto contiene una instantánea de las variables de entorno del proceso en el momento de esta invocación.Las modificaciones de las variables de entorno posteriores no se reflejarán en el iterador devuelto.</target>
        </trans-unit>
        <trans-unit id="94742684e4e1a0a940d70b49afd50e4db443fbed" translate="yes" xml:space="preserve">
          <source>The returned iterator may not actually yield any values depending on the outcome of any resolution performed.</source>
          <target state="translated">Es posible que el iterador devuelto no arroje ningún valor dependiendo del resultado de cualquier resolución realizada.</target>
        </trans-unit>
        <trans-unit id="2aad97e80249c67281fd50b9abdb7bf4c0bc39de" translate="yes" xml:space="preserve">
          <source>The returned iterator might panic if the to-be-returned index would overflow a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El iterador devuelto podr&amp;iacute;a entrar en p&amp;aacute;nico si el &amp;iacute;ndice a devolver se desbordara un &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f6e0a2276ef2ac22ba60fa606f31e8d0538ab17" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212e83558d8f38fe873f76d6ab8c409b36c6c1ca" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">El iterador devuelto requiere que el patr&amp;oacute;n admita una b&amp;uacute;squeda inversa, y ser&amp;aacute; un &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; si una b&amp;uacute;squeda hacia adelante / hacia atr&amp;aacute;s produce los mismos elementos.</target>
        </trans-unit>
        <trans-unit id="0a192fbaedef699058263c6cf3d017b9555c1581" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</source>
          <target state="translated">El iterador devuelto requiere que el patrón soporte una búsqueda inversa,y será doblemente terminado si una búsqueda hacia adelante/reversa arroja los mismos elementos.</target>
        </trans-unit>
        <trans-unit id="31cf06022e130c2b8e694b6f17ab8cbe9626501c" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4543e6c97747a65b55c800608ca5f7c928ee84b5" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">El iterador devuelto ser&amp;aacute; un &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; si el patr&amp;oacute;n permite una b&amp;uacute;squeda inversa y la b&amp;uacute;squeda hacia adelante / hacia atr&amp;aacute;s produce los mismos elementos. Esto es cierto para, por ejemplo, &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , pero no para &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcd14ee368ff1244ad97f001dc72e74042b0095f" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">El iterador devuelto ser&amp;aacute; un &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; si el patr&amp;oacute;n permite una b&amp;uacute;squeda inversa y la b&amp;uacute;squeda hacia adelante / hacia atr&amp;aacute;s produce los mismos elementos. Esto es cierto para, por ejemplo, &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , pero no para &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb1179f626056fe35d781c0e7e7072fe8a2697c8" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e7ec844babb660dc32f9f713ab552f258e8f9a" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">El iterador devuelto nunca devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; y tampoco producir&amp;aacute; la estructura &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; del par . Iterarlo es equivalente a llamar a &lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; en un bucle.</target>
        </trans-unit>
        <trans-unit id="40daaaf435dcc6bfd52a2f60c0016a88fb0c4d52" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;TcpListener::accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cacc276ab85a92453bcb875fe7d5c79fd6233ed" translate="yes" xml:space="preserve">
          <source>The returned iterator will not be double ended, because it is not efficient to support.</source>
          <target state="translated">El iterador devuelto no tendrá doble terminación,porque no es eficiente para soportar.</target>
        </trans-unit>
        <trans-unit id="6626efd84bc65ae6d8cabe4bc5b2e309e23cd9ee" translate="yes" xml:space="preserve">
          <source>The returned iterator will panic during iteration if any argument to the process is not valid unicode. If this is not desired, use the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;args_os&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">El iterador devuelto entrar&amp;aacute; en p&amp;aacute;nico durante la iteraci&amp;oacute;n si alg&amp;uacute;n argumento del proceso no es Unicode v&amp;aacute;lido. Si no lo desea, utilice la funci&amp;oacute;n &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;args_os&lt;/code&gt; en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="48642a85c9b9785eaffc2d69f306f5a44a684795" translate="yes" xml:space="preserve">
          <source>The returned iterator yields only the &lt;code&gt;value&lt;/code&gt;s for which the supplied closure returns &lt;code&gt;Some(value)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4abf6a88076e830a1096ad48a0fcbdcd010f5d" translate="yes" xml:space="preserve">
          <source>The returned lifetime is not guaranteed to be the actual lifetime of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">No se garantiza que la vida &amp;uacute;til &lt;code&gt;ptr&lt;/code&gt; sea ​​la vida real de ptr .</target>
        </trans-unit>
        <trans-unit id="dd646ddea405b753233bb6eb50b8340613c5b51f" translate="yes" xml:space="preserve">
          <source>The returned listener is ready for accepting connections.</source>
          <target state="translated">El oyente que regresa está listo para aceptar conexiones.</target>
        </trans-unit>
        <trans-unit id="32a2e5d176a9d291f17213749b86ae928f9a79fd" translate="yes" xml:space="preserve">
          <source>The returned name refers to a source path on the compiling system, but it isn't valid to represent this directly as a &lt;code&gt;&amp;amp;Path&lt;/code&gt;. The compiled code may run on a different system with a different &lt;code&gt;Path&lt;/code&gt; implementation than the system providing the contents and this library does not currently have a different &quot;host path&quot; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3776d88d1ca8845ec6b1038a3cef52ddd6c1ee" translate="yes" xml:space="preserve">
          <source>The returned object can be used for error recovery, such as re-inspecting the buffer.</source>
          <target state="translated">El objeto devuelto puede ser utilizado para la recuperación de errores,como la reinspección del buffer.</target>
        </trans-unit>
        <trans-unit id="d094ca8efdcd1c477cd38db568c96ab96a8083f1" translate="yes" xml:space="preserve">
          <source>The returned pointer is read-only; writing to it (including passing it to C code that writes to it) causes undefined behavior.</source>
          <target state="translated">El puntero devuelto es de sólo lectura;escribirle (incluyendo pasarlo al código C que le escribe)causa un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="9b9b68320305244b712b6eba3fb78b4a32d8f345" translate="yes" xml:space="preserve">
          <source>The returned pointer will be valid for as long as &lt;code&gt;self&lt;/code&gt; is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.</source>
          <target state="translated">El puntero devuelto ser&amp;aacute; v&amp;aacute;lido mientras lo sea &lt;code&gt;self&lt;/code&gt; , y apunta a una regi&amp;oacute;n contigua de memoria terminada con un byte 0 para representar el final de la cadena.</target>
        </trans-unit>
        <trans-unit id="d1d3044eae78ae415d38e3ebb8ef901b44a28df4" translate="yes" xml:space="preserve">
          <source>The returned range is half-open, which means that the end pointer points &lt;em&gt;one past&lt;/em&gt; the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c27af8743c2ff7ed690feb622313cb681b2d0e2" translate="yes" xml:space="preserve">
          <source>The returned slice can be used to fill the vector with data (e.g. by reading from a file) before marking the data as initialized using the &lt;a href=&quot;struct.vec#method.set_len&quot;&gt;&lt;code&gt;set_len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0c4a80af7569dc2827892f37e1cf7abb925f27" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">El segmento devuelto &lt;strong&gt;no&lt;/strong&gt; contiene el terminador nulo final y se garantiza que no tiene bytes nulos interiores. Si necesita el terminador nul, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="0a368474e9b2e8c2f52646dd2d7918f986464f59" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c2a4410e35e072d95d91733db13ddd5bf58ad1" translate="yes" xml:space="preserve">
          <source>The returned slice will &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator that this C string has.</source>
          <target state="translated">El segmento devuelto &lt;strong&gt;no&lt;/strong&gt; contendr&amp;aacute; el terminador nulo final que tiene esta cadena C.</target>
        </trans-unit>
        <trans-unit id="a46b9c2f552385dbbfeb1cece6cdbcca5271f43e" translate="yes" xml:space="preserve">
          <source>The returned string must not be considered to be a unique identifier of a type as multiple types may map to the same type name. Similarly, there is no guarantee that all parts of a type will appear in the returned string: for example, lifetime specifiers are currently not included. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6695d62fb3138a05ebea6941a15916ea38fd70" translate="yes" xml:space="preserve">
          <source>The returned type after indexing.</source>
          <target state="translated">El tipo devuelto después de la indexación.</target>
        </trans-unit>
        <trans-unit id="323e9e5f7457b4d404421a53102d137f9784ffb2" translate="yes" xml:space="preserve">
          <source>The returned type after the call operator is used.</source>
          <target state="translated">El tipo devuelto después de que se utilice el operador de llamadas.</target>
        </trans-unit>
        <trans-unit id="2d5978ed3eb5e45dd0ed7362549dedf897ab386a" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">El tipo devuelto implementa &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; donde el &lt;code&gt;Item&lt;/code&gt; es &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . El elemento &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; es correcto si un byte se ley&amp;oacute; correctamente y &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; en&lt;/a&gt; caso contrario. EOF se asigna para devolver &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; desde este iterador.</target>
        </trans-unit>
        <trans-unit id="94490bb5f034be81aa72ad51da07b198637a8c28" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b4fa361f895a3f7a940a0df4cc75d5065e98e6" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;atime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastAccessTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">El valor devuelto corresponde al campo &lt;code&gt;atime&lt;/code&gt; de &lt;code&gt;stat&lt;/code&gt; en plataformas Unix y al campo &lt;code&gt;ftLastAccessTime&lt;/code&gt; en plataformas Windows.</target>
        </trans-unit>
        <trans-unit id="ab7615b505b03838f921f8936a1701e974958831" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">El valor devuelto corresponde al campo de tiempo de &lt;code&gt;birthtime&lt;/code&gt; de &lt;code&gt;stat&lt;/code&gt; en plataformas Unix y al campo &lt;code&gt;ftCreationTime&lt;/code&gt; en plataformas Windows.</target>
        </trans-unit>
        <trans-unit id="2eef349b822dea9863943a97049788d8df72cce1" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;btime&lt;/code&gt; field of &lt;code&gt;statx&lt;/code&gt; on Linux kernel starting from to 4.11, the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on other Unix platforms, and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5896159de75927b2d1b622cfd587f254e9fed43" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;mtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastWriteTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">El valor devuelto corresponde al campo &lt;code&gt;mtime&lt;/code&gt; de &lt;code&gt;stat&lt;/code&gt; en plataformas Unix y al campo &lt;code&gt;ftLastWriteTime&lt;/code&gt; en plataformas Windows.</target>
        </trans-unit>
        <trans-unit id="a0ea9c14c32dc6d6e0d323b13279abc6935b1d15" translate="yes" xml:space="preserve">
          <source>The returned value does include the fractional (nanosecond) part of the duration.</source>
          <target state="translated">El valor devuelto incluye la parte fraccionaria (nanosegundo)de la duración.</target>
        </trans-unit>
        <trans-unit id="ff15d0950ff1afde3f0762acc64a9f002a6a04c1" translate="yes" xml:space="preserve">
          <source>The returned value does not have meaning for directories.</source>
          <target state="translated">El valor devuelto no tiene significado para los directorios.</target>
        </trans-unit>
        <trans-unit id="e8c08d63d79b2a138a0f12bb7a91ea3ec23dcec7" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El valor devuelto no incluye la parte fraccionaria (nanosegundos) de la duraci&amp;oacute;n, que se puede obtener utilizando &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bfa4d7247e116de4261b1e09435dc9dcadacc45" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5135e5751b93b5d235f37608301c3018208e63" translate="yes" xml:space="preserve">
          <source>The returned value is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d2d5505f46c3741e892512e8371427a53745d7" translate="yes" xml:space="preserve">
          <source>The right shift assignment operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de turno derecho &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e00fa6358174afd137529285f589695abe7555ab" translate="yes" xml:space="preserve">
          <source>The right shift operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; and &lt;code&gt;a.shr(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">El operador de turno correcto &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; . Tenga en cuenta que debido a que este rasgo se implementa para todos los tipos de enteros con m&amp;uacute;ltiples tipos del lado derecho, el verificador de tipos de Rust tiene un manejo especial para &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt; , estableciendo el tipo de resultado para operaciones enteras al tipo del operando del lado izquierdo . Esto significa que aunque &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; y &lt;code&gt;a.shr(b)&lt;/code&gt; son una y la misma desde el punto de vista de evaluaci&amp;oacute;n, que son diferentes cuando se trata de la inferencia de tipos.</target>
        </trans-unit>
        <trans-unit id="4bed85e5cf48df182fbdc5f50e1999ffc9d50cbb" translate="yes" xml:space="preserve">
          <source>The right way to suppress the warning is to actually write error handling, but because you just want to crash this program when a problem occurs, you can use &lt;code&gt;expect&lt;/code&gt;. You&amp;rsquo;ll learn about recovering from errors in Chapter 9.</source>
          <target state="translated">La forma correcta de suprimir la advertencia es escribir realmente el manejo de errores, pero debido a que solo desea bloquear este programa cuando ocurre un problema, puede usar &lt;code&gt;expect&lt;/code&gt; . Aprender&amp;aacute; a recuperarse de errores en el Cap&amp;iacute;tulo 9.</target>
        </trans-unit>
        <trans-unit id="93b14b29a7aed966fc23a390a9832d3b882cc69b" translate="yes" xml:space="preserve">
          <source>The root directory component, appears after any prefix and before anything else.</source>
          <target state="translated">El componente del directorio raíz,aparece después de cualquier prefijo y antes de cualquier otra cosa.</target>
        </trans-unit>
        <trans-unit id="a168d72d668df499616b725b5ca80c1ff007a04a" translate="yes" xml:space="preserve">
          <source>The rules for &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; match those for normal struct types, while &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; behave as if &lt;a href=&quot;../attributes/derive&quot;&gt;derived&lt;/a&gt;. For &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, the order of cloning of the captured variables is left unspecified.</source>
          <target state="translated">Las reglas para &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; coinciden con las de los tipos de estructuras normales, mientras que &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; comportan como si &lt;a href=&quot;../attributes/derive&quot;&gt;fueran derivados&lt;/a&gt; . Para &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , el orden de clonaci&amp;oacute;n de las variables capturadas no se especifica.</target>
        </trans-unit>
        <trans-unit id="3563595879dbbd21c6c2906f7bd54a9b3679529d" translate="yes" xml:space="preserve">
          <source>The rust compiler cannot link to an external library if you don't give it its name. Example:</source>
          <target state="translated">El compilador de óxido no puede enlazar con una biblioteca externa si no le das su nombre.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="54065002f88e1cb544dc442e2b3686e62225bf94" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">El compilador de óxido mantiene para cada objetivo una lista negra de ABIs sin apoyo en ese objetivo.Si un ABI está presente en dicha lista,esto normalmente significa que la combinación objetivo/ABI no está actualmente soportada por llvm.</target>
        </trans-unit>
        <trans-unit id="e602506551cf00543c3919704a07e8c114c13f33" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a list of unsupported ABIs on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dcfff8659995d9c806c4ff5bfe72343be6d124" translate="yes" xml:space="preserve">
          <source>The rustfix tool is included with Rust installations and can automatically fix some compiler warnings. If you&amp;rsquo;ve written code in Rust, you&amp;rsquo;ve probably seen compiler warnings. For example, consider this code:</source>
          <target state="translated">La herramienta rustfix se incluye con las instalaciones de Rust y puede corregir autom&amp;aacute;ticamente algunas advertencias del compilador. Si ha escrito c&amp;oacute;digo en Rust, probablemente haya visto advertencias del compilador. Por ejemplo, considere este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="d95e676c8653714db7acc846f5781f129f187994" translate="yes" xml:space="preserve">
          <source>The safety and conciseness of &lt;code&gt;for&lt;/code&gt; loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a &lt;code&gt;while&lt;/code&gt; loop in Listing 3-3, most Rustaceans would use a &lt;code&gt;for&lt;/code&gt; loop. The way to do that would be to use a &lt;code&gt;Range&lt;/code&gt;, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.</source>
          <target state="translated">La seguridad y la concisi&amp;oacute;n de los bucles &lt;code&gt;for&lt;/code&gt; los convierten en la construcci&amp;oacute;n de bucles m&amp;aacute;s utilizada en Rust. Incluso en situaciones en las que se desea ejecutar alg&amp;uacute;n c&amp;oacute;digo de un determinado n&amp;uacute;mero de veces, como en el ejemplo de cuenta atr&amp;aacute;s que utiliza un &lt;code&gt;while&lt;/code&gt; de bucle en el Listado 3-3, la mayor&amp;iacute;a de Rustaceans usar&amp;iacute;a una &lt;code&gt;for&lt;/code&gt; bucle. La forma de hacerlo ser&amp;iacute;a usar un &lt;code&gt;Range&lt;/code&gt; , que es un tipo proporcionado por la biblioteca est&amp;aacute;ndar que genera todos los n&amp;uacute;meros en secuencia comenzando desde un n&amp;uacute;mero y terminando antes de otro n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="8de5417b2f4455bae199197d09ad86c5d8b15755" translate="yes" xml:space="preserve">
          <source>The safety conditions are described in the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c5f02c44747e09b58d1ec500165079e9867619" translate="yes" xml:space="preserve">
          <source>The same applies to transmutes to &lt;code&gt;*mut fn()&lt;/code&gt;, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just &lt;code&gt;fn()&lt;/code&gt; alone suffices for that. &lt;code&gt;*mut fn()&lt;/code&gt; is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</source>
          <target state="translated">Lo mismo se aplica a las transmutaciones a &lt;code&gt;*mut fn()&lt;/code&gt; , que se observaron en la pr&amp;aacute;ctica. Sin embargo, tenga en cuenta que el uso de este tipo es generalmente incorrecto. La intenci&amp;oacute;n suele ser describir un puntero de funci&amp;oacute;n, pero solo &lt;code&gt;fn()&lt;/code&gt; suficiente para eso. &lt;code&gt;*mut fn()&lt;/code&gt; es un puntero a un puntero fn. (Dado que estos valores generalmente se pasan al c&amp;oacute;digo C, sin embargo, esto rara vez hace una diferencia en la pr&amp;aacute;ctica).</target>
        </trans-unit>
        <trans-unit id="a7f4b342720ddcec9a49dfb2ca6daf016843320d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c676ce454b9f3ef8b4d42559af1943bf2b7913d9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7e4f0db03c726bc5bd7452fa0f56591b66e33d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf7a6ad9f8fb40e4ba7caca628efe6809216b4f" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ae9b3d116905ba91635f77fa80dd3badbdd424" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f595892b4fea20450f05cddbe7763f0e003caa0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b129096713d6e93f0f6771f5a02e553c2efcf3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902a2b25118315948a58ef98f0d17bd457899153" translate="yes" xml:space="preserve">
          <source>The same goes for doc comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8159833047b3772ef09e1ff09bc6721b1345cc" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc57fcef5c1050ba1f9373a34844306a6911e2e" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt;&lt;code&gt;as_raw&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">Se aplican las mismas restricciones de acceso al destino del puntero que con &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt; &lt;code&gt;as_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e53c2cdb1077121198b1a8746e267d3b3a805b0e" translate="yes" xml:space="preserve">
          <source>The scope in which the variable &lt;code&gt;s&lt;/code&gt; is valid is the same as any function parameter&amp;rsquo;s scope, but we don&amp;rsquo;t drop what the reference points to when it goes out of scope because we don&amp;rsquo;t have ownership. When functions have references as parameters instead of the actual values, we won&amp;rsquo;t need to return the values in order to give back ownership, because we never had ownership.</source>
          <target state="translated">El alcance en el que la variable &lt;code&gt;s&lt;/code&gt; es v&amp;aacute;lida es el mismo que el alcance de cualquier par&amp;aacute;metro de funci&amp;oacute;n, pero no descartamos a qu&amp;eacute; apunta la referencia cuando sale del alcance porque no tenemos propiedad. Cuando las funciones tienen referencias como par&amp;aacute;metros en lugar de los valores reales, no necesitaremos devolver los valores para devolver la propiedad, porque nunca la tuvimos.</target>
        </trans-unit>
        <trans-unit id="2c0f9db762db77543e23786689d772ed7e180cf6" translate="yes" xml:space="preserve">
          <source>The scopes of the immutable references &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; end after the &lt;code&gt;println!&lt;/code&gt; where they are last used, which is before the mutable reference &lt;code&gt;r3&lt;/code&gt; is created. These scopes don&amp;rsquo;t overlap, so this code is allowed.</source>
          <target state="translated">Los alcances de las referencias inmutables &lt;code&gt;r1&lt;/code&gt; y &lt;code&gt;r2&lt;/code&gt; terminan despu&amp;eacute;s de &lt;code&gt;println!&lt;/code&gt; donde se usaron por &amp;uacute;ltima vez, que es antes de que se cree la referencia mutable &lt;code&gt;r3&lt;/code&gt; . Estos &amp;aacute;mbitos no se superponen, por lo que este c&amp;oacute;digo est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="547c47e37f57601f738482d42256219a9633dd7e" translate="yes" xml:space="preserve">
          <source>The search path to be used may be controlled by setting the &lt;code&gt;PATH&lt;/code&gt; environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).</source>
          <target state="translated">La ruta de b&amp;uacute;squeda que se utilizar&amp;aacute; se puede controlar configurando la &lt;code&gt;PATH&lt;/code&gt; entorno PATH en el comando, pero esto tiene algunas limitaciones de implementaci&amp;oacute;n en Windows (consulte el n&amp;uacute;mero 37519).</target>
        </trans-unit>
        <trans-unit id="3a555019f8dcc01c39b7fc4a4df1fa78e901c698" translate="yes" xml:space="preserve">
          <source>The second case example is a bit particular: the main function must always have this definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a1a4dab2732977e1598d466f79a0132530331a" translate="yes" xml:space="preserve">
          <source>The second form of macros is &lt;em&gt;procedural macros&lt;/em&gt;, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</source>
          <target state="translated">La segunda forma de macros son &lt;em&gt;las macros de procedimiento&lt;/em&gt; , que act&amp;uacute;an m&amp;aacute;s como funciones (y son un tipo de procedimiento). Las macros de procedimiento aceptan alg&amp;uacute;n c&amp;oacute;digo como entrada, operan en ese c&amp;oacute;digo y producen algo de c&amp;oacute;digo como salida en lugar de compararlo con los patrones y reemplazar el c&amp;oacute;digo con otro c&amp;oacute;digo como lo hacen las macros declarativas.</target>
        </trans-unit>
        <trans-unit id="014f5e70707fe70de5f920ceaf6bbf6f00b7acd7" translate="yes" xml:space="preserve">
          <source>The second half of the tuple that is returned is an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; here means that either there is no known upper bound, or the upper bound is larger than &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La segunda mitad de la tupla que se devuelve es una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; aqu&amp;iacute; significa que o bien no se conoce ning&amp;uacute;n superior obligados, o el l&amp;iacute;mite superior es mayor que &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4961749eb1f24345f8436cc7b35d0ebccb81384a" translate="yes" xml:space="preserve">
          <source>The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of &lt;code&gt;tt ...&lt;/code&gt;'s, even as new syntactic forms are added to the language.</source>
          <target state="translated">El segundo invariante dice que un NT complejo separado debe usar un s&amp;iacute;mbolo separador que es parte del conjunto de seguimiento predeterminado para el contenido interno del NT. Esto asegura que una macrodefinici&amp;oacute;n legal continuar&amp;aacute; analizando un fragmento de entrada en la misma secuencia delimitada de &lt;code&gt;tt ...&lt;/code&gt; , incluso cuando se agreguen nuevas formas sint&amp;aacute;cticas al lenguaje.</target>
        </trans-unit>
        <trans-unit id="3069a4f51af6a3b6633b4d681ece722a85d63fa2" translate="yes" xml:space="preserve">
          <source>The second is mutable references. They can be created from &lt;code&gt;mut&lt;/code&gt; variables and must be unique: no other variables can have a mutable reference, nor a shared reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2dca747a6f3fa79f2291ae843df5963e36bbc5" translate="yes" xml:space="preserve">
          <source>The second is that it is the offset in bytes between successive elements in an array with that item type.</source>
          <target state="translated">La segunda es que es el desplazamiento en bytes entre los sucesivos elementos de una matriz con ese tipo de elementos.</target>
        </trans-unit>
        <trans-unit id="a1e02e9dcee081f5b8c19c27d767e65c0ff37f76" translate="yes" xml:space="preserve">
          <source>The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section.</source>
          <target state="translated">La segunda es mejorar en general el conocimiento de una faceta del idioma.En ese caso,sólo tienes que navegar por el índice hasta que veas algo sobre lo que quieras saber más,y empezar a leer.Si un enlace parece interesante,haz clic en él y lee sobre esa sección.</target>
        </trans-unit>
        <trans-unit id="df5949936d6a2cd7eaf61fe27eb1fac54cf960fb" translate="yes" xml:space="preserve">
          <source>The second line that we added to the middle of the code prints the secret number. This is useful while we&amp;rsquo;re developing the program to be able to test it, but we&amp;rsquo;ll delete it from the final version. It&amp;rsquo;s not much of a game if the program prints the answer as soon as it starts!</source>
          <target state="translated">La segunda l&amp;iacute;nea que agregamos a la mitad del c&amp;oacute;digo imprime el n&amp;uacute;mero secreto. Esto es &amp;uacute;til mientras estamos desarrollando el programa para poder probarlo, pero lo eliminaremos de la versi&amp;oacute;n final. &amp;iexcl;No es un gran juego si el programa imprime la respuesta tan pronto como comienza!</target>
        </trans-unit>
        <trans-unit id="c1f82d829df68033c418a80c29f6453df31bb3f7" translate="yes" xml:space="preserve">
          <source>The second operand of a &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bb822113e197cd1e10145a43fbd748bc848a6a" translate="yes" xml:space="preserve">
          <source>The second problem with the current &lt;code&gt;Cacher&lt;/code&gt; implementation is that it only accepts closures that take one parameter of type &lt;code&gt;u32&lt;/code&gt; and return a &lt;code&gt;u32&lt;/code&gt;. We might want to cache the results of closures that take a string slice and return &lt;code&gt;usize&lt;/code&gt; values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the &lt;code&gt;Cacher&lt;/code&gt; functionality.</source>
          <target state="translated">El segundo problema con la implementaci&amp;oacute;n actual de &lt;code&gt;Cacher&lt;/code&gt; es que solo acepta cierres que toman un par&amp;aacute;metro de tipo &lt;code&gt;u32&lt;/code&gt; y devuelven &lt;code&gt;u32&lt;/code&gt; . Podr&amp;iacute;amos querer almacenar en cach&amp;eacute; los resultados de los cierres que toman un segmento de cadena y devuelven valores &lt;code&gt;usize&lt;/code&gt; , por ejemplo. Para solucionar este problema, intente introducir par&amp;aacute;metros m&amp;aacute;s gen&amp;eacute;ricos para aumentar la flexibilidad de la funcionalidad &lt;code&gt;Cacher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92462e612674a20cc7e3c63f701740ce5bea5c75" translate="yes" xml:space="preserve">
          <source>The second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</source>
          <target state="translated">La segunda regla se aplica porque hay exactamente una vida de entrada.La segunda regla especifica que la vida útil del parámetro de una entrada se asigna a la vida útil de la salida,por lo que la firma es ahora ésta:</target>
        </trans-unit>
        <trans-unit id="66815e0776a29457690bd505c60d2e19937fa654" translate="yes" xml:space="preserve">
          <source>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt;.</source>
          <target state="translated">La segunda regla es que si hay exactamente un par&amp;aacute;metro de vida &amp;uacute;til de entrada, esa vida &amp;uacute;til se asigna a todos los par&amp;aacute;metros de vida &amp;uacute;til de salida: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aedd96f8435bb44ce30001804fbe27f5473ed0ee" translate="yes" xml:space="preserve">
          <source>The second time we call &lt;code&gt;add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use a relative path. The path starts with &lt;code&gt;front_of_house&lt;/code&gt;, the name of the module defined at the same level of the module tree as &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Here the filesystem equivalent would be using the path &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt;. Starting with a name means that the path is relative.</source>
          <target state="translated">La segunda vez que llamamos &lt;code&gt;add_to_waitlist&lt;/code&gt; en &lt;code&gt;eat_at_restaurant&lt;/code&gt; , usamos una ruta relativa. La ruta comienza con &lt;code&gt;front_of_house&lt;/code&gt; , el nombre del m&amp;oacute;dulo definido en el mismo nivel del &amp;aacute;rbol de m&amp;oacute;dulos que &lt;code&gt;eat_at_restaurant&lt;/code&gt; . Aqu&amp;iacute;, el equivalente del sistema de archivos ser&amp;iacute;a usar la ruta &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt; . Comenzar con un nombre significa que la ruta es relativa.</target>
        </trans-unit>
        <trans-unit id="6719785aa3871b4c2a2d425aeb686279358fe018" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; customizes &lt;code&gt;Drop&lt;/code&gt; to deallocate the space on the heap that the box points to.</source>
          <target state="translated">El segundo rasgo importante del patr&amp;oacute;n de puntero inteligente es &lt;code&gt;Drop&lt;/code&gt; , que le permite personalizar lo que sucede cuando un valor est&amp;aacute; a punto de salir del alcance. Puede proporcionar una implementaci&amp;oacute;n para el rasgo &lt;code&gt;Drop&lt;/code&gt; en cualquier tipo, y el c&amp;oacute;digo que especifique se puede usar para liberar recursos como archivos o conexiones de red. Estamos introduciendo &lt;code&gt;Drop&lt;/code&gt; en el contexto de los punteros inteligentes porque la funcionalidad del rasgo &lt;code&gt;Drop&lt;/code&gt; casi siempre se usa al implementar un puntero inteligente. Por ejemplo, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; personaliza &lt;code&gt;Drop&lt;/code&gt; para desasignar el espacio en el mont&amp;oacute;n al que apunta el cuadro.</target>
        </trans-unit>
        <trans-unit id="445effcb8001016422ef7635d91738ff3683b61e" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, when a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is dropped it will deallocate the space on the heap that the box points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9253951b95bdbecdb3d6ee784fab1524db5c9af" translate="yes" xml:space="preserve">
          <source>The second type of operation that requires an unsafe block is calls to unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra &lt;code&gt;unsafe&lt;/code&gt; before the rest of the definition. The &lt;code&gt;unsafe&lt;/code&gt; keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&amp;rsquo;t guarantee we&amp;rsquo;ve met these requirements. By calling an unsafe function within an &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;re saying that we&amp;rsquo;ve read this function&amp;rsquo;s documentation and take responsibility for upholding the function&amp;rsquo;s contracts.</source>
          <target state="translated">El segundo tipo de operaci&amp;oacute;n que requiere un bloqueo inseguro son las llamadas a funciones inseguras. Las funciones y m&amp;eacute;todos inseguros se ven exactamente como las funciones y m&amp;eacute;todos normales, pero tienen un extra de &lt;code&gt;unsafe&lt;/code&gt; antes del resto de la definici&amp;oacute;n. La palabra clave &lt;code&gt;unsafe&lt;/code&gt; en este contexto indica que la funci&amp;oacute;n tiene requisitos que debemos cumplir cuando llamamos a esta funci&amp;oacute;n, porque Rust no puede garantizar que cumplimos con estos requisitos. Al llamar a una funci&amp;oacute;n insegura dentro de un bloque &lt;code&gt;unsafe&lt;/code&gt; , estamos diciendo que hemos le&amp;iacute;do la documentaci&amp;oacute;n de esta funci&amp;oacute;n y asumimos la responsabilidad de mantener los contratos de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3b5790cbd3c99b8bfcd34f57b9dbfe5e2b8bc741" translate="yes" xml:space="preserve">
          <source>The second-to-last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599ddbb55a436b4b2320e8d917bb378c0d788288" translate="yes" xml:space="preserve">
          <source>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</source>
          <target state="translated">La semántica para pasar un valor a una función es similar a la de asignar un valor a una variable.Pasar una variable a una función se moverá o copiará,tal como lo hace la asignación.La lista 4-3 tiene un ejemplo con algunas anotaciones que muestran dónde entran y salen las variables.</target>
        </trans-unit>
        <trans-unit id="0ebf78e0ec598941096cd9f3613dea835a20177d" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">La sem&amp;aacute;ntica de esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; excepto que el hilo se bloquear&amp;aacute; durante aproximadamente no m&amp;aacute;s de &lt;code&gt;dur&lt;/code&gt; . Este m&amp;eacute;todo no se debe utilizar para la sincronizaci&amp;oacute;n exacta debido a anomal&amp;iacute;as tales como derecho de prioridad o de plataforma diferencias que pueden no causar la cantidad m&amp;aacute;xima de tiempo esper&amp;oacute; para ser precisamente &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8ab2e3b0b43343b07ba616db0d9b83ddc1ec9a" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">La sem&amp;aacute;ntica de esta funci&amp;oacute;n son equivalentes a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , excepto que el hilo ser&amp;aacute; bloqueada durante m&amp;aacute;s o menos no m&amp;aacute;s de &lt;code&gt;ms&lt;/code&gt; milisegundos. Este m&amp;eacute;todo no debe usarse para tiempos precisos debido a anomal&amp;iacute;as como preferencia o diferencias de plataforma que pueden no causar que la cantidad m&amp;aacute;xima de tiempo esperada sea precisamente en &lt;code&gt;ms&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10369644dc806ec3584f4bc1cd00c1b37924dd8f" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">La sem&amp;aacute;ntica de esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; ,&lt;/a&gt; excepto que el hilo se bloquear&amp;aacute; durante aproximadamente no m&amp;aacute;s de &lt;code&gt;dur&lt;/code&gt; . Este m&amp;eacute;todo no se debe utilizar para la sincronizaci&amp;oacute;n exacta debido a anomal&amp;iacute;as tales como derecho de prioridad o de plataforma diferencias que pueden no causar la cantidad m&amp;aacute;xima de tiempo esper&amp;oacute; para ser precisamente &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="599bdbbdba24d3dd39b2e820e78610be901175cf" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt; long.</source>
          <target state="translated">La sem&amp;aacute;ntica de esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; ,&lt;/a&gt; excepto que el hilo se bloquear&amp;aacute; durante aproximadamente no m&amp;aacute;s de &lt;code&gt;dur&lt;/code&gt; . Este m&amp;eacute;todo no debe usarse para tiempos precisos debido a anomal&amp;iacute;as tales como preferencia o diferencias de plataforma que pueden no causar que la cantidad m&amp;aacute;xima de tiempo esperada sea precisamente &lt;code&gt;dur&lt;/code&gt; ante mucho tiempo.</target>
        </trans-unit>
        <trans-unit id="9563714599dd3161cea050e5c59d88f3adc62446" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt; long.</source>
          <target state="translated">La sem&amp;aacute;ntica de esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; ,&lt;/a&gt; excepto que el hilo se bloquear&amp;aacute; durante aproximadamente no m&amp;aacute;s de &lt;code&gt;dur&lt;/code&gt; . Este m&amp;eacute;todo no debe usarse para tiempos precisos debido a anomal&amp;iacute;as como preferencia o diferencias de plataforma que pueden no hacer que la cantidad m&amp;aacute;xima de tiempo esperada sea precisamente en &lt;code&gt;ms&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ace657d10944a484e642331ec94fc1a6e6161be" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3371efd221cedf557721fc9ee15bda8759a39a9" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e595d1de9f2e3618f10b608ff234b6ad2944f66" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3d66bfcd3164df001d8c8d3ea53b374782f46" translate="yes" xml:space="preserve">
          <source>The semicolon &lt;code&gt;;&lt;/code&gt; can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to &lt;code&gt;()&lt;/code&gt;. For example,</source>
          <target state="translated">El punto &lt;code&gt;;&lt;/code&gt; coma ; se puede usar para descartar el resultado de una expresi&amp;oacute;n al final de un bloque, haciendo que la expresi&amp;oacute;n (y por lo tanto el bloque) se eval&amp;uacute;e como &lt;code&gt;()&lt;/code&gt; . Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="bb5601bddd79e71c2b7b66e9a5ead92eff60bcdd" translate="yes" xml:space="preserve">
          <source>The send and receive operations on channels will all return a &lt;a href=&quot;../../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having &quot;hung up&quot; by being dropped in its corresponding thread.</source>
          <target state="translated">Las operaciones de env&amp;iacute;o y recepci&amp;oacute;n en los canales devolver&amp;aacute;n un &lt;a href=&quot;../../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; indica si la operaci&amp;oacute;n se realiz&amp;oacute; correctamente o no. Una operaci&amp;oacute;n fallida normalmente indica que la otra mitad de un canal se ha &quot;colgado&quot; al caer en su hilo correspondiente.</target>
        </trans-unit>
        <trans-unit id="ea8d26ff0d36fb568a938927807eafbc1ae6f29d" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's asynchronous &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; type. This half can only be owned by one thread, but it can be cloned to send to other threads.</source>
          <target state="translated">La mitad de env&amp;iacute;o del tipo de &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; as&amp;iacute;ncrono de Rust . Esta mitad solo puede ser propiedad de un hilo, pero se puede clonar para enviar a otros hilos.</target>
        </trans-unit>
        <trans-unit id="52ce535fefd9bc68502a1a5978b6409a82fd1bcb" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's synchronous &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">La mitad de &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; tipo sync_channel s&amp;iacute;ncrono de Rust .</target>
        </trans-unit>
        <trans-unit id="937e495e6de5b225295fc788a2b8a9723c5d12e3" translate="yes" xml:space="preserve">
          <source>The sequential nature of the tuple applies to its implementations of various traits. For example, in &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Ord&lt;/code&gt;, the elements are compared sequentially until the first non-equal set is found.</source>
          <target state="translated">La naturaleza secuencial de la tupla se aplica a sus implementaciones de varios rasgos. Por ejemplo, en &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; , los elementos se comparan secuencialmente hasta que se encuentra el primer conjunto no igual.</target>
        </trans-unit>
        <trans-unit id="faf864ad82a0182728e07d76ebfb5f1fdf6dc8f4" translate="yes" xml:space="preserve">
          <source>The signed two's complement integer types consist of:</source>
          <target state="translated">Los tipos enteros de complemento de los dos firmantes consisten en:</target>
        </trans-unit>
        <trans-unit id="0a593fcbffb90fbe9434a8bd0cd231a38381ce34" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the &amp;ldquo;Hello, world!&amp;rdquo; project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dca1ad1ce59bbb51cae453b849e2d3bd139c7cf" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the Hello, world! project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">Los programas de Rust m&amp;aacute;s simples, como el que hemos escrito hasta ahora, no tienen dependencias. Entonces, si hubi&amp;eacute;ramos construido el Hello, world! proyecto con Cargo, solo usar&amp;iacute;a la parte de Cargo que maneja la construcci&amp;oacute;n de su c&amp;oacute;digo. A medida que escriba programas Rust m&amp;aacute;s complejos, agregar&amp;aacute; dependencias y, si comienza un proyecto con Cargo, ser&amp;aacute; mucho m&amp;aacute;s f&amp;aacute;cil agregar dependencias.</target>
        </trans-unit>
        <trans-unit id="cc9fb663ff26b10b3b0480942ea72891d7b9e8a8" translate="yes" xml:space="preserve">
          <source>The single-address property of statics is required.</source>
          <target state="translated">Se requiere la propiedad de una sola dirección de la estática.</target>
        </trans-unit>
        <trans-unit id="019cb91a15aad53bc6628eee08e1df33b769b170" translate="yes" xml:space="preserve">
          <source>The size and offset of fields is determined by the following algorithm.</source>
          <target state="translated">El tamaño y el desplazamiento de los campos está determinado por el siguiente algoritmo.</target>
        </trans-unit>
        <trans-unit id="cd076db2ed4f4f71100b51cbd80768553b1f9904" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una instancia de &lt;code&gt;SocketAddr&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="36d5ae29044e3939345f3681fd2eee4951ec1d94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV4&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una estructura &lt;code&gt;SocketAddrV4&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="aa0a80c41eafe63e764438582cea6579e34fa99a" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV6&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una estructura &lt;code&gt;SocketAddrV6&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="e8de810002bae6a69cc3fd5fc7b805d907b3e5fa" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SystemTime&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una estructura &lt;code&gt;SystemTime&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="5b0dd86b903ec8c3b54b21a61cbefcfccd34c7a3" translate="yes" xml:space="preserve">
          <source>The size of a recursive type must be finite; in other words the recursive fields of the type must be &lt;a href=&quot;types/pointer&quot;&gt;pointer types&lt;/a&gt;.</source>
          <target state="translated">El tama&amp;ntilde;o de un tipo recursivo debe ser finito; en otras palabras, los campos recursivos del tipo deben ser &lt;a href=&quot;types/pointer&quot;&gt;tipos de puntero&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c26f5c42f6a164861e02ed67750e160fcf8f0712" translate="yes" xml:space="preserve">
          <source>The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.</source>
          <target state="translated">El tamaño de un enlace simbólico es la longitud de la ruta que contiene,sin un byte nulo de terminación.</target>
        </trans-unit>
        <trans-unit id="e1eaacf69ef80cbba3a3f01cf2e10bd4a9a5fca5" translate="yes" xml:space="preserve">
          <source>The size of a type in bytes.</source>
          <target state="translated">El tamaño de un tipo en bytes.</target>
        </trans-unit>
        <trans-unit id="96cd8943bd738b362434700faacd7dc900194564" translate="yes" xml:space="preserve">
          <source>The size of a union is the size of its largest field.</source>
          <target state="translated">El tamaño de una unión es el tamaño de su campo más grande.</target>
        </trans-unit>
        <trans-unit id="b7e7e7e0bae0750a49867bf9a72696378b080c09" translate="yes" xml:space="preserve">
          <source>The size of a value has two definitions.</source>
          <target state="translated">El tamaño de un valor tiene dos definiciones.</target>
        </trans-unit>
        <trans-unit id="5e402a67efb4a62fa553a5f1394c869ac08acac0" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Instant&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una estructura &lt;code&gt;Instant&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="ba89d7b73eb9567f0b0c3196e6cf2e84c9f4c35c" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;IpAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una instancia de &lt;code&gt;IpAddr&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="64ef5aa718e0f2a4fb9998a036169d75f54db6df" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv4Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una estructura &lt;code&gt;Ipv4Addr&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="b28d6468d140c4a12bab4e35b4415d244e5f859a" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv6Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">El tama&amp;ntilde;o de una estructura &lt;code&gt;Ipv6Addr&lt;/code&gt; puede variar seg&amp;uacute;n el sistema operativo de destino.</target>
        </trans-unit>
        <trans-unit id="a01d57dab257711e2df9579c72d88d59028c40dc" translate="yes" xml:space="preserve">
          <source>The size of most primitives is given in this table.</source>
          <target state="translated">El tamaño de la mayoría de los primitivos se indica en esta tabla.</target>
        </trans-unit>
        <trans-unit id="5a098a792b06569a6bb6f2b7d98cf8797dcd4ec6" translate="yes" xml:space="preserve">
          <source>The size of the referenced value in bytes.</source>
          <target state="translated">El tamaño del valor de referencia en bytes.</target>
        </trans-unit>
        <trans-unit id="62333b23a5b2b89de3b055144daa334820b9c575" translate="yes" xml:space="preserve">
          <source>The size of this integer type in bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1fbeb1b5be430f1bc9e3a92e1dadba4b4fdb71" translate="yes" xml:space="preserve">
          <source>The size of this primitive is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</source>
          <target state="translated">El tamaño de este primitivo es el número de bytes que se necesitan para referirse a cualquier lugar de la memoria.Por ejemplo,en un objetivo de 32 bits,esto es 4 bytes y en un objetivo de 64 bits,esto es 8 bytes.</target>
        </trans-unit>
        <trans-unit id="eaea58fd5debec4469854dd4c0d7e96ee309fa5f" translate="yes" xml:space="preserve">
          <source>The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e51743ff7cd79535af677e289113dcff07dbe9c" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte at the end of the slice.</source>
          <target state="translated">El segmento utilizado para crear un &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; debe tener uno y solo un byte nulo al final del segmento.</target>
        </trans-unit>
        <trans-unit id="06c3ab06faa47dfc08256f59e9e6b62a827af728" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad56ccc65a97d6c0192795237bde8dc8a187bcc7" translate="yes" xml:space="preserve">
          <source>The slices implement &lt;code&gt;IntoIterator&lt;/code&gt;. The iterator yields references to the slice elements.</source>
          <target state="translated">Los cortes implementan &lt;code&gt;IntoIterator&lt;/code&gt; . El iterador produce referencias a los elementos de corte.</target>
        </trans-unit>
        <trans-unit id="4d54f29cfdc5fb0b14c6bc3d825908235a2d1e62" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type.</source>
          <target state="translated">El valor más pequeño que puede ser representado por este tipo de entero.</target>
        </trans-unit>
        <trans-unit id="2ed21758c259b01204be09a1e5a970a7587f0275" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a50b28fc392edeb96ae6e8bbc1f3f65f1879e9" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab5eaa27a5d1f357d4d2bc91b9af02383caede4" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc283863a8f984dedbdb2f90ee6338a2b682ff86" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8fcd8d47309d686d033e491c707f9a8e4582c1" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124d5af779df7e9ad406378d4ae95baeff0f8e12" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7283dc0e8aef63acf9dd8ecc15410819b62a917" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1d26d88d80abad9936f065a519a8e6dae555c2" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5170dcabff61b3cd439cd574c1475742baecf6" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0709e957f7976c853e280aae68478111e39066d5" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa14915f9b53a3b041d9be135f24e5f469a12ccc" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275bb49ca6506b300934116c83ccd1ff11d81477" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c371b87930b46855075594aef0b191a2dcbb6afc" translate="yes" xml:space="preserve">
          <source>The smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is also not &lt;code&gt;Sync&lt;/code&gt; for the same reasons that it&amp;rsquo;s not &lt;code&gt;Send&lt;/code&gt;. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type (which we talked about in Chapter 15) and the family of related &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; types are not &lt;code&gt;Sync&lt;/code&gt;. The implementation of borrow checking that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does at runtime is not thread-safe. The smart pointer &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; and can be used to share access with multiple threads as you saw in the &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo;Sharing a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; Between Multiple Threads&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">El puntero inteligente &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; tampoco est&amp;aacute; &lt;code&gt;Sync&lt;/code&gt; por las mismas razones que no es &lt;code&gt;Send&lt;/code&gt; . El tipo &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (del que hablamos en el Cap&amp;iacute;tulo 15) y la familia de tipos de &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; relacionados no est&amp;aacute;n &lt;code&gt;Sync&lt;/code&gt; . La implementaci&amp;oacute;n de la comprobaci&amp;oacute;n de pr&amp;eacute;stamos que &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; hace en tiempo de ejecuci&amp;oacute;n no es segura para subprocesos. El puntero inteligente &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; y se puede utilizar para compartir el acceso con varios subprocesos, como vio en la secci&amp;oacute;n &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&quot;Compartir un &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; entre varios subprocesos&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="348ea7c78b50388dc12ad8afa807cfbceb141e14" translate="yes" xml:space="preserve">
          <source>The socket will be closed when the value is dropped.</source>
          <target state="translated">El zócalo se cerrará cuando el valor se caiga.</target>
        </trans-unit>
        <trans-unit id="26c3406d4e79e978c77c7f71fb4706519f7ecd96" translate="yes" xml:space="preserve">
          <source>The solution here is to return the &lt;code&gt;String&lt;/code&gt; directly:</source>
          <target state="translated">La soluci&amp;oacute;n aqu&amp;iacute; es devolver la &lt;code&gt;String&lt;/code&gt; directamente:</target>
        </trans-unit>
        <trans-unit id="b153caaa35f5e55b36f6162bb71df5061ac16716" translate="yes" xml:space="preserve">
          <source>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</source>
          <target state="translated">La solución es elegir un nombre diferente que no entre en conflicto con ninguna caja externa importada en el módulo actual.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
