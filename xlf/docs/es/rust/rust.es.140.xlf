<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d474f38bf85bfc1567b98ee3eb463b107a0ce2" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">En particular, esta funci&amp;oacute;n ignora los par&amp;aacute;metros de la &lt;code&gt;flag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">En particular: las &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt; , los par&amp;aacute;metros de funci&amp;oacute;n, los elementos &lt;a href=&quot;items/constant-items&quot;&gt;constantes&lt;/a&gt; y &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;ticos&lt;/a&gt; deben &lt;code&gt;Sized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Nota 1:El rango de elementos se elimina aunque el iterador no se consuma hasta el final.</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">Nota 1:El rango de elementos se elimina aunque el iterador se consuma sólo parcialmente o no se consuma en absoluto.</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">Nota 1:El primer elemento del iterador siempre será devuelto,independientemente del paso dado.</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">Nota 2: No se especifica cu&amp;aacute;ntos elementos se eliminan de la deque, si el valor de &lt;code&gt;Drain&lt;/code&gt; no se elimina , pero el pr&amp;eacute;stamo que contiene expira (por ejemplo, debido a &lt;code&gt;mem::forget&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">Nota 2: No se especifica cu&amp;aacute;ntos elementos se eliminan del vector si se filtra el valor de &lt;code&gt;Drain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">Nota 2: El momento en el que se extraen los elementos ignorados no es fijo. &lt;code&gt;StepBy&lt;/code&gt; se comporta como la secuencia &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; , pero tambi&amp;eacute;n es libre de comportarse como la secuencia &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; forma en que se usa puede cambiar para algunos iteradores por razones de rendimiento. La segunda forma har&amp;aacute; avanzar el iterador antes y puede consumir m&amp;aacute;s elementos.</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">Note tambi&amp;eacute;n que en el Listado 19-1 y 19-3, creamos punteros sin formato &lt;code&gt;*const i32&lt;/code&gt; y &lt;code&gt;*mut i32&lt;/code&gt; que apuntaban a la misma ubicaci&amp;oacute;n de memoria, donde se almacena &lt;code&gt;num&lt;/code&gt; . Si, en cambio, intent&amp;aacute;ramos crear una referencia inmutable y mutable a &lt;code&gt;num&lt;/code&gt; , el c&amp;oacute;digo no se habr&amp;iacute;a compilado porque las reglas de propiedad de Rust no permiten una referencia mutable al mismo tiempo que cualquier referencia inmutable. Con punteros sin procesar, podemos crear un puntero mutable y un puntero inmutable a la misma ubicaci&amp;oacute;n y cambiar los datos a trav&amp;eacute;s del puntero mutable, creando potencialmente una carrera de datos. &amp;iexcl;Ten cuidado!</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">Tenga en cuenta tambi&amp;eacute;n que en el contexto de este formalismo, el t&amp;eacute;rmino &quot;token&quot; generalmente &lt;em&gt;incluye&lt;/em&gt; NT simples.</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">Sin embargo,note que:</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">Nota sobre el lugar</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">Tenga en cuenta que &amp;amp; Any se limita a probar si un valor es de un tipo concreto espec&amp;iacute;fico y no se puede usar para probar si un tipo implementa un rasgo.</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">Tenga en cuenta que los &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , por ejemplo, se implementan utilizando esta primitiva. De hecho, cuando llame a &lt;code&gt;send&lt;/code&gt; o &lt;code&gt;recv&lt;/code&gt; , que est&amp;aacute;n bloqueando, ceder&amp;aacute;n si el canal no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Tenga en cuenta que &lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; &lt;/a&gt; implementan &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt; implementa &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;(T,)&lt;/code&gt; siempre indica el tipo de un 1-tupla que contiene un elemento de tipo &lt;code&gt;T&lt;/code&gt; . La coma es necesaria para la desambiguaci&amp;oacute;n sint&amp;aacute;ctica.</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;CoerceUnsized&lt;/code&gt; es utilizado principalmente por punteros inteligentes como &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; y &lt;code&gt;Arc&lt;/code&gt; para poder marcar que pueden coaccionar tipos sin tama&amp;ntilde;o a los que apuntan.</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; solo se utiliza en escenarios de un solo subproceso. Cuando analicemos la simultaneidad en el Cap&amp;iacute;tulo 16, cubriremos c&amp;oacute;mo realizar el recuento de referencias en programas multiproceso.</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rhs&lt;/code&gt; es &lt;code&gt;Self&lt;/code&gt; por defecto, pero esto no es obligatorio.</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rhs&lt;/code&gt; es &lt;code&gt;Self&lt;/code&gt; por defecto, pero esto no es obligatorio. Por ejemplo, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; implementa &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; , que permite operaciones de la forma &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rhs&lt;/code&gt; es &lt;code&gt;Self&lt;/code&gt; por defecto, pero esto no es obligatorio. Por ejemplo, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; implementa &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; , que permite operaciones de la forma &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;T&lt;/code&gt; no necesariamente implementa &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , por lo que ni siquiera puede clonar y restablecer &lt;code&gt;self.buf&lt;/code&gt; . Pero &lt;code&gt;replace&lt;/code&gt; se puede usar para disociar el valor original de &lt;code&gt;self.buf&lt;/code&gt; de &lt;code&gt;self&lt;/code&gt; , lo que permite que se devuelva:</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;T&lt;/code&gt; no necesariamente implementa &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , por lo que ni siquiera puede clonar y restablecer &lt;code&gt;self.buf&lt;/code&gt; . Pero &lt;code&gt;take&lt;/code&gt; puede usarse para disociar el valor original de &lt;code&gt;self.buf&lt;/code&gt; de &lt;code&gt;self&lt;/code&gt; , permitiendo que se devuelva:</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23e62c56ad5b9bcbd4370446379ba67e37df78f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;[expr; 0]&lt;/code&gt; is allowed, and produces an empty array. This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so be mindful of side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;drain_filter&lt;/code&gt; tambi&amp;eacute;n le permite mutar cada elemento en el cierre del filtro, independientemente de si elige mantenerlo o eliminarlo.</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;drain_filter&lt;/code&gt; permite mutar todos los elementos del cierre del filtro, independientemente de si elige mantenerlo o eliminarlo.</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;ptr::drop_in_place&lt;/code&gt; ya realiza esta comprobaci&amp;oacute;n, por lo que si su carga de trabajo puede reducirse a una peque&amp;ntilde;a cantidad de llamadas drop_in_place, no es necesario utilizarlo. En particular, tenga en cuenta que puede colocar_en_lugar un segmento, y eso har&amp;aacute; una &amp;uacute;nica verificaci&amp;oacute;n de need_drop para todos los valores.</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">Tenga en cuenta que la &lt;code&gt;query&lt;/code&gt; ahora es una &lt;code&gt;String&lt;/code&gt; lugar de un segmento de cadena, porque llamar a &lt;code&gt;to_lowercase&lt;/code&gt; crea nuevos datos en lugar de hacer referencia a los datos existentes. Digamos que la consulta es &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; , como ejemplo: ese segmento de cadena no contiene una &lt;code&gt;u&lt;/code&gt; o &lt;code&gt;t&lt;/code&gt; min&amp;uacute;scula para que la usemos, as&amp;iacute; que tenemos que asignar una nueva &lt;code&gt;String&lt;/code&gt; contenga &lt;code&gt;&quot;rust&quot;&lt;/code&gt; . Cuando pasamos la &lt;code&gt;query&lt;/code&gt; como argumento al m&amp;eacute;todo &lt;code&gt;contains&lt;/code&gt; ahora, necesitamos agregar un ampersand porque la firma de &lt;code&gt;contains&lt;/code&gt; est&amp;aacute; definida para tomar un segmento de cadena.</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;std::env::args&lt;/code&gt; entrar&amp;aacute; en p&amp;aacute;nico si alg&amp;uacute;n argumento contiene Unicode no v&amp;aacute;lido. Si su programa necesita aceptar argumentos que contengan Unicode no v&amp;aacute;lido, utilice &lt;code&gt;std::env::args_os&lt;/code&gt; en su lugar. Esa funci&amp;oacute;n devuelve un iterador que produce valores &lt;code&gt;OsString&lt;/code&gt; en lugar de valores &lt;code&gt;String&lt;/code&gt; . Hemos elegido usar &lt;code&gt;std::env::args&lt;/code&gt; aqu&amp;iacute; por simplicidad, porque los valores de &lt;code&gt;OsString&lt;/code&gt; difieren seg&amp;uacute;n la plataforma y es m&amp;aacute;s complejo trabajar con ellos que los valores de &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;zip&lt;/code&gt; produce solo cuatro pares; el quinto par te&amp;oacute;rico &lt;code&gt;(5, None)&lt;/code&gt; nunca se produce porque &lt;code&gt;zip&lt;/code&gt; devuelve &lt;code&gt;None&lt;/code&gt; cuando cualquiera de sus iteradores de entrada devuelve &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">Nótese que Rust no tiene una noción de argumentos de funciones opcionales o funciones variadas (excepto su C-FFI).</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">Obsérvese que se hace el &quot;mejor esfuerzo&quot; para asegurar que se ejecuten los destructores para los tipos almacenados en el almacenamiento local de hilos,pero no todas las plataformas pueden garantizar que se ejecuten los destructores para todos los tipos en el almacenamiento local de hilos.Por ejemplo,hay una serie de advertencias conocidas en las que los destructores no se ejecutan:</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">Tenga en cuenta que un &lt;code&gt;()&lt;/code&gt; -returning &lt;code&gt;main&lt;/code&gt; impl&amp;iacute;citamente da como resultado una terminaci&amp;oacute;n exitosa, por lo que no es necesario devolver esto desde &lt;code&gt;main&lt;/code&gt; a menos que tambi&amp;eacute;n est&amp;eacute; devolviendo otros c&amp;oacute;digos posibles.</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">Tenga en cuenta que una captura moverá o tomará prestada una variable,pero en esta situación,el cierre está tomando prestada la variable.Echa un vistazo a http://rustbyexample.com/fn/closures/capture.html para más información sobre la captura.</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">Tenga en cuenta que un comparador es simplemente un &amp;aacute;rbol de fichas. Un &quot;NT simple&quot;, como se mencion&amp;oacute; anteriormente, es un NT metavariable; por tanto, es una no repetici&amp;oacute;n. Por ejemplo, &lt;code&gt;$foo:ty&lt;/code&gt; es un NT simple pero &lt;code&gt;$($foo:ty)+&lt;/code&gt; es un NT complejo.</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">Tenga en cuenta que el alcance de una referencia comienza desde donde se introduce y contin&amp;uacute;a hasta la &amp;uacute;ltima vez que se utiliz&amp;oacute; esa referencia. Por ejemplo, este c&amp;oacute;digo se compilar&amp;aacute; porque el &amp;uacute;ltimo uso de las referencias inmutables ocurre antes de que se introduzca la referencia mutable:</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">Tenga en cuenta que un env&amp;iacute;o exitoso &lt;em&gt;no&lt;/em&gt; garantiza que el receptor vea los datos si hay un b&amp;uacute;fer en este canal. Los elementos se pueden poner en cola en el b&amp;uacute;fer interno para que el receptor los reciba en un momento posterior. Sin embargo, si el tama&amp;ntilde;o del b&amp;uacute;fer es 0, el canal se convierte en un canal de encuentro y garantiza que el receptor ha recibido los datos si esta funci&amp;oacute;n devuelve correctamente.</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">Tenga en cuenta que es posible que algunos tipos no implementen la alineaci&amp;oacute;n. En particular, generalmente no se implementa para el rasgo &lt;code&gt;Debug&lt;/code&gt; . Una buena forma de asegurarse de que se aplique el relleno es formatear su entrada y luego usar esta cadena resultante para rellenar su salida.</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que todos los &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s son v&amp;aacute;lidos &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s, y pueden convertirse a uno con &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Tenga en cuenta que se consumir&amp;aacute;n todos los elementos entre el final y el elemento devuelto, incluido el elemento devuelto. Esto tambi&amp;eacute;n significa que llamar a &lt;code&gt;nth_back(0)&lt;/code&gt; varias veces en el mismo iterador devolver&amp;aacute; diferentes elementos.</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Tenga en cuenta que todos los elementos anteriores, as&amp;iacute; como el elemento devuelto, se consumir&amp;aacute;n del iterador. Eso significa que los elementos anteriores se descartar&amp;aacute;n y tambi&amp;eacute;n que llamar a &lt;code&gt;nth(0)&lt;/code&gt; varias veces en el mismo iterador devolver&amp;aacute; elementos diferentes.</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">Tenga en cuenta que cualquier c&amp;oacute;digo en la primera impresi&amp;oacute;n de &lt;em&gt;The Rust Programming Language&lt;/em&gt; que se compil&amp;oacute; continuar&amp;aacute; compil&amp;aacute;ndose sin &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; en el &lt;em&gt;Cargo.toml&lt;/em&gt; del proyecto , incluso cuando actualice la versi&amp;oacute;n del compilador de Rust que est&amp;aacute; usando. &amp;iexcl;Esas son las garant&amp;iacute;as de compatibilidad con versiones anteriores de Rust en funcionamiento!</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">Tenga en cuenta que cualquier dato sobrante en el buffer interno se pierde.</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">Tenga en cuenta que debido a que esta función nunca regresa,y que termina el proceso,no se ejecutarán los destructores de la pila actual o de cualquier otra pila de hilos.</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">Tenga en cuenta que como esta función nunca regresa,y que termina el proceso,no se ejecutarán los destructores de la pila actual o de cualquier otra pila de hilos.Si se necesita un cierre limpio,se recomienda llamar a esta función sólo en un punto conocido donde no queden más destructores por ejecutar.</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">Tenga en cuenta que debido a que definimos el rasgo &lt;code&gt;Summary&lt;/code&gt; y los tipos &lt;code&gt;NewsArticle&lt;/code&gt; y &lt;code&gt;Tweet&lt;/code&gt; en los mismos &lt;em&gt;lib.rs&lt;/em&gt; en el Listado 10-13, todos est&amp;aacute;n en el mismo alcance. Digamos que este &lt;em&gt;lib.rs&lt;/em&gt; es para una caja que hemos llamado &lt;code&gt;aggregator&lt;/code&gt; y alguien m&amp;aacute;s quiere usar la funcionalidad de nuestra caja para implementar el rasgo &lt;code&gt;Summary&lt;/code&gt; en una estructura definida dentro del alcance de su biblioteca. Primero tendr&amp;iacute;an que llevar el rasgo a su alcance. Lo har&amp;iacute;an especificando &lt;code&gt;use aggregator::Summary;&lt;/code&gt; , lo que les permitir&amp;iacute;a implementar &lt;code&gt;Summary&lt;/code&gt; para su tipo. El &lt;code&gt;Summary&lt;/code&gt; El rasgo tambi&amp;eacute;n deber&amp;iacute;a ser un rasgo p&amp;uacute;blico para que otra caja lo implemente, lo cual se debe a que colocamos la palabra clave &lt;code&gt;pub&lt;/code&gt; antes del &lt;code&gt;trait&lt;/code&gt; en el Listado 10-12.</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">Tenga en cuenta que debido a que hemos utilizado s&amp;oacute;lo un tipo gen&amp;eacute;rico para definir &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; , esta definici&amp;oacute;n dice que el &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct es gen&amp;eacute;rico sobre alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; , y los campos &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; son &lt;em&gt;ambos&lt;/em&gt; el mismo tipo, lo que ese tipo de tal vez. Si creamos una instancia de &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; que tiene valores de diferentes tipos, como en el Listado 10-7, nuestro c&amp;oacute;digo no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="ee83d2a98a726eb4d0819a08ff35a51d203bcc33" translate="yes" xml:space="preserve">
          <source>Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">Tenga en cuenta que soltar un &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; nunca llamar&amp;aacute; al c&amp;oacute;digo de ca&amp;iacute;da de &lt;code&gt;T&lt;/code&gt; .Es su responsabilidad asegurarse de que &lt;code&gt;T&lt;/code&gt; se elimine si se inicializ&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">Tenga en cuenta que debido a la coerci&amp;oacute;n deref de la llamada al m&amp;eacute;todo, &amp;iexcl;simplemente llamar a un m&amp;eacute;todo de rasgo actuar&amp;aacute; como si funcionaran en referencias tan bien como lo hacen en valores propios! Las implementaciones descritas aqu&amp;iacute; est&amp;aacute;n pensadas para contextos gen&amp;eacute;ricos, donde el tipo final &lt;code&gt;T&lt;/code&gt; es un par&amp;aacute;metro de tipo o no es conocido localmente.</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">Tenga en cuenta que las matrices vac&amp;iacute;as &lt;code&gt;[T; 0]&lt;/code&gt; tiene el mismo requisito de alineaci&amp;oacute;n tal como el tipo de elemento &lt;code&gt;T&lt;/code&gt; . Tambi&amp;eacute;n tenga en cuenta que el error se informa de forma conservadora incluso cuando la alineaci&amp;oacute;n del tipo de tama&amp;ntilde;o cero es menor o igual que la alineaci&amp;oacute;n del campo de datos.</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">Tenga en cuenta que los nombres de las variables de entorno no distinguen entre mayúsculas y minúsculas (pero sí entre mayúsculas y minúsculas)en Windows,y entre mayúsculas y minúsculas en todas las demás plataformas.</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si &lt;code&gt;T&lt;/code&gt; tiene tama&amp;ntilde;o &lt;code&gt;0&lt;/code&gt; , el puntero debe ser no NULL y estar correctamente alineado.</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">Tenga en cuenta que incluso si &lt;code&gt;T&lt;/code&gt; tiene un tama&amp;ntilde;o &lt;code&gt;0&lt;/code&gt; , el puntero no debe ser NULL.</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si &lt;code&gt;T&lt;/code&gt; tiene tama&amp;ntilde;o &lt;code&gt;0&lt;/code&gt; , los punteros deben ser no NULL y estar alineados correctamente.</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si el tama&amp;ntilde;o efectivamente copiado ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) es &lt;code&gt;0&lt;/code&gt; , el puntero debe ser no NULL y estar alineado correctamente.</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si el tama&amp;ntilde;o efectivamente copiado ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) es &lt;code&gt;0&lt;/code&gt; , los punteros deben ser no NULL y estar correctamente alineados.</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">Tenga en cuenta que aunque la biblioteca est&amp;aacute;ndar contiene una definici&amp;oacute;n para &lt;code&gt;IpAddr&lt;/code&gt; , a&amp;uacute;n podemos crear y usar nuestra propia definici&amp;oacute;n sin conflicto porque no hemos tra&amp;iacute;do la definici&amp;oacute;n de la biblioteca est&amp;aacute;ndar a nuestro alcance. Hablaremos m&amp;aacute;s sobre c&amp;oacute;mo incorporar los tipos al alcance en el Cap&amp;iacute;tulo 7.</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">Tenga en cuenta que es posible que se agreguen plataformas futuras que tampoco tengan soporte para algunas operaciones at&amp;oacute;micas. El c&amp;oacute;digo de m&amp;aacute;xima portabilidad querr&amp;aacute; tener cuidado con los tipos at&amp;oacute;micos que se utilizan. &lt;code&gt;AtomicUsize&lt;/code&gt; y &lt;code&gt;AtomicIsize&lt;/code&gt; son generalmente los m&amp;aacute;s port&amp;aacute;tiles, pero aun as&amp;iacute; no est&amp;aacute;n disponibles en todas partes. Como referencia, la biblioteca &lt;code&gt;std&lt;/code&gt; requiere atomics del tama&amp;ntilde;o de un puntero, aunque el &lt;code&gt;core&lt;/code&gt; no lo hace.</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que los argumentos gen&amp;eacute;ricos para los constructores de variantes de enumeraci&amp;oacute;n van despu&amp;eacute;s de la variante, no despu&amp;eacute;s de la enumeraci&amp;oacute;n. Por ejemplo, escribir&amp;iacute;a &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; , en lugar de &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">Tenga en cuenta que aqu&amp;iacute; la llamada a &lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; es para mayor claridad: indica que hemos terminado con el valor dado y debe ser destruido.</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">Tenga en cuenta que si &lt;code&gt;Self::Item&lt;/code&gt; es solo &lt;code&gt;PartialOrd&lt;/code&gt; , pero no &lt;code&gt;Ord&lt;/code&gt; , la definici&amp;oacute;n anterior implica que esta funci&amp;oacute;n devuelve &lt;code&gt;false&lt;/code&gt; si dos elementos consecutivos no son comparables.</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">Tenga en cuenta que si &lt;code&gt;from&lt;/code&gt; y &lt;code&gt;to&lt;/code&gt; ambos apuntan al mismo archivo, es probable que esta operaci&amp;oacute;n lo trunque.</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">Tenga en cuenta que si una función toma múltiples argumentos de tipo pero quiere que el compilador infiera algunos de ellos,puede usar marcadores de tipo:</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">Tenga en cuenta que si la &lt;code&gt;static&lt;/code&gt; o &lt;code&gt;const&lt;/code&gt; antes incluyen referencias de funci&amp;oacute;n o cierre, que a su vez incluyen referencias, el compilador probar&amp;aacute; primero las reglas de elisi&amp;oacute;n est&amp;aacute;ndar. Si no puede resolver las duraciones seg&amp;uacute;n sus reglas habituales, se producir&amp;aacute; un error. A modo de ejemplo:</target>
        </trans-unit>
        <trans-unit id="9ef199153d75a42174c42cff6fb7c6c1476957fd" translate="yes" xml:space="preserve">
          <source>Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">Obsérvese que en Rust,las estructuras sólo pueden contener un tipo sin tamaño si el campo que contiene el tipo sin tamaño es el último y único campo de tipo sin tamaño de la estructura.</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que en algunos lenguajes y marcos de prueba, los par&amp;aacute;metros de las funciones que afirman que dos valores son iguales se denominan &lt;code&gt;expected&lt;/code&gt; y &lt;code&gt;actual&lt;/code&gt; , y el orden en el que especificamos los argumentos es importante. Sin embargo, en Rust, se llaman &lt;code&gt;left&lt;/code&gt; y &lt;code&gt;right&lt;/code&gt; , y el orden en el que especificamos el valor que esperamos y el valor que produce el c&amp;oacute;digo bajo prueba no importa. Podr&amp;iacute;amos escribir la aserci&amp;oacute;n en esta prueba como &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; , lo que dar&amp;iacute;a como resultado un mensaje de falla que muestra la &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; y que la &lt;code&gt;left&lt;/code&gt; era &lt;code&gt;5&lt;/code&gt; y la &lt;code&gt;right&lt;/code&gt; era &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">Tenga en cuenta que la introducci&amp;oacute;n de otro &lt;code&gt;struct&lt;/code&gt; solo para tener un lugar para los otros atributos puede tener efectos secundarios no deseados en la representaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">Obsérvese que es imposible vincular las dependencias dinámicas nativas a una biblioteca estática,y en este caso se imprimirán advertencias sobre todas las dependencias dinámicas nativas no vinculadas.</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">Tenga en cuenta que no es posible llamar a la implementaci&amp;oacute;n predeterminada desde una implementaci&amp;oacute;n predominante de ese mismo m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">Obsérvese que la longitud de una corriente puede cambiar con el tiempo (por ejemplo,cuando se añaden datos a un archivo).Por lo tanto,llamar a este método varias veces no necesariamente devuelve la misma longitud cada vez.</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">Tengan en cuenta que negar cualquier número entero positivo se desbordará.</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Tenga en cuenta que no se produce ninguna otra normalizaci&amp;oacute;n; en particular, &lt;code&gt;a/c&lt;/code&gt; y &lt;code&gt;a/b/../c&lt;/code&gt; son distintos, para tener en cuenta la posibilidad de que &lt;code&gt;b&lt;/code&gt; es un enlace simb&amp;oacute;lico (por lo que su padre no es &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que no todas las plataformas mantendr&amp;aacute;n esta actualizaci&amp;oacute;n de campo en los metadatos de un archivo, por ejemplo, Windows tiene una opci&amp;oacute;n para deshabilitar la actualizaci&amp;oacute;n esta vez cuando se accede a los archivos y Linux de manera similar tiene &lt;code&gt;noatime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">Tenga en cuenta que en ninguna parte de esta salida vemos &lt;code&gt;I got the value 4&lt;/code&gt; , que es lo que se imprime cuando se ejecuta la prueba que pasa. Esa salida ha sido capturada. El resultado de la prueba que fall&amp;oacute;, &lt;code&gt;I got the value 8&lt;/code&gt; , aparece en la secci&amp;oacute;n de la salida de resumen de la prueba, que tambi&amp;eacute;n muestra la causa de la falla de la prueba.</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">Tenga en cuenta que en varias llamadas para &lt;code&gt;poll&lt;/code&gt; , solo el &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; del &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; pasado a la llamada m&amp;aacute;s reciente debe programarse para recibir un despertador.</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Tenga en cuenta que no se puede pasar &lt;code&gt;CannotReallocInPlace&lt;/code&gt; a la funci&amp;oacute;n &lt;code&gt;handle_alloc_error&lt;/code&gt; ; Se espera que los clientes puedan recuperarse de &lt;code&gt;grow_in_place&lt;/code&gt; fallas de grow_in_place sin abortar, o recurrir a otro m&amp;eacute;todo de reasignaci&amp;oacute;n antes de recurrir a un aborto.</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Tenga en cuenta que no se puede pasar &lt;code&gt;CannotReallocInPlace&lt;/code&gt; a la funci&amp;oacute;n &lt;code&gt;handle_alloc_error&lt;/code&gt; ; se espera que los clientes puedan recuperarse de &lt;code&gt;shrink_in_place&lt;/code&gt; fallas de sin abortar, o recurrir a otro m&amp;eacute;todo de reasignaci&amp;oacute;n antes de recurrir a un aborto.</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">Obsérvese que los pánicos en el óxido no siempre se implementan por medio del desenrollado,sino que pueden implementarse abortando el proceso.Si se llama a esta función cuando los pánicos se implementan de esta manera,entonces esta función abortará el proceso,no desencadenará un desenrollado.</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">Observe que algunas partes de este bloque están en uso:</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">Tenga en cuenta que anclar y &lt;code&gt;Unpin&lt;/code&gt; solo afectan al tipo &lt;code&gt;P::Target&lt;/code&gt; apuntado, no al tipo de puntero &lt;code&gt;P&lt;/code&gt; en s&amp;iacute; que se envolvi&amp;oacute; en &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; . Por ejemplo, si &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;Unpin&lt;/code&gt; o no, no tiene ning&amp;uacute;n efecto en el comportamiento de &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (aqu&amp;iacute;, &lt;code&gt;T&lt;/code&gt; es el tipo apuntado).</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">Note que la lectura actualiza la rebanada para apuntar a la parte aún no leída.El trozo estará vacío cuando se alcance el EOF.</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">Tenga en cuenta que similar a &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt; , no es un error volver con una lectura corta.</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">Tenga en cuenta que similar a &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; , no es un error devolver una escritura corta.</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">Tenga en cuenta que similar a &lt;code&gt;File::read&lt;/code&gt; , no es un error volver con una lectura corta. Al regresar de una lectura tan corta, el puntero del archivo a&amp;uacute;n se actualiza.</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">Tenga en cuenta que al igual que &lt;code&gt;File::write&lt;/code&gt; , no es un error devolver una escritura corta. Al regresar de una escritura tan corta, el puntero del archivo a&amp;uacute;n se actualiza.</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que algunas plataformas pueden simplemente implementar esto en t&amp;eacute;rminos de &lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">Tenga en cuenta que stdout con frecuencia se almacena en b&amp;uacute;fer de l&amp;iacute;nea de forma predeterminada, por lo que puede ser necesario usar &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt; para garantizar que la salida se emita inmediatamente.</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">Tenga en cuenta que gracias a las garant&amp;iacute;as de seguridad de Rust, el acceso a las variables globales (est&amp;aacute;ticos) requiere &lt;code&gt;unsafe&lt;/code&gt; c&amp;oacute;digo , asumiendo que no usamos ninguna de las primitivas de sincronizaci&amp;oacute;n en este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; los operadores cortocircuitan, es decir, solo eval&amp;uacute;an su segundo operando si contribuye al resultado. Dado que este comportamiento no se puede hacer cumplir por rasgos, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; no se admiten como operadores sobrecargables.</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">Tenga en cuenta que el operador &lt;code&gt;*&lt;/code&gt; se reemplaza con una llamada al m&amp;eacute;todo &lt;code&gt;deref&lt;/code&gt; y luego una llamada al operador &lt;code&gt;*&lt;/code&gt; solo una vez, cada vez que usamos un &lt;code&gt;*&lt;/code&gt; en nuestro c&amp;oacute;digo. Debido a que la sustituci&amp;oacute;n del operador &lt;code&gt;*&lt;/code&gt; no se repite infinitamente, terminamos con datos de tipo &lt;code&gt;i32&lt;/code&gt; , &amp;iexcl;que coincide con el &lt;code&gt;5&lt;/code&gt; en &lt;code&gt;assert_eq!&lt;/code&gt; en el Listado 15-9.</target>
        </trans-unit>
        <trans-unit id="42a41979051d804f1901f27167063da0694efa1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function can be used to ignore these environment variables. Also note that the state of environment variables is cached once the first backtrace is created, so altering &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; at runtime may not actually change how backtraces are captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el iterador &lt;code&gt;FromFn&lt;/code&gt; no hace suposiciones sobre el comportamiento del cierre y, por lo tanto, de manera conservadora no implementa &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; &lt;/a&gt; , ni anula &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; de su valor predeterminado &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">Tenga en cuenta que los tipos &lt;code&gt;PrimaryColor&lt;/code&gt; y &lt;code&gt;SecondaryColor&lt;/code&gt; no aparecen en la p&amp;aacute;gina principal, ni tampoco la funci&amp;oacute;n de &lt;code&gt;mix&lt;/code&gt; . Tenemos que hacer clic en &lt;code&gt;kinds&lt;/code&gt; y &lt;code&gt;utils&lt;/code&gt; para verlos.</target>
        </trans-unit>
        <trans-unit id="8f49c43ce4bf9debfde5b04db98c0212ba6c8e15" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;SOME_PROPERTY&lt;/code&gt; associated constant would not compile, as its type &lt;code&gt;bool&lt;/code&gt; refers to the struct, rather than to the primitive bool type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">Tenga en cuenta que los valores de &lt;code&gt;origin&lt;/code&gt; y &lt;code&gt;black&lt;/code&gt; son de diferentes tipos, porque son instancias de diferentes estructuras de tupla. Cada estructura que defina es de su propio tipo, aunque los campos dentro de la estructura tienen los mismos tipos. Por ejemplo, una funci&amp;oacute;n que toma un par&amp;aacute;metro de tipo &lt;code&gt;Color&lt;/code&gt; no puede tomar un &lt;code&gt;Point&lt;/code&gt; como argumento, aunque ambos tipos se componen de tres valores &lt;code&gt;i32&lt;/code&gt; . De lo contrario, las instancias de estructura de tupla se comportan como tuplas: puede desestructurarlas en sus partes individuales, puede usar un archivo &lt;code&gt;.&lt;/code&gt; seguido del &amp;iacute;ndice para acceder a un valor individual, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">Tenga en cuenta que la funci&amp;oacute;n &lt;code&gt;internal_adder&lt;/code&gt; no est&amp;aacute; marcada como &lt;code&gt;pub&lt;/code&gt; , pero debido a que las pruebas son solo c&amp;oacute;digo de Rust y el m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; es solo otro m&amp;oacute;dulo, puede traer &lt;code&gt;internal_adder&lt;/code&gt; al alcance de una prueba y llamarlo. Si no cree que las funciones privadas deban probarse, no hay nada en Rust que lo obligue a hacerlo.</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">Tenga en cuenta que el &lt;code&gt;mod common;&lt;/code&gt; La declaraci&amp;oacute;n es la misma que la declaraci&amp;oacute;n del m&amp;oacute;dulo que demostramos en el Listado 7-25. Luego, en la funci&amp;oacute;n de prueba, podemos llamar a la funci&amp;oacute;n &lt;code&gt;common::setup()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">Tenga en cuenta que la declaraci&amp;oacute;n &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; en &lt;em&gt;src / lib.rs&lt;/em&gt; tampoco ha cambiado, ni el &lt;code&gt;use&lt;/code&gt; tiene ning&amp;uacute;n impacto en los archivos que se compilan como parte de la caja. La palabra clave &lt;code&gt;mod&lt;/code&gt; declara m&amp;oacute;dulos, y Rust busca en un archivo con el mismo nombre que el m&amp;oacute;dulo el c&amp;oacute;digo que entra en ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">Tenga en cuenta que la sintaxis de Rust considera &lt;code&gt;-1i8&lt;/code&gt; como una aplicaci&amp;oacute;n del &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;operador unario menos&lt;/a&gt; a un literal entero &lt;code&gt;1i8&lt;/code&gt; , en lugar de un solo literal entero.</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">Tenga en cuenta que el asignador puede dar a la colecci&amp;oacute;n m&amp;aacute;s espacio del que solicita. Por lo tanto, no se puede confiar en que la capacidad sea precisamente m&amp;iacute;nima. Prefiera &lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; si se esperan inserciones futuras.</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">Tenga en cuenta que el asignador puede dar a la colecci&amp;oacute;n m&amp;aacute;s espacio del que solicita. Por lo tanto, no se puede confiar en que la capacidad sea precisamente m&amp;iacute;nima. Prefiera &lt;code&gt;reserve&lt;/code&gt; si se esperan inserciones futuras.</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">Tenga en cuenta que el asignador puede dar a la colección más espacio del que solicita.Por lo tanto,no se puede confiar en que la capacidad sea precisamente mínima.Prefiera la reserva si se esperan futuras inserciones.</target>
        </trans-unit>
        <trans-unit id="08c862951a6a3b03e0330454b0efc29b2b754947" translate="yes" xml:space="preserve">
          <source>Note that the argument is not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0769350c5d5d78015e993d43a239511a252097" translate="yes" xml:space="preserve">
          <source>Note that the arguments are not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">Nótese que se hace el mejor esfuerzo para asegurar que el tiempo esperado se mide con un reloj monótono,y que no se ve afectado por los cambios realizados en el tiempo del sistema.</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">Tenga en cuenta que se hace el mejor esfuerzo para garantizar que el tiempo esperado se mida con un reloj mon&amp;oacute;tono y no se vea afectado por los cambios realizados en la hora del sistema. Esta funci&amp;oacute;n es susceptible de reactivaciones falsas. Las variables de condici&amp;oacute;n normalmente tienen un predicado booleano asociado, y el predicado siempre debe ser verificado cada vez que esta funci&amp;oacute;n regresa para proteger contra reactivaciones esp&amp;uacute;reas. Adem&amp;aacute;s, normalmente es deseable que el tiempo de espera no exceda cierta duraci&amp;oacute;n a pesar de los despertares espurios, por lo que la duraci&amp;oacute;n del sue&amp;ntilde;o se reduce por la cantidad de sue&amp;ntilde;o. Alternativamente, use el m&amp;eacute;todo &lt;code&gt;wait_timeout_until&lt;/code&gt; para esperar hasta que se cumpla una condici&amp;oacute;n con un tiempo de espera total independientemente de las vigilias espurias.</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">Tenga en cuenta que la capacidad del &lt;code&gt;self&lt;/code&gt; no cambia.</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">Tenga en cuenta que toda la instancia debe ser mutable; Rust no nos permite marcar solo ciertos campos como mutables. Como con cualquier expresi&amp;oacute;n, podemos construir una nueva instancia de la estructura como la &amp;uacute;ltima expresi&amp;oacute;n en el cuerpo de la funci&amp;oacute;n para devolver impl&amp;iacute;citamente esa nueva instancia.</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">Tenga en cuenta que el error aqu&amp;iacute; est&amp;aacute; en la definici&amp;oacute;n de la funci&amp;oacute;n gen&amp;eacute;rica: aunque solo la llamamos con un par&amp;aacute;metro que implementa &lt;code&gt;Debug&lt;/code&gt; , el compilador a&amp;uacute;n rechaza la funci&amp;oacute;n: debe funcionar con todos los tipos de entrada posibles. Para poder compilar este ejemplo, necesitamos restringir el tipo gen&amp;eacute;rico que estamos aceptando:</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">Tenga en cuenta que los resultados ampliados de las fichas de entrada pueden cambiar en el futuro.Debe tener cuidado si confía en la salida.</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el objeto m&amp;aacute;s interno establece el l&amp;iacute;mite, por lo que &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; sigue siendo &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">Observe que la &quot;i&quot; minúscula punteada es la misma que la del latín.Por lo tanto:</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">Tenga en cuenta que la macro est&amp;aacute; destinada a ser una herramienta de depuraci&amp;oacute;n y, por lo tanto, debe evitar utilizarla en el control de versiones durante per&amp;iacute;odos m&amp;aacute;s prolongados. Los casos de uso que involucran resultados de depuraci&amp;oacute;n que deber&amp;iacute;an agregarse al control de versiones son mejor atendidos por macros como &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;de la caja de &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">Tenga en cuenta que la salida de las pruebas y los resultados de las pruebas est&amp;aacute;n intercalados; la raz&amp;oacute;n es que las pruebas se est&amp;aacute;n ejecutando en paralelo, como hablamos en la secci&amp;oacute;n anterior. Intente usar la &lt;code&gt;--test-threads=1&lt;/code&gt; y la &lt;code&gt;--nocapture&lt;/code&gt; , &amp;iexcl;y vea c&amp;oacute;mo se ve la salida entonces!</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">Tenga en cuenta que el valor del puntero puede representar potencialmente un puntero v&amp;aacute;lido a una &lt;code&gt;T&lt;/code&gt; , lo que significa que no debe utilizarse como un valor centinela &quot;a&amp;uacute;n no inicializado&quot;. Los tipos que asignan perezosamente deben realizar un seguimiento de la inicializaci&amp;oacute;n por otros medios.</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">Tenga en cuenta que el tama&amp;ntilde;o de la pila del hilo principal &lt;em&gt;no lo&lt;/em&gt; determina Rust.</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">Tenga en cuenta que la biblioteca est&amp;aacute;ndar ( &lt;code&gt;std&lt;/code&gt; ) tambi&amp;eacute;n es una caja externa a nuestro paquete. Debido a que la biblioteca est&amp;aacute;ndar se env&amp;iacute;a con el lenguaje Rust, no necesitamos cambiar &lt;em&gt;Cargo.toml&lt;/em&gt; para incluir &lt;code&gt;std&lt;/code&gt; . Pero necesitamos referirnos a &amp;eacute;l con &lt;code&gt;use&lt;/code&gt; para traer elementos desde all&amp;iacute; al alcance de nuestro paquete. Por ejemplo, con &lt;code&gt;HashMap&lt;/code&gt; usar&amp;iacute;amos esta l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">Obsérvese que los rasgos AsRef y AsMut proporcionan métodos similares para tipos que pueden no ser conjuntos de tamaño fijo.Los implementadores deberían preferir esos rasgos en su lugar.</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el tipo de &lt;code&gt;v&lt;/code&gt; ahora se puede inferir del tipo de &lt;code&gt;temp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">Tenga en cuenta que el iterador subyacente todav&amp;iacute;a est&amp;aacute; avanzado cuando se llama a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; por primera vez: para recuperar el siguiente elemento, se llama a &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; en el iterador subyacente, por lo tanto, cualquier efecto secundario (es decir, cualquier cosa que no sea obtener el siguiente valor) del &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; ocurrir&amp;aacute; el m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que la utilidad del valor devuelto requiere que la &lt;code&gt;align&lt;/code&gt; sea ​​menor o igual que la alineaci&amp;oacute;n de la direcci&amp;oacute;n inicial para todo el bloque de memoria asignado. Una forma de satisfacer esta restricci&amp;oacute;n es asegurarse de que &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que las variantes de la enumeraci&amp;oacute;n tienen un espacio de nombres debajo de su identificador, y usamos dos puntos dobles para separar los dos. La raz&amp;oacute;n por la que esto es &amp;uacute;til es que ahora ambos valores &lt;code&gt;IpAddrKind::V4&lt;/code&gt; e &lt;code&gt;IpAddrKind::V6&lt;/code&gt; son del mismo tipo: &lt;code&gt;IpAddrKind&lt;/code&gt; . Entonces podemos, por ejemplo, definir una funci&amp;oacute;n que tome cualquier &lt;code&gt;IpAddrKind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">Tenga en cuenta que existe una sutil diferencia entre usar solo &lt;code&gt;_&lt;/code&gt; y usar un nombre que comience con un gui&amp;oacute;n bajo. La sintaxis &lt;code&gt;_x&lt;/code&gt; a&amp;uacute;n vincula el valor a la variable, mientras que &lt;code&gt;_&lt;/code&gt; no vincula en absoluto. Para mostrar un caso en el que esta distinci&amp;oacute;n es importante, el Listado 18-21 nos proporcionar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">Tenga en cuenta que no hay garantía de que el archivo se elimine inmediatamente (por ejemplo,dependiendo de la plataforma,otros descriptores de archivos abiertos pueden impedir la eliminación inmediata).</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">Tenga en cuenta que puede haber m&amp;aacute;s de un &lt;code&gt;Reject&lt;/code&gt; entre dos &lt;code&gt;Match&lt;/code&gt; , no es necesario que se combinen en una sola.</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">Tenga en cuenta que estas salidas son apilables en el sentido de que si se especifican varias, el compilador producir&amp;aacute; cada forma de salida a la vez sin tener que volver a compilar. Sin embargo, esto solo se aplica a las salidas especificadas por el mismo m&amp;eacute;todo. Si solo se especifican los atributos &lt;code&gt;crate_type&lt;/code&gt; , entonces se construir&amp;aacute;n todos, pero si se especifican uno o m&amp;aacute;s &lt;code&gt;--crate-type&lt;/code&gt; l&amp;iacute;nea de comando --crate-type , solo se construir&amp;aacute;n esas salidas.</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que estos requisitos significan que el rasgo en s&amp;iacute; debe implementarse de manera sim&amp;eacute;trica y transitiva: si &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; y &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; entonces &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que estos requisitos significan que el rasgo en s&amp;iacute; debe implementarse de forma sim&amp;eacute;trica y transitiva: si &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; y &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; entonces &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que esta declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; significa que &lt;code&gt;expensive_closure&lt;/code&gt; contiene la &lt;em&gt;definici&amp;oacute;n&lt;/em&gt; de funci&amp;oacute;n an&amp;oacute;nima, no el &lt;em&gt;valor resultante&lt;/em&gt; de llamar a la funci&amp;oacute;n an&amp;oacute;nima. Recuerde que estamos usando un cierre porque queremos definir el c&amp;oacute;digo para llamar en un punto, almacenar ese c&amp;oacute;digo y llamarlo en un punto posterior; el c&amp;oacute;digo que queremos llamar ahora est&amp;aacute; almacenado en &lt;code&gt;expensive_closure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">Tenga en cuenta que este enfoque necesita una referencia a S con vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; . Nada m&amp;aacute;s corto que &lt;code&gt;'a&lt;/code&gt; will ser&amp;aacute; suficiente: una vida m&amp;aacute;s corta implicar&amp;iacute;a que despu&amp;eacute;s de que la &lt;code&gt;demo&lt;/code&gt; straci&amp;oacute;n termine de ejecutarse, algo m&amp;aacute;s (&amp;iexcl;como el destructor!) Podr&amp;iacute;a acceder a los &lt;code&gt;s.data&lt;/code&gt; despu&amp;eacute;s del final de esa vida m&amp;aacute;s corta, lo que nuevamente violar&amp;iacute;a la exclusiva de &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow acceso.</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">Tenga en cuenta que esto &lt;strong&gt;no&lt;/strong&gt; devuelve el n&amp;uacute;mero de bytes en la cadena en forma de cadena del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">Tenga en cuenta que esto no mueve &lt;code&gt;v&lt;/code&gt; (a diferencia de &lt;code&gt;transmute&lt;/code&gt; ), y puede necesitar una llamada a &lt;code&gt;mem::forget(v)&lt;/code&gt; en caso de que quiera evitar que se llamen a los destructores.</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">Tenga en cuenta que este ejemplo usa &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; y no &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; s son para escenarios de un solo subproceso. Considere usar &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; o &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; si necesita mutabilidad compartida en una situaci&amp;oacute;n de m&amp;uacute;ltiples subprocesos.</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">Tenga en cuenta que este ejemplo no se compilar&amp;aacute; todav&amp;iacute;a; explicaremos por qu&amp;eacute; en un momento.</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">Tenga en cuenta que esta funci&amp;oacute;n &lt;strong&gt;puede no detectar todos los p&amp;aacute;nicos&lt;/strong&gt; en Rust. Un p&amp;aacute;nico en Rust no siempre se implementa mediante el desenrollado, pero tambi&amp;eacute;n se puede implementar abortando el proceso. Esta funci&amp;oacute;n &lt;em&gt;solo&lt;/em&gt; detecta los p&amp;aacute;nicos que se relajan, no los que abortan el proceso.</target>
        </trans-unit>
        <trans-unit id="d3651367d7bc20ea65e217082fe9e78b8f819776" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f32&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a1415dd489b9fd2f261b68de74159561b45e0" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f64&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">Tenga en cuenta que esta funci&amp;oacute;n es distinta de &lt;code&gt;as&lt;/code&gt; fundici&amp;oacute;n, que los intentos de preservar la &lt;em&gt;num&amp;eacute;rico&lt;/em&gt; valor, y no el valor bit a bit.</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">Tenga en cuenta que esta funci&amp;oacute;n es la misma que &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; er,&lt;/a&gt; excepto que est&amp;aacute; especializada para trabajar con sectores. Si Rust se especializa, es probable que esta funci&amp;oacute;n quede obsoleta (pero a&amp;uacute;n est&amp;eacute; disponible).</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">Tenga en cuenta que esta función es susceptible de despertar espurios.Las variables de condición normalmente tienen asociado un predicado booleano,y el predicado siempre debe ser comprobado cada vez que esta función vuelve para protegerse contra despertares espurios.</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">Tenga en cuenta que esta función puede bloquear el hilo actual mientras se realiza la resolución.</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">Tenga en cuenta que esto &lt;em&gt;tambi&amp;eacute;n&lt;/em&gt; es diferente de Windows-1252, tambi&amp;eacute;n conocido como p&amp;aacute;gina de c&amp;oacute;digos 1252, que es un superconjunto ISO / IEC 8859-1 que asigna algunos espacios en blanco (&amp;iexcl;no todos!) A la puntuaci&amp;oacute;n y varios caracteres latinos.</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Tenga en cuenta que esto &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que rotar a la izquierda; el RHS de un desplazamiento de envoltura a la izquierda est&amp;aacute; restringido al rango del tipo, en lugar de que los bits desplazados fuera del LHS se devuelvan al otro extremo. Todos los tipos de enteros primitivos implementan una funci&amp;oacute;n &lt;code&gt;rotate_left&lt;/code&gt; , que puede ser lo que usted desee.</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Tenga en cuenta que esto &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que rotar a la derecha; el RHS de un desplazamiento a la derecha de envoltura est&amp;aacute; restringido al rango del tipo, en lugar de que los bits desplazados fuera del LHS se devuelvan al otro extremo. Todos los tipos primitivos de enteros implementan una funci&amp;oacute;n &lt;code&gt;rotate_right&lt;/code&gt; , que puede ser lo que quieras.</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">Obsérvese que esto es diferente de la norma ISO/CEI 8859-1,también conocida como ISO 8859-1 (con un guión menos),que deja algunos &quot;espacios en blanco&quot;,valores de bytes que no se asignan a ningún carácter.La ISO-8859-1 (la de la IANA)los asigna a los códigos de control C0 y C1.</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">Tenga en cuenta que esto aún no está totalmente respaldado.</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">Tenga en cuenta que esta lista puede ser modificada con el tiempo a medida que se hagan las aclaraciones en el futuro.</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">Tenga en cuenta que esto puede no tener ningún efecto en los enchufes IPv6.</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que este m&amp;eacute;todo altera el contenido del archivo subyacente, aunque toma &lt;code&gt;&amp;amp;self&lt;/code&gt; lugar de &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que este m&amp;eacute;todo altera los permisos del archivo subyacente, aunque toma &lt;code&gt;&amp;amp;self&lt;/code&gt; lugar de &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">Tenga en cuenta que este m&amp;eacute;todo no agrega ning&amp;uacute;n relleno al tama&amp;ntilde;o general, independientemente de si el dise&amp;ntilde;o devuelto tiene una alineaci&amp;oacute;n diferente. En otras palabras, si &lt;code&gt;K&lt;/code&gt; tiene el tama&amp;ntilde;o 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; seguir&amp;aacute; &lt;em&gt;teniendo el&lt;/em&gt; tama&amp;ntilde;o 16.</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">Obsérvese que este método no tiene ningún efecto sobre la capacidad asignada de la cadena</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">Obsérvese que este método no tiene ningún efecto sobre la capacidad asignada del vector.</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">Tenga en cuenta que esta estructura &lt;strong&gt;no&lt;/strong&gt; es &lt;code&gt;repr(C)&lt;/code&gt; y no se recomienda colocarla en las firmas de las funciones de FFI. En cambio, los envoltorios seguros de funciones FFI pueden aprovechar el constructor inseguro &lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; &lt;/a&gt; para proporcionar una interfaz segura a otros consumidores.</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">Tenga en cuenta que esta técnica también puede ser utilizada en los brazos de una expresión de partido:</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">Tenga en cuenta que esto reducirá cualquier exceso de capacidad.</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;wait&lt;/code&gt; , esta funci&amp;oacute;n no intentar&amp;aacute; eliminar stdin.</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de las expresiones de matriz, esta sintaxis admite todos los elementos que implementan &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; y el n&amp;uacute;mero de elementos no tiene que ser una constante.</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">Obsérvese que los tipos sin tamaño tienen muchos posibles punteros nulos,ya que sólo se considera el puntero de datos en bruto,no su longitud,vtable,etc.Por lo tanto,dos punteros que son nulos pueden no compararse igual entre sí.</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">Tenga en cuenta que, en el futuro, puede que no sea necesario utilizar el &lt;code&gt;self&lt;/code&gt; de esta forma; es una inconsistencia en el lenguaje que los desarrolladores de Rust est&amp;aacute;n tratando de eliminar.</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">Tenga en cuenta que el uso del &lt;code&gt;type&lt;/code&gt; palabra clave no funciona aqu&amp;iacute; porque &lt;code&gt;type&lt;/code&gt; solo introduce un alias de tipo:</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">Obsérvese que las variantes sin un discriminante especificado manualmente se numeran de arriba a abajo empezando por el 0,por lo que pueden producirse choques con variantes aparentemente no relacionadas.</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">Tenga en cuenta que agregamos una anotaci&amp;oacute;n de tipo aqu&amp;iacute;. Debido a que no estamos insertando ning&amp;uacute;n valor en este vector, Rust no sabe qu&amp;eacute; tipo de elementos pretendemos almacenar. &amp;Eacute;ste es un punto importante. Los vectores se implementan usando gen&amp;eacute;ricos; cubriremos c&amp;oacute;mo usar gen&amp;eacute;ricos con sus propios tipos en el Cap&amp;iacute;tulo 10. Por ahora, sepa que el tipo &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; proporcionado por la biblioteca est&amp;aacute;ndar puede contener cualquier tipo, y cuando un vector espec&amp;iacute;fico contiene un tipo espec&amp;iacute;fico, el tipo es especificado entre par&amp;eacute;ntesis angulares. En el Listado 8-1, le hemos dicho a Rust que &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; en &lt;code&gt;v&lt;/code&gt; contendr&amp;aacute; elementos del tipo &lt;code&gt;i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">Tenga en cuenta que agregamos el campo &lt;code&gt;case_sensitive&lt;/code&gt; que contiene un booleano. Luego, necesitamos la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; para verificar el valor del campo &lt;code&gt;case_sensitive&lt;/code&gt; y usarlo para decidir si llamar a la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; o la funci&amp;oacute;n &lt;code&gt;search_case_insensitive&lt;/code&gt; , como se muestra en el Listado 12-22. Tenga en cuenta que esto todav&amp;iacute;a no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">Tenga en cuenta que no necesitamos marcar la funci&amp;oacute;n &lt;code&gt;split_at_mut&lt;/code&gt; resultante como &lt;code&gt;unsafe&lt;/code&gt; , y podemos llamar a esta funci&amp;oacute;n desde Safe Rust. Hemos creado una abstracci&amp;oacute;n segura del c&amp;oacute;digo inseguro con una implementaci&amp;oacute;n de la funci&amp;oacute;n que usa c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; de una manera segura, porque crea solo punteros v&amp;aacute;lidos a partir de los datos a los que tiene acceso esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">Tenga en cuenta que tenemos que declarar &lt;code&gt;T&lt;/code&gt; justo despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; para que podamos usarlo para especificar que estamos implementando m&amp;eacute;todos en el tipo &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; . Declarando &lt;code&gt;T&lt;/code&gt; como un tipo gen&amp;eacute;rico despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; , Rust puede identificar que el tipo entre par&amp;eacute;ntesis angulares en &lt;code&gt;Point&lt;/code&gt; es un tipo gen&amp;eacute;rico en lugar de un tipo concreto.</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que debemos utilizar la sintaxis completa de la que hablamos anteriormente en la secci&amp;oacute;n &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&quot;Caracter&amp;iacute;sticas avanzadas&quot;&lt;/a&gt; porque hay varias funciones disponibles llamadas &lt;code&gt;to_string&lt;/code&gt; . Aqu&amp;iacute;, estamos usando la funci&amp;oacute;n &lt;code&gt;to_string&lt;/code&gt; definida en el rasgo &lt;code&gt;ToString&lt;/code&gt; , que la biblioteca est&amp;aacute;ndar ha implementado para cualquier tipo que implemente &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">Tenga en cuenta que necesitamos anotaciones de por vida en este m&amp;eacute;todo, como discutimos en el Cap&amp;iacute;tulo 10. Tomamos una referencia a una &lt;code&gt;post&lt;/code&gt; como argumento y devolvemos una referencia a parte de esa &lt;code&gt;post&lt;/code&gt; , por lo que la vida &amp;uacute;til de la referencia devuelta est&amp;aacute; relacionada con la vida de la &lt;code&gt;post&lt;/code&gt; argumento posterior .</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">Tenga en cuenta que primero debemos &lt;code&gt;use&lt;/code&gt; el &lt;code&gt;HashMap&lt;/code&gt; de la parte de colecciones de la biblioteca est&amp;aacute;ndar. De nuestras tres colecciones comunes, esta es la que se usa con menos frecuencia, por lo que no se incluye en las funciones incluidas en el alcance autom&amp;aacute;ticamente en el preludio. Los mapas hash tambi&amp;eacute;n tienen menos soporte de la biblioteca est&amp;aacute;ndar; no hay una macro incorporada para construirlos, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Tenga en cuenta que necesit&amp;aacute;bamos &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; en el lado izquierdo. Esto se debe a que podr&amp;iacute;amos recopilar, por ejemplo, en un &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; lugar:</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">Tenga en cuenta que necesit&amp;aacute;bamos hacer &lt;code&gt;v1_iter&lt;/code&gt; mutable: llamar al &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo en un iterador cambia el estado interno que el iterador usa para realizar un seguimiento de d&amp;oacute;nde est&amp;aacute; en la secuencia. En otras palabras, este c&amp;oacute;digo &lt;em&gt;consume&lt;/em&gt; o &lt;em&gt;agota&lt;/em&gt; el iterador. Cada llamada al &lt;code&gt;next&lt;/code&gt; consume un elemento del iterador. No necesit&amp;aacute;bamos hacer &lt;code&gt;v1_iter&lt;/code&gt; mutable cuando usamos un bucle &lt;code&gt;for&lt;/code&gt; porque el bucle tom&amp;oacute; posesi&amp;oacute;n de &lt;code&gt;v1_iter&lt;/code&gt; y lo hizo mutable detr&amp;aacute;s de escena.</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">Tenga en cuenta que queremos que la funci&amp;oacute;n tome segmentos de cadena, que son referencias, porque no queremos que la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; se apropie de sus par&amp;aacute;metros. Queremos permitir que la funci&amp;oacute;n acepte porciones de una &lt;code&gt;String&lt;/code&gt; (el tipo almacenado en la variable &lt;code&gt;string1&lt;/code&gt; ) as&amp;iacute; como literales de cadena (que es lo que contiene la variable &lt;code&gt;string2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">Tenga en cuenta que hemos agregado una nueva l&amp;iacute;nea dentro del m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; : &lt;code&gt;use super::*;&lt;/code&gt; . El m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; es un m&amp;oacute;dulo regular que sigue las reglas de visibilidad habituales que cubrimos en el Cap&amp;iacute;tulo 7 en la secci&amp;oacute;n &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;M&amp;oacute;dulos como l&amp;iacute;mite de privacidad&amp;rdquo;&lt;/a&gt; . Debido a que el m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; es un m&amp;oacute;dulo interno, necesitamos llevar el c&amp;oacute;digo bajo prueba en el m&amp;oacute;dulo externo al alcance del m&amp;oacute;dulo interno. Usamos un glob aqu&amp;iacute; para que cualquier cosa que definamos en el m&amp;oacute;dulo externo est&amp;eacute; disponible para este m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">Tenga en cuenta que tambi&amp;eacute;n hemos editado el &lt;code&gt;contents&lt;/code&gt; la prueba anterior . Hemos agregado una nueva l&amp;iacute;nea con el texto &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; utilizando una D may&amp;uacute;scula que no deber&amp;iacute;a coincidir con la consulta &lt;code&gt;&quot;duct&quot;&lt;/code&gt; cuando estamos buscando de manera sensible a may&amp;uacute;sculas y min&amp;uacute;sculas. Cambiar la prueba anterior de esta manera ayuda a garantizar que no rompamos accidentalmente la funcionalidad de b&amp;uacute;squeda que distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas que ya hemos implementado. Esta prueba deber&amp;iacute;a pasar ahora y deber&amp;iacute;a seguir haci&amp;eacute;ndolo mientras trabajamos en la b&amp;uacute;squeda que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que cuando se producen v&amp;iacute;nculos, &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; generalmente ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; , y &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; generalmente ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Tenga en cuenta que,aunque el acceso simultáneo a las variables del entorno es seguro en Rust,algunas plataformas sólo exponen APIs inherentemente inseguras y no seguras para inspeccionar el entorno.Como resultado,es necesario tener un cuidado especial al auditar las llamadas a funciones FFI externas no seguras para garantizar que cualquier acceso al entorno externo esté correctamente sincronizado con los accesos en Rust.</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">Tenga en cuenta que aunque mutar o aliasar de forma mutante el contenido de un &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute; bien (siempre que aplique los invariantes de alguna otra manera), a&amp;uacute;n es un comportamiento indefinido tener m&amp;uacute;ltiples &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; alias de .</target>
        </trans-unit>
        <trans-unit id="f5bec177fd61b6b3b97ae7f2a117594bad43deaa" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a &lt;em&gt;safe&lt;/em&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">Tenga en cuenta que con esta función,el nuevo hilo se detendrá cuando el hilo principal termine,tanto si ha terminado de correr como si no.La salida de este programa puede ser un poco diferente cada vez,pero tendrá un aspecto similar al siguiente:</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">Note que la escritura actualiza la rebanada para señalar la parte aún no escrita.El trozo estará vacío cuando se haya sobrescrito completamente.</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">Tenga en cuenta que no puede utilizar el &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; operador&lt;/a&gt; en funciones que no devuelven un &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; . En su lugar, puede llamar a &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt; o hacer &lt;code&gt;match&lt;/code&gt; el valor de retorno para detectar cualquier posible error:</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">Tenga en cuenta que, aunque los m&amp;eacute;todos de lectura y escritura requieren un &lt;code&gt;&amp;amp;mut File&lt;/code&gt; , debido a las interfaces de &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , el titular de un &lt;code&gt;&amp;amp;File&lt;/code&gt; a&amp;uacute;n puede modificar el archivo, ya sea mediante m&amp;eacute;todos que toman &lt;code&gt;&amp;amp;File&lt;/code&gt; o recuperando el objeto del sistema operativo subyacente y modificando el archivo. de esa manera. Adem&amp;aacute;s, muchos sistemas operativos permiten la modificaci&amp;oacute;n simult&amp;aacute;nea de archivos mediante diferentes procesos. Evite asumir que tener un &lt;code&gt;&amp;amp;File&lt;/code&gt; significa que el archivo no cambiar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">Tenga en cuenta que, debido a que &lt;code&gt;$crate&lt;/code&gt; refiere a la caja actual, debe usarse con una ruta de m&amp;oacute;dulo completamente calificada cuando se refiere a elementos que no son macro:</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">Tenga en cuenta que, al igual que la enumeraci&amp;oacute;n &lt;code&gt;Option&lt;/code&gt; , la enumeraci&amp;oacute;n &lt;code&gt;Result&lt;/code&gt; y sus variantes se han incluido en el alcance del preludio, por lo que no es necesario especificar &lt;code&gt;Result::&lt;/code&gt; antes de las variantes &lt;code&gt;Ok&lt;/code&gt; y &lt;code&gt;Err&lt;/code&gt; en los brazos de &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que esto &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;puede cambiar en el futuro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;repeat&lt;/code&gt; , &lt;code&gt;repeat_packed&lt;/code&gt; no garantiza que las instancias repetidas de &lt;code&gt;self&lt;/code&gt; est&amp;eacute;n correctamente alineadas, incluso si una instancia determinada de &lt;code&gt;self&lt;/code&gt; est&amp;aacute; correctamente alineada. En otras palabras, si el dise&amp;ntilde;o devuelto por &lt;code&gt;repeat_packed&lt;/code&gt; se usa para asignar una matriz, no se garantiza que todos los elementos de la matriz est&amp;eacute;n alineados correctamente.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Fíjese en eso:</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta la documentaci&amp;oacute;n de las primitivas &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; (tambi&amp;eacute;n llamado 'segmento'). Muchas llamadas a m&amp;eacute;todos en &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; son en realidad llamadas a m&amp;eacute;todos en &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; respectivamente, a trav&amp;eacute;s de &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;coacciones deref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">Nota para los ejecutores</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">Nota para los implementadores: si esto devuelve &lt;code&gt;Ok(ptr)&lt;/code&gt; , entonces &lt;code&gt;ptr&lt;/code&gt; debe considerarse &quot;actualmente asignado&quot; y debe ser una entrada aceptable para m&amp;eacute;todos como &lt;code&gt;realloc&lt;/code&gt; o &lt;code&gt;dealloc&lt;/code&gt; , &lt;em&gt;incluso si &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; es un tipo de tama&amp;ntilde;o cero. En otras palabras, si su implementaci&amp;oacute;n de &lt;code&gt;Alloc&lt;/code&gt; anula este m&amp;eacute;todo de una manera que puede devolver un &lt;code&gt;ptr&lt;/code&gt; de tama&amp;ntilde;o cero , entonces todos los m&amp;eacute;todos de reasignaci&amp;oacute;n y desasignaci&amp;oacute;n deben anularse de manera similar para aceptar tales valores como entrada.</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta dos detalles aqu&amp;iacute;. Primero, usamos el valor de &amp;iacute;ndice de &lt;code&gt;2&lt;/code&gt; para obtener el tercer elemento: los vectores est&amp;aacute;n indexados por n&amp;uacute;mero, comenzando en cero. En segundo lugar, las dos formas de obtener el tercer elemento son usando &lt;code&gt;&amp;amp;&lt;/code&gt; y &lt;code&gt;[]&lt;/code&gt; , que nos da una referencia, o usando el m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; con el &amp;iacute;ndice pasado como argumento, lo que nos da una &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;OsString&lt;/code&gt; y &lt;code&gt;OsStr&lt;/code&gt; internamente no contienen necesariamente cadenas en la forma nativa de la plataforma; Mientras que en Unix, las cadenas se almacenan como una secuencia de valores de 8 bits, en Windows, donde las cadenas se basan en valores de 16 bits como se acaba de discutir, las cadenas tambi&amp;eacute;n se almacenan en realidad como una secuencia de valores de 8 bits, codificados en un formato menos variante estricta de UTF-8. Es &amp;uacute;til comprender esto cuando se manejan valores de capacidad y longitud.</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">Sin embargo, tenga en cuenta que no se garantiza que los instantes sean &lt;strong&gt;estables&lt;/strong&gt; . En otras palabras, cada tic del reloj subyacente puede no tener la misma duraci&amp;oacute;n (por ejemplo, algunos segundos pueden ser m&amp;aacute;s largos que otros). Un instante puede saltar hacia adelante o experimentar una dilataci&amp;oacute;n del tiempo (ralentizar o acelerar), pero nunca retroceder&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">Sin embargo, tenga en cuenta que los elementos con el mismo nombre est&amp;aacute;n permitidos para bloques &lt;code&gt;impl&lt;/code&gt; inherentes que no se superponen:</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">Sin embargo, tenga en cuenta que este no es un rasgo inseguro, por lo que no hay un contrato sucinto que este rasgo proporcione. En su lugar, tiene la intenci&amp;oacute;n de ser m&amp;aacute;s como un &quot;golpe de velocidad&quot; para alertar a los usuarios de &lt;code&gt;catch_unwind&lt;/code&gt; que se pueden presenciar invariantes rotos y es posible que deban tenerse en cuenta.</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">Tenga en cuenta que, en muchos casos, el m&amp;eacute;todo &lt;code&gt;.parse()&lt;/code&gt; en &lt;code&gt;str&lt;/code&gt; es m&amp;aacute;s adecuado.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Nota: &lt;code&gt;Pin&lt;/code&gt; tambi&amp;eacute;n implementa &lt;code&gt;Deref&lt;/code&gt; en el objetivo, que se puede usar para acceder al valor interno. Sin embargo, &lt;code&gt;Deref&lt;/code&gt; solo proporciona una referencia que dura tanto como el &lt;code&gt;Pin&lt;/code&gt; prestado , no la vida &amp;uacute;til del &lt;code&gt;Pin&lt;/code&gt; en s&amp;iacute;. Este m&amp;eacute;todo permite convertir el &lt;code&gt;Pin&lt;/code&gt; en una referencia con la misma vida &amp;uacute;til que el &lt;code&gt;Pin&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Nota: &lt;code&gt;Pin&lt;/code&gt; tambi&amp;eacute;n implementa &lt;code&gt;DerefMut&lt;/code&gt; en los datos, que se pueden usar para acceder al valor interno. Sin embargo, &lt;code&gt;DerefMut&lt;/code&gt; solo proporciona una referencia que dura tanto como el &lt;code&gt;Pin&lt;/code&gt; prestado , no la vida &amp;uacute;til del &lt;code&gt;Pin&lt;/code&gt; en s&amp;iacute;. Este m&amp;eacute;todo permite convertir el &lt;code&gt;Pin&lt;/code&gt; en una referencia con la misma vida &amp;uacute;til que el &lt;code&gt;Pin&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">Nota: &lt;code&gt;fold()&lt;/code&gt; y m&amp;eacute;todos similares que atraviesan todo el iterador pueden no terminar para iteradores infinitos, incluso en rasgos para los que un resultado es determinable en tiempo finito.</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">Nota: los cierres de &lt;code&gt;move&lt;/code&gt; a&amp;uacute;n pueden implementar &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , aunque capturan variables por movimiento. Esto se debe a que los rasgos implementados por un tipo de cierre est&amp;aacute;n determinados por lo que hace el cierre con los valores capturados, no por c&amp;oacute;mo los captura.</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153802f008ce0ac25a19e7452c9f21a823543a00" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;code&gt;Fn&lt;/code&gt; or &lt;code&gt;FnMut&lt;/code&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them. The &lt;code&gt;move&lt;/code&gt; keyword only specifies the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">Nota: &lt;code&gt;rustc&lt;/code&gt; actualmente reconoce las herramientas &quot;clippy&quot; y &quot;rustfmt&quot;.</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">Nota: &lt;code&gt;rustc&lt;/code&gt; tiene un conjunto predeterminado de funciones habilitadas para cada destino y CPU. La CPU puede elegirse con el indicador &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt; . Las caracter&amp;iacute;sticas individuales pueden habilitarse o inhabilitarse para una caja completa con el indicador de &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">Nota: Un dicho que puede escuchar acerca de lenguajes con compiladores estrictos, como Haskell y Rust, es &quot;si el c&amp;oacute;digo se compila, funciona&quot;. Pero este dicho no es universalmente cierto. Nuestro proyecto se compila, &amp;iexcl;pero no hace absolutamente nada! Si estuvi&amp;eacute;ramos construyendo un proyecto real y completo, este ser&amp;iacute;a un buen momento para empezar a escribir pruebas unitarias para comprobar que el c&amp;oacute;digo se compila &lt;em&gt;y&lt;/em&gt; tiene el comportamiento que queremos.</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">Nota:Aunque Rust,como cualquier otro lenguaje,puede ser implementado tanto por un intérprete como por un compilador,la única implementación existente es un compilador,y el lenguaje siempre ha sido diseñado para ser compilado.Por estas razones,esta sección asume un compilador.</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">Nota: Como consecuencia de que la representaci&amp;oacute;n es un atributo del art&amp;iacute;culo, la representaci&amp;oacute;n no depende de par&amp;aacute;metros gen&amp;eacute;ricos. Dos tipos cualesquiera con el mismo nombre tienen la misma representaci&amp;oacute;n. Por ejemplo, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; y &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; tienen la misma representaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">Nota: Como expresi&amp;oacute;n de flujo de control, si una expresi&amp;oacute;n de bloque es la expresi&amp;oacute;n externa de una declaraci&amp;oacute;n de expresi&amp;oacute;n, el tipo esperado es &lt;code&gt;()&lt;/code&gt; a menos que est&amp;eacute; seguida inmediatamente por un punto y coma.</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">Nota:Excepto por las pelusas,es idiomático utilizar sólo los atributos externos en los elementos de función.</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">Nota: Para mayor claridad, se recomienda usar siempre la palabra clave &lt;code&gt;dyn&lt;/code&gt; en sus objetos de caracter&amp;iacute;sticas a menos que su base de c&amp;oacute;digo admita la compilaci&amp;oacute;n con Rust 1.26 o inferior.</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">Nota: Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los detalles de implementaci&amp;oacute;n del tipo &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , consulte &quot;El Rustonomicon&quot; en https://doc.rust-lang.org/stable/nomicon/vec.html.</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">Nota: En aras de la simplicidad, nos referiremos a muchos de los problemas como &lt;em&gt;concurrentes.&lt;/em&gt; lugar de ser m&amp;aacute;s precisos al decir &lt;em&gt;concurrentes y / o paralelos&lt;/em&gt; . Si este libro fuera sobre concurrencia y / o paralelismo, ser&amp;iacute;amos m&amp;aacute;s espec&amp;iacute;ficos. Para este cap&amp;iacute;tulo, sustituya mentalmente &lt;em&gt;concurrente y / o paralelo&lt;/em&gt; siempre que usemos &lt;em&gt;concurrente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">Nota: Las funciones tambi&amp;eacute;n pueden implementar los tres rasgos &lt;code&gt;Fn&lt;/code&gt; . Si lo que queremos hacer no requiere capturar un valor del entorno, podemos usar una funci&amp;oacute;n en lugar de un cierre donde necesitamos algo que implemente un rasgo &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">Nota: Git es un sistema de control de versiones com&amp;uacute;n. Puedes cambiar &lt;code&gt;cargo new&lt;/code&gt; para usar un sistema de control de versiones diferente o ning&amp;uacute;n sistema de control de versiones usando la &lt;code&gt;--vcs&lt;/code&gt; . Ejecutar &lt;code&gt;cargo new --help&lt;/code&gt; para ver las opciones disponibles.</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">Nota: Hist&amp;oacute;ricamente, las expresiones de lugar se llamaban &lt;em&gt; lvalues&lt;/em&gt; y expresiones de valor fueron llamados &lt;em&gt;rvalues&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">Nota: Si se &lt;code&gt;PeekMut&lt;/code&gt; valor de PeekMut , el mont&amp;oacute;n puede estar en un estado incoherente.</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">Nota: si prefiere no utilizar &lt;code&gt;rustup&lt;/code&gt; por alg&amp;uacute;n motivo, consulte &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;la p&amp;aacute;gina de instalaci&amp;oacute;n de Rust&lt;/a&gt; para conocer otras opciones.</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">Nota: En C ++, este patr&amp;oacute;n de desasignaci&amp;oacute;n de recursos al final de la vida &amp;uacute;til de un elemento a veces se denomina &lt;em&gt;Adquisici&amp;oacute;n de recursos es inicializaci&amp;oacute;n (RAII)&lt;/em&gt; . La funci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; en Rust le resultar&amp;aacute; familiar si ha utilizado patrones RAII.</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">Nota: En general, no debe usar &lt;code&gt;FusedIterator&lt;/code&gt; en l&amp;iacute;mites gen&amp;eacute;ricos si necesita un iterador fusionado. En su lugar, deber&amp;iacute;a llamar a &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt; en el iterador. Si el iterador ya est&amp;aacute; fusionado, el &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt; adicional contenedor no ser&amp;aacute; operativo sin penalizaci&amp;oacute;n de rendimiento.</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4be906ba1df5fea075ac60c84354ab807a7ba2" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;code&gt;Err&lt;/code&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt;.</source>
          <target state="translated">Nota: En el caso l&amp;iacute;mite en el que est&amp;aacute; buscando con &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; donde &lt;code&gt;n&lt;/code&gt; menos la longitud del b&amp;uacute;fer interno desborda un &lt;code&gt;i64&lt;/code&gt; , se realizar&amp;aacute;n dos b&amp;uacute;squedas en lugar de una. Si la segunda b&amp;uacute;squeda devuelve &lt;code&gt;Err&lt;/code&gt; , el lector subyacente quedar&amp;aacute; en la misma posici&amp;oacute;n que tendr&amp;iacute;a si llamara a &lt;code&gt;seek&lt;/code&gt; con &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffeb95a03330faff30434eb464fab2ecfe395aa0" translate="yes" xml:space="preserve">
          <source>Note: It is idiomatic to use a &lt;a href=&quot;../statements#let-statements&quot;&gt;let statement&lt;/a&gt; with a pattern of &lt;code&gt;_&lt;/code&gt; when a must-used value is purposely discarded.</source>
          <target state="translated">Nota: Es idiom&amp;aacute;tico usar una &lt;a href=&quot;../statements#let-statements&quot;&gt;declaraci&amp;oacute;n let&lt;/a&gt; con un patr&amp;oacute;n de &lt;code&gt;_&lt;/code&gt; cuando un valor de uso obligatorio se descarta intencionalmente.</target>
        </trans-unit>
        <trans-unit id="a98353ad4c2ea48db43b41e0a837834f6a8b30a0" translate="yes" xml:space="preserve">
          <source>Note: Lifetimes can be and usually are elided with this shorthand.</source>
          <target state="translated">Nota:Las vidas pueden ser y usualmente son eludidas con esta taquigrafía.</target>
        </trans-unit>
        <trans-unit id="9458a465758bdea1aa806edbdf38d0829ff7abbc" translate="yes" xml:space="preserve">
          <source>Note: Multiple matches using the &lt;code&gt;|&lt;/code&gt; operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</source>
          <target state="translated">Nota: M&amp;uacute;ltiples coincidencias usando el &lt;code&gt;|&lt;/code&gt; El operador puede causar la protecci&amp;oacute;n del patr&amp;oacute;n y los efectos secundarios que tiene que ejecutarse varias veces. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b48aac9382dceff2ad2732e0844fc1d124e5afbe" translate="yes" xml:space="preserve">
          <source>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;Storing UTF-8 Encoded Text with Strings&amp;rdquo;&lt;/a&gt; section of Chapter 8.</source>
          <target state="translated">Nota: Los &amp;iacute;ndices de rango de corte de cadena deben ocurrir en l&amp;iacute;mites de caracteres UTF-8 v&amp;aacute;lidos. Si intenta crear un segmento de cadena en medio de un car&amp;aacute;cter multibyte, su programa se cerrar&amp;aacute; con un error. Con el fin de presentar los segmentos de cadena, asumimos ASCII solo en esta secci&amp;oacute;n; una discusi&amp;oacute;n m&amp;aacute;s detallada del manejo de UTF-8 est&amp;aacute; en el&lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&lt;/a&gt; secci&amp;oacute;n &quot;Almacenamiento de texto codificado en UTF-8 con cadenas&quot; del Cap&amp;iacute;tulo 8 encontrar&amp;aacute; 8.</target>
        </trans-unit>
        <trans-unit id="d0300d6a8e919cca08e1ab2c8db38b624e4574c2" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard library type provides a heap-allocated resizable array type.</source>
          <target state="translated">Nota: &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; tipo de biblioteca est&amp;aacute;ndar proporciona un tipo de matriz de tama&amp;ntilde;o variable asignado al mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29d2f706dbf0a3794fd072f42986f2a9c440ff62" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;//&lt;/code&gt; syntax starts a comment that continues until the end of the line. Rust ignores everything in comments, which are discussed in more detail in Chapter 3.</source>
          <target state="translated">Nota la &lt;code&gt;//&lt;/code&gt; sintaxis // inicia un comentario que contin&amp;uacute;a hasta el final de la l&amp;iacute;nea. Rust ignora todo en los comentarios, que se analizan con m&amp;aacute;s detalle en el Cap&amp;iacute;tulo 3.</target>
        </trans-unit>
        <trans-unit id="187085942721c7c78a8ec180c1642f4ed13694fc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;2..=9&lt;/code&gt; is a &lt;a href=&quot;../patterns#range-patterns&quot;&gt;Range Pattern&lt;/a&gt;, not a &lt;a href=&quot;range-expr&quot;&gt;Range Expression&lt;/a&gt;. Thus, only those types of ranges supported by range patterns can be used in match arms.</source>
          <target state="translated">Nota: &lt;code&gt;2..=9&lt;/code&gt; es un &lt;a href=&quot;../patterns#range-patterns&quot;&gt;patr&amp;oacute;n de rango&lt;/a&gt; , no un&lt;a href=&quot;range-expr&quot;&gt; expresi&amp;oacute;n de rango&lt;/a&gt; . Por lo tanto, solo los tipos de rangos admitidos por patrones de rango se pueden usar en brazos de partido.</target>
        </trans-unit>
        <trans-unit id="f039047f79b4edcb39be10eb9b4e9a5ff0260001" translate="yes" xml:space="preserve">
          <source>Note: The actual definition of the &lt;code&gt;vec!&lt;/code&gt; macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don&amp;rsquo;t include here to make the example simpler.</source>
          <target state="translated">Nota: La definici&amp;oacute;n real del &lt;code&gt;vec!&lt;/code&gt; La macro en la biblioteca est&amp;aacute;ndar incluye c&amp;oacute;digo para preasignar la cantidad correcta de memoria por adelantado. Ese c&amp;oacute;digo es una optimizaci&amp;oacute;n que no incluimos aqu&amp;iacute; para simplificar el ejemplo.</target>
        </trans-unit>
        <trans-unit id="43e1990329df70de099fd02b501085a14776154b" translate="yes" xml:space="preserve">
          <source>Note: The aforementioned shim for function pointers is necessary because &lt;code&gt;rustc&lt;/code&gt; implements &lt;code&gt;track_caller&lt;/code&gt; in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function's type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130fc90f1f7559f295e76dc148708d583a3eb9e9" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 1048576.</source>
          <target state="translated">Nota: el valor predeterminado en &lt;code&gt;rustc&lt;/code&gt; es 1048576.</target>
        </trans-unit>
        <trans-unit id="26390a0ab47722e2e502de5688756dbd639d3d95" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d9efde740053cef26656af7a7f6ab7316f24e6" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 64.</source>
          <target state="translated">Nota: el valor predeterminado en &lt;code&gt;rustc&lt;/code&gt; es 64.</target>
        </trans-unit>
        <trans-unit id="8180c8df8ae11541f19b00a561591d13760a8ee6" translate="yes" xml:space="preserve">
          <source>Note: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Nota:El rango de elementos se elimina aunque el iterador no se consuma hasta el final.</target>
        </trans-unit>
        <trans-unit id="9f4fea507ec4e68a49f42af2c77e67668a288392" translate="yes" xml:space="preserve">
          <source>Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</source>
          <target state="translated">Nota:La representación de la lista en C es la implementación definida,así que esto es realmente una &quot;mejor suposición&quot;.En particular,esto puede ser incorrecto cuando el código C de interés se compila con ciertas banderas.</target>
        </trans-unit>
        <trans-unit id="4cee4fb70834d29d39a99e3fa46a091ae845a20c" translate="yes" xml:space="preserve">
          <source>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;issue #33685&lt;/a&gt; for more details.</source>
          <target state="translated">Nota: Los ejemplos anteriores sol&amp;iacute;an ser (err&amp;oacute;neamente) aceptados por el compilador, pero esto se corrigi&amp;oacute; desde entonces. Consulte el &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;n&amp;uacute;mero 33685.&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="daadbb2b1b33b48dcd9e6359e7eecc90c0e80c1e" translate="yes" xml:space="preserve">
          <source>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust&amp;rsquo;s having no null values. However, if we try to use a variable before giving it a value, we&amp;rsquo;ll get a compile-time error, which shows that Rust indeed does not allow null values.</source>
          <target state="translated">Nota: Los ejemplos de los listados 10-17, 10-18 y 10-24 declaran variables sin darles un valor inicial, por lo que el nombre de la variable existe en el &amp;aacute;mbito externo. A primera vista, esto podr&amp;iacute;a parecer estar en conflicto con el hecho de que Rust no tenga valores nulos. Sin embargo, si intentamos usar una variable antes de darle un valor, obtendremos un error en tiempo de compilaci&amp;oacute;n, que muestra que Rust de hecho no permite valores nulos.</target>
        </trans-unit>
        <trans-unit id="50e01f1ed4a46f62a5d14f0b5fa9d8b4796d1c64" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Nota: La implementaci&amp;oacute;n de qu&amp;eacute; tipos de retorno est&amp;aacute;n permitidos est&amp;aacute; determinada por la &lt;a href=&quot;../../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; inestable rasgo de .</target>
        </trans-unit>
        <trans-unit id="788f6375fff581af876a714c5f38068ea6a94a60" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Nota: La implementaci&amp;oacute;n de qu&amp;eacute; tipos de retorno est&amp;aacute;n permitidos est&amp;aacute; determinada por la &lt;a href=&quot;../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; inestable rasgo de .</target>
        </trans-unit>
        <trans-unit id="40b1e975f4973c7f7bd859ba82ec6ff70298303a" translate="yes" xml:space="preserve">
          <source>Note: The lint checks supported by &lt;code&gt;rustc&lt;/code&gt; can be found via &lt;code&gt;rustc -W help&lt;/code&gt;, along with their default settings and are documented in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book&lt;/a&gt;.</source>
          <target state="translated">Nota: Las comprobaciones de pelusa admitidas por &lt;code&gt;rustc&lt;/code&gt; se pueden encontrar a trav&amp;eacute;s de la &lt;code&gt;rustc -W help&lt;/code&gt; , junto con su configuraci&amp;oacute;n predeterminada y est&amp;aacute;n documentadas en el &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;libro de rustc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5df3cfb866cdb5ad3722ea9687c561d88d29727a" translate="yes" xml:space="preserve">
          <source>Note: The next section assumes you&amp;rsquo;ve read the earlier section &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;Using the Newtype Pattern to Implement External Traits on External Types.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">Nota: La siguiente secci&amp;oacute;n asume que ha le&amp;iacute;do la secci&amp;oacute;n anterior &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&quot;Uso del patr&amp;oacute;n Newtype para implementar rasgos externos en tipos externos&quot;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7007864547a1ff842641db1454a617feb860ba4c" translate="yes" xml:space="preserve">
          <source>Note: The opposite of referencing by using &lt;code&gt;&amp;amp;&lt;/code&gt; is &lt;em&gt;dereferencing&lt;/em&gt;, which is accomplished with the dereference operator, &lt;code&gt;*&lt;/code&gt;. We&amp;rsquo;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</source>
          <target state="translated">Nota: Lo contrario de hacer referencia usando &lt;code&gt;&amp;amp;&lt;/code&gt; es &lt;em&gt;desreferenciar&lt;/em&gt; , que se logra con el operador de desreferencia, &lt;code&gt;*&lt;/code&gt; . Veremos algunos usos del operador de desreferencia en el Cap&amp;iacute;tulo 8 y discutiremos los detalles de la desreferencia en el Cap&amp;iacute;tulo 15.</target>
        </trans-unit>
        <trans-unit id="a0cacc6a55793cf1996cae56b2d43488d313d554" translate="yes" xml:space="preserve">
          <source>Note: The semicolon following a statement is not a part of the statement itself. They are invalid when using the &lt;code&gt;stmt&lt;/code&gt; macro matcher.</source>
          <target state="translated">Nota: El punto y coma que sigue a una declaraci&amp;oacute;n no forma parte de la declaraci&amp;oacute;n en s&amp;iacute;. Ellos no son v&amp;aacute;lidos cuando se utiliza el &lt;code&gt;stmt&lt;/code&gt; matcher macro.</target>
        </trans-unit>
        <trans-unit id="ebd41440d85e280e6b8e0940e9eb1baf556c6663" translate="yes" xml:space="preserve">
          <source>Note: The test mode is enabled by passing the &lt;code&gt;--test&lt;/code&gt; argument to &lt;code&gt;rustc&lt;/code&gt; or using &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">Nota: El modo de prueba se habilita pasando el argumento &lt;code&gt;--test&lt;/code&gt; a &lt;code&gt;rustc&lt;/code&gt; o el uso de &lt;code&gt;cargo test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019655f819e73b6b959d0e74887282806fb3a878" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. In C, an empty struct declaration like &lt;code&gt;struct Foo { }&lt;/code&gt; is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the &lt;code&gt;[[no_unique_address]]&lt;/code&gt; attribute, in which case they do not increase the overall size of the struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7281566219ec90e2a7e767d6f73d5379e3c0db2" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. This differs from C where structs without data still have a size of one byte.</source>
          <target state="translated">Nota:Este algoritmo puede producir estructuras de tamaño cero.Esto difiere de C,donde las estructuras sin datos todavía tienen un tamaño de un byte.</target>
        </trans-unit>
        <trans-unit id="84916df8964c95c521b7aa5c595fc0771cbfc9af" translate="yes" xml:space="preserve">
          <source>Note: This book assumes basic familiarity with the command line. Rust makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust support; check the IDE&amp;rsquo;s documentation for details. Recently, the Rust team has been focusing on enabling great IDE support, and progress has been made rapidly on that front!</source>
          <target state="translated">Nota: Este libro asume una familiaridad b&amp;aacute;sica con la l&amp;iacute;nea de comandos. Rust no hace demandas espec&amp;iacute;ficas sobre su edici&amp;oacute;n o herramientas o d&amp;oacute;nde vive su c&amp;oacute;digo, por lo que si prefiere usar un entorno de desarrollo integrado (IDE) en lugar de la l&amp;iacute;nea de comandos, no dude en usar su IDE favorito. Muchos IDE ahora tienen cierto grado de compatibilidad con Rust; consulte la documentaci&amp;oacute;n del IDE para obtener m&amp;aacute;s detalles. Recientemente, el equipo de Rust se ha centrado en permitir un gran soporte de IDE, &amp;iexcl;y se ha avanzado r&amp;aacute;pidamente en ese frente!</target>
        </trans-unit>
        <trans-unit id="5ac1eb98b0f589191a31e26db76121648795b41e" translate="yes" xml:space="preserve">
          <source>Note: This edition of the book is the same as &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt; available in print and ebook format from &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;.</source>
          <target state="translated">Nota: Esta edici&amp;oacute;n del libro es la misma que &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language,&lt;/a&gt; disponible en formato impreso y de libro electr&amp;oacute;nico en&lt;a href=&quot;https://nostarch.com/&quot;&gt; No Starch Press.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12f5db48053663ec58249f015893f0934fb3f9cb" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_slice&lt;/code&gt; instead.</source>
          <target state="translated">Nota: Este ejemplo muestra los &lt;code&gt;&amp;amp;str&lt;/code&gt; internos de &amp;amp; str . &lt;code&gt;unsafe&lt;/code&gt; no debe usarse para obtener un corte de cadena en circunstancias normales. Utilizar &lt;code&gt;as_slice&lt;/code&gt; en lugar.</target>
        </trans-unit>
        <trans-unit id="98315c88f72bf459de14ba0cdd9324f6a6dfd072" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c5367b5e1ca4ccf0bf834db2cd4b500fbdeb5c" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw &lt;code&gt;[T]&lt;/code&gt; type, not pointers (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;, &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;, etc.) to slices.</source>
          <target state="translated">Nota: Se trata del tipo &lt;code&gt;[T]&lt;/code&gt; sin formato, no de punteros ( &lt;code&gt;&amp;amp;[T]&lt;/code&gt; , &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt; , etc.) a los cortes.</target>
        </trans-unit>
        <trans-unit id="53274b0feb8252b3f7e0516cd656e66a12715d39" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">Nota: Se trata de los tipos de objetos de rasgo en bruto, no de punteros ( &lt;code&gt;&amp;amp;Trait&lt;/code&gt; , &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; , etc.) a los objetos de rasgo.</target>
        </trans-unit>
        <trans-unit id="c578bc980d0061348761c9a476bec4981d2bea05" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efbe622a99893d160a87ba1b5dbe54cdc04b646" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in argument position&quot;.</source>
          <target state="translated">Nota:Esto se llama a menudo &quot;Implícita en la posición del argumento&quot;.</target>
        </trans-unit>
        <trans-unit id="ebd18dc0abe826773a124050720a5e27942c51e0" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in return position&quot;.</source>
          <target state="translated">Nota:Esto se llama a menudo &quot;Impresión en posición de retorno&quot;.</target>
        </trans-unit>
        <trans-unit id="dcf4aae415a3e26a6bf431396708d40ea1b5d658" translate="yes" xml:space="preserve">
          <source>Note: This macro can be used in &lt;code&gt;no_std&lt;/code&gt; setups as well. In a &lt;code&gt;no_std&lt;/code&gt; setup you are responsible for the implementation details of the components.</source>
          <target state="translated">Nota: Esta macro tambi&amp;eacute;n se puede utilizar en configuraciones &lt;code&gt;no_std&lt;/code&gt; . En un &lt;code&gt;no_std&lt;/code&gt; configuraci&amp;oacute;n , usted es responsable de los detalles de implementaci&amp;oacute;n de los componentes.</target>
        </trans-unit>
        <trans-unit id="3ba312fede1a13f53566373763f2cc827d3cc6a0" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied but once to the stored value.</source>
          <target state="translated">Nota: Esto puede llamar a la funci&amp;oacute;n varias veces si el valor se ha cambiado de otros subprocesos mientras tanto, siempre que la funci&amp;oacute;n devuelva &lt;code&gt;Some(_)&lt;/code&gt; , pero la funci&amp;oacute;n se habr&amp;aacute; aplicado una sola vez al valor almacenado.</target>
        </trans-unit>
        <trans-unit id="859d3e3283a94e543f2b35839b775cd31f5e0f59" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied only once to the stored value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c40b5289fbe1388c2536811cdec7566f0df820" translate="yes" xml:space="preserve">
          <source>Note: This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a &lt;code&gt;struct&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239a5948be38f752de16eb5b0ffe5444c5d1e29d" translate="yes" xml:space="preserve">
          <source>Note: This section is a placeholder for more comprehensive reference material.</source>
          <target state="translated">Nota:Esta sección es un marcador de posición para un material de referencia más completo.</target>
        </trans-unit>
        <trans-unit id="5b012ed05fd45d1a0619d2a532517a96144ac5c9" translate="yes" xml:space="preserve">
          <source>Note: This section is described more in terms of the compiler than of the language.</source>
          <target state="translated">Nota:Esta sección se describe más en términos del compilador que del lenguaje.</target>
        </trans-unit>
        <trans-unit id="3b7a991aa3513a216522c1b812051b6fd94ca027" translate="yes" xml:space="preserve">
          <source>Note: Though you should not rely on this, all pointers to</source>
          <target state="translated">Nota:Aunque no deberías confiar en esto,todo indica que</target>
        </trans-unit>
        <trans-unit id="ccec92c826b382bbeb8d0f3b3ce8f2aff5320851" translate="yes" xml:space="preserve">
          <source>Note: Traits are similar to a feature often called &lt;em&gt;interfaces&lt;/em&gt; in other languages, although with some differences.</source>
          <target state="translated">Nota: Los rasgos son similares a una funci&amp;oacute;n que a menudo se denomina &lt;em&gt;interfaces&lt;/em&gt; en otros idiomas, aunque con algunas diferencias.</target>
        </trans-unit>
        <trans-unit id="0ff8579bff78c963092559227a81a969d9708ad7" translate="yes" xml:space="preserve">
          <source>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; and then not using that type and being the final expression of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block expression&lt;/a&gt; that is not used.</source>
          <target state="translated">Nota: Las expresiones triviales de no operaci&amp;oacute;n que contienen el valor no violar&amp;aacute;n la pelusa. Los ejemplos incluyen envolver el valor en un tipo que no implementa &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; y luego no usar ese tipo y ser la expresi&amp;oacute;n final de una expresi&amp;oacute;n de &lt;a href=&quot;../expressions/block-expr&quot;&gt;bloque&lt;/a&gt; que no se usa.</target>
        </trans-unit>
        <trans-unit id="eb186d5904a6ce9b777e0cf94b3203a9889bfac8" translate="yes" xml:space="preserve">
          <source>Note: Using primitive values when a complex type would be more appropriate is an anti-pattern known as &lt;em&gt;primitive obsession&lt;/em&gt;.</source>
          <target state="translated">Nota: Usar valores primitivos cuando un tipo complejo ser&amp;iacute;a m&amp;aacute;s apropiado es un anti-patr&amp;oacute;n conocido como &lt;em&gt;obsesi&amp;oacute;n primitiva&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="04993cf7d2f50288aed55f19ed2ebc1756b87d27" translate="yes" xml:space="preserve">
          <source>Note: We&amp;rsquo;re implementing a cons list that holds only &lt;code&gt;i32&lt;/code&gt; values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</source>
          <target state="translated">Nota: Estamos implementando una lista de desventajas que contiene solo valores de &lt;code&gt;i32&lt;/code&gt; para los prop&amp;oacute;sitos de este ejemplo. Podr&amp;iacute;amos haberlo implementado usando gen&amp;eacute;ricos, como discutimos en el Cap&amp;iacute;tulo 10, para definir un tipo de lista de contras que podr&amp;iacute;a almacenar valores de cualquier tipo.</target>
        </trans-unit>
        <trans-unit id="9a9063f50fe88aae84e6d578aa20b9af4873e66f" translate="yes" xml:space="preserve">
          <source>Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.</source>
          <target state="translated">Nota:Si bien se ha estabilizado la definición de las coacciones no dimensionadas y su aplicación,los rasgos en sí mismos no son todavía estables y,por lo tanto,no se pueden utilizar directamente en el óxido estable.</target>
        </trans-unit>
        <trans-unit id="2dfa6e64910004aadc24cb034a538f296b64dc2f" translate="yes" xml:space="preserve">
          <source>Note: Windows Portability Consideration</source>
          <target state="translated">Nota:Consideración de la portabilidad de Windows</target>
        </trans-unit>
        <trans-unit id="54ec2a3d57d83413137977409179cfe79c9797ac" translate="yes" xml:space="preserve">
          <source>Note: You won&amp;rsquo;t just know which traits to use and which methods and functions to call from a crate. Instructions for using a crate are in each crate&amp;rsquo;s documentation. Another neat feature of Cargo is that you can run the &lt;code&gt;cargo doc --open&lt;/code&gt; command, which will build documentation provided by all of your dependencies locally and open it in your browser. If you&amp;rsquo;re interested in other functionality in the &lt;code&gt;rand&lt;/code&gt; crate, for example, run &lt;code&gt;cargo doc --open&lt;/code&gt; and click &lt;code&gt;rand&lt;/code&gt; in the sidebar on the left.</source>
          <target state="translated">Nota: No solo sabr&amp;aacute; qu&amp;eacute; caracter&amp;iacute;sticas usar y qu&amp;eacute; m&amp;eacute;todos y funciones llamar desde una caja. Las instrucciones para usar una caja se encuentran en la documentaci&amp;oacute;n de cada caja. Otra caracter&amp;iacute;stica &lt;code&gt;cargo doc --open&lt;/code&gt; de Cargo es que puede ejecutar el comando cargo doc --open , que crear&amp;aacute; la documentaci&amp;oacute;n proporcionada por todas sus dependencias localmente y la abrir&amp;aacute; en su navegador. Si est&amp;aacute; interesado en otras funciones de la caja &lt;code&gt;rand&lt;/code&gt; , por ejemplo, ejecute &lt;code&gt;cargo doc --open&lt;/code&gt; y haga clic en &lt;code&gt;rand&lt;/code&gt; en la barra lateral de la izquierda.</target>
        </trans-unit>
        <trans-unit id="8dd21546f26b11f02ddb49b823b4ad3f527dfdac" translate="yes" xml:space="preserve">
          <source>Note: any changes to the constness of intrinsics should be discussed with the language team. This includes changes in the stability of the constness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1377a2c8bb6dcbd807394d1b50fa3eae990de774" translate="yes" xml:space="preserve">
          <source>Note: because the resulting &lt;code&gt;Location&lt;/code&gt; is a hint, an implementation may halt its walk up the stack early. See &lt;a href=&quot;#limitations&quot;&gt;Limitations&lt;/a&gt; for important caveats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7e98c548306a32db0bad3d57bbd3a5f699aa40" translate="yes" xml:space="preserve">
          <source>Note: if you open &lt;em&gt;/sleep&lt;/em&gt; in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</source>
          <target state="translated">Nota: si abre &lt;em&gt;/ duerme&lt;/em&gt; en varias ventanas del navegador simult&amp;aacute;neamente, es posible que se carguen de una en una en intervalos de 5 segundos. Algunos navegadores web ejecutan varias instancias de la misma solicitud de forma secuencial por motivos de almacenamiento en cach&amp;eacute;. Esta limitaci&amp;oacute;n no es causada por nuestro servidor web.</target>
        </trans-unit>
        <trans-unit id="0f059d54c5a420d80b996d0b044829768d22d426" translate="yes" xml:space="preserve">
          <source>Note: in a future Rust version this method may become unnecessary when array literal syntax allows &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;repeating const expressions&lt;/a&gt;. The example below could then use &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67ae8b5976b293a38b572b260c03db2df6555be" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.instant#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670b99fc8bc3c4e3e76a24aaf458d8652eb20452" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.systemtime#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94be0b88d71e4f4b09ff423fbdb3966a642ec68a" translate="yes" xml:space="preserve">
          <source>Note: only extended grapheme codepoints that begin the string will be escaped.</source>
          <target state="translated">Nota:sólo se escaparán los puntos de código de grafito extendido que comienzan la cuerda.</target>
        </trans-unit>
        <trans-unit id="15aa3f25c0678e364c46087d4cf15cef24972d41" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;Item&lt;/code&gt; type parameter is not used in this trait, but it allows impls to be more generic. Without it, we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ba94b4a0ce80567a5f66bf9563fcdf82240def" translate="yes" xml:space="preserve">
          <source>Note: the lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print &quot;In trait impl!&quot;, because &lt;code&gt;&amp;amp;self&lt;/code&gt; methods are looked up first, the trait method is found before the struct's &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method is found.</source>
          <target state="translated">Nota: la b&amp;uacute;squeda se realiza para cada tipo en orden, lo que ocasionalmente puede conducir a resultados sorprendentes. El siguiente c&amp;oacute;digo imprimir&amp;aacute; &quot;In trait impl!&quot;, Porque los m&amp;eacute;todos &lt;code&gt;&amp;amp;self&lt;/code&gt; se buscan primero, el m&amp;eacute;todo trait se encuentra antes de que se encuentre el m&amp;eacute;todo &lt;code&gt;&amp;amp;mut self&lt;/code&gt; la estructura .</target>
        </trans-unit>
        <trans-unit id="c7cb38696a69ae9af0ae23e81e9d982ddfe77188" translate="yes" xml:space="preserve">
          <source>Note: the value returned by this method is unspecified after the range has been iterated to exhaustion.</source>
          <target state="translated">Nota:el valor devuelto por este método no se especifica después de que el rango se ha iterado hasta el agotamiento.</target>
        </trans-unit>
        <trans-unit id="aa3e5b7333a9df0d2dc6ac8acfc43125fde51982" translate="yes" xml:space="preserve">
          <source>Note: there&amp;rsquo;s one big difference between the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;re about to build and the real &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: our version will not store its data on the heap. We are focusing this example on &lt;code&gt;Deref&lt;/code&gt;, so where the data is actually stored is less important than the pointer-like behavior.</source>
          <target state="translated">Nota: hay una gran diferencia entre el tipo &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; que estamos a punto de construir y el &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; real : nuestra versi&amp;oacute;n no almacenar&amp;aacute; sus datos en el mont&amp;oacute;n. Estamos enfocando este ejemplo en &lt;code&gt;Deref&lt;/code&gt; , por lo que d&amp;oacute;nde se almacenan realmente los datos es menos importante que el comportamiento similar al de un puntero.</target>
        </trans-unit>
        <trans-unit id="07525906ea71db41f7991cef8484c00c750f6dcb" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c580688b8d6e9090963bfacda97bc90a713c687" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler.</source>
          <target state="translated">Nota:este código de error ya no es emitido por el compilador.</target>
        </trans-unit>
        <trans-unit id="82b6db0c7e241e7e5bc0253c1ea4acf7f9b04451" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::alloc_ref(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.alloc_ref()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8c035d8819f3ef6c6af80dffef20eae4c16d50" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::allocator(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.allocator()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de79d60b5ae69ae8de10ccab3addf181d505537b" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Nota: esta es una funci&amp;oacute;n asociada, lo que significa que debe llamarla como &lt;code&gt;Box::into_raw(b)&lt;/code&gt; lugar de &lt;code&gt;b.into_raw()&lt;/code&gt; . Esto es para que no haya conflicto con un m&amp;eacute;todo en el tipo interno.</target>
        </trans-unit>
        <trans-unit id="9801006a2ac0b25e680ddaebb4a6a97fc9bd8dc1" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_non_null()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Nota: esta es una funci&amp;oacute;n asociada, lo que significa que debe llamarla como &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; lugar de &lt;code&gt;b.into_raw_non_null()&lt;/code&gt; . Esto es para que no haya conflicto con un m&amp;eacute;todo en el tipo interno.</target>
        </trans-unit>
        <trans-unit id="3ad7dd66ed2768898bcd615504f6e1f37abf0500" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_alloc(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_alloc()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8801e3986d4fa9491ea8a20db52c0e7bd9b75a" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_allocator(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_allocator()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61290dcffaed8f71df5ea3435ea91289cbca703" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::leak(b)&lt;/code&gt; instead of &lt;code&gt;b.leak()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Nota: esta es una funci&amp;oacute;n asociada, lo que significa que debe llamarla como &lt;code&gt;Box::leak(b)&lt;/code&gt; lugar de &lt;code&gt;b.leak()&lt;/code&gt; . Esto es para que no haya conflicto con un m&amp;eacute;todo en el tipo interno.</target>
        </trans-unit>
        <trans-unit id="99cc9083edfe04d950b19fddc376275a0d86e32a" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/index.html#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855408558daaf89b8b3b6445b95d7c1b8fc7ac9c" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;index#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Nota: aunque este tipo es inestable, se puede acceder a la funcionalidad que proporciona a trav&amp;eacute;s de las &lt;a href=&quot;index#functions&quot;&gt;funciones gratuitas en &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9ea884e20e19e59213993b5d483a5cae6c6deb6b" translate="yes" xml:space="preserve">
          <source>Notes about side effects</source>
          <target state="translated">Notas sobre los efectos secundarios</target>
        </trans-unit>
        <trans-unit id="0665801607b97f01a2cf09fef56752d404c94329" translate="yes" xml:space="preserve">
          <source>Notes and Safety</source>
          <target state="translated">Notas y seguridad</target>
        </trans-unit>
        <trans-unit id="5367ad0070e3b4dc018a1e98ba396857c9a89c8b" translate="yes" xml:space="preserve">
          <source>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in blockquotes that start with the word &quot;Note:&quot; in &lt;strong&gt;bold&lt;/strong&gt;.</source>
          <target state="translated">Las notas que contienen informaci&amp;oacute;n &amp;uacute;til sobre el estado del libro o que se&amp;ntilde;alan informaci&amp;oacute;n &amp;uacute;til, pero en su mayor&amp;iacute;a fuera de alcance, est&amp;aacute;n entre comillas en bloque que comienzan con la palabra &quot;Nota:&quot; en &lt;strong&gt;negrita&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="343e2ff0e712d5880f73c89d0629c959a0cbc677" translate="yes" xml:space="preserve">
          <source>Nothing in Rust prevents a trait from having a method with the same name as another trait&amp;rsquo;s method, nor does Rust prevent you from implementing both traits on one type. It&amp;rsquo;s also possible to implement a method directly on the type with the same name as methods from traits.</source>
          <target state="translated">Nada en Rust evita que un rasgo tenga un m&amp;eacute;todo con el mismo nombre que el m&amp;eacute;todo de otro rasgo, ni Rust le impide implementar ambos rasgos en un tipo. Tambi&amp;eacute;n es posible implementar un m&amp;eacute;todo directamente en el tipo con el mismo nombre que los m&amp;eacute;todos de rasgos.</target>
        </trans-unit>
        <trans-unit id="85a8ab9caff8306933eb7dd48f9cd08900551077" translate="yes" xml:space="preserve">
          <source>Notice in Listing 16-1 that the closure we pass to &lt;code&gt;thread::spawn&lt;/code&gt; takes no arguments: we&amp;rsquo;re not using any data from the main thread in the spawned thread&amp;rsquo;s code. To use data from the main thread in the spawned thread, the spawned thread&amp;rsquo;s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won&amp;rsquo;t yet work, as you&amp;rsquo;ll see in a moment.</source>
          <target state="translated">Observe en el Listado 16-1 que el cierre que pasamos a &lt;code&gt;thread::spawn&lt;/code&gt; no toma argumentos: no estamos usando ning&amp;uacute;n dato del hilo principal en el c&amp;oacute;digo del hilo generado. Para usar datos del hilo principal en el hilo generado, el cierre del hilo generado debe capturar los valores que necesita. El listado 16-3 muestra un intento de crear un vector en el hilo principal y usarlo en el hilo generado. Sin embargo, esto todav&amp;iacute;a no funcionar&amp;aacute;, como ver&amp;aacute; en un momento.</target>
        </trans-unit>
        <trans-unit id="753a2ed5c1b14367e2086b1d9e2763add33258b6" translate="yes" xml:space="preserve">
          <source>Notice one interesting aspect of this particular execution: the &lt;code&gt;ThreadPool&lt;/code&gt; sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</source>
          <target state="translated">Observe un aspecto interesante de esta ejecuci&amp;oacute;n en particular: &lt;code&gt;ThreadPool&lt;/code&gt; envi&amp;oacute; los mensajes de terminaci&amp;oacute;n por el canal, y antes de que cualquier trabajador recibiera los mensajes, intentamos unirnos al trabajador 0. El trabajador 0 a&amp;uacute;n no hab&amp;iacute;a recibido el mensaje de terminaci&amp;oacute;n, por lo que el hilo principal bloque&amp;oacute; la espera. para que el trabajador 0 termine. Mientras tanto, cada uno de los trabajadores recibi&amp;oacute; los mensajes de despido. Cuando el trabajador 0 termin&amp;oacute;, el hilo principal esper&amp;oacute; a que terminaran los dem&amp;aacute;s trabajadores. En ese momento, todos hab&amp;iacute;an recibido el mensaje de terminaci&amp;oacute;n y pudieron cerrar.</target>
        </trans-unit>
        <trans-unit id="d88bd61c5288b6b4a4fab344b4f64355a8809dd2" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; has a &lt;code&gt;From&lt;/code&gt; instance for &lt;code&gt;&amp;amp;T&lt;/code&gt;. However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The same goes for creating a mutable reference from a shared reference. When using this &lt;code&gt;From&lt;/code&gt; instance without an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, it is your responsibility to ensure that &lt;code&gt;as_mut&lt;/code&gt; is never called, and &lt;code&gt;as_ptr&lt;/code&gt; is never used for mutation.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; tiene un &lt;code&gt;From&lt;/code&gt; instancia para &lt;code&gt;&amp;amp;T&lt;/code&gt; . Sin embargo, esto no cambia el hecho de que la mutaci&amp;oacute;n a trav&amp;eacute;s de un (puntero derivado de una) referencia compartida es un comportamiento indefinido a menos que la mutaci&amp;oacute;n ocurra dentro de una &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . Lo mismo ocurre con la creaci&amp;oacute;n de una referencia mutable a partir de una referencia compartida. Cuando se utiliza esta &lt;code&gt;From&lt;/code&gt; instancia sin una &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; , es su responsabilidad asegurarse de que &lt;code&gt;as_mut&lt;/code&gt; nunca es llamado, y &lt;code&gt;as_ptr&lt;/code&gt; nunca se utiliza para la mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a4555814d84e265a1a37b6f84e64a162ac1d207e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;x&lt;/code&gt; is stack-allocated by &lt;code&gt;foo()&lt;/code&gt;. By default, Rust captures closed-over data by reference. This means that once &lt;code&gt;foo()&lt;/code&gt; returns, &lt;code&gt;x&lt;/code&gt; no longer exists. An attempt to access &lt;code&gt;x&lt;/code&gt; within the closure would thus be unsafe.</source>
          <target state="translated">Observe que &lt;code&gt;x&lt;/code&gt; est&amp;aacute; asignado en la pila por &lt;code&gt;foo()&lt;/code&gt; . De forma predeterminada, Rust captura datos cerrados por referencia. Esto significa que una vez que &lt;code&gt;foo()&lt;/code&gt; regresa, &lt;code&gt;x&lt;/code&gt; ya no existe. Por tanto, un intento de acceder a &lt;code&gt;x&lt;/code&gt; dentro del cierre no ser&amp;iacute;a seguro.</target>
        </trans-unit>
        <trans-unit id="0e90ccdac3be23d4ae5fee41e5c9c069831f7aa8" translate="yes" xml:space="preserve">
          <source>Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious. For example, it would be a valid, but inefficient, implementation to make both &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; return immediately without doing anything.</source>
          <target state="translated">Tenga en cuenta que estar desbloqueado no implica ninguna sincronizaci&amp;oacute;n con alguien que haya desencadenado este hilo, tambi&amp;eacute;n podr&amp;iacute;a ser falso. Por ejemplo, ser&amp;iacute;a una implementaci&amp;oacute;n v&amp;aacute;lida, pero ineficiente, hacer que &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; regresen inmediatamente sin hacer nada.</target>
        </trans-unit>
        <trans-unit id="6dc4ada24330684cf56181017076bf6667acd63e" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;code&gt;AcqRel&lt;/code&gt; will never perform &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7aa95fb880edfba626d059a08ec359fcae43db0" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; will never perform &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">N&amp;oacute;tese que en el caso de &lt;code&gt;compare_and_swap&lt;/code&gt; , es posible que la operaci&amp;oacute;n termine sin realizar ninguna tienda y por lo tanto solo tenga pedido &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; . Sin embargo, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; nunca realizar&amp;aacute; accesos &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d68951af70c1b2b14c8581375aa37ef775c2c882" translate="yes" xml:space="preserve">
          <source>Notice that the code panicked with the message &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt;. This is how &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; handles violations of the borrowing rules at runtime.</source>
          <target state="translated">Observe que el c&amp;oacute;digo entr&amp;oacute; en p&amp;aacute;nico con el mensaje &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt; . As&amp;iacute; es como &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; maneja las violaciones de las reglas de pr&amp;eacute;stamo en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e6e01b202ce551c042845c38802ff1f31e6bfcd1" translate="yes" xml:space="preserve">
          <source>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call &lt;code&gt;drop_in_place&lt;/code&gt; manually.</source>
          <target state="translated">Observe que el compilador realiza esta copia autom&amp;aacute;ticamente cuando suelta estructuras empaquetadas, es decir, normalmente no tiene que preocuparse por estos problemas a menos que llame a &lt;code&gt;drop_in_place&lt;/code&gt; manualmente.</target>
        </trans-unit>
        <trans-unit id="90e25cc098640b84fbba68a414a9fbb480dff45c" translate="yes" xml:space="preserve">
          <source>Notice that the first value in the vector is &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt;, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It&amp;rsquo;s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we&amp;rsquo;ll ignore it and save only the two arguments we need.</source>
          <target state="translated">Note que el primer valor en el vector es &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt; , que es el nombre de nuestro binario. Esto coincide con el comportamiento de la lista de argumentos en C, permitiendo que los programas usen el nombre por el que fueron invocados en su ejecuci&amp;oacute;n. A menudo es conveniente tener acceso al nombre del programa en caso de que desee imprimirlo en mensajes o cambiar el comportamiento del programa en funci&amp;oacute;n del alias de l&amp;iacute;nea de comando que se utiliz&amp;oacute; para invocar el programa. Pero para los prop&amp;oacute;sitos de este cap&amp;iacute;tulo, lo ignoraremos y guardaremos solo los dos argumentos que necesitamos.</target>
        </trans-unit>
        <trans-unit id="a69330b1430c6944224f92b74bbe0967131daf2e" translate="yes" xml:space="preserve">
          <source>Notice that the only type we&amp;rsquo;re interacting with from the crate is the &lt;code&gt;Post&lt;/code&gt; type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in&amp;mdash;draft, waiting for review, or published. Changing from one state to another will be managed internally within the &lt;code&gt;Post&lt;/code&gt; type. The states change in response to the methods called by our library&amp;rsquo;s users on the &lt;code&gt;Post&lt;/code&gt; instance, but they don&amp;rsquo;t have to manage the state changes directly. Also, users can&amp;rsquo;t make a mistake with the states, like publishing a post before it&amp;rsquo;s reviewed.</source>
          <target state="translated">Tenga en cuenta que el &amp;uacute;nico tipo con el que estamos interactuando desde la caja es el tipo &lt;code&gt;Post&lt;/code&gt; . Este tipo utilizar&amp;aacute; el patr&amp;oacute;n de estado y tendr&amp;aacute; un valor que ser&amp;aacute; uno de los tres objetos de estado que representan los distintos estados en los que puede estar una publicaci&amp;oacute;n: borrador, en espera de revisi&amp;oacute;n o publicado. El cambio de un estado a otro se gestionar&amp;aacute; internamente dentro del tipo de &lt;code&gt;Post&lt;/code&gt; . Los estados cambian en respuesta a los m&amp;eacute;todos llamados por los usuarios de nuestra biblioteca en la instancia de &lt;code&gt;Post&lt;/code&gt; , pero no tienen que administrar los cambios de estado directamente. Adem&amp;aacute;s, los usuarios no pueden cometer un error con los estados, como publicar una publicaci&amp;oacute;n antes de que sea revisada.</target>
        </trans-unit>
        <trans-unit id="a7d5a7d44a98e57a3adf5c0193845ed9098d4a93" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">Observe que el espacio de trabajo tiene solo un archivo &lt;em&gt;Cargo.lock&lt;/em&gt; en el nivel superior del espacio de trabajo en lugar de tener un &lt;em&gt;Cargo.lock&lt;/em&gt; en el directorio de cada caja. Esto asegura que todas las cajas est&amp;eacute;n usando la misma versi&amp;oacute;n de todas las dependencias. Si agregamos la caja &lt;code&gt;rand&lt;/code&gt; a los &lt;em&gt;archivos adder / Cargo.toml&lt;/em&gt; y &lt;em&gt;add-one / Cargo.toml&lt;/em&gt; , Cargo resolver&amp;aacute; ambos en una versi&amp;oacute;n de &lt;code&gt;rand&lt;/code&gt; y lo registrar&amp;aacute; en el &amp;uacute;nico &lt;em&gt;Cargo.lock&lt;/em&gt; . Hacer que todas las cajas en el espacio de trabajo usen las mismas dependencias significa que las cajas en el espacio de trabajo siempre ser&amp;aacute;n compatibles entre s&amp;iacute;. Vamos a a&amp;ntilde;adir el &lt;code&gt;rand&lt;/code&gt; del caj&amp;oacute;n a la &lt;code&gt;[dependencies]&lt;/code&gt; secci&amp;oacute;n en el&lt;em&gt;add-one / Cargo.toml&lt;/em&gt; para poder usar la caja &lt;code&gt;rand&lt;/code&gt; en la caja &lt;code&gt;add-one&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="43f89d0af380f75c1edd764ee3eac2d94a06cd6c" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; package to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a1647ef2a65fa35dd0dfd2179008c8845ec9d" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d099748c8a2369f6e0484b9fb1916260cb072d44" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;code&gt;drop&lt;/code&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;code&gt;drop&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">Tenga en cuenta que esta garant&amp;iacute;a &lt;em&gt;no&lt;/em&gt; significa que la memoria no se pierda. Todav&amp;iacute;a est&amp;aacute; completamente bien no llamar nunca a &lt;code&gt;drop&lt;/code&gt; en un elemento fijado (por ejemplo, a&amp;uacute;n puede llamar a &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; en un &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ). En el ejemplo de la lista doblemente enlazada, ese elemento simplemente permanecer&amp;iacute;a en la lista. Sin embargo, no puede liberar ni reutilizar el almacenamiento &lt;em&gt;sin llamar a &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e8e96d92ae370594b0a23d663a0a9b44ba5cff77" translate="yes" xml:space="preserve">
          <source>Notice that this time we didn&amp;rsquo;t see output indicating that Cargo was compiling &lt;code&gt;hello_cargo&lt;/code&gt;. Cargo figured out that the files hadn&amp;rsquo;t changed, so it just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it, and you would have seen this output:</source>
          <target state="translated">Observe que esta vez no vimos la salida que indica que Cargo estaba compilando &lt;code&gt;hello_cargo&lt;/code&gt; . Cargo descubri&amp;oacute; que los archivos no hab&amp;iacute;an cambiado, por lo que simplemente ejecut&amp;oacute; el binario. Si hubiera modificado su c&amp;oacute;digo fuente, Cargo habr&amp;iacute;a reconstruido el proyecto antes de ejecutarlo y habr&amp;iacute;a visto este resultado:</target>
        </trans-unit>
        <trans-unit id="75afd928e1d9d07e8e8783b4a4c896142a3ef3bd" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0d2528578bd301fdbec6c6a7d80185cfd20062" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af1b53e3b0f26b23d98afe8cfa1fff0e78676da" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">Tenga en cuenta que el uso de este pedido para una operaci&amp;oacute;n que combina cargas y almacenes conduce a una operaci&amp;oacute;n de carga &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a34cbcc2842b5a9803de21bbd3cea40bd2f9faf2" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">Tenga en cuenta que el uso de este pedido para una operaci&amp;oacute;n que combina cargas y tiendas conduce a una operaci&amp;oacute;n de tienda &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1648ed9eef01e81103715c2fb558bce27eedcadf" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t include the &lt;code&gt;unsafe&lt;/code&gt; keyword in this code. We can create raw pointers in safe code; we just can&amp;rsquo;t dereference raw pointers outside an unsafe block, as you&amp;rsquo;ll see in a bit.</source>
          <target state="translated">Tenga en cuenta que no incluimos la palabra clave &lt;code&gt;unsafe&lt;/code&gt; en este c&amp;oacute;digo. Podemos crear punteros sin procesar en c&amp;oacute;digo seguro; simplemente no podemos desreferenciar punteros sin formato fuera de un bloque inseguro, como ver&amp;aacute; en un momento.</target>
        </trans-unit>
        <trans-unit id="111ab81f0256d10482ec4d240e310c1571a40527" translate="yes" xml:space="preserve">
          <source>Notice that we need an explicit lifetime &lt;code&gt;'a&lt;/code&gt; defined in the signature of &lt;code&gt;search&lt;/code&gt; and used with the &lt;code&gt;contents&lt;/code&gt; argument and the return value. Recall in &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Chapter 10&lt;/a&gt; that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument &lt;code&gt;contents&lt;/code&gt; (rather than the argument &lt;code&gt;query&lt;/code&gt;).</source>
          <target state="translated">Tenga en cuenta que necesitamos una duraci&amp;oacute;n expl&amp;iacute;cita &lt;code&gt;'a&lt;/code&gt; definida en la firma de &lt;code&gt;search&lt;/code&gt; y utilizada con el argumento de &lt;code&gt;contents&lt;/code&gt; y el valor de retorno. Recuerde en el &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Cap&amp;iacute;tulo 10&lt;/a&gt; que los par&amp;aacute;metros de duraci&amp;oacute;n especifican qu&amp;eacute; duraci&amp;oacute;n del argumento est&amp;aacute; conectada a la duraci&amp;oacute;n del valor de retorno. En este caso, indicamos que el vector devuelto debe contener segmentos de cadena que hagan referencia a segmentos del &lt;code&gt;contents&lt;/code&gt; del argumento (en lugar de la &lt;code&gt;query&lt;/code&gt; del argumento ).</target>
        </trans-unit>
        <trans-unit id="fd9233164b7146f50abe145b0977e2ddba8ac9ff" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;ve split the code into the &lt;code&gt;hello_macro_derive&lt;/code&gt; function, which is responsible for parsing the &lt;code&gt;TokenStream&lt;/code&gt;, and the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (&lt;code&gt;hello_macro_derive&lt;/code&gt; in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (&lt;code&gt;impl_hello_macro&lt;/code&gt; in this case) will be different depending on your procedural macro&amp;rsquo;s purpose.</source>
          <target state="translated">Observe que hemos dividido el c&amp;oacute;digo en la funci&amp;oacute;n &lt;code&gt;hello_macro_derive&lt;/code&gt; , que es responsable de analizar el &lt;code&gt;TokenStream&lt;/code&gt; , y la funci&amp;oacute;n &lt;code&gt;impl_hello_macro&lt;/code&gt; , que es responsable de transformar el &amp;aacute;rbol de sintaxis: esto hace que escribir una macro de procedimiento sea m&amp;aacute;s conveniente. El c&amp;oacute;digo de la funci&amp;oacute;n externa ( &lt;code&gt;hello_macro_derive&lt;/code&gt; en este caso) ser&amp;aacute; el mismo para casi todas las cajas de macro de procedimiento que vea o cree. El c&amp;oacute;digo que especifique en el cuerpo de la funci&amp;oacute;n interna ( &lt;code&gt;impl_hello_macro&lt;/code&gt; en este caso) ser&amp;aacute; diferente seg&amp;uacute;n el prop&amp;oacute;sito de su macro de procedimiento.</target>
        </trans-unit>
        <trans-unit id="8966a5e7726edf21a4dc24ce7e3b95ed94980ac9" translate="yes" xml:space="preserve">
          <source>Notice there isn&amp;rsquo;t any code after the last line that begins with &lt;code&gt;//!&lt;/code&gt;. Because we started the comments with &lt;code&gt;//!&lt;/code&gt; instead of &lt;code&gt;///&lt;/code&gt;, we&amp;rsquo;re documenting the item that contains this comment rather than an item that follows this comment. In this case, the item that contains this comment is the &lt;em&gt;src/lib.rs&lt;/em&gt; file, which is the crate root. These comments describe the entire crate.</source>
          <target state="translated">&amp;iexcl;Observe que no hay ning&amp;uacute;n c&amp;oacute;digo despu&amp;eacute;s de la &amp;uacute;ltima l&amp;iacute;nea que comienza con &lt;code&gt;//!&lt;/code&gt; . Porque comenzamos los comentarios con &lt;code&gt;//!&lt;/code&gt; en lugar de &lt;code&gt;///&lt;/code&gt; , estamos documentando el elemento que contiene este comentario en lugar de un elemento que sigue a este comentario. En este caso, el elemento que contiene este comentario es el archivo &lt;em&gt;src / lib.rs&lt;/em&gt; , que es la ra&amp;iacute;z de la caja. Estos comentarios describen la caja completa.</target>
        </trans-unit>
        <trans-unit id="fcd0fb110f9fe32ec66824d300336739072d5b34" translate="yes" xml:space="preserve">
          <source>Notice this definition uses some new syntax: &lt;code&gt;type Item&lt;/code&gt; and &lt;code&gt;Self::Item&lt;/code&gt;, which are defining an &lt;em&gt;associated type&lt;/em&gt; with this trait. We&amp;rsquo;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the &lt;code&gt;Iterator&lt;/code&gt; trait requires that you also define an &lt;code&gt;Item&lt;/code&gt; type, and this &lt;code&gt;Item&lt;/code&gt; type is used in the return type of the &lt;code&gt;next&lt;/code&gt; method. In other words, the &lt;code&gt;Item&lt;/code&gt; type will be the type returned from the iterator.</source>
          <target state="translated">Observe que esta definici&amp;oacute;n usa una nueva sintaxis: &lt;code&gt;type Item&lt;/code&gt; y &lt;code&gt;Self::Item&lt;/code&gt; , que definen un &lt;em&gt;tipo asociado&lt;/em&gt; con este rasgo. Hablaremos sobre los tipos asociados en profundidad en el Cap&amp;iacute;tulo 19. Por ahora, todo lo que necesita saber es que este c&amp;oacute;digo dice que implementar el rasgo &lt;code&gt;Iterator&lt;/code&gt; requiere que tambi&amp;eacute;n defina un tipo de &lt;code&gt;Item&lt;/code&gt; , y este tipo de &lt;code&gt;Item&lt;/code&gt; se usa en el tipo de retorno de el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo. En otras palabras, el tipo de &lt;code&gt;Item&lt;/code&gt; ser&amp;aacute; el tipo devuelto por el iterador.</target>
        </trans-unit>
        <trans-unit id="e0aa323f0e9e9e9d80a8d3d6a7b2a9db9ba76843" translate="yes" xml:space="preserve">
          <source>Now all the instances of &lt;code&gt;Point&lt;/code&gt; shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</source>
          <target state="translated">&amp;iexcl;Ahora se permiten todas las instancias de &lt;code&gt;Point&lt;/code&gt; mostradas! Puede usar tantos par&amp;aacute;metros de tipo gen&amp;eacute;rico en una definici&amp;oacute;n como desee, pero usar m&amp;aacute;s de unos hace que su c&amp;oacute;digo sea dif&amp;iacute;cil de leer. Cuando necesite muchos tipos gen&amp;eacute;ricos en su c&amp;oacute;digo, podr&amp;iacute;a indicar que su c&amp;oacute;digo necesita reestructurarse en partes m&amp;aacute;s peque&amp;ntilde;as.</target>
        </trans-unit>
        <trans-unit id="23eaa14436421a3e3cff4560bf4fb71eb52f11da" translate="yes" xml:space="preserve">
          <source>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</source>
          <target state="translated">Ahora todas las referencias en esta firma de función tienen vidas,y el compilador puede continuar su análisis sin necesidad de que el programador anote las vidas en esta firma de función.</target>
        </trans-unit>
        <trans-unit id="6e1a1d010dc9ab9a0953fedbe299c3c77ffa1062" translate="yes" xml:space="preserve">
          <source>Now an example of &lt;code&gt;bool&lt;/code&gt; cast to integer type:</source>
          <target state="translated">Ahora un ejemplo de &lt;code&gt;bool&lt;/code&gt; a tipo entero:</target>
        </trans-unit>
        <trans-unit id="d65b9b0f422f439e94c8e42e9b963ca1e3008607" translate="yes" xml:space="preserve">
          <source>Now consider this twist where we add a call to &lt;code&gt;rev&lt;/code&gt;. This version will print &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt;. Note that the letters are reversed, but the values of the counter still go in order. This is because &lt;code&gt;map()&lt;/code&gt; is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.</source>
          <target state="translated">Ahora considere este giro en el que agregamos una llamada a &lt;code&gt;rev&lt;/code&gt; . Esta versi&amp;oacute;n imprimir&amp;aacute; &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt; . Tenga en cuenta que las letras est&amp;aacute;n invertidas, pero los valores del contador siguen en orden. Esto se debe a que &lt;code&gt;map()&lt;/code&gt; todav&amp;iacute;a se llama perezosamente en cada elemento, pero ahora estamos sacando elementos de la parte posterior del vector, en lugar de desplazarlos desde el frente.</target>
        </trans-unit>
        <trans-unit id="3a875ba4bda66efea86acc1d83b8c4cd40356ff2" translate="yes" xml:space="preserve">
          <source>Now enter the code in Listing 20-1 in &lt;em&gt;src/main.rs&lt;/em&gt; to start. This code will listen at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt; for incoming TCP streams. When it gets an incoming stream, it will print &lt;code&gt;Connection established!&lt;/code&gt;.</source>
          <target state="translated">Ahora ingrese el c&amp;oacute;digo en el Listado 20-1 en &lt;em&gt;src / main.rs&lt;/em&gt; para comenzar. Este c&amp;oacute;digo escuchar&amp;aacute; en la direcci&amp;oacute;n &lt;code&gt;127.0.0.1:7878&lt;/code&gt; para las transmisiones TCP entrantes. Cuando reciba un flujo entrante, imprimir&amp;aacute; &lt;code&gt;Connection established!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc71b87d7408d245b3b0aa3a92982cb74fc6ac9f" translate="yes" xml:space="preserve">
          <source>Now everything in the program should work as expected. Let&amp;rsquo;s try it:</source>
          <target state="translated">Ahora todo en el programa deber&amp;iacute;a funcionar como se esperaba. Vamos a intentarlo:</target>
        </trans-unit>
        <trans-unit id="d7f4763863038d188ed1914c2142e2e561d22201" translate="yes" xml:space="preserve">
          <source>Now if we change either the function or the example so the &lt;code&gt;assert_eq!&lt;/code&gt; in the example panics and run &lt;code&gt;cargo test&lt;/code&gt; again, we&amp;rsquo;ll see that the doc tests catch that the example and the code are out of sync with each other!</source>
          <target state="translated">Ahora, si cambiamos la funci&amp;oacute;n o el ejemplo, &amp;iexcl;el &lt;code&gt;assert_eq!&lt;/code&gt; en el ejemplo entra en p&amp;aacute;nico y ejecutamos &lt;code&gt;cargo test&lt;/code&gt; nuevo, veremos que las pruebas de documentaci&amp;oacute;n detectan que el ejemplo y el c&amp;oacute;digo no est&amp;aacute;n sincronizados entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="2e5aa4ec7130600ff4ecc4d4f5150848ff00d36e" translate="yes" xml:space="preserve">
          <source>Now it's possible to create at least one instance of &lt;code&gt;Foo&lt;/code&gt;: &lt;code&gt;Foo { x: None }&lt;/code&gt;.</source>
          <target state="translated">Ahora es posible crear al menos una instancia de &lt;code&gt;Foo&lt;/code&gt; : &lt;code&gt;Foo { x: None }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dee911ce426e019e30db0fccc486981ac3d8d4" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add the code in Listing 20-7 to the &lt;code&gt;else&lt;/code&gt; block to return a response with the status code 404, which signals that the content for the request was not found. We&amp;rsquo;ll also return some HTML for a page to render in the browser indicating the response to the end user.</source>
          <target state="translated">Ahora agreguemos el c&amp;oacute;digo del Listado 20-7 al bloque &lt;code&gt;else&lt;/code&gt; para devolver una respuesta con el c&amp;oacute;digo de estado 404, que indica que no se encontr&amp;oacute; el contenido de la solicitud. Tambi&amp;eacute;n devolveremos algo de HTML para que una p&amp;aacute;gina se muestre en el navegador indicando la respuesta al usuario final.</target>
        </trans-unit>
        <trans-unit id="82511279c647b8b87ee818b8d44458ab76617b1f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s compile this &amp;ldquo;Hello, world!&amp;rdquo; program and run it in the same step using the &lt;code&gt;cargo run&lt;/code&gt; command:</source>
          <target state="translated">Ahora compilemos este &quot;&amp;iexcl;Hola, mundo!&quot; programe y ejec&amp;uacute;telo en el mismo paso usando el comando &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8863ee5075a8246e730bfe40012862faba75a02b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s consider the second call of &lt;code&gt;plus_one&lt;/code&gt; in Listing 6-5, where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. We enter the &lt;code&gt;match&lt;/code&gt; and compare to the first arm.</source>
          <target state="translated">Ahora consideremos la segunda llamada de &lt;code&gt;plus_one&lt;/code&gt; en el Listado 6-5, donde &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; . Entramos al &lt;code&gt;match&lt;/code&gt; y lo comparamos con el primer brazo.</target>
        </trans-unit>
        <trans-unit id="b8300b290a67f9ed128322c21050dab12f2d0aa0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s examine lifetime annotations in the context of the &lt;code&gt;longest&lt;/code&gt; function. As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. We&amp;rsquo;ll name the lifetime &lt;code&gt;'a&lt;/code&gt; and then add it to each reference, as shown in Listing 10-22.</source>
          <target state="translated">Ahora examinemos las anotaciones de por vida en el contexto de la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; . Al igual que con los par&amp;aacute;metros de tipo gen&amp;eacute;rico, debemos declarar los par&amp;aacute;metros de vida &amp;uacute;til gen&amp;eacute;ricos entre par&amp;eacute;ntesis angulares entre el nombre de la funci&amp;oacute;n y la lista de par&amp;aacute;metros. La restricci&amp;oacute;n que queremos expresar en esta firma es que todas las referencias en los par&amp;aacute;metros y el valor de retorno deben tener la misma duraci&amp;oacute;n. Nombraremos la duraci&amp;oacute;n &lt;code&gt;'a&lt;/code&gt; ay luego la agregaremos a cada referencia, como se muestra en el Listado 10-22.</target>
        </trans-unit>
        <trans-unit id="4d1d28eae4c7f65ed347f71ad22936c83ed0eb43" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:</source>
          <target state="translated">Ahora apoy&amp;eacute;monos en el compilador para encontrar los otros lugares que necesitan cambiar. Al verificar este c&amp;oacute;digo, obtenemos dos errores:</target>
        </trans-unit>
        <trans-unit id="89a2cc6c6da74e574a540dd470febae8d113a245" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the &lt;code&gt;String&lt;/code&gt; version:</source>
          <target state="translated">Ahora veamos la versi&amp;oacute;n &lt;code&gt;String&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aaee68df203c11b18152dd8afe26709ec73580c1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the pattern in the body of the code associated with this arm: &lt;code&gt;temp_vec.push()&lt;/code&gt; within &lt;code&gt;$()*&lt;/code&gt; is generated for each part that matches &lt;code&gt;$()&lt;/code&gt; in the pattern zero or more times depending on how many times the pattern matches. The &lt;code&gt;$x&lt;/code&gt; is replaced with each expression matched. When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the code generated that replaces this macro call will be the following:</source>
          <target state="translated">Ahora veamos el patr&amp;oacute;n en el cuerpo del c&amp;oacute;digo asociado con este brazo: &lt;code&gt;temp_vec.push()&lt;/code&gt; dentro de &lt;code&gt;$()*&lt;/code&gt; se genera para cada parte que coincide con &lt;code&gt;$()&lt;/code&gt; en el patr&amp;oacute;n cero o m&amp;aacute;s veces dependiendo de cu&amp;aacute;ntas veces el coincidencias de patr&amp;oacute;n. El &lt;code&gt;$x&lt;/code&gt; se reemplaza con cada expresi&amp;oacute;n coincidente. Cuando llamamos a esta macro con &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; , el c&amp;oacute;digo generado que sustituye a esta macro llamada ser&amp;aacute; el siguiente:</target>
        </trans-unit>
        <trans-unit id="c4243cfe8f9ac10ec246b38ad823287bb3f58d73" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the &amp;ldquo;Hello, world!&amp;rdquo; program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b98c3dc4276471e5dedcfc50a6872d575390db" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the Hello, world! program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">Ahora veamos qu&amp;eacute; es diferente cuando construimos y ejecutamos Hello, world! programa con Cargo! Desde su directorio &lt;em&gt;hello_cargo&lt;/em&gt; , cree su proyecto ingresando el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="5b581411bc505a7c21b9a362d12d054fb0134b63" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the test:</source>
          <target state="translated">Ahora ejecutemos la prueba:</target>
        </trans-unit>
        <trans-unit id="f0501637a3932ce5ddf54dd291b5e0f5788b9a63" translate="yes" xml:space="preserve">
          <source>Now open &lt;em&gt;src/main.rs&lt;/em&gt; and take a look:</source>
          <target state="translated">Ahora abra &lt;em&gt;src / main.rs&lt;/em&gt; y eche un vistazo:</target>
        </trans-unit>
        <trans-unit id="b399f29f23b6c286984286dd9b48d3e844228cb4" translate="yes" xml:space="preserve">
          <source>Now open the &lt;em&gt;main.rs&lt;/em&gt; file you just created and enter the code in Listing 1-1.</source>
          <target state="translated">Ahora abra el archivo &lt;em&gt;main.rs&lt;/em&gt; que acaba de crear e ingrese el c&amp;oacute;digo en el Listado 1-1.</target>
        </trans-unit>
        <trans-unit id="d981ccfedbc387139591c6429e1ab6bbb51ae547" translate="yes" xml:space="preserve">
          <source>Now our code more clearly conveys that &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the &lt;code&gt;config&lt;/code&gt; instance in the fields named for their purpose.</source>
          <target state="translated">Ahora nuestro c&amp;oacute;digo transmite m&amp;aacute;s claramente que la &lt;code&gt;query&lt;/code&gt; y el &lt;code&gt;filename&lt;/code&gt; est&amp;aacute;n relacionados y que su prop&amp;oacute;sito es configurar c&amp;oacute;mo funcionar&amp;aacute; el programa. Cualquier c&amp;oacute;digo que use estos valores sabe encontrarlos en la instancia de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n en los campos nombrados para su prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="e98906bcddd6edae414bc05f0060b41c04becc18" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;cargo test&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">Ahora ejecute &lt;code&gt;cargo test&lt;/code&gt; en el directorio de &lt;em&gt;adici&amp;oacute;n de&lt;/em&gt; nivel superior :</target>
        </trans-unit>
        <trans-unit id="d7999991a01bc3db0ab51179e8f7d5b7ea1e4709" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;search&lt;/code&gt; function is working and tested, we need to call &lt;code&gt;search&lt;/code&gt; from our &lt;code&gt;run&lt;/code&gt; function. We need to pass the &lt;code&gt;config.query&lt;/code&gt; value and the &lt;code&gt;contents&lt;/code&gt; that &lt;code&gt;run&lt;/code&gt; reads from the file to the &lt;code&gt;search&lt;/code&gt; function. Then &lt;code&gt;run&lt;/code&gt; will print each line returned from &lt;code&gt;search&lt;/code&gt;:</source>
          <target state="translated">Ahora que la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; est&amp;aacute; funcionando y probada, necesitamos llamar a la &lt;code&gt;search&lt;/code&gt; desde nuestra funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; . Necesitamos pasar el valor &lt;code&gt;config.query&lt;/code&gt; y el &lt;code&gt;contents&lt;/code&gt; que se &lt;code&gt;run&lt;/code&gt; lee del archivo a la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; . Luego, &lt;code&gt;run&lt;/code&gt; imprimir&amp;aacute; cada l&amp;iacute;nea devuelta por la &lt;code&gt;search&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="03229adf31a42bdb64eb9cba521d26f0154223d5" translate="yes" xml:space="preserve">
          <source>Now that the closure has its own copy of the data, there's no need to worry about safety.</source>
          <target state="translated">Ahora que el cierre tiene su propia copia de los datos,no hay necesidad de preocuparse por la seguridad.</target>
        </trans-unit>
        <trans-unit id="80c8ae661a453d666a29851514f9590667d50328" translate="yes" xml:space="preserve">
          <source>Now that we have a library crate in the workspace, we can have the binary crate &lt;code&gt;adder&lt;/code&gt; depend on the library crate &lt;code&gt;add-one&lt;/code&gt;. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">Ahora que tenemos una caja de biblioteca en el espacio de trabajo, podemos hacer que el &lt;code&gt;adder&lt;/code&gt; caja binaria dependa del &lt;code&gt;add-one&lt;/code&gt; caja de biblioteca . Primero, necesitaremos agregar una dependencia de ruta en &lt;code&gt;add-one&lt;/code&gt; a &lt;em&gt;adder / Cargo.toml&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d03746f7af11550c4dab530f554fdd12c9b9be" translate="yes" xml:space="preserve">
          <source>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the &lt;code&gt;ThreadPool&lt;/code&gt; struct before returning it. But how do we &amp;ldquo;store&amp;rdquo; a thread? Let&amp;rsquo;s take another look at the &lt;code&gt;thread::spawn&lt;/code&gt; signature:</source>
          <target state="translated">Ahora que tenemos una forma de saber que tenemos un n&amp;uacute;mero v&amp;aacute;lido de subprocesos para almacenar en el grupo, podemos crear esos subprocesos y almacenarlos en la estructura &lt;code&gt;ThreadPool&lt;/code&gt; antes de devolverlo. Pero, &amp;iquest;c&amp;oacute;mo &amp;ldquo;almacenamos&amp;rdquo; un hilo? Echemos otro vistazo al &lt;code&gt;thread::spawn&lt;/code&gt; firma de generaci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="bda29c679c337b77198a68eb0c281ffe77fd4dfe" translate="yes" xml:space="preserve">
          <source>Now that we have an external dependency, Cargo fetches the latest versions of everything from the &lt;em&gt;registry&lt;/em&gt;, which is a copy of data from &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</source>
          <target state="translated">Ahora que tenemos una dependencia externa, Cargo obtiene las &amp;uacute;ltimas versiones de todo desde el &lt;em&gt;registro&lt;/em&gt; , que es una copia de los datos de &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt; . Crates.io es donde las personas del ecosistema Rust publican sus proyectos Rust de c&amp;oacute;digo abierto para que otros los usen.</target>
        </trans-unit>
        <trans-unit id="b1ccc08848b1ba0169c7f988c879a0f190ff1fea" translate="yes" xml:space="preserve">
          <source>Now that we have another package in the workspace, we can have the &lt;code&gt;adder&lt;/code&gt; package with our binary depend on the &lt;code&gt;add-one&lt;/code&gt; package, that has our library. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3228f1351fbe40c57701ca17a80dd025a6bfe94f" translate="yes" xml:space="preserve">
          <source>Now that we have the code to turn the annotated Rust code from a &lt;code&gt;TokenStream&lt;/code&gt; into a &lt;code&gt;DeriveInput&lt;/code&gt; instance, let&amp;rsquo;s generate the code that implements the &lt;code&gt;HelloMacro&lt;/code&gt; trait on the annotated type, as shown in Listing 19-33.</source>
          <target state="translated">Ahora que tenemos el c&amp;oacute;digo para convertir el c&amp;oacute;digo de Rust anotado de un &lt;code&gt;TokenStream&lt;/code&gt; en una instancia de &lt;code&gt;DeriveInput&lt;/code&gt; , generemos el c&amp;oacute;digo que implementa el rasgo &lt;code&gt;HelloMacro&lt;/code&gt; en el tipo anotado, como se muestra en el Listado 19-33.</target>
        </trans-unit>
        <trans-unit id="a05d1adf4441c02b17aff2e4ed6b1b6d76dccfa3" translate="yes" xml:space="preserve">
          <source>Now that we have the context, let&amp;rsquo;s get to the algorithm. The function &lt;code&gt;generate_workout&lt;/code&gt; in Listing 13-3 contains the business logic of the app that we&amp;rsquo;re most concerned with in this example. The rest of the code changes in this example will be made to this function.</source>
          <target state="translated">Ahora que tenemos el contexto, vayamos al algoritmo. La funci&amp;oacute;n &lt;code&gt;generate_workout&lt;/code&gt; del Listado 13-3 contiene la l&amp;oacute;gica empresarial de la aplicaci&amp;oacute;n que m&amp;aacute;s nos preocupa en este ejemplo. El resto de los cambios de c&amp;oacute;digo en este ejemplo se realizar&amp;aacute;n en esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d0d7185e0fbe1a274eebe89e5b39be3986c2db0a" translate="yes" xml:space="preserve">
          <source>Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won&amp;rsquo;t compile quite yet, as we will explain.</source>
          <target state="translated">Ahora que tenemos la entrada del usuario y un n&amp;uacute;mero aleatorio, podemos compararlos. Ese paso se muestra en el Listado 2-4. Tenga en cuenta que este c&amp;oacute;digo no se compilar&amp;aacute; todav&amp;iacute;a, como explicaremos.</target>
        </trans-unit>
        <trans-unit id="38f50db14e5d3025086efbe8bea15a9ba8ef6b08" translate="yes" xml:space="preserve">
          <source>Now that we know what the browser is asking for, let&amp;rsquo;s send back some data!</source>
          <target state="translated">Ahora que sabemos lo que pide el navegador, &amp;iexcl;enviemos algunos datos!</target>
        </trans-unit>
        <trans-unit id="e92484795e9a806e19045c8bd7479798242a92b0" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined the desired behavior using the &lt;code&gt;Summary&lt;/code&gt; trait, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; struct that uses the headline, the author, and the location to create the return value of &lt;code&gt;summarize&lt;/code&gt;. For the &lt;code&gt;Tweet&lt;/code&gt; struct, we define &lt;code&gt;summarize&lt;/code&gt; as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</source>
          <target state="translated">Ahora que hemos definido el comportamiento deseado usando el rasgo &lt;code&gt;Summary&lt;/code&gt; , podemos implementarlo en los tipos en nuestro agregador de medios. El Listado 10-13 muestra una implementaci&amp;oacute;n del rasgo &lt;code&gt;Summary&lt;/code&gt; en la estructura &lt;code&gt;NewsArticle&lt;/code&gt; que usa el t&amp;iacute;tulo, el autor y la ubicaci&amp;oacute;n para crear el valor de retorno de &lt;code&gt;summarize&lt;/code&gt; . Para la estructura &lt;code&gt;Tweet&lt;/code&gt; , definimos &lt;code&gt;summarize&lt;/code&gt; como el nombre de usuario seguido del texto completo del tweet, asumiendo que el contenido del tweet ya est&amp;aacute; limitado a 280 caracteres.</target>
        </trans-unit>
        <trans-unit id="847c864456f96a628c83e8df1e38c081c9008635" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined threads in Rust, let&amp;rsquo;s explore how to use the thread-related API provided by the standard library.</source>
          <target state="translated">Ahora que hemos definido subprocesos en Rust, exploremos c&amp;oacute;mo usar la API relacionada con subprocesos proporcionada por la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="4bba9ff87fd1d7a113978a70c232f211dcf89ab4" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;the API documentation&lt;/a&gt; for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dd1868af24eb68dc999a15f4b71b72a52c4914" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">Ahora que hemos discutido algunas de las formas m&amp;aacute;s comunes de usar vectores, aseg&amp;uacute;rese de revisar la documentaci&amp;oacute;n de la API para conocer todos los m&amp;eacute;todos &amp;uacute;tiles definidos en &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; por la biblioteca est&amp;aacute;ndar. Por ejemplo, adem&amp;aacute;s de &lt;code&gt;push&lt;/code&gt; , un m&amp;eacute;todo &lt;code&gt;pop&lt;/code&gt; elimina y devuelve el &amp;uacute;ltimo elemento. Pasemos al siguiente tipo de colecci&amp;oacute;n: &amp;iexcl; &lt;code&gt;String&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="2ec4c24a317d3f7bc3c352fa146805708f0bd185" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed the details of calling &lt;code&gt;panic!&lt;/code&gt; or returning &lt;code&gt;Result&lt;/code&gt;, let&amp;rsquo;s return to the topic of how to decide which is appropriate to use in which cases.</source>
          <target state="translated">&amp;iexcl;Ahora que hemos discutido los detalles de llamar al &lt;code&gt;panic!&lt;/code&gt; o devolviendo &lt;code&gt;Result&lt;/code&gt; , volvamos al tema de c&amp;oacute;mo decidir cu&amp;aacute;l es apropiado para usar en qu&amp;eacute; casos.</target>
        </trans-unit>
        <trans-unit id="dcf9675ca650b7816e93bbac61987240fde0e1c1" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve examined &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and some of the characteristics of smart pointers, let&amp;rsquo;s look at a few other smart pointers defined in the standard library.</source>
          <target state="translated">Ahora que hemos examinado &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y algunas de las caracter&amp;iacute;sticas de los punteros inteligentes, veamos algunos otros punteros inteligentes definidos en la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="1275cf5c5193957df5e8d9870d52448402e96389" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve explored how variables work, let&amp;rsquo;s look at more data types they can have.</source>
          <target state="translated">Ahora que hemos explorado c&amp;oacute;mo funcionan las variables, veamos m&amp;aacute;s tipos de datos que pueden tener.</target>
        </trans-unit>
        <trans-unit id="b53e79d7c3785836a15f4ecfc6aac9abee118b76" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted the logic into &lt;em&gt;src/lib.rs&lt;/em&gt; and left the argument collecting and error handling in &lt;em&gt;src/main.rs&lt;/em&gt;, it&amp;rsquo;s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line. Feel free to write some tests for the functionality in the &lt;code&gt;Config::new&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; functions on your own.</source>
          <target state="translated">Ahora que hemos extra&amp;iacute;do la l&amp;oacute;gica en &lt;em&gt;src / lib.rs&lt;/em&gt; y &lt;em&gt;hemos&lt;/em&gt; dejado la recopilaci&amp;oacute;n de argumentos y el manejo de errores en &lt;em&gt;src / main.rs&lt;/em&gt; , es mucho m&amp;aacute;s f&amp;aacute;cil escribir pruebas para la funcionalidad principal de nuestro c&amp;oacute;digo. Podemos llamar a funciones directamente con varios argumentos y verificar los valores de retorno sin tener que llamar a nuestro binario desde la l&amp;iacute;nea de comando. Si&amp;eacute;ntase libre de escribir algunas pruebas para la funcionalidad en &lt;code&gt;Config::new&lt;/code&gt; y &lt;code&gt;run&lt;/code&gt; funciones por su cuenta.</target>
        </trans-unit>
        <trans-unit id="2a08eff4bb167e5da1e95f954b1304af56f21965" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve finished refactoring the configuration parsing, let&amp;rsquo;s turn to the program&amp;rsquo;s logic. As we stated in &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separation of Concerns for Binary Projects&amp;rdquo;&lt;/a&gt;, we&amp;rsquo;ll extract a function named &lt;code&gt;run&lt;/code&gt; that will hold all the logic currently in the &lt;code&gt;main&lt;/code&gt; function that isn&amp;rsquo;t involved with setting up configuration or handling errors. When we&amp;rsquo;re done, &lt;code&gt;main&lt;/code&gt; will be concise and easy to verify by inspection, and we&amp;rsquo;ll be able to write tests for all the other logic.</source>
          <target state="translated">Ahora que hemos terminado de refactorizar el an&amp;aacute;lisis de la configuraci&amp;oacute;n, pasemos a la l&amp;oacute;gica del programa. Como dijimos en &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separaci&amp;oacute;n de preocupaciones para proyectos binarios&amp;rdquo;&lt;/a&gt; , extraeremos una funci&amp;oacute;n llamada &lt;code&gt;run&lt;/code&gt; que contendr&amp;aacute; toda la l&amp;oacute;gica actualmente en la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; que no est&amp;aacute; involucrada con la configuraci&amp;oacute;n o el manejo de errores. Cuando terminemos, &lt;code&gt;main&lt;/code&gt; ser&amp;aacute; conciso y f&amp;aacute;cil de verificar mediante inspecci&amp;oacute;n, y podremos escribir pruebas para el resto de la l&amp;oacute;gica.</target>
        </trans-unit>
        <trans-unit id="67636ff52e1a7401207e61d89497c3656085f595" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve improved the expressiveness of our I/O project, let&amp;rsquo;s look at some more features of &lt;code&gt;cargo&lt;/code&gt; that will help us share the project with the world.</source>
          <target state="translated">Ahora que hemos mejorado la expresividad de nuestro proyecto de E / S, veamos algunas caracter&amp;iacute;sticas m&amp;aacute;s de la &lt;code&gt;cargo&lt;/code&gt; que nos ayudar&amp;aacute;n a compartir el proyecto con el mundo.</target>
        </trans-unit>
        <trans-unit id="f8c732cbf77e2073635c5b38e31310fafb9b6c1e" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the &lt;code&gt;filter&lt;/code&gt; iterator adaptor. The &lt;code&gt;filter&lt;/code&gt; method on an iterator takes a closure that takes each item from the iterator and returns a Boolean. If the closure returns &lt;code&gt;true&lt;/code&gt;, the value will be included in the iterator produced by &lt;code&gt;filter&lt;/code&gt;. If the closure returns &lt;code&gt;false&lt;/code&gt;, the value won&amp;rsquo;t be included in the resulting iterator.</source>
          <target state="translated">Ahora que hemos introducido iteradores, podemos demostrar un uso com&amp;uacute;n de cierres que capturan su entorno mediante el uso del adaptador de iterador de &lt;code&gt;filter&lt;/code&gt; . El m&amp;eacute;todo de &lt;code&gt;filter&lt;/code&gt; en un iterador toma un cierre que toma cada elemento del iterador y devuelve un booleano. Si el cierre devuelve &lt;code&gt;true&lt;/code&gt; , el valor se incluir&amp;aacute; en el iterador producido por el &lt;code&gt;filter&lt;/code&gt; . Si el cierre devuelve &lt;code&gt;false&lt;/code&gt; , el valor no se incluir&amp;aacute; en el iterador resultante.</target>
        </trans-unit>
        <trans-unit id="0f5c8cc4166bf098c054b91aa56eafdd80a280aa" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve looked at how channels work, let&amp;rsquo;s look at a different method of concurrency.</source>
          <target state="translated">Ahora que hemos visto c&amp;oacute;mo funcionan los canales, veamos un m&amp;eacute;todo diferente de concurrencia.</target>
        </trans-unit>
        <trans-unit id="67653a6049372ba09d60cbd375a44f6c3cccaf9a" translate="yes" xml:space="preserve">
          <source>Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module as it allows catching a panic and then re-using the environment of the closure.</source>
          <target state="translated">Ahora que tenemos una idea de lo que es la seguridad para relajarse en Rust, tambi&amp;eacute;n es importante comprender lo que representa este rasgo. Como se mencion&amp;oacute; anteriormente, una forma de presenciar invariantes rotos es a trav&amp;eacute;s de la funci&amp;oacute;n &lt;code&gt;catch_unwind&lt;/code&gt; en este m&amp;oacute;dulo, ya que permite atrapar un p&amp;aacute;nico y luego reutilizar el entorno del cierre.</target>
        </trans-unit>
        <trans-unit id="d02969884890c4347910c461b721cc439357c5a4" translate="yes" xml:space="preserve">
          <source>Now that you have an account, let&amp;rsquo;s say you have a crate you want to publish. Before publishing, you&amp;rsquo;ll need to add some metadata to your crate by adding it to the &lt;code&gt;[package]&lt;/code&gt; section of the crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Ahora que tiene una cuenta, digamos que tiene una caja que desea publicar. Antes de publicar, deber&amp;aacute; agregar algunos metadatos a su caja agreg&amp;aacute;ndolos a la secci&amp;oacute;n &lt;code&gt;[package]&lt;/code&gt; del archivo &lt;em&gt;Cargo.toml&lt;/em&gt; de la caja .</target>
        </trans-unit>
        <trans-unit id="09f54035802dcb8ec1dd44caa3ea32209f58c20d" translate="yes" xml:space="preserve">
          <source>Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we&amp;rsquo;ve annotated the types of the values that are returned from these functions for extra clarity.</source>
          <target state="translated">Ahora que sabe c&amp;oacute;mo crear, actualizar y destruir vectores, saber leer su contenido es un buen paso siguiente. Hay dos formas de hacer referencia a un valor almacenado en un vector. En los ejemplos, hemos anotado los tipos de valores que se devuelven desde estas funciones para mayor claridad.</target>
        </trans-unit>
        <trans-unit id="81f4f18161b98344a0f7e41a60ca860036728be7" translate="yes" xml:space="preserve">
          <source>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</source>
          <target state="translated">Ahora que sabe cómo definir e implementar los rasgos,podemos explorar cómo utilizarlos para definir funciones que acepten muchos tipos diferentes.</target>
        </trans-unit>
        <trans-unit id="abb4d086b7b2c677929b00ae06d7123ecd180a15" translate="yes" xml:space="preserve">
          <source>Now that you know how to specify the behavior you want to use using the generic type parameter&amp;rsquo;s bounds, let&amp;rsquo;s return to Listing 10-5 to fix the definition of the &lt;code&gt;largest&lt;/code&gt; function that uses a generic type parameter! Last time we tried to run that code, we received this error:</source>
          <target state="translated">Ahora que sabe c&amp;oacute;mo especificar el comportamiento que desea usar usando los l&amp;iacute;mites del par&amp;aacute;metro de tipo gen&amp;eacute;rico, regresemos al Listado 10-5 para corregir la definici&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; que usa un par&amp;aacute;metro de tipo gen&amp;eacute;rico. La &amp;uacute;ltima vez que intentamos ejecutar ese c&amp;oacute;digo, recibimos este error:</target>
        </trans-unit>
        <trans-unit id="e396981103292f81034753c73fe592831d9392a8" translate="yes" xml:space="preserve">
          <source>Now that you know several ways to write tests, let&amp;rsquo;s look at what is happening when we run our tests and explore the different options we can use with &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">Ahora que conoce varias formas de escribir pruebas, veamos qu&amp;eacute; sucede cuando ejecutamos nuestras pruebas y exploramos las diferentes opciones que podemos usar con &lt;code&gt;cargo test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e62f4573546a99a0fd5e85dde630775910ab5fc8" translate="yes" xml:space="preserve">
          <source>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&amp;rsquo;s explore generic lifetimes of parameters and return values in the context of functions.</source>
          <target state="translated">Ahora que sabe d&amp;oacute;nde est&amp;aacute; la vida &amp;uacute;til de las referencias y c&amp;oacute;mo Rust analiza la vida &amp;uacute;til para garantizar que las referencias siempre sean v&amp;aacute;lidas, exploremos la vida &amp;uacute;til gen&amp;eacute;rica de los par&amp;aacute;metros y los valores de retorno en el contexto de las funciones.</target>
        </trans-unit>
        <trans-unit id="30a6477678dd7180d7e0d481486280f7e98fefae" translate="yes" xml:space="preserve">
          <source>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&amp;rsquo;s cover all the syntax we can use to create patterns.</source>
          <target state="translated">Ahora que sabe d&amp;oacute;nde usar patrones y la diferencia entre patrones refutables e irrefutables, cubramos toda la sintaxis que podemos usar para crear patrones.</target>
        </trans-unit>
        <trans-unit id="31528a068a5d3a841cff61741fee15a1c0b2479f" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve added the &lt;code&gt;rand&lt;/code&gt; crate to &lt;em&gt;Cargo.toml&lt;/em&gt;, let&amp;rsquo;s start using &lt;code&gt;rand&lt;/code&gt;. The next step is to update &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 2-3.</source>
          <target state="translated">Ahora que ha agregado la caja &lt;code&gt;rand&lt;/code&gt; a &lt;em&gt;Cargo.toml&lt;/em&gt; , comencemos a usar &lt;code&gt;rand&lt;/code&gt; . El siguiente paso es actualizar &lt;em&gt;src / main.rs&lt;/em&gt; , como se muestra en el Listado 2-3.</target>
        </trans-unit>
        <trans-unit id="25f40b5e485b1b15ed8e4d216ebb9b698b979c06" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you&amp;rsquo;re ready to publish! Publishing a crate uploads a specific version to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; for others to use.</source>
          <target state="translated">Ahora que ha creado una cuenta, ha guardado su token de API, ha elegido un nombre para su caja y ha especificado los metadatos necesarios, &amp;iexcl;est&amp;aacute; listo para publicar! Al publicar una caja, se carga una versi&amp;oacute;n espec&amp;iacute;fica en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; para que otros la utilicen.</target>
        </trans-unit>
        <trans-unit id="920c59c826e17db818f515c07dfec7c798d59ee0" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve installed Rust, let&amp;rsquo;s write your first Rust program. It&amp;rsquo;s traditional when learning a new language to write a little program that prints the text &lt;code&gt;Hello, world!&lt;/code&gt; to the screen, so we&amp;rsquo;ll do the same here!</source>
          <target state="translated">Ahora que ha instalado Rust, escriba su primer programa Rust. Cuando se aprende un nuevo idioma, es tradicional escribir un peque&amp;ntilde;o programa que imprima el texto &lt;code&gt;Hello, world!&lt;/code&gt; a la pantalla, &amp;iexcl;as&amp;iacute; que haremos lo mismo aqu&amp;iacute;!</target>
        </trans-unit>
        <trans-unit id="da83ac95984492a0d09f569c59cd96503f2138e1" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen how to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, let&amp;rsquo;s dig into how it works!</source>
          <target state="translated">Ahora que ha visto c&amp;oacute;mo usar &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , &amp;iexcl;profundicemos en c&amp;oacute;mo funciona!</target>
        </trans-unit>
        <trans-unit id="3226e5056b022a9871764bceba61de34cf95da11" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen useful ways that the standard library uses generics with the &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; enums, we&amp;rsquo;ll talk about how generics work and how you can use them in your code.</source>
          <target state="translated">Ahora que ha visto formas &amp;uacute;tiles en que la biblioteca est&amp;aacute;ndar usa gen&amp;eacute;ricos con las enumeraciones &lt;code&gt;Option&lt;/code&gt; y &lt;code&gt;Result&lt;/code&gt; , hablaremos sobre c&amp;oacute;mo funcionan los gen&amp;eacute;ricos y c&amp;oacute;mo puede usarlos en su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="c62551adf3df866d6c2e2a8e1a359461a03ffa45" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen what the test results look like in different scenarios, let&amp;rsquo;s look at some macros other than &lt;code&gt;panic!&lt;/code&gt; that are useful in tests.</source>
          <target state="translated">Ahora que ha visto c&amp;oacute;mo se ven los resultados de la prueba en diferentes escenarios, &amp;iexcl;veamos algunas macros adem&amp;aacute;s del &lt;code&gt;panic!&lt;/code&gt; que son &amp;uacute;tiles en las pruebas.</target>
        </trans-unit>
        <trans-unit id="b7ef50d26b9af16e9b7dc94b8c74f1d0f89a5d4f" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; using a pattern in the &lt;code&gt;let&lt;/code&gt; statement, as discussed in Chapter 18.</source>
          <target state="translated">Ahora, los bloques &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; solo devuelven los valores adecuados para la l&amp;iacute;nea de estado y el nombre de archivo en una tupla; luego usamos la desestructuraci&amp;oacute;n para asignar estos dos valores a &lt;code&gt;status_line&lt;/code&gt; y &lt;code&gt;filename&lt;/code&gt; usando un patr&amp;oacute;n en la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; , como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 18.</target>
        </trans-unit>
        <trans-unit id="4c7125187714db67fed394d49d485e2e00abd4cb" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;search&lt;/code&gt; function should return only the lines that contain &lt;code&gt;query&lt;/code&gt;, and our test should pass. Let&amp;rsquo;s run the test:</source>
          <target state="translated">Ahora la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; deber&amp;iacute;a devolver solo las l&amp;iacute;neas que contienen la &lt;code&gt;query&lt;/code&gt; , y nuestra prueba deber&amp;iacute;a pasar. Ejecutemos la prueba:</target>
        </trans-unit>
        <trans-unit id="522023e5be1135a608b1cd7f8c8337b4cfc43235" translate="yes" xml:space="preserve">
          <source>Now the code will compile! Let&amp;rsquo;s look at the absolute and the relative path and double-check why adding the &lt;code&gt;pub&lt;/code&gt; keyword lets us use these paths in &lt;code&gt;add_to_waitlist&lt;/code&gt; with respect to the privacy rules.</source>
          <target state="translated">&amp;iexcl;Ahora el c&amp;oacute;digo se compilar&amp;aacute;! Veamos la ruta absoluta y relativa y verifiquemos por qu&amp;eacute; agregar la palabra clave &lt;code&gt;pub&lt;/code&gt; nos permite usar estas rutas en &lt;code&gt;add_to_waitlist&lt;/code&gt; con respecto a las reglas de privacidad.</target>
        </trans-unit>
        <trans-unit id="9b0d5ba9ad57069914ace4b7ba7c228161663abb" translate="yes" xml:space="preserve">
          <source>Now the entire program should work! Let&amp;rsquo;s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, &amp;ldquo;frog&amp;rdquo;:</source>
          <target state="translated">&amp;iexcl;Ahora todo el programa deber&amp;iacute;a funcionar! Prob&amp;eacute;moslo, primero con una palabra que deber&amp;iacute;a devolver exactamente una l&amp;iacute;nea del poema de Emily Dickinson, &quot;rana&quot;:</target>
        </trans-unit>
        <trans-unit id="acdcf552dc404df4d014e75904c60498b68c4c55" translate="yes" xml:space="preserve">
          <source>Now the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d34886bdb2d79a108c1eb310a74fea56db9de1" translate="yes" xml:space="preserve">
          <source>Now the expensive calculation is called in only one place, and we&amp;rsquo;re only executing that code where we need the results.</source>
          <target state="translated">Ahora, el c&amp;aacute;lculo costoso se llama en un solo lugar, y solo estamos ejecutando ese c&amp;oacute;digo donde necesitamos los resultados.</target>
        </trans-unit>
        <trans-unit id="e22993365c1cb308452dac73cf5565235b2c67e8" translate="yes" xml:space="preserve">
          <source>Now the program is getting interesting! There&amp;rsquo;s a lot going on in this little line. Notice that this is a &lt;code&gt;let&lt;/code&gt; statement, which is used to create a &lt;em&gt;variable&lt;/em&gt;. Here&amp;rsquo;s another example:</source>
          <target state="translated">&amp;iexcl;Ahora el programa se est&amp;aacute; poniendo interesante! Est&amp;aacute;n sucediendo muchas cosas en esta peque&amp;ntilde;a l&amp;iacute;nea. Tenga en cuenta que esta es una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; , que se usa para crear una &lt;em&gt;variable&lt;/em&gt; . Aqu&amp;iacute; hay otro ejemplo:</target>
        </trans-unit>
        <trans-unit id="9b5e26741b88a54ad8284d61f9e2e51ca7f82268" translate="yes" xml:space="preserve">
          <source>Now the signature indicates that the function data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Alternatively, you could change the body to not return data from &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">Ahora la firma indica que los datos de la funci&amp;oacute;n se tomaron prestados de &lt;code&gt;x&lt;/code&gt; o de &lt;code&gt;y&lt;/code&gt; . Alternativamente, puede cambiar el cuerpo para que no devuelva datos de &lt;code&gt;y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1198ca2a8c86240e1af84c3d28743f89fded1ad" translate="yes" xml:space="preserve">
          <source>Now we can start seeing the advantages of the state pattern: the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; is the same no matter its &lt;code&gt;state&lt;/code&gt; value. Each state is responsible for its own rules.</source>
          <target state="translated">Ahora podemos empezar a ver las ventajas del patr&amp;oacute;n de estado: el m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; en &lt;code&gt;Post&lt;/code&gt; es el mismo sin importar su valor de &lt;code&gt;state&lt;/code&gt; . Cada estado es responsable de sus propias reglas.</target>
        </trans-unit>
        <trans-unit id="0ea1cd6e6626b68365f6c8947fa55d16ff141954" translate="yes" xml:space="preserve">
          <source>Now we get a warning and an error. Ignoring the warning for a moment, the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">Ahora recibimos una advertencia y un error. Ignorando la advertencia por un momento, el error ocurre porque no tenemos un m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; en &lt;code&gt;ThreadPool&lt;/code&gt; . Recuerde de la secci&amp;oacute;n &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&quot;Creaci&amp;oacute;n de una interfaz similar para un n&amp;uacute;mero finito de&lt;/a&gt; subprocesos &quot; que decidimos que nuestro grupo de subprocesos deber&amp;iacute;a tener una interfaz similar a &lt;code&gt;thread::spawn&lt;/code&gt; . Adem&amp;aacute;s, implementaremos la funci&amp;oacute;n de &lt;code&gt;execute&lt;/code&gt; para que tome el cierre que se le da y se lo d&amp;eacute; a un hilo inactivo en el grupo para que se ejecute.</target>
        </trans-unit>
        <trans-unit id="d7705a7f1894fbc9d3a536be0dfea4d6af32a807" translate="yes" xml:space="preserve">
          <source>Now we need to bring the code we moved to &lt;em&gt;src/lib.rs&lt;/em&gt; into the scope of the binary crate in &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 12-14.</source>
          <target state="translated">Ahora necesitamos traer el c&amp;oacute;digo que movimos a &lt;em&gt;src / lib.rs&lt;/em&gt; al alcance de la caja binaria en &lt;em&gt;src / main.rs&lt;/em&gt; , como se muestra en el Listado 12-14.</target>
        </trans-unit>
        <trans-unit id="b54fd4c3b5f78dc6afcacc14a208e5f25a781f43" translate="yes" xml:space="preserve">
          <source>Now we need to update the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt;: if the state is &lt;code&gt;Published&lt;/code&gt;, we want to return the value in the post&amp;rsquo;s &lt;code&gt;content&lt;/code&gt; field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</source>
          <target state="translated">Ahora necesitamos actualizar el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; en la &lt;code&gt;Post&lt;/code&gt; : si el estado es &lt;code&gt;Published&lt;/code&gt; , queremos devolver el valor en el &lt;code&gt;content&lt;/code&gt; la publicaci&amp;oacute;n. campo de ; de lo contrario, queremos devolver un segmento de cadena vac&amp;iacute;o, como se muestra en el Listado 17-17:</target>
        </trans-unit>
        <trans-unit id="6174f1c624d6e6d6e079aee3674396394f363d5b" translate="yes" xml:space="preserve">
          <source>Now we see the error onscreen and &lt;em&gt;output.txt&lt;/em&gt; contains nothing, which is the behavior we expect of command line programs.</source>
          <target state="translated">Ahora vemos el error en pantalla y &lt;em&gt;output.txt&lt;/em&gt; no contiene nada, que es el comportamiento que esperamos de los programas de l&amp;iacute;nea de comandos.</target>
        </trans-unit>
        <trans-unit id="cdda59c39165af59e97381c7390ecfef3d12a8f6" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add functionality to read the file that is specified in the &lt;code&gt;filename&lt;/code&gt; command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure &lt;code&gt;minigrep&lt;/code&gt; is working is one with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called &lt;em&gt;poem.txt&lt;/em&gt; at the root level of your project, and enter the poem &amp;ldquo;I&amp;rsquo;m Nobody! Who are you?&amp;rdquo;</source>
          <target state="translated">Ahora agregaremos funcionalidad para leer el archivo que se especifica en el argumento de la l&amp;iacute;nea de comando del &lt;code&gt;filename&lt;/code&gt; . Primero, necesitamos un archivo de muestra para probarlo: el mejor tipo de archivo para asegurarse de que &lt;code&gt;minigrep&lt;/code&gt; est&amp;aacute; funcionando es uno con una peque&amp;ntilde;a cantidad de texto en varias l&amp;iacute;neas con algunas palabras repetidas. El Listado 12-3 tiene un poema de Emily Dickinson que funcionar&amp;aacute; bien. Cree un archivo llamado &lt;em&gt;poem.txt&lt;/em&gt; en el nivel ra&amp;iacute;z de su proyecto e ingrese el poema &amp;ldquo;&amp;iexcl;No soy nadie! &amp;iquest;Qui&amp;eacute;n eres t&amp;uacute;?&quot;</target>
        </trans-unit>
        <trans-unit id="dd1d31103e62a1ec520be0bcddbbbdb89e976849" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add some types that implement the &lt;code&gt;Draw&lt;/code&gt; trait. We&amp;rsquo;ll provide the &lt;code&gt;Button&lt;/code&gt; type. Again, actually implementing a GUI library is beyond the scope of this book, so the &lt;code&gt;draw&lt;/code&gt; method won&amp;rsquo;t have any useful implementation in its body. To imagine what the implementation might look like, a &lt;code&gt;Button&lt;/code&gt; struct might have fields for &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt;, as shown in Listing 17-7:</source>
          <target state="translated">Ahora agregaremos algunos tipos que implementan el rasgo &lt;code&gt;Draw&lt;/code&gt; . Proporcionaremos el tipo de &lt;code&gt;Button&lt;/code&gt; . Nuevamente, la implementaci&amp;oacute;n de una biblioteca GUI est&amp;aacute; m&amp;aacute;s all&amp;aacute; del alcance de este libro, por lo que el m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; no tendr&amp;aacute; ninguna implementaci&amp;oacute;n &amp;uacute;til en su cuerpo. Para imaginar c&amp;oacute;mo se ver&amp;iacute;a la implementaci&amp;oacute;n, una estructura de &lt;code&gt;Button&lt;/code&gt; podr&amp;iacute;a tener campos para &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; y &lt;code&gt;label&lt;/code&gt; , como se muestra en el Listado 17-7:</target>
        </trans-unit>
        <trans-unit id="e57698dd0ca960cc0b20cbcaaf7560d2276dfedc" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement sending data in response to a client request. Responses have the following format:</source>
          <target state="translated">Ahora implementaremos el env&amp;iacute;o de datos en respuesta a la solicitud de un cliente. Las respuestas tienen el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="faa7223d94f8959f76182c7251992c3581bab825" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement the &lt;code&gt;Drop&lt;/code&gt; trait to call &lt;code&gt;join&lt;/code&gt; on each of the threads in the pool so they can finish the requests they&amp;rsquo;re working on before closing. Then we&amp;rsquo;ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we&amp;rsquo;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</source>
          <target state="translated">Ahora implementaremos el rasgo &lt;code&gt;Drop&lt;/code&gt; para llamar a &lt;code&gt;join&lt;/code&gt; en cada uno de los hilos del grupo para que puedan finalizar las solicitudes en las que est&amp;aacute;n trabajando antes de cerrar. Luego, implementaremos una forma de decirle a los subprocesos que deben dejar de aceptar nuevas solicitudes y cerrarse. Para ver este c&amp;oacute;digo en acci&amp;oacute;n, modificaremos nuestro servidor para que acepte solo dos solicitudes antes de cerrar con gracia su grupo de subprocesos.</target>
        </trans-unit>
        <trans-unit id="f36ce7a9b5e2c1e7eedfaeab844cfb65b78a49c0" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll tackle the problem that the closures given to &lt;code&gt;thread::spawn&lt;/code&gt; do absolutely nothing. Currently, we get the closure we want to execute in the &lt;code&gt;execute&lt;/code&gt; method. But we need to give &lt;code&gt;thread::spawn&lt;/code&gt; a closure to run when we create each &lt;code&gt;Worker&lt;/code&gt; during the creation of the &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">Ahora abordaremos el problema de que los cierres dados a &lt;code&gt;thread::spawn&lt;/code&gt; no hacen absolutamente nada. Actualmente, obtenemos el cierre que queremos ejecutar en el m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; . Pero necesitamos darle a &lt;code&gt;thread::spawn&lt;/code&gt; un cierre para que se ejecute cuando creamos cada &lt;code&gt;Worker&lt;/code&gt; durante la creaci&amp;oacute;n del &lt;code&gt;ThreadPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ff72d33ea4877ceb607d0497b7819ecb5fe8345" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll work on fixing our error handling. Recall that attempting to access the values in the &lt;code&gt;args&lt;/code&gt; vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</source>
          <target state="translated">Ahora trabajaremos para corregir nuestro manejo de errores. Recuerde que intentar acceder a los valores en el vector &lt;code&gt;args&lt;/code&gt; en el &amp;iacute;ndice 1 o en el &amp;iacute;ndice 2 har&amp;aacute; que el programa entre en p&amp;aacute;nico si el vector contiene menos de tres elementos. Intente ejecutar el programa sin argumentos; se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="13208408fb234a6274c662e0cea2839eb0d4df4f" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re tracking a starting &lt;em&gt;and&lt;/em&gt; an ending index, and we have even more values that were calculated from data in a particular state but aren&amp;rsquo;t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.</source>
          <target state="translated">Ahora estamos rastreando un &amp;iacute;ndice inicial &lt;em&gt;y&lt;/em&gt; final, y tenemos incluso m&amp;aacute;s valores que se calcularon a partir de datos en un estado particular, pero que no est&amp;aacute;n vinculados a ese estado en absoluto. Ahora tenemos tres variables no relacionadas flotando alrededor que deben mantenerse sincronizadas.</target>
        </trans-unit>
        <trans-unit id="e2c6d85ff7e11c55ebfacf4a5ea15b76883f9037" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;first_word&lt;/code&gt;, we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</source>
          <target state="translated">Ahora, cuando llamamos a &lt;code&gt;first_word&lt;/code&gt; , obtenemos un valor &amp;uacute;nico que est&amp;aacute; vinculado a los datos subyacentes. El valor se compone de una referencia al punto de inicio del sector y el n&amp;uacute;mero de elementos del sector.</target>
        </trans-unit>
        <trans-unit id="ae56f18fed45d04e5e1b1341584607fec330d0c6" translate="yes" xml:space="preserve">
          <source>Now when we run the program, we won&amp;rsquo;t get any errors, and we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Ahora, cuando ejecutemos el programa, no obtendremos ning&amp;uacute;n error y veremos el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="a1e40e49d7c93a75ee26e23465f603f6bbef3e57" translate="yes" xml:space="preserve">
          <source>Now when we run the test, we&amp;rsquo;ll get a more informative error message:</source>
          <target state="translated">Ahora, cuando ejecutemos la prueba, obtendremos un mensaje de error m&amp;aacute;s informativo:</target>
        </trans-unit>
        <trans-unit id="77f2a1a56e2b0bc8d28e09777d58b6d63d25bdc8" translate="yes" xml:space="preserve">
          <source>Now you know how the newtype pattern is used in relation to traits; it&amp;rsquo;s also a useful pattern even when traits are not involved. Let&amp;rsquo;s switch focus and look at some advanced ways to interact with Rust&amp;rsquo;s type system.</source>
          <target state="translated">Ahora sabe c&amp;oacute;mo se usa el patr&amp;oacute;n newtype en relaci&amp;oacute;n con los rasgos; tambi&amp;eacute;n es un patr&amp;oacute;n &amp;uacute;til incluso cuando los rasgos no est&amp;aacute;n involucrados. Cambiemos de enfoque y veamos algunas formas avanzadas de interactuar con el sistema de tipos de Rust.</target>
        </trans-unit>
        <trans-unit id="698e184c44b77b78a4f0259358fd0568a9ef42f1" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;foo()&lt;/code&gt; can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call &lt;code&gt;foo()&lt;/code&gt; on types implementing that trait that aren't behind trait objects.</source>
          <target state="translated">Ahora, ya no se puede llamar a &lt;code&gt;foo()&lt;/code&gt; en un objeto de rasgo, pero ahora se le permitir&amp;aacute; hacer un objeto de rasgo, que podr&amp;aacute; llamar a cualquier m&amp;eacute;todo seguro para objetos. Con tal l&amp;iacute;mite, todav&amp;iacute;a se puede llamar a &lt;code&gt;foo()&lt;/code&gt; en tipos que implementan ese rasgo que no est&amp;aacute;n detr&amp;aacute;s de los objetos de rasgo.</target>
        </trans-unit>
        <trans-unit id="e2eab767e7fabf7d41783d8a69e9cbea73a62c87" translate="yes" xml:space="preserve">
          <source>Now, every time you call &lt;code&gt;rustc&lt;/code&gt; or &lt;code&gt;cargo&lt;/code&gt; inside of &lt;em&gt;~/projects/needs-nightly&lt;/em&gt;, &lt;code&gt;rustup&lt;/code&gt; will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</source>
          <target state="translated">Ahora, cada vez que llame a &lt;code&gt;rustc&lt;/code&gt; o &lt;code&gt;cargo&lt;/code&gt; dentro de &lt;em&gt;~ / projects / needs-nightly&lt;/em&gt; , &lt;code&gt;rustup&lt;/code&gt; se asegurar&amp;aacute; de que est&amp;eacute; usando Rust nocturno, en lugar de su predeterminado de Rust estable. &amp;iexcl;Esto es &amp;uacute;til cuando tienes muchos proyectos de Rust!</target>
        </trans-unit>
        <trans-unit id="e79236607753f413c66ac854a24fa640c09a981f" translate="yes" xml:space="preserve">
          <source>Now, if we have the following code:</source>
          <target state="translated">Ahora,si tenemos el siguiente código:</target>
        </trans-unit>
        <trans-unit id="8bfc390ee5863dbfd9bc2b1fac71150d32bafb63" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&amp;rsquo;ll use those errors to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly. Listing 16-13 has our starting example:</source>
          <target state="translated">Ahora, intentemos compartir un valor entre varios hilos usando &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; . Haremos girar 10 subprocesos y cada uno de ellos incrementar&amp;aacute; un valor de contador en 1, por lo que el contador va de 0 a 10. Tenga en cuenta que los siguientes ejemplos tendr&amp;aacute;n errores de compilador, y usaremos esos errores para aprender m&amp;aacute;s sobre el uso &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; y c&amp;oacute;mo Rust nos ayuda a usarlo correctamente. El listado 16-13 tiene nuestro ejemplo inicial:</target>
        </trans-unit>
        <trans-unit id="12a0ede889bbdab76f8ecdca9c8b3f108a1224a8" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we&amp;rsquo;ll use that error to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4684dc088b34ae2083e2057208489a24262c5c09" translate="yes" xml:space="preserve">
          <source>Now, run this program using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">Ahora, ejecute este programa usando &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f63a9b785af57bd0365b9cf3f0ad0d87a3314b8" translate="yes" xml:space="preserve">
          <source>Now, the alias &lt;code&gt;Kilometers&lt;/code&gt; is a &lt;em&gt;synonym&lt;/em&gt; for &lt;code&gt;i32&lt;/code&gt;; unlike the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; types we created in Listing 19-15, &lt;code&gt;Kilometers&lt;/code&gt; is not a separate, new type. Values that have the type &lt;code&gt;Kilometers&lt;/code&gt; will be treated the same as values of type &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">Ahora, el alias &lt;code&gt;Kilometers&lt;/code&gt; es &lt;em&gt;sin&amp;oacute;nimo&lt;/em&gt; de &lt;code&gt;i32&lt;/code&gt; ; a diferencia de los tipos &lt;code&gt;Millimeters&lt;/code&gt; y &lt;code&gt;Meters&lt;/code&gt; que creamos en el Listado 19-15, &lt;code&gt;Kilometers&lt;/code&gt; no es un tipo nuevo separado. Los valores que tienen el tipo &lt;code&gt;Kilometers&lt;/code&gt; se tratar&amp;aacute;n de la misma manera que los valores del tipo &lt;code&gt;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89254150c2be7dc87d0a9f78d979708d51af3c47" translate="yes" xml:space="preserve">
          <source>Now, we can go further. Here are some erroneous code examples:</source>
          <target state="translated">Ahora,podemos ir más lejos.Aquí hay algunos ejemplos de códigos erróneos:</target>
        </trans-unit>
        <trans-unit id="0a10d92135d2873e2b02f8fce9c6f1692a0cbb60" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;?&lt;/code&gt; instead of &lt;code&gt;match&lt;/code&gt;, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred. We don't even have to wrap the loop in an &lt;code&gt;Ok&lt;/code&gt; because &lt;code&gt;!&lt;/code&gt; coerces to &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; automatically.</source>
          <target state="translated">Ahora, podemos usar &lt;code&gt;?&lt;/code&gt; en lugar de &lt;code&gt;match&lt;/code&gt; , y el tipo de retorno tiene mucho m&amp;aacute;s sentido: si el bucle se detiene alguna vez, significa que se produjo un error. &amp;iexcl;Ni siquiera tenemos que envolver el bucle en un &lt;code&gt;Ok&lt;/code&gt; porque &lt;code&gt;!&lt;/code&gt; coacciona a &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="00574ee534bf3b794cc8e985f367f79be7646f65" translate="yes" xml:space="preserve">
          <source>Now, when the server disconnects, we exit the loop with an error instead of panicking. While it might be intuitive to simply return the error, we might want to wrap it in a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Ahora, cuando el servidor se desconecta, salimos del ciclo con un error en lugar de entrar en p&amp;aacute;nico. Si bien puede ser intuitivo simplemente devolver el error, es posible que deseemos envolverlo en un &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; lugar:</target>
        </trans-unit>
        <trans-unit id="63f5d491af12e32408bf602e1dfb4af7a20ca44f" translate="yes" xml:space="preserve">
          <source>Now, without changing any of the code, let&amp;rsquo;s build the project, as shown in Listing 2-2.</source>
          <target state="translated">Ahora, sin cambiar nada del c&amp;oacute;digo, construyamos el proyecto, como se muestra en el Listado 2-2.</target>
        </trans-unit>
        <trans-unit id="335506e2ff8a4e3e39e5a5e2b3fc6bf1463c0bb5" translate="yes" xml:space="preserve">
          <source>Now, you get all of the default values. Rust implements &lt;code&gt;Default&lt;/code&gt; for various primitives types.</source>
          <target state="translated">Ahora, obtiene todos los valores predeterminados. Rust implementa &lt;code&gt;Default&lt;/code&gt; para varios tipos de primitivas.</target>
        </trans-unit>
        <trans-unit id="019a7808328d4c7ef510130b49858e7cc7a93df4" translate="yes" xml:space="preserve">
          <source>NulError</source>
          <target state="translated">NulError</target>
        </trans-unit>
        <trans-unit id="0cb22fef16057827ecc4973a05f1f48159ecfb08" translate="yes" xml:space="preserve">
          <source>NulError::borrow</source>
          <target state="translated">NulError::borrow</target>
        </trans-unit>
        <trans-unit id="093c6ad11b2674276a386aef18e019c41e18c73d" translate="yes" xml:space="preserve">
          <source>NulError::borrow_mut</source>
          <target state="translated">NulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2212c8b5028758465c03e3f70e4f2b53155ddf4f" translate="yes" xml:space="preserve">
          <source>NulError::cause</source>
          <target state="translated">NulError::cause</target>
        </trans-unit>
        <trans-unit id="29768f5bfd32a963dcb296b9cb20f40a82c74df5" translate="yes" xml:space="preserve">
          <source>NulError::clone</source>
          <target state="translated">NulError::clone</target>
        </trans-unit>
        <trans-unit id="11102afce6dc8292dc39655665283f8191fb13f1" translate="yes" xml:space="preserve">
          <source>NulError::clone_from</source>
          <target state="translated">NulError::clone_from</target>
        </trans-unit>
        <trans-unit id="f533f8602af54aaa16eff696d1575d42e14848a1" translate="yes" xml:space="preserve">
          <source>NulError::clone_into</source>
          <target state="translated">NulError::clone_into</target>
        </trans-unit>
        <trans-unit id="dbdb7cc3a8e4e6691a99909b0fc53de13cd8f2d3" translate="yes" xml:space="preserve">
          <source>NulError::description</source>
          <target state="translated">NulError::description</target>
        </trans-unit>
        <trans-unit id="90a567cb98b0dcdd50aff9ea97e9fff9eaab566d" translate="yes" xml:space="preserve">
          <source>NulError::eq</source>
          <target state="translated">NulError::eq</target>
        </trans-unit>
        <trans-unit id="5a4bafcb93f1795790aaa47109d1e73bf1dc48ee" translate="yes" xml:space="preserve">
          <source>NulError::fmt</source>
          <target state="translated">NulError::fmt</target>
        </trans-unit>
        <trans-unit id="fea70f345cef208acafc3c691d14a34ddbaffb2c" translate="yes" xml:space="preserve">
          <source>NulError::from</source>
          <target state="translated">NulError::from</target>
        </trans-unit>
        <trans-unit id="c667a60cc8a552cdd2774d6820e70ba3a6f7fa11" translate="yes" xml:space="preserve">
          <source>NulError::into</source>
          <target state="translated">NulError::into</target>
        </trans-unit>
        <trans-unit id="30b7683d9cdd43993a6fc1126ff7ee715887f7b2" translate="yes" xml:space="preserve">
          <source>NulError::into_vec</source>
          <target state="translated">NulError::into_vec</target>
        </trans-unit>
        <trans-unit id="0a051a00c0c437269ea80583c284491216e4bda7" translate="yes" xml:space="preserve">
          <source>NulError::ne</source>
          <target state="translated">NulError::ne</target>
        </trans-unit>
        <trans-unit id="2853d8c78438f77254b0a497c86fde1fc17dc043" translate="yes" xml:space="preserve">
          <source>NulError::nul_position</source>
          <target state="translated">NulError::nul_position</target>
        </trans-unit>
        <trans-unit id="266ad98111087a4df9e19e655c096e1306270de2" translate="yes" xml:space="preserve">
          <source>NulError::source</source>
          <target state="translated">NulError::source</target>
        </trans-unit>
        <trans-unit id="5a34a4566a411696ebf16a2b9ec49441272c8c0b" translate="yes" xml:space="preserve">
          <source>NulError::to_owned</source>
          <target state="translated">NulError::to_owned</target>
        </trans-unit>
        <trans-unit id="657290a7e7bc42a0480eee65c34175ba47172560" translate="yes" xml:space="preserve">
          <source>NulError::to_string</source>
          <target state="translated">NulError::to_string</target>
        </trans-unit>
        <trans-unit id="d1202df6e66660732652af8ec880ff1ae89ff7c3" translate="yes" xml:space="preserve">
          <source>NulError::try_from</source>
          <target state="translated">NulError::try_from</target>
        </trans-unit>
        <trans-unit id="1d16960d944bfade9db6cf467b0e67afd7e5faaf" translate="yes" xml:space="preserve">
          <source>NulError::try_into</source>
          <target state="translated">NulError::try_into</target>
        </trans-unit>
        <trans-unit id="1f3e1c8599374779dd8128ca0f06731901b2e4e4" translate="yes" xml:space="preserve">
          <source>NulError::type_id</source>
          <target state="translated">NulError::type_id</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="a7321f8049c14a666fefc1ca42149346db408d7b" translate="yes" xml:space="preserve">
          <source>Null-unchecked version</source>
          <target state="translated">Versión no revisada</target>
        </trans-unit>
        <trans-unit id="2276df81ba459368e74bc9d4361d3c8cfd09f1df" translate="yes" xml:space="preserve">
          <source>Nullable pointers</source>
          <target state="translated">Indicadores anulables</target>
        </trans-unit>
        <trans-unit id="c25cad253b19d0908d73f07b038e8b9aad37e183" translate="yes" xml:space="preserve">
          <source>Number literals</source>
          <target state="translated">Número de literales</target>
        </trans-unit>
        <trans-unit id="bcec75d4dad01d7ef8298e79673d17da682b5ff9" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2.</source>
          <target state="translated">Número de dígitos significativos en la base 2.</target>
        </trans-unit>
        <trans-unit id="2805eca363fc3f5bc17c10d2663c97e212a66b12" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12801815bc7acefa87d6f150e6c4da3f8cfc4e2c" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="21e67f90f74a7a640f48c34557cd9804c3bb16bf" translate="yes" xml:space="preserve">
          <source>Numeric Operations</source>
          <target state="translated">Operaciones numéricas</target>
        </trans-unit>
        <trans-unit id="46e7eddaee58aa04d38eef7cd137db7696751094" translate="yes" xml:space="preserve">
          <source>Numeric cast</source>
          <target state="translated">Lanzamiento numérico</target>
        </trans-unit>
        <trans-unit id="5fc7eba5de8d1ad8c7f788326b72adec568ef6c6" translate="yes" xml:space="preserve">
          <source>Numeric literal of specific type</source>
          <target state="translated">Literal numérico de tipo específico</target>
        </trans-unit>
        <trans-unit id="1569010f07b1014b3cf4df2495e2025b598353cd" translate="yes" xml:space="preserve">
          <source>Numeric type</source>
          <target state="translated">Tipo numérico</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">Tipos numéricos</target>
        </trans-unit>
        <trans-unit id="448f04fec46467e790879ea8707bb67f916a6de0" translate="yes" xml:space="preserve">
          <source>Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.</source>
          <target state="translated">Los valores numéricos utilizados en este tipo no tienen significados portátiles,y las diferentes plataformas pueden enmascarar diferentes cantidades de ellos.</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="41a98fdd88fe9c4cdb77aa3ef162d2e340554b26" translate="yes" xml:space="preserve">
          <source>O(1)~</source>
          <target state="translated">O(1)~</target>
        </trans-unit>
        <trans-unit id="aae47a530dc867303fbce9c5d00c60595dd72df2" translate="yes" xml:space="preserve">
          <source>O(1)~*</source>
          <target state="translated">O(1)~*</target>
        </trans-unit>
        <trans-unit id="21c63d891edf29bd0dc5694a68dc0fe5e6523174" translate="yes" xml:space="preserve">
          <source>O(log n)</source>
          <target state="translated">O(log n)</target>
        </trans-unit>
        <trans-unit id="e74f9c141120b2be3e1dcb28f8561ddce1e8fcd1" translate="yes" xml:space="preserve">
          <source>O(log(n))</source>
          <target state="translated">O(log(n))</target>
        </trans-unit>
        <trans-unit id="eed5a0c9d789f93df61247fbcb2bb3a3c20ad0c2" translate="yes" xml:space="preserve">
          <source>O(m)*</source>
          <target state="translated">O(m)*</target>
        </trans-unit>
        <trans-unit id="0a498ed9d22d1c99ae0662d3eb2e582169c852e2" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))</source>
          <target state="translated">O(min(i,n-i))</target>
        </trans-unit>
        <trans-unit id="dede0f12fa78bfb74f3fa2188214d44df32644d9" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))*</source>
          <target state="translated">O(min(i,n-i))*</target>
        </trans-unit>
        <trans-unit id="1eb19fcfc5873ac1d44e4d58ddd8518a66a4491a" translate="yes" xml:space="preserve">
          <source>O(n+m)</source>
          <target state="translated">O(n+m)</target>
        </trans-unit>
        <trans-unit id="c8fadbf37575cb84317acb6f8d4f3d46463f8753" translate="yes" xml:space="preserve">
          <source>O(n-i)</source>
          <target state="translated">O(n-i)</target>
        </trans-unit>
        <trans-unit id="cc8b4f2a60d0d1f3741e6ca4292cce74adf6d07a" translate="yes" xml:space="preserve">
          <source>O(n-i)*</source>
          <target state="translated">O(n-i)*</target>
        </trans-unit>
        <trans-unit id="40df041793dd78f66b71a0840b6daf38640d0a3a" translate="yes" xml:space="preserve">
          <source>OCT_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;]</source>
          <target state="translated">OCT_DIGIT: [ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2458dc9d400f320af963a0c090896d1bb8a3eafb" translate="yes" xml:space="preserve">
          <source>OCT_LITERAL :</source>
          <target state="translated">OCT_LITERAL :</target>
        </trans-unit>
        <trans-unit id="7eefb54fc6fa85bcfd8cad8fd3e002943372f832" translate="yes" xml:space="preserve">
          <source>ONCE_INIT</source>
          <target state="translated">ONCE_INIT</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="7367af2af477750e5937879b87fd589c058636c7" translate="yes" xml:space="preserve">
          <source>OS-specific behaviors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c616ed05e5cb0d4373e277ab3e8348ce34b627e9" translate="yes" xml:space="preserve">
          <source>OS-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Extensiones espec&amp;iacute;ficas del sistema operativo para &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d40770bb8444e5820c3f38469b205f65cc11cae4" translate="yes" xml:space="preserve">
          <source>OS-specific functionality.</source>
          <target state="translated">Funcionalidad específica del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="a6c434024b24606a906b9f03f39592fffa3be309" translate="yes" xml:space="preserve">
          <source>OUTER_BLOCK_DOC :</source>
          <target state="translated">BLOQUE_EXTERNO_DOC :</target>
        </trans-unit>
        <trans-unit id="0bb940376a39f5fb9ff8c9b1c3a635c5bc777eb9" translate="yes" xml:space="preserve">
          <source>OUTER_LINE_DOC :</source>
          <target state="translated">LÍNEA_EXTERIOR_DOC :</target>
        </trans-unit>
        <trans-unit id="497044c1c5d284e50b6c69945072ebc9add34281" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming Features of Rust</source>
          <target state="translated">Características de la programación orientada a objetos del óxido</target>
        </trans-unit>
        <trans-unit id="1cd60d3a8e30cd469c24d35e86095d88eed38ea9" translate="yes" xml:space="preserve">
          <source>Object Safety</source>
          <target state="translated">Seguridad de los objetos</target>
        </trans-unit>
        <trans-unit id="907637cc210857e2030448d19632670732a6954a" translate="yes" xml:space="preserve">
          <source>Object Safety Is Required for Trait Objects</source>
          <target state="translated">La seguridad de los objetos es necesaria para los objetos de carácter</target>
        </trans-unit>
        <trans-unit id="bca6b9d231b55a9e6e8a10f5e5322c009f386439" translate="yes" xml:space="preserve">
          <source>Object safe traits</source>
          <target state="translated">Rasgos de seguridad de objetos</target>
        </trans-unit>
        <trans-unit id="c0123c00fdac3367f93d574c1f48635a32708f0d" translate="yes" xml:space="preserve">
          <source>Object safe traits can be the base trait of a &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;. A trait is &lt;em&gt;object safe&lt;/em&gt; if it has the following qualities (defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt;):</source>
          <target state="translated">Los rasgos seguros del objeto pueden ser el rasgo b&amp;aacute;sico de un &lt;a href=&quot;../types/trait-object&quot;&gt;objeto rasgo&lt;/a&gt; . Un rasgo es &lt;em&gt;seguro para objetos&lt;/em&gt; si tiene las siguientes cualidades (definidas en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="23297e036939da16d72f8c944d8900bfb5bf3104" translate="yes" xml:space="preserve">
          <source>Object-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay&amp;rsquo;s programming architecture in which objects pass messages to each other. He coined the term &lt;em&gt;object-oriented programming&lt;/em&gt; in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we&amp;rsquo;ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We&amp;rsquo;ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust&amp;rsquo;s strengths instead.</source>
          <target state="translated">La programaci&amp;oacute;n orientada a objetos (OOP) es una forma de modelar programas. Los objetos vinieron de Simula en la d&amp;eacute;cada de 1960. Esos objetos influyeron en la arquitectura de programaci&amp;oacute;n de Alan Kay en la que los objetos se transmiten mensajes entre s&amp;iacute;. &amp;Eacute;l acu&amp;ntilde;&amp;oacute; el t&amp;eacute;rmino &lt;em&gt;programaci&amp;oacute;n orientada a objetos&lt;/em&gt; en 1967 para describir esta arquitectura. Muchas definiciones en competencia describen qu&amp;eacute; es la POO; algunas definiciones clasificar&amp;iacute;an a Rust como orientado a objetos, pero otras definiciones no. En este cap&amp;iacute;tulo, exploraremos ciertas caracter&amp;iacute;sticas que com&amp;uacute;nmente se consideran orientadas a objetos y c&amp;oacute;mo esas caracter&amp;iacute;sticas se traducen en Rust idiom&amp;aacute;tico. Luego, le mostraremos c&amp;oacute;mo implementar un patr&amp;oacute;n de dise&amp;ntilde;o orientado a objetos en Rust y discutiremos las ventajas y desventajas de hacerlo frente a implementar una soluci&amp;oacute;n utilizando algunas de las fortalezas de Rust.</target>
        </trans-unit>
        <trans-unit id="93a2f7998a1b0abd936ff0b0c2f570cbbedd6635" translate="yes" xml:space="preserve">
          <source>Object-oriented programs are made up of objects. An &lt;em&gt;object&lt;/em&gt; packages both data and the procedures that operate on that data. The procedures are typically called &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;operations&lt;/em&gt;.</source>
          <target state="translated">Los programas orientados a objetos se componen de objetos. Un &lt;em&gt;objeto&lt;/em&gt; empaqueta tanto los datos como los procedimientos que operan sobre esos datos. Los procedimientos se denominan normalmente &lt;em&gt;m&amp;eacute;todos&lt;/em&gt; u &lt;em&gt;operaciones&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69fa88294fcaac54902a4347d53a07e91ef5771c" translate="yes" xml:space="preserve">
          <source>Objects Contain Data and Behavior</source>
          <target state="translated">Los objetos contienen datos y comportamiento</target>
        </trans-unit>
        <trans-unit id="d206d3fa18be5581f351f10db48f9bf4a1014628" translate="yes" xml:space="preserve">
          <source>Objects that can be stepped over in both directions.</source>
          <target state="translated">Objetos que pueden ser pisados en ambas direcciones.</target>
        </trans-unit>
        <trans-unit id="c6ec1c4f32b6ec8b2dd6c5acb228ddee1480f8b1" translate="yes" xml:space="preserve">
          <source>Objects that have a notion of &lt;em&gt;successor&lt;/em&gt; and &lt;em&gt;predecessor&lt;/em&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b899f01274e7bc44fb14d411dd765a15a7787c5f" translate="yes" xml:space="preserve">
          <source>Occasionally it may be desirable not to expose in an API that there is mutation happening &quot;under the hood&quot;. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">Ocasionalmente, puede ser deseable no exponer en una API que se est&amp;aacute; produciendo una mutaci&amp;oacute;n &quot;debajo del cap&amp;oacute;&quot;. Esto puede deberse a que, l&amp;oacute;gicamente, la operaci&amp;oacute;n es inmutable, pero, por ejemplo, el almacenamiento en cach&amp;eacute; obliga a la implementaci&amp;oacute;n a realizar una mutaci&amp;oacute;n; o porque debe emplear la mutaci&amp;oacute;n para implementar un m&amp;eacute;todo de rasgo que originalmente se defini&amp;oacute; para tomar &lt;code&gt;&amp;amp;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="473e728a2f59da64c670799897819b1d614ba35f" translate="yes" xml:space="preserve">
          <source>OccupiedEntry</source>
          <target state="translated">OccupiedEntry</target>
        </trans-unit>
        <trans-unit id="9d9953ee64c9a9ed960498f1a51e79c8aae9c8dd" translate="yes" xml:space="preserve">
          <source>Occurrences of &lt;code&gt;.&lt;/code&gt; are normalized away, except if they are at the beginning of the path. For example, &lt;code&gt;a/./b&lt;/code&gt;, &lt;code&gt;a/b/&lt;/code&gt;, &lt;code&gt;a/b/.&lt;/code&gt; and &lt;code&gt;a/b&lt;/code&gt; all have &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as components, but &lt;code&gt;./a/b&lt;/code&gt; starts with an additional &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt;&lt;code&gt;CurDir&lt;/code&gt;&lt;/a&gt; component.</source>
          <target state="translated">Ocurrencias de &lt;code&gt;.&lt;/code&gt; est&amp;aacute;n normalizados, excepto si est&amp;aacute;n al comienzo de la ruta. Por ejemplo, &lt;code&gt;a/./b&lt;/code&gt; , &lt;code&gt;a/b/&lt;/code&gt; , &lt;code&gt;a/b/.&lt;/code&gt; y &lt;code&gt;a/b&lt;/code&gt; tienen todos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; como componentes, pero &lt;code&gt;./a/b&lt;/code&gt; comienza con un componente &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt; &lt;code&gt;CurDir&lt;/code&gt; &lt;/a&gt; adicional .</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="e6f02e23e2b227ac6699b92be300da464d475a6e" translate="yes" xml:space="preserve">
          <source>Octal integer</source>
          <target state="translated">Entero octal</target>
        </trans-unit>
        <trans-unit id="d04577406c042a11b4da7bb39486816308c607a6" translate="yes" xml:space="preserve">
          <source>Octal::fmt</source>
          <target state="translated">Octal::fmt</target>
        </trans-unit>
        <trans-unit id="615b20b5b110a1806177c985ebbca57031daa785" translate="yes" xml:space="preserve">
          <source>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</source>
          <target state="translated">Por supuesto,saber qué colección es la adecuada para el trabajo no te permite usarla correctamente.Aquí hay algunos consejos rápidos para un uso eficiente y correcto de las colecciones estándar en general.Si está interesado en cómo utilizar una colección específica en particular,consulte su documentación para una discusión detallada y ejemplos de códigos.</target>
        </trans-unit>
        <trans-unit id="2cbe09e34f3d1d91d444d3537b55bb92b3326aea" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;a href=&quot;fn.stdout&quot;&gt;&lt;code&gt;io::stdout&lt;/code&gt;&lt;/a&gt; directly is less common than something like &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Por supuesto, usar &lt;a href=&quot;fn.stdout&quot;&gt; &lt;code&gt;io::stdout&lt;/code&gt; &lt;/a&gt; directamente es menos com&amp;uacute;n que algo como &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="35c2f4d3ee9ba6ff467650c366d5a389ebdd0812" translate="yes" xml:space="preserve">
          <source>Of course, you can do it as long as the module you're referring to is an ancestor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d478ea3e054425d68cac2b881bb4303c629df5" translate="yes" xml:space="preserve">
          <source>Often, you&amp;rsquo;ll want to combine two existing strings. One way is to use the &lt;code&gt;+&lt;/code&gt; operator, as shown in Listing 8-18.</source>
          <target state="translated">A menudo, querr&amp;aacute; combinar dos cadenas existentes. Una forma es usar el operador &lt;code&gt;+&lt;/code&gt; , como se muestra en el Listado 8-18.</target>
        </trans-unit>
        <trans-unit id="3894dea4e557c370e601b5214f719623a770bfec" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;packed&lt;/code&gt; structs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1d4e18544489b4eaf442b238d12d6d0846066b" translate="yes" xml:space="preserve">
          <source>On Linux systems, if this is compiled as &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">En sistemas Linux, si se compila como &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="81c83f6982dcc0359616815ff2d1c2e0f9aa8bfa" translate="yes" xml:space="preserve">
          <source>On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the &lt;code&gt;ls&lt;/code&gt; command in your shell. On Linux and macOS, you&amp;rsquo;ll see two files. With PowerShell on Windows, you&amp;rsquo;ll see the same three files that you would see using CMD.</source>
          <target state="translated">En Linux, macOS y PowerShell en Windows, puede ver el ejecutable ingresando el comando &lt;code&gt;ls&lt;/code&gt; en su shell. En Linux y macOS, ver&amp;aacute; dos archivos. Con PowerShell en Windows, ver&amp;aacute; los mismos tres archivos que ver&amp;iacute;a con CMD.</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">En Linux:</target>
        </trans-unit>
        <trans-unit id="28f964279968ee11e024ad4734a1849f6d567b40" translate="yes" xml:space="preserve">
          <source>On Redox this always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">En Redox, esto siempre devuelve &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c27c55a04c34d1416124c71c1487f965daf5e2b" translate="yes" xml:space="preserve">
          <source>On Unix</source>
          <target state="translated">En Unix</target>
        </trans-unit>
        <trans-unit id="f580d63739e00a5c78d3db723e0a54f4eebdec61" translate="yes" xml:space="preserve">
          <source>On Unix platforms, calling this method corresponds to calling &lt;code&gt;fcntl&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;. On Windows calling this method corresponds to calling &lt;code&gt;ioctlsocket&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;.</source>
          <target state="translated">En plataformas Unix, llamar a este m&amp;eacute;todo corresponde a llamar a &lt;code&gt;fcntl&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; . En Windows, llamar a este m&amp;eacute;todo corresponde a llamar a &lt;code&gt;ioctlsocket&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368e8ed37eeed58c150496b19476b91dc7031ee8" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.</source>
          <target state="translated">En las plataformas Unix,la llamada al sistema subyacente puede ser interrumpida por un espurio despertar o manejador de señales.Para garantizar que el sueño se produzca al menos durante la duración especificada,esta función puede invocar esa llamada al sistema varias veces.</target>
        </trans-unit>
        <trans-unit id="5d8d403cb28547a9afda373b97085e009420f7cc" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times. Platforms which do not support nanosecond precision for sleeping will have &lt;code&gt;dur&lt;/code&gt; rounded up to the nearest granularity of time they can sleep for.</source>
          <target state="translated">En las plataformas Unix, la llamada al sistema subyacente puede ser interrumpida por una activaci&amp;oacute;n falsa o un manejador de se&amp;ntilde;ales. Para garantizar que la suspensi&amp;oacute;n se produzca durante al menos la duraci&amp;oacute;n especificada, esta funci&amp;oacute;n puede invocar esa llamada al sistema varias veces. Las plataformas que no admiten la precisi&amp;oacute;n de nanosegundos para dormir tendr&amp;aacute;n &lt;code&gt;dur&lt;/code&gt; redondeado a la granularidad m&amp;aacute;s cercana de tiempo que pueden dormir.</target>
        </trans-unit>
        <trans-unit id="f15b383f304eefe4931d61a084a59f34627760f4" translate="yes" xml:space="preserve">
          <source>On Unix systems shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">En los sistemas Unix, el shell generalmente expande los argumentos sin comillas con patrones globales (como &lt;code&gt;*&lt;/code&gt; y &lt;code&gt;?&lt;/code&gt; ). En Windows esto no se hace y dichos argumentos se pasan tal cual.</target>
        </trans-unit>
        <trans-unit id="35aecf3282b41109feea97145ac8fcf33e5a85c0" translate="yes" xml:space="preserve">
          <source>On Unix systems the shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ed9ce935220230672af1ba06994403c22fd01d" translate="yes" xml:space="preserve">
          <source>On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.</source>
          <target state="translated">En los sistemas Unix,cuando se utiliza el TLS basado en pthread,los destructores no se ejecutarán para los valores de TLS en el hilo principal cuando éste salga.Tenga en cuenta que la aplicación también saldrá inmediatamente después de que salga el hilo principal.</target>
        </trans-unit>
        <trans-unit id="fb3ee6950e481b93ea06bd207e97b8f1a208a9e6" translate="yes" xml:space="preserve">
          <source>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</source>
          <target state="translated">En los sistemas Unix,las cadenas suelen ser secuencias arbitrarias de bytes no nulos,que en muchos casos se interpretan como UTF-8.</target>
        </trans-unit>
        <trans-unit id="ade1ebaf1f97bbb67b44937124b853209f01a0de" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which augments it with two methods, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt;&lt;code&gt;from_bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;. These do inexpensive conversions from and to UTF-8 byte slices.</source>
          <target state="translated">En Unix, &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; implementa el rasgo &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; , que lo aumenta con dos m&amp;eacute;todos, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt; &lt;code&gt;from_bytes&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; . Estos realizan conversiones econ&amp;oacute;micas desde y hacia segmentos de bytes UTF-8.</target>
        </trans-unit>
        <trans-unit id="947b55450ee1839446a5472dd42bc83b983d60aa" translate="yes" xml:space="preserve">
          <source>On Unix, a path has a root if it begins with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">En Unix, una ruta tiene una ra&amp;iacute;z si comienza con &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd3b4c86524e4799caf099ecd37af36c6672deb" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">En Unix, una ruta es absoluta si comienza con la ra&amp;iacute;z, por lo que &lt;code&gt;is_absolute&lt;/code&gt; y &lt;a href=&quot;#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt; son equivalentes.</target>
        </trans-unit>
        <trans-unit id="c1d8cd80a5b3e4b5d2416174dfc8848e290d79c0" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;struct.path#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c49b23a9e8913d5f28e887403c1dd64ea25f5f0" translate="yes" xml:space="preserve">
          <source>On Unix, this will return &lt;code&gt;None&lt;/code&gt; if the process was terminated by a signal; &lt;code&gt;std::os::unix&lt;/code&gt; provides an extension trait for extracting the signal and other details from the &lt;code&gt;ExitStatus&lt;/code&gt;.</source>
          <target state="translated">En Unix, esto devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; si el proceso fue terminado por una se&amp;ntilde;al; &lt;code&gt;std::os::unix&lt;/code&gt; proporciona un rasgo de extensi&amp;oacute;n para extraer la se&amp;ntilde;al y otros detalles de &lt;code&gt;ExitStatus&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">En Windows</target>
        </trans-unit>
        <trans-unit id="340634e7ba37ae9abb46e394a10f468ca07b5406" translate="yes" xml:space="preserve">
          <source>On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to &lt;code&gt;symlink_metadata&lt;/code&gt; to learn about the target file type.</source>
          <target state="translated">En Windows y la mayor&amp;iacute;a de las plataformas Unix, esta funci&amp;oacute;n es gratuita (no se necesitan llamadas adicionales al sistema), pero algunas plataformas Unix pueden requerir la llamada equivalente a &lt;code&gt;symlink_metadata&lt;/code&gt; para conocer el tipo de archivo de destino.</target>
        </trans-unit>
        <trans-unit id="dc05b2580f0d12742976994a81fdd3a92daa9627" translate="yes" xml:space="preserve">
          <source>On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling &lt;code&gt;symlink_metadata&lt;/code&gt; on the path.</source>
          <target state="translated">En Windows, esta funci&amp;oacute;n es barata de llamar (no se necesitan llamadas adicionales al sistema), pero en las plataformas Unix esta funci&amp;oacute;n es el equivalente a llamar a &lt;code&gt;symlink_metadata&lt;/code&gt; en la ruta.</target>
        </trans-unit>
        <trans-unit id="96488f7f2e398f8d620db102c3767404f52cec35" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Windows, &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; implementa el rasgo &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; , que proporciona un m&amp;eacute;todo &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; . Esto proporciona un iterador que se puede &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; en un vector de &lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="354971d9fc4cf41d4726d0f246b8a7efa90a20dd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af64d7ebac16f152870c457029381910a90ad98" translate="yes" xml:space="preserve">
          <source>On Windows, a path has a root if it:</source>
          <target state="translated">En Windows,un camino tiene una raíz si:</target>
        </trans-unit>
        <trans-unit id="23aad31490e7c68a187977dea619fd53f62cad2c" translate="yes" xml:space="preserve">
          <source>On Windows, a path is absolute if it has a prefix and starts with the root: &lt;code&gt;c:\windows&lt;/code&gt; is absolute, while &lt;code&gt;c:temp&lt;/code&gt; and &lt;code&gt;\temp&lt;/code&gt; are not.</source>
          <target state="translated">En Windows, una ruta es absoluta si tiene un prefijo y comienza con la ra&amp;iacute;z: &lt;code&gt;c:\windows&lt;/code&gt; es absoluta, mientras que &lt;code&gt;c:temp&lt;/code&gt; y &lt;code&gt;\temp&lt;/code&gt; no lo son.</target>
        </trans-unit>
        <trans-unit id="76c59bd2f582fcbc4571a1c46e5718df63ea4def" translate="yes" xml:space="preserve">
          <source>On Windows, a symbolic link knows whether it is a file or directory.</source>
          <target state="translated">En Windows,un enlace simbólico sabe si es un archivo o un directorio.</target>
        </trans-unit>
        <trans-unit id="21bc0d515b3e6fb7f3d9412e9a760b756bd52140" translate="yes" xml:space="preserve">
          <source>On Windows, enter the command &lt;code&gt;.\main.exe&lt;/code&gt; instead of &lt;code&gt;./main&lt;/code&gt;:</source>
          <target state="translated">En Windows, ingrese el comando &lt;code&gt;.\main.exe&lt;/code&gt; lugar de &lt;code&gt;./main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5430ea74797e1304f80750653012edbeaab36ca" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. When asked which workloads to install make sure &quot;C++ build tools&quot; is selected and that the Windows 10 SDK and the English language pack components are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7a73ca0a18d815fd6e51cfa03502575932403d" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. The tools are in the Other Tools and Frameworks section.</source>
          <target state="translated">En Windows, vaya a &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; y siga las instrucciones para instalar Rust. En alg&amp;uacute;n momento de la instalaci&amp;oacute;n, recibir&amp;aacute; un mensaje que explica que tambi&amp;eacute;n necesitar&amp;aacute; las herramientas de compilaci&amp;oacute;n de C ++ para Visual Studio 2013 o posterior. La forma m&amp;aacute;s sencilla de adquirir las herramientas de compilaci&amp;oacute;n es instalar &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools para Visual Studio 2019&lt;/a&gt; . Las herramientas se encuentran en la secci&amp;oacute;n Otras herramientas y marcos.</target>
        </trans-unit>
        <trans-unit id="f9e96b3ce49cbd593ce10eba431579916c1beb4e" translate="yes" xml:space="preserve">
          <source>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</source>
          <target state="translated">En Windows,las cadenas suelen ser secuencias arbitrarias de valores de 16 bits distintos de cero,interpretadas como UTF-16 cuando es válido hacerlo.</target>
        </trans-unit>
        <trans-unit id="4d87cfdfbe26beaf98d7cabde9343985e270cf11" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57ac5776aebf69e1a4091e5f62bdd9bd9a59609" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">En Windows, esto convierte la ruta para usar &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;una&lt;/a&gt; sintaxis de ruta de longitud extendida , lo que permite que su programa use nombres de ruta m&amp;aacute;s largos, pero significa que solo puede unir rutas delimitadas por barra invertida, y puede ser incompatible con otras aplicaciones (si se pasa a la aplicaci&amp;oacute;n en la l&amp;iacute;nea de comandos, o escrito en un archivo que otra aplicaci&amp;oacute;n pueda leer).</target>
        </trans-unit>
        <trans-unit id="22cfd134aef9e5447e4029c33c01913e82dca29d" translate="yes" xml:space="preserve">
          <source>On Windows, you must specify whether a symbolic link points to a file or directory. Use &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; to create a symbolic link to a file, or &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; to create a symbolic link to a directory. Additionally, the process must have &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; in order to be able to create a symbolic link.</source>
          <target state="translated">En Windows, debe especificar si un enlace simb&amp;oacute;lico apunta a un archivo o directorio. Utilice &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; para crear un enlace simb&amp;oacute;lico a un archivo, u &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; para crear un enlace simb&amp;oacute;lico a un directorio. Adem&amp;aacute;s, el proceso debe tener &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; para poder crear un enlace simb&amp;oacute;lico.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">En Windows:</target>
        </trans-unit>
        <trans-unit id="2d943049f7275605af2957c0729af75e15804644" translate="yes" xml:space="preserve">
          <source>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">En un patr&amp;oacute;n de estructura, los campos se referencian por nombre, &amp;iacute;ndice (en el caso de estructuras de tupla) o se ignoran mediante el uso de &lt;code&gt;..&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc5ae395985a077524b266fc2c058a9c41f9a6c9" translate="yes" xml:space="preserve">
          <source>On a technical level, Rust inserts</source>
          <target state="translated">A nivel técnico,el óxido inserta</target>
        </trans-unit>
        <trans-unit id="1b348ad01b675597a26bee9f6007707cf4e88f3f" translate="yes" xml:space="preserve">
          <source>On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.</source>
          <target state="translated">En todas las plataformas es posible que el TLS reinicie otras ranuras TLS durante la destrucción.Algunas plataformas se aseguran de que esto no pueda suceder infinitamente impidiendo la reinicialización de cualquier ranura que haya sido destruida,pero no todas las plataformas tienen esta protección.Las plataformas que no tienen esta protección suelen tener un límite sintético después del cual ya no se ejecutan los destructores.</target>
        </trans-unit>
        <trans-unit id="037d4731f94d8fe39eb9b4a6879b2f19130604a0" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d799d2a3d45a2a27a645560d44031039269d8400" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;).</source>
          <target state="translated">En todas las plataformas, la nueva l&amp;iacute;nea es el car&amp;aacute;cter de AVANCE DE L&amp;Iacute;NEA ( &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ) solo (sin RETORNO DE CARRO adicional ( &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8026d1566cfb33142845deb08dc55be0e48c8b84" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutErr&lt;/code&gt;.</source>
          <target state="translated">En el desbordamiento aritm&amp;eacute;tico, devuelve &lt;code&gt;LayoutErr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf819fffd5786da2be15358bf27201c594c34573" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62056a56ee350ef2ac48d7878ee0e8c05c6cdab9" translate="yes" xml:space="preserve">
          <source>On big endian this is a no-op. On little endian the bytes are swapped.</source>
          <target state="translated">En Big Endian esto es un no-op.En la pequeña India los bytes se intercambian.</target>
        </trans-unit>
        <trans-unit id="3209db243d37f470d1d7cfe42ce3d766b7bc29ef" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;CString&lt;/code&gt; is returned.</source>
          <target state="translated">En caso de error, se devuelve la propiedad del &lt;code&gt;CString&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="4c9afd72e5fc07b12e4a58aab05b5a861ccfe991" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;OsString&lt;/code&gt; is returned.</source>
          <target state="translated">En caso de falla, se devuelve la propiedad del &lt;code&gt;OsString&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="259a9191e45f4405904adb74ccfbaecde8fac969" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &quot;.init_array&quot;. Glibc passes argc, argv, and envp to functions in &quot;.init_array&quot;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d682d53e730f8107b6e28e70ea3aca1f2f84a3a2" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &lt;code&gt;.init_array&lt;/code&gt;. Glibc passes &lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;, and &lt;code&gt;envp&lt;/code&gt; to functions in &lt;code&gt;.init_array&lt;/code&gt;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3818a4eb5a3ae2432429a2be6f00d2b57327ad67" translate="yes" xml:space="preserve">
          <source>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;, is yielded by the iterator.</source>
          <target state="translated">En la iteraci&amp;oacute;n, el cierre se aplicar&amp;aacute; a cada elemento del iterador y el valor de retorno del cierre, una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; , es proporcionado por el iterador.</target>
        </trans-unit>
        <trans-unit id="7ac8ec0fd24d5e212f6e7881f085d7af49a49607" translate="yes" xml:space="preserve">
          <source>On little endian this is a no-op. On big endian the bytes are swapped.</source>
          <target state="translated">En Little Endian esto es un no-op.En el gran Indio los bytes se intercambian.</target>
        </trans-unit>
        <trans-unit id="4e3e1efffa4b7d24fe7283223e058e550576b614" translate="yes" xml:space="preserve">
          <source>On many architectures, this function can perform better than &lt;code&gt;leading_zeros()&lt;/code&gt; on the underlying integer type, as special handling of zero can be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848a615b6290900cfd1ddd55f346fc45b2bed670" translate="yes" xml:space="preserve">
          <source>On many architectures, this function can perform better than &lt;code&gt;trailing_zeros()&lt;/code&gt; on the underlying integer type, as special handling of zero can be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4ddcfc8d324d93f4c94125de45c5742f4d5101" translate="yes" xml:space="preserve">
          <source>On non-pointer types &lt;code&gt;*x&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; in an &lt;a href=&quot;../expressions#mutability&quot;&gt;immutable place expression context&lt;/a&gt; and &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; in a mutable place expression context.</source>
          <target state="translated">En tipos que no son de puntero &lt;code&gt;*x&lt;/code&gt; es equivalente a &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; en un &lt;a href=&quot;../expressions#mutability&quot;&gt;contexto de expresi&amp;oacute;n de lugar inmutable&lt;/a&gt; y &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; en un lugar mutable contexto de expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="152e667068d08065574b6f3ea75735b1ef22f81c" translate="yes" xml:space="preserve">
          <source>On panic, this macro will print the values of the expressions with their debug representations.</source>
          <target state="translated">En caso de pánico,esta macro imprimirá los valores de las expresiones con sus representaciones de depuración.</target>
        </trans-unit>
        <trans-unit id="a0e8d873b690ac84365bcb6ce9a48ba9ac4a73cf" translate="yes" xml:space="preserve">
          <source>On some system, calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">En algunos sistemas, es necesario llamar a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; o similar para que el sistema operativo libere recursos. Un proceso que termin&amp;oacute; pero que no se ha esperado sigue existiendo como un &quot;zombi&quot;. Dejar demasiados zombis alrededor puede agotar los recursos globales (por ejemplo, ID de proceso).</target>
        </trans-unit>
        <trans-unit id="8d680bbd1b29ac2bd7f1c4039cc2f034c2409b58" translate="yes" xml:space="preserve">
          <source>On some systems, calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95b6f9f5ca3589fe7d076155399faa6b71dbbbe" translate="yes" xml:space="preserve">
          <source>On success this function will not return, and otherwise it will return an error indicating why the exec (or another part of the setup of the &lt;code&gt;Command&lt;/code&gt;) failed.</source>
          <target state="translated">Si tiene &amp;eacute;xito, esta funci&amp;oacute;n no regresar&amp;aacute; y, de lo contrario, devolver&amp;aacute; un error indicando por qu&amp;eacute; fall&amp;oacute; el ejecutivo (u otra parte de la configuraci&amp;oacute;n del &lt;code&gt;Command&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9dc3aca4d292aed062c338c543e13af0f74c89de" translate="yes" xml:space="preserve">
          <source>On success, returns a &lt;a href=&quot;../ptr/struct.nonnull&quot;&gt;&lt;code&gt;NonNull&amp;lt;[u8]&amp;gt;&lt;/code&gt;&lt;/a&gt; meeting the size and alignment guarantees of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105508220fba1586b41aed6de3e9afe8bdcad7d2" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and if the data was truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ee4aa1b293e333458ae17de2dc9971adc5a07b" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and the address from whence the data came.</source>
          <target state="translated">Al tener éxito,devuelve el número de bytes leídos y la dirección de donde vinieron los datos.</target>
        </trans-unit>
        <trans-unit id="dfc14b3f66c1dadb297ac68b0d484bfc6cc7a217" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea0ccaabe0c9b1fbc90341ab5a04d65215e560d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read.</source>
          <target state="translated">En caso de éxito,devuelve el número de bytes leídos.</target>
        </trans-unit>
        <trans-unit id="bc5a49aba56a5b26329959ae0e37a7391cbb54ed" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes written.</source>
          <target state="translated">En caso de éxito,devuelve el número de bytes escritos.</target>
        </trans-unit>
        <trans-unit id="f9b7167ab1cb81802d4cc93ff38048bd7cd2f218" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes copied is returned and it is equal to the length of the &lt;code&gt;to&lt;/code&gt; file as reported by &lt;code&gt;metadata&lt;/code&gt;.</source>
          <target state="translated">En caso de &amp;eacute;xito, el n&amp;uacute;mero total de bytes copiados se devuelve y es igual a la longitud de la &lt;code&gt;to&lt;/code&gt; archivo seg&amp;uacute;n lo informado por &lt;code&gt;metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bfa6f8c514698639a06b222dc94c1639495b9f" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes that were copied from &lt;code&gt;reader&lt;/code&gt; to &lt;code&gt;writer&lt;/code&gt; is returned.</source>
          <target state="translated">En caso de &amp;eacute;xito, se devuelve el n&amp;uacute;mero total de bytes que se copiaron del &lt;code&gt;reader&lt;/code&gt; al &lt;code&gt;writer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a00d4716ce2886f17dadaa3b0e2204d940167a" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Screen&lt;/code&gt; struct, we&amp;rsquo;ll define a method named &lt;code&gt;run&lt;/code&gt; that will call the &lt;code&gt;draw&lt;/code&gt; method on each of its &lt;code&gt;components&lt;/code&gt;, as shown in Listing 17-5:</source>
          <target state="translated">En la estructura &lt;code&gt;Screen&lt;/code&gt; , definiremos un m&amp;eacute;todo llamado &lt;code&gt;run&lt;/code&gt; que llamar&amp;aacute; al m&amp;eacute;todo &lt;code&gt;draw&lt;/code&gt; en cada uno de sus &lt;code&gt;components&lt;/code&gt; , como se muestra en el Listado 17-5:</target>
        </trans-unit>
        <trans-unit id="417a01b51fb2fc402d7ff9e7a38ed36ddb3ab97a" translate="yes" xml:space="preserve">
          <source>On the first line of &lt;code&gt;main&lt;/code&gt;, we call &lt;code&gt;env::args&lt;/code&gt;, and we immediately use &lt;code&gt;collect&lt;/code&gt; to turn the iterator into a vector containing all the values produced by the iterator. We can use the &lt;code&gt;collect&lt;/code&gt; function to create many kinds of collections, so we explicitly annotate the type of &lt;code&gt;args&lt;/code&gt; to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, &lt;code&gt;collect&lt;/code&gt; is one function you do often need to annotate because Rust isn&amp;rsquo;t able to infer the kind of collection you want.</source>
          <target state="translated">En la primera l&amp;iacute;nea de &lt;code&gt;main&lt;/code&gt; , llamamos &lt;code&gt;env::args&lt;/code&gt; , e inmediatamente usamos &lt;code&gt;collect&lt;/code&gt; para convertir el iterador en un vector que contiene todos los valores producidos por el iterador. Podemos usar la funci&amp;oacute;n de &lt;code&gt;collect&lt;/code&gt; para crear muchos tipos de colecciones, por lo que anotamos expl&amp;iacute;citamente el tipo de &lt;code&gt;args&lt;/code&gt; para especificar que queremos un vector de cadenas. Aunque rara vez necesitamos anotar tipos en Rust, &lt;code&gt;collect&lt;/code&gt; es una funci&amp;oacute;n que a menudo necesita anotar porque Rust no puede inferir el tipo de recopilaci&amp;oacute;n que desea.</target>
        </trans-unit>
        <trans-unit id="9eddcffce559b2f4fd96faa276545d34f1b2fe9a" translate="yes" xml:space="preserve">
          <source>On the other hand, one trait which would not be appropriate to implement is &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Por otro lado, un rasgo que no ser&amp;iacute;a apropiado implementar es el &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c286483c8f6ceb616a180cf64f82c92b911d5676" translate="yes" xml:space="preserve">
          <source>On the other hand, this is correct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf67f3b833240197b7f3967e7a28b88e1336e77" translate="yes" xml:space="preserve">
          <source>On the other hand, this will not compile because the &lt;code&gt;where 'b: 'a&lt;/code&gt; clause is missing: the &lt;code&gt;'b&lt;/code&gt; lifetime is not known to live at least as long as &lt;code&gt;'a&lt;/code&gt; which means this function cannot ensure it always returns a valid reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d6ad3b118e12286d44db37bda32a77e5392fde" translate="yes" xml:space="preserve">
          <source>On the other hand, when bringing in structs, enums, and other items with &lt;code&gt;use&lt;/code&gt;, it&amp;rsquo;s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library&amp;rsquo;s &lt;code&gt;HashMap&lt;/code&gt; struct into the scope of a binary crate.</source>
          <target state="translated">Por otro lado, al traer estructuras, enumeraciones y otros elementos con &lt;code&gt;use&lt;/code&gt; , es idiom&amp;aacute;tico especificar la ruta completa. El Listado 7-14 muestra la forma idiom&amp;aacute;tica de llevar la estructura &lt;code&gt;HashMap&lt;/code&gt; de la biblioteca est&amp;aacute;ndar al alcance de una caja binaria.</target>
        </trans-unit>
        <trans-unit id="50d2f428f140a723a3dc474c3eb5d43ababe5b45" translate="yes" xml:space="preserve">
          <source>On the other hand, with the method using trait objects, one &lt;code&gt;Screen&lt;/code&gt; instance can hold a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as well as a &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at how this works, and then we&amp;rsquo;ll talk about the runtime performance implications.</source>
          <target state="translated">Por otro lado, con el m&amp;eacute;todo que usa objetos de rasgo, una instancia de &lt;code&gt;Screen&lt;/code&gt; puede contener un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; que contiene un &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as&amp;iacute; como un &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt; . Veamos c&amp;oacute;mo funciona esto y luego hablaremos sobre las implicaciones del rendimiento en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="05a08140d648b8eef0f62e5e0b016ae12318d58b" translate="yes" xml:space="preserve">
          <source>On the surface, &lt;code&gt;static&lt;/code&gt; items seem very similar to &lt;a href=&quot;keyword.const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt;s: both contain a value, both require type annotations and both can only be initialized with constant functions and values. However, &lt;code&gt;static&lt;/code&gt;s are notably different in that they represent a location in memory. That means that you can have references to &lt;code&gt;static&lt;/code&gt; items and potentially even modify them, making them essentially global variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8593d2dddd7916b4461c2238bc4c5b8191583e5e" translate="yes" xml:space="preserve">
          <source>On top of that, all additional invariants of the type &lt;code&gt;T&lt;/code&gt; must be satisfied, as the &lt;code&gt;Drop&lt;/code&gt; implementation of &lt;code&gt;T&lt;/code&gt; (or its members) may rely on this. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Dropping such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; however will cause undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7c692a18f46234aa3957edc945a28ff83c44fe" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword before the type, followed by the ABI in question. The default ABI is &quot;Rust&quot;, i.e., &lt;code&gt;fn()&lt;/code&gt; is the exact same type as &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt;. A pointer to a function with C ABI would have type &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c793eb037e8ef3b7da8efa89ac452132495eae" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword to the type name, followed by the ABI in question. For example, &lt;code&gt;fn()&lt;/code&gt; is different from &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;, which itself is different from &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt;, and so on for the various ABIs that Rust supports. Non-&lt;code&gt;extern&lt;/code&gt; functions have an ABI of &lt;code&gt;&quot;Rust&quot;&lt;/code&gt;, and &lt;code&gt;extern&lt;/code&gt; functions without an explicit ABI have an ABI of &lt;code&gt;&quot;C&quot;&lt;/code&gt;. For more information, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de eso, los punteros de funci&amp;oacute;n pueden variar seg&amp;uacute;n el ABI que utilicen. Esto se logra agregando la palabra clave &lt;code&gt;extern&lt;/code&gt; al nombre del tipo, seguida de la ABI en cuesti&amp;oacute;n. Por ejemplo, &lt;code&gt;fn()&lt;/code&gt; es diferente de &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; , que a su vez es diferente de &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt; , y as&amp;iacute; sucesivamente para las distintas ABI que admite Rust. Las funciones no &lt;code&gt;extern&lt;/code&gt; as tienen un ABI de &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; y las funciones &lt;code&gt;extern&lt;/code&gt; as sin un ABI expl&amp;iacute;cito tienen un ABI de &lt;code&gt;&quot;C&quot;&lt;/code&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;la secci&amp;oacute;n de nomicon sobre convenciones de llamadas extranjeras&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2aa688af42ea89b3fbf818f2d4bdeab6c73c4a" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630c59f788be2f8b6b4b1ca247b245094c3530e8" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">Adem&amp;aacute;s de eso, recuerde que la mayor&amp;iacute;a de los tipos tienen invariantes adicionales adem&amp;aacute;s de ser considerados inicializados a nivel de tipo. Por ejemplo, un &lt;code&gt;1&lt;/code&gt; -initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; se considera inicializado ya que el &amp;uacute;nico requisito el compilador sabe de ella es que el puntero de datos debe ser no nulo. La creaci&amp;oacute;n de un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; no causa un comportamiento indefinido &lt;em&gt;inmediato&lt;/em&gt; , pero causar&amp;aacute; un comportamiento indefinido con la mayor&amp;iacute;a de las operaciones seguras (incluida su eliminaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="dde4e913efe3a7bb20d91e29731b497ad0b7ade2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;Config::new&lt;/code&gt; takes ownership of the iterator and stops using indexing operations that borrow, we can move the &lt;code&gt;String&lt;/code&gt; values from the iterator into &lt;code&gt;Config&lt;/code&gt; rather than calling &lt;code&gt;clone&lt;/code&gt; and making a new allocation.</source>
          <target state="translated">Una vez que &lt;code&gt;Config::new&lt;/code&gt; toma posesi&amp;oacute;n del iterador y deja de usar operaciones de indexaci&amp;oacute;n que piden prestado, podemos mover los valores de &lt;code&gt;String&lt;/code&gt; del iterador a &lt;code&gt;Config&lt;/code&gt; en lugar de llamar a &lt;code&gt;clone&lt;/code&gt; y hacer una nueva asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8b0de6bbc4d6a271545919a41560436f915e4647" translate="yes" xml:space="preserve">
          <source>Once a future has completed (returned &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt;), calling its &lt;code&gt;poll&lt;/code&gt; method again may panic, block forever, or cause other kinds of problems; the &lt;code&gt;Future&lt;/code&gt; trait places no requirements on the effects of such a call. However, as the &lt;code&gt;poll&lt;/code&gt; method is not marked &lt;code&gt;unsafe&lt;/code&gt;, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of &lt;code&gt;unsafe&lt;/code&gt; functions, or the like), regardless of the future's state.</source>
          <target state="translated">Una vez que un futuro se ha completado (devuelto &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt; ), volver a llamar a su m&amp;eacute;todo de &lt;code&gt;poll&lt;/code&gt; puede entrar en p&amp;aacute;nico, bloquearse para siempre o causar otro tipo de problemas; el rasgo &lt;code&gt;Future&lt;/code&gt; no impone requisitos sobre los efectos de tal llamada. Sin embargo, dado que el m&amp;eacute;todo de &lt;code&gt;poll&lt;/code&gt; no est&amp;aacute; marcado como &lt;code&gt;unsafe&lt;/code&gt; , se aplican las reglas habituales de Rust: las llamadas nunca deben causar un comportamiento indefinido (corrupci&amp;oacute;n de memoria, uso incorrecto de funciones &lt;code&gt;unsafe&lt;/code&gt; , o similares), independientemente del estado futuro.</target>
        </trans-unit>
        <trans-unit id="472f512f503c00a7a3badf54bca4e8a984d78d81" translate="yes" xml:space="preserve">
          <source>Once a future has finished, clients should not &lt;code&gt;poll&lt;/code&gt; it again.</source>
          <target state="translated">Una vez que ha terminado un futuro, los clientes no deben &lt;code&gt;poll&lt;/code&gt; de nuevo.</target>
        </trans-unit>
        <trans-unit id="52d66dce2b0cbeb3ef0b4a40c595411581c4bf47" translate="yes" xml:space="preserve">
          <source>Once a valid size is received, our &lt;code&gt;ThreadPool&lt;/code&gt; creates a new vector that can hold &lt;code&gt;size&lt;/code&gt; items. We haven&amp;rsquo;t used the &lt;code&gt;with_capacity&lt;/code&gt; function in this book yet, which performs the same task as &lt;code&gt;Vec::new&lt;/code&gt; but with an important difference: it preallocates space in the vector. Because we know we need to store &lt;code&gt;size&lt;/code&gt; elements in the vector, doing this allocation up front is slightly more efficient than using &lt;code&gt;Vec::new&lt;/code&gt;, which resizes itself as elements are inserted.</source>
          <target state="translated">Una vez que se recibe un tama&amp;ntilde;o v&amp;aacute;lido, nuestro &lt;code&gt;ThreadPool&lt;/code&gt; crea un nuevo vector que puede contener elementos de &lt;code&gt;size&lt;/code&gt; . Todav&amp;iacute;a no hemos usado la funci&amp;oacute;n &lt;code&gt;with_capacity&lt;/code&gt; en este libro, que realiza la misma tarea que &lt;code&gt;Vec::new&lt;/code&gt; pero con una diferencia importante: preasigna espacio en el vector. Como sabemos que necesitamos almacenar elementos de &lt;code&gt;size&lt;/code&gt; en el vector, hacer esta asignaci&amp;oacute;n por adelantado es un poco m&amp;aacute;s eficiente que usar &lt;code&gt;Vec::new&lt;/code&gt; , que cambia de tama&amp;ntilde;o a medida que se insertan los elementos.</target>
        </trans-unit>
        <trans-unit id="b9c2a150a70fbfb0f86650e1f5cd73ca0f595c49" translate="yes" xml:space="preserve">
          <source>Once again we're using &lt;code&gt;!&lt;/code&gt;'s ability to coerce into any other type, in this case &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;. Since this method takes a &lt;code&gt;&amp;amp;!&lt;/code&gt; as an argument we know that it can never be called (because there is no value of type &lt;code&gt;!&lt;/code&gt; for it to be called with). Writing &lt;code&gt;*self&lt;/code&gt; essentially tells the compiler &quot;We know that this code can never be run, so just treat the entire function body as having type &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;&quot;. This pattern can be used a lot when implementing traits for &lt;code&gt;!&lt;/code&gt;. Generally, any trait which only has methods which take a &lt;code&gt;self&lt;/code&gt; parameter should have such an impl.</source>
          <target state="translated">&amp;iexcl;Una vez m&amp;aacute;s estamos usando &lt;code&gt;!&lt;/code&gt; la capacidad de coaccionar a cualquier otro tipo, en este caso &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; . Dado que este m&amp;eacute;todo lleva un &lt;code&gt;&amp;amp;!&lt;/code&gt; como argumento, sabemos que nunca se puede llamar (&amp;iexcl;porque no hay un valor de tipo &lt;code&gt;!&lt;/code&gt; para llamarlo). Escribir &lt;code&gt;*self&lt;/code&gt; esencialmente le dice al compilador &quot;Sabemos que este c&amp;oacute;digo nunca se puede ejecutar, as&amp;iacute; que simplemente trate todo el cuerpo de la funci&amp;oacute;n como si tuviera el tipo &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; &quot;. &amp;iexcl;Este patr&amp;oacute;n se puede usar mucho al implementar rasgos para &lt;code&gt;!&lt;/code&gt; . Por lo general, cualquier rasgo que solo tenga m&amp;eacute;todos que tomen un par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; deber&amp;iacute;a tener tal impl.</target>
        </trans-unit>
        <trans-unit id="3c60f2098dcfc1948a1cd5eb57c13cccf48d2d00" translate="yes" xml:space="preserve">
          <source>Once again, we compile and get... different errors! The compiler is teaching us a lot.</source>
          <target state="translated">Una vez más,compilamos y obtenemos...¡diferentes errores! El compilador nos está enseñando mucho.</target>
        </trans-unit>
        <trans-unit id="30ba447807ee16c40637ce8c42ca10892e8780ac" translate="yes" xml:space="preserve">
          <source>Once half of a channel has been deallocated, most operations can no longer continue to make progress, so &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned. Many applications will continue to &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt; the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.</source>
          <target state="translated">Una vez que se ha desasignado la mitad de un canal, la mayor&amp;iacute;a de las operaciones ya no pueden continuar progresando, por lo que se devolver&amp;aacute; &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . Muchas aplicaciones continuar&amp;aacute;n &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; los resultados devueltos por este m&amp;oacute;dulo, provocando una propagaci&amp;oacute;n de fallas entre subprocesos si uno muere inesperadamente.</target>
        </trans-unit>
        <trans-unit id="a91c464fe4209e458222e2a75f2d92f1b46b0155" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6364bb4d426e3f0cecb2911427f26ed73152d755" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b36c9a4ffe1c545648e7557d44e1b469b4df260" translate="yes" xml:space="preserve">
          <source>Once this function returns, the contents of &lt;code&gt;bufs&lt;/code&gt; are unspecified, as this depends on how many calls to &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; were necessary. It is best to understand this function as taking ownership of &lt;code&gt;bufs&lt;/code&gt; and to not use &lt;code&gt;bufs&lt;/code&gt; afterwards. The underlying buffers, to which the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s point (but not the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s themselves), are unchanged and can be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa4b20ac7b7c2a8a0f92535a2333b6aa807706f" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we used iterators with &lt;code&gt;for&lt;/code&gt; loops to execute some code on each item, although we glossed over what the call to &lt;code&gt;iter&lt;/code&gt; did until now.</source>
          <target state="translated">Una vez que hemos creado un iterador, podemos usarlo de varias formas. En el Listado 3-5 del Cap&amp;iacute;tulo 3, usamos iteradores con bucles &lt;code&gt;for&lt;/code&gt; para ejecutar algo de c&amp;oacute;digo en cada elemento, aunque pasamos por alto lo que hizo la llamada a &lt;code&gt;iter&lt;/code&gt; hasta ahora.</target>
        </trans-unit>
        <trans-unit id="58851a1903858c976f2730a714ae3f3f46765304" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve implemented the &lt;code&gt;Iterator&lt;/code&gt; trait, we have an iterator! Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our &lt;code&gt;Counter&lt;/code&gt; struct by calling the &lt;code&gt;next&lt;/code&gt; method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</source>
          <target state="translated">Una vez que hemos implementado el rasgo &lt;code&gt;Iterator&lt;/code&gt; , &amp;iexcl;tenemos un iterador! El Listado 13-22 muestra una prueba que demuestra que podemos usar la funcionalidad de iterador de nuestra estructura &lt;code&gt;Counter&lt;/code&gt; llamando directamente &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo siguiente , tal como hicimos con el iterador creado a partir de un vector en el Listado 13-15.</target>
        </trans-unit>
        <trans-unit id="84bcbd885f09e288fb3013478b1c1b345aab434e" translate="yes" xml:space="preserve">
          <source>Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the &lt;code&gt;[-]&lt;/code&gt; button near the top of the page to collapse it into a more skimmable view.</source>
          <target state="translated">Una vez que est&amp;eacute; familiarizado con el contenido de la biblioteca est&amp;aacute;ndar, puede comenzar a encontrar que la verbosidad de la prosa le distrae. En esta etapa de su desarrollo, es posible que desee presionar el bot&amp;oacute;n &lt;code&gt;[-]&lt;/code&gt; cerca de la parte superior de la p&amp;aacute;gina para contraerla en una vista m&amp;aacute;s r&amp;aacute;pida.</target>
        </trans-unit>
        <trans-unit id="f9e4ff73fcbf2b9b71b1855afa48c76c6aa49139" translate="yes" xml:space="preserve">
          <source>Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; method to get a read-only raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.</source>
          <target state="translated">Una vez que tenga el tipo de segmento que necesita (con o sin un terminador nulo), puede llamar al propio m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; del segmento para obtener un puntero sin formato de solo lectura para pasar a funciones externas. Consulte la documentaci&amp;oacute;n de esa funci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo garantizar la vida &amp;uacute;til del puntero sin formato.</target>
        </trans-unit>
        <trans-unit id="ef776c26c7f6b2f89aaf4c349afba29be9ab2040" translate="yes" xml:space="preserve">
          <source>Once::all</source>
          <target state="translated">Once::all</target>
        </trans-unit>
        <trans-unit id="fa85c00dce196844734611fc55302ba498cdda9b" translate="yes" xml:space="preserve">
          <source>Once::any</source>
          <target state="translated">Once::any</target>
        </trans-unit>
        <trans-unit id="826f1ec43224196e7c0e18a9f4c8ba3d03de27f1" translate="yes" xml:space="preserve">
          <source>Once::borrow</source>
          <target state="translated">Once::borrow</target>
        </trans-unit>
        <trans-unit id="e53e91b8fe24cb0570a1a97b3316a02ec5d3ee03" translate="yes" xml:space="preserve">
          <source>Once::borrow_mut</source>
          <target state="translated">Once::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c2f8e8374534fd9f5e2ff592398a6ffc6014fd99" translate="yes" xml:space="preserve">
          <source>Once::by_ref</source>
          <target state="translated">Once::by_ref</target>
        </trans-unit>
        <trans-unit id="28a72e0c985bccd2edce22b1340d3ed027a4ac1f" translate="yes" xml:space="preserve">
          <source>Once::call_once</source>
          <target state="translated">Once::call_once</target>
        </trans-unit>
        <trans-unit id="e0cfc1e91951cfca51a0190fd8a21d0b035190a9" translate="yes" xml:space="preserve">
          <source>Once::call_once_force</source>
          <target state="translated">Once::call_once_force</target>
        </trans-unit>
        <trans-unit id="1376857cb86f72af6eff74ad397cf00fcde6210e" translate="yes" xml:space="preserve">
          <source>Once::chain</source>
          <target state="translated">Once::chain</target>
        </trans-unit>
        <trans-unit id="190ff92b2c593bf6e13bca7abde87e505a3ec2bb" translate="yes" xml:space="preserve">
          <source>Once::clone</source>
          <target state="translated">Once::clone</target>
        </trans-unit>
        <trans-unit id="212f098b1763e1e51ae7f7bc19ffa302ddfe30a1" translate="yes" xml:space="preserve">
          <source>Once::clone_from</source>
          <target state="translated">Once::clone_from</target>
        </trans-unit>
        <trans-unit id="311f7aa02f0a54433f61dae481c3b3e4040d2495" translate="yes" xml:space="preserve">
          <source>Once::clone_into</source>
          <target state="translated">Once::clone_into</target>
        </trans-unit>
        <trans-unit id="19afa196b08d6f8f3b6f43f40d2d7cd3c50fbc8f" translate="yes" xml:space="preserve">
          <source>Once::cloned</source>
          <target state="translated">Once::cloned</target>
        </trans-unit>
        <trans-unit id="6b4930ea79c81962eae48dcaf70c7227f1aa12a7" translate="yes" xml:space="preserve">
          <source>Once::cmp</source>
          <target state="translated">Once::cmp</target>
        </trans-unit>
        <trans-unit id="5d169980cad74ac2c6880808ed94fb787b98960a" translate="yes" xml:space="preserve">
          <source>Once::collect</source>
          <target state="translated">Once::collect</target>
        </trans-unit>
        <trans-unit id="313d94ea32a51b1b516cb8b52850728efe9ae8b5" translate="yes" xml:space="preserve">
          <source>Once::copied</source>
          <target state="translated">Once::copied</target>
        </trans-unit>
        <trans-unit id="f98560cce6e4eadc3911ce81d61f52d107ea5142" translate="yes" xml:space="preserve">
          <source>Once::count</source>
          <target state="translated">Once::count</target>
        </trans-unit>
        <trans-unit id="2ef6bd0928aad3dcaf46fb7f0bdafb3492745ec4" translate="yes" xml:space="preserve">
          <source>Once::cycle</source>
          <target state="translated">Once::cycle</target>
        </trans-unit>
        <trans-unit id="8ad5b4150f82970fff0038e17ac64a51521d1924" translate="yes" xml:space="preserve">
          <source>Once::enumerate</source>
          <target state="translated">Once::enumerate</target>
        </trans-unit>
        <trans-unit id="23c903ad536fa2bd73035fce46787048ed4f628a" translate="yes" xml:space="preserve">
          <source>Once::eq</source>
          <target state="translated">Once::eq</target>
        </trans-unit>
        <trans-unit id="82879e4fcf39171c09b466e2bf43bc8f45af6822" translate="yes" xml:space="preserve">
          <source>Once::filter</source>
          <target state="translated">Once::filter</target>
        </trans-unit>
        <trans-unit id="095605951ca140555bd59e4149308c63f272478d" translate="yes" xml:space="preserve">
          <source>Once::filter_map</source>
          <target state="translated">Once::filter_map</target>
        </trans-unit>
        <trans-unit id="7ca070326207c327aa1bb557f657f2fac61b1c8a" translate="yes" xml:space="preserve">
          <source>Once::find</source>
          <target state="translated">Once::find</target>
        </trans-unit>
        <trans-unit id="f8cbae0491d42da2ee0b9caaa6d41cbeef0233e4" translate="yes" xml:space="preserve">
          <source>Once::find_map</source>
          <target state="translated">Once::find_map</target>
        </trans-unit>
        <trans-unit id="8f0358e16d2477b8dc5e572ca1dae6005b455b17" translate="yes" xml:space="preserve">
          <source>Once::flat_map</source>
          <target state="translated">Once::flat_map</target>
        </trans-unit>
        <trans-unit id="8580b5a613c1d1f4df99cede210bdc2e9fe3a843" translate="yes" xml:space="preserve">
          <source>Once::flatten</source>
          <target state="translated">Once::flatten</target>
        </trans-unit>
        <trans-unit id="c9a403b6a5f9f7ce825a2ce8e6b8fc78c53b4261" translate="yes" xml:space="preserve">
          <source>Once::fmt</source>
          <target state="translated">Once::fmt</target>
        </trans-unit>
        <trans-unit id="a4dbe0ef075896956284d0f6da5e3cf48dd08238" translate="yes" xml:space="preserve">
          <source>Once::fold</source>
          <target state="translated">Once::fold</target>
        </trans-unit>
        <trans-unit id="9129023999880ed84891680b4f8fd96dda590894" translate="yes" xml:space="preserve">
          <source>Once::for_each</source>
          <target state="translated">Once::for_each</target>
        </trans-unit>
        <trans-unit id="d64f18e6780e0faf671ed9d539a0b268b8174066" translate="yes" xml:space="preserve">
          <source>Once::from</source>
          <target state="translated">Once::from</target>
        </trans-unit>
        <trans-unit id="bbf7ace21ce049891d14dd08bdb7b81831f05411" translate="yes" xml:space="preserve">
          <source>Once::fuse</source>
          <target state="translated">Once::fuse</target>
        </trans-unit>
        <trans-unit id="6d843124e3a2669cb3c40cac626394b00fbd78a9" translate="yes" xml:space="preserve">
          <source>Once::ge</source>
          <target state="translated">Once::ge</target>
        </trans-unit>
        <trans-unit id="a9af56769b34f56c5ffcf89a8ea47ff768c6858a" translate="yes" xml:space="preserve">
          <source>Once::gt</source>
          <target state="translated">Once::gt</target>
        </trans-unit>
        <trans-unit id="52b97e5420ac6c5141f11b243b00d6a1d91a82aa" translate="yes" xml:space="preserve">
          <source>Once::inspect</source>
          <target state="translated">Once::inspect</target>
        </trans-unit>
        <trans-unit id="24c9670c06579750ad91802403773c861f00f73c" translate="yes" xml:space="preserve">
          <source>Once::into</source>
          <target state="translated">Once::into</target>
        </trans-unit>
        <trans-unit id="efb0afcea9cf69ad9f300407891f7cf24889abde" translate="yes" xml:space="preserve">
          <source>Once::into_iter</source>
          <target state="translated">Once::into_iter</target>
        </trans-unit>
        <trans-unit id="0608fd7f8eac14cce16ca80dbfd5613b14204122" translate="yes" xml:space="preserve">
          <source>Once::is_completed</source>
          <target state="translated">Once::is_completed</target>
        </trans-unit>
        <trans-unit id="7251c3dcf49fe3c4c5830d926dcb3f340b9a4518" translate="yes" xml:space="preserve">
          <source>Once::is_empty</source>
          <target state="translated">Once::is_empty</target>
        </trans-unit>
        <trans-unit id="4b0fbfe12c4a015929a04dd53407a0499a03410c" translate="yes" xml:space="preserve">
          <source>Once::is_sorted</source>
          <target state="translated">Once::is_sorted</target>
        </trans-unit>
        <trans-unit id="6f25e0f3331d93f4e5eb47652d49ab83abddd5c6" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by</source>
          <target state="translated">Once::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="cb7a1da6af62c62d1c48e6f892b45246ff8fb722" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by_key</source>
          <target state="translated">Once::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="12b8716333449d7ef6ccc84a866d8c71f4d4596a" translate="yes" xml:space="preserve">
          <source>Once::last</source>
          <target state="translated">Once::last</target>
        </trans-unit>
        <trans-unit id="14b21ec5ab3251444e0715d08a995824bf98046f" translate="yes" xml:space="preserve">
          <source>Once::le</source>
          <target state="translated">Once::le</target>
        </trans-unit>
        <trans-unit id="c7ec127a76b81f92cbddfa60f7e443869f07dfc3" translate="yes" xml:space="preserve">
          <source>Once::len</source>
          <target state="translated">Once::len</target>
        </trans-unit>
        <trans-unit id="5200802a32d08edabd28e77c8bfacda66faabb5f" translate="yes" xml:space="preserve">
          <source>Once::lt</source>
          <target state="translated">Once::lt</target>
        </trans-unit>
        <trans-unit id="f2976b7d4debc6f0c6faff19e72feb23c6da98c9" translate="yes" xml:space="preserve">
          <source>Once::map</source>
          <target state="translated">Once::map</target>
        </trans-unit>
        <trans-unit id="37c43ed9043bf5a1d86c776c7a83980f8e44b550" translate="yes" xml:space="preserve">
          <source>Once::max</source>
          <target state="translated">Once::max</target>
        </trans-unit>
        <trans-unit id="42f687a90cb8ae799fc923fe98bf332780e16e1a" translate="yes" xml:space="preserve">
          <source>Once::max_by</source>
          <target state="translated">Once::max_by</target>
        </trans-unit>
        <trans-unit id="f790fae0c1ab8520d2b3bb6dee8c10e0df61fb21" translate="yes" xml:space="preserve">
          <source>Once::max_by_key</source>
          <target state="translated">Once::max_by_key</target>
        </trans-unit>
        <trans-unit id="be86a53ca110f0c0f2e5f786db25770b11e8fb89" translate="yes" xml:space="preserve">
          <source>Once::min</source>
          <target state="translated">Once::min</target>
        </trans-unit>
        <trans-unit id="5b4c2bfd34d4ce8913a24cdbba40c903c58ba228" translate="yes" xml:space="preserve">
          <source>Once::min_by</source>
          <target state="translated">Once::min_by</target>
        </trans-unit>
        <trans-unit id="0ff4bd1f1edb9d1e53ee61824c45a6b65f4eafd0" translate="yes" xml:space="preserve">
          <source>Once::min_by_key</source>
          <target state="translated">Once::min_by_key</target>
        </trans-unit>
        <trans-unit id="6236fe088142c957857770ab09a2b6fc2f27b69e" translate="yes" xml:space="preserve">
          <source>Once::ne</source>
          <target state="translated">Once::ne</target>
        </trans-unit>
        <trans-unit id="7d6911dda1f2483e209159a8e136b2c52051e6bb" translate="yes" xml:space="preserve">
          <source>Once::new</source>
          <target state="translated">Once::new</target>
        </trans-unit>
        <trans-unit id="578bd116c5e7fde5716979b05be2a783abe2fcec" translate="yes" xml:space="preserve">
          <source>Once::next</source>
          <target state="translated">Once::next</target>
        </trans-unit>
        <trans-unit id="8af821c9e317f67614d97739eed7d7394a46629b" translate="yes" xml:space="preserve">
          <source>Once::next_back</source>
          <target state="translated">Once::next_back</target>
        </trans-unit>
        <trans-unit id="430bb3482a938ef6cd7fe977041d4fa3bbc1fc55" translate="yes" xml:space="preserve">
          <source>Once::nth</source>
          <target state="translated">Once::nth</target>
        </trans-unit>
        <trans-unit id="c55b0c5a25d6a4c7729b67045964bd182f6c743b" translate="yes" xml:space="preserve">
          <source>Once::nth_back</source>
          <target state="translated">Once::nth_back</target>
        </trans-unit>
        <trans-unit id="22c36618829e3a03fdefff9bbca40dbd8e473846" translate="yes" xml:space="preserve">
          <source>Once::partial_cmp</source>
          <target state="translated">Once::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7269ba05ed7753f4b47e7a0b54fad46c7fdfa25" translate="yes" xml:space="preserve">
          <source>Once::partition</source>
          <target state="translated">Once::partition</target>
        </trans-unit>
        <trans-unit id="a2a93318d906b75ba7d478b7d2053f09b5d47c8e" translate="yes" xml:space="preserve">
          <source>Once::peekable</source>
          <target state="translated">Once::peekable</target>
        </trans-unit>
        <trans-unit id="443ba5a518af1ceeeb00165b521452d07ea04e5b" translate="yes" xml:space="preserve">
          <source>Once::position</source>
          <target state="translated">Once::position</target>
        </trans-unit>
        <trans-unit id="aefb04c2392cc211f451d367f733cc6c65c3e11b" translate="yes" xml:space="preserve">
          <source>Once::product</source>
          <target state="translated">Once::product</target>
        </trans-unit>
        <trans-unit id="0bc9c08f73c34cac78d945ebc22d8397bbb66131" translate="yes" xml:space="preserve">
          <source>Once::rev</source>
          <target state="translated">Once::rev</target>
        </trans-unit>
        <trans-unit id="3c7856aff7c1c10689eb91760b905ac36a86fd8f" translate="yes" xml:space="preserve">
          <source>Once::rfind</source>
          <target state="translated">Once::rfind</target>
        </trans-unit>
        <trans-unit id="bb98b537fa90b815cfad245be9b6f8a9980c10ad" translate="yes" xml:space="preserve">
          <source>Once::rfold</source>
          <target state="translated">Once::rfold</target>
        </trans-unit>
        <trans-unit id="068dbc2b0446d02924974dc89dc2e5c0506be3c0" translate="yes" xml:space="preserve">
          <source>Once::rposition</source>
          <target state="translated">Once::rposition</target>
        </trans-unit>
        <trans-unit id="2f7d42081a9a3b1a18973e17303b804987f7c991" translate="yes" xml:space="preserve">
          <source>Once::scan</source>
          <target state="translated">Once::scan</target>
        </trans-unit>
        <trans-unit id="689e357b41f0be20a1862814b9c83d77ef8f1e70" translate="yes" xml:space="preserve">
          <source>Once::size_hint</source>
          <target state="translated">Once::size_hint</target>
        </trans-unit>
        <trans-unit id="cbf339d38d49468cb345d7cfb9cb77b78f365fd1" translate="yes" xml:space="preserve">
          <source>Once::skip</source>
          <target state="translated">Once::skip</target>
        </trans-unit>
        <trans-unit id="86fd91a24a1bbc66ca2ece695858498a65db16dd" translate="yes" xml:space="preserve">
          <source>Once::skip_while</source>
          <target state="translated">Once::skip_while</target>
        </trans-unit>
        <trans-unit id="6fe0f81f7153271dc977040947a6cad61882f9d1" translate="yes" xml:space="preserve">
          <source>Once::step_by</source>
          <target state="translated">Once::step_by</target>
        </trans-unit>
        <trans-unit id="033b2578f1615ee184814d95335d5fd74302c231" translate="yes" xml:space="preserve">
          <source>Once::sum</source>
          <target state="translated">Once::sum</target>
        </trans-unit>
        <trans-unit id="442e2927616d29972c328197ab646af0a109e0ac" translate="yes" xml:space="preserve">
          <source>Once::take</source>
          <target state="translated">Once::take</target>
        </trans-unit>
        <trans-unit id="e0055054cf1a45bf179b412f905b6b7b804fe427" translate="yes" xml:space="preserve">
          <source>Once::take_while</source>
          <target state="translated">Once::take_while</target>
        </trans-unit>
        <trans-unit id="1ff7fdb84e0ce09813e50c320654790d32c718fe" translate="yes" xml:space="preserve">
          <source>Once::to_owned</source>
          <target state="translated">Once::to_owned</target>
        </trans-unit>
        <trans-unit id="b045ee709dc7ad89b9c21500aecbcde1537d7e58" translate="yes" xml:space="preserve">
          <source>Once::try_fold</source>
          <target state="translated">Once::try_fold</target>
        </trans-unit>
        <trans-unit id="ca7011c5d5b35881f4391164193c191f7c91a8ed" translate="yes" xml:space="preserve">
          <source>Once::try_for_each</source>
          <target state="translated">Once::try_for_each</target>
        </trans-unit>
        <trans-unit id="145392f846fa35a3754a9cdb737cf3389c9b3bb1" translate="yes" xml:space="preserve">
          <source>Once::try_from</source>
          <target state="translated">Once::try_from</target>
        </trans-unit>
        <trans-unit id="36d585158ca953d0dbbe69c61419f1e9cfd5cbd0" translate="yes" xml:space="preserve">
          <source>Once::try_into</source>
          <target state="translated">Once::try_into</target>
        </trans-unit>
        <trans-unit id="bb47966988d0ea30157cfc9b32edfc0454ef3340" translate="yes" xml:space="preserve">
          <source>Once::try_rfold</source>
          <target state="translated">Once::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e7005b30f23dbe8e521fbb090487b02e260839e" translate="yes" xml:space="preserve">
          <source>Once::type_id</source>
          <target state="translated">Once::type_id</target>
        </trans-unit>
        <trans-unit id="89b4b7dbbcd40342a9b06361de2f912cf9887391" translate="yes" xml:space="preserve">
          <source>Once::unzip</source>
          <target state="translated">Once::unzip</target>
        </trans-unit>
        <trans-unit id="9c587dbc5b4ada9eb96816888453bd9099854f2c" translate="yes" xml:space="preserve">
          <source>Once::zip</source>
          <target state="translated">Once::zip</target>
        </trans-unit>
        <trans-unit id="69dcb4de79e8a81381a0466b75f257a36ecf89cd" translate="yes" xml:space="preserve">
          <source>OnceCell</source>
          <target state="translated">OnceCell</target>
        </trans-unit>
        <trans-unit id="2db71cb543a4836972aba340022bf66c34ca9483" translate="yes" xml:space="preserve">
          <source>OnceState</source>
          <target state="translated">OnceState</target>
        </trans-unit>
        <trans-unit id="864b2494c0a17291fe44802d2dfa7280c6515a58" translate="yes" xml:space="preserve">
          <source>OnceState::borrow</source>
          <target state="translated">OnceState::borrow</target>
        </trans-unit>
        <trans-unit id="3ba03425574355acef161a03b37753e3dc3fce0d" translate="yes" xml:space="preserve">
          <source>OnceState::borrow_mut</source>
          <target state="translated">OnceState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="137f612918b3ff9f01b5b2eed8a892cbbde080f1" translate="yes" xml:space="preserve">
          <source>OnceState::fmt</source>
          <target state="translated">OnceState::fmt</target>
        </trans-unit>
        <trans-unit id="cc9d74ec28c33e153d2d0894a6de5f14c5c9aabd" translate="yes" xml:space="preserve">
          <source>OnceState::from</source>
          <target state="translated">OnceState::from</target>
        </trans-unit>
        <trans-unit id="d968db4b631f42cce77d0ea2bff8656be4e57c06" translate="yes" xml:space="preserve">
          <source>OnceState::into</source>
          <target state="translated">OnceState::into</target>
        </trans-unit>
        <trans-unit id="5279da3ce88f5a2ebd344f9b9ae566f2cb009268" translate="yes" xml:space="preserve">
          <source>OnceState::poisoned</source>
          <target state="translated">OnceState::poisoned</target>
        </trans-unit>
        <trans-unit id="8447bc72e127b3443efef418a2e8188e3cc3f620" translate="yes" xml:space="preserve">
          <source>OnceState::try_from</source>
          <target state="translated">OnceState::try_from</target>
        </trans-unit>
        <trans-unit id="2a35fc55239b76803a74ad10688fe793f6102501" translate="yes" xml:space="preserve">
          <source>OnceState::try_into</source>
          <target state="translated">OnceState::try_into</target>
        </trans-unit>
        <trans-unit id="fcd8d541e6822fd809940974bebc8a81f8b16c8d" translate="yes" xml:space="preserve">
          <source>OnceState::type_id</source>
          <target state="translated">OnceState::type_id</target>
        </trans-unit>
        <trans-unit id="bac414ebd5a08ef0bd8f0f09a9b6b081da1540b4" translate="yes" xml:space="preserve">
          <source>OnceWith</source>
          <target state="translated">OnceWith</target>
        </trans-unit>
        <trans-unit id="9421b02fba334e65b31591c89d7fcfa34aea5e57" translate="yes" xml:space="preserve">
          <source>OnceWith::all</source>
          <target state="translated">OnceWith::all</target>
        </trans-unit>
        <trans-unit id="ec045f959571abb529fe845ffb143c5aa440d98a" translate="yes" xml:space="preserve">
          <source>OnceWith::any</source>
          <target state="translated">OnceWith::any</target>
        </trans-unit>
        <trans-unit id="1ef37dd0c57f299c431f6fc7296ed50225f08e1a" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow</source>
          <target state="translated">OnceWith::borrow</target>
        </trans-unit>
        <trans-unit id="527f129227b962c7154dfbbc8fa56239753273a3" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow_mut</source>
          <target state="translated">OnceWith::borrow_mut</target>
        </trans-unit>
        <trans-unit id="220386db15c3ac797f2d78a1fa6328e0e524bbaa" translate="yes" xml:space="preserve">
          <source>OnceWith::by_ref</source>
          <target state="translated">OnceWith::by_ref</target>
        </trans-unit>
        <trans-unit id="8cca4e55ae50dd0aee68afe79ea244d5bca99ced" translate="yes" xml:space="preserve">
          <source>OnceWith::chain</source>
          <target state="translated">OnceWith::chain</target>
        </trans-unit>
        <trans-unit id="69a3e8d814785ab85c33556c6a099c9cc6ea940e" translate="yes" xml:space="preserve">
          <source>OnceWith::clone</source>
          <target state="translated">OnceWith::clone</target>
        </trans-unit>
        <trans-unit id="18ada5e17d413555745065a07348ed90106c203d" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_from</source>
          <target state="translated">OnceWith::clone_from</target>
        </trans-unit>
        <trans-unit id="840d6af9e9dfbf237e7af2ccf27dbd5ad69cee46" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_into</source>
          <target state="translated">OnceWith::clone_into</target>
        </trans-unit>
        <trans-unit id="28fb35fd1901c33eee7b84b451b7753c7c867260" translate="yes" xml:space="preserve">
          <source>OnceWith::cloned</source>
          <target state="translated">OnceWith::cloned</target>
        </trans-unit>
        <trans-unit id="30d119dee0d9c070c3e61005d6831099ce8bd793" translate="yes" xml:space="preserve">
          <source>OnceWith::cmp</source>
          <target state="translated">OnceWith::cmp</target>
        </trans-unit>
        <trans-unit id="abe9447efe3162bb1b99fa4be3a78e85a49dc04b" translate="yes" xml:space="preserve">
          <source>OnceWith::collect</source>
          <target state="translated">OnceWith::collect</target>
        </trans-unit>
        <trans-unit id="4d6da14365d0d73a28c1b23f782a042915618b92" translate="yes" xml:space="preserve">
          <source>OnceWith::copied</source>
          <target state="translated">OnceWith::copied</target>
        </trans-unit>
        <trans-unit id="7016f9903cc220eec1b3d930f0d6d91062934899" translate="yes" xml:space="preserve">
          <source>OnceWith::count</source>
          <target state="translated">OnceWith::count</target>
        </trans-unit>
        <trans-unit id="addfc373b9df5fc305b9e5e6eb635cd2466d07d4" translate="yes" xml:space="preserve">
          <source>OnceWith::cycle</source>
          <target state="translated">OnceWith::cycle</target>
        </trans-unit>
        <trans-unit id="095f0dc0c2b642b81131fb698197ca6766b54a2e" translate="yes" xml:space="preserve">
          <source>OnceWith::enumerate</source>
          <target state="translated">OnceWith::enumerate</target>
        </trans-unit>
        <trans-unit id="7e9ec613a8f6c55d8eb6ea553ee7ebd7e6244ce6" translate="yes" xml:space="preserve">
          <source>OnceWith::eq</source>
          <target state="translated">OnceWith::eq</target>
        </trans-unit>
        <trans-unit id="f3f3ad0faefd45bbd859ece3bf3eef9075759214" translate="yes" xml:space="preserve">
          <source>OnceWith::filter</source>
          <target state="translated">OnceWith::filter</target>
        </trans-unit>
        <trans-unit id="ea81115d4b00890df3a160e9b9a84ff71ded3a01" translate="yes" xml:space="preserve">
          <source>OnceWith::filter_map</source>
          <target state="translated">OnceWith::filter_map</target>
        </trans-unit>
        <trans-unit id="04462b9dd7bbda24ad2bd90e2b7883781de4acd6" translate="yes" xml:space="preserve">
          <source>OnceWith::find</source>
          <target state="translated">OnceWith::find</target>
        </trans-unit>
        <trans-unit id="aca2dee92401221e00169ab44175f018d2db65f4" translate="yes" xml:space="preserve">
          <source>OnceWith::find_map</source>
          <target state="translated">OnceWith::find_map</target>
        </trans-unit>
        <trans-unit id="10d39de4f24d2dcddb78ea6874f21fecb0e42b39" translate="yes" xml:space="preserve">
          <source>OnceWith::flat_map</source>
          <target state="translated">OnceWith::flat_map</target>
        </trans-unit>
        <trans-unit id="6ff780249f2a51d00d5d95dcfd4610dadafd2bd8" translate="yes" xml:space="preserve">
          <source>OnceWith::flatten</source>
          <target state="translated">OnceWith::flatten</target>
        </trans-unit>
        <trans-unit id="e7394a8ea887cd043223fc687a97cc1f193256c1" translate="yes" xml:space="preserve">
          <source>OnceWith::fmt</source>
          <target state="translated">OnceWith::fmt</target>
        </trans-unit>
        <trans-unit id="5e004a4ea95a589f773f9befbef25abe72f46ba2" translate="yes" xml:space="preserve">
          <source>OnceWith::fold</source>
          <target state="translated">OnceWith::fold</target>
        </trans-unit>
        <trans-unit id="0826514ea858174b22832240424d387a6a62a698" translate="yes" xml:space="preserve">
          <source>OnceWith::for_each</source>
          <target state="translated">OnceWith::for_each</target>
        </trans-unit>
        <trans-unit id="6f44e41130791319e6c6d5e080615570ac91fa72" translate="yes" xml:space="preserve">
          <source>OnceWith::from</source>
          <target state="translated">OnceWith::from</target>
        </trans-unit>
        <trans-unit id="d991094123caac201e372f78da1221c72316dec1" translate="yes" xml:space="preserve">
          <source>OnceWith::fuse</source>
          <target state="translated">OnceWith::fuse</target>
        </trans-unit>
        <trans-unit id="491865c492a9358b9d74d7461f65fbb3c2ad3116" translate="yes" xml:space="preserve">
          <source>OnceWith::ge</source>
          <target state="translated">OnceWith::ge</target>
        </trans-unit>
        <trans-unit id="cb6cb84ba3cef039e288bea61f9e271654ca16b3" translate="yes" xml:space="preserve">
          <source>OnceWith::gt</source>
          <target state="translated">OnceWith::gt</target>
        </trans-unit>
        <trans-unit id="f9bca0dbc5eb1308057e3acda537f87ae5584bf0" translate="yes" xml:space="preserve">
          <source>OnceWith::inspect</source>
          <target state="translated">OnceWith::inspect</target>
        </trans-unit>
        <trans-unit id="130c0779f2fab716215af75fb82426f43a016224" translate="yes" xml:space="preserve">
          <source>OnceWith::into</source>
          <target state="translated">OnceWith::into</target>
        </trans-unit>
        <trans-unit id="e53104deb8174e788d926bdbaa53ed5840ec7390" translate="yes" xml:space="preserve">
          <source>OnceWith::into_iter</source>
          <target state="translated">OnceWith::into_iter</target>
        </trans-unit>
        <trans-unit id="57fb266c4456dcf8194282f31a9c9693a675f52f" translate="yes" xml:space="preserve">
          <source>OnceWith::is_empty</source>
          <target state="translated">OnceWith::is_empty</target>
        </trans-unit>
        <trans-unit id="35067e17a5dc55a4bb918b85dcd10ca948035cb7" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted</source>
          <target state="translated">OnceWith::is_sorted</target>
        </trans-unit>
        <trans-unit id="fa54dbd797d14264ee865bf4783d41bbaaceb9bb" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by</source>
          <target state="translated">OnceWith::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0805f33825aaffa765bd319b5f5123f28e25c541" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by_key</source>
          <target state="translated">OnceWith::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b8642e0e6fa2a743b75cee962cacad7d55075240" translate="yes" xml:space="preserve">
          <source>OnceWith::last</source>
          <target state="translated">OnceWith::last</target>
        </trans-unit>
        <trans-unit id="93fa8fd9eba96e349d5cb407b64fe72f152eb5a8" translate="yes" xml:space="preserve">
          <source>OnceWith::le</source>
          <target state="translated">OnceWith::le</target>
        </trans-unit>
        <trans-unit id="7222c5552e670e1ab40e927a15a3bb3893a18137" translate="yes" xml:space="preserve">
          <source>OnceWith::len</source>
          <target state="translated">OnceWith::len</target>
        </trans-unit>
        <trans-unit id="115bc72442e41419d2748702b3dc2105c1045ca1" translate="yes" xml:space="preserve">
          <source>OnceWith::lt</source>
          <target state="translated">OnceWith::lt</target>
        </trans-unit>
        <trans-unit id="4a5a3ea857244c9e36891ebf8831e5ae98613302" translate="yes" xml:space="preserve">
          <source>OnceWith::map</source>
          <target state="translated">OnceWith::map</target>
        </trans-unit>
        <trans-unit id="e13117c44b319bc7f0f9709faa2a5544da1bccc4" translate="yes" xml:space="preserve">
          <source>OnceWith::max</source>
          <target state="translated">OnceWith::max</target>
        </trans-unit>
        <trans-unit id="5fe974dd4baeb92c36de177f1091466a40a950e9" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by</source>
          <target state="translated">OnceWith::max_by</target>
        </trans-unit>
        <trans-unit id="4bced0b61c3c1cb8410f882718a68a33aeae5a9b" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by_key</source>
          <target state="translated">OnceWith::max_by_key</target>
        </trans-unit>
        <trans-unit id="06568f09e719a331a84ceae60f4b66de6e9d0ea4" translate="yes" xml:space="preserve">
          <source>OnceWith::min</source>
          <target state="translated">OnceWith::min</target>
        </trans-unit>
        <trans-unit id="286481980c2d0b526534de52416aa1cce0683996" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by</source>
          <target state="translated">OnceWith::min_by</target>
        </trans-unit>
        <trans-unit id="5dd37a258caeec2b0eb6451dca8a726b836a9a92" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by_key</source>
          <target state="translated">OnceWith::min_by_key</target>
        </trans-unit>
        <trans-unit id="69f93b3a318af71379ddca4ec93fe8d140ce5f0f" translate="yes" xml:space="preserve">
          <source>OnceWith::ne</source>
          <target state="translated">OnceWith::ne</target>
        </trans-unit>
        <trans-unit id="ac26f725cccaf1526e5014347f9adea936f74ce7" translate="yes" xml:space="preserve">
          <source>OnceWith::next</source>
          <target state="translated">OnceWith::next</target>
        </trans-unit>
        <trans-unit id="e4330c855cf5f92fc7584c51cdee41319443487c" translate="yes" xml:space="preserve">
          <source>OnceWith::next_back</source>
          <target state="translated">OnceWith::next_back</target>
        </trans-unit>
        <trans-unit id="1527b9229bda86674b9d9102f7590dba88349ecd" translate="yes" xml:space="preserve">
          <source>OnceWith::nth</source>
          <target state="translated">OnceWith::nth</target>
        </trans-unit>
        <trans-unit id="52e0f2df5caf846213c666b22fff6456cda8a68f" translate="yes" xml:space="preserve">
          <source>OnceWith::nth_back</source>
          <target state="translated">OnceWith::nth_back</target>
        </trans-unit>
        <trans-unit id="2d124bbf09c7f2b80ff84f088c67f3f07ae5780b" translate="yes" xml:space="preserve">
          <source>OnceWith::partial_cmp</source>
          <target state="translated">OnceWith::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cabc7165c7c9b316158511856e73e51b4305e89b" translate="yes" xml:space="preserve">
          <source>OnceWith::partition</source>
          <target state="translated">OnceWith::partition</target>
        </trans-unit>
        <trans-unit id="1cda021009cce16eced253abaf1a3a1b11566d18" translate="yes" xml:space="preserve">
          <source>OnceWith::peekable</source>
          <target state="translated">OnceWith::peekable</target>
        </trans-unit>
        <trans-unit id="03590b6367dd3bb1ba4d65b39afee2b09ca08df1" translate="yes" xml:space="preserve">
          <source>OnceWith::position</source>
          <target state="translated">OnceWith::position</target>
        </trans-unit>
        <trans-unit id="e1735abbbee6972dc130e89d570fd8fa919407fe" translate="yes" xml:space="preserve">
          <source>OnceWith::product</source>
          <target state="translated">OnceWith::product</target>
        </trans-unit>
        <trans-unit id="ec925c93a26e2eadc7d07e055f695e74c83d4c23" translate="yes" xml:space="preserve">
          <source>OnceWith::rev</source>
          <target state="translated">OnceWith::rev</target>
        </trans-unit>
        <trans-unit id="6243776ef017e4a1cf3d502a3968703e2ab8d6ed" translate="yes" xml:space="preserve">
          <source>OnceWith::rfind</source>
          <target state="translated">OnceWith::rfind</target>
        </trans-unit>
        <trans-unit id="aea12fd7d31659bccdee8c41ecdb4fb0f15444db" translate="yes" xml:space="preserve">
          <source>OnceWith::rfold</source>
          <target state="translated">OnceWith::rfold</target>
        </trans-unit>
        <trans-unit id="0c9e294cb61289d08c63ceca07aff5dfaea0261e" translate="yes" xml:space="preserve">
          <source>OnceWith::rposition</source>
          <target state="translated">OnceWith::rposition</target>
        </trans-unit>
        <trans-unit id="cef9b43e5eedf9af103faef7b1bbe4d12db9ab2f" translate="yes" xml:space="preserve">
          <source>OnceWith::scan</source>
          <target state="translated">OnceWith::scan</target>
        </trans-unit>
        <trans-unit id="cc6e5c82263a6bf9a575956ff17a327f6e8e1a12" translate="yes" xml:space="preserve">
          <source>OnceWith::size_hint</source>
          <target state="translated">OnceWith::size_hint</target>
        </trans-unit>
        <trans-unit id="eb30275a1bfcdf9e0075819a60e55de8140da973" translate="yes" xml:space="preserve">
          <source>OnceWith::skip</source>
          <target state="translated">OnceWith::skip</target>
        </trans-unit>
        <trans-unit id="d51df4ad9879230eee4b7d1f410130e26dd6a97e" translate="yes" xml:space="preserve">
          <source>OnceWith::skip_while</source>
          <target state="translated">OnceWith::skip_while</target>
        </trans-unit>
        <trans-unit id="13b1461f738d3541f7f825bf588919136b55d36d" translate="yes" xml:space="preserve">
          <source>OnceWith::step_by</source>
          <target state="translated">OnceWith::step_by</target>
        </trans-unit>
        <trans-unit id="74e43ad0cf8bc22a5af2d491f032ca5523c1d7b0" translate="yes" xml:space="preserve">
          <source>OnceWith::sum</source>
          <target state="translated">OnceWith::sum</target>
        </trans-unit>
        <trans-unit id="89cc6b13712f2c2ac536c3feb4e1809f1a6b5cc2" translate="yes" xml:space="preserve">
          <source>OnceWith::take</source>
          <target state="translated">OnceWith::take</target>
        </trans-unit>
        <trans-unit id="8c2cd8a3d3dfa6e2cb6f5f270f11cddff7173ce1" translate="yes" xml:space="preserve">
          <source>OnceWith::take_while</source>
          <target state="translated">OnceWith::take_while</target>
        </trans-unit>
        <trans-unit id="5a630013ba78b1577b011778f861dca34fdb6510" translate="yes" xml:space="preserve">
          <source>OnceWith::to_owned</source>
          <target state="translated">OnceWith::to_owned</target>
        </trans-unit>
        <trans-unit id="030ec595a21a12e03c641afa5fc2a0fbf3cfd96d" translate="yes" xml:space="preserve">
          <source>OnceWith::try_fold</source>
          <target state="translated">OnceWith::try_fold</target>
        </trans-unit>
        <trans-unit id="716d560ebaa2fa12887a04435f9271204fee9212" translate="yes" xml:space="preserve">
          <source>OnceWith::try_for_each</source>
          <target state="translated">OnceWith::try_for_each</target>
        </trans-unit>
        <trans-unit id="585e7e8b9f7e6990f4b13d54ca37d88a0bf70ca8" translate="yes" xml:space="preserve">
          <source>OnceWith::try_from</source>
          <target state="translated">OnceWith::try_from</target>
        </trans-unit>
        <trans-unit id="7cb93d634335cbd032ccfe91d14126a928250279" translate="yes" xml:space="preserve">
          <source>OnceWith::try_into</source>
          <target state="translated">OnceWith::try_into</target>
        </trans-unit>
        <trans-unit id="640ef41bdeff4cb6f8ee26085f02e8464a124452" translate="yes" xml:space="preserve">
          <source>OnceWith::try_rfold</source>
          <target state="translated">OnceWith::try_rfold</target>
        </trans-unit>
        <trans-unit id="100a64512cd2fe1b9fbd4ceea4850862b8f813b7" translate="yes" xml:space="preserve">
          <source>OnceWith::type_id</source>
          <target state="translated">OnceWith::type_id</target>
        </trans-unit>
        <trans-unit id="64fd105a0a6aa5f709a9477cafb3d6c01fd6cfb0" translate="yes" xml:space="preserve">
          <source>OnceWith::unzip</source>
          <target state="translated">OnceWith::unzip</target>
        </trans-unit>
        <trans-unit id="433df116ad00f74cb6d78ea83682ace23f21cb19" translate="yes" xml:space="preserve">
          <source>OnceWith::zip</source>
          <target state="translated">OnceWith::zip</target>
        </trans-unit>
        <trans-unit id="c04e60357eae6b0d2f646024db69bbf3bdb3f30b" translate="yes" xml:space="preserve">
          <source>One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of &lt;code&gt;grep&lt;/code&gt;, called &lt;code&gt;ripgrep&lt;/code&gt;. By comparison, our version of &lt;code&gt;grep&lt;/code&gt; will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as &lt;code&gt;ripgrep&lt;/code&gt;.</source>
          <target state="translated">Un miembro de la comunidad de Rust, Andrew Gallant, ya ha creado una versi&amp;oacute;n muy r&amp;aacute;pida y con todas las funciones de &lt;code&gt;grep&lt;/code&gt; , llamada &lt;code&gt;ripgrep&lt;/code&gt; . En comparaci&amp;oacute;n, nuestra versi&amp;oacute;n de &lt;code&gt;grep&lt;/code&gt; ser&amp;aacute; bastante simple, pero este cap&amp;iacute;tulo le dar&amp;aacute; algunos de los conocimientos &lt;code&gt;ripgrep&lt;/code&gt; que necesita para comprender un proyecto del mundo real como ripgrep .</target>
        </trans-unit>
        <trans-unit id="6d8cb1de18a6c59ff63b7aa03082a18e5d9546ee" translate="yes" xml:space="preserve">
          <source>One benefit of implementing &lt;code&gt;IntoIterator&lt;/code&gt; is that your type will &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;work with Rust's &lt;code&gt;for&lt;/code&gt; loop syntax&lt;/a&gt;.</source>
          <target state="translated">Un beneficio de implementar &lt;code&gt;IntoIterator&lt;/code&gt; es que su tipo &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;funcionar&amp;aacute; con la sintaxis de bucle &lt;code&gt;for&lt;/code&gt; de Rust&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5bdf955d9dc47b0601586e8217dda6094c541f" translate="yes" xml:space="preserve">
          <source>One character can become multiple:</source>
          <target state="translated">Un personaje puede convertirse en varios:</target>
        </trans-unit>
        <trans-unit id="9a0e2dea9fc38cc31adcbb6e264358edce5cb875" translate="yes" xml:space="preserve">
          <source>One could use &lt;code&gt;std::os::raw::c_void&lt;/code&gt; if they want to support old Rust compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by this definition. For more information, please read &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md&quot;&gt;RFC 2521&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa91f526636a9109f1e67616db8e82d52af8d580" translate="yes" xml:space="preserve">
          <source>One detail we didn&amp;rsquo;t discuss in the &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;References and Borrowing&amp;rdquo;&lt;/a&gt; section in Chapter 4 is that every reference in Rust has a &lt;em&gt;lifetime&lt;/em&gt;, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</source>
          <target state="translated">Un detalle que no discutimos en la secci&amp;oacute;n &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;Referencias y pr&amp;eacute;stamos&amp;rdquo;&lt;/a&gt; del Cap&amp;iacute;tulo 4 es que cada referencia en Rust tiene una &lt;em&gt;vida &amp;uacute;til&lt;/em&gt; , que es el alcance para el que esa referencia es v&amp;aacute;lida. La mayor&amp;iacute;a de las veces, las vidas est&amp;aacute;n impl&amp;iacute;citas y se infieren, al igual que la mayor&amp;iacute;a de las veces, se infieren tipos. Debemos anotar tipos cuando son posibles varios tipos. De manera similar, debemos anotar las vidas cuando las vidas de las referencias podr&amp;iacute;an estar relacionadas de diferentes formas. Rust requiere que anotemos las relaciones utilizando par&amp;aacute;metros de vida &amp;uacute;til gen&amp;eacute;ricos para garantizar que las referencias reales utilizadas en tiempo de ejecuci&amp;oacute;n sean definitivamente v&amp;aacute;lidas.</target>
        </trans-unit>
        <trans-unit id="d218cebb1b26aab7ac78425185eee65d682c0943" translate="yes" xml:space="preserve">
          <source>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between &lt;code&gt;PendingReview&lt;/code&gt; and &lt;code&gt;Published&lt;/code&gt;, such as &lt;code&gt;Scheduled&lt;/code&gt;, we would have to change the code in &lt;code&gt;PendingReview&lt;/code&gt; to transition to &lt;code&gt;Scheduled&lt;/code&gt; instead. It would be less work if &lt;code&gt;PendingReview&lt;/code&gt; didn&amp;rsquo;t need to change with the addition of a new state, but that would mean switching to another design pattern.</source>
          <target state="translated">Una desventaja del patr&amp;oacute;n estatal es que, debido a que los estados implementan las transiciones entre estados, algunos de los estados est&amp;aacute;n acoplados entre s&amp;iacute;. Si agregamos otro estado entre &lt;code&gt;PendingReview&lt;/code&gt; y &lt;code&gt;Published&lt;/code&gt; , como &lt;code&gt;Scheduled&lt;/code&gt; , tendr&amp;iacute;amos que cambiar el c&amp;oacute;digo en &lt;code&gt;PendingReview&lt;/code&gt; para hacer la transici&amp;oacute;n a &lt;code&gt;Scheduled&lt;/code&gt; . Ser&amp;iacute;a menos trabajo si &lt;code&gt;PendingReview&lt;/code&gt; no necesitara cambiar con la adici&amp;oacute;n de un nuevo estado, pero eso significar&amp;iacute;a cambiar a otro patr&amp;oacute;n de dise&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="79dab74a608a5fe55775f425d883e5609ea6484a" translate="yes" xml:space="preserve">
          <source>One example of a trait with an associated type is the &lt;code&gt;Iterator&lt;/code&gt; trait that the standard library provides. The associated type is named &lt;code&gt;Item&lt;/code&gt; and stands in for the type of the values the type implementing the &lt;code&gt;Iterator&lt;/code&gt; trait is iterating over. In &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;ldquo;The &lt;code&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method&amp;rdquo;&lt;/a&gt; section of Chapter 13, we mentioned that the definition of the &lt;code&gt;Iterator&lt;/code&gt; trait is as shown in Listing 19-12.</source>
          <target state="translated">Un ejemplo de un rasgo con un tipo asociado es el rasgo &lt;code&gt;Iterator&lt;/code&gt; que proporciona la biblioteca est&amp;aacute;ndar. El tipo asociado es el nombre &lt;code&gt;Item&lt;/code&gt; y se encuentra en el tipo de los valores de la aplicaci&amp;oacute;n del tipo &lt;code&gt;Iterator&lt;/code&gt; rasgo es una iteraci&amp;oacute;n. En &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;la&lt;/a&gt; secci&amp;oacute;n &amp;ldquo;El rasgo del &lt;code&gt;Iterator&lt;/code&gt; y el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo&amp;rdquo; del Cap&amp;iacute;tulo 13, mencionamos que la definici&amp;oacute;n del rasgo del &lt;code&gt;Iterator&lt;/code&gt; es como se muestra en el Listado 19-12.</target>
        </trans-unit>
        <trans-unit id="6e24d429d27b48134811a91f7546e1e6d93fd489" translate="yes" xml:space="preserve">
          <source>One final expression that has the type &lt;code&gt;!&lt;/code&gt; is a &lt;code&gt;loop&lt;/code&gt;:</source>
          <target state="translated">&amp;iexcl;Una &amp;uacute;ltima expresi&amp;oacute;n que tiene el tipo &lt;code&gt;!&lt;/code&gt; es un &lt;code&gt;loop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08b7d5a5c0be732c550b04476aeb4d64ed0d9f34" translate="yes" xml:space="preserve">
          <source>One fix is to use &lt;code&gt;Option&lt;/code&gt;, like so:</source>
          <target state="translated">Una soluci&amp;oacute;n es usar &lt;code&gt;Option&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="0404f28b47072e36d14ad36dc7e51fdfb00d1799" translate="yes" xml:space="preserve">
          <source>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</source>
          <target state="translated">Una solución puede ser aumentar el límite de recursividad.Obsérvese que es posible crear una recursividad infinita de desreferenciación,en cuyo caso el único arreglo es romper de alguna manera la recursividad.</target>
        </trans-unit>
        <trans-unit id="604777bf4c9ef568f65e74a5ef4770d9197bf0e4" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent.</source>
          <target state="translated">Uno mayor que la mínima potencia normal posible de 2 exponentes.</target>
        </trans-unit>
        <trans-unit id="d1aad5d49e44c9e98dc9d596c60e87f16270d447" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f32::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af913244c1df707f9c82d8aebefb4735e4abcae8" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f64::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6888a831481b2df0737ae6067a1763cc0ae4b8b" translate="yes" xml:space="preserve">
          <source>One important part of this code is that the &lt;code&gt;Messenger&lt;/code&gt; trait has one method called &lt;code&gt;send&lt;/code&gt; that takes an immutable reference to &lt;code&gt;self&lt;/code&gt; and the text of the message. This is the interface our mock object needs to have. The other important part is that we want to test the behavior of the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt;. We can change what we pass in for the &lt;code&gt;value&lt;/code&gt; parameter, but &lt;code&gt;set_value&lt;/code&gt; doesn&amp;rsquo;t return anything for us to make assertions on. We want to be able to say that if we create a &lt;code&gt;LimitTracker&lt;/code&gt; with something that implements the &lt;code&gt;Messenger&lt;/code&gt; trait and a particular value for &lt;code&gt;max&lt;/code&gt;, when we pass different numbers for &lt;code&gt;value&lt;/code&gt;, the messenger is told to send the appropriate messages.</source>
          <target state="translated">Una parte importante de este c&amp;oacute;digo es que el rasgo &lt;code&gt;Messenger&lt;/code&gt; tiene un m&amp;eacute;todo llamado &lt;code&gt;send&lt;/code&gt; que toma una referencia inmutable a &lt;code&gt;self&lt;/code&gt; y al texto del mensaje. Esta es la interfaz que nuestro objeto simulado debe tener. La otra parte importante es que queremos probar el comportamiento del m&amp;eacute;todo &lt;code&gt;set_value&lt;/code&gt; en &lt;code&gt;LimitTracker&lt;/code&gt; . Podemos cambiar lo que pasamos por el par&amp;aacute;metro de &lt;code&gt;value&lt;/code&gt; , pero &lt;code&gt;set_value&lt;/code&gt; no devuelve nada para que podamos hacer afirmaciones. Queremos poder decir que si creamos un &lt;code&gt;LimitTracker&lt;/code&gt; con algo que implemente el rasgo &lt;code&gt;Messenger&lt;/code&gt; y un valor particular para &lt;code&gt;max&lt;/code&gt; , cuando pasamos diferentes n&amp;uacute;meros por &lt;code&gt;value&lt;/code&gt; , se le dice al mensajero que env&amp;iacute;e los mensajes apropiados.</target>
        </trans-unit>
        <trans-unit id="ded7cc38097138108681f22bf5306daeb4f49884" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">Un enfoque cada vez m&amp;aacute;s popular para garantizar la concurrencia segura es el &lt;em&gt;paso de mensajes&lt;/em&gt; , en el que los hilos o los actores se comunican envi&amp;aacute;ndose mensajes que contienen datos. Aqu&amp;iacute; est&amp;aacute; la idea en un eslogan de &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;la documentaci&amp;oacute;n de Go Language&lt;/a&gt; : &amp;ldquo;No te comuniques compartiendo la memoria; en cambio, comparte la memoria comunic&amp;aacute;ndote &quot;.</target>
        </trans-unit>
        <trans-unit id="d3eaa18d42b0806c5f4bdf2e764c2ce7e402d5e8" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;https://golang.org/doc/effective_go.html#concurrency&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b559b40224203447024d2ae45e68a9e1945eed" translate="yes" xml:space="preserve">
          <source>One last example:</source>
          <target state="translated">Un último ejemplo:</target>
        </trans-unit>
        <trans-unit id="1ad534544463088b932bc112e0ba96d50acc9887" translate="yes" xml:space="preserve">
          <source>One lifetime annotation by itself doesn&amp;rsquo;t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. For example, let&amp;rsquo;s say we have a function with the parameter &lt;code&gt;first&lt;/code&gt; that is a reference to an &lt;code&gt;i32&lt;/code&gt; with lifetime &lt;code&gt;'a&lt;/code&gt;. The function also has another parameter named &lt;code&gt;second&lt;/code&gt; that is another reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;. The lifetime annotations indicate that the references &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; must both live as long as that generic lifetime.</source>
          <target state="translated">Una anotaci&amp;oacute;n de por vida por s&amp;iacute; misma no tiene mucho significado, porque las anotaciones est&amp;aacute;n destinadas a decirle a Rust c&amp;oacute;mo se relacionan entre s&amp;iacute; los par&amp;aacute;metros de vida gen&amp;eacute;ricos de m&amp;uacute;ltiples referencias. Por ejemplo, digamos que tenemos una funci&amp;oacute;n con el par&amp;aacute;metro &lt;code&gt;first&lt;/code&gt; que es una referencia a un &lt;code&gt;i32&lt;/code&gt; con un tiempo &lt;code&gt;'a&lt;/code&gt; vida 'a . La funci&amp;oacute;n tambi&amp;eacute;n tiene otro par&amp;aacute;metro llamado &lt;code&gt;second&lt;/code&gt; que es otra referencia a un &lt;code&gt;i32&lt;/code&gt; que tambi&amp;eacute;n tiene el tiempo &lt;code&gt;'a&lt;/code&gt; vida 'a . Las anotaciones de vida &amp;uacute;til indican que las referencias &lt;code&gt;first&lt;/code&gt; y &lt;code&gt;second&lt;/code&gt; deben vivir tanto como esa vida &amp;uacute;til gen&amp;eacute;rica.</target>
        </trans-unit>
        <trans-unit id="eb999aea4a6804c2aba22f0ab64c0d473a5cc357" translate="yes" xml:space="preserve">
          <source>One major tool Rust has for accomplishing message-sending concurrency is the &lt;em&gt;channel&lt;/em&gt;, a programming concept that Rust&amp;rsquo;s standard library provides an implementation of. You can imagine a channel in programming as being like a channel of water, such as a stream or a river. If you put something like a rubber duck or boat into a stream, it will travel downstream to the end of the waterway.</source>
          <target state="translated">Una herramienta importante que tiene Rust para lograr la concurrencia de env&amp;iacute;o de mensajes es el &lt;em&gt;canal&lt;/em&gt; , un concepto de programaci&amp;oacute;n del que la biblioteca est&amp;aacute;ndar de Rust proporciona una implementaci&amp;oacute;n. Puede imaginarse un canal en la programaci&amp;oacute;n como un canal de agua, como un arroyo o un r&amp;iacute;o. Si coloca algo como un pato de goma o un bote en un arroyo, viajar&amp;aacute; r&amp;iacute;o abajo hasta el final del canal.</target>
        </trans-unit>
        <trans-unit id="5a21bfbca68fd0fbb69da3809cb39488fd50f372" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a100de9eac9101d503c874b2c73fc8e99b7771dc" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;struct.file#method.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;struct.file#method.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">Una nota tal vez obvia al usar el modo de adici&amp;oacute;n: aseg&amp;uacute;rese de que todos los datos que pertenecen juntos se escriban en el archivo en una sola operaci&amp;oacute;n. Esto se puede hacer concatenando cadenas antes de pasarlas a &lt;a href=&quot;struct.file#method.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; , o usando un escritor en b&amp;uacute;fer (con un b&amp;uacute;fer de tama&amp;ntilde;o adecuado) y llamando a &lt;a href=&quot;struct.file#method.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; cuando el mensaje est&amp;eacute; completo.</target>
        </trans-unit>
        <trans-unit id="2650888f948816ac8a9838e1462a292b91d57e17" translate="yes" xml:space="preserve">
          <source>One of the keys to &lt;code&gt;collect()&lt;/code&gt;'s power is that many things you might not think of as 'collections' actually are. For example, a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a collection of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. And a collection of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; can be thought of as single &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.</source>
          <target state="translated">Una de las claves para &lt;code&gt;collect()&lt;/code&gt; es que muchas cosas en las que quiz&amp;aacute;s no piense como 'colecciones' en realidad lo son. Por ejemplo, una &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; es una colecci&amp;oacute;n de &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s. Y una colecci&amp;oacute;n de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; se puede considerar como un &amp;uacute;nico &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt; . Consulte los ejemplos siguientes para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c25ed3c3dc3acc46e3e6ecc55a7e68acca10b918" translate="yes" xml:space="preserve">
          <source>One of the uses of a &lt;code&gt;loop&lt;/code&gt; is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want returned after the &lt;code&gt;break&lt;/code&gt; expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here:</source>
          <target state="translated">Uno de los usos de un &lt;code&gt;loop&lt;/code&gt; es reintentar una operaci&amp;oacute;n que sabe que puede fallar, como comprobar si un hilo ha completado su trabajo. Sin embargo, es posible que deba pasar el resultado de esa operaci&amp;oacute;n al resto de su c&amp;oacute;digo. Para hacer esto, puede agregar el valor que desea que se devuelva despu&amp;eacute;s de la expresi&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; que usa para detener el bucle; ese valor se devolver&amp;aacute; fuera del ciclo para que pueda usarlo, como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f31603daf9af84bcc62de6d02f7c02e0a197c236" translate="yes" xml:space="preserve">
          <source>One requirement for &lt;code&gt;match&lt;/code&gt; expressions is that they need to be &lt;em&gt;exhaustive&lt;/em&gt; in the sense that all possibilities for the value in the &lt;code&gt;match&lt;/code&gt; expression must be accounted for. One way to ensure you&amp;rsquo;ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</source>
          <target state="translated">Un requisito para las expresiones de &lt;code&gt;match&lt;/code&gt; es que deben ser &lt;em&gt;exhaustivas&lt;/em&gt; en el sentido de que se deben tener en cuenta todas las posibilidades del valor en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; . Una forma de asegurarse de haber cubierto todas las posibilidades es tener un patr&amp;oacute;n general para el &amp;uacute;ltimo brazo: por ejemplo, un nombre de variable que coincida con cualquier valor nunca puede fallar y, por lo tanto, cubre todos los casos restantes.</target>
        </trans-unit>
        <trans-unit id="2015b7ca5d5d193e7b2cd1b845883b1560077b31" translate="yes" xml:space="preserve">
          <source>One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. For example, we can implement standard library traits like &lt;code&gt;Display&lt;/code&gt; on a custom type like &lt;code&gt;Tweet&lt;/code&gt; as part of our &lt;code&gt;aggregator&lt;/code&gt; crate functionality, because the type &lt;code&gt;Tweet&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate. We can also implement &lt;code&gt;Summary&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in our &lt;code&gt;aggregator&lt;/code&gt; crate, because the trait &lt;code&gt;Summary&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate.</source>
          <target state="translated">Una restricci&amp;oacute;n a tener en cuenta con las implementaciones de rasgos es que podemos implementar un rasgo en un tipo solo si el rasgo o el tipo es local en nuestra caja. Por ejemplo, podemos implementar caracter&amp;iacute;sticas de biblioteca est&amp;aacute;ndar como &lt;code&gt;Display&lt;/code&gt; en un tipo personalizado como &lt;code&gt;Tweet&lt;/code&gt; como parte de nuestra funcionalidad de caja de &lt;code&gt;aggregator&lt;/code&gt; , porque el tipo &lt;code&gt;Tweet&lt;/code&gt; es local para nuestra caja de &lt;code&gt;aggregator&lt;/code&gt; . Tambi&amp;eacute;n podemos implementar &lt;code&gt;Summary&lt;/code&gt; en &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; en nuestra caja de &lt;code&gt;aggregator&lt;/code&gt; , porque el rasgo &lt;code&gt;Summary&lt;/code&gt; es local a nuestra caja de &lt;code&gt;aggregator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca14e0e855a4d320ac718d1dbab1d5658779f12" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">Siempre se debe preferir implementar &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; porque implementar &lt;code&gt;From&lt;/code&gt; proporciona autom&amp;aacute;ticamente una implementaci&amp;oacute;n de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; gracias a la implementaci&amp;oacute;n general en la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="721950a5dec28e319b3fc49a8295aa63db96bacc" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb98649134293913fe4a45ee10ddf0211b082fad" translate="yes" xml:space="preserve">
          <source>One should avoid implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; and implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; instead. Implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9063035453c1b2c42529a52a82eaf086598016e" translate="yes" xml:space="preserve">
          <source>One should only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. Otherwise one should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library. &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; cannot do these type of conversions because of Rust's orphaning rules.</source>
          <target state="translated">Solo se debe implementar &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; si se requiere una conversi&amp;oacute;n a un tipo fuera de la caja actual. De lo contrario, siempre se deber&amp;iacute;a preferir implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; porque implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; proporciona autom&amp;aacute;ticamente una implementaci&amp;oacute;n de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; gracias a la implementaci&amp;oacute;n general en la biblioteca est&amp;aacute;ndar. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; no puede hacer este tipo de conversiones debido a las reglas de hu&amp;eacute;rfano de Rust.</target>
        </trans-unit>
        <trans-unit id="1a1308a26b40990e2a9ab226282be34a9c0f3915" translate="yes" xml:space="preserve">
          <source>One special lifetime we need to discuss is &lt;code&gt;'static&lt;/code&gt;, which means that this reference &lt;em&gt;can&lt;/em&gt; live for the entire duration of the program. All string literals have the &lt;code&gt;'static&lt;/code&gt; lifetime, which we can annotate as follows:</source>
          <target state="translated">Una vida &amp;uacute;til especial que debemos analizar es &lt;code&gt;'static&lt;/code&gt; , lo que significa que esta referencia &lt;em&gt;puede&lt;/em&gt; vivir durante toda la duraci&amp;oacute;n del programa. Todos los literales de cadena tienen la &lt;code&gt;'static&lt;/code&gt; vida &amp;uacute;til est&amp;aacute;tica , que podemos anotar de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="b3c0e81ae8d50e16a5ef5685ec5ba7252876cd13" translate="yes" xml:space="preserve">
          <source>One way to do this would be to parse the guess as an &lt;code&gt;i32&lt;/code&gt; instead of only a &lt;code&gt;u32&lt;/code&gt; to allow potentially negative numbers, and then add a check for the number being in range, like so:</source>
          <target state="translated">Una forma de hacer esto ser&amp;iacute;a analizar la suposici&amp;oacute;n como un &lt;code&gt;i32&lt;/code&gt; en lugar de solo un &lt;code&gt;u32&lt;/code&gt; para permitir n&amp;uacute;meros potencialmente negativos, y luego agregar una verificaci&amp;oacute;n para que el n&amp;uacute;mero est&amp;eacute; dentro del rango, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="040e8b6c5e16e2eb7dbd8ea369897b2ed67939bb" translate="yes" xml:space="preserve">
          <source>One way to fix this is by wrapping &lt;code&gt;ListNode&lt;/code&gt; in a &lt;code&gt;Box&lt;/code&gt;, like so:</source>
          <target state="translated">Una forma de solucionar esto es envolviendo &lt;code&gt;ListNode&lt;/code&gt; en un &lt;code&gt;Box&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7b55ce1dd92a000535e70271090068fe574bb882" translate="yes" xml:space="preserve">
          <source>One way to fix this is to remove the items in negative impls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58c5baae639d4247baa5d3c55a2e51c5fc2fcbf" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;AssertUnwindSafe&lt;/code&gt; is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:</source>
          <target state="translated">Una forma de usar &lt;code&gt;AssertUnwindSafe&lt;/code&gt; es afirmar que todo el cierre en s&amp;iacute; es seguro para desenrollarse, omitiendo todas las comprobaciones para todas las variables:</target>
        </trans-unit>
        <trans-unit id="1d8228fcb1896e7f726b443ff97084ceedc8b0d1" translate="yes" xml:space="preserve">
          <source>One way to work around this is to introduce a phantom type parameter into &lt;code&gt;FooMaker&lt;/code&gt;, like so:</source>
          <target state="translated">Una forma de evitar esto es introducir un par&amp;aacute;metro de tipo fantasma en &lt;code&gt;FooMaker&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="5b0ab36b863c12847512c68879148e05a2480f26" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2a1cfc42a9afc1fe710bb8389ace0259e088eb" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="translated">Solo &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; tiene costos esperados, debido a la naturaleza probabil&amp;iacute;stica del hash. En teor&amp;iacute;a, es posible, aunque muy poco probable, que &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; experimente un peor rendimiento.</target>
        </trans-unit>
        <trans-unit id="c64700ee184977494a32292609d647c2790da91d" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;extern crate&lt;/code&gt; imports at the crate root level are allowed to import macros.</source>
          <target state="translated">Solo las importaciones de &lt;code&gt;extern crate&lt;/code&gt; al nivel de la ra&amp;iacute;z de la caja pueden importar macros.</target>
        </trans-unit>
        <trans-unit id="0f1a591311049947010f4fb443dacb5d1227b8a1" translate="yes" xml:space="preserve">
          <source>Only Inserting a Value If the Key Has No Value</source>
          <target state="translated">Sólo se inserta un valor si la llave no tiene valor</target>
        </trans-unit>
        <trans-unit id="a86a2e98e34b9080a837979f0cd7c8a23bdc05cc" translate="yes" xml:space="preserve">
          <source>Only a higher-ranked bound can be used here as the lifetime of the reference is shorter than a lifetime parameter on the function:</source>
          <target state="translated">Sólo puede utilizarse aquí un límite de mayor rango,ya que la vida útil de la referencia es más corta que un parámetro de vida útil en la función:</target>
        </trans-unit>
        <trans-unit id="154f9dfbda3c7139a94a5be92a5a5842ea10cd7e" translate="yes" xml:space="preserve">
          <source>Only a single explicit lifetime bound is permitted on trait objects. To fix this error, consider removing one of the lifetime bounds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9857467e96b586319b486e37d19a227573b8ef" translate="yes" xml:space="preserve">
          <source>Only considers whole path components to match.</source>
          <target state="translated">Sólo considera que los componentes del camino entero coinciden.</target>
        </trans-unit>
        <trans-unit id="79d045850f7f84e6ac5788c792fcb946090d94ed" translate="yes" xml:space="preserve">
          <source>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</source>
          <target state="translated">Sólo se pueden lanzar enums sin campo a los primitivos numéricos,por lo que este atributo no se aplicará a las estructuras.</target>
        </trans-unit>
        <trans-unit id="848279e3313c44734789a01608c8102412c68498" translate="yes" xml:space="preserve">
          <source>Only foreign functions can use the C-variadic type (&lt;code&gt;...&lt;/code&gt;). In such functions, &lt;code&gt;...&lt;/code&gt; may only occur non-nested. That is, &lt;code&gt;y: &amp;amp;'a ...&lt;/code&gt; is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905a2eaaaa2de81962debc1768f8a3e80eac42bb" translate="yes" xml:space="preserve">
          <source>Only functions and methods can be called using &lt;code&gt;()&lt;/code&gt;. Example:</source>
          <target state="translated">Solo se pueden llamar a funciones y m&amp;eacute;todos usando &lt;code&gt;()&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="75a9ac98deeca6b24da630baa2c701b9504057f7" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. &lt;code&gt;From&lt;/code&gt; cannot do these type of conversions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Implementar &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; solo&lt;/a&gt; si se requiere una conversi&amp;oacute;n a un tipo fuera de la caja actual. &lt;code&gt;From&lt;/code&gt; no puede hacer este tipo de conversiones debido a las reglas de hu&amp;eacute;rfano de Rust. Consulte &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="9b305a83e8f3d0e4a37b5c57b23584e5d9862317" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; when targeting a version prior to Rust 1.41 and converting to a type outside the current crate. &lt;code&gt;From&lt;/code&gt; was not able to do these types of conversions in earlier versions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f9fc3a3cbf2058b25d70080083b8cc212e6656" translate="yes" xml:space="preserve">
          <source>Only one argument can be passed per use. So instead of:</source>
          <target state="translated">Sólo se puede pasar un argumento por cada uso.Así que en lugar de:</target>
        </trans-unit>
        <trans-unit id="457e98acf3983b9b27751cc789092296edcc762f" translate="yes" xml:space="preserve">
          <source>Only one thread will have &lt;code&gt;true&lt;/code&gt; returned from their result, all other threads will have &lt;code&gt;false&lt;/code&gt; returned.</source>
          <target state="translated">Solo un hilo tendr&amp;aacute; como resultado &lt;code&gt;true&lt;/code&gt; devuelto, todos los dem&amp;aacute;s hilos tendr&amp;aacute;n como resultado &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc230d3e221cc5ba4ebb17173e6ee922e206f00e" translate="yes" xml:space="preserve">
          <source>Only paths to traits are allowed as argument inside &lt;code&gt;#[derive]&lt;/code&gt;. You can find more information about the &lt;code&gt;#[derive]&lt;/code&gt; attribute in the &lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3609d3dffa4fe7169c12045193a601a2a125a6f" translate="yes" xml:space="preserve">
          <source>Only primitive types can be cast into each other. Examples:</source>
          <target state="translated">Sólo los tipos primitivos pueden ser arrojados unos a otros.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="ab9f48b23a6a48f0ef7b5f4e6bfbc32e252bb8f0" translate="yes" xml:space="preserve">
          <source>Only published blog posts return content to print, so unapproved posts can&amp;rsquo;t accidentally be published.</source>
          <target state="translated">Solo las publicaciones de blog publicadas devuelven el contenido para imprimir, por lo que las publicaciones no aprobadas no se pueden publicar accidentalmente.</target>
        </trans-unit>
        <trans-unit id="073ebf55d3884fb61165383e76a504c9d12cc4b5" translate="yes" xml:space="preserve">
          <source>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; is not allowed.</source>
          <target state="translated">Solo las estructuras y las enumeraciones pueden implicar Send, Sync y otros rasgos de exclusi&amp;oacute;n voluntaria, y la estructura o enum debe ser local para la caja actual. Por ejemplo, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48b01a920bc2fb585e3535476a3e6dbbaef350e6" translate="yes" xml:space="preserve">
          <source>Only structural-match types (that is, types that derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;) may be used as the types of const generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b0c3f2b71fcd0ea3442b5d718eb8c566a2296f" translate="yes" xml:space="preserve">
          <source>Only the appearance of &lt;em&gt;uncovered&lt;/em&gt; type parameters is restricted. Note that for the purposes of coherence, &lt;a href=&quot;../glossary#fundamental-type-constructors&quot;&gt;fundamental types&lt;/a&gt; are special. The &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered, and &lt;code&gt;Box&amp;lt;LocalType&amp;gt;&lt;/code&gt; is considered local.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a5a90afa5fbb53aff61b9a8c2fc3d66d83b35e" translate="yes" xml:space="preserve">
          <source>Only the last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Solo el &amp;uacute;ltimo campo de &lt;code&gt;Foo&lt;/code&gt; tiene un tipo que involucra a &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa278176dd71a6e098f1078a99115e300d8910ce" translate="yes" xml:space="preserve">
          <source>Only the test with the name &lt;code&gt;one_hundred&lt;/code&gt; ran; the other two tests didn&amp;rsquo;t match that name. The test output lets us know we had more tests than what this command ran by displaying &lt;code&gt;2 filtered out&lt;/code&gt; at the end of the summary line.</source>
          <target state="translated">Solo se ejecut&amp;oacute; la prueba con el nombre &lt;code&gt;one_hundred&lt;/code&gt; ; las otras dos pruebas no coincid&amp;iacute;an con ese nombre. El resultado de la prueba nos permite saber que ten&amp;iacute;amos m&amp;aacute;s pruebas de las que ejecut&amp;oacute; este comando al mostrar &lt;code&gt;2 filtered out&lt;/code&gt; al final de la l&amp;iacute;nea de resumen.</target>
        </trans-unit>
        <trans-unit id="d609ff949d70f19612dfe2483b65eb476e7f69db" translate="yes" xml:space="preserve">
          <source>Only traits defined in the current crate can be implemented for arbitrary types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa9f253f7801e4d949e62ca0dcb20642b072d46" translate="yes" xml:space="preserve">
          <source>Only types implementing &lt;code&gt;std::ops::Deref&lt;/code&gt; can be dereferenced (such as &lt;code&gt;&amp;amp;T&lt;/code&gt;). Example:</source>
          <target state="translated">Solo los tipos que implementan &lt;code&gt;std::ops::Deref&lt;/code&gt; pueden desreferenciarse (como &lt;code&gt;&amp;amp;T&lt;/code&gt; ). Ejemplo:</target>
        </trans-unit>
        <trans-unit id="5b7cee0492b998101b493b89f7410ea880e0f8c8" translate="yes" xml:space="preserve">
          <source>Only use the item in the scope it has been defined:</source>
          <target state="translated">Utilice el artículo sólo en el ámbito que se ha definido:</target>
        </trans-unit>
        <trans-unit id="737047a48ebff11c2ae87259e8e12b5a0ea9f000" translate="yes" xml:space="preserve">
          <source>Opaque type representing the discriminant of an enum.</source>
          <target state="translated">Tipo opaco que representa el discriminante de un enum.</target>
        </trans-unit>
        <trans-unit id="3ba5a04eec7ab34d16390d75e26fc3fe98620cc4" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;Cargo.toml&lt;/em&gt; in your text editor of choice. It should look similar to the code in Listing 1-2.</source>
          <target state="translated">Abra &lt;em&gt;Cargo.toml&lt;/em&gt; en el editor de texto que elija. Deber&amp;iacute;a verse similar al c&amp;oacute;digo del Listado 1-2.</target>
        </trans-unit>
        <trans-unit id="0b3dfe100cddab4329734c9e3ee2eed64968e7db" translate="yes" xml:space="preserve">
          <source>Open Source Developers</source>
          <target state="translated">Desarrolladores de código abierto</target>
        </trans-unit>
        <trans-unit id="9e593a95e08dd5f0164cac54edffcaa5d02e5a5e" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;. If the connection fails, open a TCP connection to &lt;code&gt;127.0.0.1:8081&lt;/code&gt;:</source>
          <target state="translated">Abra una conexi&amp;oacute;n TCP a &lt;code&gt;127.0.0.1:8080&lt;/code&gt; . Si la conexi&amp;oacute;n falla, abra una conexi&amp;oacute;n TCP a &lt;code&gt;127.0.0.1:8081&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36758b7ca5d96a8abc3401009a4668433b033b74" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;:</source>
          <target state="translated">Abra una conexi&amp;oacute;n TCP a &lt;code&gt;127.0.0.1:8080&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e13d18d4e6433983fbb1efa54b9983d326c5ae6" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the &amp;ldquo;Hello, world!&amp;rdquo; project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c15f3ba1726083fcf5e460a4e8e6321cd0586e" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the Hello, world! project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="translated">Abra una terminal e ingrese los siguientes comandos para crear un directorio de &lt;em&gt;proyectos&lt;/em&gt; y un directorio para Hello, world! proyecto dentro del directorio de &lt;em&gt;proyectos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b4eb537f2a91bae055600573be45de77a27b9ed7" translate="yes" xml:space="preserve">
          <source>Open locally installed documentation</source>
          <target state="translated">Abrir la documentación instalada localmente</target>
        </trans-unit>
        <trans-unit id="84587cdad70cebf6217908dcf7d0133574192d78" translate="yes" xml:space="preserve">
          <source>Open your I/O project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file, which should look like this:</source>
          <target state="translated">Abra el archivo &lt;em&gt;src / main.rs de&lt;/em&gt; su proyecto de E / S , que deber&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="aa0399eaec8c7efbd5c34bb50abdda7465b3ccba" translate="yes" xml:space="preserve">
          <source>OpenOptions</source>
          <target state="translated">OpenOptions</target>
        </trans-unit>
        <trans-unit id="8de57f288f4a4084e69c7c4b2aa9da0a06b4257d" translate="yes" xml:space="preserve">
          <source>OpenOptions::access_mode</source>
          <target state="translated">OpenOptions::access_mode</target>
        </trans-unit>
        <trans-unit id="b67e2c499284523d04746aeea5c1bfc24b967904" translate="yes" xml:space="preserve">
          <source>OpenOptions::append</source>
          <target state="translated">OpenOptions::append</target>
        </trans-unit>
        <trans-unit id="32e358709483fecc1c34aed91a515c84a061da75" translate="yes" xml:space="preserve">
          <source>OpenOptions::attributes</source>
          <target state="translated">OpenOptions::attributes</target>
        </trans-unit>
        <trans-unit id="e5c7a13c833ad959de5247957e258cf0746e21f9" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow</source>
          <target state="translated">OpenOptions::borrow</target>
        </trans-unit>
        <trans-unit id="0acab324be26d91ab189d61abdf16dc747c5192c" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow_mut</source>
          <target state="translated">OpenOptions::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ebf38deb5d5125bd571ab2fbede6b16bab299f15" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone</source>
          <target state="translated">OpenOptions::clone</target>
        </trans-unit>
        <trans-unit id="f31d22dcf8f9c141ab8ed3fbc1d9d368635388e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_from</source>
          <target state="translated">OpenOptions::clone_from</target>
        </trans-unit>
        <trans-unit id="b0b15f6e5b6b2ad70a686d3798f9b969c1be6e56" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_into</source>
          <target state="translated">OpenOptions::clone_into</target>
        </trans-unit>
        <trans-unit id="2924b17a8e2b9d34f65d2694a37b0e1b92b85fc1" translate="yes" xml:space="preserve">
          <source>OpenOptions::create</source>
          <target state="translated">OpenOptions::create</target>
        </trans-unit>
        <trans-unit id="518de4d4d480c6aa0ee355b7e8b68e44c261345e" translate="yes" xml:space="preserve">
          <source>OpenOptions::create_new</source>
          <target state="translated">OpenOptions::create_new</target>
        </trans-unit>
        <trans-unit id="5af121b8450a8bfc83582fafa544f257437f0c14" translate="yes" xml:space="preserve">
          <source>OpenOptions::custom_flags</source>
          <target state="translated">OpenOptions::custom_flags</target>
        </trans-unit>
        <trans-unit id="676df7a6e2a4b55c69a37308e4d1e8ab3f83cd3a" translate="yes" xml:space="preserve">
          <source>OpenOptions::fmt</source>
          <target state="translated">OpenOptions::fmt</target>
        </trans-unit>
        <trans-unit id="82f3b255624db61ae979a06d980867d5802d4709" translate="yes" xml:space="preserve">
          <source>OpenOptions::from</source>
          <target state="translated">OpenOptions::from</target>
        </trans-unit>
        <trans-unit id="96ad0ddadc43e2419e6227a5777a55351dd9ac83" translate="yes" xml:space="preserve">
          <source>OpenOptions::into</source>
          <target state="translated">OpenOptions::into</target>
        </trans-unit>
        <trans-unit id="8b77c907fad19cddc5960121fab1fa49b4431f22" translate="yes" xml:space="preserve">
          <source>OpenOptions::mode</source>
          <target state="translated">OpenOptions::mode</target>
        </trans-unit>
        <trans-unit id="1285fb69a9cc28fa9fdf3579b2f9690ab52069d7" translate="yes" xml:space="preserve">
          <source>OpenOptions::new</source>
          <target state="translated">OpenOptions::new</target>
        </trans-unit>
        <trans-unit id="aa320b137860771a593f171b8bca56f205bab7e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::open</source>
          <target state="translated">OpenOptions::open</target>
        </trans-unit>
        <trans-unit id="add50a5d5957c658756ea3d2bf5f0dc20542a4ce" translate="yes" xml:space="preserve">
          <source>OpenOptions::read</source>
          <target state="translated">OpenOptions::read</target>
        </trans-unit>
        <trans-unit id="7e91e59a4c689bbc7efae946cf7ef51cecceeefe" translate="yes" xml:space="preserve">
          <source>OpenOptions::security_qos_flags</source>
          <target state="translated">OpenOptions::security_qos_flags</target>
        </trans-unit>
        <trans-unit id="90b2992d4cec48c28058dee872298370548406ec" translate="yes" xml:space="preserve">
          <source>OpenOptions::share_mode</source>
          <target state="translated">OpenOptions::share_mode</target>
        </trans-unit>
        <trans-unit id="48a692736f06da779873a596d6bb2424b9ad7161" translate="yes" xml:space="preserve">
          <source>OpenOptions::to_owned</source>
          <target state="translated">OpenOptions::to_owned</target>
        </trans-unit>
        <trans-unit id="46e980851a36d656e0daadb411e16ffdbbc2e1eb" translate="yes" xml:space="preserve">
          <source>OpenOptions::truncate</source>
          <target state="translated">OpenOptions::truncate</target>
        </trans-unit>
        <trans-unit id="5f197b60663b22df305247c4bfa1a457e5c0d835" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_from</source>
          <target state="translated">OpenOptions::try_from</target>
        </trans-unit>
        <trans-unit id="747eda4c8e3b44e7c01f7e027a9bd03352e1f790" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_into</source>
          <target state="translated">OpenOptions::try_into</target>
        </trans-unit>
        <trans-unit id="5058de688dcc60c90693a5096962f6405ea1f171" translate="yes" xml:space="preserve">
          <source>OpenOptions::type_id</source>
          <target state="translated">OpenOptions::type_id</target>
        </trans-unit>
        <trans-unit id="19a0518d3e6a36eb2eabd3b78700ce36d617b64d" translate="yes" xml:space="preserve">
          <source>OpenOptions::write</source>
          <target state="translated">OpenOptions::write</target>
        </trans-unit>
        <trans-unit id="6dc0ebb4fa3738b9bc9aac0db1fdc06f34fea9fc" translate="yes" xml:space="preserve">
          <source>OpenOptionsExt</source>
          <target state="translated">OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="45d6a023e7aaf3a8b617725a7efb650cf62cdf6c" translate="yes" xml:space="preserve">
          <source>Opening a file for both reading and writing, as well as creating it if it doesn't exist:</source>
          <target state="translated">Abrir un archivo tanto para leer como para escribir,así como crearlo si no existe:</target>
        </trans-unit>
        <trans-unit id="d0521aae78e8ad155838f7de5e8f14d0ef7781f3" translate="yes" xml:space="preserve">
          <source>Opening a file to read:</source>
          <target state="translated">Abrir un archivo para leer:</target>
        </trans-unit>
        <trans-unit id="d7d34b4c8e94f4c904313459b9fb9b442177d441" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host with a timeout.</source>
          <target state="translated">Abre una conexión TCP a un host remoto con un tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="209d3641e1fce80e2ba36a03cac2a67f569fb4c6" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host.</source>
          <target state="translated">Abre una conexión TCP a un host remoto.</target>
        </trans-unit>
        <trans-unit id="48dea963058d766cb37add48852fe3f445feaf08" translate="yes" xml:space="preserve">
          <source>Opens a file at &lt;code&gt;path&lt;/code&gt; with the options specified by &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Abre un archivo en la &lt;code&gt;path&lt;/code&gt; con las opciones especificadas por &amp;eacute;l &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ebe50b26242826a11bca679d30a026d4444d1a2" translate="yes" xml:space="preserve">
          <source>Opens a file in write-only mode.</source>
          <target state="translated">Abre un archivo en modo de sólo escritura.</target>
        </trans-unit>
        <trans-unit id="127d959111790c197f023d709985c8cb7e583159" translate="yes" xml:space="preserve">
          <source>Operand of the &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; (&lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">Operando del &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;operador de desreferencia&lt;/a&gt; ( &lt;code&gt;*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a2b8c4621b34e3c27498c6c8832719e530f09634" translate="yes" xml:space="preserve">
          <source>Operands</source>
          <target state="translated">Operands</target>
        </trans-unit>
        <trans-unit id="3b28f00441a9534ad36bef8779425496277b4521" translate="yes" xml:space="preserve">
          <source>Operands of &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt;.</source>
          <target state="translated">Operandos de &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="796e9c6aba0ed5f7facb56a161b990345eb7dff2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7809a925050c789646447f7ccccf00c4e8608c" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values is intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="translated">Las operaciones como &lt;code&gt;+&lt;/code&gt; en los valores &lt;code&gt;u32&lt;/code&gt; est&amp;aacute;n destinadas a no desbordarse nunca, y en algunas configuraciones de depuraci&amp;oacute;n se detecta el desbordamiento y genera p&amp;aacute;nico. Si bien la mayor parte de la aritm&amp;eacute;tica entra en esta categor&amp;iacute;a, algunos c&amp;oacute;digos esperan y se basan expl&amp;iacute;citamente en la aritm&amp;eacute;tica modular (por ejemplo, hash).</target>
        </trans-unit>
        <trans-unit id="732a02d050941e6169a56caaf931604a39dfcf26" translate="yes" xml:space="preserve">
          <source>Operations on ASCII strings and characters.</source>
          <target state="translated">Operaciones en cadenas y caracteres ASCII.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e2cce0c9ff63663c1cea812414bb03fc6e974bec" translate="yes" xml:space="preserve">
          <source>Operator Traits</source>
          <target state="translated">Rasgos del operador</target>
        </trans-unit>
        <trans-unit id="9cad0fd3139ef048c0168daf393a34c1807af1a2" translate="yes" xml:space="preserve">
          <source>Operator expressions</source>
          <target state="translated">Expresiones de los operadores</target>
        </trans-unit>
        <trans-unit id="9ae1b0ed74ef02f2a20320b8054a76c10c592467" translate="yes" xml:space="preserve">
          <source>Operator/Expression</source>
          <target state="translated">Operator/Expression</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="a48efc62628a97b690c020f8a1e8f8cb0bb0733d" translate="yes" xml:space="preserve">
          <source>Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in &lt;code&gt;std::ops&lt;/code&gt; or &lt;code&gt;std::cmp&lt;/code&gt;.</source>
          <target state="translated">Los operadores est&amp;aacute;n definidos para tipos integrados por el lenguaje Rust. Muchos de los siguientes operadores tambi&amp;eacute;n se pueden sobrecargar utilizando rasgos en &lt;code&gt;std::ops&lt;/code&gt; o &lt;code&gt;std::cmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b5d154187c93c9da7d2603b606ea0b5d7ebfc3" translate="yes" xml:space="preserve">
          <source>Optimization hints</source>
          <target state="translated">Consejos de optimización</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="9a8587bd4b256cb6bf9e533c046c7ec07658a2a8" translate="yes" xml:space="preserve">
          <source>Option::and</source>
          <target state="translated">Option::and</target>
        </trans-unit>
        <trans-unit id="ad6a1d3208211ea9f4a0bbc163a21ab722dcc207" translate="yes" xml:space="preserve">
          <source>Option::and_then</source>
          <target state="translated">Option::and_then</target>
        </trans-unit>
        <trans-unit id="3f27b9ef99923ea0d93a7d269559394c38b333c3" translate="yes" xml:space="preserve">
          <source>Option::as_mut</source>
          <target state="translated">Option::as_mut</target>
        </trans-unit>
        <trans-unit id="e2458bfdc527d230aa943b40bea1e47ef7c1716a" translate="yes" xml:space="preserve">
          <source>Option::as_pin_mut</source>
          <target state="translated">Option::as_pin_mut</target>
        </trans-unit>
        <trans-unit id="627cd8388f389dc8a414dc64f0bd2aeb93b8bdb8" translate="yes" xml:space="preserve">
          <source>Option::as_pin_ref</source>
          <target state="translated">Option::as_pin_ref</target>
        </trans-unit>
        <trans-unit id="9e1386f584a53f30c4efc9f16fd6a42d3d390020" translate="yes" xml:space="preserve">
          <source>Option::as_ref</source>
          <target state="translated">Option::as_ref</target>
        </trans-unit>
        <trans-unit id="7e71699a5e7a9d061403b6a9d9cd2031f35e7d57" translate="yes" xml:space="preserve">
          <source>Option::borrow</source>
          <target state="translated">Option::borrow</target>
        </trans-unit>
        <trans-unit id="5a2fc76bcd6cc7797b2fc8e79077c3b905ad253b" translate="yes" xml:space="preserve">
          <source>Option::borrow_mut</source>
          <target state="translated">Option::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f8c7733356cc897d454d9d0b3ed5583a86a4fc0c" translate="yes" xml:space="preserve">
          <source>Option::clamp</source>
          <target state="translated">Option::clamp</target>
        </trans-unit>
        <trans-unit id="b2ed5b3da837f6c02fff44b90e9fcf28f2c92857" translate="yes" xml:space="preserve">
          <source>Option::clone</source>
          <target state="translated">Option::clone</target>
        </trans-unit>
        <trans-unit id="41a138cf124c5fbd9ab6a71d2a521b6f7b355bd9" translate="yes" xml:space="preserve">
          <source>Option::clone_from</source>
          <target state="translated">Option::clone_from</target>
        </trans-unit>
        <trans-unit id="428c2ed3ef54229edff7bb1c574b0bfd79b5c01e" translate="yes" xml:space="preserve">
          <source>Option::clone_into</source>
          <target state="translated">Option::clone_into</target>
        </trans-unit>
        <trans-unit id="7cd06b03e80642a3e13258da69f36190c57d76fe" translate="yes" xml:space="preserve">
          <source>Option::cloned</source>
          <target state="translated">Option::cloned</target>
        </trans-unit>
        <trans-unit id="7ea9e4985c5cd3b4ff11c4891148d8ba5e1cf7f3" translate="yes" xml:space="preserve">
          <source>Option::cmp</source>
          <target state="translated">Option::cmp</target>
        </trans-unit>
        <trans-unit id="0498a1a6447eab280dd5d4ffdbbf44f5e3cd0a3e" translate="yes" xml:space="preserve">
          <source>Option::copied</source>
          <target state="translated">Option::copied</target>
        </trans-unit>
        <trans-unit id="cb4ad142555a29053e45e10fc10d79edcbc2a96c" translate="yes" xml:space="preserve">
          <source>Option::default</source>
          <target state="translated">Option::default</target>
        </trans-unit>
        <trans-unit id="ba7eb304c78625b7673ed4fb2b20bafd2105ff7d" translate="yes" xml:space="preserve">
          <source>Option::deref</source>
          <target state="translated">Option::deref</target>
        </trans-unit>
        <trans-unit id="cb4668f98374c478c313d6124b78706cb9deedbc" translate="yes" xml:space="preserve">
          <source>Option::eq</source>
          <target state="translated">Option::eq</target>
        </trans-unit>
        <trans-unit id="76cfff0c978f7770807e24ce63e5dfca252d4367" translate="yes" xml:space="preserve">
          <source>Option::expect</source>
          <target state="translated">Option::expect</target>
        </trans-unit>
        <trans-unit id="6a0b764b6cbe10497b80db91840a28c114598907" translate="yes" xml:space="preserve">
          <source>Option::filter</source>
          <target state="translated">Option::filter</target>
        </trans-unit>
        <trans-unit id="560bd097e6d518e06d94482f4a9697ad398f15d0" translate="yes" xml:space="preserve">
          <source>Option::flatten</source>
          <target state="translated">Option::flatten</target>
        </trans-unit>
        <trans-unit id="d94a2e5f0e616513666e331c6d9144bddb878e9c" translate="yes" xml:space="preserve">
          <source>Option::fmt</source>
          <target state="translated">Option::fmt</target>
        </trans-unit>
        <trans-unit id="cbd7d776e3b699aac19b698f4ca1165601a486cb" translate="yes" xml:space="preserve">
          <source>Option::from</source>
          <target state="translated">Option::from</target>
        </trans-unit>
        <trans-unit id="e4ce8c942f648512db0f55fca12f5af00d0f8696" translate="yes" xml:space="preserve">
          <source>Option::from_error</source>
          <target state="translated">Option::from_error</target>
        </trans-unit>
        <trans-unit id="7e569e7075b5cfd328272103d6b5f8ce7d4d2194" translate="yes" xml:space="preserve">
          <source>Option::from_iter</source>
          <target state="translated">Option::from_iter</target>
        </trans-unit>
        <trans-unit id="a43b3b6ad08c70527052c24fb47f39fcaa4ebb0e" translate="yes" xml:space="preserve">
          <source>Option::from_ok</source>
          <target state="translated">Option::from_ok</target>
        </trans-unit>
        <trans-unit id="39c61b7ca243afc1e123c7964d51460ccf7ce39f" translate="yes" xml:space="preserve">
          <source>Option::ge</source>
          <target state="translated">Option::ge</target>
        </trans-unit>
        <trans-unit id="9b6edfb0a8e4a4f18c5a5177c880df9517534d89" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert</source>
          <target state="translated">Option::get_or_insert</target>
        </trans-unit>
        <trans-unit id="998b5cc317f56f6b2107c170f3756fdcf6a6be39" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert_with</source>
          <target state="translated">Option::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="ff18d337dd9fab1c83bb85ddea3fd7d94d3281c1" translate="yes" xml:space="preserve">
          <source>Option::gt</source>
          <target state="translated">Option::gt</target>
        </trans-unit>
        <trans-unit id="501ecb8b666b964e28da12f4615b48d3b7e450ee" translate="yes" xml:space="preserve">
          <source>Option::hash</source>
          <target state="translated">Option::hash</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
