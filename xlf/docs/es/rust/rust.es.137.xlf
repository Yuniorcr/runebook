<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="6e589b43f3082da98ca0e4f046ea8ace2906bf51" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; ,&lt;/a&gt; que devuelve una &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;from_utf16_lossy&lt;/code&gt; devuelve una &lt;code&gt;String&lt;/code&gt; ya que la conversi&amp;oacute;n de UTF-16 a UTF-8 requiere una asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="1e5e6606c716b7d8ea23880ff26dd47bb4cb772b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt; , esto generalmente significa que los par&amp;aacute;metros de operaci&amp;oacute;n eran v&amp;aacute;lidos, sin embargo, el error fue causado por datos de entrada mal formados.</target>
        </trans-unit>
        <trans-unit id="42150160f2ba583b7d6c6990db7fe7b9390515b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../convert/fn.identity&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fe9eebd36a2bd7140bc3ec3fdc0c32e569dabf" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted allocations between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398c5c34b191e4676dc6961558a4a76db9314267" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted values between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; usa operaciones at&amp;oacute;micas para su recuento de referencias. Esto significa que es seguro para subprocesos. La desventaja es que las operaciones at&amp;oacute;micas son m&amp;aacute;s caras que los accesos a la memoria ordinaria. Si no comparte valores contados por referencia entre subprocesos, considere usar &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; para reducir la sobrecarga. &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; es un valor predeterminado seguro, porque el compilador detectar&amp;aacute; cualquier intento de enviar un &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; entre subprocesos. Sin embargo, una biblioteca puede elegir &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; para brindar a los consumidores de la biblioteca m&amp;aacute;s flexibilidad.</target>
        </trans-unit>
        <trans-unit id="e29ce9f9179b04ed1ae04e60eaff67bddb9bd1a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977087ec8c6cc227ec1b23f036b52a53ba5572b7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;, this method is known to never panic on the result types it is implemented for. Therefore, it can be used instead of &lt;code&gt;unwrap&lt;/code&gt; as a maintainability safeguard that will fail to compile if the error type of the &lt;code&gt;Result&lt;/code&gt; is later changed to an error that can actually occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0ba302caf06a67df91ba9d9ffb499576009fcd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18aaa1337521f474ebf73b2e843073b1e6c1a48" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n generar&amp;aacute; perezosamente el valor a pedido.</target>
        </trans-unit>
        <trans-unit id="f9a90d0a5de7f0a5dcb5f54e9d3e2cfa25b0db2a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; works with unaligned pointers.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;read_unaligned&lt;/code&gt; funciona con punteros no alineados.</target>
        </trans-unit>
        <trans-unit id="45376ed6cd7ba7a1378a0b53a56bfa0037e236a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f193c98cf25a325eda25618a82a356c0b0cf6349" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">A diferencia de la &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; , el puntero puede estar desalineado.</target>
        </trans-unit>
        <trans-unit id="6eb0fda1ae28c8f30f8d9d31bf06172d448763b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d4ccc7c19b4e12670ef1bb1f42a0a03d42f849" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert!&lt;/code&gt; is always type checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c003bf6ddb754586528cac314e476dba52106915" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&amp;iexcl;A diferencia de &lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; Las declaraciones solo est&amp;aacute;n habilitadas en compilaciones no optimizadas de forma predeterminada. &amp;iexcl;Una compilaci&amp;oacute;n optimizada omitir&amp;aacute; todo &lt;code&gt;debug_assert!&lt;/code&gt; declaraciones a menos que se pase &lt;code&gt;-C debug-assertions&lt;/code&gt; al compilador. &amp;iexcl;Esto hace &lt;code&gt;debug_assert!&lt;/code&gt; &amp;uacute;til para comprobaciones que son demasiado caras para estar presentes en una versi&amp;oacute;n de lanzamiento, pero pueden ser &amp;uacute;tiles durante el desarrollo.</target>
        </trans-unit>
        <trans-unit id="c7b2f5bacfdb6fe8fd35fce9254ebaf2411b3683" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_eq!&lt;/code&gt; is always type checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3263afd688aea4401eb3df7127fbabe1b1fe028e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&amp;iexcl;A diferencia de &lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;debug_assert_eq!&lt;/code&gt; Las declaraciones solo est&amp;aacute;n habilitadas en compilaciones no optimizadas de forma predeterminada. &amp;iexcl;Una compilaci&amp;oacute;n optimizada omitir&amp;aacute; todo &lt;code&gt;debug_assert_eq!&lt;/code&gt; declaraciones a menos que se pase &lt;code&gt;-C debug-assertions&lt;/code&gt; al compilador. &amp;iexcl;Esto hace que &lt;code&gt;debug_assert_eq!&lt;/code&gt; &amp;uacute;til para comprobaciones que son demasiado caras para estar presentes en una versi&amp;oacute;n de lanzamiento, pero pueden ser &amp;uacute;tiles durante el desarrollo.</target>
        </trans-unit>
        <trans-unit id="dacd029d3cc2c2a10a75c84ef45c21166b5ba90a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_ne!&lt;/code&gt; is always type checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d1e96304d1bbf7140b253d02ca2ad39e16daa5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&amp;iexcl;A diferencia de &lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;debug_assert_ne!&lt;/code&gt; Las declaraciones solo est&amp;aacute;n habilitadas en compilaciones no optimizadas de forma predeterminada. &amp;iexcl;Una compilaci&amp;oacute;n optimizada omitir&amp;aacute; todo &lt;code&gt;debug_assert_ne!&lt;/code&gt; declaraciones a menos que se pase &lt;code&gt;-C debug-assertions&lt;/code&gt; al compilador. &amp;iexcl;Esto hace que &lt;code&gt;debug_assert_ne!&lt;/code&gt; &amp;uacute;til para comprobaciones que son demasiado caras para estar presentes en una versi&amp;oacute;n de lanzamiento, pero pueden ser &amp;uacute;tiles durante el desarrollo.</target>
        </trans-unit>
        <trans-unit id="6cce36d9c22bd93c2a41b7e0597974f3cee7e7ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9ddf39955f900e36cc1e90f2b549ad7472a5bd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36949a10789f440243db02c27d7a2a4839d4968" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541167404f49247535e6737ca512feb21f2cf377" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac30468509752a4dadb45b544078909afc04dd2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e77b06d8fc7bb242ede2586728e20cd5ec38f2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1cb338dee4d9a50fbbd7a4ca8f1d9671b92ea5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcca6a9c5592b18a67aa751975baab86b8d73470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8564dc4303f86be3afe445dd42ac378dde93ba88" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f28ad76976058589a61b38b753ee6ff0210850" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76887ce7cd48ec3a42bf06e1a6d5d6113a38547a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb26d7e8cfff635de8d1457d1dfb96fc541fdd8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0f6d29be16ce7f6bbb39d8f34d156c5bad7880" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt;, if this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has been poisoned (i.e., a previous call to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; caused a panic), calling &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will no longer be in a poison state and all future calls to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will be no-ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97444204f29f9f8d725d9dd412f9b1cb5f20d4e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once&lt;/code&gt;&lt;/a&gt;, if this &lt;code&gt;Once&lt;/code&gt; has been poisoned (i.e., a previous call to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_once_force&lt;/code&gt; caused a panic), calling &lt;code&gt;call_once_force&lt;/code&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;code&gt;Once&lt;/code&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;code&gt;Once&lt;/code&gt; will no longer be in a poison state and all future calls to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_one_force&lt;/code&gt; will be no-ops.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once&lt;/code&gt; &lt;/a&gt; , si esta &lt;code&gt;Once&lt;/code&gt; ha sido envenenada (es decir, una llamada anterior a &lt;code&gt;call_once&lt;/code&gt; o &lt;code&gt;call_once_force&lt;/code&gt; caus&amp;oacute; p&amp;aacute;nico), llamar a &lt;code&gt;call_once_force&lt;/code&gt; a&amp;uacute;n invocar&amp;aacute; el cierre &lt;code&gt;f&lt;/code&gt; y &lt;em&gt;no&lt;/em&gt; resultar&amp;aacute; en un p&amp;aacute;nico inmediato. Si &lt;code&gt;f&lt;/code&gt; entra en p&amp;aacute;nico, el &lt;code&gt;Once&lt;/code&gt; permanecer&amp;aacute; en estado de veneno. Si &lt;code&gt;f&lt;/code&gt; no &lt;em&gt;no&lt;/em&gt; cunda el p&amp;aacute;nico, la &lt;code&gt;Once&lt;/code&gt; ya no estar&amp;aacute; en un estado de veneno y todas las futuras llamadas a &lt;code&gt;call_once&lt;/code&gt; o &lt;code&gt;call_one_force&lt;/code&gt; habr&amp;aacute;-ops.</target>
        </trans-unit>
        <trans-unit id="69bf1113333b0a6b470f760044140ccfaef050a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9701139045e2ad48d71d09c86c7eff61381e89c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb694c3e76472c257054ea4932b6e425a8976f9f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt;, zero-sized allocations are allowed in &lt;code&gt;AllocRef&lt;/code&gt;. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as &lt;code&gt;libc::malloc&lt;/code&gt;), this must be caught by the implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53e5897fa59de78d867c186db4554c739885b98" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_match&quot;&gt;&lt;code&gt;next_match&lt;/code&gt;&lt;/a&gt; will overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5b411ac352c96a1edc968b7e49d8e28ffb6bde" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt;&lt;code&gt;next_reject&lt;/code&gt;&lt;/a&gt; will overlap. This will return &lt;code&gt;(start_match, end_match)&lt;/code&gt;, where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07cc87b6de700e95562f870286c85dae89d1a54" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;, this takes a &lt;em&gt;mutable&lt;/em&gt; reference to a slice of &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s, not an immutable one. That's because we need to modify the slice to keep track of the bytes already written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee6890d64168a6d63a327f53d097426ab508e0a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; is covariant over &lt;code&gt;T&lt;/code&gt;. If this is incorrect for your use case, you should include some &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt;&lt;code&gt;PhantomData&lt;/code&gt;&lt;/a&gt; in your type to provide invariance, such as &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt;. Usually this won't be necessary; covariance is correct for most safe abstractions, such as &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, and &lt;code&gt;LinkedList&lt;/code&gt;. This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust.</source>
          <target state="translated">A diferencia de &lt;code&gt;*mut T&lt;/code&gt; , &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; es covariante sobre &lt;code&gt;T&lt;/code&gt; . Si esto es incorrecto para su caso de uso, debe incluir algunos&lt;a href=&quot;../marker/struct.phantomdata&quot;&gt; &lt;code&gt;PhantomData&lt;/code&gt; &lt;/a&gt; en su tipo para proporcionar invariancia, como &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt; . Por lo general, esto no ser&amp;aacute; necesario; la covarianza es correcta para la mayor&amp;iacute;a de las abstracciones seguras, como &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; , &lt;code&gt;Arc&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; y &lt;code&gt;LinkedList&lt;/code&gt; . Este es el caso porque proporcionan una API p&amp;uacute;blica que sigue las reglas mutables XOR compartidas normales de Rust.</target>
        </trans-unit>
        <trans-unit id="da5b9cd95305c47f8c2680144fa717b64a77ae08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; has the same size as &lt;code&gt;*mut T&lt;/code&gt;. However the pointer may still dangle if it isn't dereferenced.</source>
          <target state="translated">A diferencia de &lt;code&gt;*mut T&lt;/code&gt; , el puntero siempre debe ser no nulo, incluso si el puntero nunca se desreferencia. Esto es para que las enumeraciones pueden utilizar este valor prohibida, y se discriminante - &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; tiene el mismo tama&amp;ntilde;o que &lt;code&gt;*mut T&lt;/code&gt; . Sin embargo, el puntero todav&amp;iacute;a puede colgar si no est&amp;aacute; desreferenciado.</target>
        </trans-unit>
        <trans-unit id="2af92ae1d7844362d4deb8a5a097d647449edca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;a href=&quot;../borrow/trait.borrow&quot;&gt;&lt;code&gt;Borrow&lt;/code&gt;&lt;/a&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b18281654acc984643104c10e5e6c721877239" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;code&gt;Borrow&lt;/code&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">A diferencia de &lt;code&gt;AsRef&lt;/code&gt; , &lt;code&gt;Borrow&lt;/code&gt; tiene una impl&amp;iacute;cita general para cualquier &lt;code&gt;T&lt;/code&gt; y puede usarse para aceptar una referencia o un valor.</target>
        </trans-unit>
        <trans-unit id="5ceb8d46ab7abd8b54416adda315f1d04158fc52" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized structs are not rounded up to one byte in size.</source>
          <target state="translated">A diferencia de &lt;code&gt;C&lt;/code&gt; , las estructuras de tama&amp;ntilde;o cero no se redondean a un tama&amp;ntilde;o de un byte.</target>
        </trans-unit>
        <trans-unit id="02f8b77aa6c48466699ca8ee968807c87cf6172e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized unions are not rounded up to one byte in size.</source>
          <target state="translated">A diferencia de &lt;code&gt;C&lt;/code&gt; , las uniones de tama&amp;ntilde;o cero no se redondean a un tama&amp;ntilde;o de un byte.</target>
        </trans-unit>
        <trans-unit id="af8a23b1549826352efacb218921580838863fd0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, this method is safe because the pointer &lt;code&gt;P&lt;/code&gt; dereferences to an &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; type, which cancels the pinning guarantees.</source>
          <target state="translated">A diferencia de &lt;code&gt;Pin::new_unchecked&lt;/code&gt; , este m&amp;eacute;todo es seguro porque el puntero &lt;code&gt;P&lt;/code&gt; hace referencia a un tipo &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , que cancela las garant&amp;iacute;as de fijaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f597f0fe6680930140f1186767bedc7add8ce577" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type represents single ownership over the data it holds. So, what makes &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; different from a type like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;? Recall the borrowing rules you learned in Chapter 4:</source>
          <target state="translated">diferente a &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , el tipo &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; representa la propiedad &amp;uacute;nica de los datos que contiene. Entonces, &amp;iquest;qu&amp;eacute; hace a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; diferente de un tipo como &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ? Recuerde las reglas de pr&amp;eacute;stamo que aprendi&amp;oacute; en el Cap&amp;iacute;tulo 4:</target>
        </trans-unit>
        <trans-unit id="926eeb30ef8b029d9a554336169dcbfbccf0209b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell::borrow&lt;/code&gt;, this method is unsafe because it does not return a &lt;code&gt;Ref&lt;/code&gt;, thus leaving the borrow flag untouched. Mutably borrowing the &lt;code&gt;RefCell&lt;/code&gt; while the reference returned by this method is alive is undefined behaviour.</source>
          <target state="translated">A diferencia de &lt;code&gt;RefCell::borrow&lt;/code&gt; , este m&amp;eacute;todo no es seguro porque no devuelve una &lt;code&gt;Ref&lt;/code&gt; , por lo que deja intacta la bandera de pr&amp;eacute;stamo. Tomar prestado de manera mutable &lt;code&gt;RefCell&lt;/code&gt; mientras la referencia devuelta por este m&amp;eacute;todo est&amp;aacute; viva es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="42c8dcf936cacded32e38266231efc7d97352aa2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; only provides shared &lt;code&gt;&amp;amp;T&lt;/code&gt; references to its value. Unlike &lt;code&gt;Cell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; doesn't require copying or replacing the value to access it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c88d683b5f207c6b40e5f43b3334b288246db" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;connect_timeout&lt;/code&gt; takes a single &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; since timeout must be applied to individual addresses.</source>
          <target state="translated">diferente a &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;connect_timeout&lt;/code&gt; toma un &amp;uacute;nico &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; ya que el tiempo de espera se debe aplicar a direcciones individuales.</target>
        </trans-unit>
        <trans-unit id="1ac28d4f87c8eadd078ff1fbd83c69852aa4b470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;fill_buf&lt;/code&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">A diferencia de &lt;code&gt;fill_buf&lt;/code&gt; , esto no intentar&amp;aacute; llenar el b&amp;uacute;fer si est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="c33686d3ffa81ffa69b98b7573a09c025985a84a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">A diferencia de la &lt;code&gt;read&lt;/code&gt; , el puntero puede estar desalineado.</target>
        </trans-unit>
        <trans-unit id="5074eaba30dfa9d17ab40b89f4a8cde3f2ff28d5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;write&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">A diferencia de la &lt;code&gt;write&lt;/code&gt; , el puntero puede estar desalineado.</target>
        </trans-unit>
        <trans-unit id="0869ce408d434adce2ac58f521663bfd0e76626c" translate="yes" xml:space="preserve">
          <source>Unlike an &lt;a href=&quot;../glossary#associated-item&quot;&gt;associated&lt;/a&gt; constant, a &lt;a href=&quot;../glossary#free-item&quot;&gt;free&lt;/a&gt; constant may be unnamed by using an underscore instead of the name. For example:</source>
          <target state="translated">A diferencia de un &lt;a href=&quot;../glossary#associated-item&quot;&gt;&lt;/a&gt; constante asociada , una constante &lt;a href=&quot;../glossary#free-item&quot;&gt;libre&lt;/a&gt; puede no tener nombre usando un gui&amp;oacute;n bajo en lugar del nombre. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c1df7fba2918a10b0657219d3fc33575209df6ce" translate="yes" xml:space="preserve">
          <source>Unlike arithmetic and logical operators, the traits for overloading the operators the traits for these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression context&lt;/a&gt;:</source>
          <target state="translated">A diferencia de los operadores aritm&amp;eacute;ticos y l&amp;oacute;gicos, los rasgos para sobrecargar a los operadores, los rasgos para estos operadores se usan de manera m&amp;aacute;s general para mostrar c&amp;oacute;mo se puede comparar un tipo y probablemente se supondr&amp;aacute; que definen comparaciones reales por funciones que usan estos rasgos como l&amp;iacute;mites. Muchas funciones y macros de la biblioteca est&amp;aacute;ndar pueden utilizar esa suposici&amp;oacute;n (aunque no para garantizar la seguridad). A diferencia de los operadores aritm&amp;eacute;ticos y l&amp;oacute;gicos anteriores, estos operadores toman impl&amp;iacute;citamente pr&amp;eacute;stamos compartidos de sus operandos, evalu&amp;aacute;ndolos en el &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;contexto de expresi&amp;oacute;n de lugar&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="121561ea59642cbf851a475739b422a107512b01" translate="yes" xml:space="preserve">
          <source>Unlike closures, &lt;code&gt;fn&lt;/code&gt; is a type rather than a trait, so we specify &lt;code&gt;fn&lt;/code&gt; as the parameter type directly rather than declaring a generic type parameter with one of the &lt;code&gt;Fn&lt;/code&gt; traits as a trait bound.</source>
          <target state="translated">A diferencia de los cierres, &lt;code&gt;fn&lt;/code&gt; es un tipo en lugar de un rasgo, por lo que especificamos &lt;code&gt;fn&lt;/code&gt; como el tipo de par&amp;aacute;metro directamente en lugar de declarar un par&amp;aacute;metro de tipo gen&amp;eacute;rico con uno de los &lt;code&gt;Fn&lt;/code&gt; rasgos Fn como un l&amp;iacute;mite de rasgo.</target>
        </trans-unit>
        <trans-unit id="ddb54f325fe389efa56003444a2d405f87525e97" translate="yes" xml:space="preserve">
          <source>Unlike for structs, local variables are dropped in reverse order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64287ed646615b0f4f1dbe6a0afd166352be3fa4" translate="yes" xml:space="preserve">
          <source>Unlike generic parameters or &lt;code&gt;impl Trait&lt;/code&gt;, the compiler does not know the concrete type that is being passed. That is, the type has been &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;erased&lt;/a&gt;. As such, a &lt;code&gt;dyn Trait&lt;/code&gt; reference contains &lt;em&gt;two&lt;/em&gt; pointers. One pointer goes to the data (e.g., an instance of a struct). Another pointer goes to a map of method call names to function pointers (known as a virtual method table or vtable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac0121efe5c81f6ee999aad45c525acd80438be" translate="yes" xml:space="preserve">
          <source>Unlike in the TCP case, passing an array of addresses to the &lt;code&gt;connect&lt;/code&gt; function of a UDP socket is not a useful thing to do: The OS will be unable to determine whether something is listening on the remote address without the application sending data.</source>
          <target state="translated">A diferencia del caso de TCP, pasar una matriz de direcciones al &lt;code&gt;connect&lt;/code&gt; funci&amp;oacute;n de conexi&amp;oacute;n de un socket UDP no es algo &amp;uacute;til: el sistema operativo no podr&amp;aacute; determinar si algo est&amp;aacute; escuchando en la direcci&amp;oacute;n remota sin que la aplicaci&amp;oacute;n env&amp;iacute;e datos.</target>
        </trans-unit>
        <trans-unit id="a7c8893077e685528bec1188265b9f18660f72cd" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_match will overlap.</source>
          <target state="translated">Ao contrário de next(),não há garantia de que as gamas devolvidas deste e next_match se sobreponham.</target>
        </trans-unit>
        <trans-unit id="d71db212c677479519bbb6e79cc1b75787a4617d" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_reject will overlap. This will return (start_match, end_match), where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">Ao contrário de next(),não há garantia de que as gamas devolvidas deste e next_reject se sobreponham.Isto irá retornar (start_match,end_match),onde start_match é o índice de onde a partida começa,e end_match é o índice após o fim da partida.</target>
        </trans-unit>
        <trans-unit id="6692903ae621839ab645be72d216172c7413d4a0" translate="yes" xml:space="preserve">
          <source>Unlike normal functions, extern fns have type &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt;. This is the same type as the functions declared in an extern block.</source>
          <target state="translated">A diferencia de las funciones normales, extern fns tiene el tipo &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt; . Este es del mismo tipo que las funciones declaradas en un bloque externo.</target>
        </trans-unit>
        <trans-unit id="36f4ada6278b2f8caced444ea3301e8d71339c65" translate="yes" xml:space="preserve">
          <source>Unlike other methods on &lt;code&gt;TcpStream&lt;/code&gt;, this does not correspond to a single system call. It instead calls &lt;code&gt;connect&lt;/code&gt; in nonblocking mode and then uses an OS-specific mechanism to await the completion of the connection request.</source>
          <target state="translated">A diferencia de otros m&amp;eacute;todos en &lt;code&gt;TcpStream&lt;/code&gt; , esto no corresponde a una sola llamada al sistema. En su lugar, llama a &lt;code&gt;connect&lt;/code&gt; en modo sin bloqueo y luego usa un mecanismo espec&amp;iacute;fico del sistema operativo para esperar la finalizaci&amp;oacute;n de la solicitud de conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d70fcfde3feb0ab38dc2fc9e1a50deff87be8c12" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; free function, this method yields an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to capture any failure to create the thread at the OS level.</source>
          <target state="translated">A diferencia del &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n libre, este m&amp;eacute;todo produce un &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; para capturar cualquier fallo para crear el hilo a nivel de sistema operativo.</target>
        </trans-unit>
        <trans-unit id="f0b436366c65f5f44a2751625381a1b624985a04" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;offset&lt;/code&gt; intrinsic, this intrinsic does not restrict the resulting pointer to point into or one byte past the end of an allocated object, and it wraps with two's complement arithmetic. The resulting value is not necessarily valid to be used to actually access memory.</source>
          <target state="translated">A diferencia de la &lt;code&gt;offset&lt;/code&gt; intr&amp;iacute;nseco de , este intr&amp;iacute;nseco no restringe el puntero resultante para apuntar a un byte m&amp;aacute;s all&amp;aacute; del final de un objeto asignado, y se envuelve con aritm&amp;eacute;tica en complemento a dos. El valor resultante no es necesariamente v&amp;aacute;lido para ser utilizado para acceder realmente a la memoria.</target>
        </trans-unit>
        <trans-unit id="6faf47afea7f3d6a44a9251fcf64aa5fc01a6de0" translate="yes" xml:space="preserve">
          <source>Unlike the other kinds of loops in Rust (&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;while let&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;), loops can be used as expressions that return values via &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">A diferencia de los otros tipos de bucles en Rust ( &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;while let&lt;/code&gt; y &lt;code&gt;for&lt;/code&gt; ), los bucles se pueden usar como expresiones que devuelven valores a trav&amp;eacute;s de &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c816b7f283c34ee4cf6d4ad3a434746ee09b413" translate="yes" xml:space="preserve">
          <source>Unnamed constant</source>
          <target state="translated">Constante sem nome</target>
        </trans-unit>
        <trans-unit id="2eba6a03b89a9ddb19e9cb15699a8737f8bab076" translate="yes" xml:space="preserve">
          <source>Unpin</source>
          <target state="translated">Unpin</target>
        </trans-unit>
        <trans-unit id="5ea7d63651b5ab2fca876bb44555b1ae728096be" translate="yes" xml:space="preserve">
          <source>Unqualified path patterns can refer to:</source>
          <target state="translated">Padrões de caminho não qualificados podem referir-se a:</target>
        </trans-unit>
        <trans-unit id="76194078e8e620ab2e92b2710e1b86b55aa19577" translate="yes" xml:space="preserve">
          <source>Unrecoverable Errors with &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</source>
          <target state="translated">Errores irrecuperables con &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70558ee42c96fb4886d205abf6563d627dc6cb30" translate="yes" xml:space="preserve">
          <source>Unregisters the current allocation error hook, returning it.</source>
          <target state="translated">Desregistra o gancho de erro de atribuição actual,devolvendo-o.</target>
        </trans-unit>
        <trans-unit id="0b233b52323b31980ad438994ac81379bf159f10" translate="yes" xml:space="preserve">
          <source>Unregisters the current panic hook, returning it.</source>
          <target state="translated">Desregistra o actual gancho de pânico,devolvendo-o.</target>
        </trans-unit>
        <trans-unit id="4ad2c25804ae1c9519924b3333558a84852f9759" translate="yes" xml:space="preserve">
          <source>Unsafe Rust</source>
          <target state="translated">Ferrugem Insegura</target>
        </trans-unit>
        <trans-unit id="2bf8239af3f464752ec2490794f409624c78c660" translate="yes" xml:space="preserve">
          <source>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it&amp;rsquo;s better for it to reject some valid programs rather than accept some invalid programs. Although the code might be okay, as far as Rust is able to tell, it&amp;rsquo;s not! In these cases, you can use unsafe code to tell the compiler, &amp;ldquo;Trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</source>
          <target state="translated">Unsafe Rust existe porque, por naturaleza, el an&amp;aacute;lisis est&amp;aacute;tico es conservador. Cuando el compilador intenta determinar si el c&amp;oacute;digo mantiene o no las garant&amp;iacute;as, es mejor que rechace algunos programas v&amp;aacute;lidos en lugar de aceptar algunos programas no v&amp;aacute;lidos. Aunque el c&amp;oacute;digo puede estar bien, por lo que Rust puede decir, &amp;iexcl;no lo es! En estos casos, puede usar c&amp;oacute;digo inseguro para decirle al compilador: &quot;Conf&amp;iacute;a en m&amp;iacute;, s&amp;eacute; lo que estoy haciendo&quot;. La desventaja es que lo usa bajo su propio riesgo: si usa c&amp;oacute;digo inseguro incorrectamente, pueden ocurrir problemas debido a la inseguridad de la memoria, como la eliminaci&amp;oacute;n de referencias de puntero nulo.</target>
        </trans-unit>
        <trans-unit id="b6d976facee53ef7685c3c2e196f51896ea84263" translate="yes" xml:space="preserve">
          <source>Unsafe Rust: how to opt out of some of Rust&amp;rsquo;s guarantees and take responsibility for manually upholding those guarantees</source>
          <target state="translated">Rust inseguro: c&amp;oacute;mo optar por no recibir algunas de las garant&amp;iacute;as de Rust y asumir la responsabilidad de mantener esas garant&amp;iacute;as manualmente</target>
        </trans-unit>
        <trans-unit id="fe954ab5c7d2bf81229af474f3df1f82baf2452e" translate="yes" xml:space="preserve">
          <source>Unsafe Superpowers</source>
          <target state="translated">Superpoderes inseguros</target>
        </trans-unit>
        <trans-unit id="213dd70d91f9e41a9bf1846e9c631a99cd907b6a" translate="yes" xml:space="preserve">
          <source>Unsafe abilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baac6e0b0340f8475119715946cbe8c2961f1b1b" translate="yes" xml:space="preserve">
          <source>Unsafe blocks</source>
          <target state="translated">Blocos inseguros</target>
        </trans-unit>
        <trans-unit id="14b175946b1bbc439b9bcf446b898eb6bb255e29" translate="yes" xml:space="preserve">
          <source>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing is in the standard library.</source>
          <target state="translated">Os blocos inseguros são utilizados para embrulhar bibliotecas estrangeiras,fazer uso directo de hardware ou implementar características não directamente presentes na língua.Por exemplo,o Rust fornece as características linguísticas necessárias para implementar uma simultaneidade segura para a memória na língua,mas a implementação de threads e a passagem de mensagens está na biblioteca padrão.</target>
        </trans-unit>
        <trans-unit id="22664c4ba89e060c3e51b8ae88cd58e9bfacca10" translate="yes" xml:space="preserve">
          <source>Unsafe code may rely on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67e2a049687812f1b206c18f80d4f4b930977c1" translate="yes" xml:space="preserve">
          <source>Unsafe code relies on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">&amp;iexcl;El c&amp;oacute;digo inseguro se basa en &lt;code&gt;assert!&lt;/code&gt; para hacer cumplir invariantes en tiempo de ejecuci&amp;oacute;n que, si se violan, podr&amp;iacute;an provocar inseguridad.</target>
        </trans-unit>
        <trans-unit id="4155a1ec65a094fcbe134a0c2768d51a34c574a8" translate="yes" xml:space="preserve">
          <source>Unsafe code should not rely on the correctness of behavior after overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53274f3a611843db2cae74ec90f381fafeb9213" translate="yes" xml:space="preserve">
          <source>Unsafe code was used outside of an unsafe function or block.</source>
          <target state="translated">O código inseguro foi utilizado fora de uma função ou bloco inseguro.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">Funciones inseguras</target>
        </trans-unit>
        <trans-unit id="10b765166af116817c2643c79030e41920ee70d7" translate="yes" xml:space="preserve">
          <source>Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. Such a function must be prefixed with the keyword &lt;code&gt;unsafe&lt;/code&gt; and can only be called from an &lt;code&gt;unsafe&lt;/code&gt; block or another &lt;code&gt;unsafe&lt;/code&gt; function.</source>
          <target state="translated">Las funciones no seguras son funciones que no son seguras en todos los contextos y / o para todas las entradas posibles. Dicha funci&amp;oacute;n debe ir precedida de la palabra clave &lt;code&gt;unsafe&lt;/code&gt; y solo se puede llamar desde un bloque &lt;code&gt;unsafe&lt;/code&gt; u otra funci&amp;oacute;n &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d33167b0116d560739d43b19ab027e220d852053" translate="yes" xml:space="preserve">
          <source>Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself -- in the snippet above, for example, the &lt;code&gt;unsafe_example&lt;/code&gt; function took a pointer &lt;code&gt;x&lt;/code&gt; as argument, and then (when awaited) dereferenced that pointer. This implies that &lt;code&gt;x&lt;/code&gt; would have to be valid until the future is finished executing, and it is the callers responsibility to ensure that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d7f0c36d2323b4760c5854a9da5e93bff496e9" translate="yes" xml:space="preserve">
          <source>Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics.</source>
          <target state="translated">As operações inseguras são aquelas que podem potencialmente violar as garantias de segurança da memória da semântica estática de Rust.</target>
        </trans-unit>
        <trans-unit id="bf164d180d2c3d60fa72dcb8309415b858fb3ef4" translate="yes" xml:space="preserve">
          <source>Unsafe traits</source>
          <target state="translated">Traços inseguros</target>
        </trans-unit>
        <trans-unit id="3f92b08e3c34ebb357bc1ad626c86bb44dccf639" translate="yes" xml:space="preserve">
          <source>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</source>
          <target state="translated">Los rasgos inseguros deben tener implementaciones inseguras.Este error ocurre cuando una implementación para un rasgo inseguro no está marcada como insegura.Esto puede resolverse marcando la implementación insegura como insegura.</target>
        </trans-unit>
        <trans-unit id="5115d7bdd1417d736db11b27ea37e8ee82718f27" translate="yes" xml:space="preserve">
          <source>UnsafeCell</source>
          <target state="translated">UnsafeCell</target>
        </trans-unit>
        <trans-unit id="2c35a285bb852cf3e62f32e3633426c0ef4631a3" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow</source>
          <target state="translated">UnsafeCell::borrow</target>
        </trans-unit>
        <trans-unit id="75bc0d417d751ed027f53b28049e848ca0749b51" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow_mut</source>
          <target state="translated">UnsafeCell::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a881f13247abe21c6a44c037b8dd96d764dbe3f6" translate="yes" xml:space="preserve">
          <source>UnsafeCell::default</source>
          <target state="translated">UnsafeCell::default</target>
        </trans-unit>
        <trans-unit id="dff2508a0e8759e4bdb101a66e3d4f193575af5f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::fmt</source>
          <target state="translated">UnsafeCell::fmt</target>
        </trans-unit>
        <trans-unit id="fdaf457db9ff90155c2c22c46f8d7d84bbcf495e" translate="yes" xml:space="preserve">
          <source>UnsafeCell::from</source>
          <target state="translated">UnsafeCell::from</target>
        </trans-unit>
        <trans-unit id="3345a29406bcc11d2b5b8b2bbebd7e4e0bd82ec5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::get</source>
          <target state="translated">UnsafeCell::get</target>
        </trans-unit>
        <trans-unit id="c9466ca2fc8e49b6dbd92183423a4c8fa163622c" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into</source>
          <target state="translated">UnsafeCell::into</target>
        </trans-unit>
        <trans-unit id="f93e09df9c8216c70f11ba4964e183b8a07e1fb7" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into_inner</source>
          <target state="translated">UnsafeCell::into_inner</target>
        </trans-unit>
        <trans-unit id="b09cd160b3ecd626dee4e6ef60b717116e682ae5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::new</source>
          <target state="translated">UnsafeCell::new</target>
        </trans-unit>
        <trans-unit id="4a93c833e143a391e62488b530430f04d10a5b76" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_from</source>
          <target state="translated">UnsafeCell::try_from</target>
        </trans-unit>
        <trans-unit id="cde666e236559ffd66009b3fdec4a7ed6f2c1d9f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_into</source>
          <target state="translated">UnsafeCell::try_into</target>
        </trans-unit>
        <trans-unit id="3b8d314be6e0f9f234457b987c6cbb99be6adc66" translate="yes" xml:space="preserve">
          <source>UnsafeCell::type_id</source>
          <target state="translated">UnsafeCell::type_id</target>
        </trans-unit>
        <trans-unit id="e0539de3e0de023b7e2dd1485ffa3c4a0acc8d49" translate="yes" xml:space="preserve">
          <source>Unsafely creates a C string wrapper from a byte slice.</source>
          <target state="translated">Inseguramente crea un envoltorio de cuerda C a partir de un trozo de byte.</target>
        </trans-unit>
        <trans-unit id="80d75cb6c5a344f6eadb72b7d847c31a12dc80ca" translate="yes" xml:space="preserve">
          <source>Unsafety</source>
          <target state="translated">Unsafety</target>
        </trans-unit>
        <trans-unit id="e91344ea16120944c87d0e0635826ca2b1e1956c" translate="yes" xml:space="preserve">
          <source>Unsigned</source>
          <target state="translated">Unsigned</target>
        </trans-unit>
        <trans-unit id="ec69039d9aace16bc0675cab4f4e5d7118fc67b0" translate="yes" xml:space="preserve">
          <source>Unsize</source>
          <target state="translated">Unsize</target>
        </trans-unit>
        <trans-unit id="8702197dc32e4fc5986508c97d9597351056f2bf" translate="yes" xml:space="preserve">
          <source>Unsized Coercions</source>
          <target state="translated">Coacciones sin medida</target>
        </trans-unit>
        <trans-unit id="a090334da83d2c5e2a98abcbd42c6af2bf5571a1" translate="yes" xml:space="preserve">
          <source>Unsized data:</source>
          <target state="translated">Datos sin tamaño:</target>
        </trans-unit>
        <trans-unit id="ea2569aaa33eada2280795d75f286bd6771924fe" translate="yes" xml:space="preserve">
          <source>Unstable Features</source>
          <target state="translated">Características inestables</target>
        </trans-unit>
        <trans-unit id="92ffa7782162b2b301a0b11d2aefb00ca2f2a2f0" translate="yes" xml:space="preserve">
          <source>Until now, all our examples have been matching structs or enums that were one level deep. Matching can work on nested items too!</source>
          <target state="translated">Hasta ahora,todos nuestros ejemplos han coincidido con estructuras o enums de un nivel de profundidad.¡Las coincidencias también pueden funcionar con objetos anidados!</target>
        </trans-unit>
        <trans-unit id="9a0d085fdd50abbdcb3c17611b8692b87c3b02d5" translate="yes" xml:space="preserve">
          <source>Until now, we&amp;rsquo;ve not talked about &lt;em&gt;global variables&lt;/em&gt;, which Rust does support but can be problematic with Rust&amp;rsquo;s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</source>
          <target state="translated">Hasta ahora, no hemos hablado de &lt;em&gt;variables globales&lt;/em&gt; , que Rust s&amp;iacute; admite, pero que pueden ser problem&amp;aacute;ticas con las reglas de propiedad de Rust. Si dos subprocesos acceden a la misma variable global mutable, puede provocar una carrera de datos.</target>
        </trans-unit>
        <trans-unit id="bef75503876861f1652d24e0b101fc042661d7b5" translate="yes" xml:space="preserve">
          <source>Until these issues are resolved, you can use the &lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt;&lt;code&gt;async-trait&lt;/code&gt; crate&lt;/a&gt;, allowing you to use &lt;code&gt;async fn&lt;/code&gt; in traits by desugaring to &quot;boxed futures&quot; (&lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a466dbcb07d272a4827d08399fcc579473f95bac" translate="yes" xml:space="preserve">
          <source>Unused lifetime parameters</source>
          <target state="translated">Parámetros de vida útil no utilizados</target>
        </trans-unit>
        <trans-unit id="67f29d2fd70384a80fd94676bef420c60ec02613" translate="yes" xml:space="preserve">
          <source>Unused type parameters</source>
          <target state="translated">Parámetros de tipo no utilizados</target>
        </trans-unit>
        <trans-unit id="4309bf93c467874d67ac366ea9fc690edd209fc3" translate="yes" xml:space="preserve">
          <source>UnwindSafe</source>
          <target state="translated">UnwindSafe</target>
        </trans-unit>
        <trans-unit id="cbc02d75adc1ffc39fd3a16b3b4074d157341ccf" translate="yes" xml:space="preserve">
          <source>Unwinding the Stack or Aborting in Response to a Panic</source>
          <target state="translated">Desenrollar la pila o abortar en respuesta a un pánico</target>
        </trans-unit>
        <trans-unit id="2789441f00b1b852b1abc369acfc06188469d312" translate="yes" xml:space="preserve">
          <source>Unwraps a result or propagates its error.</source>
          <target state="translated">Desenvuelve un resultado o propaga su error.</target>
        </trans-unit>
        <trans-unit id="bf154983f21c606f5ed175df0a60de13c896591a" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Desenvuelve un resultado, produciendo el contenido de un &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88ae872ed59ebfa48f0864e25ba0455dd8b90e15" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Desenvuelve un resultado, produciendo el contenido de un &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6bb0d8e70fa6dd56dc1322239dbf82a2df0a4ac" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. Else, it returns &lt;code&gt;optb&lt;/code&gt;.</source>
          <target state="translated">Desenvuelve un resultado, produciendo el contenido de un &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; . De lo contrario, devuelve &lt;code&gt;optb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="117016b46649ef00153af6f7350c9138ecc67dda" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. If the value is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; then it calls &lt;code&gt;op&lt;/code&gt; with its value.</source>
          <target state="translated">Desenvuelve un resultado, produciendo el contenido de un &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; . Si el valor es &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; , llama a &lt;code&gt;op&lt;/code&gt; con su valor.</target>
        </trans-unit>
        <trans-unit id="6d656a32648587effa39921eb330f108c0675d59" translate="yes" xml:space="preserve">
          <source>Unwraps an option, yielding the content of a &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Desenvuelve una opci&amp;oacute;n, produciendo el contenido de un &lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44e46942e6b3560b76547c4068197f656ff8557f" translate="yes" xml:space="preserve">
          <source>Unwraps the value.</source>
          <target state="translated">Desenvuelve el valor.</target>
        </trans-unit>
        <trans-unit id="cbbcbd99f909cf5773cc2f8cf87cdd95f999143d" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;, returning the underlying reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c0f60884f81c191ed8a1499ae68b62ce7e7ea6" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">Desenvuelve este &lt;code&gt;BufReader&lt;/code&gt; y devuelve el lector subyacente.</target>
        </trans-unit>
        <trans-unit id="d79f711284b065af6b4e74f8652871df33141f21" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, returning the underlying writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69524452be5afea8f11639be9af1a3cd4b2bfb03" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">Desenvuelve este &lt;code&gt;BufWriter&lt;/code&gt; y devuelve el escritor subyacente.</target>
        </trans-unit>
        <trans-unit id="935d143678423728d032f85b20c66b89ea1e5a53" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;LineWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">Desenvuelve este &lt;code&gt;LineWriter&lt;/code&gt; y devuelve el escritor subyacente.</target>
        </trans-unit>
        <trans-unit id="2e3b12243482f11a01fe101039b067f041f66124" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; returning the underlying pointer.</source>
          <target state="translated">Desenvuelve este &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; devolviendo el puntero subyacente.</target>
        </trans-unit>
        <trans-unit id="9b17789b43e82ba91c88e4d986c1f5d5ba8289b4" translate="yes" xml:space="preserve">
          <source>Update the two instances of duplicated code to call the function instead.</source>
          <target state="translated">Actualiza las dos instancias de código duplicado para llamar a la función en su lugar.</target>
        </trans-unit>
        <trans-unit id="9d8edb0cba2f3c71c929550f878ec6f1ab95a982" translate="yes" xml:space="preserve">
          <source>Update to a newer Rust version</source>
          <target state="translated">Actualización a una nueva versión de Rust</target>
        </trans-unit>
        <trans-unit id="a37ad606755c045819fc66433cff2f591c85b628" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39de9c5b81e5a6bb6d85d389439d91c0bfb9619" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383cb3a84b0a57cded7c0258c7e1a49880c35c95" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">Actualiza &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt; a &lt;code&gt;extension&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c4a6fdd4244e071cb1f5b4ee0c1015487b2074" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">Actualizaciones &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; a &lt;code&gt;file_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="499d5f0f7c8875ae92624d65ec97b14c16b89ea7" translate="yes" xml:space="preserve">
          <source>Updates the contained value using a function and returns the new value.</source>
          <target state="translated">Actualiza el valor contenido usando una función y devuelve el nuevo valor.</target>
        </trans-unit>
        <trans-unit id="54c400ee034681ba4f94547c1f9e6d6c6ae60547" translate="yes" xml:space="preserve">
          <source>Updating a Crate to Get a New Version</source>
          <target state="translated">Actualizar una caja para obtener una nueva versión</target>
        </trans-unit>
        <trans-unit id="230bbf8ccb89f28d643435c51ba717b409f87480" translate="yes" xml:space="preserve">
          <source>Updating a Hash Map</source>
          <target state="translated">Actualizando un mapa Hash</target>
        </trans-unit>
        <trans-unit id="83885ba9f035a9010b4b1ccae0e7e7d6ed9f8e1e" translate="yes" xml:space="preserve">
          <source>Updating a String</source>
          <target state="translated">Actualizar una cuerda</target>
        </trans-unit>
        <trans-unit id="d2ba6d88a1646ea3bcd8516dafee00edcea72844" translate="yes" xml:space="preserve">
          <source>Updating a Value Based on the Old Value</source>
          <target state="translated">Actualizar un valor basado en el valor antiguo</target>
        </trans-unit>
        <trans-unit id="923fa3af760fbaa62e4ad240ccab4df3cf7cd0e1" translate="yes" xml:space="preserve">
          <source>Updating a Vector</source>
          <target state="translated">Actualización de un vector</target>
        </trans-unit>
        <trans-unit id="e383c87cdb72887f6744a78bd78fa459e44a666d" translate="yes" xml:space="preserve">
          <source>Updating and Uninstalling</source>
          <target state="translated">Actualización y desinstalación</target>
        </trans-unit>
        <trans-unit id="874862d7b95e02718d554f979aec41adae9c4cee" translate="yes" xml:space="preserve">
          <source>Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="translated">Al recibir la señal de giro,el procesador puede optimizar su comportamiento,por ejemplo,ahorrando energía o cambiando los hiper-hilos.</target>
        </trans-unit>
        <trans-unit id="a0b0bd731b8e15bb23bd7cc76d2aa724aa6bbacd" translate="yes" xml:space="preserve">
          <source>Upon receiving the spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22415b6a3d0c513d757498ec107592efc88cd6e4" translate="yes" xml:space="preserve">
          <source>UpperExp</source>
          <target state="translated">UpperExp</target>
        </trans-unit>
        <trans-unit id="fcfc7b5ea59d907143490b4156e6805ce49d5515" translate="yes" xml:space="preserve">
          <source>UpperExp::fmt</source>
          <target state="translated">UpperExp::fmt</target>
        </trans-unit>
        <trans-unit id="f690e8510e34f299255dfcc6523578488db8db3e" translate="yes" xml:space="preserve">
          <source>UpperHex</source>
          <target state="translated">UpperHex</target>
        </trans-unit>
        <trans-unit id="2bafd282159acd4fe944a3d1a0e5e2492ec2091e" translate="yes" xml:space="preserve">
          <source>UpperHex::fmt</source>
          <target state="translated">UpperHex::fmt</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="8139f3704cf1ae8bc1b831776ef1b322f4905331" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">Utilice &lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; para este comportamiento.</target>
        </trans-unit>
        <trans-unit id="31c647ca0e64548e5df242f616757ada55c0dfbe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687f0dae29440086643b86ae5972f2641cdbdfdb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;park_timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Utilice &lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;park_timeout&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebca8bdf54e76e24d82dc68f6b0bc04c50c7f47f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e960174a6840a72333f0c4af39164868fd34c4f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;struct.vec#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vec#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in the &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bbc8b66ff470f012eb3c0cc67e657fee2b3c01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Fn&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly and without mutating state (e.g., when calling it concurrently). If you do not need such strict requirements, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as bounds.</source>
          <target state="translated">Utilice &lt;code&gt;Fn&lt;/code&gt; como l&amp;iacute;mite cuando desee aceptar un par&amp;aacute;metro de tipo funci&amp;oacute;n y necesite llamarlo repetidamente y sin estado mutado (por ejemplo, cuando lo llame al mismo tiempo). Si no necesita requisitos tan estrictos, use &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; como l&amp;iacute;mites.</target>
        </trans-unit>
        <trans-unit id="606e32d3718b3ad9261ab53d0c58fffdae2c3eb7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnMut&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly, while allowing it to mutate state. If you don't want the parameter to mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a bound; if you don't need to call it repeatedly, use &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Utilice &lt;code&gt;FnMut&lt;/code&gt; como un l&amp;iacute;mite cuando desee aceptar un par&amp;aacute;metro de tipo funci&amp;oacute;n y necesite llamarlo repetidamente, mientras le permite mutar el estado. Si no desea que el par&amp;aacute;metro cambie de estado, use &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; como l&amp;iacute;mite; si no necesita llamarlo repetidamente, use &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0490417243191fd2b7e8ec23e8ffa3dcdc8fa81b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnOnce&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and only need to call it once. If you need to call the parameter repeatedly, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a bound; if you also need it to not mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Use &lt;code&gt;FnOnce&lt;/code&gt; como un l&amp;iacute;mite cuando desee aceptar un par&amp;aacute;metro de tipo funci&amp;oacute;n y solo necesite llamarlo una vez. Si necesita llamar al par&amp;aacute;metro repetidamente, use &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; como l&amp;iacute;mite; si tambi&amp;eacute;n lo necesita para no mutar el estado, use &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58e9a37a75f6d151dc00d0d282a3a92ae64a1400" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ThreadPool&lt;/code&gt; to perform some task other than serving web requests.</source>
          <target state="translated">Utilice &lt;code&gt;ThreadPool&lt;/code&gt; para realizar alguna tarea adem&amp;aacute;s de atender solicitudes web.</target>
        </trans-unit>
        <trans-unit id="d84e22d164ffb7c941231da29582df4847d529a7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;async&lt;/code&gt; in front of &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;closure&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; to turn the marked code into a &lt;code&gt;Future&lt;/code&gt;. As such the code will not be run immediately, but will only be evaluated when the returned future is &lt;code&gt;.await&lt;/code&gt;ed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14f208baffea7d1c86f95f732b3ef39c695038a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprint!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;print!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">&amp;iexcl;Utilice &lt;code&gt;eprint!&lt;/code&gt; solo para mensajes de error y progreso. &amp;iexcl;Usa la &lt;code&gt;print!&lt;/code&gt; en lugar de la salida principal de su programa.</target>
        </trans-unit>
        <trans-unit id="22665c8a7bbb569c824fae1113f4c37d6c60b38a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprintln!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;println!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">Utilice &lt;code&gt;eprintln!&lt;/code&gt; solo para mensajes de error y progreso. Utilice &lt;code&gt;println!&lt;/code&gt; en lugar de la salida principal de su programa.</target>
        </trans-unit>
        <trans-unit id="c5580c57c536b501604c5a18501909570a4f8755" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mod&lt;/code&gt; to create new &lt;a href=&quot;../reference/items/modules&quot;&gt;modules&lt;/a&gt; to encapsulate code, including other modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ead4795448020930657e9470aadfc30b6e379b7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;print!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">&amp;iexcl;Usa la &lt;code&gt;print!&lt;/code&gt; solo para la salida principal de su programa. &amp;iexcl;Utilice &lt;a href=&quot;macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt;en lugar de imprimir mensajes de error y progreso.</target>
        </trans-unit>
        <trans-unit id="8622f52bbce3eafc5d53c96e1ec31dc91867c0d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;println!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">Utilice &lt;code&gt;println!&lt;/code&gt; solo para la salida principal de su programa. Utilice &lt;a href=&quot;macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt;en lugar de imprimir mensajes de error y progreso.</target>
        </trans-unit>
        <trans-unit id="4a325d56085ed8734f6810e0ff71ad595b95fd50" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BTreeMap&lt;/code&gt; when:</source>
          <target state="translated">Utilice un &lt;code&gt;BTreeMap&lt;/code&gt; cuando:</target>
        </trans-unit>
        <trans-unit id="c5b8b83e450ccf5b057f6e9cdd558c50e56abe87" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BinaryHeap&lt;/code&gt; when:</source>
          <target state="translated">Utilice un &lt;code&gt;BinaryHeap&lt;/code&gt; cuando:</target>
        </trans-unit>
        <trans-unit id="c44210c4cd02de7b469e04353c99013251f0bdb6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;HashMap&lt;/code&gt; when:</source>
          <target state="translated">Utilice un &lt;code&gt;HashMap&lt;/code&gt; cuando:</target>
        </trans-unit>
        <trans-unit id="461b6ce24b45cd8f2525e7819f63e5f3b7e5d4c8" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;LinkedList&lt;/code&gt; when:</source>
          <target state="translated">Utilice una &lt;code&gt;LinkedList&lt;/code&gt; cuando:</target>
        </trans-unit>
        <trans-unit id="f8effe57e9b8b3183f9d4a4c43ec54816a50215a" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:</source>
          <target state="translated">Use un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; como una pila eficiente:</target>
        </trans-unit>
        <trans-unit id="18acad408e22b76af330889473712392d945f0e6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&lt;/code&gt; when:</source>
          <target state="translated">Utilice un &lt;code&gt;Vec&lt;/code&gt; cuando:</target>
        </trans-unit>
        <trans-unit id="610593fe7c0408bbb0f35796499627c6f2245b92" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;VecDeque&lt;/code&gt; when:</source>
          <target state="translated">Utilice un &lt;code&gt;VecDeque&lt;/code&gt; cuando:</target>
        </trans-unit>
        <trans-unit id="928e71deb9616cde37637c874eca1ef7178b77b4" translate="yes" xml:space="preserve">
          <source>Use a slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c1eb662164587065262615f820c57ffe90b9ef" translate="yes" xml:space="preserve">
          <source>Use an array with a fixed length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa019f3006a2c79cffd1cb8f757987c40c32ebd5" translate="yes" xml:space="preserve">
          <source>Use declarations</source>
          <target state="translated">Usar las declaraciones</target>
        </trans-unit>
        <trans-unit id="4285ed0690ab255637e0ac148f5c792cd6b8149b" translate="yes" xml:space="preserve">
          <source>Use declarations support a number of convenient shortcuts:</source>
          <target state="translated">Las declaraciones de uso respaldan una serie de atajos convenientes:</target>
        </trans-unit>
        <trans-unit id="1d940a95921bf352b68ae08ab069e2750541ca02" translate="yes" xml:space="preserve">
          <source>Use of a &lt;code&gt;str&lt;/code&gt; whose contents are not valid UTF-8 is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d154502a3f5f6795f896efa6e13908d9370d8f9a" translate="yes" xml:space="preserve">
          <source>Use of generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5acc62e88ff47e84c111044c30c66db333ca88" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax to write data to the standard output. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&amp;iexcl;Usa el &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;sintaxis para escribir datos en la salida est&amp;aacute;ndar. Consulte &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2fbe9e80ba417914254163793e464ee62322f093" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ptr/fn.null_mut&quot;&gt;&lt;code&gt;null_mut&lt;/code&gt;&lt;/a&gt; functions to create null pointers, and the &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt;&lt;code&gt;is_null&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types to check for null. The &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types also define the &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; method, for pointer math.</source>
          <target state="translated">Utilice las funciones &lt;a href=&quot;ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;ptr/fn.null_mut&quot;&gt; &lt;code&gt;null_mut&lt;/code&gt; &lt;/a&gt; para crear punteros nulos, y el m&amp;eacute;todo &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt; &lt;code&gt;is_null&lt;/code&gt; &lt;/a&gt; de los tipos &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; para comprobar si hay nulos. Los tipos &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; tambi&amp;eacute;n definen el m&amp;eacute;todo de &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; , para puntero matem&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="2e570be59fc7fd5ff7530405783a29f5828f0fe8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:</source>
          <target state="translated">Utilice la variante de &lt;code&gt;Set&lt;/code&gt; de cualquiera de estos &lt;code&gt;Map&lt;/code&gt; cuando:</target>
        </trans-unit>
        <trans-unit id="e80c04da83a86a4ecbf94ec7503d652753e12266" translate="yes" xml:space="preserve">
          <source>Use the code in Listing 12-1 to allow your &lt;code&gt;minigrep&lt;/code&gt; program to read any command line arguments passed to it and then collect the values into a vector.</source>
          <target state="translated">Utilice el c&amp;oacute;digo del Listado 12-1 para permitir que su programa &lt;code&gt;minigrep&lt;/code&gt; lea cualquier argumento de l&amp;iacute;nea de comando que se le pase y luego recopile los valores en un vector.</target>
        </trans-unit>
        <trans-unit id="b7e242e19e576b066c1fbe08cfb0b75455ae8cac" translate="yes" xml:space="preserve">
          <source>Use the same lifetime requirement for both input and output values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a96fe96ad1c2ec9146b51dd14fea6aa97e8389" translate="yes" xml:space="preserve">
          <source>Use this function only when you can prove that the code will never call it. Otherwise, consider using the &lt;a href=&quot;../macro.unreachable&quot;&gt;&lt;code&gt;unreachable!&lt;/code&gt;&lt;/a&gt; macro, which does not allow optimizations but will panic when executed.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n solo cuando pueda demostrar que el c&amp;oacute;digo nunca la llamar&amp;aacute;. De lo contrario, &amp;iexcl;considere usar el &lt;a href=&quot;../macro.unreachable&quot;&gt; &lt;code&gt;unreachable!&lt;/code&gt; &lt;/a&gt;macro, que no permite optimizaciones pero entrar&amp;aacute; en p&amp;aacute;nico cuando se ejecute.</target>
        </trans-unit>
        <trans-unit id="d6a3c9f03120ec47a98d4a452b1e2127aae8581a" translate="yes" xml:space="preserve">
          <source>Used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeFull&lt;/code&gt; produces the full array as a slice.</source>
          <target state="translated">Utilizado como &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;&amp;iacute;ndice de corte&lt;/a&gt; , &lt;code&gt;RangeFull&lt;/code&gt; produce la matriz completa como un corte.</target>
        </trans-unit>
        <trans-unit id="0ee0968c281548e8c4956da0bb80d17ce6a46d94" translate="yes" xml:space="preserve">
          <source>Used for immutable dereferencing operations, like &lt;code&gt;*v&lt;/code&gt;.</source>
          <target state="translated">Se utiliza para operaciones de eliminaci&amp;oacute;n de referencias inmutables, como &lt;code&gt;*v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4b9aeea072b24e3f199cbe699727a85aca473bd" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in immutable contexts.</source>
          <target state="translated">Se utiliza para operaciones de indexaci&amp;oacute;n ( &lt;code&gt;container[index]&lt;/code&gt; ) en contextos inmutables.</target>
        </trans-unit>
        <trans-unit id="6a6db850fe7a0893deca48224e890877525cf009" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in mutable contexts.</source>
          <target state="translated">Se utiliza para operaciones de indexaci&amp;oacute;n ( &lt;code&gt;container[index]&lt;/code&gt; ) en contextos mutables.</target>
        </trans-unit>
        <trans-unit id="b8ea53757bb98a6b5189506b4ea7e3a3e9a3ec16" translate="yes" xml:space="preserve">
          <source>Used for mutable dereferencing operations, like in &lt;code&gt;*v = 1;&lt;/code&gt;.</source>
          <target state="translated">Se utiliza para operaciones de eliminaci&amp;oacute;n de referencias mutables, como en &lt;code&gt;*v = 1;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fe043543944b7d7b206d45160cd5299a8af93e5" translate="yes" xml:space="preserve">
          <source>Used to create a default &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; instance for types that implement &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se utiliza para crear una instancia de &lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt; predeterminada para los tipos que implementan &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e28b1efed767d7b3e60d0a7700706d6642dda67" translate="yes" xml:space="preserve">
          <source>Used to do a cheap mutable-to-mutable reference conversion.</source>
          <target state="translated">Se utiliza para hacer una conversión de referencia mutable a mutable barata.</target>
        </trans-unit>
        <trans-unit id="f1b7626a3b6465a294975154f6e043096ec5995f" translate="yes" xml:space="preserve">
          <source>Used to do a cheap reference-to-reference conversion.</source>
          <target state="translated">Se utiliza para hacer una conversión barata de referencia a referencia.</target>
        </trans-unit>
        <trans-unit id="14c0b7ffa101db42d6f394a0ed0a2a772e18316c" translate="yes" xml:space="preserve">
          <source>Used to do value-to-value conversions while consuming the input value. It is the reciprocal of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se utiliza para realizar conversiones de valor a valor mientras se consume el valor de entrada. Es el rec&amp;iacute;proco de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87832790df189d88ca8070bb6de895ef1d392b7c" translate="yes" xml:space="preserve">
          <source>Used to make try_fold closures more like normal loops</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e26b00e1661d4c5dea648883f63653b80651f39" translate="yes" xml:space="preserve">
          <source>Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.</source>
          <target state="translated">Se usa para ejecutar algún código cuando un valor se sale del alcance.A veces se le llama &quot;destructor&quot;.</target>
        </trans-unit>
        <trans-unit id="5dc9662fcc8a7efba76268741a2aa91414af229f" translate="yes" xml:space="preserve">
          <source>Useful synchronization primitives.</source>
          <target state="translated">Primitivas de sincronización útiles.</target>
        </trans-unit>
        <trans-unit id="b05cb9060bef7e9cf540890d5647fd3ffbac6f9d" translate="yes" xml:space="preserve">
          <source>User lacks permissions to create directory at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">El usuario carece de permisos para crear un directorio en la &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01ed5872aedec24d23d900d1581e6ff53ed21665" translate="yes" xml:space="preserve">
          <source>User-defined types:</source>
          <target state="translated">Tipos definidos por el usuario:</target>
        </trans-unit>
        <trans-unit id="62be4731dedfbbc70aa7fa30d6649d816af8ca4b" translate="yes" xml:space="preserve">
          <source>Uses</source>
          <target state="translated">Uses</target>
        </trans-unit>
        <trans-unit id="55cf66299b4b2f9f7eb9ea6abdf809a42de50634" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning.</source>
          <target state="translated">Utiliza datos prestados para reemplazar los datos propios,generalmente por clonación.</target>
        </trans-unit>
        <trans-unit id="01c085ac9a4eda7ad0e1fc8b863d1b23ac3713d3" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Utiliza datos prestados para reemplazar los datos propios, generalmente mediante la clonaci&amp;oacute;n. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1a7e308c9ce8c72dc79594fe592d8ac0e474a60" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Utiliza datos prestados para reemplazar los datos propios, generalmente mediante la clonaci&amp;oacute;n. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41f5a93c96209d01bd88a54a350a97a8859d2caf" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Utiliza datos prestados para reemplazar los datos propios, generalmente mediante la clonaci&amp;oacute;n. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="527bd4367972a752863741d60fd99d8435d00fca" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Utiliza datos prestados para reemplazar los datos propios, generalmente mediante la clonaci&amp;oacute;n. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb87bc230d96c818f8f39be65a97f0f0c56ca879" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Utiliza datos prestados para reemplazar los datos propios, generalmente mediante la clonaci&amp;oacute;n. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e92ce0c09d5d2c377945a784545c389cc7e9354" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt;&lt;/a&gt;, a.k.a. the &lt;code&gt;memcpy32&lt;/code&gt;and &lt;code&gt;memcpy64&lt;/code&gt; intrinsics, on overlapping buffers.</source>
          <target state="translated">Usando &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt; &lt;/a&gt; , tambi&amp;eacute;n conocido como los intr&amp;iacute;nsecos &lt;code&gt;memcpy32&lt;/code&gt; y &lt;code&gt;memcpy64&lt;/code&gt; , en b&amp;uacute;feres superpuestos.</target>
        </trans-unit>
        <trans-unit id="6e1dcc3d8137ddd7e3681f9bc104f285826b7f48" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; as success ordering makes the store part of this operation &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;, and using &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; makes the final successful load &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;. The (failed) load ordering can only be &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; and must be equivalent to or weaker than the success ordering.</source>
          <target state="translated">El uso de &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; como pedido exitoso hace que la tienda sea parte de esta operaci&amp;oacute;n &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; , y el uso de &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; hace que la carga final exitosa sea &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; . El pedido de carga (fallido) solo puede ser &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; y debe ser equivalente o m&amp;aacute;s d&amp;eacute;bil que el pedido exitoso.</target>
        </trans-unit>
        <trans-unit id="7a6e8bfcb648c037a665b572caa617368582e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;Iterator::collect()&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6057ce3700db1903febbd4571a9030f98dccb52" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">Usando &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; para usar impl&amp;iacute;citamente &lt;code&gt;FromIterator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8581b668b89dc42d1d55734cab92752391e678b" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; Like a Reference</source>
          <target state="translated">Uso de &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; como referencia</target>
        </trans-unit>
        <trans-unit id="2786f97dc365e66bda997868734cec33ef9fcf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Get a Recursive Type with a Known Size</source>
          <target state="translated">Uso de &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; para obtener un tipo recursivo con un tama&amp;ntilde;o conocido</target>
        </trans-unit>
        <trans-unit id="8300c99c1ff66e26c9f9b017e5522a93d571ce81" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Point to Data on the Heap</source>
          <target state="translated">Uso de &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; para apuntar a datos en el mont&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="c4104bedba70839a84674c526e20638655c760d0" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; Functions to Call External Code</source>
          <target state="translated">Uso de funciones &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; as para llamar a c&amp;oacute;digo externo</target>
        </trans-unit>
        <trans-unit id="39a61fb39b0b2c2b47e27003fb9ca80ee4d7ca24" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; in a &lt;code&gt;let&lt;/code&gt; Statement</source>
          <target state="translated">Usar &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; en una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17f21cd4682f3498e05d46c9ba5f0db1ecf73ca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; Trait Methods Instead of Indexing</source>
          <target state="translated">Usar m&amp;eacute;todos de rasgos de &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; lugar de indexar</target>
        </trans-unit>
        <trans-unit id="cd4dbe3102cc8a86458c21a6edcf0745a3880b2c" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; Closures with Threads</source>
          <target state="translated">Uso de cierres de &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; con subprocesos</target>
        </trans-unit>
        <trans-unit id="bcb24e74610f11ffcd8b36fc02251143626de877" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to Share Data</source>
          <target state="translated">Uso de &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; para compartir datos</target>
        </trans-unit>
        <trans-unit id="4bedcde0cd8963bedfb716621a284a40e61ba006" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in Tests</source>
          <target state="translated">Uso de &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; en pruebas</target>
        </trans-unit>
        <trans-unit id="5d4e8a0abd2628d1463a51e66037adf55b78b3eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;#[repr(C)]&lt;/code&gt;.</source>
          <target state="translated">Usando &lt;code&gt;#[repr(C)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfc71d2f097570894eba309d1d3e23fc1440f195" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</source>
          <target state="translated">Usando &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; o &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; donde el argumento de la derecha es mayor o igual que el n&amp;uacute;mero de bits en el tipo de argumento de la izquierda, o es negativo.</target>
        </trans-unit>
        <trans-unit id="b645209e67cee4f9f92c20f0e033dab698fba2f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">Usando &lt;code&gt;/&lt;/code&gt; o &lt;code&gt;%&lt;/code&gt; , donde el argumento de la izquierda es el n&amp;uacute;mero entero m&amp;aacute;s peque&amp;ntilde;o de un tipo entero con signo y el argumento de la derecha es &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d0998ec9f168a2eeef48fd713f566a42f1d1993" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@&lt;/code&gt; lets us test a value and save it in a variable within one pattern.</source>
          <target state="translated">El uso de &lt;code&gt;@&lt;/code&gt; nos permite probar un valor y guardarlo en una variable dentro de un patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1ae9824a370d1fed45ea9444f749e0c2d3a71823" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;AsMut&lt;/code&gt; as trait bound for a generic function we can accept all mutable references that can be converted to type &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; we can write a function &lt;code&gt;add_one&lt;/code&gt; that takes all arguments that can be converted to &lt;code&gt;&amp;amp;mut u64&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;add_one&lt;/code&gt; accepts arguments of type &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; as well:</source>
          <target state="translated">Usando &lt;code&gt;AsMut&lt;/code&gt; como rasgo con destino a una funci&amp;oacute;n gen&amp;eacute;rica podemos aceptar todas las referencias mutables que se pueden convertir a escribir &lt;code&gt;&amp;amp;mut T&lt;/code&gt; . Debido a que &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; implementa &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; , podemos escribir una funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; que toma todos los argumentos que se pueden convertir a &lt;code&gt;&amp;amp;mut u64&lt;/code&gt; . Debido a que &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; implementa &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;add_one&lt;/code&gt; acepta argumentos de tipo &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; tambi&amp;eacute;n:</target>
        </trans-unit>
        <trans-unit id="e5f61609aec29d1aa58bf125645b7b8bf1c8648b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BuildHasherDefault&lt;/code&gt; to specify a custom &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Usando &lt;code&gt;BuildHasherDefault&lt;/code&gt; para especificar un &lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt; personalizado para &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="741ce1478263e946f77de5614872f7257f7d9bd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;TcpListener&lt;/code&gt;, we can listen for TCP connections at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt;. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn&amp;rsquo;t represent the authors&amp;rsquo; computer specifically), and &lt;code&gt;7878&lt;/code&gt; is the port. We&amp;rsquo;ve chosen this port for two reasons: HTTP is normally accepted on this port, and 7878 is &lt;em&gt;rust&lt;/em&gt; typed on a telephone.</source>
          <target state="translated">Usando &lt;code&gt;TcpListener&lt;/code&gt; , podemos escuchar conexiones TCP en la direcci&amp;oacute;n &lt;code&gt;127.0.0.1:7878&lt;/code&gt; . En la direcci&amp;oacute;n, la secci&amp;oacute;n antes de los dos puntos es una direcci&amp;oacute;n IP que representa su computadora (es la misma en todas las computadoras y no representa la computadora de los autores espec&amp;iacute;ficamente), y &lt;code&gt;7878&lt;/code&gt; es el puerto. Hemos elegido este puerto por dos razones: HTTP es normalmente aceptados en este puerto, y 7878 es &lt;em&gt;el &amp;oacute;xido&lt;/em&gt; escrito en un tel&amp;eacute;fono.</target>
        </trans-unit>
        <trans-unit id="9d282af0a0db5a0f3935d90926c6551a24490d56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cargo&lt;/code&gt;, Rust&amp;rsquo;s package manager and build system</source>
          <target state="translated">Uso de &lt;code&gt;cargo&lt;/code&gt; , administrador de paquetes y sistema de construcci&amp;oacute;n de Rust</target>
        </trans-unit>
        <trans-unit id="063f2ebb8c76224924321e7e9857525474aed57a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Usando &lt;code&gt;collect()&lt;/code&gt; para hacer una &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="781d7dd79f196f5deffe456d6e4de88c8628e79c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths()&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb72794ee8412b2ec8c4ed130b77aa3fe94a4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">Usando &lt;code&gt;env::join_paths&lt;/code&gt; con &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths&lt;/code&gt; &lt;/a&gt; para agregar un elemento a la &lt;code&gt;PATH&lt;/code&gt; entorno PATH :</target>
        </trans-unit>
        <trans-unit id="883e296f0933a9796d7609478617eb9fc57e41d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; as a &quot;do nothing&quot; base case in a conditional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145643f8069cc90bb1d66393cde6c665263c5694" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing among other interesting functions:</source>
          <target state="translated">Usar la &lt;code&gt;identity&lt;/code&gt; para no hacer nada entre otras funciones interesantes:</target>
        </trans-unit>
        <trans-unit id="f1235a5ac3f06cf39c5a154506b55894e72fe10a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing in a sequence of other, interesting, functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c92b7b9d3a5d2fd97452ae43966326ca17955c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to get a function that changes nothing in a conditional:</source>
          <target state="translated">Usando la &lt;code&gt;identity&lt;/code&gt; para obtener una funci&amp;oacute;n que no cambia nada en un condicional:</target>
        </trans-unit>
        <trans-unit id="8a03c63b02cfcec88b468a3f0a4f356859de8742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to keep the &lt;code&gt;Some&lt;/code&gt; variants of an iterator of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Usando la &lt;code&gt;identity&lt;/code&gt; para mantener &lt;code&gt;Some&lt;/code&gt; variantes de un iterador de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b86b145b4aec4479f3e7888989e9c6f53ce3db7d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;if let&lt;/code&gt; means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that &lt;code&gt;match&lt;/code&gt; enforces. Choosing between &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt; depends on what you&amp;rsquo;re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</source>
          <target state="translated">Usar &lt;code&gt;if let&lt;/code&gt; significa menos escritura, menos sangr&amp;iacute;a y menos c&amp;oacute;digo repetitivo. Sin embargo, pierde la comprobaci&amp;oacute;n exhaustiva que impone la &lt;code&gt;match&lt;/code&gt; . La elecci&amp;oacute;n entre &lt;code&gt;match&lt;/code&gt; y &lt;code&gt;if let&lt;/code&gt; depende de lo que est&amp;eacute; haciendo en su situaci&amp;oacute;n particular y de si ganar concisi&amp;oacute;n es una compensaci&amp;oacute;n adecuada por perder un control exhaustivo.</target>
        </trans-unit>
        <trans-unit id="7b98e766b3b912d79bb4b0c519c379c12d658619" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;match&lt;/code&gt; works well enough, but it can be a bit verbose and doesn&amp;rsquo;t always communicate intent well. The &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many helper methods defined on it to do various tasks. One of those methods, called &lt;code&gt;unwrap&lt;/code&gt;, is a shortcut method that is implemented just like the &lt;code&gt;match&lt;/code&gt; expression we wrote in Listing 9-4. If the &lt;code&gt;Result&lt;/code&gt; value is the &lt;code&gt;Ok&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will return the value inside the &lt;code&gt;Ok&lt;/code&gt;. If the &lt;code&gt;Result&lt;/code&gt; is the &lt;code&gt;Err&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will call the &lt;code&gt;panic!&lt;/code&gt; macro for us. Here is an example of &lt;code&gt;unwrap&lt;/code&gt; in action:</source>
          <target state="translated">El uso de &lt;code&gt;match&lt;/code&gt; funciona bastante bien, pero puede ser un poco detallado y no siempre comunica bien la intenci&amp;oacute;n. El tipo &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; tiene muchos m&amp;eacute;todos auxiliares definidos para realizar varias tareas. Uno de esos m&amp;eacute;todos, llamado &lt;code&gt;unwrap&lt;/code&gt; , es un m&amp;eacute;todo abreviado que se implementa como la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; que escribimos en el Listado 9-4. Si el valor de &lt;code&gt;Result&lt;/code&gt; ado es la variante &lt;code&gt;Ok&lt;/code&gt; , &lt;code&gt;unwrap&lt;/code&gt; devolver&amp;aacute; el valor dentro de &lt;code&gt;Ok&lt;/code&gt; . Si el &lt;code&gt;Result&lt;/code&gt; es la variante &lt;code&gt;Err&lt;/code&gt; , &amp;iexcl; &lt;code&gt;unwrap&lt;/code&gt; llamar&amp;aacute; al &lt;code&gt;panic!&lt;/code&gt; macro para nosotros. Aqu&amp;iacute; hay un ejemplo de &lt;code&gt;unwrap&lt;/code&gt; en acci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="716d3b2c36a0e8f26b1196bb5c8509c4d656cdaa" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt; can be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction.</source>
          <target state="translated">El uso de &lt;code&gt;mul_add&lt;/code&gt; puede ser m&amp;aacute;s eficaz que un multiply-add no fusionado si la arquitectura de destino tiene una instrucci&amp;oacute;n de CPU &lt;code&gt;fma&lt;/code&gt; dedicada .</target>
        </trans-unit>
        <trans-unit id="b8c91e11b4f888f4c592a35e44ac17004a0fb755" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;println!&lt;/code&gt; directly:</source>
          <target state="translated">Usando &lt;code&gt;println!&lt;/code&gt; directamente:</target>
        </trans-unit>
        <trans-unit id="4e19595061858aceb197932ab33548b4e2d9024e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;to_string&lt;/code&gt;:</source>
          <target state="translated">Usando &lt;code&gt;to_string&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9355d5eaee5786ccc5834b09b61c0a558e231c8f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe {}&lt;/code&gt; blocks and &lt;code&gt;impl&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd1e2fb0a495ca1deedb73f663b2b41b48287c3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the five actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems when they occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e77887900c6717f9133b9abc150eed86948327" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the four actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems if they occur.</source>
          <target state="translated">Usar &lt;code&gt;unsafe&lt;/code&gt; para realizar una de las cuatro acciones (superpoderes) que acabamos de comentar no est&amp;aacute; mal ni est&amp;aacute; mal visto. Pero es m&amp;aacute;s complicado corregir el c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; porque el compilador no puede ayudar a mantener la seguridad de la memoria. Cuando tiene una raz&amp;oacute;n para usar c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; , puede hacerlo, y tener la anotaci&amp;oacute;n expl&amp;iacute;cita de &lt;code&gt;unsafe&lt;/code&gt; facilita la localizaci&amp;oacute;n del origen de los problemas si ocurren.</target>
        </trans-unit>
        <trans-unit id="079ef6902b572fab1f5b45933254dfd23aa7b9b5" translate="yes" xml:space="preserve">
          <source>Using Closures that Capture Their Environment</source>
          <target state="translated">Usando cierres que capturan su entorno</target>
        </trans-unit>
        <trans-unit id="356483451b80563e823eec07c158f3c0e2a19756" translate="yes" xml:space="preserve">
          <source>Using External Packages</source>
          <target state="translated">Uso de paquetes externos</target>
        </trans-unit>
        <trans-unit id="195ec6c54d68d4bc74c1c0e9e4aa71e8ed1d66dc" translate="yes" xml:space="preserve">
          <source>Using Message Passing to Transfer Data Between Threads</source>
          <target state="translated">Usar el paso de mensajes para transferir datos entre hilos</target>
        </trans-unit>
        <trans-unit id="1f1119d00f411f28a788c634b094f7830af90354" translate="yes" xml:space="preserve">
          <source>Using Mutexes to Allow Access to Data from One Thread at a Time</source>
          <target state="translated">Uso de los Mutex para permitir el acceso a los datos de un hilo a la vez</target>
        </trans-unit>
        <trans-unit id="0f71d9d6c5e4eb6b3d84f4f1645f9d37c7834e08" translate="yes" xml:space="preserve">
          <source>Using Nested Paths to Clean Up Large &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; Lists</source>
          <target state="translated">Uso de rutas anidadas para limpiar grandes listas de &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d061dfad64af5ced98da4099941d9962a4cf4ab6" translate="yes" xml:space="preserve">
          <source>Using Other &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; Trait Methods</source>
          <target state="translated">Uso de otros m&amp;eacute;todos de rasgos de &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90caab8414681ad380cd72175835d7d3a714a974" translate="yes" xml:space="preserve">
          <source>Using Our &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; Iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">Usando el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo de nuestro &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; Iterador</target>
        </trans-unit>
        <trans-unit id="4a36ca6063affef138895d5e70695435940c7941" translate="yes" xml:space="preserve">
          <source>Using Statics or Consts</source>
          <target state="translated">Usando estática o consistencia</target>
        </trans-unit>
        <trans-unit id="1d80a86fe9446545a29df6fe583694b8305fad7f" translate="yes" xml:space="preserve">
          <source>Using Structs to Structure Related Data</source>
          <target state="translated">Uso de estructuras para estructurar datos relacionados</target>
        </trans-unit>
        <trans-unit id="1725c7720c6951cb5321da47bdec76e1efb5b498" translate="yes" xml:space="preserve">
          <source>Using Supertraits to Require One Trait&amp;rsquo;s Functionality Within Another Trait</source>
          <target state="translated">Uso de superraratos para exigir la funcionalidad de un rasgo dentro de otro rasgo</target>
        </trans-unit>
        <trans-unit id="e5f7eb8898bb60910740832d2142728eab94b626" translate="yes" xml:space="preserve">
          <source>Using Threads to Run Code Simultaneously</source>
          <target state="translated">Usar hilos para ejecutar el código simultáneamente</target>
        </trans-unit>
        <trans-unit id="9c88360016895ec6069e43a4e277e7bdb51ba9ed" translate="yes" xml:space="preserve">
          <source>Using Trait Bounds to Conditionally Implement Methods</source>
          <target state="translated">Uso de los límites de los rasgos para aplicar métodos condicionales</target>
        </trans-unit>
        <trans-unit id="b4544e80831327296977b0f0c1bed06cd890a1fd" translate="yes" xml:space="preserve">
          <source>Using Trait Objects That Allow for Values of Different Types</source>
          <target state="translated">Usando objetos de rasgos que permiten valores de diferentes tipos</target>
        </trans-unit>
        <trans-unit id="735958a37951062c949a84a063e5b1d398369b00" translate="yes" xml:space="preserve">
          <source>Using Tuple Structs without Named Fields to Create Different Types</source>
          <target state="translated">Usar estructuras tuples sin campos nombrados para crear diferentes tipos</target>
        </trans-unit>
        <trans-unit id="675231858eb84206141ae12e664714cc21d2c19b" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Store Data on the Heap</source>
          <target state="translated">Uso de &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; para almacenar datos en el mont&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="f84a17c2b7b640800d3c95a6c6874936d40e4172" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; Backtrace</source>
          <target state="translated">&amp;iexcl;Con &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; Backtrace</target>
        </trans-unit>
        <trans-unit id="fa90ed41bcf90ab01a0c0386a65d7892a205380d" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Fn&lt;/code&gt; parameter</source>
          <target state="translated">Usando un par&amp;aacute;metro &lt;code&gt;Fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c233f257ce2f61e1743d09ba4202b368e77eac25" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnMut&lt;/code&gt; parameter</source>
          <target state="translated">Usando un par&amp;aacute;metro &lt;code&gt;FnMut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c47fce11968d69df2be1beb510ac309f7cc7fe1c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnOnce&lt;/code&gt; parameter</source>
          <target state="translated">Usando un par&amp;aacute;metro &lt;code&gt;FnOnce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eaa2ddbdb2af4f1c7b600386f3ab5d07fb639266" translate="yes" xml:space="preserve">
          <source>Using a Crate to Get More Functionality</source>
          <target state="translated">Usar una caja para obtener más funcionalidad</target>
        </trans-unit>
        <trans-unit id="5490ba3cbb37583be424e7381702b1ad23cc8d1f" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El uso de un bucle giratorio de espera ocupada con &lt;code&gt;spin_loop&lt;/code&gt; se usa idealmente en situaciones en las que otro subproceso ejecutado en una CPU diferente mantiene un bloqueo en conflicto y los tiempos de espera son relativamente peque&amp;ntilde;os. Debido a que ingresar al bucle de giro de espera ocupado no activa el programador del sistema, no se produce una sobrecarga para el cambio de subprocesos. Sin embargo, si el subproceso que contiene el bloqueo en disputa se ejecuta en la misma CPU, es probable que el bucle giratorio ocupe un segmento completo de CPU antes de cambiar al subproceso que mantiene el bloqueo. Si el bloqueo contendiente est&amp;aacute; retenido por un hilo en la misma CPU o si los tiempos de espera para adquirir el bloqueo son m&amp;aacute;s largos, a menudo es mejor usar &lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c1ce34ae6a3ca80d5e3bf4a0b0c41abaf191eae" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop_hint&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El uso de un bucle giratorio de espera ocupada con &lt;code&gt;spin_loop_hint&lt;/code&gt; se usa idealmente en situaciones en las que otro subproceso ejecutado en una CPU diferente mantiene un bloqueo contencioso y los tiempos de espera son relativamente peque&amp;ntilde;os. Debido a que ingresar al bucle de giro de espera ocupado no activa el programador del sistema, no se produce una sobrecarga para el cambio de subprocesos. Sin embargo, si el subproceso que contiene el bloqueo en disputa se ejecuta en la misma CPU, es probable que el bucle giratorio ocupe un segmento completo de CPU antes de cambiar al subproceso que mantiene el bloqueo. Si el bloqueo contendiente est&amp;aacute; retenido por un hilo en la misma CPU o si los tiempos de espera para adquirir el bloqueo son m&amp;aacute;s largos, a menudo es mejor usar &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b1ac01f9a3840dc6d78887aac134760ed5ceafe" translate="yes" xml:space="preserve">
          <source>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, &amp;ldquo;Add Sally to Engineering&amp;rdquo; or &amp;ldquo;Add Amir to Sales.&amp;rdquo; Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</source>
          <target state="translated">Usando un mapa hash y vectores, cree una interfaz de texto para permitir que un usuario agregue nombres de empleados a un departamento en una empresa. Por ejemplo, &quot;Agregar a Sally a Ingenier&amp;iacute;a&quot; o &quot;Agregar Amir a Ventas&quot;. Luego, permita que el usuario recupere una lista de todas las personas de un departamento o todas las personas de la empresa por departamento, ordenadas alfab&amp;eacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="09dacd7c78dbd0bf44dabf88b33b52973a393ac8" translate="yes" xml:space="preserve">
          <source>Using a primitive representation in addition to &lt;code&gt;repr(C)&lt;/code&gt; can change the size of an enum from the &lt;code&gt;repr(C)&lt;/code&gt; form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c37907d281b1198f03324a18111844e539d53d" translate="yes" xml:space="preserve">
          <source>Using a search key that doesn't work with the Borrow trait</source>
          <target state="translated">Usando una clave de búsqueda que no funciona con el rasgo del préstamo</target>
        </trans-unit>
        <trans-unit id="cd14ecb207f28002c37a4e53dc6c1cebfa5f2ee9" translate="yes" xml:space="preserve">
          <source>Using a semicolon after &lt;code&gt;mod front_of_house&lt;/code&gt; rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the &lt;code&gt;hosting&lt;/code&gt; module to its own file as well, we change &lt;em&gt;src/front_of_house.rs&lt;/em&gt; to contain only the declaration of the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">Usar un punto y coma despu&amp;eacute;s de &lt;code&gt;mod front_of_house&lt;/code&gt; en lugar de usar un bloque le dice a Rust que cargue el contenido del m&amp;oacute;dulo desde otro archivo con el mismo nombre que el m&amp;oacute;dulo. Para continuar con nuestro ejemplo y extraer el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; a su propio archivo tambi&amp;eacute;n, cambiamos &lt;em&gt;src / front_of_house.rs&lt;/em&gt; para que contenga solo la declaraci&amp;oacute;n del m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe93078130b3109ad5108e782dba78cf01903057" translate="yes" xml:space="preserve">
          <source>Using a tuple of &lt;code&gt;Bound&lt;/code&gt;s as an argument to &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt;&lt;code&gt;BTreeMap::range&lt;/code&gt;&lt;/a&gt;. Note that in most cases, it's better to use range syntax (&lt;code&gt;1..5&lt;/code&gt;) instead.</source>
          <target state="translated">Usando una tupla de &lt;code&gt;Bound&lt;/code&gt; s como argumento para &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt; &lt;code&gt;BTreeMap::range&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que en la mayor&amp;iacute;a de los casos, es mejor utilizar la sintaxis de rango ( &lt;code&gt;1..5&lt;/code&gt; ) en su lugar.</target>
        </trans-unit>
        <trans-unit id="015c01b29f1c8ebb6c4c8943a2dc3adcbae06181" translate="yes" xml:space="preserve">
          <source>Using an Enum to Store Multiple Types</source>
          <target state="translated">Uso de un Enum para almacenar múltiples tipos</target>
        </trans-unit>
        <trans-unit id="b5882a2dc057a0d8d156ec2e30b99dd996e5bdcc" translate="yes" xml:space="preserve">
          <source>Using built-in default values:</source>
          <target state="translated">Usando los valores por defecto incorporados:</target>
        </trans-unit>
        <trans-unit id="f3dacd0d875f3e763ce98391694ffe59eeffec43" translate="yes" xml:space="preserve">
          <source>Using custom comparison logic without newtype wrappers</source>
          <target state="translated">Usando la lógica de comparación personalizada sin envoltorios de nuevo tipo</target>
        </trans-unit>
        <trans-unit id="a4db67f6f9b0784800ae988e7704553e6de06b09" translate="yes" xml:space="preserve">
          <source>Using default values:</source>
          <target state="translated">Usando los valores por defecto:</target>
        </trans-unit>
        <trans-unit id="8ec600b0ec907749b0fdd372e79b0c70b7b0dce0" translate="yes" xml:space="preserve">
          <source>Using enums has even more advantages. Thinking more about our IP address type, at the moment we don&amp;rsquo;t have a way to store the actual IP address &lt;em&gt;data&lt;/em&gt;; we only know what &lt;em&gt;kind&lt;/em&gt; it is. Given that you just learned about structs in Chapter 5, you might tackle this problem as shown in Listing 6-1.</source>
          <target state="translated">Usar enumeraciones tiene a&amp;uacute;n m&amp;aacute;s ventajas. Pensando m&amp;aacute;s en nuestro tipo de direcci&amp;oacute;n IP, por el momento no tenemos una forma de almacenar los &lt;em&gt;datos&lt;/em&gt; reales de la direcci&amp;oacute;n IP ; solo sabemos de qu&amp;eacute; &lt;em&gt;tipo&lt;/em&gt; es. Dado que acaba de aprender sobre las estructuras en el Cap&amp;iacute;tulo 5, puede abordar este problema como se muestra en el Listado 6-1.</target>
        </trans-unit>
        <trans-unit id="3e92abb62f29a9ab743c0868201fc7c6f7cc104c" translate="yes" xml:space="preserve">
          <source>Using explicit synchronization:</source>
          <target state="translated">Usando una sincronización explícita:</target>
        </trans-unit>
        <trans-unit id="26140a4b00b6db68bc5c08aa7b59f4de9a496d44" translate="yes" xml:space="preserve">
          <source>Using implicit synchronization:</source>
          <target state="translated">Usando la sincronización implícita:</target>
        </trans-unit>
        <trans-unit id="0964494ac4fd47f86d6e1abd134d8f88a80450c7" translate="yes" xml:space="preserve">
          <source>Using mutation and going finite:</source>
          <target state="translated">Usando la mutación y volviéndose finito:</target>
        </trans-unit>
        <trans-unit id="c5cfc67f6bee08fd41a46b1d08f1ad9861c6e196" translate="yes" xml:space="preserve">
          <source>Using path qualifiers like &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword.super&quot;&gt;&lt;code&gt;super&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.self&quot;&gt;&lt;code&gt;self&lt;/code&gt;&lt;/a&gt; is supported: &lt;code&gt;use crate::a::b;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5b3892671b9cc1bcba84f83ea8ba99412282b3" translate="yes" xml:space="preserve">
          <source>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax &lt;code&gt;..&lt;/code&gt; specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</source>
          <target state="translated">Usando la sintaxis de actualizaci&amp;oacute;n de la estructura, podemos lograr el mismo efecto con menos c&amp;oacute;digo, como se muestra en el Listado 5-7. La sintaxis &lt;code&gt;..&lt;/code&gt; especifica que los campos restantes no establecidos expl&amp;iacute;citamente deben tener el mismo valor que los campos en la instancia dada.</target>
        </trans-unit>
        <trans-unit id="149131436ae6fcc58b9d3b44704c0a4f62b58b80" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:</source>
          <target state="translated">Usando el 'turbofish' en lugar de anotar el &lt;code&gt;doubled&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1fee5723d61f0a87e52c62c70350b33d4a2c1211" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;four&lt;/code&gt;:</source>
          <target state="translated">Usando el 'turbofish' en lugar de anotar &lt;code&gt;four&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8dca1dfea48258776a757d0e7fdd52e32ddc6d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; Function in the &lt;code&gt;run&lt;/code&gt; Function</source>
          <target state="translated">Uso de la funci&amp;oacute;n de &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; en la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73cb7c6eceba8574fdab292dc3c5b0a2f2322727" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&lt;/code&gt; type to store the list &lt;code&gt;1, 2, 3&lt;/code&gt; would look like the code in Listing 15-3:</source>
          <target state="translated">El uso del tipo &lt;code&gt;List&lt;/code&gt; a para almacenar la lista &lt;code&gt;1, 2, 3&lt;/code&gt; se ver&amp;iacute;a como el c&amp;oacute;digo del Listado 15-3:</target>
        </trans-unit>
        <trans-unit id="707e73f8481ac39cdfa5e294240c14e577bab80b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;ref&lt;/code&gt; keyword, the value is only borrowed, not moved, making it available for use after the &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2545ef2f465dd4b2bb1fca4f7b62b633439903e" translate="yes" xml:space="preserve">
          <source>Using the Field Init Shorthand when Variables and Fields Have the Same Name</source>
          <target state="translated">Uso de la abreviatura Field Init cuando las variables y los campos tienen el mismo nombre</target>
        </trans-unit>
        <trans-unit id="527c6fc37f2c7ff511bb334d8bc01dfd4d796198" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern for Type Safety and Abstraction</source>
          <target state="translated">Usando el Nuevo Patrón de Seguridad y Abstracción de Tipos</target>
        </trans-unit>
        <trans-unit id="0445dab15f95bbaf439f12315a2f6c2606b64d6c" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern to Implement External Traits on External Types</source>
          <target state="translated">Uso del patrón de nuevos tipos para implementar rasgos externos en los tipos externos</target>
        </trans-unit>
        <trans-unit id="6efe08dd70627a6ae791a8f3c7e219c91abdce73" translate="yes" xml:space="preserve">
          <source>Using the Returned Iterator Directly</source>
          <target state="translated">Usando el iterador devuelto directamente</target>
        </trans-unit>
        <trans-unit id="bfe1a641af30e378f1440126b6876e787e3aeb21" translate="yes" xml:space="preserve">
          <source>Using the state pattern means when the business requirements of the program change, we won&amp;rsquo;t need to change the code of the value holding the state or the code that uses the value. We&amp;rsquo;ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects. Let&amp;rsquo;s look at an example of the state design pattern and how to use it in Rust.</source>
          <target state="translated">Usar el patr&amp;oacute;n de estado significa que cuando los requisitos comerciales del programa cambian, no necesitaremos cambiar el c&amp;oacute;digo del valor que contiene el estado o el c&amp;oacute;digo que usa el valor. Solo necesitaremos actualizar el c&amp;oacute;digo dentro de uno de los objetos de estado para cambiar sus reglas o quiz&amp;aacute;s agregar m&amp;aacute;s objetos de estado. Veamos un ejemplo del patr&amp;oacute;n de dise&amp;ntilde;o estatal y c&amp;oacute;mo usarlo en Rust.</target>
        </trans-unit>
        <trans-unit id="f27958ea70e4427546613b6470c7b4a627139188" translate="yes" xml:space="preserve">
          <source>Using this declaration, it must be called with at least one argument, so simply calling &lt;code&gt;printf()&lt;/code&gt; is invalid. But the following uses are allowed:</source>
          <target state="translated">Usando esta declaraci&amp;oacute;n, se debe llamar con al menos un argumento, por lo que simplemente llamar a &lt;code&gt;printf()&lt;/code&gt; no es v&amp;aacute;lido. Pero se permiten los siguientes usos:</target>
        </trans-unit>
        <trans-unit id="3febf8421408faebfe197da05a42aac2ff47af45" translate="yes" xml:space="preserve">
          <source>Using this definition, Rust is object oriented: structs and enums have data, and &lt;code&gt;impl&lt;/code&gt; blocks provide methods on structs and enums. Even though structs and enums with methods aren&amp;rsquo;t &lt;em&gt;called&lt;/em&gt; objects, they provide the same functionality, according to the Gang of Four&amp;rsquo;s definition of objects.</source>
          <target state="translated">Usando esta definici&amp;oacute;n, Rust est&amp;aacute; orientado a objetos: las estructuras y enumeraciones tienen datos, y los bloques &lt;code&gt;impl&lt;/code&gt; proporcionan m&amp;eacute;todos sobre estructuras y enumeraciones. Aunque las estructuras y enumeraciones con m&amp;eacute;todos no se &lt;em&gt;llaman&lt;/em&gt; objetos, proporcionan la misma funcionalidad, de acuerdo con la definici&amp;oacute;n de objetos de Gang of Four.</target>
        </trans-unit>
        <trans-unit id="4bd35f75969eee3d765cd1e9dcbd0cf13c21dc8a" translate="yes" xml:space="preserve">
          <source>Using this function is generally faster than using &lt;code&gt;powf&lt;/code&gt;</source>
          <target state="translated">Usar esta funci&amp;oacute;n es generalmente m&amp;aacute;s r&amp;aacute;pido que usar &lt;code&gt;powf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c548fba9d029d6e16cb5aeebbb487347aada0fef" translate="yes" xml:space="preserve">
          <source>Using this macro is often a bad idea, because if the file is parsed as an expression, it is going to be placed in the surrounding code unhygienically. This could result in variables or functions being different from what the file expected if there are variables or functions that have the same name in the current file.</source>
          <target state="translated">Usar esta macro es a menudo una mala idea,porque si el archivo es analizado como una expresión,va a ser colocado en el código circundante de forma antihigiénica.Esto podría dar lugar a que las variables o funciones sean diferentes de lo que el archivo esperaba si hay variables o funciones que tienen el mismo nombre en el archivo actual.</target>
        </trans-unit>
        <trans-unit id="a7c45efccaaa01e2feb082b19ddba5a32324e6fa" translate="yes" xml:space="preserve">
          <source>Using this method is equivalent to the following code:</source>
          <target state="translated">El uso de este método es equivalente al siguiente código:</target>
        </trans-unit>
        <trans-unit id="15e11a1b79c37f9d667f56c8b714852cef36b238" translate="yes" xml:space="preserve">
          <source>Using too many &lt;code&gt;else if&lt;/code&gt; expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called &lt;code&gt;match&lt;/code&gt; for these cases.</source>
          <target state="translated">Usar demasiadas expresiones &lt;code&gt;else if&lt;/code&gt; puede saturar su c&amp;oacute;digo, por lo que si tiene m&amp;aacute;s de una, es posible que desee refactorizar su c&amp;oacute;digo. El cap&amp;iacute;tulo 6 describe una poderosa construcci&amp;oacute;n de ramificaci&amp;oacute;n de Rust llamada &lt;code&gt;match&lt;/code&gt; para estos casos.</target>
        </trans-unit>
        <trans-unit id="e52bd27c5d26825ad08651412fd660a16f020f77" translate="yes" xml:space="preserve">
          <source>Using too many trait bounds has its downsides. Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function&amp;rsquo;s name and its parameter list, making the function signature hard to read. For this reason, Rust has alternate syntax for specifying trait bounds inside a &lt;code&gt;where&lt;/code&gt; clause after the function signature. So instead of writing this:</source>
          <target state="translated">Usar demasiados l&amp;iacute;mites de rasgos tiene sus desventajas. Cada gen&amp;eacute;rico tiene sus propios l&amp;iacute;mites de caracter&amp;iacute;sticas, por lo que las funciones con m&amp;uacute;ltiples par&amp;aacute;metros de tipo gen&amp;eacute;rico pueden contener mucha informaci&amp;oacute;n ligada a caracter&amp;iacute;sticas entre el nombre de la funci&amp;oacute;n y su lista de par&amp;aacute;metros, lo que hace que la firma de la funci&amp;oacute;n sea dif&amp;iacute;cil de leer. Por esta raz&amp;oacute;n, Rust tiene una sintaxis alternativa para especificar l&amp;iacute;mites de rasgos dentro de una cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; despu&amp;eacute;s de la firma de la funci&amp;oacute;n. Entonces, en lugar de escribir esto:</target>
        </trans-unit>
        <trans-unit id="e8270120e8e5872b95f691e94134c3c38cbe49b0" translate="yes" xml:space="preserve">
          <source>Using traits and lifetimes where appropriate (&lt;a href=&quot;ch10-00-generics&quot;&gt;Chapter 10&lt;/a&gt;)</source>
          <target state="translated">Usar rasgos y vidas cuando sea apropiado ( &lt;a href=&quot;ch10-00-generics&quot;&gt;Cap&amp;iacute;tulo 10&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1c8fe76861637e35d40bd85f3825d619bc84eadf" translate="yes" xml:space="preserve">
          <source>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</source>
          <target state="translated">El uso de funciones inseguras es potencialmente peligroso y no está permitido por los controles de seguridad.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="f903dfb928504d5e71a1ab430366f1a7eae7e14e" translate="yes" xml:space="preserve">
          <source>Using vectors and strings (collections, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;Chapter 8&lt;/a&gt;)</source>
          <target state="translated">Usar vectores y cadenas (colecciones, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;Cap&amp;iacute;tulo 8&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d6513e8f7510d42121946e2407ba6c2011fc2c1c" translate="yes" xml:space="preserve">
          <source>Usually a &lt;code&gt;use&lt;/code&gt; keyword is used to shorten the path required to refer to a module item. The keyword may appear in modules, blocks and even functions, usually at the top.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83a4fba159bee344e91cbe040d6123421c523d3" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't literally use &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; from Rust, but C APIs hand out a lot of pointers generally, so are a common source of raw pointers in Rust.</source>
          <target state="translated">Por lo general, no usar&amp;iacute;a literalmente &lt;code&gt;malloc&lt;/code&gt; y no estar&amp;iacute;a &lt;code&gt;free&lt;/code&gt; de Rust, pero las API de C brindan muchos indicadores en general, por lo que son una fuente com&amp;uacute;n de indicadores sin procesar en Rust.</target>
        </trans-unit>
        <trans-unit id="906d4775d8872c7dc79527063674165dda2ccbc0" translate="yes" xml:space="preserve">
          <source>Usually, generic parameters get &lt;em&gt;monomorphized&lt;/em&gt;. For example, if I have</source>
          <target state="translated">Por lo general, los par&amp;aacute;metros gen&amp;eacute;ricos se &lt;em&gt;monomorfizan&lt;/em&gt; . Por ejemplo, si tengo</target>
        </trans-unit>
        <trans-unit id="d259bb65f469f691c60fbc1cce6f48ae71721980" translate="yes" xml:space="preserve">
          <source>Usually, iterators iterate from left to right. After using &lt;code&gt;rev()&lt;/code&gt;, an iterator will instead iterate from right to left.</source>
          <target state="translated">Por lo general, los iteradores iteran de izquierda a derecha. Despu&amp;eacute;s de usar &lt;code&gt;rev()&lt;/code&gt; , un iterador iterar&amp;aacute; de derecha a izquierda.</target>
        </trans-unit>
        <trans-unit id="71c8b88aacf28ce47b0a58b2d2bc8a3fb05b911b" translate="yes" xml:space="preserve">
          <source>Utf8Error</source>
          <target state="translated">Utf8Error</target>
        </trans-unit>
        <trans-unit id="0dc56eae851492c66ecabf78d1bbaf00296acfbe" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow</source>
          <target state="translated">Utf8Error::borrow</target>
        </trans-unit>
        <trans-unit id="62c9947a079483bdf0d15d01617213826dc02f38" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow_mut</source>
          <target state="translated">Utf8Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="3f5e10da6a480e49a740c45c14fd97e4e299d73d" translate="yes" xml:space="preserve">
          <source>Utf8Error::cause</source>
          <target state="translated">Utf8Error::cause</target>
        </trans-unit>
        <trans-unit id="aba276798126f3d9e88abbf114717adc671724b0" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone</source>
          <target state="translated">Utf8Error::clone</target>
        </trans-unit>
        <trans-unit id="d9f741fd3eb062e41262e053f0eb1a689e8b68c8" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_from</source>
          <target state="translated">Utf8Error::clone_from</target>
        </trans-unit>
        <trans-unit id="6fb618053c3a87e8372bf0b005ef3aee33a2be29" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_into</source>
          <target state="translated">Utf8Error::clone_into</target>
        </trans-unit>
        <trans-unit id="5eb848f299ba96b5c68a3de5bf02961b034fb439" translate="yes" xml:space="preserve">
          <source>Utf8Error::description</source>
          <target state="translated">Utf8Error::description</target>
        </trans-unit>
        <trans-unit id="1e357eccf69d01f74bf39edbfab63655804a87a8" translate="yes" xml:space="preserve">
          <source>Utf8Error::eq</source>
          <target state="translated">Utf8Error::eq</target>
        </trans-unit>
        <trans-unit id="88f730d875142fa4beddb68ae32ca749e55c5da0" translate="yes" xml:space="preserve">
          <source>Utf8Error::error_len</source>
          <target state="translated">Utf8Error::error_len</target>
        </trans-unit>
        <trans-unit id="81707f4d43116cddc3b6180c7d1812770aa6aabd" translate="yes" xml:space="preserve">
          <source>Utf8Error::fmt</source>
          <target state="translated">Utf8Error::fmt</target>
        </trans-unit>
        <trans-unit id="80d9f3c5cc9b436bfc54741853eb348edcd31923" translate="yes" xml:space="preserve">
          <source>Utf8Error::from</source>
          <target state="translated">Utf8Error::from</target>
        </trans-unit>
        <trans-unit id="186ae2f6ff2c38ceed80692f48587dd9073b281b" translate="yes" xml:space="preserve">
          <source>Utf8Error::into</source>
          <target state="translated">Utf8Error::into</target>
        </trans-unit>
        <trans-unit id="da5d217600f498b06be2479022d36a4a5c15449b" translate="yes" xml:space="preserve">
          <source>Utf8Error::ne</source>
          <target state="translated">Utf8Error::ne</target>
        </trans-unit>
        <trans-unit id="65ff32fff52c3afe8fd1470fd4590b2fae222e96" translate="yes" xml:space="preserve">
          <source>Utf8Error::source</source>
          <target state="translated">Utf8Error::source</target>
        </trans-unit>
        <trans-unit id="d542954047d8755ad1a4e9a853bcf03561cdf1c9" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_owned</source>
          <target state="translated">Utf8Error::to_owned</target>
        </trans-unit>
        <trans-unit id="ef5e78b58ef441d19d975802cc905ce882b752c7" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_string</source>
          <target state="translated">Utf8Error::to_string</target>
        </trans-unit>
        <trans-unit id="eb1790431a34016d236cceca893cabedf79794fa" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_from</source>
          <target state="translated">Utf8Error::try_from</target>
        </trans-unit>
        <trans-unit id="d78057a09376f581ad70dcf23d55b916b4ec76d6" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_into</source>
          <target state="translated">Utf8Error::try_into</target>
        </trans-unit>
        <trans-unit id="77455bd6cede93b6937284b56ca0ee7128f3fcd5" translate="yes" xml:space="preserve">
          <source>Utf8Error::type_id</source>
          <target state="translated">Utf8Error::type_id</target>
        </trans-unit>
        <trans-unit id="061f930ae2881081028ec6f4738788ea0386348a" translate="yes" xml:space="preserve">
          <source>Utf8Error::valid_up_to</source>
          <target state="translated">Utf8Error::valid_up_to</target>
        </trans-unit>
        <trans-unit id="098996f33abfeafe0fd0a1060966a3bd981c2d4c" translate="yes" xml:space="preserve">
          <source>Utilities for formatting and printing &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">Utilidades para formatear e imprimir &lt;code&gt;String&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="bbf05f92621e129ba6a9d6d71f520f94619321a3" translate="yes" xml:space="preserve">
          <source>Utilities related to FFI bindings.</source>
          <target state="translated">Utilidades relacionadas con las fijaciones de FFI.</target>
        </trans-unit>
        <trans-unit id="2cfce7b7e1bbf22d999dd679513efd8dd1774d5b" translate="yes" xml:space="preserve">
          <source>Utility trait implemented only on arrays of fixed size</source>
          <target state="translated">Rasgo de utilidad implementado sólo en matrices de tamaño fijo</target>
        </trans-unit>
        <trans-unit id="f4dc02e287a9f4de99799a5c31108f51723830a7" translate="yes" xml:space="preserve">
          <source>VXWorks</source>
          <target state="translated">VXWorks</target>
        </trans-unit>
        <trans-unit id="2a62ae9e6e10d5b4d844ad431e3d12dd6181892a" translate="yes" xml:space="preserve">
          <source>VaList</source>
          <target state="translated">VaList</target>
        </trans-unit>
        <trans-unit id="d3dc417a5e809aff4e928e1c2ccc9e1476eea745" translate="yes" xml:space="preserve">
          <source>VaList::arg</source>
          <target state="translated">VaList::arg</target>
        </trans-unit>
        <trans-unit id="e56bcc6610b1a8196319373f5b202bf4d9783931" translate="yes" xml:space="preserve">
          <source>VaList::as_va_list</source>
          <target state="translated">VaList::as_va_list</target>
        </trans-unit>
        <trans-unit id="93ccd0479992f30997a13f7a0291305d4a7bcf8f" translate="yes" xml:space="preserve">
          <source>VaList::borrow</source>
          <target state="translated">VaList::borrow</target>
        </trans-unit>
        <trans-unit id="14c647375c9b8191c6015d7e9763130b93ea3cb0" translate="yes" xml:space="preserve">
          <source>VaList::borrow_mut</source>
          <target state="translated">VaList::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c8adb5d15703c32cb6620339a1ad3a830f1ad937" translate="yes" xml:space="preserve">
          <source>VaList::deref</source>
          <target state="translated">VaList::deref</target>
        </trans-unit>
        <trans-unit id="ef4f8c0aefca94cf0351ab804dcb1192072b3317" translate="yes" xml:space="preserve">
          <source>VaList::deref_mut</source>
          <target state="translated">VaList::deref_mut</target>
        </trans-unit>
        <trans-unit id="4df0a82f8196ee6c8e34acaf7e521f5043ecc3f2" translate="yes" xml:space="preserve">
          <source>VaList::fmt</source>
          <target state="translated">VaList::fmt</target>
        </trans-unit>
        <trans-unit id="03cb0ba45ef46a478c6e89bd3b44e1281a4d5eb6" translate="yes" xml:space="preserve">
          <source>VaList::from</source>
          <target state="translated">VaList::from</target>
        </trans-unit>
        <trans-unit id="2b7cbe3710d07592cd359bf917b0387f4e9e9c5d" translate="yes" xml:space="preserve">
          <source>VaList::into</source>
          <target state="translated">VaList::into</target>
        </trans-unit>
        <trans-unit id="006354eed9f82fbe26fc29d15037b46b80c2b68d" translate="yes" xml:space="preserve">
          <source>VaList::try_from</source>
          <target state="translated">VaList::try_from</target>
        </trans-unit>
        <trans-unit id="cb8a2fefa105254fc69713249a582cf152da5fab" translate="yes" xml:space="preserve">
          <source>VaList::try_into</source>
          <target state="translated">VaList::try_into</target>
        </trans-unit>
        <trans-unit id="00466fb65a3743839a76ad49fc45873af21ac5b5" translate="yes" xml:space="preserve">
          <source>VaList::type_id</source>
          <target state="translated">VaList::type_id</target>
        </trans-unit>
        <trans-unit id="c8012d496381feb2e9a104eb4daca8ce56213794" translate="yes" xml:space="preserve">
          <source>VaList::with_copy</source>
          <target state="translated">VaList::with_copy</target>
        </trans-unit>
        <trans-unit id="cda940b5210ef6c9c3a6f85409e7dfeabc36a58a" translate="yes" xml:space="preserve">
          <source>VaListImpl</source>
          <target state="translated">VaListImpl</target>
        </trans-unit>
        <trans-unit id="3ca16b32106de1b77aafe6c23653b3844b349ae2" translate="yes" xml:space="preserve">
          <source>VaListImpl::arg</source>
          <target state="translated">VaListImpl::arg</target>
        </trans-unit>
        <trans-unit id="f4173f47c545e4746400db7076f692fc8d564b6d" translate="yes" xml:space="preserve">
          <source>VaListImpl::as_va_list</source>
          <target state="translated">VaListImpl::as_va_list</target>
        </trans-unit>
        <trans-unit id="d4f4feeb2f49c83d41fa723579047ba246044ff7" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow</source>
          <target state="translated">VaListImpl::borrow</target>
        </trans-unit>
        <trans-unit id="12efac9fbc832f37c148aabeed63349a1f5126dd" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow_mut</source>
          <target state="translated">VaListImpl::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3f6404a6c3b18f2e79cb5750c66a38cba6e8a6c" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone</source>
          <target state="translated">VaListImpl::clone</target>
        </trans-unit>
        <trans-unit id="c95d8d0d76cdd92d3789595b002435cb8b173ba3" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_from</source>
          <target state="translated">VaListImpl::clone_from</target>
        </trans-unit>
        <trans-unit id="b7e21123ef8eeecb128af522573adb35c0d73ae7" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_into</source>
          <target state="translated">VaListImpl::clone_into</target>
        </trans-unit>
        <trans-unit id="8cc867e3d0ec9d7fb9edb3f064cbe3324e06efce" translate="yes" xml:space="preserve">
          <source>VaListImpl::drop</source>
          <target state="translated">VaListImpl::drop</target>
        </trans-unit>
        <trans-unit id="c61984180c1cbdf98ccebd337221adae24339007" translate="yes" xml:space="preserve">
          <source>VaListImpl::fmt</source>
          <target state="translated">VaListImpl::fmt</target>
        </trans-unit>
        <trans-unit id="5914da98901e40d1b7387569cc8698d5354eda2d" translate="yes" xml:space="preserve">
          <source>VaListImpl::from</source>
          <target state="translated">VaListImpl::from</target>
        </trans-unit>
        <trans-unit id="69d61c23655b32b3d7479d5b9b6a68338cf35be2" translate="yes" xml:space="preserve">
          <source>VaListImpl::into</source>
          <target state="translated">VaListImpl::into</target>
        </trans-unit>
        <trans-unit id="5bfd2cfab7029ef58c310f856c3da54cb4b8f66b" translate="yes" xml:space="preserve">
          <source>VaListImpl::to_owned</source>
          <target state="translated">VaListImpl::to_owned</target>
        </trans-unit>
        <trans-unit id="2a010a2b25dc2ad1ab26cc514156dc9263f6a636" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_from</source>
          <target state="translated">VaListImpl::try_from</target>
        </trans-unit>
        <trans-unit id="d69de8fd6c5d1bc620b9f394404b1608c17d118f" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_into</source>
          <target state="translated">VaListImpl::try_into</target>
        </trans-unit>
        <trans-unit id="d07770d2e23a78895791cb1ceaf87ef62f25d60c" translate="yes" xml:space="preserve">
          <source>VaListImpl::type_id</source>
          <target state="translated">VaListImpl::type_id</target>
        </trans-unit>
        <trans-unit id="d2fa0e7319df7d0644b9ea0a44af083d4b6e723c" translate="yes" xml:space="preserve">
          <source>VaListImpl::with_copy</source>
          <target state="translated">VaListImpl::with_copy</target>
        </trans-unit>
        <trans-unit id="4e28dc650ae01219c2816ac14486f89634c8fc55" translate="yes" xml:space="preserve">
          <source>VacantEntry</source>
          <target state="translated">VacantEntry</target>
        </trans-unit>
        <trans-unit id="c96052bd94ad047ad8849208c48bf71c8e89ef7c" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">La sintaxis de patr&amp;oacute;n v&amp;aacute;lida en las definiciones de macros es diferente a la sintaxis de patr&amp;oacute;n cubierta en el Cap&amp;iacute;tulo 18 porque los patrones de macro se comparan con la estructura del c&amp;oacute;digo de Rust en lugar de con los valores. Repasemos lo que significan las piezas del patr&amp;oacute;n del Listado 19-28; para obtener la sintaxis completa del patr&amp;oacute;n de macros, consulte &lt;a href=&quot;../reference/macros&quot;&gt;la referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7af7dd6d571b7430a0f3a804a2823ff5e3b34175" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros-by-example&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e50fbff8c8b7744c52b295c7fbf72559544494" translate="yes" xml:space="preserve">
          <source>Valid raw pointers as defined above are not necessarily properly aligned (where &quot;proper&quot; alignment is defined by the pointee type, i.e., &lt;code&gt;*const T&lt;/code&gt; must be aligned to &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt;). However, most functions require their arguments to be properly aligned, and will explicitly state this requirement in their documentation. Notable exceptions to this are &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los punteros en bruto v&amp;aacute;lidos como se definieron anteriormente no est&amp;aacute;n necesariamente alineados correctamente (donde la alineaci&amp;oacute;n &quot;adecuada&quot; se define por el tipo de puntero, es decir, &lt;code&gt;*const T&lt;/code&gt; debe estar alineado con &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ). Sin embargo, la mayor&amp;iacute;a de las funciones requieren que sus argumentos est&amp;eacute;n correctamente alineados y declarar&amp;aacute;n expl&amp;iacute;citamente este requisito en su documentaci&amp;oacute;n. Las excepciones notables a esto son &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;fn.write_unaligned&quot;&gt; &lt;code&gt;write_unaligned&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c48f78e987c312ef821adcc0d7ee75c56d9144ac" translate="yes" xml:space="preserve">
          <source>Validating References with Lifetimes</source>
          <target state="translated">Validación de las referencias con las vidas</target>
        </trans-unit>
        <trans-unit id="9bbb454d5a41c8f26ec9fb9b367e97c6b19c2f83" translate="yes" xml:space="preserve">
          <source>Validating the Number of Threads in &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt;</source>
          <target state="translated">Validaci&amp;oacute;n del n&amp;uacute;mero de subprocesos en &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5528864ad5f1464447c6381f31faab679eb55d8" translate="yes" xml:space="preserve">
          <source>Validating the Request and Selectively Responding</source>
          <target state="translated">Validación de la solicitud y respuesta selectiva</target>
        </trans-unit>
        <trans-unit id="c4d75c989017ceaea555b5cb2f965e9a31a0f2ae" translate="yes" xml:space="preserve">
          <source>Value being parsed is empty.</source>
          <target state="translated">El valor que se está analizando está vacío.</target>
        </trans-unit>
        <trans-unit id="202eac546e1cca5cc40fbd1aa3d448b11c2717ed" translate="yes" xml:space="preserve">
          <source>Value was Zero</source>
          <target state="translated">El valor era cero</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="0c9f5af2d57c101875a9c09b9e64f7ab67e3fee1" translate="yes" xml:space="preserve">
          <source>Values larger than the maximum integer value will saturate to the maximum value of the integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb37a0444183e3bd07455b2f462b02a3823b4ce" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; types may be mutated through shared references (i.e. the common &lt;code&gt;&amp;amp;T&lt;/code&gt; type), whereas most Rust types can only be mutated through unique (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) references. We say that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.</source>
          <target state="translated">Los valores de los tipos &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; pueden mutarse a trav&amp;eacute;s de referencias compartidas (es decir, el tipo &lt;code&gt;&amp;amp;T&lt;/code&gt; com&amp;uacute;n ), mientras que la mayor&amp;iacute;a de los tipos de Rust solo pueden mutarse mediante referencias &amp;uacute;nicas ( &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ). Decimos que &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; proporcionan 'mutabilidad interior', en contraste con los tipos t&amp;iacute;picos de Rust que exhiben 'mutabilidad heredada'.</target>
        </trans-unit>
        <trans-unit id="df0b0235c50fdaa3c200fefa43bc29bd936a024f" translate="yes" xml:space="preserve">
          <source>Values of this type are constructed using a &lt;a href=&quot;../expressions/tuple-expr#tuple-expressions&quot;&gt;tuple expression&lt;/a&gt;. Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to. Tuple elements can be accessed by either a &lt;a href=&quot;../expressions/tuple-expr#tuple-indexing-expressions&quot;&gt;tuple index expression&lt;/a&gt; or &lt;a href=&quot;../patterns#tuple-patterns&quot;&gt;pattern matching&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ead0c6d8884038da5a1c37b81bd9ecdfeb765f5" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;U&lt;/code&gt;</source>
          <target state="translated">Los valores de tipo &lt;code&gt;&amp;amp;T&lt;/code&gt; se convierten en valores de tipo &lt;code&gt;&amp;amp;U&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd64aa37983b87ea2f61bdac9618cf696e12dc47" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</source>
          <target state="translated">Los valores de tipo &lt;code&gt;&amp;amp;mut T&lt;/code&gt; se convierten en valores de tipo &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8a037908d83b45e7c8a2c2c4fe0fb372c4e345" translate="yes" xml:space="preserve">
          <source>Values returned by the iterator are returned in ascending order:</source>
          <target state="translated">Los valores devueltos por el iterador se devuelven en orden ascendente:</target>
        </trans-unit>
        <trans-unit id="7d470a568e8e665e2abbc283ee00bd48e19164d9" translate="yes" xml:space="preserve">
          <source>Values smaller than the minimum integer value will saturate to the minimum value of the integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7afb9932010efa26617ba00942998437043da478" translate="yes" xml:space="preserve">
          <source>ValuesMut</source>
          <target state="translated">ValuesMut</target>
        </trans-unit>
        <trans-unit id="6f7df0e9c5abd887cbbca9fb8a84f3706f71be4d" translate="yes" xml:space="preserve">
          <source>VarError</source>
          <target state="translated">VarError</target>
        </trans-unit>
        <trans-unit id="b2249943fec1979f3539ebcd42bc0163bc44ee0a" translate="yes" xml:space="preserve">
          <source>VarError::borrow</source>
          <target state="translated">VarError::borrow</target>
        </trans-unit>
        <trans-unit id="e76b4c157350bd5d1faf74dc1a04fc95858ad1b0" translate="yes" xml:space="preserve">
          <source>VarError::borrow_mut</source>
          <target state="translated">VarError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8102864035147256ef0e364c15593289f8d64dc2" translate="yes" xml:space="preserve">
          <source>VarError::cause</source>
          <target state="translated">VarError::cause</target>
        </trans-unit>
        <trans-unit id="7077379d5b4387ff8ef4d01332e0c9cb99aeba54" translate="yes" xml:space="preserve">
          <source>VarError::clone</source>
          <target state="translated">VarError::clone</target>
        </trans-unit>
        <trans-unit id="0632068939784835c82259892b18fa3851d349ae" translate="yes" xml:space="preserve">
          <source>VarError::clone_from</source>
          <target state="translated">VarError::clone_from</target>
        </trans-unit>
        <trans-unit id="3e4c81dcadc33c305fcb9909e431adbde92a23e1" translate="yes" xml:space="preserve">
          <source>VarError::clone_into</source>
          <target state="translated">VarError::clone_into</target>
        </trans-unit>
        <trans-unit id="ec42cb6e55e02863f7703ec026731824032ed4c6" translate="yes" xml:space="preserve">
          <source>VarError::description</source>
          <target state="translated">VarError::description</target>
        </trans-unit>
        <trans-unit id="8d65ad24989288d2260d520733e5b865bcae5729" translate="yes" xml:space="preserve">
          <source>VarError::eq</source>
          <target state="translated">VarError::eq</target>
        </trans-unit>
        <trans-unit id="467b0e136a5d88a16831d064cfef40627edbdee5" translate="yes" xml:space="preserve">
          <source>VarError::fmt</source>
          <target state="translated">VarError::fmt</target>
        </trans-unit>
        <trans-unit id="5122b46ea820b54b6d938c3fc817b38fbb3551ec" translate="yes" xml:space="preserve">
          <source>VarError::from</source>
          <target state="translated">VarError::from</target>
        </trans-unit>
        <trans-unit id="489e1a123c276c2da9ec69dea9020703001650ca" translate="yes" xml:space="preserve">
          <source>VarError::into</source>
          <target state="translated">VarError::into</target>
        </trans-unit>
        <trans-unit id="77f840cd95edf89f75e8cbd45132b08b456a0812" translate="yes" xml:space="preserve">
          <source>VarError::ne</source>
          <target state="translated">VarError::ne</target>
        </trans-unit>
        <trans-unit id="0c18e774293ad67a8f9a9531c4cd7c614981cf63" translate="yes" xml:space="preserve">
          <source>VarError::source</source>
          <target state="translated">VarError::source</target>
        </trans-unit>
        <trans-unit id="e8289e8f0efbef22ac2ef6d43d6c953e17d68e73" translate="yes" xml:space="preserve">
          <source>VarError::to_owned</source>
          <target state="translated">VarError::to_owned</target>
        </trans-unit>
        <trans-unit id="3b34bb1f1ce27eec8b875707ed1773dc9147c967" translate="yes" xml:space="preserve">
          <source>VarError::to_string</source>
          <target state="translated">VarError::to_string</target>
        </trans-unit>
        <trans-unit id="2d14c21b020fdc28d154a0e06cc4cefbc03f8bd7" translate="yes" xml:space="preserve">
          <source>VarError::try_from</source>
          <target state="translated">VarError::try_from</target>
        </trans-unit>
        <trans-unit id="20dfa7580a9574a0ffa43df49fcb51fd1edef1e7" translate="yes" xml:space="preserve">
          <source>VarError::try_into</source>
          <target state="translated">VarError::try_into</target>
        </trans-unit>
        <trans-unit id="67e6d907fb202086a0226ec13ebdeab6dee225b8" translate="yes" xml:space="preserve">
          <source>VarError::type_id</source>
          <target state="translated">VarError::type_id</target>
        </trans-unit>
        <trans-unit id="b280dc1f4f1b58422609af96e60af9910ffc1aac" translate="yes" xml:space="preserve">
          <source>Variable Scope</source>
          <target state="translated">Alcance variable</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="732411588a5167f463feab941a8f9ac01a5767df" translate="yes" xml:space="preserve">
          <source>Variables and Mutability</source>
          <target state="translated">Variables y mutabilidad</target>
        </trans-unit>
        <trans-unit id="3aa41db4c47f6adb669361c7bd5c456d22e65ea3" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration</source>
          <target state="translated">Las variables se eliminan en el orden inverso al de la declaración</target>
        </trans-unit>
        <trans-unit id="be65562327a4b52bee54dc313d949d1238b35a3e" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration. Variables declared in the same pattern drop in an unspecified ordered.</source>
          <target state="translated">Las variables se eliminan en el orden inverso al de la declaración.Las variables declaradas en el mismo patrón caen en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="098937ab2cfb527e074d853750f7a28c47a33f35" translate="yes" xml:space="preserve">
          <source>Variables bound within the pattern are scoped to the match guard and the arm's expression. The &lt;a href=&quot;../patterns#binding-modes&quot;&gt;binding mode&lt;/a&gt; (move, copy, or reference) depends on the pattern.</source>
          <target state="translated">Las variables ligadas dentro del patr&amp;oacute;n est&amp;aacute;n dirigidas al guarda del partido y la expresi&amp;oacute;n del brazo. El &lt;a href=&quot;../patterns#binding-modes&quot;&gt;modo de encuadernaci&amp;oacute;n&lt;/a&gt; (mover, copiar o referenciar) depende del patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3c4d82fabad7ffdf2edb09b215e05fb61c4a456f" translate="yes" xml:space="preserve">
          <source>Variables in Rust are immutable by default, and require the &lt;code&gt;mut&lt;/code&gt; keyword to be made mutable.</source>
          <target state="translated">Las variables en Rust son inmutables por defecto y requieren que la palabra clave &lt;code&gt;mut&lt;/code&gt; sea ​​mutable.</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">Funciones variadas</target>
        </trans-unit>
        <trans-unit id="09181b83bd980777906a8422efadb22af2c263db" translate="yes" xml:space="preserve">
          <source>Variadic parameters can only be specified with &lt;a href=&quot;../items/external-blocks&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; function types with the &lt;code&gt;&quot;C&quot;&lt;/code&gt; or &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; calling convention.</source>
          <target state="translated">Los par&amp;aacute;metros variables s&amp;oacute;lo se pueden especificar con tipos de funci&amp;oacute;n &lt;a href=&quot;../items/external-blocks&quot;&gt; &lt;code&gt;extern&lt;/code&gt; os&lt;/a&gt; con la convenci&amp;oacute;n de llamada &lt;code&gt;&quot;C&quot;&lt;/code&gt; o &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c86f67a7083ae244751a61c00202e2c7bd69682" translate="yes" xml:space="preserve">
          <source>Variadic parameters have been used on a non-C ABI function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="8a62a01b810204975c3451044bb90c7a71ef1cde" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="translated">Varianza en &lt;code&gt;'a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34a3731e86c04bcba14d808de4b083ba9ec18ab8" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Varianza en &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13ea9443937d9e6015e5a5cffcafae425d987b1a" translate="yes" xml:space="preserve">
          <source>Variance is a property that generic types have with respect to their arguments. A generic type's &lt;em&gt;variance&lt;/em&gt; in a parameter is how the subtyping of the parameter affects the subtyping of the type.</source>
          <target state="translated">La varianza es una propiedad que tienen los tipos gen&amp;eacute;ricos con respecto a sus argumentos. La &lt;em&gt;varianza&lt;/em&gt; de un tipo gen&amp;eacute;rico en un par&amp;aacute;metro es c&amp;oacute;mo el subtipo del par&amp;aacute;metro afecta el subtipo del tipo.</target>
        </trans-unit>
        <trans-unit id="9c74b0f6448f867bdf1be672d84dbe75d3a10d26" translate="yes" xml:space="preserve">
          <source>Variance of types is automatically determined as follows</source>
          <target state="translated">La variación de los tipos se determina automáticamente de la siguiente manera</target>
        </trans-unit>
        <trans-unit id="59640c3e0b061bd7062f06a5f01816c4cfbcbe86" translate="yes" xml:space="preserve">
          <source>Variant visibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc3d368f8ad61e91648458829240a7efefcd2c1" translate="yes" xml:space="preserve">
          <source>Variants</source>
          <target state="translated">Variants</target>
        </trans-unit>
        <trans-unit id="1cec834cdc1b08e2f3ed59d65a8026d0864fc5b4" translate="yes" xml:space="preserve">
          <source>Variants (Non-exhaustive)</source>
          <target state="translated">Variantes (No exhaustivo)</target>
        </trans-unit>
        <trans-unit id="b3fbdc730db8eecbbf239ec3967489785ffcc13f" translate="yes" xml:space="preserve">
          <source>Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms:</source>
          <target state="translated">Varios atributos incorporados utilizan diferentes subconjuntos de la sintaxis de los meta-artículos para especificar sus entradas.Las siguientes reglas gramaticales muestran algunas formas de uso común:</target>
        </trans-unit>
        <trans-unit id="18d5bf7e0fee25c311080dec74d574b65c4b0764" translate="yes" xml:space="preserve">
          <source>Various separators</source>
          <target state="translated">Varios separadores</target>
        </trans-unit>
        <trans-unit id="d4251864c293c17029bfa74793ffa95136fcec6d" translate="yes" xml:space="preserve">
          <source>Various things in the standard library may implement one or more of the three, where appropriate.</source>
          <target state="translated">Varias cosas en la biblioteca estándar pueden implementar una o más de las tres,cuando sea apropiado.</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="1c47de6b16a76ec820d60a85839ecc1cbf5e4457" translate="yes" xml:space="preserve">
          <source>Vars::all</source>
          <target state="translated">Vars::all</target>
        </trans-unit>
        <trans-unit id="b398eaf22edd2ef7aed1c4f858c613d773d5dd59" translate="yes" xml:space="preserve">
          <source>Vars::any</source>
          <target state="translated">Vars::any</target>
        </trans-unit>
        <trans-unit id="80450fe90037366e6900e0207a00a0ff5399c353" translate="yes" xml:space="preserve">
          <source>Vars::borrow</source>
          <target state="translated">Vars::borrow</target>
        </trans-unit>
        <trans-unit id="21a23559330914e11672cfb421023160c25aceab" translate="yes" xml:space="preserve">
          <source>Vars::borrow_mut</source>
          <target state="translated">Vars::borrow_mut</target>
        </trans-unit>
        <trans-unit id="781b07302eb0ba1fcc3cf935ec319d0ab20b1f65" translate="yes" xml:space="preserve">
          <source>Vars::by_ref</source>
          <target state="translated">Vars::by_ref</target>
        </trans-unit>
        <trans-unit id="9951d905bdeb385924f734897456db259730b15b" translate="yes" xml:space="preserve">
          <source>Vars::chain</source>
          <target state="translated">Vars::chain</target>
        </trans-unit>
        <trans-unit id="b7b0b3926db3e290b2a0c4b07b1ac73606da0d40" translate="yes" xml:space="preserve">
          <source>Vars::cloned</source>
          <target state="translated">Vars::cloned</target>
        </trans-unit>
        <trans-unit id="af8d7407e3b763504a144307a7303f5603d6229f" translate="yes" xml:space="preserve">
          <source>Vars::cmp</source>
          <target state="translated">Vars::cmp</target>
        </trans-unit>
        <trans-unit id="5a55a34bc63ca6a0899a5379932cae28b637a085" translate="yes" xml:space="preserve">
          <source>Vars::collect</source>
          <target state="translated">Vars::collect</target>
        </trans-unit>
        <trans-unit id="4eb06a4620fc01558a8bd2f2bf2b0ca80dc89a4b" translate="yes" xml:space="preserve">
          <source>Vars::copied</source>
          <target state="translated">Vars::copied</target>
        </trans-unit>
        <trans-unit id="bfb7648d61e3607bf3caff921735ae88f75f92ef" translate="yes" xml:space="preserve">
          <source>Vars::count</source>
          <target state="translated">Vars::count</target>
        </trans-unit>
        <trans-unit id="f6b7790787f62ef8a6724b8647c199f3e9fc0e6f" translate="yes" xml:space="preserve">
          <source>Vars::cycle</source>
          <target state="translated">Vars::cycle</target>
        </trans-unit>
        <trans-unit id="c728f5f416f691b01f40cd87af7f9137219eb03f" translate="yes" xml:space="preserve">
          <source>Vars::enumerate</source>
          <target state="translated">Vars::enumerate</target>
        </trans-unit>
        <trans-unit id="0a270124e47b9e2828a920edca2e2e533038569f" translate="yes" xml:space="preserve">
          <source>Vars::eq</source>
          <target state="translated">Vars::eq</target>
        </trans-unit>
        <trans-unit id="7080a20dc333e44166a8558123ba98d85eb6ded3" translate="yes" xml:space="preserve">
          <source>Vars::filter</source>
          <target state="translated">Vars::filter</target>
        </trans-unit>
        <trans-unit id="d41dd539031344f9e7e7bb6171c556fc42ef1957" translate="yes" xml:space="preserve">
          <source>Vars::filter_map</source>
          <target state="translated">Vars::filter_map</target>
        </trans-unit>
        <trans-unit id="78b0b6d5abfd7026b83ef665a619f46c392d69ed" translate="yes" xml:space="preserve">
          <source>Vars::find</source>
          <target state="translated">Vars::find</target>
        </trans-unit>
        <trans-unit id="7044c163171ec6f76f077a2bec8324df3677eec1" translate="yes" xml:space="preserve">
          <source>Vars::find_map</source>
          <target state="translated">Vars::find_map</target>
        </trans-unit>
        <trans-unit id="3b73b80a39e593c77029fbb50e77a9c267cde8cd" translate="yes" xml:space="preserve">
          <source>Vars::flat_map</source>
          <target state="translated">Vars::flat_map</target>
        </trans-unit>
        <trans-unit id="804f30eccc2a282312bcb332187a328e639337a6" translate="yes" xml:space="preserve">
          <source>Vars::flatten</source>
          <target state="translated">Vars::flatten</target>
        </trans-unit>
        <trans-unit id="4534d320518c99c9f5ec34ac48943387ea6be6eb" translate="yes" xml:space="preserve">
          <source>Vars::fmt</source>
          <target state="translated">Vars::fmt</target>
        </trans-unit>
        <trans-unit id="dcbe8ef4d0dae4b0a34ef3131b548dcabe7f720d" translate="yes" xml:space="preserve">
          <source>Vars::fold</source>
          <target state="translated">Vars::fold</target>
        </trans-unit>
        <trans-unit id="c0ce61b83b4e9c664534b8dfbab835e7e489b655" translate="yes" xml:space="preserve">
          <source>Vars::for_each</source>
          <target state="translated">Vars::for_each</target>
        </trans-unit>
        <trans-unit id="5dd1e805808b1f032c733423cbf4ac8a4c5a6981" translate="yes" xml:space="preserve">
          <source>Vars::from</source>
          <target state="translated">Vars::from</target>
        </trans-unit>
        <trans-unit id="af8c15b94b4468f337a1725be34d5554460f0a04" translate="yes" xml:space="preserve">
          <source>Vars::fuse</source>
          <target state="translated">Vars::fuse</target>
        </trans-unit>
        <trans-unit id="51bb1a81fecead1d604391ae02d739a62889b8ac" translate="yes" xml:space="preserve">
          <source>Vars::ge</source>
          <target state="translated">Vars::ge</target>
        </trans-unit>
        <trans-unit id="5b570a759e39ddbf689c5b76c7875f777d223503" translate="yes" xml:space="preserve">
          <source>Vars::gt</source>
          <target state="translated">Vars::gt</target>
        </trans-unit>
        <trans-unit id="e0b5b9d9e5ab4d21c95b05a37ba730388417d6b6" translate="yes" xml:space="preserve">
          <source>Vars::inspect</source>
          <target state="translated">Vars::inspect</target>
        </trans-unit>
        <trans-unit id="b8b6b4992b9eef91d9d506454c1498ee57011e6a" translate="yes" xml:space="preserve">
          <source>Vars::into</source>
          <target state="translated">Vars::into</target>
        </trans-unit>
        <trans-unit id="c48afb05fd046801df4e6edbf9f840dd304b60e1" translate="yes" xml:space="preserve">
          <source>Vars::into_iter</source>
          <target state="translated">Vars::into_iter</target>
        </trans-unit>
        <trans-unit id="e0ccc72484b281423161007f22d8a9293e1ba907" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted</source>
          <target state="translated">Vars::is_sorted</target>
        </trans-unit>
        <trans-unit id="e191fd1f8c7ce00d777cb35f9c5c82504bbe7781" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by</source>
          <target state="translated">Vars::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="eb9ca2ba30c83815b850a09d3feb972dfdc158e2" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by_key</source>
          <target state="translated">Vars::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6141318cc3ccabd5ae05e4611a7c5181f6046637" translate="yes" xml:space="preserve">
          <source>Vars::last</source>
          <target state="translated">Vars::last</target>
        </trans-unit>
        <trans-unit id="eecce1750e26f1ae1d749a4bae2b92eade287d53" translate="yes" xml:space="preserve">
          <source>Vars::le</source>
          <target state="translated">Vars::le</target>
        </trans-unit>
        <trans-unit id="b0904ac784f88af599fae6febadea78be6bd22be" translate="yes" xml:space="preserve">
          <source>Vars::lt</source>
          <target state="translated">Vars::lt</target>
        </trans-unit>
        <trans-unit id="aed51bf24598897e8d0ea447d651f3de39248cdc" translate="yes" xml:space="preserve">
          <source>Vars::map</source>
          <target state="translated">Vars::map</target>
        </trans-unit>
        <trans-unit id="8ab4e4308d5f56473c748138761d5bb14402ca33" translate="yes" xml:space="preserve">
          <source>Vars::max</source>
          <target state="translated">Vars::max</target>
        </trans-unit>
        <trans-unit id="5fbff539f6d31b21ce7158f6c6c1edd461357314" translate="yes" xml:space="preserve">
          <source>Vars::max_by</source>
          <target state="translated">Vars::max_by</target>
        </trans-unit>
        <trans-unit id="09ad51f2df0437fa8ff5bd6b68362c0cd8c5cfca" translate="yes" xml:space="preserve">
          <source>Vars::max_by_key</source>
          <target state="translated">Vars::max_by_key</target>
        </trans-unit>
        <trans-unit id="0ea5634589a7714b3ce13a9b994859ddc43c1472" translate="yes" xml:space="preserve">
          <source>Vars::min</source>
          <target state="translated">Vars::min</target>
        </trans-unit>
        <trans-unit id="84ccbe5bb178770383b19523a56c94a1a328c579" translate="yes" xml:space="preserve">
          <source>Vars::min_by</source>
          <target state="translated">Vars::min_by</target>
        </trans-unit>
        <trans-unit id="ef0e80e93b2480afa1eef5654b1d44253416e329" translate="yes" xml:space="preserve">
          <source>Vars::min_by_key</source>
          <target state="translated">Vars::min_by_key</target>
        </trans-unit>
        <trans-unit id="ed5f11b0702d02069bbdec987cd8231701e2f83d" translate="yes" xml:space="preserve">
          <source>Vars::ne</source>
          <target state="translated">Vars::ne</target>
        </trans-unit>
        <trans-unit id="5507ff5e66b6d746ac06bacbd6adfad687952f9d" translate="yes" xml:space="preserve">
          <source>Vars::next</source>
          <target state="translated">Vars::next</target>
        </trans-unit>
        <trans-unit id="aec94ecfda5dc5e8fd928e072a549d3135f6ad84" translate="yes" xml:space="preserve">
          <source>Vars::nth</source>
          <target state="translated">Vars::nth</target>
        </trans-unit>
        <trans-unit id="7b9faff88b13bea2403bdb806528b1b03e775923" translate="yes" xml:space="preserve">
          <source>Vars::partial_cmp</source>
          <target state="translated">Vars::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2c2aef1b9bc3af83507c48a9bec747732d905de4" translate="yes" xml:space="preserve">
          <source>Vars::partition</source>
          <target state="translated">Vars::partition</target>
        </trans-unit>
        <trans-unit id="86900414ba1e745a10275dfdac62d2d9717049f6" translate="yes" xml:space="preserve">
          <source>Vars::peekable</source>
          <target state="translated">Vars::peekable</target>
        </trans-unit>
        <trans-unit id="20b949f960f581abec205874631185ffb7bb5fa1" translate="yes" xml:space="preserve">
          <source>Vars::position</source>
          <target state="translated">Vars::position</target>
        </trans-unit>
        <trans-unit id="8f8bd9d5815bdec99dfe7927fb90687bd92fab9b" translate="yes" xml:space="preserve">
          <source>Vars::product</source>
          <target state="translated">Vars::product</target>
        </trans-unit>
        <trans-unit id="9f0f47f9e4c4906312f7cde7ba18939a86f5931f" translate="yes" xml:space="preserve">
          <source>Vars::rev</source>
          <target state="translated">Vars::rev</target>
        </trans-unit>
        <trans-unit id="4a55d6ece90a2e102e6248bacf85b746657dbf67" translate="yes" xml:space="preserve">
          <source>Vars::rposition</source>
          <target state="translated">Vars::rposition</target>
        </trans-unit>
        <trans-unit id="ef63b4a7e167047c985114917f57fd0d737537fe" translate="yes" xml:space="preserve">
          <source>Vars::scan</source>
          <target state="translated">Vars::scan</target>
        </trans-unit>
        <trans-unit id="3551c9199efbcf81653d617970dabf0cd9ed3d99" translate="yes" xml:space="preserve">
          <source>Vars::size_hint</source>
          <target state="translated">Vars::size_hint</target>
        </trans-unit>
        <trans-unit id="7943d6f84fa998209693b43046c7975775eb51cd" translate="yes" xml:space="preserve">
          <source>Vars::skip</source>
          <target state="translated">Vars::skip</target>
        </trans-unit>
        <trans-unit id="2d1337e0ea678c9a71cefd99de6b48cd2e8b1203" translate="yes" xml:space="preserve">
          <source>Vars::skip_while</source>
          <target state="translated">Vars::skip_while</target>
        </trans-unit>
        <trans-unit id="9ad1eaaaf974f3fa2bff01f61e628ff1dd93b8e7" translate="yes" xml:space="preserve">
          <source>Vars::step_by</source>
          <target state="translated">Vars::step_by</target>
        </trans-unit>
        <trans-unit id="3cfd4ab54ebdd5fc54ce1f5c5cd82d3493150512" translate="yes" xml:space="preserve">
          <source>Vars::sum</source>
          <target state="translated">Vars::sum</target>
        </trans-unit>
        <trans-unit id="b11b3042c11657cd454ca8548f85ff8aeb32a4fd" translate="yes" xml:space="preserve">
          <source>Vars::take</source>
          <target state="translated">Vars::take</target>
        </trans-unit>
        <trans-unit id="70f8ea67196cc23888fa00b81267afd9a27d3c32" translate="yes" xml:space="preserve">
          <source>Vars::take_while</source>
          <target state="translated">Vars::take_while</target>
        </trans-unit>
        <trans-unit id="288b6c944d7368cdf54e313b28e14e5725efaa9b" translate="yes" xml:space="preserve">
          <source>Vars::try_fold</source>
          <target state="translated">Vars::try_fold</target>
        </trans-unit>
        <trans-unit id="cf043e48c60478e52e24f6c062f28fb96fba6f9d" translate="yes" xml:space="preserve">
          <source>Vars::try_for_each</source>
          <target state="translated">Vars::try_for_each</target>
        </trans-unit>
        <trans-unit id="b4fd24921ed57ce691083c1322eaf0856a89e518" translate="yes" xml:space="preserve">
          <source>Vars::try_from</source>
          <target state="translated">Vars::try_from</target>
        </trans-unit>
        <trans-unit id="1daadb045ef158df87f592275c11205ecf5af378" translate="yes" xml:space="preserve">
          <source>Vars::try_into</source>
          <target state="translated">Vars::try_into</target>
        </trans-unit>
        <trans-unit id="2e2cb28cd54a254643d5c8595fc8be18813e9b3a" translate="yes" xml:space="preserve">
          <source>Vars::type_id</source>
          <target state="translated">Vars::type_id</target>
        </trans-unit>
        <trans-unit id="6b38c485c26bfb440ab87bcbfba50961f6cb40d6" translate="yes" xml:space="preserve">
          <source>Vars::unzip</source>
          <target state="translated">Vars::unzip</target>
        </trans-unit>
        <trans-unit id="bbe99efeecd60ccb331cf47e045d9299f8d35e6e" translate="yes" xml:space="preserve">
          <source>Vars::zip</source>
          <target state="translated">Vars::zip</target>
        </trans-unit>
        <trans-unit id="b3dd49122e36d39473d927caf75a7a1efe1ad95f" translate="yes" xml:space="preserve">
          <source>VarsOs</source>
          <target state="translated">VarsOs</target>
        </trans-unit>
        <trans-unit id="0be42997f9c0fa87236d029096ab1f10b322e7b9" translate="yes" xml:space="preserve">
          <source>VarsOs::all</source>
          <target state="translated">VarsOs::all</target>
        </trans-unit>
        <trans-unit id="2f3479491bf53557e01f4e76c184381ed836098b" translate="yes" xml:space="preserve">
          <source>VarsOs::any</source>
          <target state="translated">VarsOs::any</target>
        </trans-unit>
        <trans-unit id="434053241a0ce77b4a57a19b617f9cd0e0d5e814" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow</source>
          <target state="translated">VarsOs::borrow</target>
        </trans-unit>
        <trans-unit id="2d141f266e89d234f18a990d5d607d1646f48aee" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow_mut</source>
          <target state="translated">VarsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="425cc86c692b838ef921c23811c4e3302d1bdfc4" translate="yes" xml:space="preserve">
          <source>VarsOs::by_ref</source>
          <target state="translated">VarsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="2ea472498ef341c6fb344b9d8ee413b4e6235be7" translate="yes" xml:space="preserve">
          <source>VarsOs::chain</source>
          <target state="translated">VarsOs::chain</target>
        </trans-unit>
        <trans-unit id="a8c6d8c806adad2da3dacb9238da96bf328655bd" translate="yes" xml:space="preserve">
          <source>VarsOs::cloned</source>
          <target state="translated">VarsOs::cloned</target>
        </trans-unit>
        <trans-unit id="fda36a1ed84216068b1296731249e671c956362c" translate="yes" xml:space="preserve">
          <source>VarsOs::cmp</source>
          <target state="translated">VarsOs::cmp</target>
        </trans-unit>
        <trans-unit id="2db35bab4983e6e4d87a02ad263efa15ddb43d0d" translate="yes" xml:space="preserve">
          <source>VarsOs::collect</source>
          <target state="translated">VarsOs::collect</target>
        </trans-unit>
        <trans-unit id="e1850e83c9e256bacb297e01d179d1197cc0db06" translate="yes" xml:space="preserve">
          <source>VarsOs::copied</source>
          <target state="translated">VarsOs::copied</target>
        </trans-unit>
        <trans-unit id="5c6630d2555a45d97d28a5536655aff9f9e9d3b8" translate="yes" xml:space="preserve">
          <source>VarsOs::count</source>
          <target state="translated">VarsOs::count</target>
        </trans-unit>
        <trans-unit id="f0ac502bdac4e93b09bdc50516564d5e56dc7727" translate="yes" xml:space="preserve">
          <source>VarsOs::cycle</source>
          <target state="translated">VarsOs::cycle</target>
        </trans-unit>
        <trans-unit id="a5e0728a5c9381105cc966f06f76ab6ed5f65903" translate="yes" xml:space="preserve">
          <source>VarsOs::enumerate</source>
          <target state="translated">VarsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="0d4efb3a8d96184d450211631b5b79b1a60ab789" translate="yes" xml:space="preserve">
          <source>VarsOs::eq</source>
          <target state="translated">VarsOs::eq</target>
        </trans-unit>
        <trans-unit id="31db361add8338260d55916657c39337f09b86d7" translate="yes" xml:space="preserve">
          <source>VarsOs::filter</source>
          <target state="translated">VarsOs::filter</target>
        </trans-unit>
        <trans-unit id="0d0a62d2dca8a37393e2c92243786aaf41313690" translate="yes" xml:space="preserve">
          <source>VarsOs::filter_map</source>
          <target state="translated">VarsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="ae7d5fede6f36ca665efd08ae94669cbd14b7cc6" translate="yes" xml:space="preserve">
          <source>VarsOs::find</source>
          <target state="translated">VarsOs::find</target>
        </trans-unit>
        <trans-unit id="a97602f19f448bb335f850af073a9ce84cd5d88f" translate="yes" xml:space="preserve">
          <source>VarsOs::find_map</source>
          <target state="translated">VarsOs::find_map</target>
        </trans-unit>
        <trans-unit id="3678c5ef82f2cb08bc3b287c092316a2ada00a18" translate="yes" xml:space="preserve">
          <source>VarsOs::flat_map</source>
          <target state="translated">VarsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="e8a42aa17639bc96d10468e86951b455866c4904" translate="yes" xml:space="preserve">
          <source>VarsOs::flatten</source>
          <target state="translated">VarsOs::flatten</target>
        </trans-unit>
        <trans-unit id="46320ba9ecbf055cb2e56af08cec6e628a336f92" translate="yes" xml:space="preserve">
          <source>VarsOs::fmt</source>
          <target state="translated">VarsOs::fmt</target>
        </trans-unit>
        <trans-unit id="7bcbf2e75da1a46894beb596faa2a485d58f6a2d" translate="yes" xml:space="preserve">
          <source>VarsOs::fold</source>
          <target state="translated">VarsOs::fold</target>
        </trans-unit>
        <trans-unit id="51b69162489f5329a52d08395d177be1d60cb6a5" translate="yes" xml:space="preserve">
          <source>VarsOs::for_each</source>
          <target state="translated">VarsOs::for_each</target>
        </trans-unit>
        <trans-unit id="e06ff647273899d3fd4ea62e139dbf757cf3d8cc" translate="yes" xml:space="preserve">
          <source>VarsOs::from</source>
          <target state="translated">VarsOs::from</target>
        </trans-unit>
        <trans-unit id="0245bbf420434587e8ec6bdf35d9cf62a6cde011" translate="yes" xml:space="preserve">
          <source>VarsOs::fuse</source>
          <target state="translated">VarsOs::fuse</target>
        </trans-unit>
        <trans-unit id="479913c8896a1c5102d2a5ea1234f740bfde2328" translate="yes" xml:space="preserve">
          <source>VarsOs::ge</source>
          <target state="translated">VarsOs::ge</target>
        </trans-unit>
        <trans-unit id="17feba1de0fe9c2331df5c53c185c7617b4b8cc1" translate="yes" xml:space="preserve">
          <source>VarsOs::gt</source>
          <target state="translated">VarsOs::gt</target>
        </trans-unit>
        <trans-unit id="3033c2aeecf938c398013c5ab0852cd122a7d6b0" translate="yes" xml:space="preserve">
          <source>VarsOs::inspect</source>
          <target state="translated">VarsOs::inspect</target>
        </trans-unit>
        <trans-unit id="3f0b3d392367dab2dc143ca178da7b4d778bbd17" translate="yes" xml:space="preserve">
          <source>VarsOs::into</source>
          <target state="translated">VarsOs::into</target>
        </trans-unit>
        <trans-unit id="16fa54e40b1321bab910ef3ac287342748aea056" translate="yes" xml:space="preserve">
          <source>VarsOs::into_iter</source>
          <target state="translated">VarsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="5c63504ce660906345551dba943ce8d045612e95" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted</source>
          <target state="translated">VarsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="0fdd66d1bfafd9226a154278db222c3aee97c735" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by</source>
          <target state="translated">VarsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="204163a740d898b80542e502e7da9a7661337b36" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by_key</source>
          <target state="translated">VarsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="ae35eac698343e1ee4eeec512aed1c16a136d0c7" translate="yes" xml:space="preserve">
          <source>VarsOs::last</source>
          <target state="translated">VarsOs::last</target>
        </trans-unit>
        <trans-unit id="c01f90cf460a2003e266fcb0b34415121c12b736" translate="yes" xml:space="preserve">
          <source>VarsOs::le</source>
          <target state="translated">VarsOs::le</target>
        </trans-unit>
        <trans-unit id="c0cd86a67a36a78ad1451aca611b8fd991760e20" translate="yes" xml:space="preserve">
          <source>VarsOs::lt</source>
          <target state="translated">VarsOs::lt</target>
        </trans-unit>
        <trans-unit id="1cefab93b3f7c14142541eedb899ab5e71be9fc4" translate="yes" xml:space="preserve">
          <source>VarsOs::map</source>
          <target state="translated">VarsOs::map</target>
        </trans-unit>
        <trans-unit id="e6a8c9754fd49b2d51cbf24ecf6d94304e8e64c3" translate="yes" xml:space="preserve">
          <source>VarsOs::max</source>
          <target state="translated">VarsOs::max</target>
        </trans-unit>
        <trans-unit id="1f1f50d119da0ed96c40d44ea09ef96812375781" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by</source>
          <target state="translated">VarsOs::max_by</target>
        </trans-unit>
        <trans-unit id="0f2e6793ee02c5031cf6cc652fab9884db10bbdb" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by_key</source>
          <target state="translated">VarsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="af3d6a04943a8cf3ad8a6978c4e20520bbd7810c" translate="yes" xml:space="preserve">
          <source>VarsOs::min</source>
          <target state="translated">VarsOs::min</target>
        </trans-unit>
        <trans-unit id="65325562c65c7a37d9553910d80a4c50713493e5" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by</source>
          <target state="translated">VarsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce454f9015d8cd8601694fb53b1aac058cf4ec7c" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by_key</source>
          <target state="translated">VarsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="1c7e1099c4b87dd8e83e87ef896a8fe06530c255" translate="yes" xml:space="preserve">
          <source>VarsOs::ne</source>
          <target state="translated">VarsOs::ne</target>
        </trans-unit>
        <trans-unit id="abe200e7a70bbf42fbb261f3d6ecb1a850953161" translate="yes" xml:space="preserve">
          <source>VarsOs::next</source>
          <target state="translated">VarsOs::next</target>
        </trans-unit>
        <trans-unit id="753f8e880e8ece081c8080be088d05ec0d200f80" translate="yes" xml:space="preserve">
          <source>VarsOs::nth</source>
          <target state="translated">VarsOs::nth</target>
        </trans-unit>
        <trans-unit id="b6af18bf99508b4a2d5aac1fbdfad4b5780a6f74" translate="yes" xml:space="preserve">
          <source>VarsOs::partial_cmp</source>
          <target state="translated">VarsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba0322e8a281d2965f09dafdfe9b78ec1f84e172" translate="yes" xml:space="preserve">
          <source>VarsOs::partition</source>
          <target state="translated">VarsOs::partition</target>
        </trans-unit>
        <trans-unit id="91938a0453fc3e7b7813e5df0009b7580ef490d3" translate="yes" xml:space="preserve">
          <source>VarsOs::peekable</source>
          <target state="translated">VarsOs::peekable</target>
        </trans-unit>
        <trans-unit id="7a37b0e06b2930dc5a294f234caa4a16804177d0" translate="yes" xml:space="preserve">
          <source>VarsOs::position</source>
          <target state="translated">VarsOs::position</target>
        </trans-unit>
        <trans-unit id="4f098ada18205fbc46f5cd22be9968ee3d7b0363" translate="yes" xml:space="preserve">
          <source>VarsOs::product</source>
          <target state="translated">VarsOs::product</target>
        </trans-unit>
        <trans-unit id="6bf84c68f9daffbf302bd074f0e8be5a6ea7823d" translate="yes" xml:space="preserve">
          <source>VarsOs::rev</source>
          <target state="translated">VarsOs::rev</target>
        </trans-unit>
        <trans-unit id="1c60d42a9413b8a7c101dc83c2565f5d37b81a2a" translate="yes" xml:space="preserve">
          <source>VarsOs::rposition</source>
          <target state="translated">VarsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f65790ae1d5619919415f11aef0fe2aee47448a6" translate="yes" xml:space="preserve">
          <source>VarsOs::scan</source>
          <target state="translated">VarsOs::scan</target>
        </trans-unit>
        <trans-unit id="cb8748c599d4e59ff120199769de64e5786ad929" translate="yes" xml:space="preserve">
          <source>VarsOs::size_hint</source>
          <target state="translated">VarsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="3ea59b4b1aae9dc7c132d58be49e094fc8eaa95f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip</source>
          <target state="translated">VarsOs::skip</target>
        </trans-unit>
        <trans-unit id="02c1e6608b48c61896af2016b5b52d75d023957f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip_while</source>
          <target state="translated">VarsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="a0d6c6ad525cb20f675d004819c2121e056f42c8" translate="yes" xml:space="preserve">
          <source>VarsOs::step_by</source>
          <target state="translated">VarsOs::step_by</target>
        </trans-unit>
        <trans-unit id="6846222d088cefb1075c2f24c4eadbd7aed705eb" translate="yes" xml:space="preserve">
          <source>VarsOs::sum</source>
          <target state="translated">VarsOs::sum</target>
        </trans-unit>
        <trans-unit id="91c3203375fe48ab0d3fa32901ee5de67c77a411" translate="yes" xml:space="preserve">
          <source>VarsOs::take</source>
          <target state="translated">VarsOs::take</target>
        </trans-unit>
        <trans-unit id="144ba83f71bf339d2fc7ce6106d27d858be059f1" translate="yes" xml:space="preserve">
          <source>VarsOs::take_while</source>
          <target state="translated">VarsOs::take_while</target>
        </trans-unit>
        <trans-unit id="330e5de6bdd0923300ee2e19673f82661fe3b5aa" translate="yes" xml:space="preserve">
          <source>VarsOs::try_fold</source>
          <target state="translated">VarsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="7f9b1fb25f2d8dc898d57dd0ad57aa6074d0db25" translate="yes" xml:space="preserve">
          <source>VarsOs::try_for_each</source>
          <target state="translated">VarsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="0371b8d74af891c05681249ef7f32d83f6e8d3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::try_from</source>
          <target state="translated">VarsOs::try_from</target>
        </trans-unit>
        <trans-unit id="45aa3acec5ebcabeaf089da80e453c0f5f80cd2d" translate="yes" xml:space="preserve">
          <source>VarsOs::try_into</source>
          <target state="translated">VarsOs::try_into</target>
        </trans-unit>
        <trans-unit id="24d5d9ef2bba5983d72962681554163d3cc0d7ea" translate="yes" xml:space="preserve">
          <source>VarsOs::type_id</source>
          <target state="translated">VarsOs::type_id</target>
        </trans-unit>
        <trans-unit id="3e592311e132f7aa730baaf56aa5dd0ae220e3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::unzip</source>
          <target state="translated">VarsOs::unzip</target>
        </trans-unit>
        <trans-unit id="e4769bb4e270bd8e779d33f3cae641957c2527b8" translate="yes" xml:space="preserve">
          <source>VarsOs::zip</source>
          <target state="translated">VarsOs::zip</target>
        </trans-unit>
        <trans-unit id="3e8f48ebd55451a20501b45af4a4265976d600b6" translate="yes" xml:space="preserve">
          <source>Vec</source>
          <target state="translated">Vec</target>
        </trans-unit>
        <trans-unit id="9e8ec9d213a0da31ccaaba571b14789e42b08935" translate="yes" xml:space="preserve">
          <source>Vec::align_to</source>
          <target state="translated">Vec::align_to</target>
        </trans-unit>
        <trans-unit id="a6107ed66afb53f802511a5a643ee8656e497b0a" translate="yes" xml:space="preserve">
          <source>Vec::align_to_mut</source>
          <target state="translated">Vec::align_to_mut</target>
        </trans-unit>
        <trans-unit id="f61abeec7dd01f8c47bf83db4b4d0456a9af5e0b" translate="yes" xml:space="preserve">
          <source>Vec::append</source>
          <target state="translated">Vec::append</target>
        </trans-unit>
        <trans-unit id="966721890fa8492f6b4046bd9708da68c72adc73" translate="yes" xml:space="preserve">
          <source>Vec::as_mut</source>
          <target state="translated">Vec::as_mut</target>
        </trans-unit>
        <trans-unit id="831194353af948439212b65f5180ee63686be5ff" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_ptr</source>
          <target state="translated">Vec::as_mut_ptr</target>
        </trans-unit>
        <trans-unit id="2cd229f1c1c1c67e55b523142a4b5506c79ab5e4" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_slice</source>
          <target state="translated">Vec::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="c1e6da016e5f4ce35006127886b4b180eede68b8" translate="yes" xml:space="preserve">
          <source>Vec::as_ptr</source>
          <target state="translated">Vec::as_ptr</target>
        </trans-unit>
        <trans-unit id="8b5099d8e9c3e715862b2b38f181235c7cc24477" translate="yes" xml:space="preserve">
          <source>Vec::as_ref</source>
          <target state="translated">Vec::as_ref</target>
        </trans-unit>
        <trans-unit id="e50619a5c819f0a35e08edd227565f793562e4c8" translate="yes" xml:space="preserve">
          <source>Vec::as_slice</source>
          <target state="translated">Vec::as_slice</target>
        </trans-unit>
        <trans-unit id="0fd5dd3c29cf93dd4e97ef65f08a9644b11adf66" translate="yes" xml:space="preserve">
          <source>Vec::binary_search</source>
          <target state="translated">Vec::binary_search</target>
        </trans-unit>
        <trans-unit id="b52fc5259d9a5986689a231729ba2250dccdf822" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by</source>
          <target state="translated">Vec::binary_search_by</target>
        </trans-unit>
        <trans-unit id="c25875b591cdd49de2d27d47ee6d7ac1e21d9162" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by_key</source>
          <target state="translated">Vec::binary_search_by_key</target>
        </trans-unit>
        <trans-unit id="85bd126983a102e0968ff3a77e6cc098a02d6d2b" translate="yes" xml:space="preserve">
          <source>Vec::borrow</source>
          <target state="translated">Vec::borrow</target>
        </trans-unit>
        <trans-unit id="ce949f50884f71dd9c3bd065b3e9f2fac3e1b9b1" translate="yes" xml:space="preserve">
          <source>Vec::borrow_mut</source>
          <target state="translated">Vec::borrow_mut</target>
        </trans-unit>
        <trans-unit id="adf16c9ee55ed12543d9f09958b2da182d391549" translate="yes" xml:space="preserve">
          <source>Vec::by_ref</source>
          <target state="translated">Vec::by_ref</target>
        </trans-unit>
        <trans-unit id="879e3baf25a9301dece592c8e2fe831ab282b68c" translate="yes" xml:space="preserve">
          <source>Vec::capacity</source>
          <target state="translated">Vec::capacity</target>
        </trans-unit>
        <trans-unit id="0008361e288cf11981ce829d1646ffd8fcfd353d" translate="yes" xml:space="preserve">
          <source>Vec::chunks</source>
          <target state="translated">Vec::chunks</target>
        </trans-unit>
        <trans-unit id="753b8583ee481b3421bba7d981070ec72378a929" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact</source>
          <target state="translated">Vec::chunks_exact</target>
        </trans-unit>
        <trans-unit id="c16f1e8e4bdb33b2b62eb139dbdd695cce8cd9cb" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact_mut</source>
          <target state="translated">Vec::chunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="5129df9df37eeb41ed7c2d7d9a8c46bfb809e00b" translate="yes" xml:space="preserve">
          <source>Vec::chunks_mut</source>
          <target state="translated">Vec::chunks_mut</target>
        </trans-unit>
        <trans-unit id="b0c0c66afeddeab3613458326ddff56179dee6c6" translate="yes" xml:space="preserve">
          <source>Vec::clamp</source>
          <target state="translated">Vec::clamp</target>
        </trans-unit>
        <trans-unit id="2c2fbd7321fb15ce32f39380f1451dd1d8285167" translate="yes" xml:space="preserve">
          <source>Vec::clear</source>
          <target state="translated">Vec::clear</target>
        </trans-unit>
        <trans-unit id="f74617c56b1b4cb0ac739e41c8d386b187a932a0" translate="yes" xml:space="preserve">
          <source>Vec::clone</source>
          <target state="translated">Vec::clone</target>
        </trans-unit>
        <trans-unit id="7d2eba94d2d4e553221edef828d32477a74ec086" translate="yes" xml:space="preserve">
          <source>Vec::clone_from</source>
          <target state="translated">Vec::clone_from</target>
        </trans-unit>
        <trans-unit id="d765a16b06a09ff23e51adef46f6c11da8454339" translate="yes" xml:space="preserve">
          <source>Vec::clone_from_slice</source>
          <target state="translated">Vec::clone_from_slice</target>
        </trans-unit>
        <trans-unit id="33b8cb435611a78c3d465aaa7784c2b37cbb74e7" translate="yes" xml:space="preserve">
          <source>Vec::clone_into</source>
          <target state="translated">Vec::clone_into</target>
        </trans-unit>
        <trans-unit id="54c91e49e772a616e17900001275475155f0db86" translate="yes" xml:space="preserve">
          <source>Vec::cmp</source>
          <target state="translated">Vec::cmp</target>
        </trans-unit>
        <trans-unit id="0a3297559d1b2d0f5e9d86fb8e4f2702a52aed73" translate="yes" xml:space="preserve">
          <source>Vec::contains</source>
          <target state="translated">Vec::contains</target>
        </trans-unit>
        <trans-unit id="15b499228e83cdfe5d9bacf8f2717eb38b48f38b" translate="yes" xml:space="preserve">
          <source>Vec::copy_from_slice</source>
          <target state="translated">Vec::copy_from_slice</target>
        </trans-unit>
        <trans-unit id="b8ba6b02b6ab7d9e4a58c6ff8c4f8ed29c394009" translate="yes" xml:space="preserve">
          <source>Vec::copy_within</source>
          <target state="translated">Vec::copy_within</target>
        </trans-unit>
        <trans-unit id="789846c5e092b1b0a4c096dc5aa2920af554cadf" translate="yes" xml:space="preserve">
          <source>Vec::dedup</source>
          <target state="translated">Vec::dedup</target>
        </trans-unit>
        <trans-unit id="ef8409a58825c28ce8665f515341da99406dc45e" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by</source>
          <target state="translated">Vec::dedup_by</target>
        </trans-unit>
        <trans-unit id="363d4ee344588ea07c6bc5cfb25580f99e4e6fc4" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by_key</source>
          <target state="translated">Vec::dedup_by_key</target>
        </trans-unit>
        <trans-unit id="1a3c24e46d01efcb53b2e47b9f9fe05604eec885" translate="yes" xml:space="preserve">
          <source>Vec::default</source>
          <target state="translated">Vec::default</target>
        </trans-unit>
        <trans-unit id="b1a2319f3d6321033c9832ada871bb0364c41d6d" translate="yes" xml:space="preserve">
          <source>Vec::deref</source>
          <target state="translated">Vec::deref</target>
        </trans-unit>
        <trans-unit id="700ab6732dec0f913d9f30592a8a083e6275f0e9" translate="yes" xml:space="preserve">
          <source>Vec::deref_mut</source>
          <target state="translated">Vec::deref_mut</target>
        </trans-unit>
        <trans-unit id="5b692065705c3002050f3bc84600cd18eab70011" translate="yes" xml:space="preserve">
          <source>Vec::drain</source>
          <target state="translated">Vec::drain</target>
        </trans-unit>
        <trans-unit id="b56f02a07b5d1e06767ba9089e5a26237d2b6e96" translate="yes" xml:space="preserve">
          <source>Vec::drain_filter</source>
          <target state="translated">Vec::drain_filter</target>
        </trans-unit>
        <trans-unit id="1590e7c585be22084bde77caac361ebaa4d26167" translate="yes" xml:space="preserve">
          <source>Vec::drop</source>
          <target state="translated">Vec::drop</target>
        </trans-unit>
        <trans-unit id="c4e9c1a11aab0c3fbaa646a64a22f3069178f1e1" translate="yes" xml:space="preserve">
          <source>Vec::ends_with</source>
          <target state="translated">Vec::ends_with</target>
        </trans-unit>
        <trans-unit id="6460efc15d9228e5937dc4d9b4bb45990d32a27e" translate="yes" xml:space="preserve">
          <source>Vec::eq</source>
          <target state="translated">Vec::eq</target>
        </trans-unit>
        <trans-unit id="8e07e8d35672a19e43e8097f16c00d816c5cbe97" translate="yes" xml:space="preserve">
          <source>Vec::eq_ignore_ascii_case</source>
          <target state="translated">Vec::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="e46b7aa4e045855309d716fccf00cabd75a21e77" translate="yes" xml:space="preserve">
          <source>Vec::extend</source>
          <target state="translated">Vec::extend</target>
        </trans-unit>
        <trans-unit id="bb82f4df3cb27f5fbf87e6541ca1f465f414d3a5" translate="yes" xml:space="preserve">
          <source>Vec::extend_from_slice</source>
          <target state="translated">Vec::extend_from_slice</target>
        </trans-unit>
        <trans-unit id="87732cce3e95948f8d258db19ab24839895b0f76" translate="yes" xml:space="preserve">
          <source>Vec::first</source>
          <target state="translated">Vec::first</target>
        </trans-unit>
        <trans-unit id="fd582f0cbcb6e9f15ed28c1811608a7720bbbf52" translate="yes" xml:space="preserve">
          <source>Vec::first_mut</source>
          <target state="translated">Vec::first_mut</target>
        </trans-unit>
        <trans-unit id="cea112245a192a2715a4ac0d0d4ca6f9f0c88d11" translate="yes" xml:space="preserve">
          <source>Vec::flush</source>
          <target state="translated">Vec::flush</target>
        </trans-unit>
        <trans-unit id="74c0bff699639364b714e18c5e924ebe36d7bbb8" translate="yes" xml:space="preserve">
          <source>Vec::fmt</source>
          <target state="translated">Vec::fmt</target>
        </trans-unit>
        <trans-unit id="3b03e0120686cad397d6fe329718262a73208e9a" translate="yes" xml:space="preserve">
          <source>Vec::from</source>
          <target state="translated">Vec::from</target>
        </trans-unit>
        <trans-unit id="d2409bb7c2f488110f44be1023fc83c93200bfb1" translate="yes" xml:space="preserve">
          <source>Vec::from_iter</source>
          <target state="translated">Vec::from_iter</target>
        </trans-unit>
        <trans-unit id="e5b23b921224c968a51d83bca668d1740812f940" translate="yes" xml:space="preserve">
          <source>Vec::from_raw_parts</source>
          <target state="translated">Vec::from_raw_parts</target>
        </trans-unit>
        <trans-unit id="1b86c87d45b678c05eaedfa482e8e125c09283aa" translate="yes" xml:space="preserve">
          <source>Vec::ge</source>
          <target state="translated">Vec::ge</target>
        </trans-unit>
        <trans-unit id="a36985c63a8174e8d6e9d553daa519abe7ef73a3" translate="yes" xml:space="preserve">
          <source>Vec::get</source>
          <target state="translated">Vec::get</target>
        </trans-unit>
        <trans-unit id="55451d4c9012f0e9dc2705a9a20313c583cbad02" translate="yes" xml:space="preserve">
          <source>Vec::get_mut</source>
          <target state="translated">Vec::get_mut</target>
        </trans-unit>
        <trans-unit id="fbd1dbfc28f1dbf35081eb8a3b624e1ddb17a7d4" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked</source>
          <target state="translated">Vec::get_unchecked</target>
        </trans-unit>
        <trans-unit id="17aa782943cb8ba6f59f4076d63241b08687fe04" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked_mut</source>
          <target state="translated">Vec::get_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="12e2684fc2a72b4cdaf5511139faebcd74106115" translate="yes" xml:space="preserve">
          <source>Vec::gt</source>
          <target state="translated">Vec::gt</target>
        </trans-unit>
        <trans-unit id="3214576db0b2f915d4813a780951e762d0453108" translate="yes" xml:space="preserve">
          <source>Vec::hash</source>
          <target state="translated">Vec::hash</target>
        </trans-unit>
        <trans-unit id="cbad63e4de555a52c1156aacfa7acaa37d288f2d" translate="yes" xml:space="preserve">
          <source>Vec::hash_slice</source>
          <target state="translated">Vec::hash_slice</target>
        </trans-unit>
        <trans-unit id="817acc1f56c6b7266c14b400f36bd6915fc69aa9" translate="yes" xml:space="preserve">
          <source>Vec::index</source>
          <target state="translated">Vec::index</target>
        </trans-unit>
        <trans-unit id="255317cd139deae7b3798accef614b86d687af60" translate="yes" xml:space="preserve">
          <source>Vec::index_mut</source>
          <target state="translated">Vec::index_mut</target>
        </trans-unit>
        <trans-unit id="dae9879e89996749967d788919fd3919726095e5" translate="yes" xml:space="preserve">
          <source>Vec::insert</source>
          <target state="translated">Vec::insert</target>
        </trans-unit>
        <trans-unit id="4607993cbee4135669d2825495742a160937c51e" translate="yes" xml:space="preserve">
          <source>Vec::into</source>
          <target state="translated">Vec::into</target>
        </trans-unit>
        <trans-unit id="349c4bbf0cf7617a82524fff4ab6dd6dc12191ae" translate="yes" xml:space="preserve">
          <source>Vec::into_boxed_slice</source>
          <target state="translated">Vec::into_boxed_slice</target>
        </trans-unit>
        <trans-unit id="a2683d7c8a491dd1d14d82cbf394796000e6a7fa" translate="yes" xml:space="preserve">
          <source>Vec::into_iter</source>
          <target state="translated">Vec::into_iter</target>
        </trans-unit>
        <trans-unit id="0617d70073dd3ee36b70acc3469082e13a466d03" translate="yes" xml:space="preserve">
          <source>Vec::is_ascii</source>
          <target state="translated">Vec::is_ascii</target>
        </trans-unit>
        <trans-unit id="03169a81c036f8a9e76093b58242f30ae578d6e1" translate="yes" xml:space="preserve">
          <source>Vec::is_empty</source>
          <target state="translated">Vec::is_empty</target>
        </trans-unit>
        <trans-unit id="61e088912bf7c1fb5b0f0a806c372825ce419a0f" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted</source>
          <target state="translated">Vec::is_sorted</target>
        </trans-unit>
        <trans-unit id="2f71d97de0d886a25068ec904913d5f995b9ec67" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by</source>
          <target state="translated">Vec::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="13b69e903c4a68fcfe01f0c6f71a43d7cffcb8d2" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by_key</source>
          <target state="translated">Vec::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="67f810a4a6906d879a0e5bcdbd0629cdca0805fc" translate="yes" xml:space="preserve">
          <source>Vec::iter</source>
          <target state="translated">Vec::iter</target>
        </trans-unit>
        <trans-unit id="de14eea28b8af3ebd1fa7277134614ec35bede5f" translate="yes" xml:space="preserve">
          <source>Vec::iter_mut</source>
          <target state="translated">Vec::iter_mut</target>
        </trans-unit>
        <trans-unit id="89cb435951d0739bd80a43fd6eff389c96ea9137" translate="yes" xml:space="preserve">
          <source>Vec::last</source>
          <target state="translated">Vec::last</target>
        </trans-unit>
        <trans-unit id="8ec2cd17a9007516bf67a64facc2086a511ddabc" translate="yes" xml:space="preserve">
          <source>Vec::last_mut</source>
          <target state="translated">Vec::last_mut</target>
        </trans-unit>
        <trans-unit id="fbceeb72cec6860fa83702dbf07c61c0fba92768" translate="yes" xml:space="preserve">
          <source>Vec::le</source>
          <target state="translated">Vec::le</target>
        </trans-unit>
        <trans-unit id="525552cdf64c17bf1df49d77d5e10db05c4a1e65" translate="yes" xml:space="preserve">
          <source>Vec::len</source>
          <target state="translated">Vec::len</target>
        </trans-unit>
        <trans-unit id="1987ee0ae7df89f62926afad448cc8dcba8deb75" translate="yes" xml:space="preserve">
          <source>Vec::lt</source>
          <target state="translated">Vec::lt</target>
        </trans-unit>
        <trans-unit id="d73c1ce0cf0d3ba3f02694929282ef1ce4003f43" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_lowercase</source>
          <target state="translated">Vec::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="c984649eda1457369a83cadb8cb7cced71d85e8a" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_uppercase</source>
          <target state="translated">Vec::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="a14d3f9cce464f0a15bfb1ccdba70544cd9996dc" translate="yes" xml:space="preserve">
          <source>Vec::max</source>
          <target state="translated">Vec::max</target>
        </trans-unit>
        <trans-unit id="b7e2ddaad5a1e72a47531993b322493826992f01" translate="yes" xml:space="preserve">
          <source>Vec::min</source>
          <target state="translated">Vec::min</target>
        </trans-unit>
        <trans-unit id="27ac869c9c4d65022ccbe3db59b454048dac5d01" translate="yes" xml:space="preserve">
          <source>Vec::ne</source>
          <target state="translated">Vec::ne</target>
        </trans-unit>
        <trans-unit id="6fd848867337ba44b23b17c9fe00c94d829ea233" translate="yes" xml:space="preserve">
          <source>Vec::new</source>
          <target state="translated">Vec::new</target>
        </trans-unit>
        <trans-unit id="dcf8d5a328aa406810dabf32cd5ae01b3697decb" translate="yes" xml:space="preserve">
          <source>Vec::partial_cmp</source>
          <target state="translated">Vec::partial_cmp</target>
        </trans-unit>
        <trans-unit id="9694e7862ef0e60d886fd728679d90a8ee9470af" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index</source>
          <target state="translated">Vec::partition_at_index</target>
        </trans-unit>
        <trans-unit id="0bf6ca8cb659d720aa701bffc2851bc20dd39575" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by</source>
          <target state="translated">Vec::partition_at_index_by</target>
        </trans-unit>
        <trans-unit id="e14cd1ff21e7d949dfbecf45a57afb30d74ae935" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by_key</source>
          <target state="translated">Vec::partition_at_index_by_key</target>
        </trans-unit>
        <trans-unit id="a3bcf68a32491f6ce459bed1b83a0728f8d3facb" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup</source>
          <target state="translated">Vec::partition_dedup</target>
        </trans-unit>
        <trans-unit id="b33b907d031cab1a9f82dfabed52b3ec36a0bec7" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by</source>
          <target state="translated">Vec::partition_dedup_by</target>
        </trans-unit>
        <trans-unit id="e9042527cd9f8f7b837ac9979689f102fa5b9413" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by_key</source>
          <target state="translated">Vec::partition_dedup_by_key</target>
        </trans-unit>
        <trans-unit id="bb66cba5fa2c2be8852cc1be9f1f0442c400f3c1" translate="yes" xml:space="preserve">
          <source>Vec::pop</source>
          <target state="translated">Vec::pop</target>
        </trans-unit>
        <trans-unit id="015702c3beb31216ec8635f66c58b2dd6c7ce7d3" translate="yes" xml:space="preserve">
          <source>Vec::push</source>
          <target state="translated">Vec::push</target>
        </trans-unit>
        <trans-unit id="2a4ecb67c06267aff12807a92f7519558492cac3" translate="yes" xml:space="preserve">
          <source>Vec::rchunks</source>
          <target state="translated">Vec::rchunks</target>
        </trans-unit>
        <trans-unit id="2190a180c9e13d2c97a99729fb1cab9822f2b367" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact</source>
          <target state="translated">Vec::rchunks_exact</target>
        </trans-unit>
        <trans-unit id="8817d4c686ebb9e3df7649dc1ef10bbfc99e5a0f" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact_mut</source>
          <target state="translated">Vec::rchunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="d8b31989d0600b79568eabfbd02443e705c374f4" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_mut</source>
          <target state="translated">Vec::rchunks_mut</target>
        </trans-unit>
        <trans-unit id="845831747d56f3eeb00bb35e02809974b407e592" translate="yes" xml:space="preserve">
          <source>Vec::remove</source>
          <target state="translated">Vec::remove</target>
        </trans-unit>
        <trans-unit id="f2019e8c59ea1c039539318392c79102cc50f496" translate="yes" xml:space="preserve">
          <source>Vec::remove_item</source>
          <target state="translated">Vec::remove_item</target>
        </trans-unit>
        <trans-unit id="2a5af4f0d9906283d3505112b8edea1ff6aa8327" translate="yes" xml:space="preserve">
          <source>Vec::repeat</source>
          <target state="translated">Vec::repeat</target>
        </trans-unit>
        <trans-unit id="4030131e8b0f427754fca9b6fc2438b48ee132aa" translate="yes" xml:space="preserve">
          <source>Vec::reserve</source>
          <target state="translated">Vec::reserve</target>
        </trans-unit>
        <trans-unit id="c585b5b6b44dd8ead3846dfe6ff450a1d78b7ca4" translate="yes" xml:space="preserve">
          <source>Vec::reserve_exact</source>
          <target state="translated">Vec::reserve_exact</target>
        </trans-unit>
        <trans-unit id="abcfd065a68ab661075eb65973b1c2983f76906b" translate="yes" xml:space="preserve">
          <source>Vec::resize</source>
          <target state="translated">Vec::resize</target>
        </trans-unit>
        <trans-unit id="f9f7275b35ba8425eb32e3d8e98e0b77a08d75b9" translate="yes" xml:space="preserve">
          <source>Vec::resize_default</source>
          <target state="translated">Vec::resize_default</target>
        </trans-unit>
        <trans-unit id="9f1a1a7d355751c7299454f0938fedf8e60dd549" translate="yes" xml:space="preserve">
          <source>Vec::resize_with</source>
          <target state="translated">Vec::resize_with</target>
        </trans-unit>
        <trans-unit id="fd564ef5b54702a40658f77d501d340f02796c3b" translate="yes" xml:space="preserve">
          <source>Vec::retain</source>
          <target state="translated">Vec::retain</target>
        </trans-unit>
        <trans-unit id="020a2b7b3ef0fc23c178b5a1d57cf3220ce5e5ff" translate="yes" xml:space="preserve">
          <source>Vec::reverse</source>
          <target state="translated">Vec::reverse</target>
        </trans-unit>
        <trans-unit id="b4c1d9424701ec16b3d33474bf2a08c4a985a07b" translate="yes" xml:space="preserve">
          <source>Vec::rotate_left</source>
          <target state="translated">Vec::rotate_left</target>
        </trans-unit>
        <trans-unit id="a21a400e9268e082bb2ce482e8a8dfc6ab09fcf1" translate="yes" xml:space="preserve">
          <source>Vec::rotate_right</source>
          <target state="translated">Vec::rotate_right</target>
        </trans-unit>
        <trans-unit id="230272571f5aeb260545461fbf996bc487081e16" translate="yes" xml:space="preserve">
          <source>Vec::rsplit</source>
          <target state="translated">Vec::rsplit</target>
        </trans-unit>
        <trans-unit id="7588b43de214dc9942b6ec718d4f47a2bcedcba0" translate="yes" xml:space="preserve">
          <source>Vec::rsplit_mut</source>
          <target state="translated">Vec::rsplit_mut</target>
        </trans-unit>
        <trans-unit id="7d1297a0cd4e2ea121ae3252d869a3ab0996a1d6" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn</source>
          <target state="translated">Vec::rsplitn</target>
        </trans-unit>
        <trans-unit id="62a275a0772dd8dc1d1984c12daaf575f3aeeba5" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn_mut</source>
          <target state="translated">Vec::rsplitn_mut</target>
        </trans-unit>
        <trans-unit id="b0b31a5d59982433104183b210cdc7f9a7187cc9" translate="yes" xml:space="preserve">
          <source>Vec::set_len</source>
          <target state="translated">Vec::set_len</target>
        </trans-unit>
        <trans-unit id="dcf4c0bec18deb050ca3760e0ffcb5fbdd9b508d" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to</source>
          <target state="translated">Vec::shrink_to</target>
        </trans-unit>
        <trans-unit id="85ba0030d7417692c1610e814b9b07a58d76e77c" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to_fit</source>
          <target state="translated">Vec::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="16d167d14ba9fe06f16ed99bae2a2c03419b826b" translate="yes" xml:space="preserve">
          <source>Vec::sort</source>
          <target state="translated">Vec::sort</target>
        </trans-unit>
        <trans-unit id="81d8d3adb266cd3ddbf5075796bf792188963e60" translate="yes" xml:space="preserve">
          <source>Vec::sort_by</source>
          <target state="translated">Vec::sort_by</target>
        </trans-unit>
        <trans-unit id="fdaa89a60d5801892ad1d2af91cf732bf0fa3243" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_cached_key</source>
          <target state="translated">Vec::sort_by_cached_key</target>
        </trans-unit>
        <trans-unit id="d7a763e74650730d9254a393db15ca96341ce8b4" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_key</source>
          <target state="translated">Vec::sort_by_key</target>
        </trans-unit>
        <trans-unit id="abf375eb46a47b0a7dc0651c427daa5777cdc87d" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable</source>
          <target state="translated">Vec::sort_unstable</target>
        </trans-unit>
        <trans-unit id="6b1b6c683e214a704567cbb4866e258d5339b1a6" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by</source>
          <target state="translated">Vec::sort_unstable_by</target>
        </trans-unit>
        <trans-unit id="98bc35f1fee62d3c06dfa775a7a509e42577ec92" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by_key</source>
          <target state="translated">Vec::sort_unstable_by_key</target>
        </trans-unit>
        <trans-unit id="32db21414779495d647f8b90a008c9ef3267c648" translate="yes" xml:space="preserve">
          <source>Vec::splice</source>
          <target state="translated">Vec::splice</target>
        </trans-unit>
        <trans-unit id="a29a88b90b2283fcc62467ac92b894872c49e16c" translate="yes" xml:space="preserve">
          <source>Vec::split</source>
          <target state="translated">Vec::split</target>
        </trans-unit>
        <trans-unit id="6850cc7f3a18a5ae8795a517214f52bd03e37d1b" translate="yes" xml:space="preserve">
          <source>Vec::split_at</source>
          <target state="translated">Vec::split_at</target>
        </trans-unit>
        <trans-unit id="fffa7968cc458ceca06542d5bd41cbc6ab30cf0c" translate="yes" xml:space="preserve">
          <source>Vec::split_at_mut</source>
          <target state="translated">Vec::split_at_mut</target>
        </trans-unit>
        <trans-unit id="a158f5776929dc5fa591347c97af279ee6f308b5" translate="yes" xml:space="preserve">
          <source>Vec::split_first</source>
          <target state="translated">Vec::split_first</target>
        </trans-unit>
        <trans-unit id="6bc5d749a8be60dd619275925ca3abe61e1f1d9c" translate="yes" xml:space="preserve">
          <source>Vec::split_first_mut</source>
          <target state="translated">Vec::split_first_mut</target>
        </trans-unit>
        <trans-unit id="37a2c9e4c660e48769312c66dd3af4005f29a265" translate="yes" xml:space="preserve">
          <source>Vec::split_last</source>
          <target state="translated">Vec::split_last</target>
        </trans-unit>
        <trans-unit id="18a1b33cf122a212120639e6c43b624cc50e7d15" translate="yes" xml:space="preserve">
          <source>Vec::split_last_mut</source>
          <target state="translated">Vec::split_last_mut</target>
        </trans-unit>
        <trans-unit id="cf6ca76593d5b57fc21960139169843fb9cd7b00" translate="yes" xml:space="preserve">
          <source>Vec::split_mut</source>
          <target state="translated">Vec::split_mut</target>
        </trans-unit>
        <trans-unit id="03a916c0fcda14cb715141144403e9cf172139de" translate="yes" xml:space="preserve">
          <source>Vec::split_off</source>
          <target state="translated">Vec::split_off</target>
        </trans-unit>
        <trans-unit id="07108e7065deeacdbce3703bf0867dca70e0aa63" translate="yes" xml:space="preserve">
          <source>Vec::splitn</source>
          <target state="translated">Vec::splitn</target>
        </trans-unit>
        <trans-unit id="670a558b46826ad5134c813b4ea72c5f594e6c9a" translate="yes" xml:space="preserve">
          <source>Vec::splitn_mut</source>
          <target state="translated">Vec::splitn_mut</target>
        </trans-unit>
        <trans-unit id="0c0afbd8febc9c5f973424fd46f0e38ed59ccbe9" translate="yes" xml:space="preserve">
          <source>Vec::starts_with</source>
          <target state="translated">Vec::starts_with</target>
        </trans-unit>
        <trans-unit id="ad111eb0f36abc808f9f63d831dd393671b7d60f" translate="yes" xml:space="preserve">
          <source>Vec::swap</source>
          <target state="translated">Vec::swap</target>
        </trans-unit>
        <trans-unit id="c2d87a017cf8d077c99bd71bef846182121ea2f2" translate="yes" xml:space="preserve">
          <source>Vec::swap_remove</source>
          <target state="translated">Vec::swap_remove</target>
        </trans-unit>
        <trans-unit id="65ba4dcc752fbaf145dfc393c0ebd072c03850f4" translate="yes" xml:space="preserve">
          <source>Vec::swap_with_slice</source>
          <target state="translated">Vec::swap_with_slice</target>
        </trans-unit>
        <trans-unit id="187dcbc4c913473ea9ecc0da0ece64f155078f4d" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_lowercase</source>
          <target state="translated">Vec::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="9e994a24d814eaa773517353561f7db1763ba8c8" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_uppercase</source>
          <target state="translated">Vec::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="2d58122faa3b804afda87ac1afe94b0c2cf49a62" translate="yes" xml:space="preserve">
          <source>Vec::to_owned</source>
          <target state="translated">Vec::to_owned</target>
        </trans-unit>
        <trans-unit id="8295dc906018a2b87ebb59e81316a74736c8fba2" translate="yes" xml:space="preserve">
          <source>Vec::to_vec</source>
          <target state="translated">Vec::to_vec</target>
        </trans-unit>
        <trans-unit id="bbcf834cd40bf8d351710e8898b52c0706e47891" translate="yes" xml:space="preserve">
          <source>Vec::truncate</source>
          <target state="translated">Vec::truncate</target>
        </trans-unit>
        <trans-unit id="b539d40fa6817c484aec79eab2f72f8b069cd61a" translate="yes" xml:space="preserve">
          <source>Vec::try_from</source>
          <target state="translated">Vec::try_from</target>
        </trans-unit>
        <trans-unit id="edfbddcc1f5344a46cf8226a51d4480baae3f991" translate="yes" xml:space="preserve">
          <source>Vec::try_into</source>
          <target state="translated">Vec::try_into</target>
        </trans-unit>
        <trans-unit id="5c86c8fb54973c689718f247d2725be10c514476" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve</source>
          <target state="translated">Vec::try_reserve</target>
        </trans-unit>
        <trans-unit id="31147313c7e8fcea891f9a87a61ed1563dcc2831" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve_exact</source>
          <target state="translated">Vec::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="eed582f83a9d0aa9e1d0f2c268a23f8e413a6328" translate="yes" xml:space="preserve">
          <source>Vec::type_id</source>
          <target state="translated">Vec::type_id</target>
        </trans-unit>
        <trans-unit id="464742f01bb0869c25eb2800b7d8db8a1c7aac11" translate="yes" xml:space="preserve">
          <source>Vec::windows</source>
          <target state="translated">Vec::windows</target>
        </trans-unit>
        <trans-unit id="5728e3095df170ba310bd22e53f060f7088cdde8" translate="yes" xml:space="preserve">
          <source>Vec::with_capacity</source>
          <target state="translated">Vec::with_capacity</target>
        </trans-unit>
        <trans-unit id="265d2eb25b96552c36adc69855110dc3fd58c9aa" translate="yes" xml:space="preserve">
          <source>Vec::write</source>
          <target state="translated">Vec::write</target>
        </trans-unit>
        <trans-unit id="aeb1c503a25270fdde3115b7ad8a988a9c161a9d" translate="yes" xml:space="preserve">
          <source>Vec::write_all</source>
          <target state="translated">Vec::write_all</target>
        </trans-unit>
        <trans-unit id="bdef50740c7daaafaaf5156f90836f0887c73803" translate="yes" xml:space="preserve">
          <source>Vec::write_fmt</source>
          <target state="translated">Vec::write_fmt</target>
        </trans-unit>
        <trans-unit id="fb5d72587567483189e25ea2273df15eb40edb69" translate="yes" xml:space="preserve">
          <source>Vec::write_vectored</source>
          <target state="translated">Vec::write_vectored</target>
        </trans-unit>
        <trans-unit id="d8b188dca79494d553b4a25f8e7ba135fd059e06" translate="yes" xml:space="preserve">
          <source>VecDeque</source>
          <target state="translated">VecDeque</target>
        </trans-unit>
        <trans-unit id="daac388a0835b2f7f116ce4b930ba45f24e2d4f5" translate="yes" xml:space="preserve">
          <source>VecDeque::append</source>
          <target state="translated">VecDeque::append</target>
        </trans-unit>
        <trans-unit id="131f1606d9fb60120a570fc56345c3b4206cde68" translate="yes" xml:space="preserve">
          <source>VecDeque::as_mut_slices</source>
          <target state="translated">VecDeque::as_mut_slices</target>
        </trans-unit>
        <trans-unit id="e9e3cfebdd186278d399abad0a429053157088f8" translate="yes" xml:space="preserve">
          <source>VecDeque::as_slices</source>
          <target state="translated">VecDeque::as_slices</target>
        </trans-unit>
        <trans-unit id="0edc19e4ca1884e4aacf2a2a4380274826fb2740" translate="yes" xml:space="preserve">
          <source>VecDeque::back</source>
          <target state="translated">VecDeque::back</target>
        </trans-unit>
        <trans-unit id="ccf30a4382ae9328f9552afa5c5dfcfb35aef1b4" translate="yes" xml:space="preserve">
          <source>VecDeque::back_mut</source>
          <target state="translated">VecDeque::back_mut</target>
        </trans-unit>
        <trans-unit id="1d2610cb9f7282ea37e182a5f5c322a259c73e56" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow</source>
          <target state="translated">VecDeque::borrow</target>
        </trans-unit>
        <trans-unit id="c85001c25549712efa3bc4037af617403882f850" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow_mut</source>
          <target state="translated">VecDeque::borrow_mut</target>
        </trans-unit>
        <trans-unit id="50c2744064aa2c0045027447f96537e071e16754" translate="yes" xml:space="preserve">
          <source>VecDeque::capacity</source>
          <target state="translated">VecDeque::capacity</target>
        </trans-unit>
        <trans-unit id="d9ea40fef888b1aa5e6f0be9bc6eb9c5f0603d26" translate="yes" xml:space="preserve">
          <source>VecDeque::clamp</source>
          <target state="translated">VecDeque::clamp</target>
        </trans-unit>
        <trans-unit id="cef7bd89bf4a4eb9ba33004328fb058621269fe0" translate="yes" xml:space="preserve">
          <source>VecDeque::clear</source>
          <target state="translated">VecDeque::clear</target>
        </trans-unit>
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">Los vectores tambi&amp;eacute;n admiten la indexaci&amp;oacute;n (a trav&amp;eacute;s de &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt; rasgos ):</target>
        </trans-unit>
        <trans-unit id="10bd4ec04f26e95aeb5bf4a6ea31710e8b61d3aa" translate="yes" xml:space="preserve">
          <source>Vectors ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">Los vectores tienen indexaci&amp;oacute;n &lt;code&gt;O(1)&lt;/code&gt; , &lt;code&gt;O(1)&lt;/code&gt; amortizado empujar (hasta el final) y &lt;code&gt;O(1)&lt;/code&gt; pop (desde el final).</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">Los vectores,las cadenas y los mapas hash proporcionarán una gran cantidad de funcionalidad necesaria en los programas cuando se necesite almacenar,acceder y modificar datos.Aquí hay algunos ejercicios para los que debería estar equipado para resolver:</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Los prefijos UNC verbatim constan de &lt;code&gt;\?\UNC\&lt;/code&gt; seguido inmediatamente por el nombre de host del servidor y un nombre compartido.</target>
        </trans-unit>
        <trans-unit id="deeec6948b9b0c7f539defff599e2c9119f209e1" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">Prefijo de disco literal, por ejemplo, &lt;code&gt;\?\C:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9892a19a8c55087305e1dc4f1a3f3fc14b7bbe" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\\?\C:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">Los prefijos de disco textuales constan de &lt;code&gt;\?\&lt;/code&gt; Seguido inmediatamente por la letra de la unidad y &lt;code&gt;:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbcf31c83c72d79322932f64e5c3a662a2b82084" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">Verbatim prefijo de uso de Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N&lt;/strong&gt; aming &lt;strong&gt;C&lt;/strong&gt; onvenci&amp;oacute;n&lt;/em&gt; , por ejemplo, &lt;code&gt;\?\UNC\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d803e02d9c2966256665f4a37fc515a7b6b0270" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">Prefijo literal, por ejemplo, &lt;code&gt;\?\cat_pics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec64b930987590c33c18d3b5f5e6cd65655febca" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\\?\cat_pics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">Los prefijos textuales consisten en &lt;code&gt;\?\&lt;/code&gt; Seguido inmediatamente por el componente dado.</target>
        </trans-unit>
        <trans-unit id="6c060304c7d1622fca546ec1708bfccb55b07579" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">Verifique que no haya escrito mal el nombre del campo o que el campo exista.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">A trav&amp;eacute;s de referencias inmutables, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; permite compartir datos entre m&amp;uacute;ltiples partes de su programa solo para lectura. Si &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; le permit&amp;iacute;a tener m&amp;uacute;ltiples referencias mutables, podr&amp;iacute;a violar una de las reglas de pr&amp;eacute;stamo discutidas en el Cap&amp;iacute;tulo 4: m&amp;uacute;ltiples pr&amp;eacute;stamos mutables en el mismo lugar pueden causar carreras de datos e inconsistencias. &amp;iexcl;Pero poder mutar datos es muy &amp;uacute;til! En la siguiente secci&amp;oacute;n, discutiremos el patr&amp;oacute;n de mutabilidad interior y el tipo &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; que puede usar junto con un &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; para trabajar con esta restricci&amp;oacute;n de inmutabilidad.</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">Ve los datos subyacentes como una subcategoría de los datos originales.</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">La violación de estos puede causar problemas como la corrupción de las estructuras internas de datos del asignador.</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">La violaci&amp;oacute;n de estos puede causar problemas como da&amp;ntilde;ar las estructuras de datos internas del asignador. Por ejemplo, es &lt;strong&gt;no&lt;/strong&gt; seguro para construir un &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; desde un puntero a una C &lt;code&gt;char&lt;/code&gt; matriz y un &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4c0ad7ae3e37221747e827bd3d99a0ac9c1516" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array with length &lt;code&gt;size_t&lt;/code&gt;. It's also not safe to build one from a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; and its length, because the allocator cares about the alignment, and these two types have different alignments. The buffer was allocated with alignment 2 (for &lt;code&gt;u16&lt;/code&gt;), but after turning it into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; it'll be deallocated with alignment 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">Visibilidad y privacidad</target>
        </trans-unit>
        <trans-unit id="acf880408a272d86a4dffcc14370fa0e4c75f47e" translate="yes" xml:space="preserve">
          <source>Visibility is restricted to a module which isn't an ancestor of the current item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">Visita los valores que representan la diferencia, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; pero no en &lt;code&gt;other&lt;/code&gt; , en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Visita los valores que representan la diferencia, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; pero no en el &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">Visita los valores que representan la intersecci&amp;oacute;n, es decir, los valores que est&amp;aacute;n tanto en &lt;code&gt;self&lt;/code&gt; como en &lt;code&gt;other&lt;/code&gt; , en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Visita los valores que representan la intersecci&amp;oacute;n, es decir, los valores que est&amp;aacute;n tanto en &lt;code&gt;self&lt;/code&gt; como en el &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">Visita los valores que representan la diferencia sim&amp;eacute;trica, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; pero no en ambos, en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">Visita los valores que representan la diferencia sim&amp;eacute;trica, es decir, los valores que est&amp;aacute;n en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; pero no en ambos.</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">Visita los valores que representan la uni&amp;oacute;n, es decir, todos los valores en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; , sin duplicados, en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">Visita los valores que representan la uni&amp;oacute;n, es decir, todos los valores en &lt;code&gt;self&lt;/code&gt; o en &lt;code&gt;other&lt;/code&gt; , sin duplicados.</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">Visualizaci&amp;oacute;n de cambios en &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; y &lt;code&gt;weak_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">Las operaciones volátiles están pensadas para actuar sobre la memoria de E/S,y se garantiza que no serán eludidas o reordenadas por el compilador a través de otras operaciones volátiles.</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="84367e806ed16f93cd67aba890fbaef52d16a0b0" translate="yes" xml:space="preserve">
          <source>WASI</source>
          <target state="translated">WASI</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">Esperando a que todos los subprocesos terminen usando controles de &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">Esperando la completa expiración del tiempo de espera:</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">Espera a que el hilo asociado termine.</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">Espera a que el niño salga completamente,devolviendo el estado con el que salió.Esta función seguirá teniendo el mismo valor de retorno después de haber sido llamada al menos una vez.</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">Espera en esta variable de la condición para una notificación,que se prolonga después de una duración determinada.</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">Espera en esta variable de la condición para una notificación,que se prolonga después de una duración determinada.Las estelas espurias no harán que esta función regrese.</target>
        </trans-unit>
        <trans-unit id="d6a3650e37b6043ab9616dfc37b87c0ed505a997" translate="yes" xml:space="preserve">
          <source>Wake</source>
          <target state="translated">Wake</target>
        </trans-unit>
        <trans-unit id="2b6971b8cb619ebe6c9f69185b57e5e06726f961" translate="yes" xml:space="preserve">
          <source>Wake this task without consuming the waker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b7b65fb8cc05d38d07b2b178ad74919bff2a82" translate="yes" xml:space="preserve">
          <source>Wake this task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">Despierta la tarea asociada con este &lt;code&gt;Waker&lt;/code&gt; sin consumir el &lt;code&gt;Waker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">Despierta la tarea asociada con este &lt;code&gt;Waker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">Despierta todos los hilos bloqueados en este condvar.</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">Despierta un hilo bloqueado en este condvar.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">Advertencia: &lt;code&gt;hash_builder&lt;/code&gt; se genera normalmente de forma aleatoria y est&amp;aacute; dise&amp;ntilde;ado para permitir que HashMaps sea resistente a ataques que provocan muchas colisiones y un rendimiento muy deficiente. Configurarlo manualmente usando esta funci&amp;oacute;n puede exponer un vector de ataque DoS.</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">Advertencia: &lt;code&gt;hasher&lt;/code&gt; normalmente se genera aleatoriamente y est&amp;aacute; dise&amp;ntilde;ado para permitir que los &lt;code&gt;HashSet&lt;/code&gt; sean resistentes a los ataques que causan muchas colisiones y un rendimiento muy bajo. Configurarlo manualmente usando esta funci&amp;oacute;n puede exponer un vector de ataque DoS.</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">Advertencia: Es posible que las opciones de configuraci&amp;oacute;n establecidas arbitrariamente tengan el mismo valor que las opciones de configuraci&amp;oacute;n establecidas por el compilador. Por ejemplo, es posible &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; mientras se compila en un destino de Windows, y tener configuradas las opciones de configuraci&amp;oacute;n de &lt;code&gt;unix&lt;/code&gt; y &lt;code&gt;windows&lt;/code&gt; al mismo tiempo. No es prudente hacer esto.</target>
        </trans-unit>
        <trans-unit id="953fdee2421f57eef922d79cc862ee6e22ccfc48" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; can only legally hold the discrimnant values, everything else is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. Therefore, using a field-less enum in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">Advertencia: existen diferencias cruciales entre una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n en el lenguaje C y las enumeraciones tipo C de Rust con esta representaci&amp;oacute;n. Una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n en C es principalmente un &lt;code&gt;typedef&lt;/code&gt; m&amp;aacute;s algunas constantes nombradas; en otras palabras, un objeto de tipo &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n puede contener cualquier valor entero. Por ejemplo, esto se utiliza a menudo para bitflags en &lt;code&gt;C&lt;/code&gt; . Por el contrario, las enumeraciones de tipo C de Rust solo pueden contener legalmente los valores discriminantes, todo lo dem&amp;aacute;s es un comportamiento indefinido. Por lo tanto, usar una enumeraci&amp;oacute;n similar a C en FFI para modelar una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n C a menudo es incorrecto.</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">Advertencia: este libro est&amp;aacute; incompleto. Documentar todo lleva un tiempo. Consulte los &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;problemas de GitHub&lt;/a&gt; para conocer lo que no est&amp;aacute; documentado en este libro.</target>
        </trans-unit>
        <trans-unit id="f1f7ce6b6e1db1f6b36ab4dbe1ad4b6e4aa8f982" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">Advertencia:Este es un ejemplo de advertencia.</target>
        </trans-unit>
        <trans-unit id="0411a6eec332f44831efbc3f9708608318be0eda" translate="yes" xml:space="preserve">
          <source>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">Advertencia: El uso de &lt;code&gt;no_std&lt;/code&gt; no evita que se vincule la biblioteca est&amp;aacute;ndar. A&amp;uacute;n es v&amp;aacute;lido poner &lt;code&gt;extern crate std;&lt;/code&gt; en la caja y las dependencias tambi&amp;eacute;n pueden vincularlo.</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">Las advertencias que muestran un comportamiento incorrecto en el lenguaje o posibles interacciones confusas de las características del lenguaje están en un recuadro de advertencia especial.</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">¿Tuvo éxito la terminación? La terminación de la señal no se considera un éxito,y el éxito se define como un estado de salida cero.</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">Formas en que las variables y los datos interactúan:Clonar</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">Formas en que las variables y los datos interactúan:Moverse</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">&lt;code&gt;use minigrep::Config&lt;/code&gt; una l&amp;iacute;nea use minigrep :: Config para llevar el tipo de &lt;code&gt;Config&lt;/code&gt; de la caja de la biblioteca al alcance de la caja binaria, y anteponemos la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; con nuestro nombre de caja. Ahora toda la funcionalidad deber&amp;iacute;a estar conectada y deber&amp;iacute;a funcionar. Ejecute el programa con &lt;code&gt;cargo run&lt;/code&gt; y aseg&amp;uacute;rese de que todo funcione correctamente.</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">Agregamos una implementaci&amp;oacute;n predeterminada para el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; que devuelve un segmento de cadena vac&amp;iacute;o. Eso significa que no necesitamos implementar &lt;code&gt;content&lt;/code&gt; en las estructuras &lt;code&gt;Draft&lt;/code&gt; y &lt;code&gt;PendingReview&lt;/code&gt; . La estructura &lt;code&gt;Published&lt;/code&gt; anular&amp;aacute; el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; y devolver&amp;aacute; el valor en &lt;code&gt;post.content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">Agregamos el m&amp;eacute;todo de &lt;code&gt;approve&lt;/code&gt; al rasgo de &lt;code&gt;State&lt;/code&gt; y agregamos una nueva estructura que implementa el &lt;code&gt;State&lt;/code&gt; , el estado &lt;code&gt;Published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">Agregamos tipos al l&amp;iacute;mite de rasgo &lt;code&gt;Fn&lt;/code&gt; para representar los tipos de par&amp;aacute;metros y valores de retorno que los cierres deben tener para coincidir con este l&amp;iacute;mite de rasgo. En este caso, nuestro cierre tiene un par&amp;aacute;metro de tipo &lt;code&gt;u32&lt;/code&gt; y devuelve &lt;code&gt;u32&lt;/code&gt; , por lo que el l&amp;iacute;mite de rasgo que especificamos es &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">Tambi&amp;eacute;n necesitamos una forma de almacenar las l&amp;iacute;neas que contienen nuestra cadena de consulta. Para eso, podemos hacer un vector mutable antes del ciclo &lt;code&gt;for&lt;/code&gt; y llamar al m&amp;eacute;todo &lt;code&gt;push&lt;/code&gt; para almacenar una &lt;code&gt;line&lt;/code&gt; en el vector. Despu&amp;eacute;s del ciclo &lt;code&gt;for&lt;/code&gt; , devolvemos el vector, como se muestra en el Listado 12-19.</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">No podemos ejecutar esta prueba y verla fallar porque la prueba ni siquiera se compila: &amp;iexcl;la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; a&amp;uacute;n no existe! As&amp;iacute; que ahora agregaremos el c&amp;oacute;digo suficiente para que la prueba se compile y se ejecute agregando una definici&amp;oacute;n de la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; que siempre devuelve un vector vac&amp;iacute;o, como se muestra en el Listado 12-16. Luego, la prueba deber&amp;iacute;a compilarse y fallar porque un vector vac&amp;iacute;o no coincide con un vector que contiene la l&amp;iacute;nea &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">No podemos usar las variables &lt;code&gt;field_name&lt;/code&gt; y &lt;code&gt;field_value&lt;/code&gt; despu&amp;eacute;s de que se hayan movido al mapa hash con la llamada a &lt;code&gt;insert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">No podemos usar &lt;code&gt;v1_iter&lt;/code&gt; despu&amp;eacute;s de la llamada a &lt;code&gt;sum&lt;/code&gt; porque &lt;code&gt;sum&lt;/code&gt; toma posesi&amp;oacute;n del iterador al que lo llamamos.</target>
        </trans-unit>
        <trans-unit id="03b218b584e4a8c7465d02aa1590edcd7370cd71" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">Adjuntamos los datos a cada variante del enum directamente,así que no hay necesidad de una estructura extra.</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">Nos unen &lt;code&gt;guess&lt;/code&gt; que la expresi&amp;oacute;n &lt;code&gt;guess.trim().parse()&lt;/code&gt; . La &lt;code&gt;guess&lt;/code&gt; en la expresi&amp;oacute;n se refiere a la &lt;code&gt;guess&lt;/code&gt; original que era una &lt;code&gt;String&lt;/code&gt; con la entrada en ella. El m&amp;eacute;todo de &lt;code&gt;trim&lt;/code&gt; en una instancia de &lt;code&gt;String&lt;/code&gt; eliminar&amp;aacute; cualquier espacio en blanco al principio y al final. Aunque &lt;code&gt;u32&lt;/code&gt; solo puede contener caracteres num&amp;eacute;ricos, el usuario debe presionar enter para satisfacer &lt;code&gt;read_line&lt;/code&gt; . Cuando el usuario presiona enter, se agrega un car&amp;aacute;cter de nueva l&amp;iacute;nea a la cadena. Por ejemplo, si el usuario escribe 5 y presiona Intro, &lt;code&gt;guess&lt;/code&gt; ver&amp;aacute; as&amp;iacute;: &lt;code&gt;5\n&lt;/code&gt; . El &lt;code&gt;\n&lt;/code&gt; representa &quot;nueva l&amp;iacute;nea&quot;, el resultado de presionar enter. El m&amp;eacute;todo de &lt;code&gt;trim&lt;/code&gt; elimina &lt;code&gt;\n&lt;/code&gt; , lo que da como resultado solo &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">Traemos &lt;code&gt;std::io::prelude&lt;/code&gt; al alcance para obtener acceso a ciertos rasgos que nos permiten leer y escribir en el flujo. En el bucle &lt;code&gt;for&lt;/code&gt; de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; , en lugar de imprimir un mensaje que dice que hicimos una conexi&amp;oacute;n, ahora llamamos a la nueva funci&amp;oacute;n &lt;code&gt;handle_connection&lt;/code&gt; y le pasamos el &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">Llamamos a tener referencias como &lt;em&gt;pr&amp;eacute;stamo de&lt;/em&gt; par&amp;aacute;metros de funci&amp;oacute;n . Como en la vida real, si una persona posee algo, se lo puede pedir prestado. Cuando termines, tienes que devolverlo.</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">Llamamos al m&amp;eacute;todo &lt;code&gt;as_ref&lt;/code&gt; en la &lt;code&gt;Option&lt;/code&gt; porque queremos una referencia al valor dentro de la &lt;code&gt;Option&lt;/code&gt; lugar de la propiedad del valor. Como el &lt;code&gt;state&lt;/code&gt; es una &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; , cuando llamamos a &lt;code&gt;as_ref&lt;/code&gt; , se devuelve una &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; . Si no llamamos a &lt;code&gt;as_ref&lt;/code&gt; , obtendr&amp;iacute;amos un error porque no podemos mover el &lt;code&gt;state&lt;/code&gt; del &lt;code&gt;&amp;amp;self&lt;/code&gt; prestado del par&amp;aacute;metro de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">Tambi&amp;eacute;n podemos implementar condicionalmente un rasgo para cualquier tipo que implemente otro rasgo. Las implementaciones de un rasgo en cualquier tipo que satisfaga los l&amp;iacute;mites del rasgo se denominan &lt;em&gt;implementaciones generales&lt;/em&gt; y se utilizan ampliamente en la biblioteca est&amp;aacute;ndar de Rust. Por ejemplo, la biblioteca est&amp;aacute;ndar implementa el rasgo &lt;code&gt;ToString&lt;/code&gt; en cualquier tipo que implemente el rasgo &lt;code&gt;Display&lt;/code&gt; . El bloque &lt;code&gt;impl&lt;/code&gt; en la biblioteca est&amp;aacute;ndar es similar a este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">Tambi&amp;eacute;n podemos construir rutas relativas que comienzan en el m&amp;oacute;dulo padre usando &lt;code&gt;super&lt;/code&gt; al comienzo de la ruta. Esto es como empezar un camino sistema de archivos con el &lt;code&gt;..&lt;/code&gt; sintaxis. &amp;iquest;Por qu&amp;eacute; querr&amp;iacute;amos hacer esto?</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">Tambi&amp;eacute;n podemos definir estructuras para usar un par&amp;aacute;metro de tipo gen&amp;eacute;rico en uno o m&amp;aacute;s campos usando la sintaxis &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Listado 10-6 muestra c&amp;oacute;mo definir un &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; estructura para sostener &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; valores de coordenadas de cualquier tipo.</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">También podemos desestructurar con valores literales como parte del patrón de estructura en lugar de crear variables para todos los campos.Hacerlo nos permite probar algunos de los campos para valores particulares mientras creamos variables para desestructurar los otros campos.</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">Tambi&amp;eacute;n podemos iterar sobre referencias mutables a cada elemento en un vector mutable para realizar cambios en todos los elementos. El ciclo &lt;code&gt;for&lt;/code&gt; del Listado 8-9 agregar&amp;aacute; &lt;code&gt;50&lt;/code&gt; a cada elemento.</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">Tambi&amp;eacute;n podemos ejecutar pruebas para una caja en particular en un espacio de trabajo desde el directorio de nivel superior usando la &lt;code&gt;-p&lt;/code&gt; y especificando el nombre de la caja que queremos probar:</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">Tambi&amp;eacute;n podemos especificar m&amp;aacute;s de un l&amp;iacute;mite de rasgo. Supongamos que queremos &lt;code&gt;notify&lt;/code&gt; para usar el formato de visualizaci&amp;oacute;n en el &lt;code&gt;item&lt;/code&gt; , as&amp;iacute; como el m&amp;eacute;todo de &lt;code&gt;summarize&lt;/code&gt; : especificamos en la definici&amp;oacute;n de &lt;code&gt;notify&lt;/code&gt; que el &lt;code&gt;item&lt;/code&gt; debe implementar tanto la &lt;code&gt;Display&lt;/code&gt; como el &lt;code&gt;Summary&lt;/code&gt; . Podemos hacerlo usando la sintaxis &lt;code&gt;+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">Tambi&amp;eacute;n podemos aprovechar los iteradores en la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; en nuestro proyecto de E / S, que se reproduce aqu&amp;iacute; en el Listado 13-28 como estaba en el Listado 12-19:</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar &lt;code&gt;_&lt;/code&gt; dentro de otro patr&amp;oacute;n para ignorar solo una parte de un valor, por ejemplo, cuando queremos probar solo una parte de un valor pero no tenemos uso para las otras partes en el c&amp;oacute;digo correspondiente que queremos ejecutar. El listado 18-18 muestra el c&amp;oacute;digo responsable de administrar el valor de una configuraci&amp;oacute;n. Los requisitos comerciales son que el usuario no debe poder sobrescribir una personalizaci&amp;oacute;n existente de una configuraci&amp;oacute;n, pero puede desarmar la configuraci&amp;oacute;n y darle un valor si no est&amp;aacute; configurada actualmente.</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar &lt;code&gt;extern&lt;/code&gt; para crear una interfaz que permita a otros lenguajes llamar a funciones de Rust. En lugar de un bloque &lt;code&gt;extern&lt;/code&gt; , agregamos la palabra clave &lt;code&gt;extern&lt;/code&gt; y especificamos el ABI a usar justo antes de la palabra clave &lt;code&gt;fn&lt;/code&gt; . Tambi&amp;eacute;n necesitamos agregar una anotaci&amp;oacute;n &lt;code&gt;#[no_mangle]&lt;/code&gt; para decirle al compilador de Rust que no altere el nombre de esta funci&amp;oacute;n. &lt;em&gt;Destrozar&lt;/em&gt;es cuando un compilador cambia el nombre que le hemos dado a una funci&amp;oacute;n por un nombre diferente que contiene m&amp;aacute;s informaci&amp;oacute;n para que otras partes del proceso de compilaci&amp;oacute;n la consuman, pero es menos legible por humanos. Cada compilador de lenguaje de programaci&amp;oacute;n modifica los nombres de manera ligeramente diferente, por lo que para que una funci&amp;oacute;n de Rust pueda ser nombrada por otros lenguajes, debemos deshabilitar la manipulaci&amp;oacute;n de nombres del compilador de Rust.</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar &lt;code&gt;pub&lt;/code&gt; para designar estructuras y enumeraciones como p&amp;uacute;blicas, pero hay algunos detalles adicionales. Si usamos &lt;code&gt;pub&lt;/code&gt; antes de una definici&amp;oacute;n de estructura, la hacemos p&amp;uacute;blica, pero los campos de la estructura seguir&amp;aacute;n siendo privados. Podemos hacer que cada campo sea p&amp;uacute;blico o no, caso por caso. En el Listado 7-9, hemos definido una &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; p&amp;uacute;blica back_of_house :: Breakfast con un campo de &lt;code&gt;toast&lt;/code&gt; p&amp;uacute;blico pero una &lt;code&gt;seasonal_fruit&lt;/code&gt; privada.campo. Esto modela el caso en un restaurante donde el cliente puede elegir el tipo de pan que viene con una comida, pero el chef decide qu&amp;eacute; fruta acompa&amp;ntilde;a la comida en funci&amp;oacute;n de la temporada y el stock. La fruta disponible cambia r&amp;aacute;pidamente, por lo que los clientes no pueden elegir la fruta o incluso ver qu&amp;eacute; fruta obtendr&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">También podemos utilizar patrones en las listas de parámetros de cierre de la misma manera que en las listas de parámetros de funciones,porque los cierres son similares a las funciones,como se discute en el capítulo 13.</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar patrones para desestructurar estructuras, enumeraciones, tuplas y referencias para usar diferentes partes de estos valores. Repasemos cada valor.</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar la sintaxis &lt;code&gt;impl Trait&lt;/code&gt; en la posici&amp;oacute;n de retorno para devolver un valor de alg&amp;uacute;n tipo que implemente un rasgo, como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar la funci&amp;oacute;n &lt;code&gt;String::from&lt;/code&gt; para crear un &lt;code&gt;String&lt;/code&gt; a partir de un string literal. El c&amp;oacute;digo del Listado 8-13 es equivalente al c&amp;oacute;digo del Listado 8-12 que usa &lt;code&gt;to_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">También podemos usar subrayados en múltiples lugares dentro de un patrón para ignorar valores particulares.La lista 18-19 muestra un ejemplo de ignorar el segundo y el cuarto valor en una tupla de cinco elementos.</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">Podemos construir un proyecto usando &lt;code&gt;cargo build&lt;/code&gt; &lt;code&gt;cargo check&lt;/code&gt; o verificaci&amp;oacute;n de carga .</target>
        </trans-unit>
        <trans-unit id="838e973f1067e2cb1c1db7ba741330fcbc0ac60a" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce64501de0b20285b589ca7f67901cf5515ef19d" translate="yes" xml:space="preserve">
          <source>We can build a project without producing a binary to check for errors using &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">Podemos construir y ejecutar un proyecto en un solo paso usando &lt;code&gt;cargo run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">Podemos llamar a cualquier funci&amp;oacute;n que hayamos definido ingresando su nombre seguido de un par de par&amp;eacute;ntesis. Debido a que &lt;code&gt;another_function&lt;/code&gt; est&amp;aacute; definida en el programa, se puede llamar desde dentro de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; . Tenga en cuenta que definimos otra &lt;code&gt;another_function&lt;/code&gt; &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; en el c&amp;oacute;digo fuente; tambi&amp;eacute;n podr&amp;iacute;amos haberlo definido antes. A Rust no le importa d&amp;oacute;nde defina sus funciones, solo que est&amp;eacute;n definidas en alg&amp;uacute;n lugar.</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">Podemos llamar a la funci&amp;oacute;n &lt;code&gt;hello&lt;/code&gt; con un segmento de cadena como argumento, como &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; por ejemplo. Deref coercion hace posible llamar &lt;code&gt;hello&lt;/code&gt; con una referencia a un valor de tipo &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; , como se muestra en el Listado 15-12:</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">Podemos llamar &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo siguiente en iteradores directamente; El Listado 13-15 demuestra qu&amp;eacute; valores se devuelven de llamadas repetidas a &lt;code&gt;next&lt;/code&gt; en el iterador creado a partir del vector.</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">Podemos cambiar la definici&amp;oacute;n de la enumeraci&amp;oacute;n &lt;code&gt;List&lt;/code&gt; en el Listado 15-2 y el uso de la &lt;code&gt;List&lt;/code&gt; a en el Listado 15-3 al c&amp;oacute;digo en el Listado 15-5, que compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">Podemos combinar &lt;code&gt;str&lt;/code&gt; con todo tipo de punteros: por ejemplo, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; o &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; . De hecho, has visto esto antes, pero con un tipo de tama&amp;ntilde;o din&amp;aacute;mico diferente: rasgos. Cada rasgo es un tipo de tama&amp;ntilde;o din&amp;aacute;mico al que podemos referirnos usando el nombre del rasgo. En el Cap&amp;iacute;tulo 17 en la secci&amp;oacute;n &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&quot;Uso de objetos de rasgo que permiten valores de diferentes tipos&quot;&lt;/a&gt; , mencionamos que para usar rasgos como objetos de rasgo, debemos ponerlos detr&amp;aacute;s de un puntero, como &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; o &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; ( &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; tambi&amp;eacute;n funcionar&amp;iacute;a).</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">Podemos crear instancias de cada una de las dos variantes de &lt;code&gt;IpAddrKind&lt;/code&gt; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="6778f0bff382e98f9e7494c1dbfeeb8d0d54aa88" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte (counting from 1) of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">Podemos crear rebanadas utilizando un rango entre corchetes especificando &lt;code&gt;[starting_index..ending_index]&lt;/code&gt; , donde &lt;code&gt;starting_index&lt;/code&gt; es la primera posici&amp;oacute;n en la rebanada y &lt;code&gt;ending_index&lt;/code&gt; es uno m&amp;aacute;s que la &amp;uacute;ltima posici&amp;oacute;n en la rebanada. Internamente, la estructura de datos rebanada almacena la posici&amp;oacute;n de partida y la longitud de la rebanada, que corresponde a &lt;code&gt;ending_index&lt;/code&gt; menos &lt;code&gt;starting_index&lt;/code&gt; . Entonces, en el caso de &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; , &lt;code&gt;world&lt;/code&gt; ser&amp;iacute;a un segmento que contiene un puntero al s&amp;eacute;ptimo byte de &lt;code&gt;s&lt;/code&gt; con un valor de longitud de 5.</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">Podemos expresar este concepto en c&amp;oacute;digo definiendo una enumeraci&amp;oacute;n &lt;code&gt;IpAddrKind&lt;/code&gt; y enumerando los posibles tipos que puede ser una direcci&amp;oacute;n IP, &lt;code&gt;V4&lt;/code&gt; y &lt;code&gt;V6&lt;/code&gt; . Estos se conocen como las &lt;em&gt;variantes&lt;/em&gt; de la enumeraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="76dc799b358f8c432443282c326218cb637140a7" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are the variants of the enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">Podemos arreglar el error en el código de la Lista 4-6 con sólo un pequeño ajuste:</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">Podemos solucionar el problema de que el hilo generado no se ejecute, o no se ejecute completamente, guardando el valor de retorno de &lt;code&gt;thread::spawn&lt;/code&gt; en una variable. El tipo de retorno de &lt;code&gt;thread::spawn&lt;/code&gt; es &lt;code&gt;JoinHandle&lt;/code&gt; . Un &lt;code&gt;JoinHandle&lt;/code&gt; es un valor de propiedad que, cuando llamamos al m&amp;eacute;todo de &lt;code&gt;join&lt;/code&gt; , esperar&amp;aacute; a que termine su hilo. El Listado 16-2 muestra c&amp;oacute;mo usar &lt;code&gt;JoinHandle&lt;/code&gt; del hilo que creamos en el Listado 16-1 y llamar a &lt;code&gt;join&lt;/code&gt; para asegurarse de que el hilo generado termina antes de las salidas &lt;code&gt;main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">Podemos obtener un valor del mapa hash proporcionando su clave para el m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; , como se muestra en el Listado 8-23.</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">Podemos hacer crecer una &lt;code&gt;String&lt;/code&gt; usando el m&amp;eacute;todo &lt;code&gt;push_str&lt;/code&gt; para agregar un segmento de cadena, como se muestra en el Listado 8-15.</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">Podemos implementar m&amp;eacute;todos en estructuras y enumeraciones (como hicimos en el Cap&amp;iacute;tulo 5) y tambi&amp;eacute;n usar tipos gen&amp;eacute;ricos en sus definiciones. El Listado 10-9 muestra la estructura &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; que definimos en el Listado 10-6 con un m&amp;eacute;todo llamado &lt;code&gt;x&lt;/code&gt; implementado en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">Podemos incluir un &lt;code&gt;else&lt;/code&gt; con un &lt;code&gt;if let&lt;/code&gt; . El bloque de c&amp;oacute;digo que va con &lt;code&gt;else&lt;/code&gt; es el mismo que el bloque de c&amp;oacute;digo que ir&amp;iacute;a con el caso &lt;code&gt;_&lt;/code&gt; en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; que es equivalente a &lt;code&gt;if let&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; . Recuerde la definici&amp;oacute;n de enumeraci&amp;oacute;n de &lt;code&gt;Coin&lt;/code&gt; en el Listado 6-4, donde la variante &lt;code&gt;Quarter&lt;/code&gt; tambi&amp;eacute;n ten&amp;iacute;a un valor &lt;code&gt;UsState&lt;/code&gt; . Si quisi&amp;eacute;ramos contar todas las monedas que no son de un cuarto que vemos al mismo tiempo que anunciamos el estado de los cuartos, podr&amp;iacute;amos hacerlo con una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; como esta:</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">En su lugar, podemos devolver un valor de &lt;code&gt;Result&lt;/code&gt; que contendr&amp;aacute; una instancia de &lt;code&gt;Config&lt;/code&gt; en el caso exitoso y describir&amp;aacute; el problema en el caso de error. Cuando &lt;code&gt;Config::new&lt;/code&gt; est&amp;aacute; comunicando con &lt;code&gt;main&lt;/code&gt; , podemos usar el tipo &lt;code&gt;Result&lt;/code&gt; para se&amp;ntilde;alar que hubo un problema. Entonces podemos cambiar &lt;code&gt;main&lt;/code&gt; para convertir una variante &lt;code&gt;Err&lt;/code&gt; en un error m&amp;aacute;s pr&amp;aacute;ctico para nuestros usuarios sin el texto circundante sobre el &lt;code&gt;thread 'main'&lt;/code&gt; y &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; que una llamada al &lt;code&gt;panic!&lt;/code&gt; causas.</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Podemos iterar sobre cada par clave / valor en un mapa hash de manera similar a como lo hacemos con los vectores, usando un bucle &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">Podemos mezclar,combinar y anidar patrones de desestructuración de maneras aún más complejas.El siguiente ejemplo muestra una desestructuración complicada en la que anidamos estructuras y tuplas dentro de una tupla y desestructuramos todos los valores primitivos hacia fuera:</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">Ahora podemos agregar &lt;code&gt;use rand;&lt;/code&gt; al archivo &lt;em&gt;add-one / src / lib.rs&lt;/em&gt; , y construir todo el espacio de trabajo ejecutando &lt;code&gt;cargo build&lt;/code&gt; en el directorio &lt;em&gt;add&lt;/em&gt; traer&amp;aacute; y compilar&amp;aacute; la caja &lt;code&gt;rand&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">Podemos pasar el nombre de cualquier funci&amp;oacute;n de &lt;code&gt;cargo test&lt;/code&gt; a la prueba de carga para ejecutar solo esa prueba:</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">Probablemente podemos adivinar lo que esto est&amp;aacute; haciendo: &amp;ldquo;atar el valor &lt;code&gt;5&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; ; luego haz una copia del valor en &lt;code&gt;x&lt;/code&gt; y &amp;uacute;nelo a &lt;code&gt;y&lt;/code&gt; &quot;. Ahora tenemos dos variables, &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , y ambos iguales &lt;code&gt;5&lt;/code&gt; . De hecho, esto es lo que est&amp;aacute; sucediendo, porque los n&amp;uacute;meros enteros son valores simples con un tama&amp;ntilde;o fijo conocido, y estos dos &lt;code&gt;5&lt;/code&gt; valores se insertan en la pila.</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">Podemos representar el mismo concepto de una manera m&amp;aacute;s concisa usando solo una enumeraci&amp;oacute;n, en lugar de una enumeraci&amp;oacute;n dentro de una estructura, colocando datos directamente en cada variante de enumeraci&amp;oacute;n. Esta nueva definici&amp;oacute;n de la enumeraci&amp;oacute;n &lt;code&gt;IpAddr&lt;/code&gt; dice que las variantes &lt;code&gt;V4&lt;/code&gt; y &lt;code&gt;V6&lt;/code&gt; tendr&amp;aacute;n valores de &lt;code&gt;String&lt;/code&gt; asociados :</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">Podemos reescribir el c&amp;oacute;digo en el Listado 15-6 para usar &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; lugar de una referencia; el operador de desreferencia funcionar&amp;aacute; como se muestra en el Listado 15-7:</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">Podemos ver que &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; tiene un recuento de referencia inicial de 1; luego, cada vez que llamamos a &lt;code&gt;clone&lt;/code&gt; , el recuento aumenta en 1. Cuando &lt;code&gt;c&lt;/code&gt; sale del alcance, el recuento disminuye en 1. No tenemos que llamar a una funci&amp;oacute;n para disminuir el recuento de referencias como tenemos que llamar a &lt;code&gt;Rc::clone&lt;/code&gt; para aumentar el recuento de referencias: la implementaci&amp;oacute;n del rasgo &lt;code&gt;Drop&lt;/code&gt; reduce el recuento de referencias autom&amp;aacute;ticamente cuando un valor &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; sale del alcance.</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">Podemos ver el valor que obtuvimos en la salida de la prueba,lo que nos ayudaría a depurar lo que sucedió en lugar de lo que esperábamos que sucediera.</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">Podemos especificar parte del nombre de una prueba y se ejecutar&amp;aacute; cualquier prueba cuyo nombre coincida con ese valor. Por ejemplo, debido a que dos de los nombres de nuestras pruebas contienen &lt;code&gt;add&lt;/code&gt; , podemos ejecutar esos dos ejecutando &lt;code&gt;cargo test add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">&amp;iexcl;A&amp;uacute;n podemos hacerlo mejor que esto! Dado que todas estas son cadenas, podemos usar &lt;code&gt;From::from&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">Todav&amp;iacute;a podemos ejecutar una funci&amp;oacute;n de prueba de integraci&amp;oacute;n particular especificando el nombre de la funci&amp;oacute;n de prueba como argumento para &lt;code&gt;cargo test&lt;/code&gt; . Para ejecutar todas las pruebas en un archivo de prueba de integraci&amp;oacute;n en particular, use el argumento &lt;code&gt;--test&lt;/code&gt; de &lt;code&gt;cargo test&lt;/code&gt; de carga seguido del nombre del archivo:</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">Podemos dar otro peque&amp;ntilde;o paso para mejorar &lt;code&gt;parse_config&lt;/code&gt; m&amp;aacute;s la funci&amp;oacute;n parse_config . Por el momento, estamos devolviendo una tupla, pero luego inmediatamente dividimos esa tupla en partes individuales nuevamente. Esta es una se&amp;ntilde;al de que quiz&amp;aacute;s a&amp;uacute;n no tengamos la abstracci&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">Podemos usar &lt;code&gt;LineWriter&lt;/code&gt; para escribir una l&amp;iacute;nea a la vez, reduciendo significativamente el n&amp;uacute;mero de escrituras reales en el archivo.</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">Podemos usar una ruta anidada en cualquier nivel de una ruta, lo cual es &amp;uacute;til cuando se combinan dos instrucciones de &lt;code&gt;use&lt;/code&gt; que comparten una subruta. Por ejemplo, el Listado 7-19 muestra dos declaraciones de &lt;code&gt;use&lt;/code&gt; : una que trae &lt;code&gt;std::io&lt;/code&gt; al alcance y otra que trae &lt;code&gt;std::io::Write&lt;/code&gt; al alcance.</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">Podemos usar gen&amp;eacute;ricos para crear definiciones para elementos como firmas de funciones o estructuras, que luego podemos usar con muchos tipos de datos concretos diferentes. Primero veamos c&amp;oacute;mo definir funciones, estructuras, enumeraciones y m&amp;eacute;todos usando gen&amp;eacute;ricos. Luego discutiremos c&amp;oacute;mo los gen&amp;eacute;ricos afectan el rendimiento del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">Podemos escribir pruebas que afirmen, por ejemplo, que cuando pasamos &lt;code&gt;3&lt;/code&gt; a la funci&amp;oacute;n &lt;code&gt;add_two&lt;/code&gt; , el valor devuelto es &lt;code&gt;5&lt;/code&gt; . Podemos ejecutar estas pruebas siempre que hagamos cambios en nuestro c&amp;oacute;digo para asegurarnos de que no haya cambiado ning&amp;uacute;n comportamiento correcto existente.</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">Podemos escribir este c&amp;oacute;digo de una manera m&amp;aacute;s concisa usando m&amp;eacute;todos de adaptador de iterador. Hacerlo tambi&amp;eacute;n nos permite evitar tener un vector de &lt;code&gt;results&lt;/code&gt; intermedios mutable . El estilo de programaci&amp;oacute;n funcional prefiere minimizar la cantidad de estado mutable para hacer el c&amp;oacute;digo m&amp;aacute;s claro. La eliminaci&amp;oacute;n del estado mutable podr&amp;iacute;a permitir una mejora futura para que la b&amp;uacute;squeda se realice en paralelo, porque no tendr&amp;iacute;amos que administrar el acceso simult&amp;aacute;neo al vector de &lt;code&gt;results&lt;/code&gt; . El Listado 13-29 muestra este cambio:</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">No podemos deshabilitar la inserci&amp;oacute;n autom&amp;aacute;tica de &lt;code&gt;drop&lt;/code&gt; cuando un valor sale del alcance, y no podemos llamar al m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; expl&amp;iacute;citamente. Entonces, si necesitamos forzar la limpieza de un valor temprano, podemos usar la funci&amp;oacute;n &lt;code&gt;std::mem::drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">No podemos hacer lo mismo con las funciones; si intentamos con el siguiente ejemplo, nuestro c&amp;oacute;digo no se compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">No podemos implementar esta funci&amp;oacute;n usando solo Rust seguro. Un intento podr&amp;iacute;a parecerse al Listado 19-5, que no se compilar&amp;aacute;. Para simplificar, implementaremos &lt;code&gt;split_at_mut&lt;/code&gt; como una funci&amp;oacute;n en lugar de un m&amp;eacute;todo y solo para segmentos de valores &lt;code&gt;i32&lt;/code&gt; en lugar de un tipo &lt;code&gt;T&lt;/code&gt; gen&amp;eacute;rico .</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">No podemos modificar &lt;code&gt;MockMessenger&lt;/code&gt; para realizar un seguimiento de los mensajes, porque el m&amp;eacute;todo de &lt;code&gt;send&lt;/code&gt; toma una referencia inmutable a &lt;code&gt;self&lt;/code&gt; . Tampoco podemos aceptar la sugerencia del texto de error para usar &lt;code&gt;&amp;amp;mut self&lt;/code&gt; en su lugar, porque entonces la firma del &lt;code&gt;send&lt;/code&gt; no coincidir&amp;iacute;a con la firma en la definici&amp;oacute;n del rasgo de &lt;code&gt;Messenger&lt;/code&gt; (si&amp;eacute;ntase libre de probar y ver qu&amp;eacute; mensaje de error obtiene).</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">No podemos especificar los nombres de m&amp;uacute;ltiples pruebas de esta manera; s&amp;oacute;lo se utilizar&amp;aacute; el primer valor dado a &lt;code&gt;cargo test&lt;/code&gt; . Pero hay una forma de ejecutar varias pruebas.</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">No podemos crear un objeto de tipo &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;amp;Foo&lt;/code&gt; ya que en este caso &lt;code&gt;Self&lt;/code&gt; no tendr&amp;iacute;a &lt;code&gt;Sized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">Elegimos &lt;code&gt;usize&lt;/code&gt; como el tipo de par&amp;aacute;metro de &lt;code&gt;size&lt;/code&gt; , porque sabemos que un n&amp;uacute;mero negativo de hilos no tiene ning&amp;uacute;n sentido. Tambi&amp;eacute;n sabemos que usaremos este 4 como el n&amp;uacute;mero de elementos en una colecci&amp;oacute;n de subprocesos, que es para lo que es el tipo &lt;code&gt;usize&lt;/code&gt; , como se discuti&amp;oacute; en la secci&amp;oacute;n &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Tipos de enteros&amp;rdquo;&lt;/a&gt; del Cap&amp;iacute;tulo 3.</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">Clonamos el &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; en &lt;code&gt;leaf&lt;/code&gt; y lo almacenamos en &lt;code&gt;branch&lt;/code&gt; , lo que significa que el &lt;code&gt;Node&lt;/code&gt; en &lt;code&gt;leaf&lt;/code&gt; ahora tiene dos propietarios: &lt;code&gt;leaf&lt;/code&gt; y &lt;code&gt;branch&lt;/code&gt; . Podemos ir de &lt;code&gt;branch&lt;/code&gt; en &lt;code&gt;leaf&lt;/code&gt; trav&amp;eacute;s de &lt;code&gt;branch.children&lt;/code&gt; , pero no hay forma de ir de &lt;code&gt;leaf&lt;/code&gt; en &lt;code&gt;branch&lt;/code&gt; . La raz&amp;oacute;n es que la &lt;code&gt;leaf&lt;/code&gt; no tiene ninguna referencia a la &lt;code&gt;branch&lt;/code&gt; y no sabe que est&amp;aacute;n relacionados. Queremos que la &lt;code&gt;leaf&lt;/code&gt; sepa que la &lt;code&gt;branch&lt;/code&gt; es su padre. Haremos eso a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">&amp;iexcl;Tambi&amp;eacute;n podr&amp;iacute;amos usar el &lt;code&gt;vec!&lt;/code&gt; macro para hacer un vector de dos enteros o un vector de cinco cortes de cadena. No podr&amp;iacute;amos usar una funci&amp;oacute;n para hacer lo mismo porque no sabr&amp;iacute;amos el n&amp;uacute;mero o tipo de valores por adelantado.</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">Podr&amp;iacute;amos cambiar la definici&amp;oacute;n de &lt;code&gt;Cons&lt;/code&gt; para contener referencias en su lugar, pero luego tendr&amp;iacute;amos que especificar par&amp;aacute;metros de duraci&amp;oacute;n. Al especificar los par&amp;aacute;metros de duraci&amp;oacute;n, estar&amp;iacute;amos especificando que cada elemento de la lista vivir&amp;aacute; al menos tanto como la lista completa. El comprobador de pr&amp;eacute;stamos no nos dejar&amp;iacute;a compilar &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; por ejemplo, porque el valor &lt;code&gt;Nil&lt;/code&gt; temporal se eliminar&amp;iacute;a antes de que &lt;code&gt;a&lt;/code&gt; pudiera hacer referencia a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">¡Podríamos hacer más aquí! Si quieres seguir mejorando este proyecto,aquí tienes algunas ideas:</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">Podr&amp;iacute;amos haber llamado &lt;code&gt;a.clone()&lt;/code&gt; lugar de &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; , pero la convenci&amp;oacute;n de Rust es usar &lt;code&gt;Rc::clone&lt;/code&gt; en este caso. La implementaci&amp;oacute;n de &lt;code&gt;Rc::clone&lt;/code&gt; no hace una copia profunda de todos los datos como hacen las implementaciones de &lt;code&gt;clone&lt;/code&gt; de la mayor&amp;iacute;a de los tipos . La llamada a &lt;code&gt;Rc::clone&lt;/code&gt; solo incrementa el recuento de referencias, lo que no lleva mucho tiempo. Las copias profundas de datos pueden llevar mucho tiempo. Al usar &lt;code&gt;Rc::clone&lt;/code&gt; para el recuento de referencias, podemos distinguir visualmente entre los tipos de clones de copia profunda y los tipos de clones que aumentan el recuento de referencias. Al buscar problemas de rendimiento en el c&amp;oacute;digo, solo debemos considerar los clones de copia profunda y podemos ignorar las llamadas a &lt;code&gt;Rc::clone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">Podr&amp;iacute;amos administrar los datos de &lt;code&gt;String&lt;/code&gt; de varias maneras diferentes, pero la ruta m&amp;aacute;s f&amp;aacute;cil, aunque algo ineficiente, es llamar al m&amp;eacute;todo de &lt;code&gt;clone&lt;/code&gt; en los valores. Esto har&amp;aacute; una copia completa de los datos para que los posea la instancia de &lt;code&gt;Config&lt;/code&gt; , lo que requiere m&amp;aacute;s tiempo y memoria que almacenar una referencia a los datos de la cadena. Sin embargo, clonar los datos tambi&amp;eacute;n hace que nuestro c&amp;oacute;digo sea muy sencillo porque no tenemos que administrar la vida &amp;uacute;til de las referencias; en esta circunstancia, renunciar a un poco de rendimiento para ganar simplicidad es una compensaci&amp;oacute;n que vale la pena.</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">Podr&amp;iacute;amos reestructurar el programa de ejercicios de muchas formas. Primero, intentaremos extraer la llamada duplicada a la funci&amp;oacute;n &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; en una variable, como se muestra en el Listado 13-4.</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">Podr&amp;iacute;amos, por ejemplo, implementar m&amp;eacute;todos solo en instancias de &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; lugar de en instancias de &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; con cualquier tipo gen&amp;eacute;rico. En el Listado 10-10 usamos el tipo concreto &lt;code&gt;f32&lt;/code&gt; , lo que significa que no declaramos ning&amp;uacute;n tipo despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">&amp;iexcl;Cubrimos mucho en este cap&amp;iacute;tulo! Ahora que conoce los par&amp;aacute;metros de tipo gen&amp;eacute;rico, las caracter&amp;iacute;sticas y los l&amp;iacute;mites de las caracter&amp;iacute;sticas, y los par&amp;aacute;metros de vida &amp;uacute;til gen&amp;eacute;ricos, est&amp;aacute; listo para escribir c&amp;oacute;digo sin repetici&amp;oacute;n que funcione en muchas situaciones diferentes. Los par&amp;aacute;metros de tipo gen&amp;eacute;rico le permiten aplicar el c&amp;oacute;digo a diferentes tipos. Los rasgos y los l&amp;iacute;mites de los rasgos garantizan que, aunque los tipos sean gen&amp;eacute;ricos, tendr&amp;aacute;n el comportamiento que necesita el c&amp;oacute;digo. Aprendi&amp;oacute; a usar anotaciones de por vida para asegurarse de que este c&amp;oacute;digo flexible no tenga referencias colgantes. Y todo este an&amp;aacute;lisis ocurre en tiempo de compilaci&amp;oacute;n, lo que no afecta el rendimiento del tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">Creamos una variable de &lt;code&gt;counter&lt;/code&gt; para contener un &lt;code&gt;i32&lt;/code&gt; dentro de un &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; , como hicimos en el Listado 16-12. A continuaci&amp;oacute;n, creamos 10 subprocesos iterando sobre un rango de n&amp;uacute;meros. Usamos &lt;code&gt;thread::spawn&lt;/code&gt; y damos a todos los hilos el mismo cierre, uno que mueve el contador al hilo, adquiere un bloqueo en &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; llamando al m&amp;eacute;todo de &lt;code&gt;lock&lt;/code&gt; , y luego agrega 1 al valor en el mutex. Cuando un hilo termina de ejecutar su cierre, &lt;code&gt;num&lt;/code&gt; saldr&amp;aacute; del alcance y liberar&amp;aacute; el bloqueo para que otro hilo pueda adquirirlo.</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">Creamos un directorio de &lt;em&gt;pruebas&lt;/em&gt; en el nivel superior de nuestro directorio de proyectos, junto a &lt;em&gt;src&lt;/em&gt; . Cargo sabe buscar archivos de prueba de integraci&amp;oacute;n en este directorio. Luego podemos crear tantos archivos de prueba como queramos en este directorio, y Cargo compilar&amp;aacute; cada uno de los archivos como una caja individual.</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">Creamos un nuevo canal usando la funci&amp;oacute;n &lt;code&gt;mpsc::channel&lt;/code&gt; ; &lt;code&gt;mpsc&lt;/code&gt; significa &lt;em&gt;productor m&amp;uacute;ltiple, consumidor &amp;uacute;nico&lt;/em&gt; . En resumen, la forma en que la biblioteca est&amp;aacute;ndar de Rust implementa canales significa que un canal puede tener m&amp;uacute;ltiples extremos de &lt;em&gt;env&amp;iacute;o&lt;/em&gt; que producen valores, pero solo un extremo de &lt;em&gt;recepci&amp;oacute;n&lt;/em&gt; que consume esos valores. Imag&amp;iacute;nese que varios arroyos fluyen juntos en un gran r&amp;iacute;o: todo lo que se env&amp;iacute;a por cualquiera de los arroyos terminar&amp;aacute; en un r&amp;iacute;o al final. Comenzaremos con un solo productor por ahora, pero agregaremos varios productores cuando este ejemplo funcione.</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">Creamos una tupla escribiendo una lista de valores separados por comas entre par&amp;eacute;ntesis. Cada posici&amp;oacute;n en la tupla tiene un tipo, y los tipos de los diferentes valores en la tupla no tienen que ser los mismos. Hemos agregado anotaciones de tipo opcionales en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Creamos un valor que es una instancia de &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; y lo almacenamos en una variable denominada &lt;code&gt;value&lt;/code&gt; para que podamos acceder a &amp;eacute;l directamente m&amp;aacute;s tarde. Entonces se crea una &lt;code&gt;List&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; con un &lt;code&gt;Cons&lt;/code&gt; variante que tiene &lt;code&gt;value&lt;/code&gt; . Necesitamos clonar el &lt;code&gt;value&lt;/code&gt; para que tanto &lt;code&gt;a&lt;/code&gt; como el &lt;code&gt;value&lt;/code&gt; tengan la propiedad del valor &lt;code&gt;5&lt;/code&gt; interno en lugar de transferir la propiedad del &lt;code&gt;value&lt;/code&gt; a &lt;code&gt;a&lt;/code&gt; o tener &lt;code&gt;a&lt;/code&gt; pr&amp;eacute;stamo del &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">Creamos una variable &lt;code&gt;one_borrow&lt;/code&gt; para el puntero inteligente &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; devuelto desde &lt;code&gt;borrow_mut&lt;/code&gt; . Luego creamos otro pr&amp;eacute;stamo mutable de la misma manera en la variable &lt;code&gt;two_borrow&lt;/code&gt; . Esto crea dos referencias mutables en el mismo &amp;aacute;mbito, lo cual no est&amp;aacute; permitido. Cuando ejecutamos las pruebas para nuestra biblioteca, el c&amp;oacute;digo del Listado 15-23 se compilar&amp;aacute; sin errores, pero la prueba fallar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">Creamos una variable llamada &lt;code&gt;guess&lt;/code&gt; . Pero espera, &amp;iquest;el programa no tiene ya una variable llamada &lt;code&gt;guess&lt;/code&gt; ? Lo hace, pero Rust nos permite &lt;em&gt;sombrear&lt;/em&gt; el valor anterior de &lt;code&gt;guess&lt;/code&gt; con uno nuevo. Esta funci&amp;oacute;n se utiliza a menudo en situaciones en las que desea convertir un valor de un tipo a otro. El sombreado nos permite reutilizar el nombre de la variable de &lt;code&gt;guess&lt;/code&gt; lugar de obligarnos a crear dos variables &amp;uacute;nicas, como &lt;code&gt;guess_str&lt;/code&gt; y &lt;code&gt;guess&lt;/code&gt; , por ejemplo. (El Cap&amp;iacute;tulo 3 cubre el sombreado con m&amp;aacute;s detalle).</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Creamos una instancia &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; contiene un valor &lt;code&gt;List&lt;/code&gt; en la variable &lt;code&gt;a&lt;/code&gt; con una lista inicial de &lt;code&gt;5, Nil&lt;/code&gt; . Luego creamos una instancia &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; contiene otro valor &lt;code&gt;List&lt;/code&gt; en la variable &lt;code&gt;b&lt;/code&gt; que contiene el valor 10 y apunta a la lista en &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">Definimos un m&amp;oacute;dulo comenzando con la palabra clave &lt;code&gt;mod&lt;/code&gt; y luego especificamos el nombre del m&amp;oacute;dulo (en este caso, &lt;code&gt;front_of_house&lt;/code&gt; ) y colocamos llaves alrededor del cuerpo del m&amp;oacute;dulo. Dentro de los m&amp;oacute;dulos, podemos tener otros m&amp;oacute;dulos, como en este caso con los m&amp;oacute;dulos de &lt;code&gt;hosting&lt;/code&gt; y &lt;code&gt;serving&lt;/code&gt; . Los m&amp;oacute;dulos tambi&amp;eacute;n pueden contener definiciones para otros elementos, como estructuras, enumeraciones, constantes, rasgos o, como en el Listado 7-1, funciones.</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">Definimos una estructura llamada &lt;code&gt;MyBox&lt;/code&gt; y declaramos un par&amp;aacute;metro gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; , porque queremos que nuestro tipo contenga valores de cualquier tipo. El &lt;code&gt;MyBox&lt;/code&gt; tipo es una struct tupla con un elemento de tipo &lt;code&gt;T&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;MyBox::new&lt;/code&gt; toma un par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; y devuelve una instancia de &lt;code&gt;MyBox&lt;/code&gt; que contiene el valor pasado.</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">Definimos la variable &lt;code&gt;b&lt;/code&gt; para que tenga el valor de una &lt;code&gt;Box&lt;/code&gt; que apunta al valor &lt;code&gt;5&lt;/code&gt; , que se asigna en el mont&amp;oacute;n. Este programa imprimir&amp;aacute; &lt;code&gt;b = 5&lt;/code&gt; ; en este caso, podemos acceder a los datos en el cuadro de manera similar a como lo har&amp;iacute;amos si estos datos estuvieran en la pila. Al igual que cualquier valor de propiedad, cuando un cuadro sale del alcance, como lo hace &lt;code&gt;b&lt;/code&gt; al final de &lt;code&gt;main&lt;/code&gt; , se desasignar&amp;aacute;. La desasignaci&amp;oacute;n ocurre para la caja (almacenada en la pila) y los datos a los que apunta (almacenados en la pila).</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">&amp;iexcl;Lo hicimos! Contamos de 0 a 10, lo que puede no parecer muy impresionante, pero nos ense&amp;ntilde;&amp;oacute; mucho sobre &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; y la seguridad de subprocesos. Tambi&amp;eacute;n puede usar la estructura de este programa para realizar operaciones m&amp;aacute;s complicadas que simplemente incrementar un contador. Con esta estrategia, puede dividir un c&amp;aacute;lculo en partes independientes, dividir esas partes en subprocesos y luego usar un &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; para que cada subproceso actualice el resultado final con su parte.</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">No manejamos el caso &lt;code&gt;None&lt;/code&gt; , por lo que este c&amp;oacute;digo provocar&amp;aacute; un error. Afortunadamente, es un error que Rust sabe atrapar. Si intentamos compilar este c&amp;oacute;digo, obtendremos este error:</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">Discutimos c&amp;oacute;mo controlar la encapsulaci&amp;oacute;n en el Cap&amp;iacute;tulo 7: podemos usar la palabra clave &lt;code&gt;pub&lt;/code&gt; para decidir qu&amp;eacute; m&amp;oacute;dulos, tipos, funciones y m&amp;eacute;todos en nuestro c&amp;oacute;digo deben ser p&amp;uacute;blicos y, por defecto, todo lo dem&amp;aacute;s es privado. Por ejemplo, podemos definir una estructura &lt;code&gt;AveragedCollection&lt;/code&gt; que tiene un campo que contiene un vector de valores &lt;code&gt;i32&lt;/code&gt; . La estructura tambi&amp;eacute;n puede tener un campo que contenga el promedio de los valores en el vector, lo que significa que el promedio no tiene que calcularse a pedido cuando alguien lo necesite. En otras palabras, &lt;code&gt;AveragedCollection&lt;/code&gt; almacenar&amp;aacute; en cach&amp;eacute; el promedio calculado para nosotros. El Listado 17-1 tiene la definici&amp;oacute;n de la estructura &lt;code&gt;AveragedCollection&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">Hacemos esto agregando otro atributo, &lt;code&gt;should_panic&lt;/code&gt; , a nuestra funci&amp;oacute;n de prueba. Este atributo hace un pase de prueba si el c&amp;oacute;digo dentro de la funci&amp;oacute;n entra en p&amp;aacute;nico; la prueba fallar&amp;aacute; si el c&amp;oacute;digo dentro de la funci&amp;oacute;n no entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">No recibimos un mensaje muy &amp;uacute;til en este caso, pero cuando miramos la funci&amp;oacute;n de prueba, vemos que est&amp;aacute; anotado con &lt;code&gt;#[should_panic]&lt;/code&gt; . La falla que obtuvimos significa que el c&amp;oacute;digo en la funci&amp;oacute;n de prueba no caus&amp;oacute; p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">No necesitamos anotar ning&amp;uacute;n c&amp;oacute;digo en &lt;em&gt;tests / integration_test.rs&lt;/em&gt; con &lt;code&gt;#[cfg(test)]&lt;/code&gt; . Cargo trata el directorio de &lt;code&gt;tests&lt;/code&gt; especial y compila archivos en este directorio solo cuando ejecutamos &lt;code&gt;cargo test&lt;/code&gt; . Ejecute la &lt;code&gt;cargo test&lt;/code&gt; ahora:</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">No somos due&amp;ntilde;os de la memoria en esta ubicaci&amp;oacute;n arbitraria, y no hay garant&amp;iacute;a de que el segmento que crea este c&amp;oacute;digo contenga valores &lt;code&gt;i32&lt;/code&gt; v&amp;aacute;lidos . Intentar utilizar el &lt;code&gt;slice&lt;/code&gt; como si fuera un segmento v&amp;aacute;lido da como resultado un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">No solo necesitamos crear una tabla de todas las implementaciones de todos los m&amp;eacute;todos de &lt;code&gt;Trait&lt;/code&gt; , necesitamos crear dicha tabla, para cada tipo diferente alimentado a &lt;code&gt;foo()&lt;/code&gt; . En este caso, resulta ser (10 tipos que implementan &lt;code&gt;Trait&lt;/code&gt; ) * (3 tipos que se alimentan a &lt;code&gt;foo()&lt;/code&gt; ) = 30 implementaciones.</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">Terminamos con una salida diferente:</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">&lt;code&gt;deref&lt;/code&gt; el cuerpo del m&amp;eacute;todo deref con &lt;code&gt;&amp;amp;self.0&lt;/code&gt; para que &lt;code&gt;deref&lt;/code&gt; devuelva una referencia al valor al que queremos acceder con el operador &lt;code&gt;*&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; Listado 15-9 que llama a &lt;code&gt;*&lt;/code&gt; en el valor &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; ahora se compila y las aserciones pasan.</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">Primero cubrimos los rasgos en la secci&amp;oacute;n &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&quot;Rasgos: Definici&amp;oacute;n del comportamiento compartido&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 10, pero al igual que con las vidas, no discutimos los detalles m&amp;aacute;s avanzados. Ahora que sabe m&amp;aacute;s sobre Rust, podemos entrar en el meollo de la cuesti&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">Arreglamos una serie de pequeños errores y una redacción imprecisa a lo largo del libro.¡Gracias a los lectores que los reportaron!</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">Obtenemos una instancia de estructura &lt;code&gt;Ident&lt;/code&gt; que contiene el nombre (identificador) del tipo anotado usando &lt;code&gt;ast.ident&lt;/code&gt; . La estructura del Listado 19-32 muestra que cuando ejecutamos la funci&amp;oacute;n &lt;code&gt;impl_hello_macro&lt;/code&gt; en el c&amp;oacute;digo del Listado 19-30, la &lt;code&gt;ident&lt;/code&gt; ificaci&amp;oacute;n que obtenemos tendr&amp;aacute; el campo &lt;code&gt;ident&lt;/code&gt; con un valor de &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; . Por lo tanto, la variable de &lt;code&gt;name&lt;/code&gt; en el Listado 19-33 contendr&amp;aacute; una instancia de estructura &lt;code&gt;Ident&lt;/code&gt; que, cuando se imprima, ser&amp;aacute; la cadena &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; , el nombre de la estructura en el Listado 19-30.</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">Recibimos un error que dice que se requiere &lt;code&gt;Display&lt;/code&gt; pero no est&amp;aacute; implementado:</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">Tenemos un error:</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">Obtenemos el índice para el final de la palabra de la misma manera que lo hicimos en la lista 4-7,buscando la primera ocurrencia de un espacio.Cuando encontramos un espacio,devolvemos un trozo de cadena usando el comienzo de la cadena y el índice del espacio como índices de comienzo y final.</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">Le damos a &lt;code&gt;Post&lt;/code&gt; un m&amp;eacute;todo p&amp;uacute;blico llamado &lt;code&gt;request_review&lt;/code&gt; que tomar&amp;aacute; una referencia mutable a &lt;code&gt;self&lt;/code&gt; . Luego llamamos a un m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; interno en el estado actual de &lt;code&gt;Post&lt;/code&gt; , y este segundo m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; consume el estado actual y devuelve un nuevo estado.</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">Tenemos un rasgo y su función.En este punto,nuestro usuario de la caja podría implementar el rasgo para lograr la funcionalidad deseada,así:</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">Tenemos otro patr&amp;oacute;n &amp;uacute;til que explota un detalle de implementaci&amp;oacute;n de estructuras de tupla y variantes de enumeraci&amp;oacute;n de estructura de tupla. Estos tipos usan &lt;code&gt;()&lt;/code&gt; como sintaxis de inicializador, que parece una llamada a funci&amp;oacute;n. Los inicializadores se implementan realmente como funciones que devuelven una instancia construida a partir de sus argumentos. Podemos usar estas funciones de inicializador como punteros de funci&amp;oacute;n que implementan los rasgos de cierre, lo que significa que podemos especificar las funciones de inicializador como argumentos para m&amp;eacute;todos que toman cierres, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">Tenemos la mayor parte del juego funcionando ahora, pero el usuario solo puede hacer una suposici&amp;oacute;n. &amp;iexcl;Cambiemos eso agregando un bucle!</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">Tenemos dos estructuras, &lt;code&gt;Millimeters&lt;/code&gt; y &lt;code&gt;Meters&lt;/code&gt; , con valores en diferentes unidades. Queremos agregar valores en mil&amp;iacute;metros a valores en metros y que la implementaci&amp;oacute;n de &lt;code&gt;Add&lt;/code&gt; haga la conversi&amp;oacute;n correctamente. Podemos implementar &lt;code&gt;Add&lt;/code&gt; por &lt;code&gt;Millimeters&lt;/code&gt; con &lt;code&gt;Meters&lt;/code&gt; como el &lt;code&gt;RHS&lt;/code&gt; , como se muestra en el Listado 19-15.</target>
        </trans-unit>
        <trans-unit id="d8a3dea7c52bc3f0b1a5887645fbfc3ac18bf504" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;Rhs&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160ceff2ab6cdd2b56a8bbd9402294ab3fbd2021" translate="yes" xml:space="preserve">
          <source>We have written an &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;async book&lt;/a&gt; detailing async/await and trade-offs compared to using threads.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
